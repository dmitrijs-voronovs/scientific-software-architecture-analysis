id,quality_attribute,keyword,matched_word,match_idx,sentence,source,author,repo,version,wiki,url
https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877480974:636,Integrability,integrat,integrate,636,"Hmm. I think given general `u, v` we need to solve an elliptic equation to find `psi`, eg `lap(psi) = dx v - dy u`. Then the geostrophic buoyancy field is `b = f * dz(psi)`. For some boundary conditions or assumptions of homogeneity, we can possibly simplify this procedure. One could in principle use the conjugate gradient solver to write a fully general utility, though. Hopefully this task will be taken up once the hydrostatic model is operational. Some care must be taken with the geostrophic mode / computation of the geostrophic free surface displacement for the hydrostatic model. Or, given a geostrophic buoyancy field we can integrate in `z` (eg summation of `b * dz`). This would be the intent of `IntegratedField`, but nobody has implemented that yet. Absent those techniques I think the best method for idealized problems is to use a geostrophic streamfunction. This is illustrated by the Eady turbulence example:. https://github.com/CliMA/Oceananigans.jl/blob/0153dec98e58b7819ae8e1d57516fc7994694762/examples/eady_turbulence.jl#L38-L41. https://github.com/CliMA/Oceananigans.jl/blob/0153dec98e58b7819ae8e1d57516fc7994694762/examples/eady_turbulence.jl#L151-L152. It's also used in a number of validation cases, but those aren't always useful for general audiences.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877480974
https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877480974:710,Integrability,Integrat,IntegratedField,710,"Hmm. I think given general `u, v` we need to solve an elliptic equation to find `psi`, eg `lap(psi) = dx v - dy u`. Then the geostrophic buoyancy field is `b = f * dz(psi)`. For some boundary conditions or assumptions of homogeneity, we can possibly simplify this procedure. One could in principle use the conjugate gradient solver to write a fully general utility, though. Hopefully this task will be taken up once the hydrostatic model is operational. Some care must be taken with the geostrophic mode / computation of the geostrophic free surface displacement for the hydrostatic model. Or, given a geostrophic buoyancy field we can integrate in `z` (eg summation of `b * dz`). This would be the intent of `IntegratedField`, but nobody has implemented that yet. Absent those techniques I think the best method for idealized problems is to use a geostrophic streamfunction. This is illustrated by the Eady turbulence example:. https://github.com/CliMA/Oceananigans.jl/blob/0153dec98e58b7819ae8e1d57516fc7994694762/examples/eady_turbulence.jl#L38-L41. https://github.com/CliMA/Oceananigans.jl/blob/0153dec98e58b7819ae8e1d57516fc7994694762/examples/eady_turbulence.jl#L151-L152. It's also used in a number of validation cases, but those aren't always useful for general audiences.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877480974
https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877480974:1209,Security,validat,validation,1209,"Hmm. I think given general `u, v` we need to solve an elliptic equation to find `psi`, eg `lap(psi) = dx v - dy u`. Then the geostrophic buoyancy field is `b = f * dz(psi)`. For some boundary conditions or assumptions of homogeneity, we can possibly simplify this procedure. One could in principle use the conjugate gradient solver to write a fully general utility, though. Hopefully this task will be taken up once the hydrostatic model is operational. Some care must be taken with the geostrophic mode / computation of the geostrophic free surface displacement for the hydrostatic model. Or, given a geostrophic buoyancy field we can integrate in `z` (eg summation of `b * dz`). This would be the intent of `IntegratedField`, but nobody has implemented that yet. Absent those techniques I think the best method for idealized problems is to use a geostrophic streamfunction. This is illustrated by the Eady turbulence example:. https://github.com/CliMA/Oceananigans.jl/blob/0153dec98e58b7819ae8e1d57516fc7994694762/examples/eady_turbulence.jl#L38-L41. https://github.com/CliMA/Oceananigans.jl/blob/0153dec98e58b7819ae8e1d57516fc7994694762/examples/eady_turbulence.jl#L151-L152. It's also used in a number of validation cases, but those aren't always useful for general audiences.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877480974
https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877480974:250,Usability,simpl,simplify,250,"Hmm. I think given general `u, v` we need to solve an elliptic equation to find `psi`, eg `lap(psi) = dx v - dy u`. Then the geostrophic buoyancy field is `b = f * dz(psi)`. For some boundary conditions or assumptions of homogeneity, we can possibly simplify this procedure. One could in principle use the conjugate gradient solver to write a fully general utility, though. Hopefully this task will be taken up once the hydrostatic model is operational. Some care must be taken with the geostrophic mode / computation of the geostrophic free surface displacement for the hydrostatic model. Or, given a geostrophic buoyancy field we can integrate in `z` (eg summation of `b * dz`). This would be the intent of `IntegratedField`, but nobody has implemented that yet. Absent those techniques I think the best method for idealized problems is to use a geostrophic streamfunction. This is illustrated by the Eady turbulence example:. https://github.com/CliMA/Oceananigans.jl/blob/0153dec98e58b7819ae8e1d57516fc7994694762/examples/eady_turbulence.jl#L38-L41. https://github.com/CliMA/Oceananigans.jl/blob/0153dec98e58b7819ae8e1d57516fc7994694762/examples/eady_turbulence.jl#L151-L152. It's also used in a number of validation cases, but those aren't always useful for general audiences.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877480974
https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877483764:48,Deployability,integrat,integrate,48,"> Or, given a geostrophic buoyancy field we can integrate in z (eg summation of b * dz). This would be the intent of IntegratedField, but nobody has implemented that yet. That was more along the lines of what I was thinking. Basically showing users how to create a `u`, find out what `b` is, and then indicate if it's best to use that as `BackgroundField`, or an `Array` or something. But it seems like `IntegratedField` needs to be in place for something as simple as what I'm envisioning?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877483764
https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877483764:117,Deployability,Integrat,IntegratedField,117,"> Or, given a geostrophic buoyancy field we can integrate in z (eg summation of b * dz). This would be the intent of IntegratedField, but nobody has implemented that yet. That was more along the lines of what I was thinking. Basically showing users how to create a `u`, find out what `b` is, and then indicate if it's best to use that as `BackgroundField`, or an `Array` or something. But it seems like `IntegratedField` needs to be in place for something as simple as what I'm envisioning?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877483764
https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877483764:404,Deployability,Integrat,IntegratedField,404,"> Or, given a geostrophic buoyancy field we can integrate in z (eg summation of b * dz). This would be the intent of IntegratedField, but nobody has implemented that yet. That was more along the lines of what I was thinking. Basically showing users how to create a `u`, find out what `b` is, and then indicate if it's best to use that as `BackgroundField`, or an `Array` or something. But it seems like `IntegratedField` needs to be in place for something as simple as what I'm envisioning?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877483764
https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877483764:48,Integrability,integrat,integrate,48,"> Or, given a geostrophic buoyancy field we can integrate in z (eg summation of b * dz). This would be the intent of IntegratedField, but nobody has implemented that yet. That was more along the lines of what I was thinking. Basically showing users how to create a `u`, find out what `b` is, and then indicate if it's best to use that as `BackgroundField`, or an `Array` or something. But it seems like `IntegratedField` needs to be in place for something as simple as what I'm envisioning?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877483764
https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877483764:117,Integrability,Integrat,IntegratedField,117,"> Or, given a geostrophic buoyancy field we can integrate in z (eg summation of b * dz). This would be the intent of IntegratedField, but nobody has implemented that yet. That was more along the lines of what I was thinking. Basically showing users how to create a `u`, find out what `b` is, and then indicate if it's best to use that as `BackgroundField`, or an `Array` or something. But it seems like `IntegratedField` needs to be in place for something as simple as what I'm envisioning?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877483764
https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877483764:404,Integrability,Integrat,IntegratedField,404,"> Or, given a geostrophic buoyancy field we can integrate in z (eg summation of b * dz). This would be the intent of IntegratedField, but nobody has implemented that yet. That was more along the lines of what I was thinking. Basically showing users how to create a `u`, find out what `b` is, and then indicate if it's best to use that as `BackgroundField`, or an `Array` or something. But it seems like `IntegratedField` needs to be in place for something as simple as what I'm envisioning?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877483764
https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877483764:459,Usability,simpl,simple,459,"> Or, given a geostrophic buoyancy field we can integrate in z (eg summation of b * dz). This would be the intent of IntegratedField, but nobody has implemented that yet. That was more along the lines of what I was thinking. Basically showing users how to create a `u`, find out what `b` is, and then indicate if it's best to use that as `BackgroundField`, or an `Array` or something. But it seems like `IntegratedField` needs to be in place for something as simple as what I'm envisioning?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877483764
https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877561795:50,Deployability,integrat,integrate,50,"> > Or, given a geostrophic buoyancy field we can integrate in z (eg summation of b * dz). This would be the intent of IntegratedField, but nobody has implemented that yet.; > ; > That was more along the lines of what I was thinking. Basically showing users how to create a `u`, find out what `b` is, and then indicate if it's best to use that as `BackgroundField`, or an `Array` or something.; > ; > But it seems like `IntegratedField` needs to be in place for something as simple as what I'm envisioning?. Just to clarify, the quoted example suggests integrating `b` to find `psi`. If `u` is a function of `y` only I think we can integrate the relation `dy(psi) = u` to find `psi`. If the geostrophic streamfunction is a function of `x, y` then I think solving an elliptic problem is required, probably?. To summarize:. * To obtain `psi(x, y, z)` from `b(x, y, z)`, we integrate the relation `b = f * dz(psi)`. `IntegratedField` is useful.; * To obtain `psi(x, y, z)` from from `u(x, y, z)`, `v(x, y, z)` I _think_ (might be worth thinking about this more) we solve the horizontal elliptic problem `hlap(psi) = dx(v) - dy(u)` at every vertical level.; * To obtain a 2D `psi(y, z)` (for example), we might be able to integrate `dy(psi) = u`. These techniques could be important when initializing from data, perhaps. I'm not sure. For example, if a 3D distribution of `T, S` were obtained from data without knowledge of the velocity field, it might make sense to initialize the problem with a geostrophic velocity field. It'd be great to have utilities for all of these cases eventually. For idealized work I think its better to specify the streamfunction `psi`. This method is demonstrated by the Eady turbulence example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877561795
https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877561795:119,Deployability,Integrat,IntegratedField,119,"> > Or, given a geostrophic buoyancy field we can integrate in z (eg summation of b * dz). This would be the intent of IntegratedField, but nobody has implemented that yet.; > ; > That was more along the lines of what I was thinking. Basically showing users how to create a `u`, find out what `b` is, and then indicate if it's best to use that as `BackgroundField`, or an `Array` or something.; > ; > But it seems like `IntegratedField` needs to be in place for something as simple as what I'm envisioning?. Just to clarify, the quoted example suggests integrating `b` to find `psi`. If `u` is a function of `y` only I think we can integrate the relation `dy(psi) = u` to find `psi`. If the geostrophic streamfunction is a function of `x, y` then I think solving an elliptic problem is required, probably?. To summarize:. * To obtain `psi(x, y, z)` from `b(x, y, z)`, we integrate the relation `b = f * dz(psi)`. `IntegratedField` is useful.; * To obtain `psi(x, y, z)` from from `u(x, y, z)`, `v(x, y, z)` I _think_ (might be worth thinking about this more) we solve the horizontal elliptic problem `hlap(psi) = dx(v) - dy(u)` at every vertical level.; * To obtain a 2D `psi(y, z)` (for example), we might be able to integrate `dy(psi) = u`. These techniques could be important when initializing from data, perhaps. I'm not sure. For example, if a 3D distribution of `T, S` were obtained from data without knowledge of the velocity field, it might make sense to initialize the problem with a geostrophic velocity field. It'd be great to have utilities for all of these cases eventually. For idealized work I think its better to specify the streamfunction `psi`. This method is demonstrated by the Eady turbulence example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877561795
https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877561795:420,Deployability,Integrat,IntegratedField,420,"> > Or, given a geostrophic buoyancy field we can integrate in z (eg summation of b * dz). This would be the intent of IntegratedField, but nobody has implemented that yet.; > ; > That was more along the lines of what I was thinking. Basically showing users how to create a `u`, find out what `b` is, and then indicate if it's best to use that as `BackgroundField`, or an `Array` or something.; > ; > But it seems like `IntegratedField` needs to be in place for something as simple as what I'm envisioning?. Just to clarify, the quoted example suggests integrating `b` to find `psi`. If `u` is a function of `y` only I think we can integrate the relation `dy(psi) = u` to find `psi`. If the geostrophic streamfunction is a function of `x, y` then I think solving an elliptic problem is required, probably?. To summarize:. * To obtain `psi(x, y, z)` from `b(x, y, z)`, we integrate the relation `b = f * dz(psi)`. `IntegratedField` is useful.; * To obtain `psi(x, y, z)` from from `u(x, y, z)`, `v(x, y, z)` I _think_ (might be worth thinking about this more) we solve the horizontal elliptic problem `hlap(psi) = dx(v) - dy(u)` at every vertical level.; * To obtain a 2D `psi(y, z)` (for example), we might be able to integrate `dy(psi) = u`. These techniques could be important when initializing from data, perhaps. I'm not sure. For example, if a 3D distribution of `T, S` were obtained from data without knowledge of the velocity field, it might make sense to initialize the problem with a geostrophic velocity field. It'd be great to have utilities for all of these cases eventually. For idealized work I think its better to specify the streamfunction `psi`. This method is demonstrated by the Eady turbulence example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877561795
https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877561795:553,Deployability,integrat,integrating,553,"> > Or, given a geostrophic buoyancy field we can integrate in z (eg summation of b * dz). This would be the intent of IntegratedField, but nobody has implemented that yet.; > ; > That was more along the lines of what I was thinking. Basically showing users how to create a `u`, find out what `b` is, and then indicate if it's best to use that as `BackgroundField`, or an `Array` or something.; > ; > But it seems like `IntegratedField` needs to be in place for something as simple as what I'm envisioning?. Just to clarify, the quoted example suggests integrating `b` to find `psi`. If `u` is a function of `y` only I think we can integrate the relation `dy(psi) = u` to find `psi`. If the geostrophic streamfunction is a function of `x, y` then I think solving an elliptic problem is required, probably?. To summarize:. * To obtain `psi(x, y, z)` from `b(x, y, z)`, we integrate the relation `b = f * dz(psi)`. `IntegratedField` is useful.; * To obtain `psi(x, y, z)` from from `u(x, y, z)`, `v(x, y, z)` I _think_ (might be worth thinking about this more) we solve the horizontal elliptic problem `hlap(psi) = dx(v) - dy(u)` at every vertical level.; * To obtain a 2D `psi(y, z)` (for example), we might be able to integrate `dy(psi) = u`. These techniques could be important when initializing from data, perhaps. I'm not sure. For example, if a 3D distribution of `T, S` were obtained from data without knowledge of the velocity field, it might make sense to initialize the problem with a geostrophic velocity field. It'd be great to have utilities for all of these cases eventually. For idealized work I think its better to specify the streamfunction `psi`. This method is demonstrated by the Eady turbulence example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877561795
https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877561795:632,Deployability,integrat,integrate,632,"> > Or, given a geostrophic buoyancy field we can integrate in z (eg summation of b * dz). This would be the intent of IntegratedField, but nobody has implemented that yet.; > ; > That was more along the lines of what I was thinking. Basically showing users how to create a `u`, find out what `b` is, and then indicate if it's best to use that as `BackgroundField`, or an `Array` or something.; > ; > But it seems like `IntegratedField` needs to be in place for something as simple as what I'm envisioning?. Just to clarify, the quoted example suggests integrating `b` to find `psi`. If `u` is a function of `y` only I think we can integrate the relation `dy(psi) = u` to find `psi`. If the geostrophic streamfunction is a function of `x, y` then I think solving an elliptic problem is required, probably?. To summarize:. * To obtain `psi(x, y, z)` from `b(x, y, z)`, we integrate the relation `b = f * dz(psi)`. `IntegratedField` is useful.; * To obtain `psi(x, y, z)` from from `u(x, y, z)`, `v(x, y, z)` I _think_ (might be worth thinking about this more) we solve the horizontal elliptic problem `hlap(psi) = dx(v) - dy(u)` at every vertical level.; * To obtain a 2D `psi(y, z)` (for example), we might be able to integrate `dy(psi) = u`. These techniques could be important when initializing from data, perhaps. I'm not sure. For example, if a 3D distribution of `T, S` were obtained from data without knowledge of the velocity field, it might make sense to initialize the problem with a geostrophic velocity field. It'd be great to have utilities for all of these cases eventually. For idealized work I think its better to specify the streamfunction `psi`. This method is demonstrated by the Eady turbulence example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877561795
https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877561795:871,Deployability,integrat,integrate,871,"> > Or, given a geostrophic buoyancy field we can integrate in z (eg summation of b * dz). This would be the intent of IntegratedField, but nobody has implemented that yet.; > ; > That was more along the lines of what I was thinking. Basically showing users how to create a `u`, find out what `b` is, and then indicate if it's best to use that as `BackgroundField`, or an `Array` or something.; > ; > But it seems like `IntegratedField` needs to be in place for something as simple as what I'm envisioning?. Just to clarify, the quoted example suggests integrating `b` to find `psi`. If `u` is a function of `y` only I think we can integrate the relation `dy(psi) = u` to find `psi`. If the geostrophic streamfunction is a function of `x, y` then I think solving an elliptic problem is required, probably?. To summarize:. * To obtain `psi(x, y, z)` from `b(x, y, z)`, we integrate the relation `b = f * dz(psi)`. `IntegratedField` is useful.; * To obtain `psi(x, y, z)` from from `u(x, y, z)`, `v(x, y, z)` I _think_ (might be worth thinking about this more) we solve the horizontal elliptic problem `hlap(psi) = dx(v) - dy(u)` at every vertical level.; * To obtain a 2D `psi(y, z)` (for example), we might be able to integrate `dy(psi) = u`. These techniques could be important when initializing from data, perhaps. I'm not sure. For example, if a 3D distribution of `T, S` were obtained from data without knowledge of the velocity field, it might make sense to initialize the problem with a geostrophic velocity field. It'd be great to have utilities for all of these cases eventually. For idealized work I think its better to specify the streamfunction `psi`. This method is demonstrated by the Eady turbulence example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877561795
https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877561795:914,Deployability,Integrat,IntegratedField,914,"> > Or, given a geostrophic buoyancy field we can integrate in z (eg summation of b * dz). This would be the intent of IntegratedField, but nobody has implemented that yet.; > ; > That was more along the lines of what I was thinking. Basically showing users how to create a `u`, find out what `b` is, and then indicate if it's best to use that as `BackgroundField`, or an `Array` or something.; > ; > But it seems like `IntegratedField` needs to be in place for something as simple as what I'm envisioning?. Just to clarify, the quoted example suggests integrating `b` to find `psi`. If `u` is a function of `y` only I think we can integrate the relation `dy(psi) = u` to find `psi`. If the geostrophic streamfunction is a function of `x, y` then I think solving an elliptic problem is required, probably?. To summarize:. * To obtain `psi(x, y, z)` from `b(x, y, z)`, we integrate the relation `b = f * dz(psi)`. `IntegratedField` is useful.; * To obtain `psi(x, y, z)` from from `u(x, y, z)`, `v(x, y, z)` I _think_ (might be worth thinking about this more) we solve the horizontal elliptic problem `hlap(psi) = dx(v) - dy(u)` at every vertical level.; * To obtain a 2D `psi(y, z)` (for example), we might be able to integrate `dy(psi) = u`. These techniques could be important when initializing from data, perhaps. I'm not sure. For example, if a 3D distribution of `T, S` were obtained from data without knowledge of the velocity field, it might make sense to initialize the problem with a geostrophic velocity field. It'd be great to have utilities for all of these cases eventually. For idealized work I think its better to specify the streamfunction `psi`. This method is demonstrated by the Eady turbulence example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877561795
https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877561795:1218,Deployability,integrat,integrate,1218,"> > Or, given a geostrophic buoyancy field we can integrate in z (eg summation of b * dz). This would be the intent of IntegratedField, but nobody has implemented that yet.; > ; > That was more along the lines of what I was thinking. Basically showing users how to create a `u`, find out what `b` is, and then indicate if it's best to use that as `BackgroundField`, or an `Array` or something.; > ; > But it seems like `IntegratedField` needs to be in place for something as simple as what I'm envisioning?. Just to clarify, the quoted example suggests integrating `b` to find `psi`. If `u` is a function of `y` only I think we can integrate the relation `dy(psi) = u` to find `psi`. If the geostrophic streamfunction is a function of `x, y` then I think solving an elliptic problem is required, probably?. To summarize:. * To obtain `psi(x, y, z)` from `b(x, y, z)`, we integrate the relation `b = f * dz(psi)`. `IntegratedField` is useful.; * To obtain `psi(x, y, z)` from from `u(x, y, z)`, `v(x, y, z)` I _think_ (might be worth thinking about this more) we solve the horizontal elliptic problem `hlap(psi) = dx(v) - dy(u)` at every vertical level.; * To obtain a 2D `psi(y, z)` (for example), we might be able to integrate `dy(psi) = u`. These techniques could be important when initializing from data, perhaps. I'm not sure. For example, if a 3D distribution of `T, S` were obtained from data without knowledge of the velocity field, it might make sense to initialize the problem with a geostrophic velocity field. It'd be great to have utilities for all of these cases eventually. For idealized work I think its better to specify the streamfunction `psi`. This method is demonstrated by the Eady turbulence example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877561795
https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877561795:50,Integrability,integrat,integrate,50,"> > Or, given a geostrophic buoyancy field we can integrate in z (eg summation of b * dz). This would be the intent of IntegratedField, but nobody has implemented that yet.; > ; > That was more along the lines of what I was thinking. Basically showing users how to create a `u`, find out what `b` is, and then indicate if it's best to use that as `BackgroundField`, or an `Array` or something.; > ; > But it seems like `IntegratedField` needs to be in place for something as simple as what I'm envisioning?. Just to clarify, the quoted example suggests integrating `b` to find `psi`. If `u` is a function of `y` only I think we can integrate the relation `dy(psi) = u` to find `psi`. If the geostrophic streamfunction is a function of `x, y` then I think solving an elliptic problem is required, probably?. To summarize:. * To obtain `psi(x, y, z)` from `b(x, y, z)`, we integrate the relation `b = f * dz(psi)`. `IntegratedField` is useful.; * To obtain `psi(x, y, z)` from from `u(x, y, z)`, `v(x, y, z)` I _think_ (might be worth thinking about this more) we solve the horizontal elliptic problem `hlap(psi) = dx(v) - dy(u)` at every vertical level.; * To obtain a 2D `psi(y, z)` (for example), we might be able to integrate `dy(psi) = u`. These techniques could be important when initializing from data, perhaps. I'm not sure. For example, if a 3D distribution of `T, S` were obtained from data without knowledge of the velocity field, it might make sense to initialize the problem with a geostrophic velocity field. It'd be great to have utilities for all of these cases eventually. For idealized work I think its better to specify the streamfunction `psi`. This method is demonstrated by the Eady turbulence example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877561795
https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877561795:119,Integrability,Integrat,IntegratedField,119,"> > Or, given a geostrophic buoyancy field we can integrate in z (eg summation of b * dz). This would be the intent of IntegratedField, but nobody has implemented that yet.; > ; > That was more along the lines of what I was thinking. Basically showing users how to create a `u`, find out what `b` is, and then indicate if it's best to use that as `BackgroundField`, or an `Array` or something.; > ; > But it seems like `IntegratedField` needs to be in place for something as simple as what I'm envisioning?. Just to clarify, the quoted example suggests integrating `b` to find `psi`. If `u` is a function of `y` only I think we can integrate the relation `dy(psi) = u` to find `psi`. If the geostrophic streamfunction is a function of `x, y` then I think solving an elliptic problem is required, probably?. To summarize:. * To obtain `psi(x, y, z)` from `b(x, y, z)`, we integrate the relation `b = f * dz(psi)`. `IntegratedField` is useful.; * To obtain `psi(x, y, z)` from from `u(x, y, z)`, `v(x, y, z)` I _think_ (might be worth thinking about this more) we solve the horizontal elliptic problem `hlap(psi) = dx(v) - dy(u)` at every vertical level.; * To obtain a 2D `psi(y, z)` (for example), we might be able to integrate `dy(psi) = u`. These techniques could be important when initializing from data, perhaps. I'm not sure. For example, if a 3D distribution of `T, S` were obtained from data without knowledge of the velocity field, it might make sense to initialize the problem with a geostrophic velocity field. It'd be great to have utilities for all of these cases eventually. For idealized work I think its better to specify the streamfunction `psi`. This method is demonstrated by the Eady turbulence example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877561795
https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877561795:420,Integrability,Integrat,IntegratedField,420,"> > Or, given a geostrophic buoyancy field we can integrate in z (eg summation of b * dz). This would be the intent of IntegratedField, but nobody has implemented that yet.; > ; > That was more along the lines of what I was thinking. Basically showing users how to create a `u`, find out what `b` is, and then indicate if it's best to use that as `BackgroundField`, or an `Array` or something.; > ; > But it seems like `IntegratedField` needs to be in place for something as simple as what I'm envisioning?. Just to clarify, the quoted example suggests integrating `b` to find `psi`. If `u` is a function of `y` only I think we can integrate the relation `dy(psi) = u` to find `psi`. If the geostrophic streamfunction is a function of `x, y` then I think solving an elliptic problem is required, probably?. To summarize:. * To obtain `psi(x, y, z)` from `b(x, y, z)`, we integrate the relation `b = f * dz(psi)`. `IntegratedField` is useful.; * To obtain `psi(x, y, z)` from from `u(x, y, z)`, `v(x, y, z)` I _think_ (might be worth thinking about this more) we solve the horizontal elliptic problem `hlap(psi) = dx(v) - dy(u)` at every vertical level.; * To obtain a 2D `psi(y, z)` (for example), we might be able to integrate `dy(psi) = u`. These techniques could be important when initializing from data, perhaps. I'm not sure. For example, if a 3D distribution of `T, S` were obtained from data without knowledge of the velocity field, it might make sense to initialize the problem with a geostrophic velocity field. It'd be great to have utilities for all of these cases eventually. For idealized work I think its better to specify the streamfunction `psi`. This method is demonstrated by the Eady turbulence example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877561795
https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877561795:553,Integrability,integrat,integrating,553,"> > Or, given a geostrophic buoyancy field we can integrate in z (eg summation of b * dz). This would be the intent of IntegratedField, but nobody has implemented that yet.; > ; > That was more along the lines of what I was thinking. Basically showing users how to create a `u`, find out what `b` is, and then indicate if it's best to use that as `BackgroundField`, or an `Array` or something.; > ; > But it seems like `IntegratedField` needs to be in place for something as simple as what I'm envisioning?. Just to clarify, the quoted example suggests integrating `b` to find `psi`. If `u` is a function of `y` only I think we can integrate the relation `dy(psi) = u` to find `psi`. If the geostrophic streamfunction is a function of `x, y` then I think solving an elliptic problem is required, probably?. To summarize:. * To obtain `psi(x, y, z)` from `b(x, y, z)`, we integrate the relation `b = f * dz(psi)`. `IntegratedField` is useful.; * To obtain `psi(x, y, z)` from from `u(x, y, z)`, `v(x, y, z)` I _think_ (might be worth thinking about this more) we solve the horizontal elliptic problem `hlap(psi) = dx(v) - dy(u)` at every vertical level.; * To obtain a 2D `psi(y, z)` (for example), we might be able to integrate `dy(psi) = u`. These techniques could be important when initializing from data, perhaps. I'm not sure. For example, if a 3D distribution of `T, S` were obtained from data without knowledge of the velocity field, it might make sense to initialize the problem with a geostrophic velocity field. It'd be great to have utilities for all of these cases eventually. For idealized work I think its better to specify the streamfunction `psi`. This method is demonstrated by the Eady turbulence example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877561795
https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877561795:632,Integrability,integrat,integrate,632,"> > Or, given a geostrophic buoyancy field we can integrate in z (eg summation of b * dz). This would be the intent of IntegratedField, but nobody has implemented that yet.; > ; > That was more along the lines of what I was thinking. Basically showing users how to create a `u`, find out what `b` is, and then indicate if it's best to use that as `BackgroundField`, or an `Array` or something.; > ; > But it seems like `IntegratedField` needs to be in place for something as simple as what I'm envisioning?. Just to clarify, the quoted example suggests integrating `b` to find `psi`. If `u` is a function of `y` only I think we can integrate the relation `dy(psi) = u` to find `psi`. If the geostrophic streamfunction is a function of `x, y` then I think solving an elliptic problem is required, probably?. To summarize:. * To obtain `psi(x, y, z)` from `b(x, y, z)`, we integrate the relation `b = f * dz(psi)`. `IntegratedField` is useful.; * To obtain `psi(x, y, z)` from from `u(x, y, z)`, `v(x, y, z)` I _think_ (might be worth thinking about this more) we solve the horizontal elliptic problem `hlap(psi) = dx(v) - dy(u)` at every vertical level.; * To obtain a 2D `psi(y, z)` (for example), we might be able to integrate `dy(psi) = u`. These techniques could be important when initializing from data, perhaps. I'm not sure. For example, if a 3D distribution of `T, S` were obtained from data without knowledge of the velocity field, it might make sense to initialize the problem with a geostrophic velocity field. It'd be great to have utilities for all of these cases eventually. For idealized work I think its better to specify the streamfunction `psi`. This method is demonstrated by the Eady turbulence example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877561795
https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877561795:871,Integrability,integrat,integrate,871,"> > Or, given a geostrophic buoyancy field we can integrate in z (eg summation of b * dz). This would be the intent of IntegratedField, but nobody has implemented that yet.; > ; > That was more along the lines of what I was thinking. Basically showing users how to create a `u`, find out what `b` is, and then indicate if it's best to use that as `BackgroundField`, or an `Array` or something.; > ; > But it seems like `IntegratedField` needs to be in place for something as simple as what I'm envisioning?. Just to clarify, the quoted example suggests integrating `b` to find `psi`. If `u` is a function of `y` only I think we can integrate the relation `dy(psi) = u` to find `psi`. If the geostrophic streamfunction is a function of `x, y` then I think solving an elliptic problem is required, probably?. To summarize:. * To obtain `psi(x, y, z)` from `b(x, y, z)`, we integrate the relation `b = f * dz(psi)`. `IntegratedField` is useful.; * To obtain `psi(x, y, z)` from from `u(x, y, z)`, `v(x, y, z)` I _think_ (might be worth thinking about this more) we solve the horizontal elliptic problem `hlap(psi) = dx(v) - dy(u)` at every vertical level.; * To obtain a 2D `psi(y, z)` (for example), we might be able to integrate `dy(psi) = u`. These techniques could be important when initializing from data, perhaps. I'm not sure. For example, if a 3D distribution of `T, S` were obtained from data without knowledge of the velocity field, it might make sense to initialize the problem with a geostrophic velocity field. It'd be great to have utilities for all of these cases eventually. For idealized work I think its better to specify the streamfunction `psi`. This method is demonstrated by the Eady turbulence example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877561795
https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877561795:914,Integrability,Integrat,IntegratedField,914,"> > Or, given a geostrophic buoyancy field we can integrate in z (eg summation of b * dz). This would be the intent of IntegratedField, but nobody has implemented that yet.; > ; > That was more along the lines of what I was thinking. Basically showing users how to create a `u`, find out what `b` is, and then indicate if it's best to use that as `BackgroundField`, or an `Array` or something.; > ; > But it seems like `IntegratedField` needs to be in place for something as simple as what I'm envisioning?. Just to clarify, the quoted example suggests integrating `b` to find `psi`. If `u` is a function of `y` only I think we can integrate the relation `dy(psi) = u` to find `psi`. If the geostrophic streamfunction is a function of `x, y` then I think solving an elliptic problem is required, probably?. To summarize:. * To obtain `psi(x, y, z)` from `b(x, y, z)`, we integrate the relation `b = f * dz(psi)`. `IntegratedField` is useful.; * To obtain `psi(x, y, z)` from from `u(x, y, z)`, `v(x, y, z)` I _think_ (might be worth thinking about this more) we solve the horizontal elliptic problem `hlap(psi) = dx(v) - dy(u)` at every vertical level.; * To obtain a 2D `psi(y, z)` (for example), we might be able to integrate `dy(psi) = u`. These techniques could be important when initializing from data, perhaps. I'm not sure. For example, if a 3D distribution of `T, S` were obtained from data without knowledge of the velocity field, it might make sense to initialize the problem with a geostrophic velocity field. It'd be great to have utilities for all of these cases eventually. For idealized work I think its better to specify the streamfunction `psi`. This method is demonstrated by the Eady turbulence example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877561795
https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877561795:1218,Integrability,integrat,integrate,1218,"> > Or, given a geostrophic buoyancy field we can integrate in z (eg summation of b * dz). This would be the intent of IntegratedField, but nobody has implemented that yet.; > ; > That was more along the lines of what I was thinking. Basically showing users how to create a `u`, find out what `b` is, and then indicate if it's best to use that as `BackgroundField`, or an `Array` or something.; > ; > But it seems like `IntegratedField` needs to be in place for something as simple as what I'm envisioning?. Just to clarify, the quoted example suggests integrating `b` to find `psi`. If `u` is a function of `y` only I think we can integrate the relation `dy(psi) = u` to find `psi`. If the geostrophic streamfunction is a function of `x, y` then I think solving an elliptic problem is required, probably?. To summarize:. * To obtain `psi(x, y, z)` from `b(x, y, z)`, we integrate the relation `b = f * dz(psi)`. `IntegratedField` is useful.; * To obtain `psi(x, y, z)` from from `u(x, y, z)`, `v(x, y, z)` I _think_ (might be worth thinking about this more) we solve the horizontal elliptic problem `hlap(psi) = dx(v) - dy(u)` at every vertical level.; * To obtain a 2D `psi(y, z)` (for example), we might be able to integrate `dy(psi) = u`. These techniques could be important when initializing from data, perhaps. I'm not sure. For example, if a 3D distribution of `T, S` were obtained from data without knowledge of the velocity field, it might make sense to initialize the problem with a geostrophic velocity field. It'd be great to have utilities for all of these cases eventually. For idealized work I think its better to specify the streamfunction `psi`. This method is demonstrated by the Eady turbulence example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877561795
https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877561795:475,Usability,simpl,simple,475,"> > Or, given a geostrophic buoyancy field we can integrate in z (eg summation of b * dz). This would be the intent of IntegratedField, but nobody has implemented that yet.; > ; > That was more along the lines of what I was thinking. Basically showing users how to create a `u`, find out what `b` is, and then indicate if it's best to use that as `BackgroundField`, or an `Array` or something.; > ; > But it seems like `IntegratedField` needs to be in place for something as simple as what I'm envisioning?. Just to clarify, the quoted example suggests integrating `b` to find `psi`. If `u` is a function of `y` only I think we can integrate the relation `dy(psi) = u` to find `psi`. If the geostrophic streamfunction is a function of `x, y` then I think solving an elliptic problem is required, probably?. To summarize:. * To obtain `psi(x, y, z)` from `b(x, y, z)`, we integrate the relation `b = f * dz(psi)`. `IntegratedField` is useful.; * To obtain `psi(x, y, z)` from from `u(x, y, z)`, `v(x, y, z)` I _think_ (might be worth thinking about this more) we solve the horizontal elliptic problem `hlap(psi) = dx(v) - dy(u)` at every vertical level.; * To obtain a 2D `psi(y, z)` (for example), we might be able to integrate `dy(psi) = u`. These techniques could be important when initializing from data, perhaps. I'm not sure. For example, if a 3D distribution of `T, S` were obtained from data without knowledge of the velocity field, it might make sense to initialize the problem with a geostrophic velocity field. It'd be great to have utilities for all of these cases eventually. For idealized work I think its better to specify the streamfunction `psi`. This method is demonstrated by the Eady turbulence example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877561795
https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877651839:725,Deployability,integrat,integrate,725,"To clarify: I think there is utility in a simple example. However, I also recommend using a streamfunction for idealized cases, since its easier to reproduce and understand. Idealized cases with simple geostrophic flows include experiments like the Eady turbulence problem, or LES cases that simulate turbulence in the presence of a simple geostrophic flow. Another class of experiments (likely more prevalent and important than LES around geostrophic flows?) are realistic / quasi-realistic simulations on the sphere initialized from data or complicated buoyancy distributions. For these it's often important to find a flow field that's in _discrete_ geostrophic balance with an arbitrary buoyancy field. We can show how to integrate the buoyancy field for this purpose; but having `IntegratedField` implemented will make it a bit cleaner. The problem of finding a streamfunction from a velocity field is likewise be important for simulations on the cubed sphere; or cases in which the grid coordinate system does not align with, for example, a geographic coordinate system. This is the case that @francispoulin was attempting to solve in #1826, I think. @navidcy may illustrate how to do this in post processing using the conjugate gradient solver in his horizontal convection example, perhaps.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877651839
https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877651839:784,Deployability,Integrat,IntegratedField,784,"To clarify: I think there is utility in a simple example. However, I also recommend using a streamfunction for idealized cases, since its easier to reproduce and understand. Idealized cases with simple geostrophic flows include experiments like the Eady turbulence problem, or LES cases that simulate turbulence in the presence of a simple geostrophic flow. Another class of experiments (likely more prevalent and important than LES around geostrophic flows?) are realistic / quasi-realistic simulations on the sphere initialized from data or complicated buoyancy distributions. For these it's often important to find a flow field that's in _discrete_ geostrophic balance with an arbitrary buoyancy field. We can show how to integrate the buoyancy field for this purpose; but having `IntegratedField` implemented will make it a bit cleaner. The problem of finding a streamfunction from a velocity field is likewise be important for simulations on the cubed sphere; or cases in which the grid coordinate system does not align with, for example, a geographic coordinate system. This is the case that @francispoulin was attempting to solve in #1826, I think. @navidcy may illustrate how to do this in post processing using the conjugate gradient solver in his horizontal convection example, perhaps.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877651839
https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877651839:725,Integrability,integrat,integrate,725,"To clarify: I think there is utility in a simple example. However, I also recommend using a streamfunction for idealized cases, since its easier to reproduce and understand. Idealized cases with simple geostrophic flows include experiments like the Eady turbulence problem, or LES cases that simulate turbulence in the presence of a simple geostrophic flow. Another class of experiments (likely more prevalent and important than LES around geostrophic flows?) are realistic / quasi-realistic simulations on the sphere initialized from data or complicated buoyancy distributions. For these it's often important to find a flow field that's in _discrete_ geostrophic balance with an arbitrary buoyancy field. We can show how to integrate the buoyancy field for this purpose; but having `IntegratedField` implemented will make it a bit cleaner. The problem of finding a streamfunction from a velocity field is likewise be important for simulations on the cubed sphere; or cases in which the grid coordinate system does not align with, for example, a geographic coordinate system. This is the case that @francispoulin was attempting to solve in #1826, I think. @navidcy may illustrate how to do this in post processing using the conjugate gradient solver in his horizontal convection example, perhaps.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877651839
https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877651839:784,Integrability,Integrat,IntegratedField,784,"To clarify: I think there is utility in a simple example. However, I also recommend using a streamfunction for idealized cases, since its easier to reproduce and understand. Idealized cases with simple geostrophic flows include experiments like the Eady turbulence problem, or LES cases that simulate turbulence in the presence of a simple geostrophic flow. Another class of experiments (likely more prevalent and important than LES around geostrophic flows?) are realistic / quasi-realistic simulations on the sphere initialized from data or complicated buoyancy distributions. For these it's often important to find a flow field that's in _discrete_ geostrophic balance with an arbitrary buoyancy field. We can show how to integrate the buoyancy field for this purpose; but having `IntegratedField` implemented will make it a bit cleaner. The problem of finding a streamfunction from a velocity field is likewise be important for simulations on the cubed sphere; or cases in which the grid coordinate system does not align with, for example, a geographic coordinate system. This is the case that @francispoulin was attempting to solve in #1826, I think. @navidcy may illustrate how to do this in post processing using the conjugate gradient solver in his horizontal convection example, perhaps.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877651839
https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877651839:42,Usability,simpl,simple,42,"To clarify: I think there is utility in a simple example. However, I also recommend using a streamfunction for idealized cases, since its easier to reproduce and understand. Idealized cases with simple geostrophic flows include experiments like the Eady turbulence problem, or LES cases that simulate turbulence in the presence of a simple geostrophic flow. Another class of experiments (likely more prevalent and important than LES around geostrophic flows?) are realistic / quasi-realistic simulations on the sphere initialized from data or complicated buoyancy distributions. For these it's often important to find a flow field that's in _discrete_ geostrophic balance with an arbitrary buoyancy field. We can show how to integrate the buoyancy field for this purpose; but having `IntegratedField` implemented will make it a bit cleaner. The problem of finding a streamfunction from a velocity field is likewise be important for simulations on the cubed sphere; or cases in which the grid coordinate system does not align with, for example, a geographic coordinate system. This is the case that @francispoulin was attempting to solve in #1826, I think. @navidcy may illustrate how to do this in post processing using the conjugate gradient solver in his horizontal convection example, perhaps.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877651839
https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877651839:195,Usability,simpl,simple,195,"To clarify: I think there is utility in a simple example. However, I also recommend using a streamfunction for idealized cases, since its easier to reproduce and understand. Idealized cases with simple geostrophic flows include experiments like the Eady turbulence problem, or LES cases that simulate turbulence in the presence of a simple geostrophic flow. Another class of experiments (likely more prevalent and important than LES around geostrophic flows?) are realistic / quasi-realistic simulations on the sphere initialized from data or complicated buoyancy distributions. For these it's often important to find a flow field that's in _discrete_ geostrophic balance with an arbitrary buoyancy field. We can show how to integrate the buoyancy field for this purpose; but having `IntegratedField` implemented will make it a bit cleaner. The problem of finding a streamfunction from a velocity field is likewise be important for simulations on the cubed sphere; or cases in which the grid coordinate system does not align with, for example, a geographic coordinate system. This is the case that @francispoulin was attempting to solve in #1826, I think. @navidcy may illustrate how to do this in post processing using the conjugate gradient solver in his horizontal convection example, perhaps.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877651839
https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877651839:333,Usability,simpl,simple,333,"To clarify: I think there is utility in a simple example. However, I also recommend using a streamfunction for idealized cases, since its easier to reproduce and understand. Idealized cases with simple geostrophic flows include experiments like the Eady turbulence problem, or LES cases that simulate turbulence in the presence of a simple geostrophic flow. Another class of experiments (likely more prevalent and important than LES around geostrophic flows?) are realistic / quasi-realistic simulations on the sphere initialized from data or complicated buoyancy distributions. For these it's often important to find a flow field that's in _discrete_ geostrophic balance with an arbitrary buoyancy field. We can show how to integrate the buoyancy field for this purpose; but having `IntegratedField` implemented will make it a bit cleaner. The problem of finding a streamfunction from a velocity field is likewise be important for simulations on the cubed sphere; or cases in which the grid coordinate system does not align with, for example, a geographic coordinate system. This is the case that @francispoulin was attempting to solve in #1826, I think. @navidcy may illustrate how to do this in post processing using the conjugate gradient solver in his horizontal convection example, perhaps.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877651839
https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877699609:698,Usability,Clear,Clearly,698,"This all sounds very good and what @glwagner suggests will certainly work, and yes, that is exactly what I was trying to do in #1826. As a question of style, introducing a streamfunction is convenient for those of us that like streamfunctions, but really we're computing the pressure. Since the governing equations that we state for `IncompressibleModel` and `HydrostaticModel` are in terms of pressure, then that might be good as an introductory example. Oceananigans has a pressure solver already. Since the basic profiles that we consider have nonlinear terms, then I wonder if it's possible to use the built in pressure solver to determine `p` and then compute `b` using a derivative operator. Clearly the functionality is there and being able to solve for the pressure of your initial conditions, which is what we're really doing, might be helpful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846#issuecomment-877699609
https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-877709922:541,Testability,Log,Logger,541,"@glwagner I need some help with:. - Top boundary condition: when I try constructing it with parameters, e.g.,; ```; b_surf(x, y, t, p) = p.b0 * cos( * x / p.Lx); ```; the script does run. All the movies I made was like that. But when Documenter.jl run is it fails! I can reproduce this -- I know this is not so clear now. I tried all combinations of parameters/arguments and I can't understand what's happening. That's why I hard coded the values in the surface boundary condition at the moment. - Why do we get all these warnings from the Logger when we run the simulation? Perhaps these warnings hint something about the boundary condition issue? They seem boundary condition related... - As you can see from the movies this problem is ideal for VerticallyStretchedGrids as there for a boundary layer at the Any attempts adding a `VerticallyStretchedGrid` has given be blow ups, *even when the stretching on the grid is almost zero*, i.e., when the `VerticallyStretchedGrid`  `RegularGrid`. - How do I setup the Poisson solver to obtain solution of b=0 with b(x, t) = cos(x) and no flux boundary condition at all other walls.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-877709922
https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-877709922:312,Usability,clear,clear,312,"@glwagner I need some help with:. - Top boundary condition: when I try constructing it with parameters, e.g.,; ```; b_surf(x, y, t, p) = p.b0 * cos( * x / p.Lx); ```; the script does run. All the movies I made was like that. But when Documenter.jl run is it fails! I can reproduce this -- I know this is not so clear now. I tried all combinations of parameters/arguments and I can't understand what's happening. That's why I hard coded the values in the surface boundary condition at the moment. - Why do we get all these warnings from the Logger when we run the simulation? Perhaps these warnings hint something about the boundary condition issue? They seem boundary condition related... - As you can see from the movies this problem is ideal for VerticallyStretchedGrids as there for a boundary layer at the Any attempts adding a `VerticallyStretchedGrid` has given be blow ups, *even when the stretching on the grid is almost zero*, i.e., when the `VerticallyStretchedGrid`  `RegularGrid`. - How do I setup the Poisson solver to obtain solution of b=0 with b(x, t) = cos(x) and no flux boundary condition at all other walls.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-877709922
https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-877740920:79,Availability,error,error,79,"> * But when Documenter.jl run is it fails!. How does it fail? Does it emit an error? What is the error?. > Why do we get all these warnings from the Logger when we run the simulation? Perhaps these warnings hint something about the boundary condition issue? They seem boundary condition related... What warnings are you getting?. > As you can see from the movies this problem is ideal for VerticallyStretchedGrids as there for a boundary layer at the Any attempts adding a VerticallyStretchedGrid has given be blow ups, even when the stretching on the grid is almost zero, i.e., when the VerticallyStretchedGrid  RegularGrid. That's a concern. We should add dynamics / physics tests that stress-test the stretched grid. Can you confirm that you get the right result when the stretched grid is exactly identical to the regular grid?. > How do I setup the Poisson solver to obtain solution of b=0 with b(x, t) = cos(x) and no flux boundary condition at all other walls. Let's zoom. To clarify, we have a `PreconditionedConjugateGradientSolver` that I think would work well for this. This solver is a generic linear algebra solve that works with Oceananigans fields; it is not limited to solving the Poisson equation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-877740920
https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-877740920:98,Availability,error,error,98,"> * But when Documenter.jl run is it fails!. How does it fail? Does it emit an error? What is the error?. > Why do we get all these warnings from the Logger when we run the simulation? Perhaps these warnings hint something about the boundary condition issue? They seem boundary condition related... What warnings are you getting?. > As you can see from the movies this problem is ideal for VerticallyStretchedGrids as there for a boundary layer at the Any attempts adding a VerticallyStretchedGrid has given be blow ups, even when the stretching on the grid is almost zero, i.e., when the VerticallyStretchedGrid  RegularGrid. That's a concern. We should add dynamics / physics tests that stress-test the stretched grid. Can you confirm that you get the right result when the stretched grid is exactly identical to the regular grid?. > How do I setup the Poisson solver to obtain solution of b=0 with b(x, t) = cos(x) and no flux boundary condition at all other walls. Let's zoom. To clarify, we have a `PreconditionedConjugateGradientSolver` that I think would work well for this. This solver is a generic linear algebra solve that works with Oceananigans fields; it is not limited to solving the Poisson equation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-877740920
https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-877740920:150,Testability,Log,Logger,150,"> * But when Documenter.jl run is it fails!. How does it fail? Does it emit an error? What is the error?. > Why do we get all these warnings from the Logger when we run the simulation? Perhaps these warnings hint something about the boundary condition issue? They seem boundary condition related... What warnings are you getting?. > As you can see from the movies this problem is ideal for VerticallyStretchedGrids as there for a boundary layer at the Any attempts adding a VerticallyStretchedGrid has given be blow ups, even when the stretching on the grid is almost zero, i.e., when the VerticallyStretchedGrid  RegularGrid. That's a concern. We should add dynamics / physics tests that stress-test the stretched grid. Can you confirm that you get the right result when the stretched grid is exactly identical to the regular grid?. > How do I setup the Poisson solver to obtain solution of b=0 with b(x, t) = cos(x) and no flux boundary condition at all other walls. Let's zoom. To clarify, we have a `PreconditionedConjugateGradientSolver` that I think would work well for this. This solver is a generic linear algebra solve that works with Oceananigans fields; it is not limited to solving the Poisson equation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-877740920
https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-877740920:679,Testability,test,tests,679,"> * But when Documenter.jl run is it fails!. How does it fail? Does it emit an error? What is the error?. > Why do we get all these warnings from the Logger when we run the simulation? Perhaps these warnings hint something about the boundary condition issue? They seem boundary condition related... What warnings are you getting?. > As you can see from the movies this problem is ideal for VerticallyStretchedGrids as there for a boundary layer at the Any attempts adding a VerticallyStretchedGrid has given be blow ups, even when the stretching on the grid is almost zero, i.e., when the VerticallyStretchedGrid  RegularGrid. That's a concern. We should add dynamics / physics tests that stress-test the stretched grid. Can you confirm that you get the right result when the stretched grid is exactly identical to the regular grid?. > How do I setup the Poisson solver to obtain solution of b=0 with b(x, t) = cos(x) and no flux boundary condition at all other walls. Let's zoom. To clarify, we have a `PreconditionedConjugateGradientSolver` that I think would work well for this. This solver is a generic linear algebra solve that works with Oceananigans fields; it is not limited to solving the Poisson equation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-877740920
https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-877740920:697,Testability,test,test,697,"> * But when Documenter.jl run is it fails!. How does it fail? Does it emit an error? What is the error?. > Why do we get all these warnings from the Logger when we run the simulation? Perhaps these warnings hint something about the boundary condition issue? They seem boundary condition related... What warnings are you getting?. > As you can see from the movies this problem is ideal for VerticallyStretchedGrids as there for a boundary layer at the Any attempts adding a VerticallyStretchedGrid has given be blow ups, even when the stretching on the grid is almost zero, i.e., when the VerticallyStretchedGrid  RegularGrid. That's a concern. We should add dynamics / physics tests that stress-test the stretched grid. Can you confirm that you get the right result when the stretched grid is exactly identical to the regular grid?. > How do I setup the Poisson solver to obtain solution of b=0 with b(x, t) = cos(x) and no flux boundary condition at all other walls. Let's zoom. To clarify, we have a `PreconditionedConjugateGradientSolver` that I think would work well for this. This solver is a generic linear algebra solve that works with Oceananigans fields; it is not limited to solving the Poisson equation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-877740920
https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-877741754:46,Testability,Log,Logger,46,> > Why do we get all these warnings from the Logger when we run the simulation? Perhaps these warnings hint something about the boundary condition issue? They seem boundary condition related...; > ; > What warnings are you getting?; > . see here: https://clima.github.io/OceananigansDocumentation/previews/PR1847/generated/horizontal_convection/,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-877741754
https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-877743159:87,Availability,error,error,87,"> > * But when Documenter.jl run is it fails!; > ; > How does it fail? Does it emit an error? What is the error?. I'll rerun it now and post the error. Let's see what [this log](https://buildkite.com/clima/oceananigans/builds/3269#3fdc21e3-4269-4134-af7b-87b99576aec3) gives. > > As you can see from the movies this problem is ideal for VerticallyStretchedGrids as there for a boundary layer at the Any attempts adding a VerticallyStretchedGrid has given be blow ups, even when the stretching on the grid is almost zero, i.e., when the VerticallyStretchedGrid  RegularGrid.; > ; > That's a concern. We should add dynamics / physics tests that stress-test the stretched grid. Can you confirm that you get the right result when the stretched grid is exactly identical to the regular grid?. Would this create a vertically stretched grid with example the same spacing as the regular one?. ```Julia; grid = RegularRectilinearGrid(size = (Nx, Nz),; x = (-Lx/2, Lx/2),; z = (-H, 0),; halo = (3, 3),; topology = (Bounded, Flat, Bounded)). grid_stretched = VerticallyStretchedRectilinearGrid(size = (Nx, Nz),; topology = (Bounded, Flat, Bounded),; x = (-Lx/2, Lx/2),; halo = (3, 3),; z_faces = grid.zF); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-877743159
https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-877743159:106,Availability,error,error,106,"> > * But when Documenter.jl run is it fails!; > ; > How does it fail? Does it emit an error? What is the error?. I'll rerun it now and post the error. Let's see what [this log](https://buildkite.com/clima/oceananigans/builds/3269#3fdc21e3-4269-4134-af7b-87b99576aec3) gives. > > As you can see from the movies this problem is ideal for VerticallyStretchedGrids as there for a boundary layer at the Any attempts adding a VerticallyStretchedGrid has given be blow ups, even when the stretching on the grid is almost zero, i.e., when the VerticallyStretchedGrid  RegularGrid.; > ; > That's a concern. We should add dynamics / physics tests that stress-test the stretched grid. Can you confirm that you get the right result when the stretched grid is exactly identical to the regular grid?. Would this create a vertically stretched grid with example the same spacing as the regular one?. ```Julia; grid = RegularRectilinearGrid(size = (Nx, Nz),; x = (-Lx/2, Lx/2),; z = (-H, 0),; halo = (3, 3),; topology = (Bounded, Flat, Bounded)). grid_stretched = VerticallyStretchedRectilinearGrid(size = (Nx, Nz),; topology = (Bounded, Flat, Bounded),; x = (-Lx/2, Lx/2),; halo = (3, 3),; z_faces = grid.zF); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-877743159
https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-877743159:145,Availability,error,error,145,"> > * But when Documenter.jl run is it fails!; > ; > How does it fail? Does it emit an error? What is the error?. I'll rerun it now and post the error. Let's see what [this log](https://buildkite.com/clima/oceananigans/builds/3269#3fdc21e3-4269-4134-af7b-87b99576aec3) gives. > > As you can see from the movies this problem is ideal for VerticallyStretchedGrids as there for a boundary layer at the Any attempts adding a VerticallyStretchedGrid has given be blow ups, even when the stretching on the grid is almost zero, i.e., when the VerticallyStretchedGrid  RegularGrid.; > ; > That's a concern. We should add dynamics / physics tests that stress-test the stretched grid. Can you confirm that you get the right result when the stretched grid is exactly identical to the regular grid?. Would this create a vertically stretched grid with example the same spacing as the regular one?. ```Julia; grid = RegularRectilinearGrid(size = (Nx, Nz),; x = (-Lx/2, Lx/2),; z = (-H, 0),; halo = (3, 3),; topology = (Bounded, Flat, Bounded)). grid_stretched = VerticallyStretchedRectilinearGrid(size = (Nx, Nz),; topology = (Bounded, Flat, Bounded),; x = (-Lx/2, Lx/2),; halo = (3, 3),; z_faces = grid.zF); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-877743159
https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-877743159:173,Testability,log,log,173,"> > * But when Documenter.jl run is it fails!; > ; > How does it fail? Does it emit an error? What is the error?. I'll rerun it now and post the error. Let's see what [this log](https://buildkite.com/clima/oceananigans/builds/3269#3fdc21e3-4269-4134-af7b-87b99576aec3) gives. > > As you can see from the movies this problem is ideal for VerticallyStretchedGrids as there for a boundary layer at the Any attempts adding a VerticallyStretchedGrid has given be blow ups, even when the stretching on the grid is almost zero, i.e., when the VerticallyStretchedGrid  RegularGrid.; > ; > That's a concern. We should add dynamics / physics tests that stress-test the stretched grid. Can you confirm that you get the right result when the stretched grid is exactly identical to the regular grid?. Would this create a vertically stretched grid with example the same spacing as the regular one?. ```Julia; grid = RegularRectilinearGrid(size = (Nx, Nz),; x = (-Lx/2, Lx/2),; z = (-H, 0),; halo = (3, 3),; topology = (Bounded, Flat, Bounded)). grid_stretched = VerticallyStretchedRectilinearGrid(size = (Nx, Nz),; topology = (Bounded, Flat, Bounded),; x = (-Lx/2, Lx/2),; halo = (3, 3),; z_faces = grid.zF); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-877743159
https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-877743159:633,Testability,test,tests,633,"> > * But when Documenter.jl run is it fails!; > ; > How does it fail? Does it emit an error? What is the error?. I'll rerun it now and post the error. Let's see what [this log](https://buildkite.com/clima/oceananigans/builds/3269#3fdc21e3-4269-4134-af7b-87b99576aec3) gives. > > As you can see from the movies this problem is ideal for VerticallyStretchedGrids as there for a boundary layer at the Any attempts adding a VerticallyStretchedGrid has given be blow ups, even when the stretching on the grid is almost zero, i.e., when the VerticallyStretchedGrid  RegularGrid.; > ; > That's a concern. We should add dynamics / physics tests that stress-test the stretched grid. Can you confirm that you get the right result when the stretched grid is exactly identical to the regular grid?. Would this create a vertically stretched grid with example the same spacing as the regular one?. ```Julia; grid = RegularRectilinearGrid(size = (Nx, Nz),; x = (-Lx/2, Lx/2),; z = (-H, 0),; halo = (3, 3),; topology = (Bounded, Flat, Bounded)). grid_stretched = VerticallyStretchedRectilinearGrid(size = (Nx, Nz),; topology = (Bounded, Flat, Bounded),; x = (-Lx/2, Lx/2),; halo = (3, 3),; z_faces = grid.zF); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-877743159
https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-877743159:651,Testability,test,test,651,"> > * But when Documenter.jl run is it fails!; > ; > How does it fail? Does it emit an error? What is the error?. I'll rerun it now and post the error. Let's see what [this log](https://buildkite.com/clima/oceananigans/builds/3269#3fdc21e3-4269-4134-af7b-87b99576aec3) gives. > > As you can see from the movies this problem is ideal for VerticallyStretchedGrids as there for a boundary layer at the Any attempts adding a VerticallyStretchedGrid has given be blow ups, even when the stretching on the grid is almost zero, i.e., when the VerticallyStretchedGrid  RegularGrid.; > ; > That's a concern. We should add dynamics / physics tests that stress-test the stretched grid. Can you confirm that you get the right result when the stretched grid is exactly identical to the regular grid?. Would this create a vertically stretched grid with example the same spacing as the regular one?. ```Julia; grid = RegularRectilinearGrid(size = (Nx, Nz),; x = (-Lx/2, Lx/2),; z = (-H, 0),; halo = (3, 3),; topology = (Bounded, Flat, Bounded)). grid_stretched = VerticallyStretchedRectilinearGrid(size = (Nx, Nz),; topology = (Bounded, Flat, Bounded),; x = (-Lx/2, Lx/2),; halo = (3, 3),; z_faces = grid.zF); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-877743159
https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-878316763:778,Deployability,Continuous,ContinuousBoundaryFunction,778,"> > > Why do we get all these warnings from the Logger when we run the simulation? Perhaps these warnings hint something about the boundary condition issue? They seem boundary condition related...; > > ; > > ; > > What warnings are you getting?; > ; > see here: https://clima.github.io/OceananigansDocumentation/previews/PR1847/generated/horizontal_convection/. Are you referring to these two warnings:. ```julia;  Warning: type parameters for NamedTuple{(:x, :y, :z),Tuple} do not match type NamedTuple in workspace; reconstructing;  @ JLD2 /storage7/buildkite-agent/.julia-3275/packages/JLD2/sFiXk/src/data/reconstructing_datatypes.jl:430;  Warning: type CoordinateBoundaryConditions{BoundaryCondition{Flux, Nothing},BoundaryCondition{Value,Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center,Center,Nothing,64,Main.__atexample__named__horizontal_convection.#b,Nothing,Tuple{},Tuple{},Tuple{}}}} does not exist in workspace; reconstructing;  @ JLD2 /storage7/buildkite-agent/.julia-3275/packages/JLD2/sFiXk/src/data/reconstructing_datatypes.jl:358; ```. that are emitted after `run!(simulation)`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-878316763
https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-878316763:48,Testability,Log,Logger,48,"> > > Why do we get all these warnings from the Logger when we run the simulation? Perhaps these warnings hint something about the boundary condition issue? They seem boundary condition related...; > > ; > > ; > > What warnings are you getting?; > ; > see here: https://clima.github.io/OceananigansDocumentation/previews/PR1847/generated/horizontal_convection/. Are you referring to these two warnings:. ```julia;  Warning: type parameters for NamedTuple{(:x, :y, :z),Tuple} do not match type NamedTuple in workspace; reconstructing;  @ JLD2 /storage7/buildkite-agent/.julia-3275/packages/JLD2/sFiXk/src/data/reconstructing_datatypes.jl:430;  Warning: type CoordinateBoundaryConditions{BoundaryCondition{Flux, Nothing},BoundaryCondition{Value,Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center,Center,Nothing,64,Main.__atexample__named__horizontal_convection.#b,Nothing,Tuple{},Tuple{},Tuple{}}}} does not exist in workspace; reconstructing;  @ JLD2 /storage7/buildkite-agent/.julia-3275/packages/JLD2/sFiXk/src/data/reconstructing_datatypes.jl:358; ```. that are emitted after `run!(simulation)`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-878316763
https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-878496271:430,Deployability,Continuous,ContinuousBoundaryFunction,430,"> Are you referring to these two warnings:; > ; > ```julia; >  Warning: type parameters for NamedTuple{(:x, :y, :z),Tuple} do not match type NamedTuple in workspace; reconstructing; >  @ JLD2 /storage7/buildkite-agent/.julia-3275/packages/JLD2/sFiXk/src/data/reconstructing_datatypes.jl:430; >  Warning: type CoordinateBoundaryConditions{BoundaryCondition{Flux, Nothing},BoundaryCondition{Value,Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center,Center,Nothing,64,Main.__atexample__named__horizontal_convection.#b,Nothing,Tuple{},Tuple{},Tuple{}}}} does not exist in workspace; reconstructing; >  @ JLD2 /storage7/buildkite-agent/.julia-3275/packages/JLD2/sFiXk/src/data/reconstructing_datatypes.jl:358; > ```; > ; > that are emitted after `run!(simulation)`?. Yeap",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-878496271
https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-878826622:604,Energy Efficiency,Reduce,ReducedField,604,"I tried to compare computing Nu from saved  and from saved b and I got some differences. Any ideas what's happening here?. So with only the `.jld2` output you get when you run the example, I did:. ```Julia; using JLD2, Plots; using Oceananigans; using Oceananigans.AbstractOperations: volume; using Oceananigans.Fields. saved_output_prefix = ""horizontal_convection""; saved_output_filename = saved_output_prefix * "".jld2"". file = jldopen(saved_output_filename);  = file[""closure//b""]. _timeseries = FieldTimeSeries(saved_output_filename, """"). t = _timeseries.times; grid = _timeseries.grid. _ = ReducedField(Nothing, Nothing, Nothing, CPU(), grid, dims=(1, 2, 3)); Nu_from_ = zeros(length(t)). ## Can we broadcast over the time dimension?; for i = 1:length(t);  = _timeseries[i]; sum!(_,  * volume); Nu_from_[i] = _[1, 1, 1]; end. plot(t, Nu_from_,; title = ""A measure for Nu(t)"",; xlabel = ""Time"",; ylabel = ""Nu(t)"",; linewidth = 3,; label = ""computed from saved ""). b_timeseries = FieldTimeSeries(saved_output_filename, ""b""). t = b_timeseries.times; grid = b_timeseries.grid. _mod_b = ReducedField(Nothing, Nothing, Nothing, CPU(), grid, dims=(1, 2, 3)); Nu_from_b = zeros(length(t)). ## Can we broadcast over the time dimension?; for i = 1:length(t); b = b_timeseries[i]; sum!(_mod_b,  * (x(b)^2+z(b)^2) * volume); Nu_from_b[i] = _mod_b[1, 1, 1]; end. plot!(t, Nu_from_b,; linestyle = :dash,; linewidth = 3,; label = ""computed from saved b""). savefig(""two_Nu_computations.png""); ```. ![two_Nu_computations](https://user-images.githubusercontent.com/7112768/125404874-7d648180-e3fa-11eb-8f90-6171b0e40d1e.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-878826622
https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-878826622:1112,Energy Efficiency,Reduce,ReducedField,1112,"I tried to compare computing Nu from saved  and from saved b and I got some differences. Any ideas what's happening here?. So with only the `.jld2` output you get when you run the example, I did:. ```Julia; using JLD2, Plots; using Oceananigans; using Oceananigans.AbstractOperations: volume; using Oceananigans.Fields. saved_output_prefix = ""horizontal_convection""; saved_output_filename = saved_output_prefix * "".jld2"". file = jldopen(saved_output_filename);  = file[""closure//b""]. _timeseries = FieldTimeSeries(saved_output_filename, """"). t = _timeseries.times; grid = _timeseries.grid. _ = ReducedField(Nothing, Nothing, Nothing, CPU(), grid, dims=(1, 2, 3)); Nu_from_ = zeros(length(t)). ## Can we broadcast over the time dimension?; for i = 1:length(t);  = _timeseries[i]; sum!(_,  * volume); Nu_from_[i] = _[1, 1, 1]; end. plot(t, Nu_from_,; title = ""A measure for Nu(t)"",; xlabel = ""Time"",; ylabel = ""Nu(t)"",; linewidth = 3,; label = ""computed from saved ""). b_timeseries = FieldTimeSeries(saved_output_filename, ""b""). t = b_timeseries.times; grid = b_timeseries.grid. _mod_b = ReducedField(Nothing, Nothing, Nothing, CPU(), grid, dims=(1, 2, 3)); Nu_from_b = zeros(length(t)). ## Can we broadcast over the time dimension?; for i = 1:length(t); b = b_timeseries[i]; sum!(_mod_b,  * (x(b)^2+z(b)^2) * volume); Nu_from_b[i] = _mod_b[1, 1, 1]; end. plot!(t, Nu_from_b,; linestyle = :dash,; linewidth = 3,; label = ""computed from saved b""). savefig(""two_Nu_computations.png""); ```. ![two_Nu_computations](https://user-images.githubusercontent.com/7112768/125404874-7d648180-e3fa-11eb-8f90-6171b0e40d1e.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-878826622
https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-878829232:979,Deployability,Continuous,ContinuousBoundaryFunction,979,"Something related with the boundary conditions of the loaded saved `b` perhaps?. E.g., . ```julia; julia> b_timeseries[10]; Field located at (Center, Center, Center);  data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (128, 1, 64);  grid: RegularRectilinearGrid{Float64, Bounded, Flat, Bounded}(Nx=128, Ny=1, Nz=64);  boundary conditions: JLD2.ReconstructedTypes.var""##NamedTuple{(:x, :y, :z),Tuple}#261""(CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}(BoundaryCondition: type=ZeroFlux, condition=nothing, BoundaryCondition: type=ZeroFlux, condition=nothing), CoordinateBoundaryConditions{Nothing, Nothing}(nothing, nothing), JLD2.ReconstructedTypes.var""##CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Value,Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center,Center,Nothing,64,Main.#b,Nothing,Tuple{},Tuple{},Tuple{}}}}#262""()); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-878829232
https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-878829232:54,Performance,load,loaded,54,"Something related with the boundary conditions of the loaded saved `b` perhaps?. E.g., . ```julia; julia> b_timeseries[10]; Field located at (Center, Center, Center);  data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (128, 1, 64);  grid: RegularRectilinearGrid{Float64, Bounded, Flat, Bounded}(Nx=128, Ny=1, Nz=64);  boundary conditions: JLD2.ReconstructedTypes.var""##NamedTuple{(:x, :y, :z),Tuple}#261""(CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}(BoundaryCondition: type=ZeroFlux, condition=nothing, BoundaryCondition: type=ZeroFlux, condition=nothing), CoordinateBoundaryConditions{Nothing, Nothing}(nothing, nothing), JLD2.ReconstructedTypes.var""##CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Value,Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center,Center,Nothing,64,Main.#b,Nothing,Tuple{},Tuple{},Tuple{}}}}#262""()); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-878829232
https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-881780508:515,Deployability,Continuous,ContinuousBoundaryFunction,515,"OK, this is now ready to review. I have hardcoded the boundary condition parameters! Any attempt to include them via parameters failed. Please help by showing me how (try building the docs though first before you claim success :) --- I tried a million times!). Also, I get a lot of these warnings:; ```;  Warning: type FieldBoundaryConditions{BoundaryCondition{Flux, Nothing},BoundaryCondition{Flux, Nothing},Nothing,Nothing,BoundaryCondition{Flux, Nothing},BoundaryCondition{Value,Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center,Center,Nothing,64,Main.__atexample__named__horizontal_convection.#b,Nothing,Tuple{},Tuple{},Tuple{}}},BoundaryCondition{Flux, Nothing}} does not exist in workspace; reconstructing;  @ JLD2 ~/.julia/packages/JLD2/sFiXk/src/data/reconstructing_datatypes.jl:358; ```. Any idea why? My instinct says that these issues are intertwined but I can't figure out why...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-881780508
https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-881793492:955,Availability,error,error,955,"> OK, this is now ready to review.; > ; > I have hardcoded the boundary condition parameters! Any attempt to include them via parameters failed. Please help by showing me how (try building the docs though first before you claim success :) --- I tried a million times!); > ; > Also, I get a lot of these warnings:; > ; > ```; >  Warning: type FieldBoundaryConditions{BoundaryCondition{Flux, Nothing},BoundaryCondition{Flux, Nothing},Nothing,Nothing,BoundaryCondition{Flux, Nothing},BoundaryCondition{Value,Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center,Center,Nothing,64,Main.__atexample__named__horizontal_convection.#b,Nothing,Tuple{},Tuple{},Tuple{}}},BoundaryCondition{Flux, Nothing}} does not exist in workspace; reconstructing; >  @ JLD2 ~/.julia/packages/JLD2/sFiXk/src/data/reconstructing_datatypes.jl:358; > ```; > ; > Any idea why? My instinct says that these issues are intertwined but I can't figure out why... What's the error?. I believe that warning comes from `FieldTimeSeries`. But that's a warning, not an error, so its ok.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-881793492
https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-881793492:1045,Availability,error,error,1045,"> OK, this is now ready to review.; > ; > I have hardcoded the boundary condition parameters! Any attempt to include them via parameters failed. Please help by showing me how (try building the docs though first before you claim success :) --- I tried a million times!); > ; > Also, I get a lot of these warnings:; > ; > ```; >  Warning: type FieldBoundaryConditions{BoundaryCondition{Flux, Nothing},BoundaryCondition{Flux, Nothing},Nothing,Nothing,BoundaryCondition{Flux, Nothing},BoundaryCondition{Value,Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center,Center,Nothing,64,Main.__atexample__named__horizontal_convection.#b,Nothing,Tuple{},Tuple{},Tuple{}}},BoundaryCondition{Flux, Nothing}} does not exist in workspace; reconstructing; >  @ JLD2 ~/.julia/packages/JLD2/sFiXk/src/data/reconstructing_datatypes.jl:358; > ```; > ; > Any idea why? My instinct says that these issues are intertwined but I can't figure out why... What's the error?. I believe that warning comes from `FieldTimeSeries`. But that's a warning, not an error, so its ok.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-881793492
https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-881793492:538,Deployability,Continuous,ContinuousBoundaryFunction,538,"> OK, this is now ready to review.; > ; > I have hardcoded the boundary condition parameters! Any attempt to include them via parameters failed. Please help by showing me how (try building the docs though first before you claim success :) --- I tried a million times!); > ; > Also, I get a lot of these warnings:; > ; > ```; >  Warning: type FieldBoundaryConditions{BoundaryCondition{Flux, Nothing},BoundaryCondition{Flux, Nothing},Nothing,Nothing,BoundaryCondition{Flux, Nothing},BoundaryCondition{Value,Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center,Center,Nothing,64,Main.__atexample__named__horizontal_convection.#b,Nothing,Tuple{},Tuple{},Tuple{}}},BoundaryCondition{Flux, Nothing}} does not exist in workspace; reconstructing; >  @ JLD2 ~/.julia/packages/JLD2/sFiXk/src/data/reconstructing_datatypes.jl:358; > ```; > ; > Any idea why? My instinct says that these issues are intertwined but I can't figure out why... What's the error?. I believe that warning comes from `FieldTimeSeries`. But that's a warning, not an error, so its ok.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-881793492
https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-881794493:1028,Availability,error,error,1028,"> > OK, this is now ready to review.; > > I have hardcoded the boundary condition parameters! Any attempt to include them via parameters failed. Please help by showing me how (try building the docs though first before you claim success :) --- I tried a million times!); > > Also, I get a lot of these warnings:; > > ```; > >  Warning: type FieldBoundaryConditions{BoundaryCondition{Flux, Nothing},BoundaryCondition{Flux, Nothing},Nothing,Nothing,BoundaryCondition{Flux, Nothing},BoundaryCondition{Value,Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center,Center,Nothing,64,Main.__atexample__named__horizontal_convection.#b,Nothing,Tuple{},Tuple{},Tuple{}}},BoundaryCondition{Flux, Nothing}} does not exist in workspace; reconstructing; > >  @ JLD2 ~/.julia/packages/JLD2/sFiXk/src/data/reconstructing_datatypes.jl:358; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > Any idea why? My instinct says that these issues are intertwined but I can't figure out why...; > ; > What's the error?; > ; > I believe that warning comes from `FieldTimeSeries`. But that's a warning, not an error, so its ok. when I did; ```; const b = 1.0; const k = 2 / Lx. @inline b(x, y, t, p) = - p.b * cos(p.k * x). b_bcs = FieldBoundaryConditions(top = ValueBoundaryCondition(b, parameters = (b = b, k = k))); ```; and try to build the docs I get:; ```;  Debug: Running ExpanderPipeline on generated/horizontal_convection.md;  @ Documenter.Expanders ~/.julia/packages/Documenter/4JDQo/src/Expanders.jl:39;  Warning: failed to run `@example` block in src/generated/horizontal_convection.md:221-223;  ```@example horizontal_convection;  run!(simulation);  ```;  c.value = TypeError: in <:, expected Type, got a value of type JLD2.OnDiskRepresentation{(0,), Tuple{NamedTuple{(:b, :k), Tuple{Float64, Float64}}}, Tuple{NamedTuple{(:b, :k), Tuple{Float64, Float64}}}}; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-881794493
https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-881794493:1124,Availability,error,error,1124,"> > OK, this is now ready to review.; > > I have hardcoded the boundary condition parameters! Any attempt to include them via parameters failed. Please help by showing me how (try building the docs though first before you claim success :) --- I tried a million times!); > > Also, I get a lot of these warnings:; > > ```; > >  Warning: type FieldBoundaryConditions{BoundaryCondition{Flux, Nothing},BoundaryCondition{Flux, Nothing},Nothing,Nothing,BoundaryCondition{Flux, Nothing},BoundaryCondition{Value,Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center,Center,Nothing,64,Main.__atexample__named__horizontal_convection.#b,Nothing,Tuple{},Tuple{},Tuple{}}},BoundaryCondition{Flux, Nothing}} does not exist in workspace; reconstructing; > >  @ JLD2 ~/.julia/packages/JLD2/sFiXk/src/data/reconstructing_datatypes.jl:358; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > Any idea why? My instinct says that these issues are intertwined but I can't figure out why...; > ; > What's the error?; > ; > I believe that warning comes from `FieldTimeSeries`. But that's a warning, not an error, so its ok. when I did; ```; const b = 1.0; const k = 2 / Lx. @inline b(x, y, t, p) = - p.b * cos(p.k * x). b_bcs = FieldBoundaryConditions(top = ValueBoundaryCondition(b, parameters = (b = b, k = k))); ```; and try to build the docs I get:; ```;  Debug: Running ExpanderPipeline on generated/horizontal_convection.md;  @ Documenter.Expanders ~/.julia/packages/Documenter/4JDQo/src/Expanders.jl:39;  Warning: failed to run `@example` block in src/generated/horizontal_convection.md:221-223;  ```@example horizontal_convection;  run!(simulation);  ```;  c.value = TypeError: in <:, expected Type, got a value of type JLD2.OnDiskRepresentation{(0,), Tuple{NamedTuple{(:b, :k), Tuple{Float64, Float64}}}, Tuple{NamedTuple{(:b, :k), Tuple{Float64, Float64}}}}; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-881794493
https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-881794493:536,Deployability,Continuous,ContinuousBoundaryFunction,536,"> > OK, this is now ready to review.; > > I have hardcoded the boundary condition parameters! Any attempt to include them via parameters failed. Please help by showing me how (try building the docs though first before you claim success :) --- I tried a million times!); > > Also, I get a lot of these warnings:; > > ```; > >  Warning: type FieldBoundaryConditions{BoundaryCondition{Flux, Nothing},BoundaryCondition{Flux, Nothing},Nothing,Nothing,BoundaryCondition{Flux, Nothing},BoundaryCondition{Value,Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center,Center,Nothing,64,Main.__atexample__named__horizontal_convection.#b,Nothing,Tuple{},Tuple{},Tuple{}}},BoundaryCondition{Flux, Nothing}} does not exist in workspace; reconstructing; > >  @ JLD2 ~/.julia/packages/JLD2/sFiXk/src/data/reconstructing_datatypes.jl:358; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > Any idea why? My instinct says that these issues are intertwined but I can't figure out why...; > ; > What's the error?; > ; > I believe that warning comes from `FieldTimeSeries`. But that's a warning, not an error, so its ok. when I did; ```; const b = 1.0; const k = 2 / Lx. @inline b(x, y, t, p) = - p.b * cos(p.k * x). b_bcs = FieldBoundaryConditions(top = ValueBoundaryCondition(b, parameters = (b = b, k = k))); ```; and try to build the docs I get:; ```;  Debug: Running ExpanderPipeline on generated/horizontal_convection.md;  @ Documenter.Expanders ~/.julia/packages/Documenter/4JDQo/src/Expanders.jl:39;  Warning: failed to run `@example` block in src/generated/horizontal_convection.md:221-223;  ```@example horizontal_convection;  run!(simulation);  ```;  c.value = TypeError: in <:, expected Type, got a value of type JLD2.OnDiskRepresentation{(0,), Tuple{NamedTuple{(:b, :k), Tuple{Float64, Float64}}}, Tuple{NamedTuple{(:b, :k), Tuple{Float64, Float64}}}}; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-881794493
https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-881831102:387,Energy Efficiency,reduce,reduce,387,"> I think we can make this example a bit shorter with literate techniques. For example, we write the boundary condition in latex once, and then its re-expressed almost identically in code. We may only need to write the boundary condition once with code.; > ; > It's otherwise beautiful, obviously... I shorten it a bit. Removed eqs and tried to combine description of the math + code to reduce clutter.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1847#issuecomment-881831102
https://github.com/CliMA/Oceananigans.jl/pull/1848#issuecomment-877649413:85,Availability,error,errors,85,> Sorry I was too quick to merge yesterday.; > ; > This looks good but I see that it errors with the following; > ; > ```; > Checkpointer [GPU]: Test Failed at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-1/clima/oceananigans/test/test_checkpointer.jl:14; >  | Expression: all(test_model.timestepper.G.w.data . true_model.timestepper.G.w.data); > ```; > ```. That's an intermittent failure; we just have to re-run (unfortunately).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1848#issuecomment-877649413
https://github.com/CliMA/Oceananigans.jl/pull/1848#issuecomment-877649413:125,Availability,Checkpoint,Checkpointer,125,> Sorry I was too quick to merge yesterday.; > ; > This looks good but I see that it errors with the following; > ; > ```; > Checkpointer [GPU]: Test Failed at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-1/clima/oceananigans/test/test_checkpointer.jl:14; >  | Expression: all(test_model.timestepper.G.w.data . true_model.timestepper.G.w.data); > ```; > ```. That's an intermittent failure; we just have to re-run (unfortunately).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1848#issuecomment-877649413
https://github.com/CliMA/Oceananigans.jl/pull/1848#issuecomment-877649413:413,Availability,failure,failure,413,> Sorry I was too quick to merge yesterday.; > ; > This looks good but I see that it errors with the following; > ; > ```; > Checkpointer [GPU]: Test Failed at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-1/clima/oceananigans/test/test_checkpointer.jl:14; >  | Expression: all(test_model.timestepper.G.w.data . true_model.timestepper.G.w.data); > ```; > ```. That's an intermittent failure; we just have to re-run (unfortunately).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1848#issuecomment-877649413
https://github.com/CliMA/Oceananigans.jl/pull/1848#issuecomment-877649413:145,Testability,Test,Test,145,> Sorry I was too quick to merge yesterday.; > ; > This looks good but I see that it errors with the following; > ; > ```; > Checkpointer [GPU]: Test Failed at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-1/clima/oceananigans/test/test_checkpointer.jl:14; >  | Expression: all(test_model.timestepper.G.w.data . true_model.timestepper.G.w.data); > ```; > ```. That's an intermittent failure; we just have to re-run (unfortunately).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1848#issuecomment-877649413
https://github.com/CliMA/Oceananigans.jl/pull/1848#issuecomment-877649413:252,Testability,test,test,252,> Sorry I was too quick to merge yesterday.; > ; > This looks good but I see that it errors with the following; > ; > ```; > Checkpointer [GPU]: Test Failed at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-1/clima/oceananigans/test/test_checkpointer.jl:14; >  | Expression: all(test_model.timestepper.G.w.data . true_model.timestepper.G.w.data); > ```; > ```. That's an intermittent failure; we just have to re-run (unfortunately).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1848#issuecomment-877649413
https://github.com/CliMA/Oceananigans.jl/pull/1848#issuecomment-877700061:34,Testability,test,test,34,Thanks for doing that and now all test pass. Very nice,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1848#issuecomment-877700061
https://github.com/CliMA/Oceananigans.jl/issues/1849#issuecomment-877905755:232,Testability,test,test,232,"Hmnm, I thought there existed a Poisson solver that worked for each topology. Maybe I'm wrong?. I looked at your code and see you want to use `(Periodic, Flat, Bounded)`. I also checked in `test_poisson_solver.jl` and see this does test that particular topology but the test is for instantiating. . Is it possible that the model can instantiate but not solve the poisson problem for this topology? If yes then do we want a stronger test?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1849#issuecomment-877905755
https://github.com/CliMA/Oceananigans.jl/issues/1849#issuecomment-877905755:270,Testability,test,test,270,"Hmnm, I thought there existed a Poisson solver that worked for each topology. Maybe I'm wrong?. I looked at your code and see you want to use `(Periodic, Flat, Bounded)`. I also checked in `test_poisson_solver.jl` and see this does test that particular topology but the test is for instantiating. . Is it possible that the model can instantiate but not solve the poisson problem for this topology? If yes then do we want a stronger test?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1849#issuecomment-877905755
https://github.com/CliMA/Oceananigans.jl/issues/1849#issuecomment-877905755:432,Testability,test,test,432,"Hmnm, I thought there existed a Poisson solver that worked for each topology. Maybe I'm wrong?. I looked at your code and see you want to use `(Periodic, Flat, Bounded)`. I also checked in `test_poisson_solver.jl` and see this does test that particular topology but the test is for instantiating. . Is it possible that the model can instantiate but not solve the poisson problem for this topology? If yes then do we want a stronger test?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1849#issuecomment-877905755
https://github.com/CliMA/Oceananigans.jl/issues/1849#issuecomment-878312638:225,Security,validat,validation,225,"As for issues with other topologies, we could possibly use the ""forced flow, fixed-slip"" convergence test with 2D slices oriented in various directions to uncover issues:. https://github.com/CliMA/Oceananigans.jl/blob/master/validation/convergence_tests/src/ForcedFlowFixedSlip.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1849#issuecomment-878312638
https://github.com/CliMA/Oceananigans.jl/issues/1849#issuecomment-878312638:101,Testability,test,test,101,"As for issues with other topologies, we could possibly use the ""forced flow, fixed-slip"" convergence test with 2D slices oriented in various directions to uncover issues:. https://github.com/CliMA/Oceananigans.jl/blob/master/validation/convergence_tests/src/ForcedFlowFixedSlip.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1849#issuecomment-878312638
https://github.com/CliMA/Oceananigans.jl/issues/1849#issuecomment-881907317:1087,Testability,test,test,1087,"This problem may be an issue with the vertically stretched grid rather than the FourierTridiagonalPoissonSolver. The mixed FFT/Tridiagonal Poisson solver uses similar constructs as the FFTBased Poisson solver. The two ingredients are 1) a Fourier transform in the `Flat` direction, and 2) computation of the eigenvalues:. https://github.com/CliMA/Oceananigans.jl/blob/5fbd8cd20c5db8e9b11b6175984e7592a08fc874/src/Solvers/poisson_eigenvalues.jl#L8-L11. https://github.com/CliMA/Oceananigans.jl/blob/5fbd8cd20c5db8e9b11b6175984e7592a08fc874/src/Solvers/poisson_eigenvalues.jl#L31. The first eigenvalue is 0, so the `Flat` case is correct. It's also used for the fully FFT-based solver and we know it works in that context. The transforms must be fine too. The grids differ though in how grid metrics are computed, so I suspect the problem is there. I think we've also had issues with `HydrostaticFreeSurfaceModel` and `VerticallyStretchedRectilinearGrid` with `Flat` topologies, but I haven't looked into it systematically. We might be able to convert the internal wave ~~setup~~ dynamics test to a vertically bounded domain and put it on a stretched grid to test these issues.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1849#issuecomment-881907317
https://github.com/CliMA/Oceananigans.jl/issues/1849#issuecomment-881907317:1157,Testability,test,test,1157,"This problem may be an issue with the vertically stretched grid rather than the FourierTridiagonalPoissonSolver. The mixed FFT/Tridiagonal Poisson solver uses similar constructs as the FFTBased Poisson solver. The two ingredients are 1) a Fourier transform in the `Flat` direction, and 2) computation of the eigenvalues:. https://github.com/CliMA/Oceananigans.jl/blob/5fbd8cd20c5db8e9b11b6175984e7592a08fc874/src/Solvers/poisson_eigenvalues.jl#L8-L11. https://github.com/CliMA/Oceananigans.jl/blob/5fbd8cd20c5db8e9b11b6175984e7592a08fc874/src/Solvers/poisson_eigenvalues.jl#L31. The first eigenvalue is 0, so the `Flat` case is correct. It's also used for the fully FFT-based solver and we know it works in that context. The transforms must be fine too. The grids differ though in how grid metrics are computed, so I suspect the problem is there. I think we've also had issues with `HydrostaticFreeSurfaceModel` and `VerticallyStretchedRectilinearGrid` with `Flat` topologies, but I haven't looked into it systematically. We might be able to convert the internal wave ~~setup~~ dynamics test to a vertically bounded domain and put it on a stretched grid to test these issues.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1849#issuecomment-881907317
https://github.com/CliMA/Oceananigans.jl/issues/1849#issuecomment-881913151:298,Testability,test,test,298,"I think I get the idea, but I still can't imagine what could be wrong with the vertically stretched grids themselves. They seems pretty straightforward. Could you clarify what specific metrics you're talking about that are different?. > We might be able to convert the internal wave setup dynamics test to a vertically bounded domain and put it on a stretched grid to test these issues. This seems like a good idea.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1849#issuecomment-881913151
https://github.com/CliMA/Oceananigans.jl/issues/1849#issuecomment-881913151:368,Testability,test,test,368,"I think I get the idea, but I still can't imagine what could be wrong with the vertically stretched grids themselves. They seems pretty straightforward. Could you clarify what specific metrics you're talking about that are different?. > We might be able to convert the internal wave setup dynamics test to a vertically bounded domain and put it on a stretched grid to test these issues. This seems like a good idea.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1849#issuecomment-881913151
https://github.com/CliMA/Oceananigans.jl/issues/1849#issuecomment-881923453:1603,Safety,avoid,avoid,1603,"> I think I get the idea, but I still can't imagine what could be wrong with the vertically stretched grids themselves. They seems pretty straightforward. Could you clarify what specific metrics you're talking about that are different?; > ; > > We might be able to convert the internal wave setup dynamics test to a vertically bounded domain and put it on a stretched grid to test these issues.; > ; > This seems like a good idea. I don't know which ones are problematic --- once we find those, the problem is solved. The answer might be obvious; it looks like we only redefine `Flat` metrics for `RegularRectilinearGrid`:. https://github.com/CliMA/Oceananigans.jl/blob/326f22aff244ad1f9d0778b9d06184f348db211b/src/Operators/spacings_and_areas_and_volumes.jl#L57-L62. We may just have to use `AbstractGrid` rather than `RegularRectilinearGrid`. I'm not sure why the above functions are specific to `RegularRectilinearGrid` in the first place. @francispoulin you helped with this, right? Do you know?. We're missing many of the horizontal metrics too so I think we should add those, otherwise `Flat` won't work with curvilinear grids, either. EDIT: definitions for flat _area_ metrics are probably not very useful / represent edge cases that need special consideration. So we might just focus on flat _linear_ metrics for now (dx, dy at various locations). Right now additional horizontal linear metrics are irrelevant because there are no rectilinear grids that are stretched in horizontal directions. However, we will need these once we have general stretched rectilinear grids and it might be good to avoid confusion like what's happening in the present issue... I'm putting together a test for rectilinear grids that catches this. I suggest we fix the problem after we have the test. If anyone has more information about `Flat` please chime in.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1849#issuecomment-881923453
https://github.com/CliMA/Oceananigans.jl/issues/1849#issuecomment-881923453:306,Testability,test,test,306,"> I think I get the idea, but I still can't imagine what could be wrong with the vertically stretched grids themselves. They seems pretty straightforward. Could you clarify what specific metrics you're talking about that are different?; > ; > > We might be able to convert the internal wave setup dynamics test to a vertically bounded domain and put it on a stretched grid to test these issues.; > ; > This seems like a good idea. I don't know which ones are problematic --- once we find those, the problem is solved. The answer might be obvious; it looks like we only redefine `Flat` metrics for `RegularRectilinearGrid`:. https://github.com/CliMA/Oceananigans.jl/blob/326f22aff244ad1f9d0778b9d06184f348db211b/src/Operators/spacings_and_areas_and_volumes.jl#L57-L62. We may just have to use `AbstractGrid` rather than `RegularRectilinearGrid`. I'm not sure why the above functions are specific to `RegularRectilinearGrid` in the first place. @francispoulin you helped with this, right? Do you know?. We're missing many of the horizontal metrics too so I think we should add those, otherwise `Flat` won't work with curvilinear grids, either. EDIT: definitions for flat _area_ metrics are probably not very useful / represent edge cases that need special consideration. So we might just focus on flat _linear_ metrics for now (dx, dy at various locations). Right now additional horizontal linear metrics are irrelevant because there are no rectilinear grids that are stretched in horizontal directions. However, we will need these once we have general stretched rectilinear grids and it might be good to avoid confusion like what's happening in the present issue... I'm putting together a test for rectilinear grids that catches this. I suggest we fix the problem after we have the test. If anyone has more information about `Flat` please chime in.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1849#issuecomment-881923453
https://github.com/CliMA/Oceananigans.jl/issues/1849#issuecomment-881923453:376,Testability,test,test,376,"> I think I get the idea, but I still can't imagine what could be wrong with the vertically stretched grids themselves. They seems pretty straightforward. Could you clarify what specific metrics you're talking about that are different?; > ; > > We might be able to convert the internal wave setup dynamics test to a vertically bounded domain and put it on a stretched grid to test these issues.; > ; > This seems like a good idea. I don't know which ones are problematic --- once we find those, the problem is solved. The answer might be obvious; it looks like we only redefine `Flat` metrics for `RegularRectilinearGrid`:. https://github.com/CliMA/Oceananigans.jl/blob/326f22aff244ad1f9d0778b9d06184f348db211b/src/Operators/spacings_and_areas_and_volumes.jl#L57-L62. We may just have to use `AbstractGrid` rather than `RegularRectilinearGrid`. I'm not sure why the above functions are specific to `RegularRectilinearGrid` in the first place. @francispoulin you helped with this, right? Do you know?. We're missing many of the horizontal metrics too so I think we should add those, otherwise `Flat` won't work with curvilinear grids, either. EDIT: definitions for flat _area_ metrics are probably not very useful / represent edge cases that need special consideration. So we might just focus on flat _linear_ metrics for now (dx, dy at various locations). Right now additional horizontal linear metrics are irrelevant because there are no rectilinear grids that are stretched in horizontal directions. However, we will need these once we have general stretched rectilinear grids and it might be good to avoid confusion like what's happening in the present issue... I'm putting together a test for rectilinear grids that catches this. I suggest we fix the problem after we have the test. If anyone has more information about `Flat` please chime in.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1849#issuecomment-881923453
https://github.com/CliMA/Oceananigans.jl/issues/1849#issuecomment-881923453:1688,Testability,test,test,1688,"> I think I get the idea, but I still can't imagine what could be wrong with the vertically stretched grids themselves. They seems pretty straightforward. Could you clarify what specific metrics you're talking about that are different?; > ; > > We might be able to convert the internal wave setup dynamics test to a vertically bounded domain and put it on a stretched grid to test these issues.; > ; > This seems like a good idea. I don't know which ones are problematic --- once we find those, the problem is solved. The answer might be obvious; it looks like we only redefine `Flat` metrics for `RegularRectilinearGrid`:. https://github.com/CliMA/Oceananigans.jl/blob/326f22aff244ad1f9d0778b9d06184f348db211b/src/Operators/spacings_and_areas_and_volumes.jl#L57-L62. We may just have to use `AbstractGrid` rather than `RegularRectilinearGrid`. I'm not sure why the above functions are specific to `RegularRectilinearGrid` in the first place. @francispoulin you helped with this, right? Do you know?. We're missing many of the horizontal metrics too so I think we should add those, otherwise `Flat` won't work with curvilinear grids, either. EDIT: definitions for flat _area_ metrics are probably not very useful / represent edge cases that need special consideration. So we might just focus on flat _linear_ metrics for now (dx, dy at various locations). Right now additional horizontal linear metrics are irrelevant because there are no rectilinear grids that are stretched in horizontal directions. However, we will need these once we have general stretched rectilinear grids and it might be good to avoid confusion like what's happening in the present issue... I'm putting together a test for rectilinear grids that catches this. I suggest we fix the problem after we have the test. If anyone has more information about `Flat` please chime in.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1849#issuecomment-881923453
https://github.com/CliMA/Oceananigans.jl/issues/1849#issuecomment-881923453:1781,Testability,test,test,1781,"> I think I get the idea, but I still can't imagine what could be wrong with the vertically stretched grids themselves. They seems pretty straightforward. Could you clarify what specific metrics you're talking about that are different?; > ; > > We might be able to convert the internal wave setup dynamics test to a vertically bounded domain and put it on a stretched grid to test these issues.; > ; > This seems like a good idea. I don't know which ones are problematic --- once we find those, the problem is solved. The answer might be obvious; it looks like we only redefine `Flat` metrics for `RegularRectilinearGrid`:. https://github.com/CliMA/Oceananigans.jl/blob/326f22aff244ad1f9d0778b9d06184f348db211b/src/Operators/spacings_and_areas_and_volumes.jl#L57-L62. We may just have to use `AbstractGrid` rather than `RegularRectilinearGrid`. I'm not sure why the above functions are specific to `RegularRectilinearGrid` in the first place. @francispoulin you helped with this, right? Do you know?. We're missing many of the horizontal metrics too so I think we should add those, otherwise `Flat` won't work with curvilinear grids, either. EDIT: definitions for flat _area_ metrics are probably not very useful / represent edge cases that need special consideration. So we might just focus on flat _linear_ metrics for now (dx, dy at various locations). Right now additional horizontal linear metrics are irrelevant because there are no rectilinear grids that are stretched in horizontal directions. However, we will need these once we have general stretched rectilinear grids and it might be good to avoid confusion like what's happening in the present issue... I'm putting together a test for rectilinear grids that catches this. I suggest we fix the problem after we have the test. If anyone has more information about `Flat` please chime in.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1849#issuecomment-881923453
https://github.com/CliMA/Oceananigans.jl/issues/1850#issuecomment-878315017:496,Availability,robust,robust,496,"It can't be completely independent because it still needs `using Oceananigans`, but it could be _more_ independent. I agree that's desirable. I think using absolute filepaths rather than referencing the existing output writers, and using more explicit `nodes` functions could help, eg. ```julia; x, y, z = nodes((Face, Face, Center), grid) ; x, y, z = nodes((Center, Center, Center), grid); ```. I think the grid is serialized so you could load it from file (though this feature isn't very robust right now since it doesn't work for stretched grids, for example).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1850#issuecomment-878315017
https://github.com/CliMA/Oceananigans.jl/issues/1850#issuecomment-878315017:446,Performance,load,load,446,"It can't be completely independent because it still needs `using Oceananigans`, but it could be _more_ independent. I agree that's desirable. I think using absolute filepaths rather than referencing the existing output writers, and using more explicit `nodes` functions could help, eg. ```julia; x, y, z = nodes((Face, Face, Center), grid) ; x, y, z = nodes((Center, Center, Center), grid); ```. I think the grid is serialized so you could load it from file (though this feature isn't very robust right now since it doesn't work for stretched grids, for example).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1850#issuecomment-878315017
https://github.com/CliMA/Oceananigans.jl/issues/1850#issuecomment-1022295367:234,Modifiability,variab,variables,234,"Exactly what I am struggling with right now: figuring out how to quickly get x, y, z coordinates when loading an output file created previously (with JLD2 output writer}). So as far as I understand in that case the 'model' and 'grid' variables do not exist. ; `xc = file([""grid/xC""]) `; etc. works, but contains the halos.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1850#issuecomment-1022295367
https://github.com/CliMA/Oceananigans.jl/issues/1850#issuecomment-1022295367:102,Performance,load,loading,102,"Exactly what I am struggling with right now: figuring out how to quickly get x, y, z coordinates when loading an output file created previously (with JLD2 output writer}). So as far as I understand in that case the 'model' and 'grid' variables do not exist. ; `xc = file([""grid/xC""]) `; etc. works, but contains the halos.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1850#issuecomment-1022295367
https://github.com/CliMA/Oceananigans.jl/issues/1850#issuecomment-1479891573:202,Availability,error,error,202,"I'm closing this issue because I'm judging that it's not of current, timely relevance to Oceananigans development. If you would like to make it a higher priority or if you think the issue was closed in error please feel free to re-open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1850#issuecomment-1479891573
https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879252108:408,Security,access,accesses,408,"> ""Flattening"" the model setup section by bringing its sections out into the main list. I agree with absolutely everything except with this. Flattening out the sections makes it hard to situate yourself and find things in the docs. This isn't a problem if you're assuming that users will just read everything from beginning to end, but I think that happens very very rarely, and the overwhelming majority of accesses to the docs are just for consultation. I remember at some point reading about this and how some (non-rigorous) surveys/studies pointed out a preference for a few nested menus in websites, as opposed to a long flat list of sections. But I can't find it right now and until I can find it again you're free to take this as a personal preference :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879252108
https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879259142:838,Availability,error,errors,838,"A more hierarchical organization of the docs is. 1. Introduction; * What's Oceananigans?; * Installation; * Writing your first script; * Do you want to save the world? (by contributing to Oceananigans); - Contributing guide; - Features that need validating; - Features that need documenting and examples; * Gallery; 2. Examples; 3. Building models, running simulations, and post processing; * Grids and computer architectures; * Fields, BoundaryCondition, and AbstractOperations; * IncompressibleModel; * HydrostaticFreeSurfaceModel; * ShallowWaterModel; * Setting initial conditions; * Diffusion, viscosity, and TurbulenceClosures; * Forcing functions; * Coriolis forces; * Buoyancy forces; * Simulation; * OutputWriters; * OutputReaders, post-processing, and plotting; 5. Useful tips; * Using Graphics Processing Units (GPUs); * Common errors and performance pitfalls; 8. Fluid dynamics and ocean physics; * Navier-Stokes and tracer conservation equations; * The hydrostatic approximation and shallow water equations; * The Boussinesq approximation and equations of state for seawater; * Rotating domains and Coriolis forces; * Diffusion, hyperdiffusion, and parameterization of subgrid processes; - Basic models for diffusive processes; - Large eddy simulation; - Boundary layer parameterization; 9. Numerical implementation; * The finite volume discretization on a staggered grid; * Interpolation, differencing, and advection schemes; * Boundary conditions and immersed boundaries; * The pressure correction method for enforcing mass conservation; * Discretization of hydrostatic and non-hydrostatic pressure; * Implicit time-stepping; * Multi-domain simulations and the cubed sphere; 10. Developer guide; 11. Appendix; * References",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879259142
https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879259142:92,Deployability,Install,Installation,92,"A more hierarchical organization of the docs is. 1. Introduction; * What's Oceananigans?; * Installation; * Writing your first script; * Do you want to save the world? (by contributing to Oceananigans); - Contributing guide; - Features that need validating; - Features that need documenting and examples; * Gallery; 2. Examples; 3. Building models, running simulations, and post processing; * Grids and computer architectures; * Fields, BoundaryCondition, and AbstractOperations; * IncompressibleModel; * HydrostaticFreeSurfaceModel; * ShallowWaterModel; * Setting initial conditions; * Diffusion, viscosity, and TurbulenceClosures; * Forcing functions; * Coriolis forces; * Buoyancy forces; * Simulation; * OutputWriters; * OutputReaders, post-processing, and plotting; 5. Useful tips; * Using Graphics Processing Units (GPUs); * Common errors and performance pitfalls; 8. Fluid dynamics and ocean physics; * Navier-Stokes and tracer conservation equations; * The hydrostatic approximation and shallow water equations; * The Boussinesq approximation and equations of state for seawater; * Rotating domains and Coriolis forces; * Diffusion, hyperdiffusion, and parameterization of subgrid processes; - Basic models for diffusive processes; - Large eddy simulation; - Boundary layer parameterization; 9. Numerical implementation; * The finite volume discretization on a staggered grid; * Interpolation, differencing, and advection schemes; * Boundary conditions and immersed boundaries; * The pressure correction method for enforcing mass conservation; * Discretization of hydrostatic and non-hydrostatic pressure; * Implicit time-stepping; * Multi-domain simulations and the cubed sphere; 10. Developer guide; 11. Appendix; * References",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879259142
https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879259142:1161,Modifiability,parameteriz,parameterization,1161,"A more hierarchical organization of the docs is. 1. Introduction; * What's Oceananigans?; * Installation; * Writing your first script; * Do you want to save the world? (by contributing to Oceananigans); - Contributing guide; - Features that need validating; - Features that need documenting and examples; * Gallery; 2. Examples; 3. Building models, running simulations, and post processing; * Grids and computer architectures; * Fields, BoundaryCondition, and AbstractOperations; * IncompressibleModel; * HydrostaticFreeSurfaceModel; * ShallowWaterModel; * Setting initial conditions; * Diffusion, viscosity, and TurbulenceClosures; * Forcing functions; * Coriolis forces; * Buoyancy forces; * Simulation; * OutputWriters; * OutputReaders, post-processing, and plotting; 5. Useful tips; * Using Graphics Processing Units (GPUs); * Common errors and performance pitfalls; 8. Fluid dynamics and ocean physics; * Navier-Stokes and tracer conservation equations; * The hydrostatic approximation and shallow water equations; * The Boussinesq approximation and equations of state for seawater; * Rotating domains and Coriolis forces; * Diffusion, hyperdiffusion, and parameterization of subgrid processes; - Basic models for diffusive processes; - Large eddy simulation; - Boundary layer parameterization; 9. Numerical implementation; * The finite volume discretization on a staggered grid; * Interpolation, differencing, and advection schemes; * Boundary conditions and immersed boundaries; * The pressure correction method for enforcing mass conservation; * Discretization of hydrostatic and non-hydrostatic pressure; * Implicit time-stepping; * Multi-domain simulations and the cubed sphere; 10. Developer guide; 11. Appendix; * References",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879259142
https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879259142:1282,Modifiability,parameteriz,parameterization,1282,"A more hierarchical organization of the docs is. 1. Introduction; * What's Oceananigans?; * Installation; * Writing your first script; * Do you want to save the world? (by contributing to Oceananigans); - Contributing guide; - Features that need validating; - Features that need documenting and examples; * Gallery; 2. Examples; 3. Building models, running simulations, and post processing; * Grids and computer architectures; * Fields, BoundaryCondition, and AbstractOperations; * IncompressibleModel; * HydrostaticFreeSurfaceModel; * ShallowWaterModel; * Setting initial conditions; * Diffusion, viscosity, and TurbulenceClosures; * Forcing functions; * Coriolis forces; * Buoyancy forces; * Simulation; * OutputWriters; * OutputReaders, post-processing, and plotting; 5. Useful tips; * Using Graphics Processing Units (GPUs); * Common errors and performance pitfalls; 8. Fluid dynamics and ocean physics; * Navier-Stokes and tracer conservation equations; * The hydrostatic approximation and shallow water equations; * The Boussinesq approximation and equations of state for seawater; * Rotating domains and Coriolis forces; * Diffusion, hyperdiffusion, and parameterization of subgrid processes; - Basic models for diffusive processes; - Large eddy simulation; - Boundary layer parameterization; 9. Numerical implementation; * The finite volume discretization on a staggered grid; * Interpolation, differencing, and advection schemes; * Boundary conditions and immersed boundaries; * The pressure correction method for enforcing mass conservation; * Discretization of hydrostatic and non-hydrostatic pressure; * Implicit time-stepping; * Multi-domain simulations and the cubed sphere; 10. Developer guide; 11. Appendix; * References",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879259142
https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879259142:849,Performance,perform,performance,849,"A more hierarchical organization of the docs is. 1. Introduction; * What's Oceananigans?; * Installation; * Writing your first script; * Do you want to save the world? (by contributing to Oceananigans); - Contributing guide; - Features that need validating; - Features that need documenting and examples; * Gallery; 2. Examples; 3. Building models, running simulations, and post processing; * Grids and computer architectures; * Fields, BoundaryCondition, and AbstractOperations; * IncompressibleModel; * HydrostaticFreeSurfaceModel; * ShallowWaterModel; * Setting initial conditions; * Diffusion, viscosity, and TurbulenceClosures; * Forcing functions; * Coriolis forces; * Buoyancy forces; * Simulation; * OutputWriters; * OutputReaders, post-processing, and plotting; 5. Useful tips; * Using Graphics Processing Units (GPUs); * Common errors and performance pitfalls; 8. Fluid dynamics and ocean physics; * Navier-Stokes and tracer conservation equations; * The hydrostatic approximation and shallow water equations; * The Boussinesq approximation and equations of state for seawater; * Rotating domains and Coriolis forces; * Diffusion, hyperdiffusion, and parameterization of subgrid processes; - Basic models for diffusive processes; - Large eddy simulation; - Boundary layer parameterization; 9. Numerical implementation; * The finite volume discretization on a staggered grid; * Interpolation, differencing, and advection schemes; * Boundary conditions and immersed boundaries; * The pressure correction method for enforcing mass conservation; * Discretization of hydrostatic and non-hydrostatic pressure; * Implicit time-stepping; * Multi-domain simulations and the cubed sphere; 10. Developer guide; 11. Appendix; * References",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879259142
https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879259142:246,Security,validat,validating,246,"A more hierarchical organization of the docs is. 1. Introduction; * What's Oceananigans?; * Installation; * Writing your first script; * Do you want to save the world? (by contributing to Oceananigans); - Contributing guide; - Features that need validating; - Features that need documenting and examples; * Gallery; 2. Examples; 3. Building models, running simulations, and post processing; * Grids and computer architectures; * Fields, BoundaryCondition, and AbstractOperations; * IncompressibleModel; * HydrostaticFreeSurfaceModel; * ShallowWaterModel; * Setting initial conditions; * Diffusion, viscosity, and TurbulenceClosures; * Forcing functions; * Coriolis forces; * Buoyancy forces; * Simulation; * OutputWriters; * OutputReaders, post-processing, and plotting; 5. Useful tips; * Using Graphics Processing Units (GPUs); * Common errors and performance pitfalls; 8. Fluid dynamics and ocean physics; * Navier-Stokes and tracer conservation equations; * The hydrostatic approximation and shallow water equations; * The Boussinesq approximation and equations of state for seawater; * Rotating domains and Coriolis forces; * Diffusion, hyperdiffusion, and parameterization of subgrid processes; - Basic models for diffusive processes; - Large eddy simulation; - Boundary layer parameterization; 9. Numerical implementation; * The finite volume discretization on a staggered grid; * Interpolation, differencing, and advection schemes; * Boundary conditions and immersed boundaries; * The pressure correction method for enforcing mass conservation; * Discretization of hydrostatic and non-hydrostatic pressure; * Implicit time-stepping; * Multi-domain simulations and the cubed sphere; 10. Developer guide; 11. Appendix; * References",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879259142
https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879259142:218,Usability,guid,guide,218,"A more hierarchical organization of the docs is. 1. Introduction; * What's Oceananigans?; * Installation; * Writing your first script; * Do you want to save the world? (by contributing to Oceananigans); - Contributing guide; - Features that need validating; - Features that need documenting and examples; * Gallery; 2. Examples; 3. Building models, running simulations, and post processing; * Grids and computer architectures; * Fields, BoundaryCondition, and AbstractOperations; * IncompressibleModel; * HydrostaticFreeSurfaceModel; * ShallowWaterModel; * Setting initial conditions; * Diffusion, viscosity, and TurbulenceClosures; * Forcing functions; * Coriolis forces; * Buoyancy forces; * Simulation; * OutputWriters; * OutputReaders, post-processing, and plotting; 5. Useful tips; * Using Graphics Processing Units (GPUs); * Common errors and performance pitfalls; 8. Fluid dynamics and ocean physics; * Navier-Stokes and tracer conservation equations; * The hydrostatic approximation and shallow water equations; * The Boussinesq approximation and equations of state for seawater; * Rotating domains and Coriolis forces; * Diffusion, hyperdiffusion, and parameterization of subgrid processes; - Basic models for diffusive processes; - Large eddy simulation; - Boundary layer parameterization; 9. Numerical implementation; * The finite volume discretization on a staggered grid; * Interpolation, differencing, and advection schemes; * Boundary conditions and immersed boundaries; * The pressure correction method for enforcing mass conservation; * Discretization of hydrostatic and non-hydrostatic pressure; * Implicit time-stepping; * Multi-domain simulations and the cubed sphere; 10. Developer guide; 11. Appendix; * References",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879259142
https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879259142:1703,Usability,guid,guide,1703,"A more hierarchical organization of the docs is. 1. Introduction; * What's Oceananigans?; * Installation; * Writing your first script; * Do you want to save the world? (by contributing to Oceananigans); - Contributing guide; - Features that need validating; - Features that need documenting and examples; * Gallery; 2. Examples; 3. Building models, running simulations, and post processing; * Grids and computer architectures; * Fields, BoundaryCondition, and AbstractOperations; * IncompressibleModel; * HydrostaticFreeSurfaceModel; * ShallowWaterModel; * Setting initial conditions; * Diffusion, viscosity, and TurbulenceClosures; * Forcing functions; * Coriolis forces; * Buoyancy forces; * Simulation; * OutputWriters; * OutputReaders, post-processing, and plotting; 5. Useful tips; * Using Graphics Processing Units (GPUs); * Common errors and performance pitfalls; 8. Fluid dynamics and ocean physics; * Navier-Stokes and tracer conservation equations; * The hydrostatic approximation and shallow water equations; * The Boussinesq approximation and equations of state for seawater; * Rotating domains and Coriolis forces; * Diffusion, hyperdiffusion, and parameterization of subgrid processes; - Basic models for diffusive processes; - Large eddy simulation; - Boundary layer parameterization; 9. Numerical implementation; * The finite volume discretization on a staggered grid; * Interpolation, differencing, and advection schemes; * Boundary conditions and immersed boundaries; * The pressure correction method for enforcing mass conservation; * Discretization of hydrostatic and non-hydrostatic pressure; * Implicit time-stepping; * Multi-domain simulations and the cubed sphere; 10. Developer guide; 11. Appendix; * References",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879259142
https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879265116:677,Availability,error,errors,677,"> A more hierarchical organization of the docs is; > ; > 1. Introduction; > ; > * What's Oceananigans?; > * Installation; > * Writing your first script; > 2. Examples; > 3. Model setup; > ; > * Fields, BoundaryCondition, and AbstractOperations; > * IncompressibleModel; > * HydrostaticFreeSurfaceModel; > * ShallowWaterModel; > * Setting initial conditions; > * Diffusion, viscosity, and TurbulenceClosures; > * Forcing functions; > * Coriolis forces; > * Buoyancy forces; > 4. Simulations and post processing; > ; > * Simulation; > * OutputWriters; > * OutputReaders, post-processing, and plotting; > 5. Useful tips; > ; > * Using Graphics Processing Units (GPUs); > * Common errors and performance pitfalls; > 6. Contributor's guide; > 7. Gallery (this should be way higher eventually, but we need more recent content to motivate that...); > 8. Physics and numerical implementation; > 9. Appendix. I wholeheartedly agree with this structure :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879265116
https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879265116:108,Deployability,Install,Installation,108,"> A more hierarchical organization of the docs is; > ; > 1. Introduction; > ; > * What's Oceananigans?; > * Installation; > * Writing your first script; > 2. Examples; > 3. Model setup; > ; > * Fields, BoundaryCondition, and AbstractOperations; > * IncompressibleModel; > * HydrostaticFreeSurfaceModel; > * ShallowWaterModel; > * Setting initial conditions; > * Diffusion, viscosity, and TurbulenceClosures; > * Forcing functions; > * Coriolis forces; > * Buoyancy forces; > 4. Simulations and post processing; > ; > * Simulation; > * OutputWriters; > * OutputReaders, post-processing, and plotting; > 5. Useful tips; > ; > * Using Graphics Processing Units (GPUs); > * Common errors and performance pitfalls; > 6. Contributor's guide; > 7. Gallery (this should be way higher eventually, but we need more recent content to motivate that...); > 8. Physics and numerical implementation; > 9. Appendix. I wholeheartedly agree with this structure :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879265116
https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879265116:688,Performance,perform,performance,688,"> A more hierarchical organization of the docs is; > ; > 1. Introduction; > ; > * What's Oceananigans?; > * Installation; > * Writing your first script; > 2. Examples; > 3. Model setup; > ; > * Fields, BoundaryCondition, and AbstractOperations; > * IncompressibleModel; > * HydrostaticFreeSurfaceModel; > * ShallowWaterModel; > * Setting initial conditions; > * Diffusion, viscosity, and TurbulenceClosures; > * Forcing functions; > * Coriolis forces; > * Buoyancy forces; > 4. Simulations and post processing; > ; > * Simulation; > * OutputWriters; > * OutputReaders, post-processing, and plotting; > 5. Useful tips; > ; > * Using Graphics Processing Units (GPUs); > * Common errors and performance pitfalls; > 6. Contributor's guide; > 7. Gallery (this should be way higher eventually, but we need more recent content to motivate that...); > 8. Physics and numerical implementation; > 9. Appendix. I wholeheartedly agree with this structure :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879265116
https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879265116:729,Usability,guid,guide,729,"> A more hierarchical organization of the docs is; > ; > 1. Introduction; > ; > * What's Oceananigans?; > * Installation; > * Writing your first script; > 2. Examples; > 3. Model setup; > ; > * Fields, BoundaryCondition, and AbstractOperations; > * IncompressibleModel; > * HydrostaticFreeSurfaceModel; > * ShallowWaterModel; > * Setting initial conditions; > * Diffusion, viscosity, and TurbulenceClosures; > * Forcing functions; > * Coriolis forces; > * Buoyancy forces; > 4. Simulations and post processing; > ; > * Simulation; > * OutputWriters; > * OutputReaders, post-processing, and plotting; > 5. Useful tips; > ; > * Using Graphics Processing Units (GPUs); > * Common errors and performance pitfalls; > 6. Contributor's guide; > 7. Gallery (this should be way higher eventually, but we need more recent content to motivate that...); > 8. Physics and numerical implementation; > 9. Appendix. I wholeheartedly agree with this structure :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879265116
https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880689429:29,Modifiability,enhance,enhance,29,"Yeap, lets add them now and enhance/improve later",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880689429
https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880741401:255,Deployability,update,update,255,"I'm thinking about updating `benchmarks.md` with the new benchmark result tables and graphs. Should I do it now or wait until the docs get refactored?; It's only a single file in the appendix section, but I'm not too sure how me opening a PR on it now to update it will affect the grander refactoring plan.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880741401
https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880741401:139,Modifiability,refactor,refactored,139,"I'm thinking about updating `benchmarks.md` with the new benchmark result tables and graphs. Should I do it now or wait until the docs get refactored?; It's only a single file in the appendix section, but I'm not too sure how me opening a PR on it now to update it will affect the grander refactoring plan.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880741401
https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880741401:289,Modifiability,refactor,refactoring,289,"I'm thinking about updating `benchmarks.md` with the new benchmark result tables and graphs. Should I do it now or wait until the docs get refactored?; It's only a single file in the appendix section, but I'm not too sure how me opening a PR on it now to update it will affect the grander refactoring plan.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880741401
https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880741401:29,Testability,benchmark,benchmarks,29,"I'm thinking about updating `benchmarks.md` with the new benchmark result tables and graphs. Should I do it now or wait until the docs get refactored?; It's only a single file in the appendix section, but I'm not too sure how me opening a PR on it now to update it will affect the grander refactoring plan.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880741401
https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880741401:57,Testability,benchmark,benchmark,57,"I'm thinking about updating `benchmarks.md` with the new benchmark result tables and graphs. Should I do it now or wait until the docs get refactored?; It's only a single file in the appendix section, but I'm not too sure how me opening a PR on it now to update it will affect the grander refactoring plan.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880741401
https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880742532:259,Deployability,update,update,259,"> I'm thinking about updating `benchmarks.md` with the new benchmark result tables and graphs. Should I do it now or wait until the docs get refactored?; > It's only a single file in the appendix section, but I'm not too sure how me opening a PR on it now to update it will affect the grander refactoring plan. As @glwagner said, this refactoring is a long term plan. I think running new benchmarks now will definitely be a positive change and (imo) a great contribution to the docs ;)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880742532
https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880742532:141,Modifiability,refactor,refactored,141,"> I'm thinking about updating `benchmarks.md` with the new benchmark result tables and graphs. Should I do it now or wait until the docs get refactored?; > It's only a single file in the appendix section, but I'm not too sure how me opening a PR on it now to update it will affect the grander refactoring plan. As @glwagner said, this refactoring is a long term plan. I think running new benchmarks now will definitely be a positive change and (imo) a great contribution to the docs ;)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880742532
https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880742532:293,Modifiability,refactor,refactoring,293,"> I'm thinking about updating `benchmarks.md` with the new benchmark result tables and graphs. Should I do it now or wait until the docs get refactored?; > It's only a single file in the appendix section, but I'm not too sure how me opening a PR on it now to update it will affect the grander refactoring plan. As @glwagner said, this refactoring is a long term plan. I think running new benchmarks now will definitely be a positive change and (imo) a great contribution to the docs ;)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880742532
https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880742532:335,Modifiability,refactor,refactoring,335,"> I'm thinking about updating `benchmarks.md` with the new benchmark result tables and graphs. Should I do it now or wait until the docs get refactored?; > It's only a single file in the appendix section, but I'm not too sure how me opening a PR on it now to update it will affect the grander refactoring plan. As @glwagner said, this refactoring is a long term plan. I think running new benchmarks now will definitely be a positive change and (imo) a great contribution to the docs ;)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880742532
https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880742532:31,Testability,benchmark,benchmarks,31,"> I'm thinking about updating `benchmarks.md` with the new benchmark result tables and graphs. Should I do it now or wait until the docs get refactored?; > It's only a single file in the appendix section, but I'm not too sure how me opening a PR on it now to update it will affect the grander refactoring plan. As @glwagner said, this refactoring is a long term plan. I think running new benchmarks now will definitely be a positive change and (imo) a great contribution to the docs ;)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880742532
https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880742532:59,Testability,benchmark,benchmark,59,"> I'm thinking about updating `benchmarks.md` with the new benchmark result tables and graphs. Should I do it now or wait until the docs get refactored?; > It's only a single file in the appendix section, but I'm not too sure how me opening a PR on it now to update it will affect the grander refactoring plan. As @glwagner said, this refactoring is a long term plan. I think running new benchmarks now will definitely be a positive change and (imo) a great contribution to the docs ;)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880742532
https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880742532:388,Testability,benchmark,benchmarks,388,"> I'm thinking about updating `benchmarks.md` with the new benchmark result tables and graphs. Should I do it now or wait until the docs get refactored?; > It's only a single file in the appendix section, but I'm not too sure how me opening a PR on it now to update it will affect the grander refactoring plan. As @glwagner said, this refactoring is a long term plan. I think running new benchmarks now will definitely be a positive change and (imo) a great contribution to the docs ;)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880742532
https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880829840:90,Deployability,update,update,90,"Hmm, it could make sense to make benchmarking results more prominent. Please feel free to update the benchmarks. More generally I think we need a streamlined way of updating the benchmarks so that we can recreate them easily for (for example) every minor release.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880829840
https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880829840:255,Deployability,release,release,255,"Hmm, it could make sense to make benchmarking results more prominent. Please feel free to update the benchmarks. More generally I think we need a streamlined way of updating the benchmarks so that we can recreate them easily for (for example) every minor release.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880829840
https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880829840:33,Testability,benchmark,benchmarking,33,"Hmm, it could make sense to make benchmarking results more prominent. Please feel free to update the benchmarks. More generally I think we need a streamlined way of updating the benchmarks so that we can recreate them easily for (for example) every minor release.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880829840
https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880829840:101,Testability,benchmark,benchmarks,101,"Hmm, it could make sense to make benchmarking results more prominent. Please feel free to update the benchmarks. More generally I think we need a streamlined way of updating the benchmarks so that we can recreate them easily for (for example) every minor release.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880829840
https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880829840:178,Testability,benchmark,benchmarks,178,"Hmm, it could make sense to make benchmarking results more prominent. Please feel free to update the benchmarks. More generally I think we need a streamlined way of updating the benchmarks so that we can recreate them easily for (for example) every minor release.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880829840
https://github.com/CliMA/Oceananigans.jl/issues/1856#issuecomment-879274829:94,Safety,predict,prediction,94,"It's used for some of the simulations in this paper to mitigate a too-low subgrid tracer flux prediction in free convection:. https://journals.ametsoc.org/view/journals/phoc/51/5/JPO-D-20-0178.1.xml. In cases that lack sufficient shear it seems that AMD can underpredict the eddy viscosity near boundaries. Almost all cases of interest have some mean shear though --- free convection is essentially an edge case. Others may use it too, I don't know.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1856#issuecomment-879274829
https://github.com/CliMA/Oceananigans.jl/pull/1859#issuecomment-880639149:208,Availability,error,error,208,> Looks good and hope the tests all pass.; > ; > Should any new tests be added?. I think we should test that we can use `ContinuousBoundaryFunction` on an auxiliary field and run `fill_halo_regions!` without error. Or better yet show that it produces the right thing.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1859#issuecomment-880639149
https://github.com/CliMA/Oceananigans.jl/pull/1859#issuecomment-880639149:121,Deployability,Continuous,ContinuousBoundaryFunction,121,> Looks good and hope the tests all pass.; > ; > Should any new tests be added?. I think we should test that we can use `ContinuousBoundaryFunction` on an auxiliary field and run `fill_halo_regions!` without error. Or better yet show that it produces the right thing.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1859#issuecomment-880639149
https://github.com/CliMA/Oceananigans.jl/pull/1859#issuecomment-880639149:26,Testability,test,tests,26,> Looks good and hope the tests all pass.; > ; > Should any new tests be added?. I think we should test that we can use `ContinuousBoundaryFunction` on an auxiliary field and run `fill_halo_regions!` without error. Or better yet show that it produces the right thing.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1859#issuecomment-880639149
https://github.com/CliMA/Oceananigans.jl/pull/1859#issuecomment-880639149:64,Testability,test,tests,64,> Looks good and hope the tests all pass.; > ; > Should any new tests be added?. I think we should test that we can use `ContinuousBoundaryFunction` on an auxiliary field and run `fill_halo_regions!` without error. Or better yet show that it produces the right thing.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1859#issuecomment-880639149
https://github.com/CliMA/Oceananigans.jl/pull/1859#issuecomment-880639149:99,Testability,test,test,99,> Looks good and hope the tests all pass.; > ; > Should any new tests be added?. I think we should test that we can use `ContinuousBoundaryFunction` on an auxiliary field and run `fill_halo_regions!` without error. Or better yet show that it produces the right thing.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1859#issuecomment-880639149
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880765565:170,Performance,multi-thread,multi-threaded,170,"Would be good to do some profiling (probably with a system profiler like perf), to understand where time is spent. The kernels using KernelAbstractions are automatically multi-threaded.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880765565
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880826423:921,Integrability,depend,dependencies,921,"To fill in a few more details for @hennyg888 --- _almost all_ multithreading in Oceananigans is achieved via [`KernelAbstractions.jl`](https://github.com/JuliaGPU/KernelAbstractions.jl). Improving efficiency for Oceananigans kernels likely means contributing to `KernelAbstractions.jl` (which @vchuravy may or may not be excited about :-D). More specifically, all tendency evaluations, non-communicative / non-periodic halo fills (periodic halo filling uses Base broadcasting and thus is not parallelized), integrals (like the hydrostatic pressure integral, or vertical velocity computation in `HydrostaticFreeSurfaceModel`), evaluation of diagnostics, and broadcasting with fields all use KernelAbstractions via the Oceananigans function `launch!`:. https://github.com/CliMA/Oceananigans.jl/blob/6e39d3fcc098c69ac207cc21be759cf6bd3ec604/src/Utils/kernel_launching.jl#L71-L90. The line . ```julia; event = loop!(args...; dependencies=dependencies, kwargs...); ```. launches a kernel, using [`KernelAbstractions` syntax](https://juliagpu.github.io/KernelAbstractions.jl/stable/#Quickstart-1). `event` is a token that can be ""waited"" on if we need to. So either we can improve multithreading by changing what happens when `loop!` is called --- or, possibly, by refining the dependency tree so that we can launch more kernels simultaneously. The second optimization is probably more important for small problems. You have mostly benchmarked fairly large problems so I don't we'd see much speed for them. But I'm not 100% sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880826423
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880826423:934,Integrability,depend,dependencies,934,"To fill in a few more details for @hennyg888 --- _almost all_ multithreading in Oceananigans is achieved via [`KernelAbstractions.jl`](https://github.com/JuliaGPU/KernelAbstractions.jl). Improving efficiency for Oceananigans kernels likely means contributing to `KernelAbstractions.jl` (which @vchuravy may or may not be excited about :-D). More specifically, all tendency evaluations, non-communicative / non-periodic halo fills (periodic halo filling uses Base broadcasting and thus is not parallelized), integrals (like the hydrostatic pressure integral, or vertical velocity computation in `HydrostaticFreeSurfaceModel`), evaluation of diagnostics, and broadcasting with fields all use KernelAbstractions via the Oceananigans function `launch!`:. https://github.com/CliMA/Oceananigans.jl/blob/6e39d3fcc098c69ac207cc21be759cf6bd3ec604/src/Utils/kernel_launching.jl#L71-L90. The line . ```julia; event = loop!(args...; dependencies=dependencies, kwargs...); ```. launches a kernel, using [`KernelAbstractions` syntax](https://juliagpu.github.io/KernelAbstractions.jl/stable/#Quickstart-1). `event` is a token that can be ""waited"" on if we need to. So either we can improve multithreading by changing what happens when `loop!` is called --- or, possibly, by refining the dependency tree so that we can launch more kernels simultaneously. The second optimization is probably more important for small problems. You have mostly benchmarked fairly large problems so I don't we'd see much speed for them. But I'm not 100% sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880826423
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880826423:1272,Integrability,depend,dependency,1272,"To fill in a few more details for @hennyg888 --- _almost all_ multithreading in Oceananigans is achieved via [`KernelAbstractions.jl`](https://github.com/JuliaGPU/KernelAbstractions.jl). Improving efficiency for Oceananigans kernels likely means contributing to `KernelAbstractions.jl` (which @vchuravy may or may not be excited about :-D). More specifically, all tendency evaluations, non-communicative / non-periodic halo fills (periodic halo filling uses Base broadcasting and thus is not parallelized), integrals (like the hydrostatic pressure integral, or vertical velocity computation in `HydrostaticFreeSurfaceModel`), evaluation of diagnostics, and broadcasting with fields all use KernelAbstractions via the Oceananigans function `launch!`:. https://github.com/CliMA/Oceananigans.jl/blob/6e39d3fcc098c69ac207cc21be759cf6bd3ec604/src/Utils/kernel_launching.jl#L71-L90. The line . ```julia; event = loop!(args...; dependencies=dependencies, kwargs...); ```. launches a kernel, using [`KernelAbstractions` syntax](https://juliagpu.github.io/KernelAbstractions.jl/stable/#Quickstart-1). `event` is a token that can be ""waited"" on if we need to. So either we can improve multithreading by changing what happens when `loop!` is called --- or, possibly, by refining the dependency tree so that we can launch more kernels simultaneously. The second optimization is probably more important for small problems. You have mostly benchmarked fairly large problems so I don't we'd see much speed for them. But I'm not 100% sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880826423
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880826423:1350,Performance,optimiz,optimization,1350,"To fill in a few more details for @hennyg888 --- _almost all_ multithreading in Oceananigans is achieved via [`KernelAbstractions.jl`](https://github.com/JuliaGPU/KernelAbstractions.jl). Improving efficiency for Oceananigans kernels likely means contributing to `KernelAbstractions.jl` (which @vchuravy may or may not be excited about :-D). More specifically, all tendency evaluations, non-communicative / non-periodic halo fills (periodic halo filling uses Base broadcasting and thus is not parallelized), integrals (like the hydrostatic pressure integral, or vertical velocity computation in `HydrostaticFreeSurfaceModel`), evaluation of diagnostics, and broadcasting with fields all use KernelAbstractions via the Oceananigans function `launch!`:. https://github.com/CliMA/Oceananigans.jl/blob/6e39d3fcc098c69ac207cc21be759cf6bd3ec604/src/Utils/kernel_launching.jl#L71-L90. The line . ```julia; event = loop!(args...; dependencies=dependencies, kwargs...); ```. launches a kernel, using [`KernelAbstractions` syntax](https://juliagpu.github.io/KernelAbstractions.jl/stable/#Quickstart-1). `event` is a token that can be ""waited"" on if we need to. So either we can improve multithreading by changing what happens when `loop!` is called --- or, possibly, by refining the dependency tree so that we can launch more kernels simultaneously. The second optimization is probably more important for small problems. You have mostly benchmarked fairly large problems so I don't we'd see much speed for them. But I'm not 100% sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880826423
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880826423:1426,Testability,benchmark,benchmarked,1426,"To fill in a few more details for @hennyg888 --- _almost all_ multithreading in Oceananigans is achieved via [`KernelAbstractions.jl`](https://github.com/JuliaGPU/KernelAbstractions.jl). Improving efficiency for Oceananigans kernels likely means contributing to `KernelAbstractions.jl` (which @vchuravy may or may not be excited about :-D). More specifically, all tendency evaluations, non-communicative / non-periodic halo fills (periodic halo filling uses Base broadcasting and thus is not parallelized), integrals (like the hydrostatic pressure integral, or vertical velocity computation in `HydrostaticFreeSurfaceModel`), evaluation of diagnostics, and broadcasting with fields all use KernelAbstractions via the Oceananigans function `launch!`:. https://github.com/CliMA/Oceananigans.jl/blob/6e39d3fcc098c69ac207cc21be759cf6bd3ec604/src/Utils/kernel_launching.jl#L71-L90. The line . ```julia; event = loop!(args...; dependencies=dependencies, kwargs...); ```. launches a kernel, using [`KernelAbstractions` syntax](https://juliagpu.github.io/KernelAbstractions.jl/stable/#Quickstart-1). `event` is a token that can be ""waited"" on if we need to. So either we can improve multithreading by changing what happens when `loop!` is called --- or, possibly, by refining the dependency tree so that we can launch more kernels simultaneously. The second optimization is probably more important for small problems. You have mostly benchmarked fairly large problems so I don't we'd see much speed for them. But I'm not 100% sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880826423
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880838040:62,Performance,multi-thread,multi-threaded,62,"@hennyg888 do you have the same problems using MPI instead of multi-threaded, and on the same CPU ( Intel(R) Xeon(R) Platinum 8260 CPU @ 2.40GHz ). ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880838040
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880842022:170,Testability,benchmark,benchmarks,170,For MPI I ran it on up to 128 Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz CPUs with efficiencies at around 80%. I think I have some results for MPI weak and strong scaling benchmarks posted here at the bottom #1722.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880842022
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880844335:66,Performance,multi-thread,multi-threading,66,"Thanks everyone for your feedback. @vchuravy , great to know that multi-threading is built in! . I agree that profiling would be a good way to determine why we get not great efficiency. I have not used perf but we can look into it. Also, do you know of benchmarking others have done using `KernelAbstractions` on threads that we could look at for comparison?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880844335
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880844335:253,Testability,benchmark,benchmarking,253,"Thanks everyone for your feedback. @vchuravy , great to know that multi-threading is built in! . I agree that profiling would be a good way to determine why we get not great efficiency. I have not used perf but we can look into it. Also, do you know of benchmarking others have done using `KernelAbstractions` on threads that we could look at for comparison?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880844335
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880844335:25,Usability,feedback,feedback,25,"Thanks everyone for your feedback. @vchuravy , great to know that multi-threading is built in! . I agree that profiling would be a good way to determine why we get not great efficiency. I have not used perf but we can look into it. Also, do you know of benchmarking others have done using `KernelAbstractions` on threads that we could look at for comparison?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880844335
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880901251:95,Testability,test,tests,95,@francispoulin (and @hennyg888 ) no worries. We can use what we have too. . I think both these tests ( #1861 and #1722 ) are on a single CPU (just lots of cores)?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880901251
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880903279:33,Testability,test,tests,33,"Sorry, I was thinking of the MPI tests (since that's what I'm looking at for the slides right now). I agree that for one CPU vs one GPU, it would be nice to use the same CPU and GPU in the different tests. I know we can specify the GPU type in the SLURM script. Maybe we can do the sme for the CPU?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880903279
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880903279:199,Testability,test,tests,199,"Sorry, I was thinking of the MPI tests (since that's what I'm looking at for the slides right now). I agree that for one CPU vs one GPU, it would be nice to use the same CPU and GPU in the different tests. I know we can specify the GPU type in the SLURM script. Maybe we can do the sme for the CPU?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880903279
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880913594:23,Testability,benchmark,benchmarking,23,"> Also, do you know of benchmarking others have done using `KernelAbstractions` on threads that we could look at for comparison?. I did some benchmarks in the beginning, but mostly focused on strong scaling.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880913594
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880913594:141,Testability,benchmark,benchmarks,141,"> Also, do you know of benchmarking others have done using `KernelAbstractions` on threads that we could look at for comparison?. I did some benchmarks in the beginning, but mostly focused on strong scaling.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880913594
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880919738:25,Testability,benchmark,benchmarking,25,"> > Also, do you know of benchmarking others have done using `KernelAbstractions` on threads that we could look at for comparison?; > ; > I did some benchmarks in the beginning, but mostly focused on strong scaling. Thanks for the information. Can you point me to where some of these results might be found?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880919738
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880919738:149,Testability,benchmark,benchmarks,149,"> > Also, do you know of benchmarking others have done using `KernelAbstractions` on threads that we could look at for comparison?; > ; > I did some benchmarks in the beginning, but mostly focused on strong scaling. Thanks for the information. Can you point me to where some of these results might be found?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880919738
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-881473478:52,Testability,benchmark,benchmarks,52,"@christophernhill @francispoulin I ran the threaded benchmarks up to 32 threads on 32 cores with Julia 1.6.0 and on the same CPUs as what the MPI benchmarks used. Makes sense since they're all benchmarking parallel computing efficiency. ; ```; Oceananigans v0.58.9; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, broadwell); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :. Shallow water model weak scaling with multithreading benchmark; ;  size  threads  min  median  mean  max  memory  allocs  samples ; ;  (8192, 512)  1  1.458 s  1.458 s  1.458 s  1.458 s  1.37 MiB  2318  4 ;  (8192, 1024)  2  2.925 s  2.989 s  2.989 s  3.052 s  18.06 MiB  1076944  2 ;  (8192, 2048)  4  2.296 s  2.381 s  2.397 s  2.515 s  13.60 MiB  760190  3 ;  (8192, 4096)  8  2.347 s  2.369 s  2.377 s  2.415 s  16.36 MiB  891860  3 ;  (8192, 8192)  16  2.407 s  2.548 s  2.517 s  2.595 s  17.44 MiB  863941  3 ;  (8192, 16384)  32  3.023 s  3.069 s  3.069 s  3.115 s  23.03 MiB  1034063  2 ; . Shallow water model weak multithreading scaling speedup; ;  size  threads  slowdown  efficiency  memory  allocs ; ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-881473478
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-881473478:146,Testability,benchmark,benchmarks,146,"@christophernhill @francispoulin I ran the threaded benchmarks up to 32 threads on 32 cores with Julia 1.6.0 and on the same CPUs as what the MPI benchmarks used. Makes sense since they're all benchmarking parallel computing efficiency. ; ```; Oceananigans v0.58.9; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, broadwell); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :. Shallow water model weak scaling with multithreading benchmark; ;  size  threads  min  median  mean  max  memory  allocs  samples ; ;  (8192, 512)  1  1.458 s  1.458 s  1.458 s  1.458 s  1.37 MiB  2318  4 ;  (8192, 1024)  2  2.925 s  2.989 s  2.989 s  3.052 s  18.06 MiB  1076944  2 ;  (8192, 2048)  4  2.296 s  2.381 s  2.397 s  2.515 s  13.60 MiB  760190  3 ;  (8192, 4096)  8  2.347 s  2.369 s  2.377 s  2.415 s  16.36 MiB  891860  3 ;  (8192, 8192)  16  2.407 s  2.548 s  2.517 s  2.595 s  17.44 MiB  863941  3 ;  (8192, 16384)  32  3.023 s  3.069 s  3.069 s  3.115 s  23.03 MiB  1034063  2 ; . Shallow water model weak multithreading scaling speedup; ;  size  threads  slowdown  efficiency  memory  allocs ; ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-881473478
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-881473478:193,Testability,benchmark,benchmarking,193,"@christophernhill @francispoulin I ran the threaded benchmarks up to 32 threads on 32 cores with Julia 1.6.0 and on the same CPUs as what the MPI benchmarks used. Makes sense since they're all benchmarking parallel computing efficiency. ; ```; Oceananigans v0.58.9; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, broadwell); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :. Shallow water model weak scaling with multithreading benchmark; ;  size  threads  min  median  mean  max  memory  allocs  samples ; ;  (8192, 512)  1  1.458 s  1.458 s  1.458 s  1.458 s  1.37 MiB  2318  4 ;  (8192, 1024)  2  2.925 s  2.989 s  2.989 s  3.052 s  18.06 MiB  1076944  2 ;  (8192, 2048)  4  2.296 s  2.381 s  2.397 s  2.515 s  13.60 MiB  760190  3 ;  (8192, 4096)  8  2.347 s  2.369 s  2.377 s  2.415 s  16.36 MiB  891860  3 ;  (8192, 8192)  16  2.407 s  2.548 s  2.517 s  2.595 s  17.44 MiB  863941  3 ;  (8192, 16384)  32  3.023 s  3.069 s  3.069 s  3.115 s  23.03 MiB  1034063  2 ; . Shallow water model weak multithreading scaling speedup; ;  size  threads  slowdown  efficiency  memory  allocs ; ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-881473478
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-881473478:865,Testability,benchmark,benchmark,865,"@christophernhill @francispoulin I ran the threaded benchmarks up to 32 threads on 32 cores with Julia 1.6.0 and on the same CPUs as what the MPI benchmarks used. Makes sense since they're all benchmarking parallel computing efficiency. ; ```; Oceananigans v0.58.9; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, broadwell); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :. Shallow water model weak scaling with multithreading benchmark; ;  size  threads  min  median  mean  max  memory  allocs  samples ; ;  (8192, 512)  1  1.458 s  1.458 s  1.458 s  1.458 s  1.37 MiB  2318  4 ;  (8192, 1024)  2  2.925 s  2.989 s  2.989 s  3.052 s  18.06 MiB  1076944  2 ;  (8192, 2048)  4  2.296 s  2.381 s  2.397 s  2.515 s  13.60 MiB  760190  3 ;  (8192, 4096)  8  2.347 s  2.369 s  2.377 s  2.415 s  16.36 MiB  891860  3 ;  (8192, 8192)  16  2.407 s  2.548 s  2.517 s  2.595 s  17.44 MiB  863941  3 ;  (8192, 16384)  32  3.023 s  3.069 s  3.069 s  3.115 s  23.03 MiB  1034063  2 ; . Shallow water model weak multithreading scaling speedup; ;  size  threads  slowdown  efficiency  memory  allocs ; ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-881473478
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-881473478:2510,Testability,benchmark,benchmarks,2510,"s  1.458 s  1.458 s  1.37 MiB  2318  4 ;  (8192, 1024)  2  2.925 s  2.989 s  2.989 s  3.052 s  18.06 MiB  1076944  2 ;  (8192, 2048)  4  2.296 s  2.381 s  2.397 s  2.515 s  13.60 MiB  760190  3 ;  (8192, 4096)  8  2.347 s  2.369 s  2.377 s  2.415 s  16.36 MiB  891860  3 ;  (8192, 8192)  16  2.407 s  2.548 s  2.517 s  2.595 s  17.44 MiB  863941  3 ;  (8192, 16384)  32  3.023 s  3.069 s  3.069 s  3.115 s  23.03 MiB  1034063  2 ; . Shallow water model weak multithreading scaling speedup; ;  size  threads  slowdown  efficiency  memory  allocs ; ;  (8192, 512)  1  1.0  1.0  1.0  1.0 ;  (8192, 1024)  2  2.04972  0.487872  13.2156  464.601 ;  (8192, 2048)  4  1.63302  0.612363  9.95278  327.951 ;  (8192, 4096)  8  1.62507  0.615359  11.9706  384.754 ;  (8192, 8192)  16  1.74747  0.572257  12.755  372.71 ;  (8192, 16384)  32  2.10486  0.47509  16.846  446.101 ; ; ```; Also, after reviewing the new benchmarks and comparing them to the old benchmarks currently displayed on [`benchmarks.md`](https://github.com/CliMA/Oceananigans.jl/blob/master/docs/src/appendix/benchmarks.md), it seems like all the CPU vs GPU benchmarks use the same CPU and all the MPI and threaded benchmarks use another type of CPUs.; The MPI and threaded benchmarks use Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz, while every other benchmark including the CPU to GPU speedup benchmarks use Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz. ; This is mainly because the speedup benchmarks need a single better CPU and the MPI benchmarks need many CPUs and the exact types worked out to be like this on the cluster.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-881473478
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-881473478:2551,Testability,benchmark,benchmarks,2551,"s  1.458 s  1.458 s  1.37 MiB  2318  4 ;  (8192, 1024)  2  2.925 s  2.989 s  2.989 s  3.052 s  18.06 MiB  1076944  2 ;  (8192, 2048)  4  2.296 s  2.381 s  2.397 s  2.515 s  13.60 MiB  760190  3 ;  (8192, 4096)  8  2.347 s  2.369 s  2.377 s  2.415 s  16.36 MiB  891860  3 ;  (8192, 8192)  16  2.407 s  2.548 s  2.517 s  2.595 s  17.44 MiB  863941  3 ;  (8192, 16384)  32  3.023 s  3.069 s  3.069 s  3.115 s  23.03 MiB  1034063  2 ; . Shallow water model weak multithreading scaling speedup; ;  size  threads  slowdown  efficiency  memory  allocs ; ;  (8192, 512)  1  1.0  1.0  1.0  1.0 ;  (8192, 1024)  2  2.04972  0.487872  13.2156  464.601 ;  (8192, 2048)  4  1.63302  0.612363  9.95278  327.951 ;  (8192, 4096)  8  1.62507  0.615359  11.9706  384.754 ;  (8192, 8192)  16  1.74747  0.572257  12.755  372.71 ;  (8192, 16384)  32  2.10486  0.47509  16.846  446.101 ; ; ```; Also, after reviewing the new benchmarks and comparing them to the old benchmarks currently displayed on [`benchmarks.md`](https://github.com/CliMA/Oceananigans.jl/blob/master/docs/src/appendix/benchmarks.md), it seems like all the CPU vs GPU benchmarks use the same CPU and all the MPI and threaded benchmarks use another type of CPUs.; The MPI and threaded benchmarks use Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz, while every other benchmark including the CPU to GPU speedup benchmarks use Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz. ; This is mainly because the speedup benchmarks need a single better CPU and the MPI benchmarks need many CPUs and the exact types worked out to be like this on the cluster.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-881473478
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-881473478:2587,Testability,benchmark,benchmarks,2587,"s  1.458 s  1.458 s  1.37 MiB  2318  4 ;  (8192, 1024)  2  2.925 s  2.989 s  2.989 s  3.052 s  18.06 MiB  1076944  2 ;  (8192, 2048)  4  2.296 s  2.381 s  2.397 s  2.515 s  13.60 MiB  760190  3 ;  (8192, 4096)  8  2.347 s  2.369 s  2.377 s  2.415 s  16.36 MiB  891860  3 ;  (8192, 8192)  16  2.407 s  2.548 s  2.517 s  2.595 s  17.44 MiB  863941  3 ;  (8192, 16384)  32  3.023 s  3.069 s  3.069 s  3.115 s  23.03 MiB  1034063  2 ; . Shallow water model weak multithreading scaling speedup; ;  size  threads  slowdown  efficiency  memory  allocs ; ;  (8192, 512)  1  1.0  1.0  1.0  1.0 ;  (8192, 1024)  2  2.04972  0.487872  13.2156  464.601 ;  (8192, 2048)  4  1.63302  0.612363  9.95278  327.951 ;  (8192, 4096)  8  1.62507  0.615359  11.9706  384.754 ;  (8192, 8192)  16  1.74747  0.572257  12.755  372.71 ;  (8192, 16384)  32  2.10486  0.47509  16.846  446.101 ; ; ```; Also, after reviewing the new benchmarks and comparing them to the old benchmarks currently displayed on [`benchmarks.md`](https://github.com/CliMA/Oceananigans.jl/blob/master/docs/src/appendix/benchmarks.md), it seems like all the CPU vs GPU benchmarks use the same CPU and all the MPI and threaded benchmarks use another type of CPUs.; The MPI and threaded benchmarks use Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz, while every other benchmark including the CPU to GPU speedup benchmarks use Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz. ; This is mainly because the speedup benchmarks need a single better CPU and the MPI benchmarks need many CPUs and the exact types worked out to be like this on the cluster.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-881473478
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-881473478:2674,Testability,benchmark,benchmarks,2674,"s  1.458 s  1.458 s  1.37 MiB  2318  4 ;  (8192, 1024)  2  2.925 s  2.989 s  2.989 s  3.052 s  18.06 MiB  1076944  2 ;  (8192, 2048)  4  2.296 s  2.381 s  2.397 s  2.515 s  13.60 MiB  760190  3 ;  (8192, 4096)  8  2.347 s  2.369 s  2.377 s  2.415 s  16.36 MiB  891860  3 ;  (8192, 8192)  16  2.407 s  2.548 s  2.517 s  2.595 s  17.44 MiB  863941  3 ;  (8192, 16384)  32  3.023 s  3.069 s  3.069 s  3.115 s  23.03 MiB  1034063  2 ; . Shallow water model weak multithreading scaling speedup; ;  size  threads  slowdown  efficiency  memory  allocs ; ;  (8192, 512)  1  1.0  1.0  1.0  1.0 ;  (8192, 1024)  2  2.04972  0.487872  13.2156  464.601 ;  (8192, 2048)  4  1.63302  0.612363  9.95278  327.951 ;  (8192, 4096)  8  1.62507  0.615359  11.9706  384.754 ;  (8192, 8192)  16  1.74747  0.572257  12.755  372.71 ;  (8192, 16384)  32  2.10486  0.47509  16.846  446.101 ; ; ```; Also, after reviewing the new benchmarks and comparing them to the old benchmarks currently displayed on [`benchmarks.md`](https://github.com/CliMA/Oceananigans.jl/blob/master/docs/src/appendix/benchmarks.md), it seems like all the CPU vs GPU benchmarks use the same CPU and all the MPI and threaded benchmarks use another type of CPUs.; The MPI and threaded benchmarks use Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz, while every other benchmark including the CPU to GPU speedup benchmarks use Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz. ; This is mainly because the speedup benchmarks need a single better CPU and the MPI benchmarks need many CPUs and the exact types worked out to be like this on the cluster.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-881473478
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-881473478:2723,Testability,benchmark,benchmarks,2723,"s  1.458 s  1.458 s  1.37 MiB  2318  4 ;  (8192, 1024)  2  2.925 s  2.989 s  2.989 s  3.052 s  18.06 MiB  1076944  2 ;  (8192, 2048)  4  2.296 s  2.381 s  2.397 s  2.515 s  13.60 MiB  760190  3 ;  (8192, 4096)  8  2.347 s  2.369 s  2.377 s  2.415 s  16.36 MiB  891860  3 ;  (8192, 8192)  16  2.407 s  2.548 s  2.517 s  2.595 s  17.44 MiB  863941  3 ;  (8192, 16384)  32  3.023 s  3.069 s  3.069 s  3.115 s  23.03 MiB  1034063  2 ; . Shallow water model weak multithreading scaling speedup; ;  size  threads  slowdown  efficiency  memory  allocs ; ;  (8192, 512)  1  1.0  1.0  1.0  1.0 ;  (8192, 1024)  2  2.04972  0.487872  13.2156  464.601 ;  (8192, 2048)  4  1.63302  0.612363  9.95278  327.951 ;  (8192, 4096)  8  1.62507  0.615359  11.9706  384.754 ;  (8192, 8192)  16  1.74747  0.572257  12.755  372.71 ;  (8192, 16384)  32  2.10486  0.47509  16.846  446.101 ; ; ```; Also, after reviewing the new benchmarks and comparing them to the old benchmarks currently displayed on [`benchmarks.md`](https://github.com/CliMA/Oceananigans.jl/blob/master/docs/src/appendix/benchmarks.md), it seems like all the CPU vs GPU benchmarks use the same CPU and all the MPI and threaded benchmarks use another type of CPUs.; The MPI and threaded benchmarks use Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz, while every other benchmark including the CPU to GPU speedup benchmarks use Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz. ; This is mainly because the speedup benchmarks need a single better CPU and the MPI benchmarks need many CPUs and the exact types worked out to be like this on the cluster.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-881473478
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-881473478:2780,Testability,benchmark,benchmarks,2780,"s  1.458 s  1.458 s  1.37 MiB  2318  4 ;  (8192, 1024)  2  2.925 s  2.989 s  2.989 s  3.052 s  18.06 MiB  1076944  2 ;  (8192, 2048)  4  2.296 s  2.381 s  2.397 s  2.515 s  13.60 MiB  760190  3 ;  (8192, 4096)  8  2.347 s  2.369 s  2.377 s  2.415 s  16.36 MiB  891860  3 ;  (8192, 8192)  16  2.407 s  2.548 s  2.517 s  2.595 s  17.44 MiB  863941  3 ;  (8192, 16384)  32  3.023 s  3.069 s  3.069 s  3.115 s  23.03 MiB  1034063  2 ; . Shallow water model weak multithreading scaling speedup; ;  size  threads  slowdown  efficiency  memory  allocs ; ;  (8192, 512)  1  1.0  1.0  1.0  1.0 ;  (8192, 1024)  2  2.04972  0.487872  13.2156  464.601 ;  (8192, 2048)  4  1.63302  0.612363  9.95278  327.951 ;  (8192, 4096)  8  1.62507  0.615359  11.9706  384.754 ;  (8192, 8192)  16  1.74747  0.572257  12.755  372.71 ;  (8192, 16384)  32  2.10486  0.47509  16.846  446.101 ; ; ```; Also, after reviewing the new benchmarks and comparing them to the old benchmarks currently displayed on [`benchmarks.md`](https://github.com/CliMA/Oceananigans.jl/blob/master/docs/src/appendix/benchmarks.md), it seems like all the CPU vs GPU benchmarks use the same CPU and all the MPI and threaded benchmarks use another type of CPUs.; The MPI and threaded benchmarks use Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz, while every other benchmark including the CPU to GPU speedup benchmarks use Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz. ; This is mainly because the speedup benchmarks need a single better CPU and the MPI benchmarks need many CPUs and the exact types worked out to be like this on the cluster.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-881473478
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-881473478:2839,Testability,benchmark,benchmarks,2839,"s  1.458 s  1.458 s  1.37 MiB  2318  4 ;  (8192, 1024)  2  2.925 s  2.989 s  2.989 s  3.052 s  18.06 MiB  1076944  2 ;  (8192, 2048)  4  2.296 s  2.381 s  2.397 s  2.515 s  13.60 MiB  760190  3 ;  (8192, 4096)  8  2.347 s  2.369 s  2.377 s  2.415 s  16.36 MiB  891860  3 ;  (8192, 8192)  16  2.407 s  2.548 s  2.517 s  2.595 s  17.44 MiB  863941  3 ;  (8192, 16384)  32  3.023 s  3.069 s  3.069 s  3.115 s  23.03 MiB  1034063  2 ; . Shallow water model weak multithreading scaling speedup; ;  size  threads  slowdown  efficiency  memory  allocs ; ;  (8192, 512)  1  1.0  1.0  1.0  1.0 ;  (8192, 1024)  2  2.04972  0.487872  13.2156  464.601 ;  (8192, 2048)  4  1.63302  0.612363  9.95278  327.951 ;  (8192, 4096)  8  1.62507  0.615359  11.9706  384.754 ;  (8192, 8192)  16  1.74747  0.572257  12.755  372.71 ;  (8192, 16384)  32  2.10486  0.47509  16.846  446.101 ; ; ```; Also, after reviewing the new benchmarks and comparing them to the old benchmarks currently displayed on [`benchmarks.md`](https://github.com/CliMA/Oceananigans.jl/blob/master/docs/src/appendix/benchmarks.md), it seems like all the CPU vs GPU benchmarks use the same CPU and all the MPI and threaded benchmarks use another type of CPUs.; The MPI and threaded benchmarks use Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz, while every other benchmark including the CPU to GPU speedup benchmarks use Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz. ; This is mainly because the speedup benchmarks need a single better CPU and the MPI benchmarks need many CPUs and the exact types worked out to be like this on the cluster.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-881473478
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-881473478:2915,Testability,benchmark,benchmark,2915,"s  1.458 s  1.458 s  1.37 MiB  2318  4 ;  (8192, 1024)  2  2.925 s  2.989 s  2.989 s  3.052 s  18.06 MiB  1076944  2 ;  (8192, 2048)  4  2.296 s  2.381 s  2.397 s  2.515 s  13.60 MiB  760190  3 ;  (8192, 4096)  8  2.347 s  2.369 s  2.377 s  2.415 s  16.36 MiB  891860  3 ;  (8192, 8192)  16  2.407 s  2.548 s  2.517 s  2.595 s  17.44 MiB  863941  3 ;  (8192, 16384)  32  3.023 s  3.069 s  3.069 s  3.115 s  23.03 MiB  1034063  2 ; . Shallow water model weak multithreading scaling speedup; ;  size  threads  slowdown  efficiency  memory  allocs ; ;  (8192, 512)  1  1.0  1.0  1.0  1.0 ;  (8192, 1024)  2  2.04972  0.487872  13.2156  464.601 ;  (8192, 2048)  4  1.63302  0.612363  9.95278  327.951 ;  (8192, 4096)  8  1.62507  0.615359  11.9706  384.754 ;  (8192, 8192)  16  1.74747  0.572257  12.755  372.71 ;  (8192, 16384)  32  2.10486  0.47509  16.846  446.101 ; ; ```; Also, after reviewing the new benchmarks and comparing them to the old benchmarks currently displayed on [`benchmarks.md`](https://github.com/CliMA/Oceananigans.jl/blob/master/docs/src/appendix/benchmarks.md), it seems like all the CPU vs GPU benchmarks use the same CPU and all the MPI and threaded benchmarks use another type of CPUs.; The MPI and threaded benchmarks use Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz, while every other benchmark including the CPU to GPU speedup benchmarks use Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz. ; This is mainly because the speedup benchmarks need a single better CPU and the MPI benchmarks need many CPUs and the exact types worked out to be like this on the cluster.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-881473478
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-881473478:2958,Testability,benchmark,benchmarks,2958,"s  1.458 s  1.458 s  1.37 MiB  2318  4 ;  (8192, 1024)  2  2.925 s  2.989 s  2.989 s  3.052 s  18.06 MiB  1076944  2 ;  (8192, 2048)  4  2.296 s  2.381 s  2.397 s  2.515 s  13.60 MiB  760190  3 ;  (8192, 4096)  8  2.347 s  2.369 s  2.377 s  2.415 s  16.36 MiB  891860  3 ;  (8192, 8192)  16  2.407 s  2.548 s  2.517 s  2.595 s  17.44 MiB  863941  3 ;  (8192, 16384)  32  3.023 s  3.069 s  3.069 s  3.115 s  23.03 MiB  1034063  2 ; . Shallow water model weak multithreading scaling speedup; ;  size  threads  slowdown  efficiency  memory  allocs ; ;  (8192, 512)  1  1.0  1.0  1.0  1.0 ;  (8192, 1024)  2  2.04972  0.487872  13.2156  464.601 ;  (8192, 2048)  4  1.63302  0.612363  9.95278  327.951 ;  (8192, 4096)  8  1.62507  0.615359  11.9706  384.754 ;  (8192, 8192)  16  1.74747  0.572257  12.755  372.71 ;  (8192, 16384)  32  2.10486  0.47509  16.846  446.101 ; ; ```; Also, after reviewing the new benchmarks and comparing them to the old benchmarks currently displayed on [`benchmarks.md`](https://github.com/CliMA/Oceananigans.jl/blob/master/docs/src/appendix/benchmarks.md), it seems like all the CPU vs GPU benchmarks use the same CPU and all the MPI and threaded benchmarks use another type of CPUs.; The MPI and threaded benchmarks use Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz, while every other benchmark including the CPU to GPU speedup benchmarks use Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz. ; This is mainly because the speedup benchmarks need a single better CPU and the MPI benchmarks need many CPUs and the exact types worked out to be like this on the cluster.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-881473478
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-881473478:3054,Testability,benchmark,benchmarks,3054,"s  1.458 s  1.458 s  1.37 MiB  2318  4 ;  (8192, 1024)  2  2.925 s  2.989 s  2.989 s  3.052 s  18.06 MiB  1076944  2 ;  (8192, 2048)  4  2.296 s  2.381 s  2.397 s  2.515 s  13.60 MiB  760190  3 ;  (8192, 4096)  8  2.347 s  2.369 s  2.377 s  2.415 s  16.36 MiB  891860  3 ;  (8192, 8192)  16  2.407 s  2.548 s  2.517 s  2.595 s  17.44 MiB  863941  3 ;  (8192, 16384)  32  3.023 s  3.069 s  3.069 s  3.115 s  23.03 MiB  1034063  2 ; . Shallow water model weak multithreading scaling speedup; ;  size  threads  slowdown  efficiency  memory  allocs ; ;  (8192, 512)  1  1.0  1.0  1.0  1.0 ;  (8192, 1024)  2  2.04972  0.487872  13.2156  464.601 ;  (8192, 2048)  4  1.63302  0.612363  9.95278  327.951 ;  (8192, 4096)  8  1.62507  0.615359  11.9706  384.754 ;  (8192, 8192)  16  1.74747  0.572257  12.755  372.71 ;  (8192, 16384)  32  2.10486  0.47509  16.846  446.101 ; ; ```; Also, after reviewing the new benchmarks and comparing them to the old benchmarks currently displayed on [`benchmarks.md`](https://github.com/CliMA/Oceananigans.jl/blob/master/docs/src/appendix/benchmarks.md), it seems like all the CPU vs GPU benchmarks use the same CPU and all the MPI and threaded benchmarks use another type of CPUs.; The MPI and threaded benchmarks use Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz, while every other benchmark including the CPU to GPU speedup benchmarks use Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz. ; This is mainly because the speedup benchmarks need a single better CPU and the MPI benchmarks need many CPUs and the exact types worked out to be like this on the cluster.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-881473478
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-881473478:3102,Testability,benchmark,benchmarks,3102,"s  1.458 s  1.458 s  1.37 MiB  2318  4 ;  (8192, 1024)  2  2.925 s  2.989 s  2.989 s  3.052 s  18.06 MiB  1076944  2 ;  (8192, 2048)  4  2.296 s  2.381 s  2.397 s  2.515 s  13.60 MiB  760190  3 ;  (8192, 4096)  8  2.347 s  2.369 s  2.377 s  2.415 s  16.36 MiB  891860  3 ;  (8192, 8192)  16  2.407 s  2.548 s  2.517 s  2.595 s  17.44 MiB  863941  3 ;  (8192, 16384)  32  3.023 s  3.069 s  3.069 s  3.115 s  23.03 MiB  1034063  2 ; . Shallow water model weak multithreading scaling speedup; ;  size  threads  slowdown  efficiency  memory  allocs ; ;  (8192, 512)  1  1.0  1.0  1.0  1.0 ;  (8192, 1024)  2  2.04972  0.487872  13.2156  464.601 ;  (8192, 2048)  4  1.63302  0.612363  9.95278  327.951 ;  (8192, 4096)  8  1.62507  0.615359  11.9706  384.754 ;  (8192, 8192)  16  1.74747  0.572257  12.755  372.71 ;  (8192, 16384)  32  2.10486  0.47509  16.846  446.101 ; ; ```; Also, after reviewing the new benchmarks and comparing them to the old benchmarks currently displayed on [`benchmarks.md`](https://github.com/CliMA/Oceananigans.jl/blob/master/docs/src/appendix/benchmarks.md), it seems like all the CPU vs GPU benchmarks use the same CPU and all the MPI and threaded benchmarks use another type of CPUs.; The MPI and threaded benchmarks use Intel(R) Xeon(R) CPU E5-2683 v4 @ 2.10GHz, while every other benchmark including the CPU to GPU speedup benchmarks use Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz. ; This is mainly because the speedup benchmarks need a single better CPU and the MPI benchmarks need many CPUs and the exact types worked out to be like this on the cluster.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-881473478
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-881986070:955,Performance,perform,performance,955,"> Interesting idea @christophernhill . For the last results that @hennyg888 posted in #1722, I did some calculations and found the following.; > ; > ```; > GPU; > N=256 3.0e9; > N=128 2.6e9; > N=64 6.6e8; > ; > CPU; > N=256 8.6e6; > N=128 9.1e6; > N=64 9.0e6; > ```; > ; > In an article that @ali-ramadhan referenced on the slack channel recently, a paper using a shallow water model in python, Roullet and Gaillard (2021), said they were getting 2 TFlops per second using a thousand cores. We are getting 3 GigaFlops on GPU and 9 MegaFlops.; > ; > Certainly very good speedup since we have O(400) with `WENO5`, but this makes me wonder whether we could do better?; > ; > But to answer your question, when @hennyg888 has the data, we can certainly produce these plots easily enough (unless there is a problem that I'm missing). We have to do more work to compare with Roullet and Gaillard (2021). First of all, there are typos in the paper: sometimes the performance is listed as 2 GFlops, other times as 2 TFlops. Second --- if I understand the situation correctly --- I don't think we've ever measured floating point operations per second. The numbers you've calculated are grid points per second; however we do many floating point operations per grid point. Roullet and Gaillard (2021) estimate their code performs something like 700-800 Flops per grid point. ![image](https://user-images.githubusercontent.com/15271942/126053492-345154c2-22e2-4af8-a898-ac68e889733d.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-881986070
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-881986070:1309,Performance,perform,performs,1309,"> Interesting idea @christophernhill . For the last results that @hennyg888 posted in #1722, I did some calculations and found the following.; > ; > ```; > GPU; > N=256 3.0e9; > N=128 2.6e9; > N=64 6.6e8; > ; > CPU; > N=256 8.6e6; > N=128 9.1e6; > N=64 9.0e6; > ```; > ; > In an article that @ali-ramadhan referenced on the slack channel recently, a paper using a shallow water model in python, Roullet and Gaillard (2021), said they were getting 2 TFlops per second using a thousand cores. We are getting 3 GigaFlops on GPU and 9 MegaFlops.; > ; > Certainly very good speedup since we have O(400) with `WENO5`, but this makes me wonder whether we could do better?; > ; > But to answer your question, when @hennyg888 has the data, we can certainly produce these plots easily enough (unless there is a problem that I'm missing). We have to do more work to compare with Roullet and Gaillard (2021). First of all, there are typos in the paper: sometimes the performance is listed as 2 GFlops, other times as 2 TFlops. Second --- if I understand the situation correctly --- I don't think we've ever measured floating point operations per second. The numbers you've calculated are grid points per second; however we do many floating point operations per grid point. Roullet and Gaillard (2021) estimate their code performs something like 700-800 Flops per grid point. ![image](https://user-images.githubusercontent.com/15271942/126053492-345154c2-22e2-4af8-a898-ac68e889733d.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-881986070
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-885981005:34,Testability,test,testing,34,I put together some utilities for testing multithreading versus Base.threads for a simple kernel:. https://github.com/glwagner/multithreaded-stencils. I've used a new repo because it might be worthwhile to test threaded computations in other programming languages.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-885981005
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-885981005:206,Testability,test,test,206,I put together some utilities for testing multithreading versus Base.threads for a simple kernel:. https://github.com/glwagner/multithreaded-stencils. I've used a new repo because it might be worthwhile to test threaded computations in other programming languages.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-885981005
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-885981005:83,Usability,simpl,simple,83,I put together some utilities for testing multithreading versus Base.threads for a simple kernel:. https://github.com/glwagner/multithreaded-stencils. I've used a new repo because it might be worthwhile to test threaded computations in other programming languages.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-885981005
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886072589:240,Integrability,depend,dependent,240,"Very nice work @glwagner , and thanks for making this. Lots of good stuff here. In your calculations, you find that there is saturation at 16 threads. I might guess that you have 16 cores on one node? I would think that this should be node dependent. Also, in the table, might it be possible to compute the efficiency as well? I think that's more standard than speed up.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886072589
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886073990:257,Integrability,depend,dependent,257,"> Very nice work @glwagner , and thanks for making this. Lots of good stuff here.; > ; > ; > ; > In your calculations, you find that there is saturation at 16 threads. I might guess that you have 16 cores on one node? I would think that this should be node dependent.; > ; > ; > ; > Also, in the table, might it be possible to compute the efficiency as well? I think that's more standard than speed up. . Ah, this machine has 48 cores. Since threading has an overhead cost, we expect saturation at some point. It's surprising that this happens at just 16 cores for such a large problem (512^3) though. We can calculate more metrics for sure. I think it would be worthwhile to investigate whether other threading paradigms scale differently for the same problem. Numba + parallel accelerator might be a good test case. @hennyg888 would you be interested in that?. Here are some docs:. https://numba.pydata.org/numba-doc/latest/user/parallel.html",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886073990
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886073990:807,Testability,test,test,807,"> Very nice work @glwagner , and thanks for making this. Lots of good stuff here.; > ; > ; > ; > In your calculations, you find that there is saturation at 16 threads. I might guess that you have 16 cores on one node? I would think that this should be node dependent.; > ; > ; > ; > Also, in the table, might it be possible to compute the efficiency as well? I think that's more standard than speed up. . Ah, this machine has 48 cores. Since threading has an overhead cost, we expect saturation at some point. It's surprising that this happens at just 16 cores for such a large problem (512^3) though. We can calculate more metrics for sure. I think it would be worthwhile to investigate whether other threading paradigms scale differently for the same problem. Numba + parallel accelerator might be a good test case. @hennyg888 would you be interested in that?. Here are some docs:. https://numba.pydata.org/numba-doc/latest/user/parallel.html",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886073990
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886074548:481,Performance,multi-thread,multi-threading,481,"I agree that I would expect it to saturate at higher than 16 if there were 48 cores, but clearly I'm wrong. Getting another benchmark would be a good idea. I'm happy to consider the numba + parallel idea since that would be good to test the architecture. This [mini-course](https://github.com/omlins/parallel-gpu-workshop-JuliaCon21) did give some threaded examples to solve the diffusion equation in 3D. I wonder if we might want to ask Ludovic if they have done any scalings for multi-threading?. I'm happy to discuss this with @hennyg888 on Monday and see what we come up with. Others are happy to join the discussion if they like.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886074548
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886074548:124,Testability,benchmark,benchmark,124,"I agree that I would expect it to saturate at higher than 16 if there were 48 cores, but clearly I'm wrong. Getting another benchmark would be a good idea. I'm happy to consider the numba + parallel idea since that would be good to test the architecture. This [mini-course](https://github.com/omlins/parallel-gpu-workshop-JuliaCon21) did give some threaded examples to solve the diffusion equation in 3D. I wonder if we might want to ask Ludovic if they have done any scalings for multi-threading?. I'm happy to discuss this with @hennyg888 on Monday and see what we come up with. Others are happy to join the discussion if they like.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886074548
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886074548:232,Testability,test,test,232,"I agree that I would expect it to saturate at higher than 16 if there were 48 cores, but clearly I'm wrong. Getting another benchmark would be a good idea. I'm happy to consider the numba + parallel idea since that would be good to test the architecture. This [mini-course](https://github.com/omlins/parallel-gpu-workshop-JuliaCon21) did give some threaded examples to solve the diffusion equation in 3D. I wonder if we might want to ask Ludovic if they have done any scalings for multi-threading?. I'm happy to discuss this with @hennyg888 on Monday and see what we come up with. Others are happy to join the discussion if they like.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886074548
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886074548:89,Usability,clear,clearly,89,"I agree that I would expect it to saturate at higher than 16 if there were 48 cores, but clearly I'm wrong. Getting another benchmark would be a good idea. I'm happy to consider the numba + parallel idea since that would be good to test the architecture. This [mini-course](https://github.com/omlins/parallel-gpu-workshop-JuliaCon21) did give some threaded examples to solve the diffusion equation in 3D. I wonder if we might want to ask Ludovic if they have done any scalings for multi-threading?. I'm happy to discuss this with @hennyg888 on Monday and see what we come up with. Others are happy to join the discussion if they like.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886074548
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886076610:299,Availability,down,down,299,"Below is a link to a paper that compares the scalability of multi-threading in Python, Julia and Chapel. . Brief Summary: They find that none of them do as well as OpenMP but give some reasons as to why. But they do find some improvements going up to 64 threads, but the effiicency in some cases go down to 20%. It seems that Python might do better on low numbers of threads but Julia does better on more. This was last year so I am sure this should probably redone. Also, I should mention I don't believe their problem is like ours but it's an example and has some pictures, so that's nice to see. https://hal.inria.fr/hal-02879767/document",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886076610
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886076610:45,Performance,scalab,scalability,45,"Below is a link to a paper that compares the scalability of multi-threading in Python, Julia and Chapel. . Brief Summary: They find that none of them do as well as OpenMP but give some reasons as to why. But they do find some improvements going up to 64 threads, but the effiicency in some cases go down to 20%. It seems that Python might do better on low numbers of threads but Julia does better on more. This was last year so I am sure this should probably redone. Also, I should mention I don't believe their problem is like ours but it's an example and has some pictures, so that's nice to see. https://hal.inria.fr/hal-02879767/document",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886076610
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886076610:60,Performance,multi-thread,multi-threading,60,"Below is a link to a paper that compares the scalability of multi-threading in Python, Julia and Chapel. . Brief Summary: They find that none of them do as well as OpenMP but give some reasons as to why. But they do find some improvements going up to 64 threads, but the effiicency in some cases go down to 20%. It seems that Python might do better on low numbers of threads but Julia does better on more. This was last year so I am sure this should probably redone. Also, I should mention I don't believe their problem is like ours but it's an example and has some pictures, so that's nice to see. https://hal.inria.fr/hal-02879767/document",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886076610
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886090304:249,Integrability,depend,dependent,249,"> > Very nice work @glwagner , and thanks for making this. Lots of good stuff here.; > > In your calculations, you find that there is saturation at 16 threads. I might guess that you have 16 cores on one node? I would think that this should be node dependent.; > > Also, in the table, might it be possible to compute the efficiency as well? I think that's more standard than speed up.; > ; > Ah, this machine has 48 cores. Since threading has an overhead cost, we expect saturation at some point. It's surprising that this happens at just 16 cores for such a large problem (512^3) though.; > ; > We can calculate more metrics for sure.; > ; > I think it would be worthwhile to investigate whether other threading paradigms scale differently for the same problem. Numba + parallel accelerator might be a good test case. @hennyg888 would you be interested in that?; > ; > Here are some docs:; > ; > https://numba.pydata.org/numba-doc/latest/user/parallel.html. You run out of memory bandwidth at some point - usually before you get to saturate all the cores for something; like diffusion. So some of 16 thread drop off could be that. . I guess we could get even more minimalist and check a multi-threaded stream benchmark to see that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886090304
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886090304:1188,Performance,multi-thread,multi-threaded,1188,"> > Very nice work @glwagner , and thanks for making this. Lots of good stuff here.; > > In your calculations, you find that there is saturation at 16 threads. I might guess that you have 16 cores on one node? I would think that this should be node dependent.; > > Also, in the table, might it be possible to compute the efficiency as well? I think that's more standard than speed up.; > ; > Ah, this machine has 48 cores. Since threading has an overhead cost, we expect saturation at some point. It's surprising that this happens at just 16 cores for such a large problem (512^3) though.; > ; > We can calculate more metrics for sure.; > ; > I think it would be worthwhile to investigate whether other threading paradigms scale differently for the same problem. Numba + parallel accelerator might be a good test case. @hennyg888 would you be interested in that?; > ; > Here are some docs:; > ; > https://numba.pydata.org/numba-doc/latest/user/parallel.html. You run out of memory bandwidth at some point - usually before you get to saturate all the cores for something; like diffusion. So some of 16 thread drop off could be that. . I guess we could get even more minimalist and check a multi-threaded stream benchmark to see that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886090304
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886090304:808,Testability,test,test,808,"> > Very nice work @glwagner , and thanks for making this. Lots of good stuff here.; > > In your calculations, you find that there is saturation at 16 threads. I might guess that you have 16 cores on one node? I would think that this should be node dependent.; > > Also, in the table, might it be possible to compute the efficiency as well? I think that's more standard than speed up.; > ; > Ah, this machine has 48 cores. Since threading has an overhead cost, we expect saturation at some point. It's surprising that this happens at just 16 cores for such a large problem (512^3) though.; > ; > We can calculate more metrics for sure.; > ; > I think it would be worthwhile to investigate whether other threading paradigms scale differently for the same problem. Numba + parallel accelerator might be a good test case. @hennyg888 would you be interested in that?; > ; > Here are some docs:; > ; > https://numba.pydata.org/numba-doc/latest/user/parallel.html. You run out of memory bandwidth at some point - usually before you get to saturate all the cores for something; like diffusion. So some of 16 thread drop off could be that. . I guess we could get even more minimalist and check a multi-threaded stream benchmark to see that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886090304
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886090304:1210,Testability,benchmark,benchmark,1210,"> > Very nice work @glwagner , and thanks for making this. Lots of good stuff here.; > > In your calculations, you find that there is saturation at 16 threads. I might guess that you have 16 cores on one node? I would think that this should be node dependent.; > > Also, in the table, might it be possible to compute the efficiency as well? I think that's more standard than speed up.; > ; > Ah, this machine has 48 cores. Since threading has an overhead cost, we expect saturation at some point. It's surprising that this happens at just 16 cores for such a large problem (512^3) though.; > ; > We can calculate more metrics for sure.; > ; > I think it would be worthwhile to investigate whether other threading paradigms scale differently for the same problem. Numba + parallel accelerator might be a good test case. @hennyg888 would you be interested in that?; > ; > Here are some docs:; > ; > https://numba.pydata.org/numba-doc/latest/user/parallel.html. You run out of memory bandwidth at some point - usually before you get to saturate all the cores for something; like diffusion. So some of 16 thread drop off could be that. . I guess we could get even more minimalist and check a multi-threaded stream benchmark to see that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886090304
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886218106:117,Testability,benchmark,benchmark,117,"I am open to trying whatever simple example you suggest @christophernhill , but I'm not sure what you mean by stream benchmark. Sorry.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886218106
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886218106:29,Usability,simpl,simple,29,"I am open to trying whatever simple example you suggest @christophernhill , but I'm not sure what you mean by stream benchmark. Sorry.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886218106
https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-1479892147:26,Testability,benchmark,benchmarks,26,Thanks @hennyg888 for the benchmarks!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-1479892147
https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-881661216:21,Testability,log,log,21,"Perhaps we could put log this info at the `@debug` level?. We've also discussed logging initialization at @info (so that everyone sees it). I think logging individual tendency kernel timings might be hard because they are completed asychronously, but we can log how long it takes to compute _all_ the tendencies.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-881661216
https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-881661216:80,Testability,log,logging,80,"Perhaps we could put log this info at the `@debug` level?. We've also discussed logging initialization at @info (so that everyone sees it). I think logging individual tendency kernel timings might be hard because they are completed asychronously, but we can log how long it takes to compute _all_ the tendencies.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-881661216
https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-881661216:148,Testability,log,logging,148,"Perhaps we could put log this info at the `@debug` level?. We've also discussed logging initialization at @info (so that everyone sees it). I think logging individual tendency kernel timings might be hard because they are completed asychronously, but we can log how long it takes to compute _all_ the tendencies.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-881661216
https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-881661216:258,Testability,log,log,258,"Perhaps we could put log this info at the `@debug` level?. We've also discussed logging initialization at @info (so that everyone sees it). I think logging individual tendency kernel timings might be hard because they are completed asychronously, but we can log how long it takes to compute _all_ the tendencies.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-881661216
https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-882111021:30,Testability,log,log,30,"We could also introduce a new log level, eg `TIMINGS` or something. Might not be good to hijack `@debug` --- it's used for other stuff, so the timing logs might get buried. Like this 100-iteration simulation:. ```; Debug: PreconditionedConjugateGradientSolver 9, |r|: 2.0861651135626188e-13;  @ Oceananigans.Solvers ~/Projects/Oceananigans.jl/src/Solvers/preconditioned_conjugate_gradient_solver.jl:185;  Debug: PreconditionedConjugateGradientSolver 9, : 4.352084881045736e-26;  @ Oceananigans.Solvers ~/Projects/Oceananigans.jl/src/Solvers/preconditioned_conjugate_gradient_solver.jl:192;  Debug: PreconditionedConjugateGradientSolver 9, |z|: 2.0861651135626188e-13;  @ Oceananigans.Solvers ~/Projects/Oceananigans.jl/src/Solvers/preconditioned_conjugate_gradient_solver.jl:193;  Debug: Launching kernel broadcast_xy! with worksize (128, 1);  @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85;  Debug: PreconditionedConjugateGradientSolver 9, : 0.1312038209706307;  @ Oceananigans.Solvers ~/Projects/Oceananigans.jl/src/Solvers/preconditioned_conjugate_gradient_solver.jl:201;  Debug: Launching kernel _fill_west_halo! with worksize (1, 1);  @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85;  Debug: Launching kernel _fill_east_halo! with worksize (1, 1);  @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85;  Debug: Launching kernel _implicit_free_surface_linear_operation! with worksize (128, 1);  @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85;  Debug: Launching kernel _fill_west_halo! with worksize (1, 1);  @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85;  Debug: Launching kernel _fill_east_halo! with worksize (1, 1);  @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85;  Debug: PreconditionedConjugateGradientSolver 9, |q|: 3.772383893402093e-14;  @ Oceananigans.Solvers ~/Proje",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-882111021
https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-882111021:150,Testability,log,logs,150,"We could also introduce a new log level, eg `TIMINGS` or something. Might not be good to hijack `@debug` --- it's used for other stuff, so the timing logs might get buried. Like this 100-iteration simulation:. ```; Debug: PreconditionedConjugateGradientSolver 9, |r|: 2.0861651135626188e-13;  @ Oceananigans.Solvers ~/Projects/Oceananigans.jl/src/Solvers/preconditioned_conjugate_gradient_solver.jl:185;  Debug: PreconditionedConjugateGradientSolver 9, : 4.352084881045736e-26;  @ Oceananigans.Solvers ~/Projects/Oceananigans.jl/src/Solvers/preconditioned_conjugate_gradient_solver.jl:192;  Debug: PreconditionedConjugateGradientSolver 9, |z|: 2.0861651135626188e-13;  @ Oceananigans.Solvers ~/Projects/Oceananigans.jl/src/Solvers/preconditioned_conjugate_gradient_solver.jl:193;  Debug: Launching kernel broadcast_xy! with worksize (128, 1);  @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85;  Debug: PreconditionedConjugateGradientSolver 9, : 0.1312038209706307;  @ Oceananigans.Solvers ~/Projects/Oceananigans.jl/src/Solvers/preconditioned_conjugate_gradient_solver.jl:201;  Debug: Launching kernel _fill_west_halo! with worksize (1, 1);  @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85;  Debug: Launching kernel _fill_east_halo! with worksize (1, 1);  @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85;  Debug: Launching kernel _implicit_free_surface_linear_operation! with worksize (128, 1);  @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85;  Debug: Launching kernel _fill_west_halo! with worksize (1, 1);  @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85;  Debug: Launching kernel _fill_east_halo! with worksize (1, 1);  @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85;  Debug: PreconditionedConjugateGradientSolver 9, |q|: 3.772383893402093e-14;  @ Oceananigans.Solvers ~/Proje",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-882111021
https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-882111021:5347,Usability,progress bar,progress bars,5347,"east_west_u_velocity! with worksize (1, 1);  @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85;  Debug: Launching kernel _fill_bottom_halo! with worksize (128, 1);  @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85;  Debug: Launching kernel _fill_top_halo! with worksize (128, 1);  @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85;  Debug: Launching kernel _fill_west_halo! with worksize (1, 1);  @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85;  Debug: Launching kernel _fill_east_halo! with worksize (1, 1);  @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85;  Debug: Launching kernel _fill_bottom_halo! with worksize (128, 1);  @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85;  Debug: Launching kernel _fill_top_halo! with worksize (128, 1);  @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85;  Debug: Launching kernel _fill_west_halo! with worksize (1, 1);  @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85;  Debug: Launching kernel _fill_east_halo! with worksize (1, 1);  @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85;  Debug: Launching kernel _fill_west_halo! with worksize (1, 1);  @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85;  Debug: Launching kernel _fill_east_halo! with worksize (1, 1);  @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85;  Debug: Launching kernel _fill_bottom_halo! with worksize (128, 1);  @ Oceananigans.Utils ~/Projects/Oceananigans.jl/src/Utils/kernel_launching.jl:85; ```. I think I'll try to pepper a few `@info` here and there when resolving this issue. Ultimately it'd be slick to have some cool wigits, spinners, and progress bars like what happens when julia precompiles packages...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-882111021
https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-887905146:44,Testability,log,log,44,@ali-ramadhan what do you think about a new log level for timing that doesn't spit debug?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-887905146
https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-887921831:876,Performance,bottleneck,bottleneck,876,"New log level should be enough if we just need flat per-iteration timings to time a few blocks for a few iterations. Are you thinking of just logging raw `@time` data?. I'm not sure if we need anything more than a new log level, but I imagine some of the benefits of using a package like TimerOutputs.jl would make the timer blocks much more useful for debugging and for users. It allows for nested timers and produces a very nice table summary at the end which includes number of calls and average time/memory allocations. This could also be useful for users wishing to time their simulations to figure out how much time is being spent on I/O vs. in kernels vs. solvers vs. callbacks, etc. I guess I also see timers as a debugging tool for users. Could help be figure out cluster filesystem issues or figure out whether Oceananigans or my coupled model (via callback) is the bottleneck. Otherwise if the timers are just a developer debugging tool that dumps timing information, that's useful but it might not be useful for timing real-world scripts/simulations since the log would fill up with a huge number of lines that can't be interpreted without further processing. Here's an example of it in use: https://github.com/JuliaGPU/CUDA.jl/issues/149#issuecomment-461943376 (CUDA.jl has been using TimerOutputs.jl for a long time I think). TimerOutputs.jl is easy to use since you just add `@timeit` blocks but that does add some noise to the code (not sure if more or less than using a timing log level).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-887921831
https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-887921831:4,Testability,log,log,4,"New log level should be enough if we just need flat per-iteration timings to time a few blocks for a few iterations. Are you thinking of just logging raw `@time` data?. I'm not sure if we need anything more than a new log level, but I imagine some of the benefits of using a package like TimerOutputs.jl would make the timer blocks much more useful for debugging and for users. It allows for nested timers and produces a very nice table summary at the end which includes number of calls and average time/memory allocations. This could also be useful for users wishing to time their simulations to figure out how much time is being spent on I/O vs. in kernels vs. solvers vs. callbacks, etc. I guess I also see timers as a debugging tool for users. Could help be figure out cluster filesystem issues or figure out whether Oceananigans or my coupled model (via callback) is the bottleneck. Otherwise if the timers are just a developer debugging tool that dumps timing information, that's useful but it might not be useful for timing real-world scripts/simulations since the log would fill up with a huge number of lines that can't be interpreted without further processing. Here's an example of it in use: https://github.com/JuliaGPU/CUDA.jl/issues/149#issuecomment-461943376 (CUDA.jl has been using TimerOutputs.jl for a long time I think). TimerOutputs.jl is easy to use since you just add `@timeit` blocks but that does add some noise to the code (not sure if more or less than using a timing log level).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-887921831
https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-887921831:142,Testability,log,logging,142,"New log level should be enough if we just need flat per-iteration timings to time a few blocks for a few iterations. Are you thinking of just logging raw `@time` data?. I'm not sure if we need anything more than a new log level, but I imagine some of the benefits of using a package like TimerOutputs.jl would make the timer blocks much more useful for debugging and for users. It allows for nested timers and produces a very nice table summary at the end which includes number of calls and average time/memory allocations. This could also be useful for users wishing to time their simulations to figure out how much time is being spent on I/O vs. in kernels vs. solvers vs. callbacks, etc. I guess I also see timers as a debugging tool for users. Could help be figure out cluster filesystem issues or figure out whether Oceananigans or my coupled model (via callback) is the bottleneck. Otherwise if the timers are just a developer debugging tool that dumps timing information, that's useful but it might not be useful for timing real-world scripts/simulations since the log would fill up with a huge number of lines that can't be interpreted without further processing. Here's an example of it in use: https://github.com/JuliaGPU/CUDA.jl/issues/149#issuecomment-461943376 (CUDA.jl has been using TimerOutputs.jl for a long time I think). TimerOutputs.jl is easy to use since you just add `@timeit` blocks but that does add some noise to the code (not sure if more or less than using a timing log level).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-887921831
https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-887921831:218,Testability,log,log,218,"New log level should be enough if we just need flat per-iteration timings to time a few blocks for a few iterations. Are you thinking of just logging raw `@time` data?. I'm not sure if we need anything more than a new log level, but I imagine some of the benefits of using a package like TimerOutputs.jl would make the timer blocks much more useful for debugging and for users. It allows for nested timers and produces a very nice table summary at the end which includes number of calls and average time/memory allocations. This could also be useful for users wishing to time their simulations to figure out how much time is being spent on I/O vs. in kernels vs. solvers vs. callbacks, etc. I guess I also see timers as a debugging tool for users. Could help be figure out cluster filesystem issues or figure out whether Oceananigans or my coupled model (via callback) is the bottleneck. Otherwise if the timers are just a developer debugging tool that dumps timing information, that's useful but it might not be useful for timing real-world scripts/simulations since the log would fill up with a huge number of lines that can't be interpreted without further processing. Here's an example of it in use: https://github.com/JuliaGPU/CUDA.jl/issues/149#issuecomment-461943376 (CUDA.jl has been using TimerOutputs.jl for a long time I think). TimerOutputs.jl is easy to use since you just add `@timeit` blocks but that does add some noise to the code (not sure if more or less than using a timing log level).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-887921831
https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-887921831:1072,Testability,log,log,1072,"New log level should be enough if we just need flat per-iteration timings to time a few blocks for a few iterations. Are you thinking of just logging raw `@time` data?. I'm not sure if we need anything more than a new log level, but I imagine some of the benefits of using a package like TimerOutputs.jl would make the timer blocks much more useful for debugging and for users. It allows for nested timers and produces a very nice table summary at the end which includes number of calls and average time/memory allocations. This could also be useful for users wishing to time their simulations to figure out how much time is being spent on I/O vs. in kernels vs. solvers vs. callbacks, etc. I guess I also see timers as a debugging tool for users. Could help be figure out cluster filesystem issues or figure out whether Oceananigans or my coupled model (via callback) is the bottleneck. Otherwise if the timers are just a developer debugging tool that dumps timing information, that's useful but it might not be useful for timing real-world scripts/simulations since the log would fill up with a huge number of lines that can't be interpreted without further processing. Here's an example of it in use: https://github.com/JuliaGPU/CUDA.jl/issues/149#issuecomment-461943376 (CUDA.jl has been using TimerOutputs.jl for a long time I think). TimerOutputs.jl is easy to use since you just add `@timeit` blocks but that does add some noise to the code (not sure if more or less than using a timing log level).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-887921831
https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-887921831:1494,Testability,log,log,1494,"New log level should be enough if we just need flat per-iteration timings to time a few blocks for a few iterations. Are you thinking of just logging raw `@time` data?. I'm not sure if we need anything more than a new log level, but I imagine some of the benefits of using a package like TimerOutputs.jl would make the timer blocks much more useful for debugging and for users. It allows for nested timers and produces a very nice table summary at the end which includes number of calls and average time/memory allocations. This could also be useful for users wishing to time their simulations to figure out how much time is being spent on I/O vs. in kernels vs. solvers vs. callbacks, etc. I guess I also see timers as a debugging tool for users. Could help be figure out cluster filesystem issues or figure out whether Oceananigans or my coupled model (via callback) is the bottleneck. Otherwise if the timers are just a developer debugging tool that dumps timing information, that's useful but it might not be useful for timing real-world scripts/simulations since the log would fill up with a huge number of lines that can't be interpreted without further processing. Here's an example of it in use: https://github.com/JuliaGPU/CUDA.jl/issues/149#issuecomment-461943376 (CUDA.jl has been using TimerOutputs.jl for a long time I think). TimerOutputs.jl is easy to use since you just add `@timeit` blocks but that does add some noise to the code (not sure if more or less than using a timing log level).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-887921831
https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-887967029:891,Performance,bottleneck,bottleneck,891,"> New log level should be enough if we just need flat per-iteration timings to time a few blocks for a few iterations. Are you thinking of just logging raw `@time` data?; > ; > I'm not sure if we need anything more than a new log level, but I imagine some of the benefits of using a package like TimerOutputs.jl would make the timer blocks much more useful for debugging and for users. It allows for nested timers and produces a very nice table summary at the end which includes number of calls and average time/memory allocations.; > ; > This could also be useful for users wishing to time their simulations to figure out how much time is being spent on I/O vs. in kernels vs. solvers vs. callbacks, etc. I guess I also see timers as a debugging tool for users. Could help be figure out cluster filesystem issues or figure out whether Oceananigans or my coupled model (via callback) is the bottleneck.; > ; > Otherwise if the timers are just a developer debugging tool that dumps timing information, that's useful but it might not be useful for timing real-world scripts/simulations since the log would fill up with a huge number of lines that can't be interpreted without further processing.; > ; > Here's an example of it in use: [JuliaGPU/CUDA.jl#149 (comment)](https://github.com/JuliaGPU/CUDA.jl/issues/149#issuecomment-461943376) (CUDA.jl has been using TimerOutputs.jl for a long time I think); > ; > TimerOutputs.jl is easy to use since you just add `@timeit` blocks but that does add some noise to the code (not sure if more or less than using a timing log level). @ali-ramadhan I was thinking timing would be useful for general use around figuring out where time is going in day-to-day modeling - so some summary table as in TimerOutputs.jl would be a great thing to aim for - I think?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-887967029
https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-887967029:6,Testability,log,log,6,"> New log level should be enough if we just need flat per-iteration timings to time a few blocks for a few iterations. Are you thinking of just logging raw `@time` data?; > ; > I'm not sure if we need anything more than a new log level, but I imagine some of the benefits of using a package like TimerOutputs.jl would make the timer blocks much more useful for debugging and for users. It allows for nested timers and produces a very nice table summary at the end which includes number of calls and average time/memory allocations.; > ; > This could also be useful for users wishing to time their simulations to figure out how much time is being spent on I/O vs. in kernels vs. solvers vs. callbacks, etc. I guess I also see timers as a debugging tool for users. Could help be figure out cluster filesystem issues or figure out whether Oceananigans or my coupled model (via callback) is the bottleneck.; > ; > Otherwise if the timers are just a developer debugging tool that dumps timing information, that's useful but it might not be useful for timing real-world scripts/simulations since the log would fill up with a huge number of lines that can't be interpreted without further processing.; > ; > Here's an example of it in use: [JuliaGPU/CUDA.jl#149 (comment)](https://github.com/JuliaGPU/CUDA.jl/issues/149#issuecomment-461943376) (CUDA.jl has been using TimerOutputs.jl for a long time I think); > ; > TimerOutputs.jl is easy to use since you just add `@timeit` blocks but that does add some noise to the code (not sure if more or less than using a timing log level). @ali-ramadhan I was thinking timing would be useful for general use around figuring out where time is going in day-to-day modeling - so some summary table as in TimerOutputs.jl would be a great thing to aim for - I think?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-887967029
https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-887967029:144,Testability,log,logging,144,"> New log level should be enough if we just need flat per-iteration timings to time a few blocks for a few iterations. Are you thinking of just logging raw `@time` data?; > ; > I'm not sure if we need anything more than a new log level, but I imagine some of the benefits of using a package like TimerOutputs.jl would make the timer blocks much more useful for debugging and for users. It allows for nested timers and produces a very nice table summary at the end which includes number of calls and average time/memory allocations.; > ; > This could also be useful for users wishing to time their simulations to figure out how much time is being spent on I/O vs. in kernels vs. solvers vs. callbacks, etc. I guess I also see timers as a debugging tool for users. Could help be figure out cluster filesystem issues or figure out whether Oceananigans or my coupled model (via callback) is the bottleneck.; > ; > Otherwise if the timers are just a developer debugging tool that dumps timing information, that's useful but it might not be useful for timing real-world scripts/simulations since the log would fill up with a huge number of lines that can't be interpreted without further processing.; > ; > Here's an example of it in use: [JuliaGPU/CUDA.jl#149 (comment)](https://github.com/JuliaGPU/CUDA.jl/issues/149#issuecomment-461943376) (CUDA.jl has been using TimerOutputs.jl for a long time I think); > ; > TimerOutputs.jl is easy to use since you just add `@timeit` blocks but that does add some noise to the code (not sure if more or less than using a timing log level). @ali-ramadhan I was thinking timing would be useful for general use around figuring out where time is going in day-to-day modeling - so some summary table as in TimerOutputs.jl would be a great thing to aim for - I think?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-887967029
https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-887967029:226,Testability,log,log,226,"> New log level should be enough if we just need flat per-iteration timings to time a few blocks for a few iterations. Are you thinking of just logging raw `@time` data?; > ; > I'm not sure if we need anything more than a new log level, but I imagine some of the benefits of using a package like TimerOutputs.jl would make the timer blocks much more useful for debugging and for users. It allows for nested timers and produces a very nice table summary at the end which includes number of calls and average time/memory allocations.; > ; > This could also be useful for users wishing to time their simulations to figure out how much time is being spent on I/O vs. in kernels vs. solvers vs. callbacks, etc. I guess I also see timers as a debugging tool for users. Could help be figure out cluster filesystem issues or figure out whether Oceananigans or my coupled model (via callback) is the bottleneck.; > ; > Otherwise if the timers are just a developer debugging tool that dumps timing information, that's useful but it might not be useful for timing real-world scripts/simulations since the log would fill up with a huge number of lines that can't be interpreted without further processing.; > ; > Here's an example of it in use: [JuliaGPU/CUDA.jl#149 (comment)](https://github.com/JuliaGPU/CUDA.jl/issues/149#issuecomment-461943376) (CUDA.jl has been using TimerOutputs.jl for a long time I think); > ; > TimerOutputs.jl is easy to use since you just add `@timeit` blocks but that does add some noise to the code (not sure if more or less than using a timing log level). @ali-ramadhan I was thinking timing would be useful for general use around figuring out where time is going in day-to-day modeling - so some summary table as in TimerOutputs.jl would be a great thing to aim for - I think?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-887967029
https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-887967029:1094,Testability,log,log,1094,"> New log level should be enough if we just need flat per-iteration timings to time a few blocks for a few iterations. Are you thinking of just logging raw `@time` data?; > ; > I'm not sure if we need anything more than a new log level, but I imagine some of the benefits of using a package like TimerOutputs.jl would make the timer blocks much more useful for debugging and for users. It allows for nested timers and produces a very nice table summary at the end which includes number of calls and average time/memory allocations.; > ; > This could also be useful for users wishing to time their simulations to figure out how much time is being spent on I/O vs. in kernels vs. solvers vs. callbacks, etc. I guess I also see timers as a debugging tool for users. Could help be figure out cluster filesystem issues or figure out whether Oceananigans or my coupled model (via callback) is the bottleneck.; > ; > Otherwise if the timers are just a developer debugging tool that dumps timing information, that's useful but it might not be useful for timing real-world scripts/simulations since the log would fill up with a huge number of lines that can't be interpreted without further processing.; > ; > Here's an example of it in use: [JuliaGPU/CUDA.jl#149 (comment)](https://github.com/JuliaGPU/CUDA.jl/issues/149#issuecomment-461943376) (CUDA.jl has been using TimerOutputs.jl for a long time I think); > ; > TimerOutputs.jl is easy to use since you just add `@timeit` blocks but that does add some noise to the code (not sure if more or less than using a timing log level). @ali-ramadhan I was thinking timing would be useful for general use around figuring out where time is going in day-to-day modeling - so some summary table as in TimerOutputs.jl would be a great thing to aim for - I think?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-887967029
https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-887967029:1563,Testability,log,log,1563,"> New log level should be enough if we just need flat per-iteration timings to time a few blocks for a few iterations. Are you thinking of just logging raw `@time` data?; > ; > I'm not sure if we need anything more than a new log level, but I imagine some of the benefits of using a package like TimerOutputs.jl would make the timer blocks much more useful for debugging and for users. It allows for nested timers and produces a very nice table summary at the end which includes number of calls and average time/memory allocations.; > ; > This could also be useful for users wishing to time their simulations to figure out how much time is being spent on I/O vs. in kernels vs. solvers vs. callbacks, etc. I guess I also see timers as a debugging tool for users. Could help be figure out cluster filesystem issues or figure out whether Oceananigans or my coupled model (via callback) is the bottleneck.; > ; > Otherwise if the timers are just a developer debugging tool that dumps timing information, that's useful but it might not be useful for timing real-world scripts/simulations since the log would fill up with a huge number of lines that can't be interpreted without further processing.; > ; > Here's an example of it in use: [JuliaGPU/CUDA.jl#149 (comment)](https://github.com/JuliaGPU/CUDA.jl/issues/149#issuecomment-461943376) (CUDA.jl has been using TimerOutputs.jl for a long time I think); > ; > TimerOutputs.jl is easy to use since you just add `@timeit` blocks but that does add some noise to the code (not sure if more or less than using a timing log level). @ali-ramadhan I was thinking timing would be useful for general use around figuring out where time is going in day-to-day modeling - so some summary table as in TimerOutputs.jl would be a great thing to aim for - I think?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-887967029
https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-888339455:59,Testability,log,log,59,"TimerOutputs sounds awesome! Was just thinking about a new log level since debug spits a _lot_ of information, which might make the output hard to interpret if you're only interested in looking at timings. So maybe a `TIMINGS` log level between `INFO` and `DEBUG` would be useful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-888339455
https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-888339455:227,Testability,log,log,227,"TimerOutputs sounds awesome! Was just thinking about a new log level since debug spits a _lot_ of information, which might make the output hard to interpret if you're only interested in looking at timings. So maybe a `TIMINGS` log level between `INFO` and `DEBUG` would be useful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-888339455
https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-888340062:27,Testability,log,logging,27,> Are you thinking of just logging raw `@time` data?. Agnostic about the logging format and TimerOutputs sounds awesome.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-888340062
https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-888340062:73,Testability,log,logging,73,> Are you thinking of just logging raw `@time` data?. Agnostic about the logging format and TimerOutputs sounds awesome.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-888340062
https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-888341027:106,Integrability,depend,depend,106,"> I guess I also see timers as a debugging tool for users. Totally agree since simulation performance can depend entirely on performance of forcing functions, boundary conditions, and diagnostics; not just code that ships in src.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-888341027
https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-888341027:90,Performance,perform,performance,90,"> I guess I also see timers as a debugging tool for users. Totally agree since simulation performance can depend entirely on performance of forcing functions, boundary conditions, and diagnostics; not just code that ships in src.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-888341027
https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-888341027:125,Performance,perform,performance,125,"> I guess I also see timers as a debugging tool for users. Totally agree since simulation performance can depend entirely on performance of forcing functions, boundary conditions, and diagnostics; not just code that ships in src.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-888341027
https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881456119:575,Testability,test,test,575,I'm not sure whether that is a correct assumption or not. Some of them were designed to be used on the GPU:. https://github.com/CliMA/Oceananigans.jl/blob/6e39d3fcc098c69ac207cc21be759cf6bd3ec604/examples/ocean_wind_mixing_and_convection.jl#L157-L158. But I don't think anyone has ever tried to run the Kelvin-Helmholtz example on the GPU before (for example). Many of the others have been run on the GPU. But I think to really ensure this is the case in the long run we'll have to use CI. We actually used to do something like this (including altering selected lines in the test scripts to make them more amenable to CI) so someone could dredge up that testing code to use with our GPU CI to solve this.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881456119
https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881456119:654,Testability,test,testing,654,I'm not sure whether that is a correct assumption or not. Some of them were designed to be used on the GPU:. https://github.com/CliMA/Oceananigans.jl/blob/6e39d3fcc098c69ac207cc21be759cf6bd3ec604/examples/ocean_wind_mixing_and_convection.jl#L157-L158. But I don't think anyone has ever tried to run the Kelvin-Helmholtz example on the GPU before (for example). Many of the others have been run on the GPU. But I think to really ensure this is the case in the long run we'll have to use CI. We actually used to do something like this (including altering selected lines in the test scripts to make them more amenable to CI) so someone could dredge up that testing code to use with our GPU CI to solve this.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881456119
https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881522322:333,Availability,down,downside,333,"One thing that I was also thinking about is that defining (global) problem; parameters as constants might help out regardless. Every time I do that for; my scripts it speeds up compilation times and often also significantly; speeds up runtimes. Therefore there might be a benefit to using `const`; throughout, even without GPUs. The downside to that is that if a user tries to run several examples in the; same REPL session they might be, without their knowing, trying to redefine; some constants and get some errors and warnings related to that. On Fri, Jul 16, 2021 at 8:05 AM Francis J. Poulin ***@***.***>; wrote:. > I think modifying the examples to run on GPUs easily is a good idea. After; > putting together the ShallowWaterModel example I tried it on a GPU and; > found out that it failed. I added a bunch of const and it then worked; > easily enough. This would make it easier for the user to play with the two; > architectures, which would be a big plus.; >; > ; > You are receiving this because you authored the thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881516816>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADEX5KUFT35UOWJSRKU2M5TTYBDCBANCNFSM5AOQEC5A>; > .; >. -- ; Toms L. Chor; Postdoctoral researcher; Atmospheric and Oceanic Science department; University of Maryland; https://tomchor.github.io/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881522322
https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881522322:510,Availability,error,errors,510,"One thing that I was also thinking about is that defining (global) problem; parameters as constants might help out regardless. Every time I do that for; my scripts it speeds up compilation times and often also significantly; speeds up runtimes. Therefore there might be a benefit to using `const`; throughout, even without GPUs. The downside to that is that if a user tries to run several examples in the; same REPL session they might be, without their knowing, trying to redefine; some constants and get some errors and warnings related to that. On Fri, Jul 16, 2021 at 8:05 AM Francis J. Poulin ***@***.***>; wrote:. > I think modifying the examples to run on GPUs easily is a good idea. After; > putting together the ShallowWaterModel example I tried it on a GPU and; > found out that it failed. I added a bunch of const and it then worked; > easily enough. This would make it easier for the user to play with the two; > architectures, which would be a big plus.; >; > ; > You are receiving this because you authored the thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881516816>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADEX5KUFT35UOWJSRKU2M5TTYBDCBANCNFSM5AOQEC5A>; > .; >. -- ; Toms L. Chor; Postdoctoral researcher; Atmospheric and Oceanic Science department; University of Maryland; https://tomchor.github.io/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881522322
https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881662284:64,Modifiability,variab,variables,64,In the examples I have developed I have tried to always declare variables that are referenced globally in forcing functions or boundary conditions as `const`. Definitely open PRs to fix this if you find places where that isn't the case. I haven't stayed on top of every example that's been added.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881662284
https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881673256:253,Testability,test,test,253,"I see some stuff like `N2` in the [plankton example](https://clima.github.io/OceananigansDocumentation/stable/generated/convecting_plankton/#Boundary-conditions), which is a fixed problem parameter used in the BC but isn't a `const`. I haven't tried to test if making this a constant speeds up things, but I guess I should, no? Should I make a PR to make those alterations?. P.S.: I'm not super clear on which cases defining things as a const helps or not. I just know that the general rule is use something as a `const` if it really isn't gonna change in the problem. That general rule comes from the julia docs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881673256
https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881673256:395,Usability,clear,clear,395,"I see some stuff like `N2` in the [plankton example](https://clima.github.io/OceananigansDocumentation/stable/generated/convecting_plankton/#Boundary-conditions), which is a fixed problem parameter used in the BC but isn't a `const`. I haven't tried to test if making this a constant speeds up things, but I guess I should, no? Should I make a PR to make those alterations?. P.S.: I'm not super clear on which cases defining things as a const helps or not. I just know that the general rule is use something as a `const` if it really isn't gonna change in the problem. That general rule comes from the julia docs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881673256
https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881683697:979,Availability,mask,masking,979,"`const` matters when a variable is referenced as a global variable in a function; something like. ```julia; const a = 2; f(x) = a * x; ```. `a` is not an argument to `f(x)`; it's value is taken from the global scope. In that case it needs to be `const`, or `f(x)` cannot be compiled on the GPU. When numbers are added to explicit data structures --- which is what happens when they are inserted into the `parameters` kwarg in the constructor for `BoundaryCondition` or `Forcing` --- then it's irrelevant whether a variable is declared `const`. This is because in that case the variable is explicitly an argument to the function (eg via the argument `p` in `boundary_condition(x, y, t, p)`). In fact, this is the purpose of the `parameters` kwarg --- to avoid having to use `const` (which is annoying or inconvenient, and has compilation / performance pitfalls). However the API has not developed enough to completely avoid `const` in all cases (eg for `BackgroundFields`, or for masking / target functions in things like `Relaxation`). So we still wrestle with it from time to time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881683697
https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881683697:23,Modifiability,variab,variable,23,"`const` matters when a variable is referenced as a global variable in a function; something like. ```julia; const a = 2; f(x) = a * x; ```. `a` is not an argument to `f(x)`; it's value is taken from the global scope. In that case it needs to be `const`, or `f(x)` cannot be compiled on the GPU. When numbers are added to explicit data structures --- which is what happens when they are inserted into the `parameters` kwarg in the constructor for `BoundaryCondition` or `Forcing` --- then it's irrelevant whether a variable is declared `const`. This is because in that case the variable is explicitly an argument to the function (eg via the argument `p` in `boundary_condition(x, y, t, p)`). In fact, this is the purpose of the `parameters` kwarg --- to avoid having to use `const` (which is annoying or inconvenient, and has compilation / performance pitfalls). However the API has not developed enough to completely avoid `const` in all cases (eg for `BackgroundFields`, or for masking / target functions in things like `Relaxation`). So we still wrestle with it from time to time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881683697
https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881683697:58,Modifiability,variab,variable,58,"`const` matters when a variable is referenced as a global variable in a function; something like. ```julia; const a = 2; f(x) = a * x; ```. `a` is not an argument to `f(x)`; it's value is taken from the global scope. In that case it needs to be `const`, or `f(x)` cannot be compiled on the GPU. When numbers are added to explicit data structures --- which is what happens when they are inserted into the `parameters` kwarg in the constructor for `BoundaryCondition` or `Forcing` --- then it's irrelevant whether a variable is declared `const`. This is because in that case the variable is explicitly an argument to the function (eg via the argument `p` in `boundary_condition(x, y, t, p)`). In fact, this is the purpose of the `parameters` kwarg --- to avoid having to use `const` (which is annoying or inconvenient, and has compilation / performance pitfalls). However the API has not developed enough to completely avoid `const` in all cases (eg for `BackgroundFields`, or for masking / target functions in things like `Relaxation`). So we still wrestle with it from time to time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881683697
https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881683697:514,Modifiability,variab,variable,514,"`const` matters when a variable is referenced as a global variable in a function; something like. ```julia; const a = 2; f(x) = a * x; ```. `a` is not an argument to `f(x)`; it's value is taken from the global scope. In that case it needs to be `const`, or `f(x)` cannot be compiled on the GPU. When numbers are added to explicit data structures --- which is what happens when they are inserted into the `parameters` kwarg in the constructor for `BoundaryCondition` or `Forcing` --- then it's irrelevant whether a variable is declared `const`. This is because in that case the variable is explicitly an argument to the function (eg via the argument `p` in `boundary_condition(x, y, t, p)`). In fact, this is the purpose of the `parameters` kwarg --- to avoid having to use `const` (which is annoying or inconvenient, and has compilation / performance pitfalls). However the API has not developed enough to completely avoid `const` in all cases (eg for `BackgroundFields`, or for masking / target functions in things like `Relaxation`). So we still wrestle with it from time to time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881683697
https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881683697:577,Modifiability,variab,variable,577,"`const` matters when a variable is referenced as a global variable in a function; something like. ```julia; const a = 2; f(x) = a * x; ```. `a` is not an argument to `f(x)`; it's value is taken from the global scope. In that case it needs to be `const`, or `f(x)` cannot be compiled on the GPU. When numbers are added to explicit data structures --- which is what happens when they are inserted into the `parameters` kwarg in the constructor for `BoundaryCondition` or `Forcing` --- then it's irrelevant whether a variable is declared `const`. This is because in that case the variable is explicitly an argument to the function (eg via the argument `p` in `boundary_condition(x, y, t, p)`). In fact, this is the purpose of the `parameters` kwarg --- to avoid having to use `const` (which is annoying or inconvenient, and has compilation / performance pitfalls). However the API has not developed enough to completely avoid `const` in all cases (eg for `BackgroundFields`, or for masking / target functions in things like `Relaxation`). So we still wrestle with it from time to time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881683697
https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881683697:839,Performance,perform,performance,839,"`const` matters when a variable is referenced as a global variable in a function; something like. ```julia; const a = 2; f(x) = a * x; ```. `a` is not an argument to `f(x)`; it's value is taken from the global scope. In that case it needs to be `const`, or `f(x)` cannot be compiled on the GPU. When numbers are added to explicit data structures --- which is what happens when they are inserted into the `parameters` kwarg in the constructor for `BoundaryCondition` or `Forcing` --- then it's irrelevant whether a variable is declared `const`. This is because in that case the variable is explicitly an argument to the function (eg via the argument `p` in `boundary_condition(x, y, t, p)`). In fact, this is the purpose of the `parameters` kwarg --- to avoid having to use `const` (which is annoying or inconvenient, and has compilation / performance pitfalls). However the API has not developed enough to completely avoid `const` in all cases (eg for `BackgroundFields`, or for masking / target functions in things like `Relaxation`). So we still wrestle with it from time to time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881683697
https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881683697:753,Safety,avoid,avoid,753,"`const` matters when a variable is referenced as a global variable in a function; something like. ```julia; const a = 2; f(x) = a * x; ```. `a` is not an argument to `f(x)`; it's value is taken from the global scope. In that case it needs to be `const`, or `f(x)` cannot be compiled on the GPU. When numbers are added to explicit data structures --- which is what happens when they are inserted into the `parameters` kwarg in the constructor for `BoundaryCondition` or `Forcing` --- then it's irrelevant whether a variable is declared `const`. This is because in that case the variable is explicitly an argument to the function (eg via the argument `p` in `boundary_condition(x, y, t, p)`). In fact, this is the purpose of the `parameters` kwarg --- to avoid having to use `const` (which is annoying or inconvenient, and has compilation / performance pitfalls). However the API has not developed enough to completely avoid `const` in all cases (eg for `BackgroundFields`, or for masking / target functions in things like `Relaxation`). So we still wrestle with it from time to time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881683697
https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881683697:917,Safety,avoid,avoid,917,"`const` matters when a variable is referenced as a global variable in a function; something like. ```julia; const a = 2; f(x) = a * x; ```. `a` is not an argument to `f(x)`; it's value is taken from the global scope. In that case it needs to be `const`, or `f(x)` cannot be compiled on the GPU. When numbers are added to explicit data structures --- which is what happens when they are inserted into the `parameters` kwarg in the constructor for `BoundaryCondition` or `Forcing` --- then it's irrelevant whether a variable is declared `const`. This is because in that case the variable is explicitly an argument to the function (eg via the argument `p` in `boundary_condition(x, y, t, p)`). In fact, this is the purpose of the `parameters` kwarg --- to avoid having to use `const` (which is annoying or inconvenient, and has compilation / performance pitfalls). However the API has not developed enough to completely avoid `const` in all cases (eg for `BackgroundFields`, or for masking / target functions in things like `Relaxation`). So we still wrestle with it from time to time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881683697
https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881686691:277,Deployability,Continuous,ContinuousBoundaryFunction,277,"Also to be clear, declaring something as `const`, and then inserting that variable's value into another data structure does not guarantee that the value in the second data structure is fixed. `const` attaches to a name and does not ""propagate"" into other data structures like `ContinuousBoundaryFunction.parameters`. So things like the following are valid:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> const b = 2; 2. julia> t = Test(b); Test{Int64}(2). julia> t.a = 3; 3. julia> t; Test{Int64}(3); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881686691
https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881686691:74,Modifiability,variab,variable,74,"Also to be clear, declaring something as `const`, and then inserting that variable's value into another data structure does not guarantee that the value in the second data structure is fixed. `const` attaches to a name and does not ""propagate"" into other data structures like `ContinuousBoundaryFunction.parameters`. So things like the following are valid:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> const b = 2; 2. julia> t = Test(b); Test{Int64}(2). julia> t.a = 3; 3. julia> t; Test{Int64}(3); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881686691
https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881686691:390,Testability,Test,Test,390,"Also to be clear, declaring something as `const`, and then inserting that variable's value into another data structure does not guarantee that the value in the second data structure is fixed. `const` attaches to a name and does not ""propagate"" into other data structures like `ContinuousBoundaryFunction.parameters`. So things like the following are valid:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> const b = 2; 2. julia> t = Test(b); Test{Int64}(2). julia> t.a = 3; 3. julia> t; Test{Int64}(3); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881686691
https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881686691:446,Testability,Test,Test,446,"Also to be clear, declaring something as `const`, and then inserting that variable's value into another data structure does not guarantee that the value in the second data structure is fixed. `const` attaches to a name and does not ""propagate"" into other data structures like `ContinuousBoundaryFunction.parameters`. So things like the following are valid:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> const b = 2; 2. julia> t = Test(b); Test{Int64}(2). julia> t.a = 3; 3. julia> t; Test{Int64}(3); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881686691
https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881686691:455,Testability,Test,Test,455,"Also to be clear, declaring something as `const`, and then inserting that variable's value into another data structure does not guarantee that the value in the second data structure is fixed. `const` attaches to a name and does not ""propagate"" into other data structures like `ContinuousBoundaryFunction.parameters`. So things like the following are valid:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> const b = 2; 2. julia> t = Test(b); Test{Int64}(2). julia> t.a = 3; 3. julia> t; Test{Int64}(3); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881686691
https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881686691:500,Testability,Test,Test,500,"Also to be clear, declaring something as `const`, and then inserting that variable's value into another data structure does not guarantee that the value in the second data structure is fixed. `const` attaches to a name and does not ""propagate"" into other data structures like `ContinuousBoundaryFunction.parameters`. So things like the following are valid:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> const b = 2; 2. julia> t = Test(b); Test{Int64}(2). julia> t.a = 3; 3. julia> t; Test{Int64}(3); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881686691
https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881686691:11,Usability,clear,clear,11,"Also to be clear, declaring something as `const`, and then inserting that variable's value into another data structure does not guarantee that the value in the second data structure is fixed. `const` attaches to a name and does not ""propagate"" into other data structures like `ContinuousBoundaryFunction.parameters`. So things like the following are valid:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> const b = 2; 2. julia> t = Test(b); Test{Int64}(2). julia> t.a = 3; 3. julia> t; Test{Int64}(3); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881686691
https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881690306:1068,Integrability,depend,depends,1068,"Another non-function example is this piece of code from the wind mixing case:. ```julia; Q = Q / ( * c) # K m s, surface temperature flux. # Finally, we impose a temperature gradient `dTdz` both initially and at the; # bottom of the domain, culminating in the boundary conditions on temperature,. dTdz = 0.01 # K m. T_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Q),; bottom = GradientBoundaryCondition(dTdz)); ```. This should work on the GPU. The reason is that `Q` and `dTdz` are not referenced in functions. Instead, they end up inside the data structures `model.tracers.T.boundary_conditions.top.condition` and `model.tracers.T.boundary_conditions.bottom.condition`. Likewise, this code is valid too:. ```julia; @inline Q(x, y, t, S, evaporation_rate) = - evaporation_rate * S # [salinity unit] m s; nothing # hide. # where `S` is salinity. We use an evporation rate of 1 millimeter per hour,. evaporation_rate = 1e-3 / hour # m s. # We build the `Flux` evaporation `BoundaryCondition` with the function `Q`,; # indicating that `Q` depends on salinity `S` and passing; # the parameter `evaporation_rate`,. evaporation_bc = FluxBoundaryCondition(Q, field_dependencies=:S, parameters=evaporation_rate); ```. because `evaporation_rate` enters into `Q` in its 5th argument. It does not need to be, and should not be, `const`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881690306
https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881696539:91,Modifiability,variab,variables-and-scoping,91,"Here's the julia docs on constants for reference:. https://docs.julialang.org/en/v1/manual/variables-and-scoping/#Constants. This statement in the julia docs could maybe be clarified:. > It is difficult for the compiler to optimize code involving global variables, since their values (or even their types) might change at almost any time. because its ambiguous what ""code involving global variables"" is. For Oceananigans, this almost always means ""functions that capture global variables in their scope"". So `f(x) = a * x` is going to be slow unless `a` is `const`; otherwise `f(x)` cannot be inlined properly because the type of `a` is uncertain.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881696539
https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881696539:254,Modifiability,variab,variables,254,"Here's the julia docs on constants for reference:. https://docs.julialang.org/en/v1/manual/variables-and-scoping/#Constants. This statement in the julia docs could maybe be clarified:. > It is difficult for the compiler to optimize code involving global variables, since their values (or even their types) might change at almost any time. because its ambiguous what ""code involving global variables"" is. For Oceananigans, this almost always means ""functions that capture global variables in their scope"". So `f(x) = a * x` is going to be slow unless `a` is `const`; otherwise `f(x)` cannot be inlined properly because the type of `a` is uncertain.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881696539
https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881696539:389,Modifiability,variab,variables,389,"Here's the julia docs on constants for reference:. https://docs.julialang.org/en/v1/manual/variables-and-scoping/#Constants. This statement in the julia docs could maybe be clarified:. > It is difficult for the compiler to optimize code involving global variables, since their values (or even their types) might change at almost any time. because its ambiguous what ""code involving global variables"" is. For Oceananigans, this almost always means ""functions that capture global variables in their scope"". So `f(x) = a * x` is going to be slow unless `a` is `const`; otherwise `f(x)` cannot be inlined properly because the type of `a` is uncertain.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881696539
https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881696539:478,Modifiability,variab,variables,478,"Here's the julia docs on constants for reference:. https://docs.julialang.org/en/v1/manual/variables-and-scoping/#Constants. This statement in the julia docs could maybe be clarified:. > It is difficult for the compiler to optimize code involving global variables, since their values (or even their types) might change at almost any time. because its ambiguous what ""code involving global variables"" is. For Oceananigans, this almost always means ""functions that capture global variables in their scope"". So `f(x) = a * x` is going to be slow unless `a` is `const`; otherwise `f(x)` cannot be inlined properly because the type of `a` is uncertain.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881696539
https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881696539:223,Performance,optimiz,optimize,223,"Here's the julia docs on constants for reference:. https://docs.julialang.org/en/v1/manual/variables-and-scoping/#Constants. This statement in the julia docs could maybe be clarified:. > It is difficult for the compiler to optimize code involving global variables, since their values (or even their types) might change at almost any time. because its ambiguous what ""code involving global variables"" is. For Oceananigans, this almost always means ""functions that capture global variables in their scope"". So `f(x) = a * x` is going to be slow unless `a` is `const`; otherwise `f(x)` cannot be inlined properly because the type of `a` is uncertain.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881696539
https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-882647783:117,Availability,error,error,117,"I tried running the `ShallowWaterModel` example on a `GPU` and it failed because of how we compute the norm, see the error message below. @glwagner , I remember we talked about this but, sadly, I don't know if we had a solution. What would you recommend?. ```; ERROR: LoadError: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] assertscalar(op::String); @ GPUArrays ~/.julia/packages/GPUArrays/8dzSJ/src/host/indexing.jl:53; [3] getindex(::CUDA.CuArray{Float64, 3}, ::Int64, ::Int64, ::Int64); @ GPUArrays ~/.julia/packages/GPUArrays/8dzSJ/src/host/indexing.jl:86; [4] getindex; @ ./subarray.jl:276 [inlined]; [5] _getindex; @ ./abstractarray.jl:1214 [inlined]; [6] getindex; @ ./abstractarray.jl:1170 [inlined]; [7] iterate; @ ./abstractarray.jl:1096 [inlined]; [8] iterate; @ ./abstractarray.jl:1094 [inlined]; [9] generic_normInf(x::SubArray{Float64, 3, CUDA.CuArray{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}); @ LinearAlgebra /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl:465; [10] normInf; @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl:556 [inlined]; [11] generic_norm2(x::SubArray{Float64, 3, CUDA.CuArray{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}); @ LinearAlgebra /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl:497; [12] norm2; @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl:558 ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-882647783
https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-882647783:261,Availability,ERROR,ERROR,261,"I tried running the `ShallowWaterModel` example on a `GPU` and it failed because of how we compute the norm, see the error message below. @glwagner , I remember we talked about this but, sadly, I don't know if we had a solution. What would you recommend?. ```; ERROR: LoadError: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] assertscalar(op::String); @ GPUArrays ~/.julia/packages/GPUArrays/8dzSJ/src/host/indexing.jl:53; [3] getindex(::CUDA.CuArray{Float64, 3}, ::Int64, ::Int64, ::Int64); @ GPUArrays ~/.julia/packages/GPUArrays/8dzSJ/src/host/indexing.jl:86; [4] getindex; @ ./subarray.jl:276 [inlined]; [5] _getindex; @ ./abstractarray.jl:1214 [inlined]; [6] getindex; @ ./abstractarray.jl:1170 [inlined]; [7] iterate; @ ./abstractarray.jl:1096 [inlined]; [8] iterate; @ ./abstractarray.jl:1094 [inlined]; [9] generic_normInf(x::SubArray{Float64, 3, CUDA.CuArray{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}); @ LinearAlgebra /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl:465; [10] normInf; @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl:556 [inlined]; [11] generic_norm2(x::SubArray{Float64, 3, CUDA.CuArray{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}); @ LinearAlgebra /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl:497; [12] norm2; @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl:558 ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-882647783
https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-882647783:706,Availability,error,error,706,"I tried running the `ShallowWaterModel` example on a `GPU` and it failed because of how we compute the norm, see the error message below. @glwagner , I remember we talked about this but, sadly, I don't know if we had a solution. What would you recommend?. ```; ERROR: LoadError: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] assertscalar(op::String); @ GPUArrays ~/.julia/packages/GPUArrays/8dzSJ/src/host/indexing.jl:53; [3] getindex(::CUDA.CuArray{Float64, 3}, ::Int64, ::Int64, ::Int64); @ GPUArrays ~/.julia/packages/GPUArrays/8dzSJ/src/host/indexing.jl:86; [4] getindex; @ ./subarray.jl:276 [inlined]; [5] _getindex; @ ./abstractarray.jl:1214 [inlined]; [6] getindex; @ ./abstractarray.jl:1170 [inlined]; [7] iterate; @ ./abstractarray.jl:1096 [inlined]; [8] iterate; @ ./abstractarray.jl:1094 [inlined]; [9] generic_normInf(x::SubArray{Float64, 3, CUDA.CuArray{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}); @ LinearAlgebra /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl:465; [10] normInf; @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl:556 [inlined]; [11] generic_norm2(x::SubArray{Float64, 3, CUDA.CuArray{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}); @ LinearAlgebra /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl:497; [12] norm2; @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl:558 ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-882647783
https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-882647783:733,Availability,error,error,733,"I tried running the `ShallowWaterModel` example on a `GPU` and it failed because of how we compute the norm, see the error message below. @glwagner , I remember we talked about this but, sadly, I don't know if we had a solution. What would you recommend?. ```; ERROR: LoadError: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] assertscalar(op::String); @ GPUArrays ~/.julia/packages/GPUArrays/8dzSJ/src/host/indexing.jl:53; [3] getindex(::CUDA.CuArray{Float64, 3}, ::Int64, ::Int64, ::Int64); @ GPUArrays ~/.julia/packages/GPUArrays/8dzSJ/src/host/indexing.jl:86; [4] getindex; @ ./subarray.jl:276 [inlined]; [5] _getindex; @ ./abstractarray.jl:1214 [inlined]; [6] getindex; @ ./abstractarray.jl:1170 [inlined]; [7] iterate; @ ./abstractarray.jl:1096 [inlined]; [8] iterate; @ ./abstractarray.jl:1094 [inlined]; [9] generic_normInf(x::SubArray{Float64, 3, CUDA.CuArray{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}); @ LinearAlgebra /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl:465; [10] normInf; @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl:556 [inlined]; [11] generic_norm2(x::SubArray{Float64, 3, CUDA.CuArray{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}); @ LinearAlgebra /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl:497; [12] norm2; @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl:558 ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-882647783
https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-882647783:123,Integrability,message,message,123,"I tried running the `ShallowWaterModel` example on a `GPU` and it failed because of how we compute the norm, see the error message below. @glwagner , I remember we talked about this but, sadly, I don't know if we had a solution. What would you recommend?. ```; ERROR: LoadError: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] assertscalar(op::String); @ GPUArrays ~/.julia/packages/GPUArrays/8dzSJ/src/host/indexing.jl:53; [3] getindex(::CUDA.CuArray{Float64, 3}, ::Int64, ::Int64, ::Int64); @ GPUArrays ~/.julia/packages/GPUArrays/8dzSJ/src/host/indexing.jl:86; [4] getindex; @ ./subarray.jl:276 [inlined]; [5] _getindex; @ ./abstractarray.jl:1214 [inlined]; [6] getindex; @ ./abstractarray.jl:1170 [inlined]; [7] iterate; @ ./abstractarray.jl:1096 [inlined]; [8] iterate; @ ./abstractarray.jl:1094 [inlined]; [9] generic_normInf(x::SubArray{Float64, 3, CUDA.CuArray{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}); @ LinearAlgebra /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl:465; [10] normInf; @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl:556 [inlined]; [11] generic_norm2(x::SubArray{Float64, 3, CUDA.CuArray{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}); @ LinearAlgebra /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl:497; [12] norm2; @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl:558 ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-882647783
https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-882647783:268,Performance,Load,LoadError,268,"I tried running the `ShallowWaterModel` example on a `GPU` and it failed because of how we compute the norm, see the error message below. @glwagner , I remember we talked about this but, sadly, I don't know if we had a solution. What would you recommend?. ```; ERROR: LoadError: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] assertscalar(op::String); @ GPUArrays ~/.julia/packages/GPUArrays/8dzSJ/src/host/indexing.jl:53; [3] getindex(::CUDA.CuArray{Float64, 3}, ::Int64, ::Int64, ::Int64); @ GPUArrays ~/.julia/packages/GPUArrays/8dzSJ/src/host/indexing.jl:86; [4] getindex; @ ./subarray.jl:276 [inlined]; [5] _getindex; @ ./abstractarray.jl:1214 [inlined]; [6] getindex; @ ./abstractarray.jl:1170 [inlined]; [7] iterate; @ ./abstractarray.jl:1096 [inlined]; [8] iterate; @ ./abstractarray.jl:1094 [inlined]; [9] generic_normInf(x::SubArray{Float64, 3, CUDA.CuArray{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}); @ LinearAlgebra /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl:465; [10] normInf; @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl:556 [inlined]; [11] generic_norm2(x::SubArray{Float64, 3, CUDA.CuArray{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}); @ LinearAlgebra /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl:497; [12] norm2; @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl:558 ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-882647783
https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-882647783:750,Testability,assert,assertscalar,750,"I tried running the `ShallowWaterModel` example on a `GPU` and it failed because of how we compute the norm, see the error message below. @glwagner , I remember we talked about this but, sadly, I don't know if we had a solution. What would you recommend?. ```; ERROR: LoadError: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] assertscalar(op::String); @ GPUArrays ~/.julia/packages/GPUArrays/8dzSJ/src/host/indexing.jl:53; [3] getindex(::CUDA.CuArray{Float64, 3}, ::Int64, ::Int64, ::Int64); @ GPUArrays ~/.julia/packages/GPUArrays/8dzSJ/src/host/indexing.jl:86; [4] getindex; @ ./subarray.jl:276 [inlined]; [5] _getindex; @ ./abstractarray.jl:1214 [inlined]; [6] getindex; @ ./abstractarray.jl:1170 [inlined]; [7] iterate; @ ./abstractarray.jl:1096 [inlined]; [8] iterate; @ ./abstractarray.jl:1094 [inlined]; [9] generic_normInf(x::SubArray{Float64, 3, CUDA.CuArray{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}); @ LinearAlgebra /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl:465; [10] normInf; @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl:556 [inlined]; [11] generic_norm2(x::SubArray{Float64, 3, CUDA.CuArray{Float64, 3}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}); @ LinearAlgebra /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl:497; [12] norm2; @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/generic.jl:558 ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-882647783
https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-882662678:81,Availability,error,error,81,"It looks like `perturbation_norm` needs to be defined in a GPU friendly way. The error message is cutoff so I can't see where that function is defined (the clue is at the bottom of what's posted):. ```; [15] perturbation_norm(model::ShallowWaterModel{RegularRectilinearGrid{Float64, Periodic, Bounded, Flat, OffsetArrays.OffsetVector{Fl; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-882662678
https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-882662678:87,Integrability,message,message,87,"It looks like `perturbation_norm` needs to be defined in a GPU friendly way. The error message is cutoff so I can't see where that function is defined (the clue is at the bottom of what's posted):. ```; [15] perturbation_norm(model::ShallowWaterModel{RegularRectilinearGrid{Float64, Periodic, Bounded, Flat, OffsetArrays.OffsetVector{Fl; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-882662678
https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-1479876046:202,Availability,error,error,202,"I'm closing this issue because I'm judging that it's not of current, timely relevance to Oceananigans development. If you would like to make it a higher priority or if you think the issue was closed in error please feel free to re-open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-1479876046
https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-2016739183:125,Availability,error,errors,125,"@glwagner I am trying to run the Kelvin-Helmholtz instability example on a GPU; however, the model has failed, throwing some errors. Can someone help me to sort this error. Please find the attached error below: . using Random, Statistics. mean_perturbation_kinetic_energy = Field(Average(1/2 * (u^2 + w^2))); noise(x, z) = randn(); set!(model, u=noise, w=noise, b=noise); rescale!(simulation.model, mean_perturbation_kinetic_energy, target_kinetic_energy=1e-6); growth_rates, power_method_data = estimate_growth_rate(simulation, mean_perturbation_kinetic_energy, perturbation_vorticity, b). @info ""Power iterations converged! Estimated growth rate: $(growth_rates[end])"". Error: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore should be avoided. If you want to allow scalar iteration, use `allowscalar` or `@allowscalar`; to enable scalar iteration globally or for the operations in question.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-2016739183
https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-2016739183:166,Availability,error,error,166,"@glwagner I am trying to run the Kelvin-Helmholtz instability example on a GPU; however, the model has failed, throwing some errors. Can someone help me to sort this error. Please find the attached error below: . using Random, Statistics. mean_perturbation_kinetic_energy = Field(Average(1/2 * (u^2 + w^2))); noise(x, z) = randn(); set!(model, u=noise, w=noise, b=noise); rescale!(simulation.model, mean_perturbation_kinetic_energy, target_kinetic_energy=1e-6); growth_rates, power_method_data = estimate_growth_rate(simulation, mean_perturbation_kinetic_energy, perturbation_vorticity, b). @info ""Power iterations converged! Estimated growth rate: $(growth_rates[end])"". Error: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore should be avoided. If you want to allow scalar iteration, use `allowscalar` or `@allowscalar`; to enable scalar iteration globally or for the operations in question.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-2016739183
https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-2016739183:198,Availability,error,error,198,"@glwagner I am trying to run the Kelvin-Helmholtz instability example on a GPU; however, the model has failed, throwing some errors. Can someone help me to sort this error. Please find the attached error below: . using Random, Statistics. mean_perturbation_kinetic_energy = Field(Average(1/2 * (u^2 + w^2))); noise(x, z) = randn(); set!(model, u=noise, w=noise, b=noise); rescale!(simulation.model, mean_perturbation_kinetic_energy, target_kinetic_energy=1e-6); growth_rates, power_method_data = estimate_growth_rate(simulation, mean_perturbation_kinetic_energy, perturbation_vorticity, b). @info ""Power iterations converged! Estimated growth rate: $(growth_rates[end])"". Error: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore should be avoided. If you want to allow scalar iteration, use `allowscalar` or `@allowscalar`; to enable scalar iteration globally or for the operations in question.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-2016739183
https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-2016739183:672,Availability,Error,Error,672,"@glwagner I am trying to run the Kelvin-Helmholtz instability example on a GPU; however, the model has failed, throwing some errors. Can someone help me to sort this error. Please find the attached error below: . using Random, Statistics. mean_perturbation_kinetic_energy = Field(Average(1/2 * (u^2 + w^2))); noise(x, z) = randn(); set!(model, u=noise, w=noise, b=noise); rescale!(simulation.model, mean_perturbation_kinetic_energy, target_kinetic_energy=1e-6); growth_rates, power_method_data = estimate_growth_rate(simulation, mean_perturbation_kinetic_energy, perturbation_vorticity, b). @info ""Power iterations converged! Estimated growth rate: $(growth_rates[end])"". Error: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore should be avoided. If you want to allow scalar iteration, use `allowscalar` or `@allowscalar`; to enable scalar iteration globally or for the operations in question.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-2016739183
https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-2016739183:598,Energy Efficiency,Power,Power,598,"@glwagner I am trying to run the Kelvin-Helmholtz instability example on a GPU; however, the model has failed, throwing some errors. Can someone help me to sort this error. Please find the attached error below: . using Random, Statistics. mean_perturbation_kinetic_energy = Field(Average(1/2 * (u^2 + w^2))); noise(x, z) = randn(); set!(model, u=noise, w=noise, b=noise); rescale!(simulation.model, mean_perturbation_kinetic_energy, target_kinetic_energy=1e-6); growth_rates, power_method_data = estimate_growth_rate(simulation, mean_perturbation_kinetic_energy, perturbation_vorticity, b). @info ""Power iterations converged! Estimated growth rate: $(growth_rates[end])"". Error: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore should be avoided. If you want to allow scalar iteration, use `allowscalar` or `@allowscalar`; to enable scalar iteration globally or for the operations in question.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-2016739183
https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-2016739183:960,Safety,avoid,avoided,960,"@glwagner I am trying to run the Kelvin-Helmholtz instability example on a GPU; however, the model has failed, throwing some errors. Can someone help me to sort this error. Please find the attached error below: . using Random, Statistics. mean_perturbation_kinetic_energy = Field(Average(1/2 * (u^2 + w^2))); noise(x, z) = randn(); set!(model, u=noise, w=noise, b=noise); rescale!(simulation.model, mean_perturbation_kinetic_energy, target_kinetic_energy=1e-6); growth_rates, power_method_data = estimate_growth_rate(simulation, mean_perturbation_kinetic_energy, perturbation_vorticity, b). @info ""Power iterations converged! Estimated growth rate: $(growth_rates[end])"". Error: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore should be avoided. If you want to allow scalar iteration, use `allowscalar` or `@allowscalar`; to enable scalar iteration globally or for the operations in question.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-2016739183
https://github.com/CliMA/Oceananigans.jl/pull/1864#issuecomment-881956216:61,Availability,failure,failure,61,Some test pass and it makes no sense. Is it just random test failure past of the test natural variability?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1864#issuecomment-881956216
https://github.com/CliMA/Oceananigans.jl/pull/1864#issuecomment-881956216:94,Modifiability,variab,variability,94,Some test pass and it makes no sense. Is it just random test failure past of the test natural variability?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1864#issuecomment-881956216
https://github.com/CliMA/Oceananigans.jl/pull/1864#issuecomment-881956216:5,Testability,test,test,5,Some test pass and it makes no sense. Is it just random test failure past of the test natural variability?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1864#issuecomment-881956216
https://github.com/CliMA/Oceananigans.jl/pull/1864#issuecomment-881956216:56,Testability,test,test,56,Some test pass and it makes no sense. Is it just random test failure past of the test natural variability?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1864#issuecomment-881956216
https://github.com/CliMA/Oceananigans.jl/pull/1864#issuecomment-881956216:81,Testability,test,test,81,Some test pass and it makes no sense. Is it just random test failure past of the test natural variability?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1864#issuecomment-881956216
https://github.com/CliMA/Oceananigans.jl/pull/1864#issuecomment-881974489:63,Availability,failure,failure,63,"> Some test pass and it makes no sense. Is it just random test failure past of the test natural variability?. It's natural variability in hardware instructions for GPU, which is pretty scary. sverdrup has a Quadro P6000 which is a bit older and intended more for gaming. I think weird stuff goes on deep inside. If we had billions of dollars we'd get a little cluster dedicated to CI up and running and make beautiful examples and have lightning fast tests (and an engineer to maintain them). Not there yet.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1864#issuecomment-881974489
https://github.com/CliMA/Oceananigans.jl/pull/1864#issuecomment-881974489:96,Modifiability,variab,variability,96,"> Some test pass and it makes no sense. Is it just random test failure past of the test natural variability?. It's natural variability in hardware instructions for GPU, which is pretty scary. sverdrup has a Quadro P6000 which is a bit older and intended more for gaming. I think weird stuff goes on deep inside. If we had billions of dollars we'd get a little cluster dedicated to CI up and running and make beautiful examples and have lightning fast tests (and an engineer to maintain them). Not there yet.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1864#issuecomment-881974489
https://github.com/CliMA/Oceananigans.jl/pull/1864#issuecomment-881974489:123,Modifiability,variab,variability,123,"> Some test pass and it makes no sense. Is it just random test failure past of the test natural variability?. It's natural variability in hardware instructions for GPU, which is pretty scary. sverdrup has a Quadro P6000 which is a bit older and intended more for gaming. I think weird stuff goes on deep inside. If we had billions of dollars we'd get a little cluster dedicated to CI up and running and make beautiful examples and have lightning fast tests (and an engineer to maintain them). Not there yet.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1864#issuecomment-881974489
https://github.com/CliMA/Oceananigans.jl/pull/1864#issuecomment-881974489:7,Testability,test,test,7,"> Some test pass and it makes no sense. Is it just random test failure past of the test natural variability?. It's natural variability in hardware instructions for GPU, which is pretty scary. sverdrup has a Quadro P6000 which is a bit older and intended more for gaming. I think weird stuff goes on deep inside. If we had billions of dollars we'd get a little cluster dedicated to CI up and running and make beautiful examples and have lightning fast tests (and an engineer to maintain them). Not there yet.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1864#issuecomment-881974489
https://github.com/CliMA/Oceananigans.jl/pull/1864#issuecomment-881974489:58,Testability,test,test,58,"> Some test pass and it makes no sense. Is it just random test failure past of the test natural variability?. It's natural variability in hardware instructions for GPU, which is pretty scary. sverdrup has a Quadro P6000 which is a bit older and intended more for gaming. I think weird stuff goes on deep inside. If we had billions of dollars we'd get a little cluster dedicated to CI up and running and make beautiful examples and have lightning fast tests (and an engineer to maintain them). Not there yet.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1864#issuecomment-881974489
https://github.com/CliMA/Oceananigans.jl/pull/1864#issuecomment-881974489:83,Testability,test,test,83,"> Some test pass and it makes no sense. Is it just random test failure past of the test natural variability?. It's natural variability in hardware instructions for GPU, which is pretty scary. sverdrup has a Quadro P6000 which is a bit older and intended more for gaming. I think weird stuff goes on deep inside. If we had billions of dollars we'd get a little cluster dedicated to CI up and running and make beautiful examples and have lightning fast tests (and an engineer to maintain them). Not there yet.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1864#issuecomment-881974489
https://github.com/CliMA/Oceananigans.jl/pull/1864#issuecomment-881974489:451,Testability,test,tests,451,"> Some test pass and it makes no sense. Is it just random test failure past of the test natural variability?. It's natural variability in hardware instructions for GPU, which is pretty scary. sverdrup has a Quadro P6000 which is a bit older and intended more for gaming. I think weird stuff goes on deep inside. If we had billions of dollars we'd get a little cluster dedicated to CI up and running and make beautiful examples and have lightning fast tests (and an engineer to maintain them). Not there yet.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1864#issuecomment-881974489
https://github.com/CliMA/Oceananigans.jl/pull/1865#issuecomment-881943451:354,Availability,toler,tolerance,354,"> I don't have enough knowledge to comment on the logistics of the test I think, but what I can assess looks pretty good!. Perhaps I should expand on the original post. Before this PR, we had an ""internal wave dynamics"" test which tested that the vertical propagation of an internal wave was simulated ""accurately"" (according to a more or less arbitrary tolerance). The domain is horizontally periodic and vertically bounded with one point in the y-direction; therefore the grid could be made `Flat` in the y-direction. Also, the wave has a vertical wavenumber of 16 and a horizontal wavenumber of 1, so it has a thin aspect ratio and is nearly hydrostatic. After this PR we conduct 8 tests, rather than 1 --- 4 tests for `IncompressibleModel` and 4 tests for `HydrostaticFreeSurfaceModel`. For each model we run the tests on 4 different grids:. * y-periodic `RegularRectilinearGrid` (the original grid used in the test); * y-`Flat` `RegularRectilinearGrid`; * y-periodic `VerticallyStretchedRectilinearGrid` with regular spacing in `z`; * y-`Flat` `VerticallyStretchedRectilinearGrid` with regular spacing in `z`. The test for the last grid failed for both models due to NaNs prior to the fixes implemented in this PR. Let me know if that clarifies the new tests that were added or if more information would be helpful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1865#issuecomment-881943451
https://github.com/CliMA/Oceananigans.jl/pull/1865#issuecomment-881943451:50,Testability,log,logistics,50,"> I don't have enough knowledge to comment on the logistics of the test I think, but what I can assess looks pretty good!. Perhaps I should expand on the original post. Before this PR, we had an ""internal wave dynamics"" test which tested that the vertical propagation of an internal wave was simulated ""accurately"" (according to a more or less arbitrary tolerance). The domain is horizontally periodic and vertically bounded with one point in the y-direction; therefore the grid could be made `Flat` in the y-direction. Also, the wave has a vertical wavenumber of 16 and a horizontal wavenumber of 1, so it has a thin aspect ratio and is nearly hydrostatic. After this PR we conduct 8 tests, rather than 1 --- 4 tests for `IncompressibleModel` and 4 tests for `HydrostaticFreeSurfaceModel`. For each model we run the tests on 4 different grids:. * y-periodic `RegularRectilinearGrid` (the original grid used in the test); * y-`Flat` `RegularRectilinearGrid`; * y-periodic `VerticallyStretchedRectilinearGrid` with regular spacing in `z`; * y-`Flat` `VerticallyStretchedRectilinearGrid` with regular spacing in `z`. The test for the last grid failed for both models due to NaNs prior to the fixes implemented in this PR. Let me know if that clarifies the new tests that were added or if more information would be helpful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1865#issuecomment-881943451
https://github.com/CliMA/Oceananigans.jl/pull/1865#issuecomment-881943451:67,Testability,test,test,67,"> I don't have enough knowledge to comment on the logistics of the test I think, but what I can assess looks pretty good!. Perhaps I should expand on the original post. Before this PR, we had an ""internal wave dynamics"" test which tested that the vertical propagation of an internal wave was simulated ""accurately"" (according to a more or less arbitrary tolerance). The domain is horizontally periodic and vertically bounded with one point in the y-direction; therefore the grid could be made `Flat` in the y-direction. Also, the wave has a vertical wavenumber of 16 and a horizontal wavenumber of 1, so it has a thin aspect ratio and is nearly hydrostatic. After this PR we conduct 8 tests, rather than 1 --- 4 tests for `IncompressibleModel` and 4 tests for `HydrostaticFreeSurfaceModel`. For each model we run the tests on 4 different grids:. * y-periodic `RegularRectilinearGrid` (the original grid used in the test); * y-`Flat` `RegularRectilinearGrid`; * y-periodic `VerticallyStretchedRectilinearGrid` with regular spacing in `z`; * y-`Flat` `VerticallyStretchedRectilinearGrid` with regular spacing in `z`. The test for the last grid failed for both models due to NaNs prior to the fixes implemented in this PR. Let me know if that clarifies the new tests that were added or if more information would be helpful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1865#issuecomment-881943451
https://github.com/CliMA/Oceananigans.jl/pull/1865#issuecomment-881943451:220,Testability,test,test,220,"> I don't have enough knowledge to comment on the logistics of the test I think, but what I can assess looks pretty good!. Perhaps I should expand on the original post. Before this PR, we had an ""internal wave dynamics"" test which tested that the vertical propagation of an internal wave was simulated ""accurately"" (according to a more or less arbitrary tolerance). The domain is horizontally periodic and vertically bounded with one point in the y-direction; therefore the grid could be made `Flat` in the y-direction. Also, the wave has a vertical wavenumber of 16 and a horizontal wavenumber of 1, so it has a thin aspect ratio and is nearly hydrostatic. After this PR we conduct 8 tests, rather than 1 --- 4 tests for `IncompressibleModel` and 4 tests for `HydrostaticFreeSurfaceModel`. For each model we run the tests on 4 different grids:. * y-periodic `RegularRectilinearGrid` (the original grid used in the test); * y-`Flat` `RegularRectilinearGrid`; * y-periodic `VerticallyStretchedRectilinearGrid` with regular spacing in `z`; * y-`Flat` `VerticallyStretchedRectilinearGrid` with regular spacing in `z`. The test for the last grid failed for both models due to NaNs prior to the fixes implemented in this PR. Let me know if that clarifies the new tests that were added or if more information would be helpful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1865#issuecomment-881943451
https://github.com/CliMA/Oceananigans.jl/pull/1865#issuecomment-881943451:231,Testability,test,tested,231,"> I don't have enough knowledge to comment on the logistics of the test I think, but what I can assess looks pretty good!. Perhaps I should expand on the original post. Before this PR, we had an ""internal wave dynamics"" test which tested that the vertical propagation of an internal wave was simulated ""accurately"" (according to a more or less arbitrary tolerance). The domain is horizontally periodic and vertically bounded with one point in the y-direction; therefore the grid could be made `Flat` in the y-direction. Also, the wave has a vertical wavenumber of 16 and a horizontal wavenumber of 1, so it has a thin aspect ratio and is nearly hydrostatic. After this PR we conduct 8 tests, rather than 1 --- 4 tests for `IncompressibleModel` and 4 tests for `HydrostaticFreeSurfaceModel`. For each model we run the tests on 4 different grids:. * y-periodic `RegularRectilinearGrid` (the original grid used in the test); * y-`Flat` `RegularRectilinearGrid`; * y-periodic `VerticallyStretchedRectilinearGrid` with regular spacing in `z`; * y-`Flat` `VerticallyStretchedRectilinearGrid` with regular spacing in `z`. The test for the last grid failed for both models due to NaNs prior to the fixes implemented in this PR. Let me know if that clarifies the new tests that were added or if more information would be helpful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1865#issuecomment-881943451
https://github.com/CliMA/Oceananigans.jl/pull/1865#issuecomment-881943451:685,Testability,test,tests,685,"> I don't have enough knowledge to comment on the logistics of the test I think, but what I can assess looks pretty good!. Perhaps I should expand on the original post. Before this PR, we had an ""internal wave dynamics"" test which tested that the vertical propagation of an internal wave was simulated ""accurately"" (according to a more or less arbitrary tolerance). The domain is horizontally periodic and vertically bounded with one point in the y-direction; therefore the grid could be made `Flat` in the y-direction. Also, the wave has a vertical wavenumber of 16 and a horizontal wavenumber of 1, so it has a thin aspect ratio and is nearly hydrostatic. After this PR we conduct 8 tests, rather than 1 --- 4 tests for `IncompressibleModel` and 4 tests for `HydrostaticFreeSurfaceModel`. For each model we run the tests on 4 different grids:. * y-periodic `RegularRectilinearGrid` (the original grid used in the test); * y-`Flat` `RegularRectilinearGrid`; * y-periodic `VerticallyStretchedRectilinearGrid` with regular spacing in `z`; * y-`Flat` `VerticallyStretchedRectilinearGrid` with regular spacing in `z`. The test for the last grid failed for both models due to NaNs prior to the fixes implemented in this PR. Let me know if that clarifies the new tests that were added or if more information would be helpful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1865#issuecomment-881943451
https://github.com/CliMA/Oceananigans.jl/pull/1865#issuecomment-881943451:712,Testability,test,tests,712,"> I don't have enough knowledge to comment on the logistics of the test I think, but what I can assess looks pretty good!. Perhaps I should expand on the original post. Before this PR, we had an ""internal wave dynamics"" test which tested that the vertical propagation of an internal wave was simulated ""accurately"" (according to a more or less arbitrary tolerance). The domain is horizontally periodic and vertically bounded with one point in the y-direction; therefore the grid could be made `Flat` in the y-direction. Also, the wave has a vertical wavenumber of 16 and a horizontal wavenumber of 1, so it has a thin aspect ratio and is nearly hydrostatic. After this PR we conduct 8 tests, rather than 1 --- 4 tests for `IncompressibleModel` and 4 tests for `HydrostaticFreeSurfaceModel`. For each model we run the tests on 4 different grids:. * y-periodic `RegularRectilinearGrid` (the original grid used in the test); * y-`Flat` `RegularRectilinearGrid`; * y-periodic `VerticallyStretchedRectilinearGrid` with regular spacing in `z`; * y-`Flat` `VerticallyStretchedRectilinearGrid` with regular spacing in `z`. The test for the last grid failed for both models due to NaNs prior to the fixes implemented in this PR. Let me know if that clarifies the new tests that were added or if more information would be helpful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1865#issuecomment-881943451
https://github.com/CliMA/Oceananigans.jl/pull/1865#issuecomment-881943451:750,Testability,test,tests,750,"> I don't have enough knowledge to comment on the logistics of the test I think, but what I can assess looks pretty good!. Perhaps I should expand on the original post. Before this PR, we had an ""internal wave dynamics"" test which tested that the vertical propagation of an internal wave was simulated ""accurately"" (according to a more or less arbitrary tolerance). The domain is horizontally periodic and vertically bounded with one point in the y-direction; therefore the grid could be made `Flat` in the y-direction. Also, the wave has a vertical wavenumber of 16 and a horizontal wavenumber of 1, so it has a thin aspect ratio and is nearly hydrostatic. After this PR we conduct 8 tests, rather than 1 --- 4 tests for `IncompressibleModel` and 4 tests for `HydrostaticFreeSurfaceModel`. For each model we run the tests on 4 different grids:. * y-periodic `RegularRectilinearGrid` (the original grid used in the test); * y-`Flat` `RegularRectilinearGrid`; * y-periodic `VerticallyStretchedRectilinearGrid` with regular spacing in `z`; * y-`Flat` `VerticallyStretchedRectilinearGrid` with regular spacing in `z`. The test for the last grid failed for both models due to NaNs prior to the fixes implemented in this PR. Let me know if that clarifies the new tests that were added or if more information would be helpful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1865#issuecomment-881943451
https://github.com/CliMA/Oceananigans.jl/pull/1865#issuecomment-881943451:817,Testability,test,tests,817,"> I don't have enough knowledge to comment on the logistics of the test I think, but what I can assess looks pretty good!. Perhaps I should expand on the original post. Before this PR, we had an ""internal wave dynamics"" test which tested that the vertical propagation of an internal wave was simulated ""accurately"" (according to a more or less arbitrary tolerance). The domain is horizontally periodic and vertically bounded with one point in the y-direction; therefore the grid could be made `Flat` in the y-direction. Also, the wave has a vertical wavenumber of 16 and a horizontal wavenumber of 1, so it has a thin aspect ratio and is nearly hydrostatic. After this PR we conduct 8 tests, rather than 1 --- 4 tests for `IncompressibleModel` and 4 tests for `HydrostaticFreeSurfaceModel`. For each model we run the tests on 4 different grids:. * y-periodic `RegularRectilinearGrid` (the original grid used in the test); * y-`Flat` `RegularRectilinearGrid`; * y-periodic `VerticallyStretchedRectilinearGrid` with regular spacing in `z`; * y-`Flat` `VerticallyStretchedRectilinearGrid` with regular spacing in `z`. The test for the last grid failed for both models due to NaNs prior to the fixes implemented in this PR. Let me know if that clarifies the new tests that were added or if more information would be helpful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1865#issuecomment-881943451
https://github.com/CliMA/Oceananigans.jl/pull/1865#issuecomment-881943451:915,Testability,test,test,915,"> I don't have enough knowledge to comment on the logistics of the test I think, but what I can assess looks pretty good!. Perhaps I should expand on the original post. Before this PR, we had an ""internal wave dynamics"" test which tested that the vertical propagation of an internal wave was simulated ""accurately"" (according to a more or less arbitrary tolerance). The domain is horizontally periodic and vertically bounded with one point in the y-direction; therefore the grid could be made `Flat` in the y-direction. Also, the wave has a vertical wavenumber of 16 and a horizontal wavenumber of 1, so it has a thin aspect ratio and is nearly hydrostatic. After this PR we conduct 8 tests, rather than 1 --- 4 tests for `IncompressibleModel` and 4 tests for `HydrostaticFreeSurfaceModel`. For each model we run the tests on 4 different grids:. * y-periodic `RegularRectilinearGrid` (the original grid used in the test); * y-`Flat` `RegularRectilinearGrid`; * y-periodic `VerticallyStretchedRectilinearGrid` with regular spacing in `z`; * y-`Flat` `VerticallyStretchedRectilinearGrid` with regular spacing in `z`. The test for the last grid failed for both models due to NaNs prior to the fixes implemented in this PR. Let me know if that clarifies the new tests that were added or if more information would be helpful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1865#issuecomment-881943451
https://github.com/CliMA/Oceananigans.jl/pull/1865#issuecomment-881943451:1119,Testability,test,test,1119,"> I don't have enough knowledge to comment on the logistics of the test I think, but what I can assess looks pretty good!. Perhaps I should expand on the original post. Before this PR, we had an ""internal wave dynamics"" test which tested that the vertical propagation of an internal wave was simulated ""accurately"" (according to a more or less arbitrary tolerance). The domain is horizontally periodic and vertically bounded with one point in the y-direction; therefore the grid could be made `Flat` in the y-direction. Also, the wave has a vertical wavenumber of 16 and a horizontal wavenumber of 1, so it has a thin aspect ratio and is nearly hydrostatic. After this PR we conduct 8 tests, rather than 1 --- 4 tests for `IncompressibleModel` and 4 tests for `HydrostaticFreeSurfaceModel`. For each model we run the tests on 4 different grids:. * y-periodic `RegularRectilinearGrid` (the original grid used in the test); * y-`Flat` `RegularRectilinearGrid`; * y-periodic `VerticallyStretchedRectilinearGrid` with regular spacing in `z`; * y-`Flat` `VerticallyStretchedRectilinearGrid` with regular spacing in `z`. The test for the last grid failed for both models due to NaNs prior to the fixes implemented in this PR. Let me know if that clarifies the new tests that were added or if more information would be helpful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1865#issuecomment-881943451
https://github.com/CliMA/Oceananigans.jl/pull/1865#issuecomment-881943451:1258,Testability,test,tests,1258,"> I don't have enough knowledge to comment on the logistics of the test I think, but what I can assess looks pretty good!. Perhaps I should expand on the original post. Before this PR, we had an ""internal wave dynamics"" test which tested that the vertical propagation of an internal wave was simulated ""accurately"" (according to a more or less arbitrary tolerance). The domain is horizontally periodic and vertically bounded with one point in the y-direction; therefore the grid could be made `Flat` in the y-direction. Also, the wave has a vertical wavenumber of 16 and a horizontal wavenumber of 1, so it has a thin aspect ratio and is nearly hydrostatic. After this PR we conduct 8 tests, rather than 1 --- 4 tests for `IncompressibleModel` and 4 tests for `HydrostaticFreeSurfaceModel`. For each model we run the tests on 4 different grids:. * y-periodic `RegularRectilinearGrid` (the original grid used in the test); * y-`Flat` `RegularRectilinearGrid`; * y-periodic `VerticallyStretchedRectilinearGrid` with regular spacing in `z`; * y-`Flat` `VerticallyStretchedRectilinearGrid` with regular spacing in `z`. The test for the last grid failed for both models due to NaNs prior to the fixes implemented in this PR. Let me know if that clarifies the new tests that were added or if more information would be helpful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1865#issuecomment-881943451
https://github.com/CliMA/Oceananigans.jl/pull/1865#issuecomment-881949061:305,Testability,test,tests,305,"> Should we remove the warning when constructing `FourierTridiagonalPoissonSolver`?. Are you talking about this one? https://github.com/CliMA/Oceananigans.jl/blob/5fbd8cd20c5db8e9b11b6175984e7592a08fc874/src/Solvers/fourier_tridiagonal_poisson_solver.jl#L31-L34. If so, I think we can remove it after the tests pass, no? Unless you think there might be more issues lurking.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1865#issuecomment-881949061
https://github.com/CliMA/Oceananigans.jl/pull/1865#issuecomment-881949550:634,Availability,down,down,634,"> > Should we remove the warning when constructing `FourierTridiagonalPoissonSolver`?; > ; > Are you talking about this one?; > ; > https://github.com/CliMA/Oceananigans.jl/blob/5fbd8cd20c5db8e9b11b6175984e7592a08fc874/src/Solvers/fourier_tridiagonal_poisson_solver.jl#L31-L34; > ; > If so, I think we can remove it after the tests pass, no? Unless you think there might be more issues lurking. Yes, that warning. I realized that the Poisson solver tests (not withstanding the bizarre aspects pointed out in #1867) don't test Flat topologies for the vertically stretched grid. So I've added those. If those pass we can certainly take down the warning. I guess the internal wave test is also a good indication that the solver is working. Either way the warning was a bit misleading since no calculations using the vertically stretched grid were likely to work without correct metrics --- not just calculations involving the Poisson solver.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1865#issuecomment-881949550
https://github.com/CliMA/Oceananigans.jl/pull/1865#issuecomment-881949550:326,Testability,test,tests,326,"> > Should we remove the warning when constructing `FourierTridiagonalPoissonSolver`?; > ; > Are you talking about this one?; > ; > https://github.com/CliMA/Oceananigans.jl/blob/5fbd8cd20c5db8e9b11b6175984e7592a08fc874/src/Solvers/fourier_tridiagonal_poisson_solver.jl#L31-L34; > ; > If so, I think we can remove it after the tests pass, no? Unless you think there might be more issues lurking. Yes, that warning. I realized that the Poisson solver tests (not withstanding the bizarre aspects pointed out in #1867) don't test Flat topologies for the vertically stretched grid. So I've added those. If those pass we can certainly take down the warning. I guess the internal wave test is also a good indication that the solver is working. Either way the warning was a bit misleading since no calculations using the vertically stretched grid were likely to work without correct metrics --- not just calculations involving the Poisson solver.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1865#issuecomment-881949550
https://github.com/CliMA/Oceananigans.jl/pull/1865#issuecomment-881949550:449,Testability,test,tests,449,"> > Should we remove the warning when constructing `FourierTridiagonalPoissonSolver`?; > ; > Are you talking about this one?; > ; > https://github.com/CliMA/Oceananigans.jl/blob/5fbd8cd20c5db8e9b11b6175984e7592a08fc874/src/Solvers/fourier_tridiagonal_poisson_solver.jl#L31-L34; > ; > If so, I think we can remove it after the tests pass, no? Unless you think there might be more issues lurking. Yes, that warning. I realized that the Poisson solver tests (not withstanding the bizarre aspects pointed out in #1867) don't test Flat topologies for the vertically stretched grid. So I've added those. If those pass we can certainly take down the warning. I guess the internal wave test is also a good indication that the solver is working. Either way the warning was a bit misleading since no calculations using the vertically stretched grid were likely to work without correct metrics --- not just calculations involving the Poisson solver.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1865#issuecomment-881949550
https://github.com/CliMA/Oceananigans.jl/pull/1865#issuecomment-881949550:521,Testability,test,test,521,"> > Should we remove the warning when constructing `FourierTridiagonalPoissonSolver`?; > ; > Are you talking about this one?; > ; > https://github.com/CliMA/Oceananigans.jl/blob/5fbd8cd20c5db8e9b11b6175984e7592a08fc874/src/Solvers/fourier_tridiagonal_poisson_solver.jl#L31-L34; > ; > If so, I think we can remove it after the tests pass, no? Unless you think there might be more issues lurking. Yes, that warning. I realized that the Poisson solver tests (not withstanding the bizarre aspects pointed out in #1867) don't test Flat topologies for the vertically stretched grid. So I've added those. If those pass we can certainly take down the warning. I guess the internal wave test is also a good indication that the solver is working. Either way the warning was a bit misleading since no calculations using the vertically stretched grid were likely to work without correct metrics --- not just calculations involving the Poisson solver.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1865#issuecomment-881949550
https://github.com/CliMA/Oceananigans.jl/pull/1865#issuecomment-881949550:678,Testability,test,test,678,"> > Should we remove the warning when constructing `FourierTridiagonalPoissonSolver`?; > ; > Are you talking about this one?; > ; > https://github.com/CliMA/Oceananigans.jl/blob/5fbd8cd20c5db8e9b11b6175984e7592a08fc874/src/Solvers/fourier_tridiagonal_poisson_solver.jl#L31-L34; > ; > If so, I think we can remove it after the tests pass, no? Unless you think there might be more issues lurking. Yes, that warning. I realized that the Poisson solver tests (not withstanding the bizarre aspects pointed out in #1867) don't test Flat topologies for the vertically stretched grid. So I've added those. If those pass we can certainly take down the warning. I guess the internal wave test is also a good indication that the solver is working. Either way the warning was a bit misleading since no calculations using the vertically stretched grid were likely to work without correct metrics --- not just calculations involving the Poisson solver.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1865#issuecomment-881949550
https://github.com/CliMA/Oceananigans.jl/pull/1865#issuecomment-881954693:11,Testability,test,tests,11,CPU solver tests passed so I'm pretty hopeful...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1865#issuecomment-881954693
https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-881938607:178,Usability,clear,clearer,178,@francispoulin does it also make sense to write these divergences as two-dimensional (in xy) since that's what we are restricted to for ShallowWaterModel? It might make the code clearer.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-881938607
https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-882601937:520,Deployability,integrat,integrate,520,"Very sorry for the problems that you found but I'm glad you found them. I believe when @ali-ramadhan and I put this together we were following other examples but I definitely should have been more careful. Just so that I understand, instead of having `momentum_flux_huu, advection` and `transport_tracer_flux_x` we should have had something involving the area? I'm happy to help fix this where I can. As for computing the velocity, I hope we can fix that soon as well. I know that `ShallowWaterModel` is a bit odd as we integrate the mass transports, not the velocities, but we do use the velocity a lot. I wonder if it's worth while computing the velocities (correctly) and then storing those. That should certainly help when we add in `closure` schemes, since those should be based on the velocities, for the most part. One option would be to add `model.velocities,u` and something similar for `v`, and then access them when we need them. That has the unfortuante effect of storing 5 instead of 3 fields, so it would make things more memory intensive. I don't know if it's better to just compute the velocities everytime we need them?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-882601937
https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-882601937:520,Integrability,integrat,integrate,520,"Very sorry for the problems that you found but I'm glad you found them. I believe when @ali-ramadhan and I put this together we were following other examples but I definitely should have been more careful. Just so that I understand, instead of having `momentum_flux_huu, advection` and `transport_tracer_flux_x` we should have had something involving the area? I'm happy to help fix this where I can. As for computing the velocity, I hope we can fix that soon as well. I know that `ShallowWaterModel` is a bit odd as we integrate the mass transports, not the velocities, but we do use the velocity a lot. I wonder if it's worth while computing the velocities (correctly) and then storing those. That should certainly help when we add in `closure` schemes, since those should be based on the velocities, for the most part. One option would be to add `model.velocities,u` and something similar for `v`, and then access them when we need them. That has the unfortuante effect of storing 5 instead of 3 fields, so it would make things more memory intensive. I don't know if it's better to just compute the velocities everytime we need them?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-882601937
https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-882601937:910,Security,access,access,910,"Very sorry for the problems that you found but I'm glad you found them. I believe when @ali-ramadhan and I put this together we were following other examples but I definitely should have been more careful. Just so that I understand, instead of having `momentum_flux_huu, advection` and `transport_tracer_flux_x` we should have had something involving the area? I'm happy to help fix this where I can. As for computing the velocity, I hope we can fix that soon as well. I know that `ShallowWaterModel` is a bit odd as we integrate the mass transports, not the velocities, but we do use the velocity a lot. I wonder if it's worth while computing the velocities (correctly) and then storing those. That should certainly help when we add in `closure` schemes, since those should be based on the velocities, for the most part. One option would be to add `model.velocities,u` and something similar for `v`, and then access them when we need them. That has the unfortuante effect of storing 5 instead of 3 fields, so it would make things more memory intensive. I don't know if it's better to just compute the velocities everytime we need them?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-882601937
https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-882666483:385,Performance,perform,perform,385,"No need to apologize, just trying to help. I think you can form an AbstractOperation for velocities when the model is constructed, eg:. ```julia; velocities = (u = uh/h, v = vh/h); ```. These can be stored in `ShallowWaterModel.velocities`, and used in kernels. They have a getindex method so they'll work with WENO functions too. This doesn't use any extra memory. AbstractOperations perform the calculation `uh/h` with correct interpolation on the fly. > Just so that I understand, instead of having momentum_flux_huu, advection and transport_tracer_flux_x we should have had something involving the area? I'm happy to help fix this where I can. We'd write a horizontal divergence either as. ```; div(Q) = 1 / V * (x(Ax * Qx) + y(Ay * Qy)); ```. or. ```; div(Q) = 1 / Az * (x(y * Qx) + y(x * Qy)); ```. I think this is written in the docstrings but doesn't appear to be reflected in the code. Correct me if I'm wrong.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-882666483
https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-882704896:249,Usability,clear,clear,249,"Maybe part of my confusion is on whether the solution fields, `uh,vh,h`, are cell averaged quantities or not. If they are then do we need to multipy by the area?. Maybe having docs on the finite volume method, as discussed previously, would help to clear some of this up?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-882704896
https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-886679071:183,Security,validat,validation,183,"> #1900 brings the finite-volume discussion further up in the Docs/Numerical Implementations. I think that's a great idea. Also, it occurs to me that it would be nice to have another validation code for `ShallowWaterModel`. The Bickley jet example was good and we confirmed the growth rates, but perhaps a propagatoing equatorial Rossby wave would be fun. This is an exact solution to the equations and we can ensure that the phase speed matches that with theory. Maybe this would help us to ensure that all the integrals are done correctly. I don't think this would be interesting enough to become an example but it might interest some people.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-886679071
https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-886708305:34,Deployability,Integrat,Integrated,34,"I think more validation is great. Integrated cases are split into three categories:. 1. Tests (eg the stuff in `test_dynamics.jl` for NonhydrostaticModel). These run during CI.; 2. `validation/`. These are scientific validation cases that often require scientific interpretation or are expensive. These are similar to ""Tests"" but may lack a quantitative metric of success.; 3. `examples/`. These are intended to showcase the API and library usage to users. They should not be used as tests, because they are very expensive to run (via Documenter) and to maintain (for one because they have a high standard for code quality). I suggest adding bona fide Tests and validation, rather than examples, if we are interested in determining the correctness of the code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-886708305
https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-886708305:34,Integrability,Integrat,Integrated,34,"I think more validation is great. Integrated cases are split into three categories:. 1. Tests (eg the stuff in `test_dynamics.jl` for NonhydrostaticModel). These run during CI.; 2. `validation/`. These are scientific validation cases that often require scientific interpretation or are expensive. These are similar to ""Tests"" but may lack a quantitative metric of success.; 3. `examples/`. These are intended to showcase the API and library usage to users. They should not be used as tests, because they are very expensive to run (via Documenter) and to maintain (for one because they have a high standard for code quality). I suggest adding bona fide Tests and validation, rather than examples, if we are interested in determining the correctness of the code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-886708305
https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-886708305:13,Security,validat,validation,13,"I think more validation is great. Integrated cases are split into three categories:. 1. Tests (eg the stuff in `test_dynamics.jl` for NonhydrostaticModel). These run during CI.; 2. `validation/`. These are scientific validation cases that often require scientific interpretation or are expensive. These are similar to ""Tests"" but may lack a quantitative metric of success.; 3. `examples/`. These are intended to showcase the API and library usage to users. They should not be used as tests, because they are very expensive to run (via Documenter) and to maintain (for one because they have a high standard for code quality). I suggest adding bona fide Tests and validation, rather than examples, if we are interested in determining the correctness of the code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-886708305
https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-886708305:182,Security,validat,validation,182,"I think more validation is great. Integrated cases are split into three categories:. 1. Tests (eg the stuff in `test_dynamics.jl` for NonhydrostaticModel). These run during CI.; 2. `validation/`. These are scientific validation cases that often require scientific interpretation or are expensive. These are similar to ""Tests"" but may lack a quantitative metric of success.; 3. `examples/`. These are intended to showcase the API and library usage to users. They should not be used as tests, because they are very expensive to run (via Documenter) and to maintain (for one because they have a high standard for code quality). I suggest adding bona fide Tests and validation, rather than examples, if we are interested in determining the correctness of the code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-886708305
https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-886708305:217,Security,validat,validation,217,"I think more validation is great. Integrated cases are split into three categories:. 1. Tests (eg the stuff in `test_dynamics.jl` for NonhydrostaticModel). These run during CI.; 2. `validation/`. These are scientific validation cases that often require scientific interpretation or are expensive. These are similar to ""Tests"" but may lack a quantitative metric of success.; 3. `examples/`. These are intended to showcase the API and library usage to users. They should not be used as tests, because they are very expensive to run (via Documenter) and to maintain (for one because they have a high standard for code quality). I suggest adding bona fide Tests and validation, rather than examples, if we are interested in determining the correctness of the code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-886708305
https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-886708305:662,Security,validat,validation,662,"I think more validation is great. Integrated cases are split into three categories:. 1. Tests (eg the stuff in `test_dynamics.jl` for NonhydrostaticModel). These run during CI.; 2. `validation/`. These are scientific validation cases that often require scientific interpretation or are expensive. These are similar to ""Tests"" but may lack a quantitative metric of success.; 3. `examples/`. These are intended to showcase the API and library usage to users. They should not be used as tests, because they are very expensive to run (via Documenter) and to maintain (for one because they have a high standard for code quality). I suggest adding bona fide Tests and validation, rather than examples, if we are interested in determining the correctness of the code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-886708305
https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-886708305:88,Testability,Test,Tests,88,"I think more validation is great. Integrated cases are split into three categories:. 1. Tests (eg the stuff in `test_dynamics.jl` for NonhydrostaticModel). These run during CI.; 2. `validation/`. These are scientific validation cases that often require scientific interpretation or are expensive. These are similar to ""Tests"" but may lack a quantitative metric of success.; 3. `examples/`. These are intended to showcase the API and library usage to users. They should not be used as tests, because they are very expensive to run (via Documenter) and to maintain (for one because they have a high standard for code quality). I suggest adding bona fide Tests and validation, rather than examples, if we are interested in determining the correctness of the code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-886708305
https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-886708305:319,Testability,Test,Tests,319,"I think more validation is great. Integrated cases are split into three categories:. 1. Tests (eg the stuff in `test_dynamics.jl` for NonhydrostaticModel). These run during CI.; 2. `validation/`. These are scientific validation cases that often require scientific interpretation or are expensive. These are similar to ""Tests"" but may lack a quantitative metric of success.; 3. `examples/`. These are intended to showcase the API and library usage to users. They should not be used as tests, because they are very expensive to run (via Documenter) and to maintain (for one because they have a high standard for code quality). I suggest adding bona fide Tests and validation, rather than examples, if we are interested in determining the correctness of the code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-886708305
https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-886708305:484,Testability,test,tests,484,"I think more validation is great. Integrated cases are split into three categories:. 1. Tests (eg the stuff in `test_dynamics.jl` for NonhydrostaticModel). These run during CI.; 2. `validation/`. These are scientific validation cases that often require scientific interpretation or are expensive. These are similar to ""Tests"" but may lack a quantitative metric of success.; 3. `examples/`. These are intended to showcase the API and library usage to users. They should not be used as tests, because they are very expensive to run (via Documenter) and to maintain (for one because they have a high standard for code quality). I suggest adding bona fide Tests and validation, rather than examples, if we are interested in determining the correctness of the code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-886708305
https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-886708305:652,Testability,Test,Tests,652,"I think more validation is great. Integrated cases are split into three categories:. 1. Tests (eg the stuff in `test_dynamics.jl` for NonhydrostaticModel). These run during CI.; 2. `validation/`. These are scientific validation cases that often require scientific interpretation or are expensive. These are similar to ""Tests"" but may lack a quantitative metric of success.; 3. `examples/`. These are intended to showcase the API and library usage to users. They should not be used as tests, because they are very expensive to run (via Documenter) and to maintain (for one because they have a high standard for code quality). I suggest adding bona fide Tests and validation, rather than examples, if we are interested in determining the correctness of the code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-886708305
https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-1116357004:161,Integrability,depend,dependencies,161,"@glwagner : . I am trying to follow the reasoning as to why the momentum flux does not need the area terms and I have an idea. First, I have tried to follow the dependencies of the flux function and find the following:. `div_hUu` -> `momentum_flux_huu`, -> `_advective_momentum_flux_Uu` -> `advective_momentum_flux_Uu`. The final function is defined for either centered of upwinding schemes. . `centered_advective_fluxes.jl` has a defintion that shows it's proportional to `Ax`, and hence the area: https://github.com/CliMA/Oceananigans.jl/blob/f1cd43fbfbb5520122f75b2d3fea84f43b4a22e5/src/Advection/centered_advective_fluxes.jl#L15. `upwind_biased_advective_fluxes.jl` has a definition that shows it is proportional to `Ax` as well: https://github.com/CliMA/Oceananigans.jl/blob/f1cd43fbfbb5520122f75b2d3fea84f43b4a22e5/src/Advection/upwind_biased_advective_fluxes.jl#L24. Something similar is true for `advective_tracer_flux`, and those can be found in the same files. Does this answer the question why there should not be any area terms in the flux?. If this convention is confusing, do we want to do something different?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-1116357004
https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-1116367010:163,Testability,test,test,163,"@glwagner : I don't know that this approaches achieves the high order that we can achieve and I am happy to try something else. . Also, it would be nice to have a test that does this. The test that we have for advection assumes that `h` is constant initially, and that migth be too simple to see whether we always achieve the high order that we want to achieve.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-1116367010
https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-1116367010:188,Testability,test,test,188,"@glwagner : I don't know that this approaches achieves the high order that we can achieve and I am happy to try something else. . Also, it would be nice to have a test that does this. The test that we have for advection assumes that `h` is constant initially, and that migth be too simple to see whether we always achieve the high order that we want to achieve.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-1116367010
https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-1116367010:282,Usability,simpl,simple,282,"@glwagner : I don't know that this approaches achieves the high order that we can achieve and I am happy to try something else. . Also, it would be nice to have a test that does this. The test that we have for advection assumes that `h` is constant initially, and that migth be too simple to see whether we always achieve the high order that we want to achieve.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-1116367010
https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-1479891153:202,Availability,error,error,202,"I'm closing this issue because I'm judging that it's not of current, timely relevance to Oceananigans development. If you would like to make it a higher priority or if you think the issue was closed in error please feel free to re-open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1866#issuecomment-1479891153
https://github.com/CliMA/Oceananigans.jl/issues/1867#issuecomment-1479893941:202,Availability,error,error,202,"I'm closing this issue because I'm judging that it's not of current, timely relevance to Oceananigans development. If you would like to make it a higher priority or if you think the issue was closed in error please feel free to re-open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1867#issuecomment-1479893941
https://github.com/CliMA/Oceananigans.jl/pull/1869#issuecomment-884620494:52,Testability,test,tests,52,Should I hold on reviewing until you figure out the tests?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1869#issuecomment-884620494
https://github.com/CliMA/Oceananigans.jl/pull/1869#issuecomment-884797909:54,Testability,test,tests,54,"> Should I hold on reviewing until you figure out the tests?. No, it's ready for review. The lingering remaining issues are not substantial.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1869#issuecomment-884797909
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882051618:172,Usability,simpl,simply,172,"> > oh @glwagner, did you already did this in #1867?; > > If so then close this... :) (and link #1620 to #1867); > ; > No, I didn't! #1867 is just an issue, not a PR. ?. I simply got confused... :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882051618
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326:1312,Availability,down,down,1312,"up Ratio"", title=""Incompressible Model Benchmarks: CPU/GPU""); benchmark/benchmark_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model benchmarks""); benchmark/benchmark_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model.jl: @info ""Benchmarking distributed incompressible model strong scaling with $(typeof(decomposition)) decomposition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed incompressible model on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Benchmarking distributed incompressible model on rank $local_rank...""; docs/src/physics/incompressible_model.md:# Incompressible model; docs/src/numerical_implementation/time_stepping.md:where, e.g., ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326:2718,Integrability,protocol,protocols,2718,"osition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed incompressible model on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Benchmarking distributed incompressible model on rank $local_rank...""; docs/src/physics/incompressible_model.md:# Incompressible model; docs/src/numerical_implementation/time_stepping.md:where, e.g., for the incompressible model, ; docs/make.jl: ""Incompressible model"" => ""physics/incompressible_model.md"",; src/Distributed/distributed_incompressible_model.jl:##### Distributed incompressible model constructor; validation/immersed_boundaries/flow_around_cylinder.jl:# setting up incompressible model with immersed boundary; ```. If you're okay with it I can make these alterations myself (idk what are the protocols about modifying other people's PRs...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326:1344,Performance,perform,performance,1344,"up Ratio"", title=""Incompressible Model Benchmarks: CPU/GPU""); benchmark/benchmark_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model benchmarks""); benchmark/benchmark_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model.jl: @info ""Benchmarking distributed incompressible model strong scaling with $(typeof(decomposition)) decomposition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed incompressible model on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Benchmarking distributed incompressible model on rank $local_rank...""; docs/src/physics/incompressible_model.md:# Incompressible model; docs/src/numerical_implementation/time_stepping.md:where, e.g., ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326:2523,Security,validat,validation,2523,"osition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed incompressible model on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Benchmarking distributed incompressible model on rank $local_rank...""; docs/src/physics/incompressible_model.md:# Incompressible model; docs/src/numerical_implementation/time_stepping.md:where, e.g., for the incompressible model, ; docs/make.jl: ""Incompressible model"" => ""physics/incompressible_model.md"",; src/Distributed/distributed_incompressible_model.jl:##### Distributed incompressible model constructor; validation/immersed_boundaries/flow_around_cylinder.jl:# setting up incompressible model with immersed boundary; ```. If you're okay with it I can make these alterations myself (idk what are the protocols about modifying other people's PRs...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326:107,Testability,benchmark,benchmark,107,"This is what I found:. ```; (base) tomas@np900:~/repos/Oceananigans.jl$ grep -ri ""incompressible model"" *; benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Times (ms)"", title=""Incompressible Model Benchmarks: CPU vs GPU""); benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Speedup Ratio"", title=""Incompressible Model Benchmarks: CPU/GPU""); benchmark/benchmark_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model benchmarks""); benchmark/benchmark_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model.jl: @info ""Benchmarking distributed incompressible model strong scaling with $(typeof(decomposition)) decomposition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326:214,Testability,Benchmark,Benchmarks,214,"This is what I found:. ```; (base) tomas@np900:~/repos/Oceananigans.jl$ grep -ri ""incompressible model"" *; benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Times (ms)"", title=""Incompressible Model Benchmarks: CPU vs GPU""); benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Speedup Ratio"", title=""Incompressible Model Benchmarks: CPU/GPU""); benchmark/benchmark_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model benchmarks""); benchmark/benchmark_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model.jl: @info ""Benchmarking distributed incompressible model strong scaling with $(typeof(decomposition)) decomposition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326:240,Testability,benchmark,benchmark,240,"This is what I found:. ```; (base) tomas@np900:~/repos/Oceananigans.jl$ grep -ri ""incompressible model"" *; benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Times (ms)"", title=""Incompressible Model Benchmarks: CPU vs GPU""); benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Speedup Ratio"", title=""Incompressible Model Benchmarks: CPU/GPU""); benchmark/benchmark_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model benchmarks""); benchmark/benchmark_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model.jl: @info ""Benchmarking distributed incompressible model strong scaling with $(typeof(decomposition)) decomposition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326:350,Testability,Benchmark,Benchmarks,350,"This is what I found:. ```; (base) tomas@np900:~/repos/Oceananigans.jl$ grep -ri ""incompressible model"" *; benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Times (ms)"", title=""Incompressible Model Benchmarks: CPU vs GPU""); benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Speedup Ratio"", title=""Incompressible Model Benchmarks: CPU/GPU""); benchmark/benchmark_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model benchmarks""); benchmark/benchmark_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model.jl: @info ""Benchmarking distributed incompressible model strong scaling with $(typeof(decomposition)) decomposition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326:373,Testability,benchmark,benchmark,373,"This is what I found:. ```; (base) tomas@np900:~/repos/Oceananigans.jl$ grep -ri ""incompressible model"" *; benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Times (ms)"", title=""Incompressible Model Benchmarks: CPU vs GPU""); benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Speedup Ratio"", title=""Incompressible Model Benchmarks: CPU/GPU""); benchmark/benchmark_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model benchmarks""); benchmark/benchmark_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model.jl: @info ""Benchmarking distributed incompressible model strong scaling with $(typeof(decomposition)) decomposition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326:473,Testability,benchmark,benchmarks,473,"This is what I found:. ```; (base) tomas@np900:~/repos/Oceananigans.jl$ grep -ri ""incompressible model"" *; benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Times (ms)"", title=""Incompressible Model Benchmarks: CPU vs GPU""); benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Speedup Ratio"", title=""Incompressible Model Benchmarks: CPU/GPU""); benchmark/benchmark_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model benchmarks""); benchmark/benchmark_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model.jl: @info ""Benchmarking distributed incompressible model strong scaling with $(typeof(decomposition)) decomposition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326:487,Testability,benchmark,benchmark,487,"This is what I found:. ```; (base) tomas@np900:~/repos/Oceananigans.jl$ grep -ri ""incompressible model"" *; benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Times (ms)"", title=""Incompressible Model Benchmarks: CPU vs GPU""); benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Speedup Ratio"", title=""Incompressible Model Benchmarks: CPU/GPU""); benchmark/benchmark_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model benchmarks""); benchmark/benchmark_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model.jl: @info ""Benchmarking distributed incompressible model strong scaling with $(typeof(decomposition)) decomposition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326:612,Testability,benchmark,benchmark,612,"This is what I found:. ```; (base) tomas@np900:~/repos/Oceananigans.jl$ grep -ri ""incompressible model"" *; benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Times (ms)"", title=""Incompressible Model Benchmarks: CPU vs GPU""); benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Speedup Ratio"", title=""Incompressible Model Benchmarks: CPU/GPU""); benchmark/benchmark_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model benchmarks""); benchmark/benchmark_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model.jl: @info ""Benchmarking distributed incompressible model strong scaling with $(typeof(decomposition)) decomposition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326:669,Testability,Benchmark,Benchmarking,669,"This is what I found:. ```; (base) tomas@np900:~/repos/Oceananigans.jl$ grep -ri ""incompressible model"" *; benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Times (ms)"", title=""Incompressible Model Benchmarks: CPU vs GPU""); benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Speedup Ratio"", title=""Incompressible Model Benchmarks: CPU/GPU""); benchmark/benchmark_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model benchmarks""); benchmark/benchmark_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model.jl: @info ""Benchmarking distributed incompressible model strong scaling with $(typeof(decomposition)) decomposition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326:822,Testability,benchmark,benchmark,822,"This is what I found:. ```; (base) tomas@np900:~/repos/Oceananigans.jl$ grep -ri ""incompressible model"" *; benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Times (ms)"", title=""Incompressible Model Benchmarks: CPU vs GPU""); benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Speedup Ratio"", title=""Incompressible Model Benchmarks: CPU/GPU""); benchmark/benchmark_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model benchmarks""); benchmark/benchmark_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model.jl: @info ""Benchmarking distributed incompressible model strong scaling with $(typeof(decomposition)) decomposition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326:942,Testability,benchmark,benchmark,942,"This is what I found:. ```; (base) tomas@np900:~/repos/Oceananigans.jl$ grep -ri ""incompressible model"" *; benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Times (ms)"", title=""Incompressible Model Benchmarks: CPU vs GPU""); benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Speedup Ratio"", title=""Incompressible Model Benchmarks: CPU/GPU""); benchmark/benchmark_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model benchmarks""); benchmark/benchmark_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model.jl: @info ""Benchmarking distributed incompressible model strong scaling with $(typeof(decomposition)) decomposition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326:955,Testability,benchmark,benchmark,955,"This is what I found:. ```; (base) tomas@np900:~/repos/Oceananigans.jl$ grep -ri ""incompressible model"" *; benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Times (ms)"", title=""Incompressible Model Benchmarks: CPU vs GPU""); benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Speedup Ratio"", title=""Incompressible Model Benchmarks: CPU/GPU""); benchmark/benchmark_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model benchmarks""); benchmark/benchmark_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model.jl: @info ""Benchmarking distributed incompressible model strong scaling with $(typeof(decomposition)) decomposition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326:1088,Testability,benchmark,benchmark,1088,"s/Oceananigans.jl$ grep -ri ""incompressible model"" *; benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Times (ms)"", title=""Incompressible Model Benchmarks: CPU vs GPU""); benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Speedup Ratio"", title=""Incompressible Model Benchmarks: CPU/GPU""); benchmark/benchmark_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model benchmarks""); benchmark/benchmark_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model.jl: @info ""Benchmarking distributed incompressible model strong scaling with $(typeof(decomposition)) decomposition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed incompressible model on rank $local_rank...""; bench",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326:1187,Testability,test,tests,1187,"pressible Model Benchmarks: CPU vs GPU""); benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Speedup Ratio"", title=""Incompressible Model Benchmarks: CPU/GPU""); benchmark/benchmark_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model benchmarks""); benchmark/benchmark_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model.jl: @info ""Benchmarking distributed incompressible model strong scaling with $(typeof(decomposition)) decomposition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed incompressible model on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Benchmarking distributed incompressible model on rank $local_rank...""; docs/src/physics/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326:1274,Testability,test,test,1274,"up Ratio"", title=""Incompressible Model Benchmarks: CPU/GPU""); benchmark/benchmark_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model benchmarks""); benchmark/benchmark_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model.jl: @info ""Benchmarking distributed incompressible model strong scaling with $(typeof(decomposition)) decomposition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed incompressible model on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Benchmarking distributed incompressible model on rank $local_rank...""; docs/src/physics/incompressible_model.md:# Incompressible model; docs/src/numerical_implementation/time_stepping.md:where, e.g., ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326:1369,Testability,benchmark,benchmark,1369,"ressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model benchmarks""); benchmark/benchmark_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model.jl: @info ""Benchmarking distributed incompressible model strong scaling with $(typeof(decomposition)) decomposition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed incompressible model on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Benchmarking distributed incompressible model on rank $local_rank...""; docs/src/physics/incompressible_model.md:# Incompressible model; docs/src/numerical_implementation/time_stepping.md:where, e.g., for the incompressible model, ; docs/make.jl: ""Incompressible model"" => ""physics/incompr",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326:1511,Testability,benchmark,benchmarks,1511,"compressible_model.jl: benchmarks_pretty_table(df_, title=""Incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model.jl: @info ""Benchmarking distributed incompressible model strong scaling with $(typeof(decomposition)) decomposition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed incompressible model on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Benchmarking distributed incompressible model on rank $local_rank...""; docs/src/physics/incompressible_model.md:# Incompressible model; docs/src/numerical_implementation/time_stepping.md:where, e.g., for the incompressible model, ; docs/make.jl: ""Incompressible model"" => ""physics/incompressible_model.md"",; src/Distributed/distributed_incompressible_model.jl:##### Distributed incompressible model",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326:1525,Testability,benchmark,benchmark,1525,"compressible_model.jl: benchmarks_pretty_table(df_, title=""Incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model.jl: @info ""Benchmarking distributed incompressible model strong scaling with $(typeof(decomposition)) decomposition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed incompressible model on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Benchmarking distributed incompressible model on rank $local_rank...""; docs/src/physics/incompressible_model.md:# Incompressible model; docs/src/numerical_implementation/time_stepping.md:where, e.g., for the incompressible model, ; docs/make.jl: ""Incompressible model"" => ""physics/incompressible_model.md"",; src/Distributed/distributed_incompressible_model.jl:##### Distributed incompressible model",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326:1692,Testability,benchmark,benchmark,1692,"o ""Benchmarking distributed incompressible model strong scaling with $(typeof(decomposition)) decomposition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed incompressible model on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Benchmarking distributed incompressible model on rank $local_rank...""; docs/src/physics/incompressible_model.md:# Incompressible model; docs/src/numerical_implementation/time_stepping.md:where, e.g., for the incompressible model, ; docs/make.jl: ""Incompressible model"" => ""physics/incompressible_model.md"",; src/Distributed/distributed_incompressible_model.jl:##### Distributed incompressible model constructor; validation/immersed_boundaries/flow_around_cylinder.jl:# setting up incompressible model with immersed boundary; ```. If you're okay with it I ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326:1916,Testability,benchmark,benchmark,1916,"osition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed incompressible model on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Benchmarking distributed incompressible model on rank $local_rank...""; docs/src/physics/incompressible_model.md:# Incompressible model; docs/src/numerical_implementation/time_stepping.md:where, e.g., for the incompressible model, ; docs/make.jl: ""Incompressible model"" => ""physics/incompressible_model.md"",; src/Distributed/distributed_incompressible_model.jl:##### Distributed incompressible model constructor; validation/immersed_boundaries/flow_around_cylinder.jl:# setting up incompressible model with immersed boundary; ```. If you're okay with it I can make these alterations myself (idk what are the protocols about modifying other people's PRs...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326:2048,Testability,benchmark,benchmark,2048,"osition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed incompressible model on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Benchmarking distributed incompressible model on rank $local_rank...""; docs/src/physics/incompressible_model.md:# Incompressible model; docs/src/numerical_implementation/time_stepping.md:where, e.g., for the incompressible model, ; docs/make.jl: ""Incompressible model"" => ""physics/incompressible_model.md"",; src/Distributed/distributed_incompressible_model.jl:##### Distributed incompressible model constructor; validation/immersed_boundaries/flow_around_cylinder.jl:# setting up incompressible model with immersed boundary; ```. If you're okay with it I can make these alterations myself (idk what are the protocols about modifying other people's PRs...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326:2111,Testability,Benchmark,Benchmarking,2111,"osition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed incompressible model on rank $local_rank...""; benchmark/strong_scaling_incompressible_model_single.jl:@info ""Benchmarking distributed incompressible model on rank $local_rank...""; docs/src/physics/incompressible_model.md:# Incompressible model; docs/src/numerical_implementation/time_stepping.md:where, e.g., for the incompressible model, ; docs/make.jl: ""Incompressible model"" => ""physics/incompressible_model.md"",; src/Distributed/distributed_incompressible_model.jl:##### Distributed incompressible model constructor; validation/immersed_boundaries/flow_around_cylinder.jl:# setting up incompressible model with immersed boundary; ```. If you're okay with it I can make these alterations myself (idk what are the protocols about modifying other people's PRs...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882146326
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932:1338,Availability,down,down,1338,"itle=""Incompressible Model Benchmarks: CPU/GPU""); > benchmark/benchmark_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model benchmarks""); > benchmark/benchmark_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model.jl: @info ""Benchmarking distributed incompressible model strong scaling with $(typeof(decomposition)) decomposition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); > benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; > benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); > benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed incompressible model on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Benchmarking distributed incompressible model on rank $local_rank...""; > docs/src/physics/incompressible_model.md:# Incompressible model; > docs/src/numerical_implementation/time_stepping.md",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932:2772,Integrability,protocol,protocols,2772,"mark""); > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); > benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; > benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); > benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed incompressible model on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Benchmarking distributed incompressible model on rank $local_rank...""; > docs/src/physics/incompressible_model.md:# Incompressible model; > docs/src/numerical_implementation/time_stepping.md:where, e.g., for the incompressible model, ; > docs/make.jl: ""Incompressible model"" => ""physics/incompressible_model.md"",; > src/Distributed/distributed_incompressible_model.jl:##### Distributed incompressible model constructor; > validation/immersed_boundaries/flow_around_cylinder.jl:# setting up incompressible model with immersed boundary; > ```; > ; > If you're okay with it I can make these alterations myself (idk what are the protocols about modifying other people's PRs...). Thanks that's helpful!; Hm... Are you sure you are looking at the latest version? Because some of those incompressible things I've changed already!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932:1370,Performance,perform,performance,1370,"itle=""Incompressible Model Benchmarks: CPU/GPU""); > benchmark/benchmark_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model benchmarks""); > benchmark/benchmark_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model.jl: @info ""Benchmarking distributed incompressible model strong scaling with $(typeof(decomposition)) decomposition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); > benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; > benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); > benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed incompressible model on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Benchmarking distributed incompressible model on rank $local_rank...""; > docs/src/physics/incompressible_model.md:# Incompressible model; > docs/src/numerical_implementation/time_stepping.md",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932:2569,Security,validat,validation,2569,"mark""); > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); > benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; > benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); > benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed incompressible model on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Benchmarking distributed incompressible model on rank $local_rank...""; > docs/src/physics/incompressible_model.md:# Incompressible model; > docs/src/numerical_implementation/time_stepping.md:where, e.g., for the incompressible model, ; > docs/make.jl: ""Incompressible model"" => ""physics/incompressible_model.md"",; > src/Distributed/distributed_incompressible_model.jl:##### Distributed incompressible model constructor; > validation/immersed_boundaries/flow_around_cylinder.jl:# setting up incompressible model with immersed boundary; > ```; > ; > If you're okay with it I can make these alterations myself (idk what are the protocols about modifying other people's PRs...). Thanks that's helpful!; Hm... Are you sure you are looking at the latest version? Because some of those incompressible things I've changed already!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932:119,Testability,benchmark,benchmark,119,"> This is what I found:; > ; > ```; > (base) tomas@np900:~/repos/Oceananigans.jl$ grep -ri ""incompressible model"" *; > benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Times (ms)"", title=""Incompressible Model Benchmarks: CPU vs GPU""); > benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Speedup Ratio"", title=""Incompressible Model Benchmarks: CPU/GPU""); > benchmark/benchmark_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model benchmarks""); > benchmark/benchmark_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model.jl: @info ""Benchmarking distributed incompressible model strong scaling with $(typeof(decomposition)) decomposition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); > benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; > benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); > benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_singl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932:226,Testability,Benchmark,Benchmarks,226,"> This is what I found:; > ; > ```; > (base) tomas@np900:~/repos/Oceananigans.jl$ grep -ri ""incompressible model"" *; > benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Times (ms)"", title=""Incompressible Model Benchmarks: CPU vs GPU""); > benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Speedup Ratio"", title=""Incompressible Model Benchmarks: CPU/GPU""); > benchmark/benchmark_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model benchmarks""); > benchmark/benchmark_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model.jl: @info ""Benchmarking distributed incompressible model strong scaling with $(typeof(decomposition)) decomposition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); > benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; > benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); > benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_singl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932:254,Testability,benchmark,benchmark,254,"> This is what I found:; > ; > ```; > (base) tomas@np900:~/repos/Oceananigans.jl$ grep -ri ""incompressible model"" *; > benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Times (ms)"", title=""Incompressible Model Benchmarks: CPU vs GPU""); > benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Speedup Ratio"", title=""Incompressible Model Benchmarks: CPU/GPU""); > benchmark/benchmark_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model benchmarks""); > benchmark/benchmark_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model.jl: @info ""Benchmarking distributed incompressible model strong scaling with $(typeof(decomposition)) decomposition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); > benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; > benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); > benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_singl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932:364,Testability,Benchmark,Benchmarks,364,"> This is what I found:; > ; > ```; > (base) tomas@np900:~/repos/Oceananigans.jl$ grep -ri ""incompressible model"" *; > benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Times (ms)"", title=""Incompressible Model Benchmarks: CPU vs GPU""); > benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Speedup Ratio"", title=""Incompressible Model Benchmarks: CPU/GPU""); > benchmark/benchmark_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model benchmarks""); > benchmark/benchmark_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model.jl: @info ""Benchmarking distributed incompressible model strong scaling with $(typeof(decomposition)) decomposition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); > benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; > benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); > benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_singl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932:389,Testability,benchmark,benchmark,389,"> This is what I found:; > ; > ```; > (base) tomas@np900:~/repos/Oceananigans.jl$ grep -ri ""incompressible model"" *; > benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Times (ms)"", title=""Incompressible Model Benchmarks: CPU vs GPU""); > benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Speedup Ratio"", title=""Incompressible Model Benchmarks: CPU/GPU""); > benchmark/benchmark_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model benchmarks""); > benchmark/benchmark_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model.jl: @info ""Benchmarking distributed incompressible model strong scaling with $(typeof(decomposition)) decomposition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); > benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; > benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); > benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_singl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932:489,Testability,benchmark,benchmarks,489,"> This is what I found:; > ; > ```; > (base) tomas@np900:~/repos/Oceananigans.jl$ grep -ri ""incompressible model"" *; > benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Times (ms)"", title=""Incompressible Model Benchmarks: CPU vs GPU""); > benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Speedup Ratio"", title=""Incompressible Model Benchmarks: CPU/GPU""); > benchmark/benchmark_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model benchmarks""); > benchmark/benchmark_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model.jl: @info ""Benchmarking distributed incompressible model strong scaling with $(typeof(decomposition)) decomposition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); > benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; > benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); > benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_singl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932:505,Testability,benchmark,benchmark,505,"> This is what I found:; > ; > ```; > (base) tomas@np900:~/repos/Oceananigans.jl$ grep -ri ""incompressible model"" *; > benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Times (ms)"", title=""Incompressible Model Benchmarks: CPU vs GPU""); > benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Speedup Ratio"", title=""Incompressible Model Benchmarks: CPU/GPU""); > benchmark/benchmark_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model benchmarks""); > benchmark/benchmark_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model.jl: @info ""Benchmarking distributed incompressible model strong scaling with $(typeof(decomposition)) decomposition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); > benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; > benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); > benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_singl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932:632,Testability,benchmark,benchmark,632,"> This is what I found:; > ; > ```; > (base) tomas@np900:~/repos/Oceananigans.jl$ grep -ri ""incompressible model"" *; > benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Times (ms)"", title=""Incompressible Model Benchmarks: CPU vs GPU""); > benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Speedup Ratio"", title=""Incompressible Model Benchmarks: CPU/GPU""); > benchmark/benchmark_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model benchmarks""); > benchmark/benchmark_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model.jl: @info ""Benchmarking distributed incompressible model strong scaling with $(typeof(decomposition)) decomposition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); > benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; > benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); > benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_singl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932:689,Testability,Benchmark,Benchmarking,689,"> This is what I found:; > ; > ```; > (base) tomas@np900:~/repos/Oceananigans.jl$ grep -ri ""incompressible model"" *; > benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Times (ms)"", title=""Incompressible Model Benchmarks: CPU vs GPU""); > benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Speedup Ratio"", title=""Incompressible Model Benchmarks: CPU/GPU""); > benchmark/benchmark_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model benchmarks""); > benchmark/benchmark_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model.jl: @info ""Benchmarking distributed incompressible model strong scaling with $(typeof(decomposition)) decomposition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); > benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; > benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); > benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_singl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932:844,Testability,benchmark,benchmark,844,"> This is what I found:; > ; > ```; > (base) tomas@np900:~/repos/Oceananigans.jl$ grep -ri ""incompressible model"" *; > benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Times (ms)"", title=""Incompressible Model Benchmarks: CPU vs GPU""); > benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Speedup Ratio"", title=""Incompressible Model Benchmarks: CPU/GPU""); > benchmark/benchmark_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model benchmarks""); > benchmark/benchmark_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model.jl: @info ""Benchmarking distributed incompressible model strong scaling with $(typeof(decomposition)) decomposition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); > benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; > benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); > benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_singl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932:964,Testability,benchmark,benchmark,964,"> This is what I found:; > ; > ```; > (base) tomas@np900:~/repos/Oceananigans.jl$ grep -ri ""incompressible model"" *; > benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Times (ms)"", title=""Incompressible Model Benchmarks: CPU vs GPU""); > benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Speedup Ratio"", title=""Incompressible Model Benchmarks: CPU/GPU""); > benchmark/benchmark_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model benchmarks""); > benchmark/benchmark_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model.jl: @info ""Benchmarking distributed incompressible model strong scaling with $(typeof(decomposition)) decomposition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); > benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; > benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); > benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_singl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932:979,Testability,benchmark,benchmark,979,"> This is what I found:; > ; > ```; > (base) tomas@np900:~/repos/Oceananigans.jl$ grep -ri ""incompressible model"" *; > benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Times (ms)"", title=""Incompressible Model Benchmarks: CPU vs GPU""); > benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Speedup Ratio"", title=""Incompressible Model Benchmarks: CPU/GPU""); > benchmark/benchmark_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model benchmarks""); > benchmark/benchmark_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model.jl: @info ""Benchmarking distributed incompressible model strong scaling with $(typeof(decomposition)) decomposition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); > benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; > benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); > benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_singl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932:1114,Testability,benchmark,benchmark,1114,"jl$ grep -ri ""incompressible model"" *; > benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Times (ms)"", title=""Incompressible Model Benchmarks: CPU vs GPU""); > benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Speedup Ratio"", title=""Incompressible Model Benchmarks: CPU/GPU""); > benchmark/benchmark_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model benchmarks""); > benchmark/benchmark_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model.jl: @info ""Benchmarking distributed incompressible model strong scaling with $(typeof(decomposition)) decomposition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); > benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; > benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); > benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed incompressible model on rank $local_rank..",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932:1213,Testability,test,tests,1213,"l Benchmarks: CPU vs GPU""); > benchmark/benchmark_incompressible_model.jl: xlabel=""Nx"", ylabel=""Speedup Ratio"", title=""Incompressible Model Benchmarks: CPU/GPU""); > benchmark/benchmark_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model benchmarks""); > benchmark/benchmark_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model.jl: @info ""Benchmarking distributed incompressible model strong scaling with $(typeof(decomposition)) decomposition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); > benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; > benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); > benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed incompressible model on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Benchmarking distributed incompressible model on rank $local_rank...""; > docs/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932:1300,Testability,test,test,1300,"itle=""Incompressible Model Benchmarks: CPU/GPU""); > benchmark/benchmark_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model benchmarks""); > benchmark/benchmark_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model.jl: @info ""Benchmarking distributed incompressible model strong scaling with $(typeof(decomposition)) decomposition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); > benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; > benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); > benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed incompressible model on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Benchmarking distributed incompressible model on rank $local_rank...""; > docs/src/physics/incompressible_model.md:# Incompressible model; > docs/src/numerical_implementation/time_stepping.md",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932:1397,Testability,benchmark,benchmark,1397,"del.jl:benchmarks_pretty_table(df, title=""Incompressible model benchmarks""); > benchmark/benchmark_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model.jl: @info ""Benchmarking distributed incompressible model strong scaling with $(typeof(decomposition)) decomposition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); > benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; > benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); > benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed incompressible model on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Benchmarking distributed incompressible model on rank $local_rank...""; > docs/src/physics/incompressible_model.md:# Incompressible model; > docs/src/numerical_implementation/time_stepping.md:where, e.g., for the incompressible model, ; > docs/make.jl: ""Incompressible model"" => """,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932:1539,Testability,benchmark,benchmarks,1539,"e_model.jl: benchmarks_pretty_table(df_, title=""Incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model.jl: @info ""Benchmarking distributed incompressible model strong scaling with $(typeof(decomposition)) decomposition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); > benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; > benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); > benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed incompressible model on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Benchmarking distributed incompressible model on rank $local_rank...""; > docs/src/physics/incompressible_model.md:# Incompressible model; > docs/src/numerical_implementation/time_stepping.md:where, e.g., for the incompressible model, ; > docs/make.jl: ""Incompressible model"" => ""physics/incompressible_model.md"",; > src/Distributed/distributed_incompressible_model.jl:##### Distributed incom",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932:1555,Testability,benchmark,benchmark,1555,"e_model.jl: benchmarks_pretty_table(df_, title=""Incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model.jl: @info ""Benchmarking distributed incompressible model strong scaling with $(typeof(decomposition)) decomposition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); > benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; > benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); > benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed incompressible model on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Benchmarking distributed incompressible model on rank $local_rank...""; > docs/src/physics/incompressible_model.md:# Incompressible model; > docs/src/numerical_implementation/time_stepping.md:where, e.g., for the incompressible model, ; > docs/make.jl: ""Incompressible model"" => ""physics/incompressible_model.md"",; > src/Distributed/distributed_incompressible_model.jl:##### Distributed incom",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932:1724,Testability,benchmark,benchmark,1724,"king distributed incompressible model strong scaling with $(typeof(decomposition)) decomposition [N=($Nx, $Ny, $Nz), ranks=($Rx, $Ry, $Rz)]...""; > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df, title=""Incompressible model strong scaling benchmark""); > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); > benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; > benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); > benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed incompressible model on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Benchmarking distributed incompressible model on rank $local_rank...""; > docs/src/physics/incompressible_model.md:# Incompressible model; > docs/src/numerical_implementation/time_stepping.md:where, e.g., for the incompressible model, ; > docs/make.jl: ""Incompressible model"" => ""physics/incompressible_model.md"",; > src/Distributed/distributed_incompressible_model.jl:##### Distributed incompressible model constructor; > validation/immersed_boundaries/flow_around_cylinder.jl:# setting up incompressible model with immersed boundary; > ```; > ; > If",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932:1950,Testability,benchmark,benchmark,1950,"mark""); > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); > benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; > benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); > benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed incompressible model on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Benchmarking distributed incompressible model on rank $local_rank...""; > docs/src/physics/incompressible_model.md:# Incompressible model; > docs/src/numerical_implementation/time_stepping.md:where, e.g., for the incompressible model, ; > docs/make.jl: ""Incompressible model"" => ""physics/incompressible_model.md"",; > src/Distributed/distributed_incompressible_model.jl:##### Distributed incompressible model constructor; > validation/immersed_boundaries/flow_around_cylinder.jl:# setting up incompressible model with immersed boundary; > ```; > ; > If you're okay with it I can make these alterations myself (idk what are the protocols about modifying other people's PRs...). Thanks that's helpful!; Hm... Are you sure you are looking at the latest version? Because some of those incompressible things I've changed already!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932:2084,Testability,benchmark,benchmark,2084,"mark""); > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); > benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; > benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); > benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed incompressible model on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Benchmarking distributed incompressible model on rank $local_rank...""; > docs/src/physics/incompressible_model.md:# Incompressible model; > docs/src/numerical_implementation/time_stepping.md:where, e.g., for the incompressible model, ; > docs/make.jl: ""Incompressible model"" => ""physics/incompressible_model.md"",; > src/Distributed/distributed_incompressible_model.jl:##### Distributed incompressible model constructor; > validation/immersed_boundaries/flow_around_cylinder.jl:# setting up incompressible model with immersed boundary; > ```; > ; > If you're okay with it I can make these alterations myself (idk what are the protocols about modifying other people's PRs...). Thanks that's helpful!; Hm... Are you sure you are looking at the latest version? Because some of those incompressible things I've changed already!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932:2147,Testability,Benchmark,Benchmarking,2147,"mark""); > benchmark/strong_scaling_incompressible_model.jl:benchmarks_pretty_table(df_, title=""Incompressible model strong scaling speedup""); > benchmark/README.md:Running the `benchmark_regression.jl` script will run the incompressible model tests on the current branch and on the master branch for comparison. This is useful to test whether the current branch slows down the code or introduces any performance regression.; > benchmark/benchmark_vertically_stretched_incompressible_model.jl:benchmarks_pretty_table(df, title=""Vertically-stretched incompressible model benchmarks""); > benchmark/benchmark_vertically_stretched_incompressible_model.jl: benchmarks_pretty_table(df_, title=""Vertically-stretched incompressible model CPU to GPU speedup""); > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Setting up distributed incompressible model with N=($Nx, $Ny, $Nz) grid points and ranks=($Rx, $Ry, $Rz) ($decomposition decomposition) on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Warming up distributed incompressible model on rank $local_rank...""; > benchmark/strong_scaling_incompressible_model_single.jl:@info ""Benchmarking distributed incompressible model on rank $local_rank...""; > docs/src/physics/incompressible_model.md:# Incompressible model; > docs/src/numerical_implementation/time_stepping.md:where, e.g., for the incompressible model, ; > docs/make.jl: ""Incompressible model"" => ""physics/incompressible_model.md"",; > src/Distributed/distributed_incompressible_model.jl:##### Distributed incompressible model constructor; > validation/immersed_boundaries/flow_around_cylinder.jl:# setting up incompressible model with immersed boundary; > ```; > ; > If you're okay with it I can make these alterations myself (idk what are the protocols about modifying other people's PRs...). Thanks that's helpful!; Hm... Are you sure you are looking at the latest version? Because some of those incompressible things I've changed already!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882147932
https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882149988:175,Integrability,protocol,protocol,175,"but, @tomchor, I'd be definitely more than happy if you'd made these changes since they are trivial and need not be discussed or what not ;). (just saying in response to your protocol concerns..!). thanks for reviewing!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1870#issuecomment-882149988
https://github.com/CliMA/Oceananigans.jl/issues/1872#issuecomment-882572666:180,Usability,clear,clear,180,"> The horizontal convection example with a boundary layer at the top is ideal for a VerticallyStretchedRectilinearGrid. I'm not sure I agree with this statement though. Just to be clear: I'm not saying I disagree, it's just not obvious to me that that's the case. From the videos in the example the viscous boundary layer seems pretty well-resolved to me (unless you're planning on changing the Pr (or Ra) number?). Plus the turbulence pretty much covers the whole domain, so I don't think we'd want a very coarse grid at the bottom. Is there a metric to look at to gauge the ""resolvedness"" of the viscous boundary layer?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1872#issuecomment-882572666
https://github.com/CliMA/Oceananigans.jl/issues/1872#issuecomment-882858629:259,Integrability,depend,depending,259,"Hm... I see both your points. The boundary layer is indeed pronounced in the buoyancy or buoyancy dissipation. But indeed for Ra=1e8 the boundary layer is most probably well-resolved. The boundary layer thickness, however, scales with Ra^{-1/5} or Ra^{-1/4} (depending on the flow regime)... Thus, for the Ra value in the example you are right: no modification is needed. But if one wants to take this up to higher Ra values then higher vertical resolution near the top will help. Perhaps we close this issue (as, I agree, is not really an _issue_ of the code). Or convert to discussion?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1872#issuecomment-882858629
https://github.com/CliMA/Oceananigans.jl/issues/1873#issuecomment-882642426:373,Integrability,depend,dependencies,373,"The answer for this, as per @glwagner's comments, is because that's the syntax for `KernelAbstractions`, which we use to compute GPU kernels:. From @glwagner :. The kernel is created here:; `diffusivity_kernel! = calculate_tracer_diffusivity!(device(arch), workgroup, worksize)`; and launched here:; `event = diffusivity_kernel!(, grid, closure, c, Val(tracer_index), U, dependencies=barrier)`; the diffiusivity calculations do not depend on one another, so they are all launch simultaneously. At the end, we wait for all of them to finish here:; `wait(device(arch), MultiEvent(Tuple(events)))`. Noticeably apparently we don't use `lauch!` in this case, even though apparently we should?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1873#issuecomment-882642426
https://github.com/CliMA/Oceananigans.jl/issues/1873#issuecomment-882642426:434,Integrability,depend,depend,434,"The answer for this, as per @glwagner's comments, is because that's the syntax for `KernelAbstractions`, which we use to compute GPU kernels:. From @glwagner :. The kernel is created here:; `diffusivity_kernel! = calculate_tracer_diffusivity!(device(arch), workgroup, worksize)`; and launched here:; `event = diffusivity_kernel!(, grid, closure, c, Val(tracer_index), U, dependencies=barrier)`; the diffiusivity calculations do not depend on one another, so they are all launch simultaneously. At the end, we wait for all of them to finish here:; `wait(device(arch), MultiEvent(Tuple(events)))`. Noticeably apparently we don't use `lauch!` in this case, even though apparently we should?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1873#issuecomment-882642426
https://github.com/CliMA/Oceananigans.jl/issues/1873#issuecomment-882653413:485,Integrability,interface,interface,485,"> Here's a question: wouldn't it be better if this were a `KernelComputedField`? (Or maybe even a `KernelFunctionOperation`?). I think reusing more features that have been developed for user applications internally is a great idea in general. More code reuse, more understandable internals. I have thought about this a bit for diffusivities and pressure fields, which are both auxiliary fields to a model and some flavor of ""ComputedField"". I think we would need to expand on the user interface to `KernelComputedField` for this purpose. There are a few reasons. First, the user interface to ComputedField does not supply a way to combine kernel computations for more than one field. Second, we need to develop a user interface for propagating arguments from `compute!` into the kernel. The reason is that we have to pass in both `closure` and `buoyancy` into this kernel. `KernelComputedField` supports parameters right now. However, I think its important that these arguments are explicitly passed from the model (rather than being bound to the diffusivities at model construction time) --- because models are mutable, which means that users can change the closure or buoyancy model on the fly (provided the new object has the same type as the old one). Expanding the computed field infrastructure to support simultaneous computation and propagated arguments would be really cool I think and a great addition to the code. Once that's done we could consider refactoring internal code, which would also be awesome.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1873#issuecomment-882653413
https://github.com/CliMA/Oceananigans.jl/issues/1873#issuecomment-882653413:579,Integrability,interface,interface,579,"> Here's a question: wouldn't it be better if this were a `KernelComputedField`? (Or maybe even a `KernelFunctionOperation`?). I think reusing more features that have been developed for user applications internally is a great idea in general. More code reuse, more understandable internals. I have thought about this a bit for diffusivities and pressure fields, which are both auxiliary fields to a model and some flavor of ""ComputedField"". I think we would need to expand on the user interface to `KernelComputedField` for this purpose. There are a few reasons. First, the user interface to ComputedField does not supply a way to combine kernel computations for more than one field. Second, we need to develop a user interface for propagating arguments from `compute!` into the kernel. The reason is that we have to pass in both `closure` and `buoyancy` into this kernel. `KernelComputedField` supports parameters right now. However, I think its important that these arguments are explicitly passed from the model (rather than being bound to the diffusivities at model construction time) --- because models are mutable, which means that users can change the closure or buoyancy model on the fly (provided the new object has the same type as the old one). Expanding the computed field infrastructure to support simultaneous computation and propagated arguments would be really cool I think and a great addition to the code. Once that's done we could consider refactoring internal code, which would also be awesome.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1873#issuecomment-882653413
https://github.com/CliMA/Oceananigans.jl/issues/1873#issuecomment-882653413:718,Integrability,interface,interface,718,"> Here's a question: wouldn't it be better if this were a `KernelComputedField`? (Or maybe even a `KernelFunctionOperation`?). I think reusing more features that have been developed for user applications internally is a great idea in general. More code reuse, more understandable internals. I have thought about this a bit for diffusivities and pressure fields, which are both auxiliary fields to a model and some flavor of ""ComputedField"". I think we would need to expand on the user interface to `KernelComputedField` for this purpose. There are a few reasons. First, the user interface to ComputedField does not supply a way to combine kernel computations for more than one field. Second, we need to develop a user interface for propagating arguments from `compute!` into the kernel. The reason is that we have to pass in both `closure` and `buoyancy` into this kernel. `KernelComputedField` supports parameters right now. However, I think its important that these arguments are explicitly passed from the model (rather than being bound to the diffusivities at model construction time) --- because models are mutable, which means that users can change the closure or buoyancy model on the fly (provided the new object has the same type as the old one). Expanding the computed field infrastructure to support simultaneous computation and propagated arguments would be really cool I think and a great addition to the code. Once that's done we could consider refactoring internal code, which would also be awesome.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1873#issuecomment-882653413
https://github.com/CliMA/Oceananigans.jl/issues/1873#issuecomment-882653413:1459,Modifiability,refactor,refactoring,1459,"> Here's a question: wouldn't it be better if this were a `KernelComputedField`? (Or maybe even a `KernelFunctionOperation`?). I think reusing more features that have been developed for user applications internally is a great idea in general. More code reuse, more understandable internals. I have thought about this a bit for diffusivities and pressure fields, which are both auxiliary fields to a model and some flavor of ""ComputedField"". I think we would need to expand on the user interface to `KernelComputedField` for this purpose. There are a few reasons. First, the user interface to ComputedField does not supply a way to combine kernel computations for more than one field. Second, we need to develop a user interface for propagating arguments from `compute!` into the kernel. The reason is that we have to pass in both `closure` and `buoyancy` into this kernel. `KernelComputedField` supports parameters right now. However, I think its important that these arguments are explicitly passed from the model (rather than being bound to the diffusivities at model construction time) --- because models are mutable, which means that users can change the closure or buoyancy model on the fly (provided the new object has the same type as the old one). Expanding the computed field infrastructure to support simultaneous computation and propagated arguments would be really cool I think and a great addition to the code. Once that's done we could consider refactoring internal code, which would also be awesome.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1873#issuecomment-882653413
https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882718585:204,Availability,down,downside,204,"I'm also wondering if it would be better to compute the discrete perturbation vorticity by calculating the initial vorticity analytically, storing it, and using it when we calculate the perturbation. The downside is that the perturbation will contain the noise in addition to the Bickley jet. But since the noise is small this may not be a big deal.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882718585
https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882739134:83,Usability,clear,clearly,83,Please go ahead @glwagner and get this started. I am happy to help where I can but clearly you understand what needs to be done here better than I do.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882739134
https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882740823:241,Usability,simpl,simply,241,"I am open to trying something different with how vorticity is computed. I computed it exactly and used those analytical expressions, but this is a pain when you want to consider a different jet, and you have to compute this again. If we can simply state the initial velocity and height, and then compute the voriticty, that migth be easier.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882740823
https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882750311:376,Modifiability,flexible,flexible,376,"> I am open to trying something different with how vorticity is computed. I computed it exactly and used those analytical expressions, but this is a pain when you want to consider a different jet, and you have to compute this again. If we can simply state the initial velocity and height, and then compute the voriticty, that migth be easier. Right! In addition to being more flexible and illustrating the diagnostic procedure in general, a discrete calculation is more ""exact"" than an analytical expression.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882750311
https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882750311:243,Usability,simpl,simply,243,"> I am open to trying something different with how vorticity is computed. I computed it exactly and used those analytical expressions, but this is a pain when you want to consider a different jet, and you have to compute this again. If we can simply state the initial velocity and height, and then compute the voriticty, that migth be easier. Right! In addition to being more flexible and illustrating the diagnostic procedure in general, a discrete calculation is more ""exact"" than an analytical expression.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882750311
https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882755027:385,Modifiability,flexible,flexible,385,"> > I am open to trying something different with how vorticity is computed. I computed it exactly and used those analytical expressions, but this is a pain when you want to consider a different jet, and you have to compute this again. If we can simply state the initial velocity and height, and then compute the voriticty, that migth be easier.; > ; > Right! In addition to being more flexible and illustrating the diagnostic procedure in general, a discrete calculation is more ""exact"" than an analytical expression. I am puzzled by your statement here. A discrete, i.e. numerical calculation, is more exact than the analytical (so called exact) expression? . I guess it's more appropriate for the discretization that we are using, which is probably the point you are making. Okay, I see that and agree it's probably the better way to go.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882755027
https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882755027:245,Usability,simpl,simply,245,"> > I am open to trying something different with how vorticity is computed. I computed it exactly and used those analytical expressions, but this is a pain when you want to consider a different jet, and you have to compute this again. If we can simply state the initial velocity and height, and then compute the voriticty, that migth be easier.; > ; > Right! In addition to being more flexible and illustrating the diagnostic procedure in general, a discrete calculation is more ""exact"" than an analytical expression. I am puzzled by your statement here. A discrete, i.e. numerical calculation, is more exact than the analytical (so called exact) expression? . I guess it's more appropriate for the discretization that we are using, which is probably the point you are making. Okay, I see that and agree it's probably the better way to go.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882755027
https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882757399:1472,Deployability,continuous,continuous,1472,"> > > I am open to trying something different with how vorticity is computed. I computed it exactly and used those analytical expressions, but this is a pain when you want to consider a different jet, and you have to compute this again. If we can simply state the initial velocity and height, and then compute the voriticty, that migth be easier.; > > ; > > ; > > Right! In addition to being more flexible and illustrating the diagnostic procedure in general, a discrete calculation is more ""exact"" than an analytical expression.; > ; > I am puzzled by your statement here. A discrete, i.e. numerical calculation, is more exact than the analytical (so called exact) expression?; > ; > I guess it's more appropriate for the discretization that we are using, which is probably the point you are making. Okay, I see that and agree it's probably the better way to go. Correct. There's a ""discrete vorticity"". The analytically calculated vorticity is close to the discrete vorticity, but not exactly equal to it. For example, the perturbation vorticity in the current definition may not be initially zero, even if there were no noise. If the ""mean vorticity"" were calculated discretely, then the perturbation vorticity would be identically zero initially. A similar concept holds for geostrophic balance. There is a discrete geostrophic balance condition contains in a model that's stratified and rotating. This discrete condition is close to, but not exactly identical to the continuous geostrophic balance condition. This point has to do with approximation / discretization in general, through for some discretization (eg spectral decompositions), discrete representations may be closer to continuous analytical representations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882757399
https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882757399:1687,Deployability,continuous,continuous,1687,"> > > I am open to trying something different with how vorticity is computed. I computed it exactly and used those analytical expressions, but this is a pain when you want to consider a different jet, and you have to compute this again. If we can simply state the initial velocity and height, and then compute the voriticty, that migth be easier.; > > ; > > ; > > Right! In addition to being more flexible and illustrating the diagnostic procedure in general, a discrete calculation is more ""exact"" than an analytical expression.; > ; > I am puzzled by your statement here. A discrete, i.e. numerical calculation, is more exact than the analytical (so called exact) expression?; > ; > I guess it's more appropriate for the discretization that we are using, which is probably the point you are making. Okay, I see that and agree it's probably the better way to go. Correct. There's a ""discrete vorticity"". The analytically calculated vorticity is close to the discrete vorticity, but not exactly equal to it. For example, the perturbation vorticity in the current definition may not be initially zero, even if there were no noise. If the ""mean vorticity"" were calculated discretely, then the perturbation vorticity would be identically zero initially. A similar concept holds for geostrophic balance. There is a discrete geostrophic balance condition contains in a model that's stratified and rotating. This discrete condition is close to, but not exactly identical to the continuous geostrophic balance condition. This point has to do with approximation / discretization in general, through for some discretization (eg spectral decompositions), discrete representations may be closer to continuous analytical representations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882757399
https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882757399:397,Modifiability,flexible,flexible,397,"> > > I am open to trying something different with how vorticity is computed. I computed it exactly and used those analytical expressions, but this is a pain when you want to consider a different jet, and you have to compute this again. If we can simply state the initial velocity and height, and then compute the voriticty, that migth be easier.; > > ; > > ; > > Right! In addition to being more flexible and illustrating the diagnostic procedure in general, a discrete calculation is more ""exact"" than an analytical expression.; > ; > I am puzzled by your statement here. A discrete, i.e. numerical calculation, is more exact than the analytical (so called exact) expression?; > ; > I guess it's more appropriate for the discretization that we are using, which is probably the point you are making. Okay, I see that and agree it's probably the better way to go. Correct. There's a ""discrete vorticity"". The analytically calculated vorticity is close to the discrete vorticity, but not exactly equal to it. For example, the perturbation vorticity in the current definition may not be initially zero, even if there were no noise. If the ""mean vorticity"" were calculated discretely, then the perturbation vorticity would be identically zero initially. A similar concept holds for geostrophic balance. There is a discrete geostrophic balance condition contains in a model that's stratified and rotating. This discrete condition is close to, but not exactly identical to the continuous geostrophic balance condition. This point has to do with approximation / discretization in general, through for some discretization (eg spectral decompositions), discrete representations may be closer to continuous analytical representations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882757399
https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882757399:247,Usability,simpl,simply,247,"> > > I am open to trying something different with how vorticity is computed. I computed it exactly and used those analytical expressions, but this is a pain when you want to consider a different jet, and you have to compute this again. If we can simply state the initial velocity and height, and then compute the voriticty, that migth be easier.; > > ; > > ; > > Right! In addition to being more flexible and illustrating the diagnostic procedure in general, a discrete calculation is more ""exact"" than an analytical expression.; > ; > I am puzzled by your statement here. A discrete, i.e. numerical calculation, is more exact than the analytical (so called exact) expression?; > ; > I guess it's more appropriate for the discretization that we are using, which is probably the point you are making. Okay, I see that and agree it's probably the better way to go. Correct. There's a ""discrete vorticity"". The analytically calculated vorticity is close to the discrete vorticity, but not exactly equal to it. For example, the perturbation vorticity in the current definition may not be initially zero, even if there were no noise. If the ""mean vorticity"" were calculated discretely, then the perturbation vorticity would be identically zero initially. A similar concept holds for geostrophic balance. There is a discrete geostrophic balance condition contains in a model that's stratified and rotating. This discrete condition is close to, but not exactly identical to the continuous geostrophic balance condition. This point has to do with approximation / discretization in general, through for some discretization (eg spectral decompositions), discrete representations may be closer to continuous analytical representations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882757399
https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882771196:1009,Energy Efficiency,reduce,reduced,1009,"> I think that calculating the mean vorticity before we compute the noise would be great.; > ; > Your code looks very clean, but I'm not quite sure what it's doing different from what we had before?. Previously we had. ```julia; Statistics.norm(a::AbstractField) = sqrt(mapreduce(x -> x * x, +, interior(a))); ```. `interior(a)` returns a `view` over `parent(a)` that contains only the interior indices. Moreover `GPUArray` recognizes a `view` over a `CuArray` as on the GPU, and thus this function hooks into a special GPU-specific `mapreduce`. But this strategy fails for AbstractOperations, which have no `parent` array. To use GPU-specific code, we have to a) ensure that the output of `mapreduce` is initialized properly through `similar` or b) attempt to use `Base.mapreducedim!` instead. By using `mapreducedim!`, we can ensure GPU-specific code is called by initializing the output. It's a bit silly for the case of 0-dimensional output. Nevertheless, what I've done is initialized a 1-element array, reduced into it, and then output the result, indexing with `CUDA.@allowscalar`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882771196
https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882802165:170,Testability,test,tests,170,> I suppose we'll see it when the example is compiled into a preview. Sounds good and I looked through the code and everything looks good to me. . I will merge after the tests pass.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-882802165
https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-883037288:29,Deployability,update,updated,29,"I don't think those docs are updated for this PR yet, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-883037288
https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-883304986:92,Testability,test,tests,92,"I don't think the docs build --- the last commit I sent had architecture = GPU(), doh!. The tests hadn't finished running when the PR was merged:. ![image](https://user-images.githubusercontent.com/15271942/126313951-4e78d5b9-cce8-4a90-b784-692491d3d4e1.png). So we didn't catch it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-883304986
https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-883366377:10,Safety,detect,detective,10,"Some nice detective work @glwagner , and I agree that the initial profile looks much better and therefore justifies this improvement. As for the growth rate plot, in the movies, both cases have an intial perturbation O(1e-3) or so. I can believe this has a norm of O(1e-2). However, initially, the value is much smaller and I'm guessing it's zero. This is probably because we don't compute it at the first index. I will have to look at the plotting script and see why that is. . One easy fix is to start plotting at the second point. A more satisfying fix would be to actually compute the norm at the first index. I will try and figure this out later today, but now breakfast!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1874#issuecomment-883366377
https://github.com/CliMA/Oceananigans.jl/pull/1875#issuecomment-883025275:17,Testability,test,test,17,Any idea why the test isn't passing?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1875#issuecomment-883025275
https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883517465:319,Usability,clear,clear,319,"~One other option that might be easier to implement is to keep the store the tuple in `model.closures`, but only store the total viscosity (the sum of all closures in the tuple) in `model.diffusivities`. Maybe we'd have to rename it as `model.diffusivities._tot` and `model.diffusivities._tot` .~. ~I think that's as clear, but simpler.~. Scratch that! I was thinking of a specific example I had in mind and forgot that not every closure can be simplified to the sum of diffusivities times the nabla operator.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883517465
https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883517465:330,Usability,simpl,simpler,330,"~One other option that might be easier to implement is to keep the store the tuple in `model.closures`, but only store the total viscosity (the sum of all closures in the tuple) in `model.diffusivities`. Maybe we'd have to rename it as `model.diffusivities._tot` and `model.diffusivities._tot` .~. ~I think that's as clear, but simpler.~. Scratch that! I was thinking of a specific example I had in mind and forgot that not every closure can be simplified to the sum of diffusivities times the nabla operator.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883517465
https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883517465:447,Usability,simpl,simplified,447,"~One other option that might be easier to implement is to keep the store the tuple in `model.closures`, but only store the total viscosity (the sum of all closures in the tuple) in `model.diffusivities`. Maybe we'd have to rename it as `model.diffusivities._tot` and `model.diffusivities._tot` .~. ~I think that's as clear, but simpler.~. Scratch that! I was thinking of a specific example I had in mind and forgot that not every closure can be simplified to the sum of diffusivities times the nabla operator.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883517465
https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883658908:513,Availability,down,downside,513,"Yeah I think this change would help! It would definitely make things; clearer. Here's a couple alternative thoughts though:. Would it be possible to get rid of diffusivities altogether and store the; precomputed fields in the closures directly? E.g. AMD would have an extra; field data, so would smagorinsky and so on. I think it'd simplify things,; although I'm not sure how feasible that would be. I guess in order to; calculate those, the closure would need to already be associated with a; model, so that's a downside right away... Another thought: why not just also store the constant viscosities in the; diffusivities property? I know it's not necessary, but it wouldn't take up; any significant space and it would make things more intuitive/organized I; think. On Tue, Jul 20, 2021, 12:40 Gregory L. Wagner ***@***.***>; wrote:. > Ah I see the confusion. The field model.diffusivities stores viscosities; > and diffusivities that have to be precomputed. For diffusivities prescribed; > as constants or functions we don't need to store the diffusivities; instead; > the information needed to compute the diffusivity or viscosity is bound to; > model.closure.; >; > Perhaps we could call this model property ""diffusivity_fields""? This would; > distinguish the information there from constant or function diffusivities.; >; > ; > You are receiving this because you authored the thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883645905>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADEX5KSF44HXRQARFRTAQ6DTYXGJNANCNFSM5AV5LNJQ>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883658908
https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883658908:70,Usability,clear,clearer,70,"Yeah I think this change would help! It would definitely make things; clearer. Here's a couple alternative thoughts though:. Would it be possible to get rid of diffusivities altogether and store the; precomputed fields in the closures directly? E.g. AMD would have an extra; field data, so would smagorinsky and so on. I think it'd simplify things,; although I'm not sure how feasible that would be. I guess in order to; calculate those, the closure would need to already be associated with a; model, so that's a downside right away... Another thought: why not just also store the constant viscosities in the; diffusivities property? I know it's not necessary, but it wouldn't take up; any significant space and it would make things more intuitive/organized I; think. On Tue, Jul 20, 2021, 12:40 Gregory L. Wagner ***@***.***>; wrote:. > Ah I see the confusion. The field model.diffusivities stores viscosities; > and diffusivities that have to be precomputed. For diffusivities prescribed; > as constants or functions we don't need to store the diffusivities; instead; > the information needed to compute the diffusivity or viscosity is bound to; > model.closure.; >; > Perhaps we could call this model property ""diffusivity_fields""? This would; > distinguish the information there from constant or function diffusivities.; >; > ; > You are receiving this because you authored the thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883645905>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADEX5KSF44HXRQARFRTAQ6DTYXGJNANCNFSM5AV5LNJQ>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883658908
https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883658908:332,Usability,simpl,simplify,332,"Yeah I think this change would help! It would definitely make things; clearer. Here's a couple alternative thoughts though:. Would it be possible to get rid of diffusivities altogether and store the; precomputed fields in the closures directly? E.g. AMD would have an extra; field data, so would smagorinsky and so on. I think it'd simplify things,; although I'm not sure how feasible that would be. I guess in order to; calculate those, the closure would need to already be associated with a; model, so that's a downside right away... Another thought: why not just also store the constant viscosities in the; diffusivities property? I know it's not necessary, but it wouldn't take up; any significant space and it would make things more intuitive/organized I; think. On Tue, Jul 20, 2021, 12:40 Gregory L. Wagner ***@***.***>; wrote:. > Ah I see the confusion. The field model.diffusivities stores viscosities; > and diffusivities that have to be precomputed. For diffusivities prescribed; > as constants or functions we don't need to store the diffusivities; instead; > the information needed to compute the diffusivity or viscosity is bound to; > model.closure.; >; > Perhaps we could call this model property ""diffusivity_fields""? This would; > distinguish the information there from constant or function diffusivities.; >; > ; > You are receiving this because you authored the thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883645905>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADEX5KSF44HXRQARFRTAQ6DTYXGJNANCNFSM5AV5LNJQ>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883658908
https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883658908:738,Usability,intuit,intuitive,738,"Yeah I think this change would help! It would definitely make things; clearer. Here's a couple alternative thoughts though:. Would it be possible to get rid of diffusivities altogether and store the; precomputed fields in the closures directly? E.g. AMD would have an extra; field data, so would smagorinsky and so on. I think it'd simplify things,; although I'm not sure how feasible that would be. I guess in order to; calculate those, the closure would need to already be associated with a; model, so that's a downside right away... Another thought: why not just also store the constant viscosities in the; diffusivities property? I know it's not necessary, but it wouldn't take up; any significant space and it would make things more intuitive/organized I; think. On Tue, Jul 20, 2021, 12:40 Gregory L. Wagner ***@***.***>; wrote:. > Ah I see the confusion. The field model.diffusivities stores viscosities; > and diffusivities that have to be precomputed. For diffusivities prescribed; > as constants or functions we don't need to store the diffusivities; instead; > the information needed to compute the diffusivity or viscosity is bound to; > model.closure.; >; > Perhaps we could call this model property ""diffusivity_fields""? This would; > distinguish the information there from constant or function diffusivities.; >; > ; > You are receiving this because you authored the thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883645905>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADEX5KSF44HXRQARFRTAQ6DTYXGJNANCNFSM5AV5LNJQ>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883658908
https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883709160:868,Availability,mainten,maintenance,868,"Those are all possible developments. To put fields in `closure` we have to implement a pattern (implemented for things like boundary conditions, though it's taken a lot of work to get it right) whereby users instantiate a ""template"" `closure`, to which fields / data are added later given knowledge of the grid in the model constructor. Otherwise, users have to provide `grid` as an argument when constructing both a closure and a model. Either pattern is possible --- but implementing a ""template + materialization"" design is complicated, whereas requiring users to provide `grid` when constructing a closure changes the API. When a complicated algorithm endows the code with more features, I feel it could be justified if the feature is good enough. But if its only purpose is to rearrange where array references are bound, it feels less worth the trade off of code maintenance and the work to implement it. Another solution is documentation. Storing constant values in `diffusivities` is possible, but could be interpreted as boilerplate. The coefficients need to be stored in `closure`, because that's where users specify them. So copying the constants or functions into `diffusivities` (this would have to be done individually for all closures) requires additional code. I think of all the changes to `diffusivities`, the one that makes the most sense is to eliminate that field and change the API so that `grid` is a required argument for closures that have fields associated with them. This is a substantial internal refactor, but perhaps someone wants to take it up?. Note: I don't this will work for memory parallel models until #1825 is resolved.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883709160
https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883709160:1524,Modifiability,refactor,refactor,1524,"Those are all possible developments. To put fields in `closure` we have to implement a pattern (implemented for things like boundary conditions, though it's taken a lot of work to get it right) whereby users instantiate a ""template"" `closure`, to which fields / data are added later given knowledge of the grid in the model constructor. Otherwise, users have to provide `grid` as an argument when constructing both a closure and a model. Either pattern is possible --- but implementing a ""template + materialization"" design is complicated, whereas requiring users to provide `grid` when constructing a closure changes the API. When a complicated algorithm endows the code with more features, I feel it could be justified if the feature is good enough. But if its only purpose is to rearrange where array references are bound, it feels less worth the trade off of code maintenance and the work to implement it. Another solution is documentation. Storing constant values in `diffusivities` is possible, but could be interpreted as boilerplate. The coefficients need to be stored in `closure`, because that's where users specify them. So copying the constants or functions into `diffusivities` (this would have to be done individually for all closures) requires additional code. I think of all the changes to `diffusivities`, the one that makes the most sense is to eliminate that field and change the API so that `grid` is a required argument for closures that have fields associated with them. This is a substantial internal refactor, but perhaps someone wants to take it up?. Note: I don't this will work for memory parallel models until #1825 is resolved.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883709160
https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883732045:817,Modifiability,refactor,refactor,817,"> Storing constant values in diffusivities is possible, but could be interpreted as boilerplate. The coefficients need to be stored in closure, because that's where users specify them. So copying the constants or functions into diffusivities (this would have to be done individually for all closures) requires additional code. We don't have that many closures that would need this though, right? I think only `IsotropicConstant`, `AnisotropicConstant` and the biharmonic one that I see in the docs. (I think you have a TKE-based one that isn't listed in the docs also?). > I think of all the changes to diffusivities, the one that makes the most sense is to eliminate that field and change the API so that grid is a required argument for closures that have fields associated with them. This is a substantial internal refactor, but perhaps someone wants to take it up?. I like this option, but keeping the user from creating a closure without a grid seems a bit counter-productive... It's still not clear to me which one I'd vote for. For the time being, should we do something for the problem title refers to?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883732045
https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883732045:998,Usability,clear,clear,998,"> Storing constant values in diffusivities is possible, but could be interpreted as boilerplate. The coefficients need to be stored in closure, because that's where users specify them. So copying the constants or functions into diffusivities (this would have to be done individually for all closures) requires additional code. We don't have that many closures that would need this though, right? I think only `IsotropicConstant`, `AnisotropicConstant` and the biharmonic one that I see in the docs. (I think you have a TKE-based one that isn't listed in the docs also?). > I think of all the changes to diffusivities, the one that makes the most sense is to eliminate that field and change the API so that grid is a required argument for closures that have fields associated with them. This is a substantial internal refactor, but perhaps someone wants to take it up?. I like this option, but keeping the user from creating a closure without a grid seems a bit counter-productive... It's still not clear to me which one I'd vote for. For the time being, should we do something for the problem title refers to?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883732045
https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883733159:347,Modifiability,refactor,refactoring,347,"I think all the closures we have contain diffusivity data (constants or functions or fields) that are not in `diffusivities`. The list is here:. https://github.com/CliMA/Oceananigans.jl/tree/master/src/TurbulenceClosures/turbulence_closure_implementations. Only a subset of the code is documented, so better to look to the source when considering refactoring I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883733159
https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-884589510:164,Usability,simpl,simplest,164,"Just for the record, @glwagner and I decided to go with [this suggestion](https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883645905) which is the simplest for the time being. The naming is more intuitive and (with the new name) is makes sense that an empty element is created when a closure doesn't require an auxiliary field.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-884589510
https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-884589510:212,Usability,intuit,intuitive,212,"Just for the record, @glwagner and I decided to go with [this suggestion](https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883645905) which is the simplest for the time being. The naming is more intuitive and (with the new name) is makes sense that an empty element is created when a closure doesn't require an auxiliary field.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-884589510
https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883454939:16,Security,validat,validation,16,"There's no real validation of this feature, so it wasn't added to the docs. Perhaps you can come up with a nice validation experiment that we can use to gain confidence that it works correctly, and then add some documentation?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883454939
https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883454939:112,Security,validat,validation,112,"There's no real validation of this feature, so it wasn't added to the docs. Perhaps you can come up with a nice validation experiment that we can use to gain confidence that it works correctly, and then add some documentation?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883454939
https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883511439:474,Integrability,interface,interface,474,"Ah, I see. I thought it was validated. > Perhaps you can come up with a nice validation experiment that we can use to gain confidence that it works correctly, and then add some documentation?. It's hard for me to come up with a validation experiment for that I think. Are we testing that the viscosities are calculated and added correctly? (Thus a simple analytical example might suffice or an example where we just add two constant diffusities.) Or are we testing that the interface is working?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883511439
https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883511439:28,Security,validat,validated,28,"Ah, I see. I thought it was validated. > Perhaps you can come up with a nice validation experiment that we can use to gain confidence that it works correctly, and then add some documentation?. It's hard for me to come up with a validation experiment for that I think. Are we testing that the viscosities are calculated and added correctly? (Thus a simple analytical example might suffice or an example where we just add two constant diffusities.) Or are we testing that the interface is working?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883511439
https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883511439:77,Security,validat,validation,77,"Ah, I see. I thought it was validated. > Perhaps you can come up with a nice validation experiment that we can use to gain confidence that it works correctly, and then add some documentation?. It's hard for me to come up with a validation experiment for that I think. Are we testing that the viscosities are calculated and added correctly? (Thus a simple analytical example might suffice or an example where we just add two constant diffusities.) Or are we testing that the interface is working?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883511439
https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883511439:228,Security,validat,validation,228,"Ah, I see. I thought it was validated. > Perhaps you can come up with a nice validation experiment that we can use to gain confidence that it works correctly, and then add some documentation?. It's hard for me to come up with a validation experiment for that I think. Are we testing that the viscosities are calculated and added correctly? (Thus a simple analytical example might suffice or an example where we just add two constant diffusities.) Or are we testing that the interface is working?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883511439
https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883511439:275,Testability,test,testing,275,"Ah, I see. I thought it was validated. > Perhaps you can come up with a nice validation experiment that we can use to gain confidence that it works correctly, and then add some documentation?. It's hard for me to come up with a validation experiment for that I think. Are we testing that the viscosities are calculated and added correctly? (Thus a simple analytical example might suffice or an example where we just add two constant diffusities.) Or are we testing that the interface is working?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883511439
https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883511439:457,Testability,test,testing,457,"Ah, I see. I thought it was validated. > Perhaps you can come up with a nice validation experiment that we can use to gain confidence that it works correctly, and then add some documentation?. It's hard for me to come up with a validation experiment for that I think. Are we testing that the viscosities are calculated and added correctly? (Thus a simple analytical example might suffice or an example where we just add two constant diffusities.) Or are we testing that the interface is working?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883511439
https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883511439:348,Usability,simpl,simple,348,"Ah, I see. I thought it was validated. > Perhaps you can come up with a nice validation experiment that we can use to gain confidence that it works correctly, and then add some documentation?. It's hard for me to come up with a validation experiment for that I think. Are we testing that the viscosities are calculated and added correctly? (Thus a simple analytical example might suffice or an example where we just add two constant diffusities.) Or are we testing that the interface is working?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883511439
https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883637947:346,Security,validat,validation,346,"You could use two AnisotropicDiffusivity closures (or 3?) that individually set the diffusivities in each direction. Then you can test that a model which uses a single closure with all three diffusivities returns the same result as a model with a 3-tuple of different closures. That actually might be good enough for a bona fide test, not just a validation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883637947
https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883637947:130,Testability,test,test,130,"You could use two AnisotropicDiffusivity closures (or 3?) that individually set the diffusivities in each direction. Then you can test that a model which uses a single closure with all three diffusivities returns the same result as a model with a 3-tuple of different closures. That actually might be good enough for a bona fide test, not just a validation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883637947
https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883637947:329,Testability,test,test,329,"You could use two AnisotropicDiffusivity closures (or 3?) that individually set the diffusivities in each direction. Then you can test that a model which uses a single closure with all three diffusivities returns the same result as a model with a 3-tuple of different closures. That actually might be good enough for a bona fide test, not just a validation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883637947
https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883638590:152,Availability,error,error,152,"I'm thinking of an integration test that tests the whole pipeline: use of a 3-tuple when constructing a model, test that time-stepping works without an error, and test that the output is correct. It's probably easier to compare two models than to compare one model to an analytical solution. Comparison to an analytical solution is tricky, usually we have to invoke an arbitrary tolerance.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883638590
https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883638590:379,Availability,toler,tolerance,379,"I'm thinking of an integration test that tests the whole pipeline: use of a 3-tuple when constructing a model, test that time-stepping works without an error, and test that the output is correct. It's probably easier to compare two models than to compare one model to an analytical solution. Comparison to an analytical solution is tricky, usually we have to invoke an arbitrary tolerance.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883638590
https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883638590:19,Deployability,integrat,integration,19,"I'm thinking of an integration test that tests the whole pipeline: use of a 3-tuple when constructing a model, test that time-stepping works without an error, and test that the output is correct. It's probably easier to compare two models than to compare one model to an analytical solution. Comparison to an analytical solution is tricky, usually we have to invoke an arbitrary tolerance.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883638590
https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883638590:57,Deployability,pipeline,pipeline,57,"I'm thinking of an integration test that tests the whole pipeline: use of a 3-tuple when constructing a model, test that time-stepping works without an error, and test that the output is correct. It's probably easier to compare two models than to compare one model to an analytical solution. Comparison to an analytical solution is tricky, usually we have to invoke an arbitrary tolerance.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883638590
https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883638590:19,Integrability,integrat,integration,19,"I'm thinking of an integration test that tests the whole pipeline: use of a 3-tuple when constructing a model, test that time-stepping works without an error, and test that the output is correct. It's probably easier to compare two models than to compare one model to an analytical solution. Comparison to an analytical solution is tricky, usually we have to invoke an arbitrary tolerance.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883638590
https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883638590:31,Testability,test,test,31,"I'm thinking of an integration test that tests the whole pipeline: use of a 3-tuple when constructing a model, test that time-stepping works without an error, and test that the output is correct. It's probably easier to compare two models than to compare one model to an analytical solution. Comparison to an analytical solution is tricky, usually we have to invoke an arbitrary tolerance.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883638590
https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883638590:41,Testability,test,tests,41,"I'm thinking of an integration test that tests the whole pipeline: use of a 3-tuple when constructing a model, test that time-stepping works without an error, and test that the output is correct. It's probably easier to compare two models than to compare one model to an analytical solution. Comparison to an analytical solution is tricky, usually we have to invoke an arbitrary tolerance.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883638590
https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883638590:111,Testability,test,test,111,"I'm thinking of an integration test that tests the whole pipeline: use of a 3-tuple when constructing a model, test that time-stepping works without an error, and test that the output is correct. It's probably easier to compare two models than to compare one model to an analytical solution. Comparison to an analytical solution is tricky, usually we have to invoke an arbitrary tolerance.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883638590
https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883638590:163,Testability,test,test,163,"I'm thinking of an integration test that tests the whole pipeline: use of a 3-tuple when constructing a model, test that time-stepping works without an error, and test that the output is correct. It's probably easier to compare two models than to compare one model to an analytical solution. Comparison to an analytical solution is tricky, usually we have to invoke an arbitrary tolerance.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883638590
https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883734013:185,Availability,toler,tolerance,185,"> It's probably easier to compare two models than to compare one model to an analytical solution. Comparison to an analytical solution is tricky, usually we have to invoke an arbitrary tolerance. Good point. Adding 3 separate constant diffusivities is a good idea, but it wouldn't test any LES closures (where the fields have to actually be computed). Do you think that'd be necessary?. Another possibility is to compare a model with `closure=SmagorisnkyLilly(=1e-6, =1e-7)` against a model with `closure=(SmagorisnkyLilly(=0, =0), IsotropicDiffusivity(=1e-6, =1e-7)`. Those should be equivalent, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883734013
https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883734013:281,Testability,test,test,281,"> It's probably easier to compare two models than to compare one model to an analytical solution. Comparison to an analytical solution is tricky, usually we have to invoke an arbitrary tolerance. Good point. Adding 3 separate constant diffusivities is a good idea, but it wouldn't test any LES closures (where the fields have to actually be computed). Do you think that'd be necessary?. Another possibility is to compare a model with `closure=SmagorisnkyLilly(=1e-6, =1e-7)` against a model with `closure=(SmagorisnkyLilly(=0, =0), IsotropicDiffusivity(=1e-6, =1e-7)`. Those should be equivalent, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883734013
https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883756091:14,Testability,test,test,14,That's a good test too! Might be nice to do both tests in fact.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883756091
https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883756091:49,Testability,test,tests,49,That's a good test too! Might be nice to do both tests in fact.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883756091
https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883757223:31,Testability,test,tests,31,Any suggestion as to where the tests would go?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883757223
https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883847271:62,Testability,test,test,62,Probably https://github.com/CliMA/Oceananigans.jl/blob/master/test/test_turbulence_closures.jl,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-883847271
https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-884199479:37,Testability,test,test,37,"Also I think just doing the proposed test with a mix of LES closure and `IsotropicDiffusivity` is just fine. I think we can be reasonably confident the infrastructure works with that one test. I think we should also run the tests for different mixes of `time_discretization`. The infrastructure is supposed to work generally (so it should be valid to use `ExplicitTimeDiscretization` for both, `VerticallyImplicitTimeDiscretization` for both, or a mix). But we can collaborate on expanding the test to those cases once the basic comparison between the two simulations is in place.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-884199479
https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-884199479:187,Testability,test,test,187,"Also I think just doing the proposed test with a mix of LES closure and `IsotropicDiffusivity` is just fine. I think we can be reasonably confident the infrastructure works with that one test. I think we should also run the tests for different mixes of `time_discretization`. The infrastructure is supposed to work generally (so it should be valid to use `ExplicitTimeDiscretization` for both, `VerticallyImplicitTimeDiscretization` for both, or a mix). But we can collaborate on expanding the test to those cases once the basic comparison between the two simulations is in place.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-884199479
https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-884199479:224,Testability,test,tests,224,"Also I think just doing the proposed test with a mix of LES closure and `IsotropicDiffusivity` is just fine. I think we can be reasonably confident the infrastructure works with that one test. I think we should also run the tests for different mixes of `time_discretization`. The infrastructure is supposed to work generally (so it should be valid to use `ExplicitTimeDiscretization` for both, `VerticallyImplicitTimeDiscretization` for both, or a mix). But we can collaborate on expanding the test to those cases once the basic comparison between the two simulations is in place.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-884199479
https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-884199479:494,Testability,test,test,494,"Also I think just doing the proposed test with a mix of LES closure and `IsotropicDiffusivity` is just fine. I think we can be reasonably confident the infrastructure works with that one test. I think we should also run the tests for different mixes of `time_discretization`. The infrastructure is supposed to work generally (so it should be valid to use `ExplicitTimeDiscretization` for both, `VerticallyImplicitTimeDiscretization` for both, or a mix). But we can collaborate on expanding the test to those cases once the basic comparison between the two simulations is in place.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879#issuecomment-884199479
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-884202297:48,Testability,benchmark,benchmark,48,The results from running the new multithreading benchmark scripts are posted in #1861.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-884202297
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-884203129:75,Testability,test,test,75,> Looks good to me. This will be a good starting point for when we want to test the threading efficiency of the code.; > ; > Strange that docs don't build but can't believe it's because of these files. CI was offline yesterday and is just back this morning! Let's restart and see what happens.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-884203129
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-884210574:36,Testability,benchmark,benchmark,36,What are the current results of the benchmark?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-884210574
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-884220433:38,Testability,benchmark,benchmark,38,> What are the current results of the benchmark?. I think Henry has the results at the top of #1861. They can be copied here if you prefer.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-884220433
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-884362524:43,Availability,error,error,43,"> Hmm, docs still seem to fail. What's the error?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-884362524
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-884364299:19,Availability,ERROR,ERROR,19,"Copied below. ```; ERROR: LoadError: `makedocs` encountered an error. Terminating build; --;  | Stacktrace:;  | [1] error(s::String);  | @ Base ./error.jl:33;  | [2] runner(#unused#::Type{Documenter.Builder.RenderDocument}, doc::Documenter.Documents.Document);  | @ Documenter.Builder /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Builder.jl:255;  | [3] dispatch(#unused#::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Documents.Document);  | @ Documenter.Utilities.Selectors /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Utilities/Selectors.jl:170;  | [4] #2;  | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:257 [inlined];  | [5] cd(f::Documenter.var""#2#3""{Documenter.Documents.Document}, dir::String);  | @ Base.Filesystem ./file.jl:106;  | [6] #makedocs#1;  | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:256 [inlined];  | [7] top-level scope;  | @ ~/builds/tartarus-9/clima/oceananigans/docs/make.jl:155;  | in expression starting at /var/lib/buildkite-agent/builds/tartarus-9/clima/oceananigans/docs/make.jl:155;  |  Error: The command exited with status 1;  | user command error: exit status 1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-884364299
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-884364299:63,Availability,error,error,63,"Copied below. ```; ERROR: LoadError: `makedocs` encountered an error. Terminating build; --;  | Stacktrace:;  | [1] error(s::String);  | @ Base ./error.jl:33;  | [2] runner(#unused#::Type{Documenter.Builder.RenderDocument}, doc::Documenter.Documents.Document);  | @ Documenter.Builder /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Builder.jl:255;  | [3] dispatch(#unused#::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Documents.Document);  | @ Documenter.Utilities.Selectors /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Utilities/Selectors.jl:170;  | [4] #2;  | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:257 [inlined];  | [5] cd(f::Documenter.var""#2#3""{Documenter.Documents.Document}, dir::String);  | @ Base.Filesystem ./file.jl:106;  | [6] #makedocs#1;  | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:256 [inlined];  | [7] top-level scope;  | @ ~/builds/tartarus-9/clima/oceananigans/docs/make.jl:155;  | in expression starting at /var/lib/buildkite-agent/builds/tartarus-9/clima/oceananigans/docs/make.jl:155;  |  Error: The command exited with status 1;  | user command error: exit status 1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-884364299
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-884364299:118,Availability,error,error,118,"Copied below. ```; ERROR: LoadError: `makedocs` encountered an error. Terminating build; --;  | Stacktrace:;  | [1] error(s::String);  | @ Base ./error.jl:33;  | [2] runner(#unused#::Type{Documenter.Builder.RenderDocument}, doc::Documenter.Documents.Document);  | @ Documenter.Builder /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Builder.jl:255;  | [3] dispatch(#unused#::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Documents.Document);  | @ Documenter.Utilities.Selectors /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Utilities/Selectors.jl:170;  | [4] #2;  | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:257 [inlined];  | [5] cd(f::Documenter.var""#2#3""{Documenter.Documents.Document}, dir::String);  | @ Base.Filesystem ./file.jl:106;  | [6] #makedocs#1;  | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:256 [inlined];  | [7] top-level scope;  | @ ~/builds/tartarus-9/clima/oceananigans/docs/make.jl:155;  | in expression starting at /var/lib/buildkite-agent/builds/tartarus-9/clima/oceananigans/docs/make.jl:155;  |  Error: The command exited with status 1;  | user command error: exit status 1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-884364299
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-884364299:149,Availability,error,error,149,"Copied below. ```; ERROR: LoadError: `makedocs` encountered an error. Terminating build; --;  | Stacktrace:;  | [1] error(s::String);  | @ Base ./error.jl:33;  | [2] runner(#unused#::Type{Documenter.Builder.RenderDocument}, doc::Documenter.Documents.Document);  | @ Documenter.Builder /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Builder.jl:255;  | [3] dispatch(#unused#::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Documents.Document);  | @ Documenter.Utilities.Selectors /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Utilities/Selectors.jl:170;  | [4] #2;  | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:257 [inlined];  | [5] cd(f::Documenter.var""#2#3""{Documenter.Documents.Document}, dir::String);  | @ Base.Filesystem ./file.jl:106;  | [6] #makedocs#1;  | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:256 [inlined];  | [7] top-level scope;  | @ ~/builds/tartarus-9/clima/oceananigans/docs/make.jl:155;  | in expression starting at /var/lib/buildkite-agent/builds/tartarus-9/clima/oceananigans/docs/make.jl:155;  |  Error: The command exited with status 1;  | user command error: exit status 1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-884364299
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-884364299:1173,Availability,Error,Error,1173,"Copied below. ```; ERROR: LoadError: `makedocs` encountered an error. Terminating build; --;  | Stacktrace:;  | [1] error(s::String);  | @ Base ./error.jl:33;  | [2] runner(#unused#::Type{Documenter.Builder.RenderDocument}, doc::Documenter.Documents.Document);  | @ Documenter.Builder /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Builder.jl:255;  | [3] dispatch(#unused#::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Documents.Document);  | @ Documenter.Utilities.Selectors /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Utilities/Selectors.jl:170;  | [4] #2;  | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:257 [inlined];  | [5] cd(f::Documenter.var""#2#3""{Documenter.Documents.Document}, dir::String);  | @ Base.Filesystem ./file.jl:106;  | [6] #makedocs#1;  | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:256 [inlined];  | [7] top-level scope;  | @ ~/builds/tartarus-9/clima/oceananigans/docs/make.jl:155;  | in expression starting at /var/lib/buildkite-agent/builds/tartarus-9/clima/oceananigans/docs/make.jl:155;  |  Error: The command exited with status 1;  | user command error: exit status 1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-884364299
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-884364299:1231,Availability,error,error,1231,"Copied below. ```; ERROR: LoadError: `makedocs` encountered an error. Terminating build; --;  | Stacktrace:;  | [1] error(s::String);  | @ Base ./error.jl:33;  | [2] runner(#unused#::Type{Documenter.Builder.RenderDocument}, doc::Documenter.Documents.Document);  | @ Documenter.Builder /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Builder.jl:255;  | [3] dispatch(#unused#::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Documents.Document);  | @ Documenter.Utilities.Selectors /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Utilities/Selectors.jl:170;  | [4] #2;  | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:257 [inlined];  | [5] cd(f::Documenter.var""#2#3""{Documenter.Documents.Document}, dir::String);  | @ Base.Filesystem ./file.jl:106;  | [6] #makedocs#1;  | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:256 [inlined];  | [7] top-level scope;  | @ ~/builds/tartarus-9/clima/oceananigans/docs/make.jl:155;  | in expression starting at /var/lib/buildkite-agent/builds/tartarus-9/clima/oceananigans/docs/make.jl:155;  |  Error: The command exited with status 1;  | user command error: exit status 1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-884364299
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-884364299:26,Performance,Load,LoadError,26,"Copied below. ```; ERROR: LoadError: `makedocs` encountered an error. Terminating build; --;  | Stacktrace:;  | [1] error(s::String);  | @ Base ./error.jl:33;  | [2] runner(#unused#::Type{Documenter.Builder.RenderDocument}, doc::Documenter.Documents.Document);  | @ Documenter.Builder /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Builder.jl:255;  | [3] dispatch(#unused#::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Documents.Document);  | @ Documenter.Utilities.Selectors /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Utilities/Selectors.jl:170;  | [4] #2;  | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:257 [inlined];  | [5] cd(f::Documenter.var""#2#3""{Documenter.Documents.Document}, dir::String);  | @ Base.Filesystem ./file.jl:106;  | [6] #makedocs#1;  | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:256 [inlined];  | [7] top-level scope;  | @ ~/builds/tartarus-9/clima/oceananigans/docs/make.jl:155;  | in expression starting at /var/lib/buildkite-agent/builds/tartarus-9/clima/oceananigans/docs/make.jl:155;  |  Error: The command exited with status 1;  | user command error: exit status 1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-884364299
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887149801:12,Availability,down,down,12,"After going down the rabbit hole of `Documenter.jl` all I can say is that the error message we're seeing means nothing.; All it means that in the makedocs process, there was an error. It is not the makedocs that's throwing the error, but actually something much earlier that pushed an error into the docs.internal.errors field of the document object. Here's where it happens as according to the error log we can see:; https://github.com/JuliaDocs/Documenter.jl/blob/master/src/Builder.jl#L255; As seen in https://github.com/CliMA/Oceananigans.jl/blob/master/docs/make.jl#L162, the makedocs strict option is set to true which follows that:; **`strict`** -- [`makedocs`](@ref) fails the build right before rendering if it encountered; any errors with the document in the previous build phases.; Interestingly enough, the error we see can be summarized as ""error: there's an error"", but does not give any more info on what exactly the error was.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887149801
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887149801:78,Availability,error,error,78,"After going down the rabbit hole of `Documenter.jl` all I can say is that the error message we're seeing means nothing.; All it means that in the makedocs process, there was an error. It is not the makedocs that's throwing the error, but actually something much earlier that pushed an error into the docs.internal.errors field of the document object. Here's where it happens as according to the error log we can see:; https://github.com/JuliaDocs/Documenter.jl/blob/master/src/Builder.jl#L255; As seen in https://github.com/CliMA/Oceananigans.jl/blob/master/docs/make.jl#L162, the makedocs strict option is set to true which follows that:; **`strict`** -- [`makedocs`](@ref) fails the build right before rendering if it encountered; any errors with the document in the previous build phases.; Interestingly enough, the error we see can be summarized as ""error: there's an error"", but does not give any more info on what exactly the error was.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887149801
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887149801:177,Availability,error,error,177,"After going down the rabbit hole of `Documenter.jl` all I can say is that the error message we're seeing means nothing.; All it means that in the makedocs process, there was an error. It is not the makedocs that's throwing the error, but actually something much earlier that pushed an error into the docs.internal.errors field of the document object. Here's where it happens as according to the error log we can see:; https://github.com/JuliaDocs/Documenter.jl/blob/master/src/Builder.jl#L255; As seen in https://github.com/CliMA/Oceananigans.jl/blob/master/docs/make.jl#L162, the makedocs strict option is set to true which follows that:; **`strict`** -- [`makedocs`](@ref) fails the build right before rendering if it encountered; any errors with the document in the previous build phases.; Interestingly enough, the error we see can be summarized as ""error: there's an error"", but does not give any more info on what exactly the error was.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887149801
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887149801:227,Availability,error,error,227,"After going down the rabbit hole of `Documenter.jl` all I can say is that the error message we're seeing means nothing.; All it means that in the makedocs process, there was an error. It is not the makedocs that's throwing the error, but actually something much earlier that pushed an error into the docs.internal.errors field of the document object. Here's where it happens as according to the error log we can see:; https://github.com/JuliaDocs/Documenter.jl/blob/master/src/Builder.jl#L255; As seen in https://github.com/CliMA/Oceananigans.jl/blob/master/docs/make.jl#L162, the makedocs strict option is set to true which follows that:; **`strict`** -- [`makedocs`](@ref) fails the build right before rendering if it encountered; any errors with the document in the previous build phases.; Interestingly enough, the error we see can be summarized as ""error: there's an error"", but does not give any more info on what exactly the error was.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887149801
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887149801:285,Availability,error,error,285,"After going down the rabbit hole of `Documenter.jl` all I can say is that the error message we're seeing means nothing.; All it means that in the makedocs process, there was an error. It is not the makedocs that's throwing the error, but actually something much earlier that pushed an error into the docs.internal.errors field of the document object. Here's where it happens as according to the error log we can see:; https://github.com/JuliaDocs/Documenter.jl/blob/master/src/Builder.jl#L255; As seen in https://github.com/CliMA/Oceananigans.jl/blob/master/docs/make.jl#L162, the makedocs strict option is set to true which follows that:; **`strict`** -- [`makedocs`](@ref) fails the build right before rendering if it encountered; any errors with the document in the previous build phases.; Interestingly enough, the error we see can be summarized as ""error: there's an error"", but does not give any more info on what exactly the error was.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887149801
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887149801:314,Availability,error,errors,314,"After going down the rabbit hole of `Documenter.jl` all I can say is that the error message we're seeing means nothing.; All it means that in the makedocs process, there was an error. It is not the makedocs that's throwing the error, but actually something much earlier that pushed an error into the docs.internal.errors field of the document object. Here's where it happens as according to the error log we can see:; https://github.com/JuliaDocs/Documenter.jl/blob/master/src/Builder.jl#L255; As seen in https://github.com/CliMA/Oceananigans.jl/blob/master/docs/make.jl#L162, the makedocs strict option is set to true which follows that:; **`strict`** -- [`makedocs`](@ref) fails the build right before rendering if it encountered; any errors with the document in the previous build phases.; Interestingly enough, the error we see can be summarized as ""error: there's an error"", but does not give any more info on what exactly the error was.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887149801
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887149801:395,Availability,error,error,395,"After going down the rabbit hole of `Documenter.jl` all I can say is that the error message we're seeing means nothing.; All it means that in the makedocs process, there was an error. It is not the makedocs that's throwing the error, but actually something much earlier that pushed an error into the docs.internal.errors field of the document object. Here's where it happens as according to the error log we can see:; https://github.com/JuliaDocs/Documenter.jl/blob/master/src/Builder.jl#L255; As seen in https://github.com/CliMA/Oceananigans.jl/blob/master/docs/make.jl#L162, the makedocs strict option is set to true which follows that:; **`strict`** -- [`makedocs`](@ref) fails the build right before rendering if it encountered; any errors with the document in the previous build phases.; Interestingly enough, the error we see can be summarized as ""error: there's an error"", but does not give any more info on what exactly the error was.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887149801
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887149801:737,Availability,error,errors,737,"After going down the rabbit hole of `Documenter.jl` all I can say is that the error message we're seeing means nothing.; All it means that in the makedocs process, there was an error. It is not the makedocs that's throwing the error, but actually something much earlier that pushed an error into the docs.internal.errors field of the document object. Here's where it happens as according to the error log we can see:; https://github.com/JuliaDocs/Documenter.jl/blob/master/src/Builder.jl#L255; As seen in https://github.com/CliMA/Oceananigans.jl/blob/master/docs/make.jl#L162, the makedocs strict option is set to true which follows that:; **`strict`** -- [`makedocs`](@ref) fails the build right before rendering if it encountered; any errors with the document in the previous build phases.; Interestingly enough, the error we see can be summarized as ""error: there's an error"", but does not give any more info on what exactly the error was.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887149801
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887149801:819,Availability,error,error,819,"After going down the rabbit hole of `Documenter.jl` all I can say is that the error message we're seeing means nothing.; All it means that in the makedocs process, there was an error. It is not the makedocs that's throwing the error, but actually something much earlier that pushed an error into the docs.internal.errors field of the document object. Here's where it happens as according to the error log we can see:; https://github.com/JuliaDocs/Documenter.jl/blob/master/src/Builder.jl#L255; As seen in https://github.com/CliMA/Oceananigans.jl/blob/master/docs/make.jl#L162, the makedocs strict option is set to true which follows that:; **`strict`** -- [`makedocs`](@ref) fails the build right before rendering if it encountered; any errors with the document in the previous build phases.; Interestingly enough, the error we see can be summarized as ""error: there's an error"", but does not give any more info on what exactly the error was.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887149801
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887149801:854,Availability,error,error,854,"After going down the rabbit hole of `Documenter.jl` all I can say is that the error message we're seeing means nothing.; All it means that in the makedocs process, there was an error. It is not the makedocs that's throwing the error, but actually something much earlier that pushed an error into the docs.internal.errors field of the document object. Here's where it happens as according to the error log we can see:; https://github.com/JuliaDocs/Documenter.jl/blob/master/src/Builder.jl#L255; As seen in https://github.com/CliMA/Oceananigans.jl/blob/master/docs/make.jl#L162, the makedocs strict option is set to true which follows that:; **`strict`** -- [`makedocs`](@ref) fails the build right before rendering if it encountered; any errors with the document in the previous build phases.; Interestingly enough, the error we see can be summarized as ""error: there's an error"", but does not give any more info on what exactly the error was.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887149801
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887149801:872,Availability,error,error,872,"After going down the rabbit hole of `Documenter.jl` all I can say is that the error message we're seeing means nothing.; All it means that in the makedocs process, there was an error. It is not the makedocs that's throwing the error, but actually something much earlier that pushed an error into the docs.internal.errors field of the document object. Here's where it happens as according to the error log we can see:; https://github.com/JuliaDocs/Documenter.jl/blob/master/src/Builder.jl#L255; As seen in https://github.com/CliMA/Oceananigans.jl/blob/master/docs/make.jl#L162, the makedocs strict option is set to true which follows that:; **`strict`** -- [`makedocs`](@ref) fails the build right before rendering if it encountered; any errors with the document in the previous build phases.; Interestingly enough, the error we see can be summarized as ""error: there's an error"", but does not give any more info on what exactly the error was.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887149801
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887149801:932,Availability,error,error,932,"After going down the rabbit hole of `Documenter.jl` all I can say is that the error message we're seeing means nothing.; All it means that in the makedocs process, there was an error. It is not the makedocs that's throwing the error, but actually something much earlier that pushed an error into the docs.internal.errors field of the document object. Here's where it happens as according to the error log we can see:; https://github.com/JuliaDocs/Documenter.jl/blob/master/src/Builder.jl#L255; As seen in https://github.com/CliMA/Oceananigans.jl/blob/master/docs/make.jl#L162, the makedocs strict option is set to true which follows that:; **`strict`** -- [`makedocs`](@ref) fails the build right before rendering if it encountered; any errors with the document in the previous build phases.; Interestingly enough, the error we see can be summarized as ""error: there's an error"", but does not give any more info on what exactly the error was.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887149801
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887149801:84,Integrability,message,message,84,"After going down the rabbit hole of `Documenter.jl` all I can say is that the error message we're seeing means nothing.; All it means that in the makedocs process, there was an error. It is not the makedocs that's throwing the error, but actually something much earlier that pushed an error into the docs.internal.errors field of the document object. Here's where it happens as according to the error log we can see:; https://github.com/JuliaDocs/Documenter.jl/blob/master/src/Builder.jl#L255; As seen in https://github.com/CliMA/Oceananigans.jl/blob/master/docs/make.jl#L162, the makedocs strict option is set to true which follows that:; **`strict`** -- [`makedocs`](@ref) fails the build right before rendering if it encountered; any errors with the document in the previous build phases.; Interestingly enough, the error we see can be summarized as ""error: there's an error"", but does not give any more info on what exactly the error was.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887149801
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887149801:401,Testability,log,log,401,"After going down the rabbit hole of `Documenter.jl` all I can say is that the error message we're seeing means nothing.; All it means that in the makedocs process, there was an error. It is not the makedocs that's throwing the error, but actually something much earlier that pushed an error into the docs.internal.errors field of the document object. Here's where it happens as according to the error log we can see:; https://github.com/JuliaDocs/Documenter.jl/blob/master/src/Builder.jl#L255; As seen in https://github.com/CliMA/Oceananigans.jl/blob/master/docs/make.jl#L162, the makedocs strict option is set to true which follows that:; **`strict`** -- [`makedocs`](@ref) fails the build right before rendering if it encountered; any errors with the document in the previous build phases.; Interestingly enough, the error we see can be summarized as ""error: there's an error"", but does not give any more info on what exactly the error was.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887149801
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887450206:5,Availability,error,error,5,This error is also happening in #1892 so presumably not because of the changes made to the code.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887450206
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887500390:30,Availability,ERROR,ERROR,30,"> Copied below.; > ; > ```; > ERROR: LoadError: `makedocs` encountered an error. Terminating build; > --; >  | Stacktrace:; >  | [1] error(s::String); >  | @ Base ./error.jl:33; >  | [2] runner(#unused#::Type{Documenter.Builder.RenderDocument}, doc::Documenter.Documents.Document); >  | @ Documenter.Builder /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Builder.jl:255; >  | [3] dispatch(#unused#::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Documents.Document); >  | @ Documenter.Utilities.Selectors /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Utilities/Selectors.jl:170; >  | [4] #2; >  | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:257 [inlined]; >  | [5] cd(f::Documenter.var""#2#3""{Documenter.Documents.Document}, dir::String); >  | @ Base.Filesystem ./file.jl:106; >  | [6] #makedocs#1; >  | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:256 [inlined]; >  | [7] top-level scope; >  | @ ~/builds/tartarus-9/clima/oceananigans/docs/make.jl:155; >  | in expression starting at /var/lib/buildkite-agent/builds/tartarus-9/clima/oceananigans/docs/make.jl:155; >  |  Error: The command exited with status 1; >  | user command error: exit status 1; > ```. This is only the top of the error. Farther down, we see. ```;  Warning: failed to run `@example` block in src/generated/shallow_water_Bickley_jet.md:70-77; --;  |  ```@example shallow_water_Bickley_jet;  |  model = ShallowWaterModel(architecture = GPU(),;  |  timestepper = :RungeKutta3,;  |  advection = WENO5(),;  |  grid = grid,;  |  gravitational_acceleration = g,;  |  coriolis = FPlane(f=f));  |  ```;  |  c.value = CUDA error (code 100, CUDA_ERROR_NO_DEVICE);  |  @ Documenter.Expanders /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Expanders.jl:563; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887500390
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887500390:74,Availability,error,error,74,"> Copied below.; > ; > ```; > ERROR: LoadError: `makedocs` encountered an error. Terminating build; > --; >  | Stacktrace:; >  | [1] error(s::String); >  | @ Base ./error.jl:33; >  | [2] runner(#unused#::Type{Documenter.Builder.RenderDocument}, doc::Documenter.Documents.Document); >  | @ Documenter.Builder /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Builder.jl:255; >  | [3] dispatch(#unused#::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Documents.Document); >  | @ Documenter.Utilities.Selectors /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Utilities/Selectors.jl:170; >  | [4] #2; >  | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:257 [inlined]; >  | [5] cd(f::Documenter.var""#2#3""{Documenter.Documents.Document}, dir::String); >  | @ Base.Filesystem ./file.jl:106; >  | [6] #makedocs#1; >  | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:256 [inlined]; >  | [7] top-level scope; >  | @ ~/builds/tartarus-9/clima/oceananigans/docs/make.jl:155; >  | in expression starting at /var/lib/buildkite-agent/builds/tartarus-9/clima/oceananigans/docs/make.jl:155; >  |  Error: The command exited with status 1; >  | user command error: exit status 1; > ```. This is only the top of the error. Farther down, we see. ```;  Warning: failed to run `@example` block in src/generated/shallow_water_Bickley_jet.md:70-77; --;  |  ```@example shallow_water_Bickley_jet;  |  model = ShallowWaterModel(architecture = GPU(),;  |  timestepper = :RungeKutta3,;  |  advection = WENO5(),;  |  grid = grid,;  |  gravitational_acceleration = g,;  |  coriolis = FPlane(f=f));  |  ```;  |  c.value = CUDA error (code 100, CUDA_ERROR_NO_DEVICE);  |  @ Documenter.Expanders /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Expanders.jl:563; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887500390
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887500390:135,Availability,error,error,135,"> Copied below.; > ; > ```; > ERROR: LoadError: `makedocs` encountered an error. Terminating build; > --; >  | Stacktrace:; >  | [1] error(s::String); >  | @ Base ./error.jl:33; >  | [2] runner(#unused#::Type{Documenter.Builder.RenderDocument}, doc::Documenter.Documents.Document); >  | @ Documenter.Builder /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Builder.jl:255; >  | [3] dispatch(#unused#::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Documents.Document); >  | @ Documenter.Utilities.Selectors /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Utilities/Selectors.jl:170; >  | [4] #2; >  | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:257 [inlined]; >  | [5] cd(f::Documenter.var""#2#3""{Documenter.Documents.Document}, dir::String); >  | @ Base.Filesystem ./file.jl:106; >  | [6] #makedocs#1; >  | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:256 [inlined]; >  | [7] top-level scope; >  | @ ~/builds/tartarus-9/clima/oceananigans/docs/make.jl:155; >  | in expression starting at /var/lib/buildkite-agent/builds/tartarus-9/clima/oceananigans/docs/make.jl:155; >  |  Error: The command exited with status 1; >  | user command error: exit status 1; > ```. This is only the top of the error. Farther down, we see. ```;  Warning: failed to run `@example` block in src/generated/shallow_water_Bickley_jet.md:70-77; --;  |  ```@example shallow_water_Bickley_jet;  |  model = ShallowWaterModel(architecture = GPU(),;  |  timestepper = :RungeKutta3,;  |  advection = WENO5(),;  |  grid = grid,;  |  gravitational_acceleration = g,;  |  coriolis = FPlane(f=f));  |  ```;  |  c.value = CUDA error (code 100, CUDA_ERROR_NO_DEVICE);  |  @ Documenter.Expanders /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Expanders.jl:563; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887500390
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887500390:168,Availability,error,error,168,"> Copied below.; > ; > ```; > ERROR: LoadError: `makedocs` encountered an error. Terminating build; > --; >  | Stacktrace:; >  | [1] error(s::String); >  | @ Base ./error.jl:33; >  | [2] runner(#unused#::Type{Documenter.Builder.RenderDocument}, doc::Documenter.Documents.Document); >  | @ Documenter.Builder /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Builder.jl:255; >  | [3] dispatch(#unused#::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Documents.Document); >  | @ Documenter.Utilities.Selectors /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Utilities/Selectors.jl:170; >  | [4] #2; >  | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:257 [inlined]; >  | [5] cd(f::Documenter.var""#2#3""{Documenter.Documents.Document}, dir::String); >  | @ Base.Filesystem ./file.jl:106; >  | [6] #makedocs#1; >  | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:256 [inlined]; >  | [7] top-level scope; >  | @ ~/builds/tartarus-9/clima/oceananigans/docs/make.jl:155; >  | in expression starting at /var/lib/buildkite-agent/builds/tartarus-9/clima/oceananigans/docs/make.jl:155; >  |  Error: The command exited with status 1; >  | user command error: exit status 1; > ```. This is only the top of the error. Farther down, we see. ```;  Warning: failed to run `@example` block in src/generated/shallow_water_Bickley_jet.md:70-77; --;  |  ```@example shallow_water_Bickley_jet;  |  model = ShallowWaterModel(architecture = GPU(),;  |  timestepper = :RungeKutta3,;  |  advection = WENO5(),;  |  grid = grid,;  |  gravitational_acceleration = g,;  |  coriolis = FPlane(f=f));  |  ```;  |  c.value = CUDA error (code 100, CUDA_ERROR_NO_DEVICE);  |  @ Documenter.Expanders /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Expanders.jl:563; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887500390
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887500390:1220,Availability,Error,Error,1220,"> Copied below.; > ; > ```; > ERROR: LoadError: `makedocs` encountered an error. Terminating build; > --; >  | Stacktrace:; >  | [1] error(s::String); >  | @ Base ./error.jl:33; >  | [2] runner(#unused#::Type{Documenter.Builder.RenderDocument}, doc::Documenter.Documents.Document); >  | @ Documenter.Builder /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Builder.jl:255; >  | [3] dispatch(#unused#::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Documents.Document); >  | @ Documenter.Utilities.Selectors /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Utilities/Selectors.jl:170; >  | [4] #2; >  | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:257 [inlined]; >  | [5] cd(f::Documenter.var""#2#3""{Documenter.Documents.Document}, dir::String); >  | @ Base.Filesystem ./file.jl:106; >  | [6] #makedocs#1; >  | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:256 [inlined]; >  | [7] top-level scope; >  | @ ~/builds/tartarus-9/clima/oceananigans/docs/make.jl:155; >  | in expression starting at /var/lib/buildkite-agent/builds/tartarus-9/clima/oceananigans/docs/make.jl:155; >  |  Error: The command exited with status 1; >  | user command error: exit status 1; > ```. This is only the top of the error. Farther down, we see. ```;  Warning: failed to run `@example` block in src/generated/shallow_water_Bickley_jet.md:70-77; --;  |  ```@example shallow_water_Bickley_jet;  |  model = ShallowWaterModel(architecture = GPU(),;  |  timestepper = :RungeKutta3,;  |  advection = WENO5(),;  |  grid = grid,;  |  gravitational_acceleration = g,;  |  coriolis = FPlane(f=f));  |  ```;  |  c.value = CUDA error (code 100, CUDA_ERROR_NO_DEVICE);  |  @ Documenter.Expanders /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Expanders.jl:563; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887500390
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887500390:1280,Availability,error,error,1280,"> Copied below.; > ; > ```; > ERROR: LoadError: `makedocs` encountered an error. Terminating build; > --; >  | Stacktrace:; >  | [1] error(s::String); >  | @ Base ./error.jl:33; >  | [2] runner(#unused#::Type{Documenter.Builder.RenderDocument}, doc::Documenter.Documents.Document); >  | @ Documenter.Builder /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Builder.jl:255; >  | [3] dispatch(#unused#::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Documents.Document); >  | @ Documenter.Utilities.Selectors /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Utilities/Selectors.jl:170; >  | [4] #2; >  | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:257 [inlined]; >  | [5] cd(f::Documenter.var""#2#3""{Documenter.Documents.Document}, dir::String); >  | @ Base.Filesystem ./file.jl:106; >  | [6] #makedocs#1; >  | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:256 [inlined]; >  | [7] top-level scope; >  | @ ~/builds/tartarus-9/clima/oceananigans/docs/make.jl:155; >  | in expression starting at /var/lib/buildkite-agent/builds/tartarus-9/clima/oceananigans/docs/make.jl:155; >  |  Error: The command exited with status 1; >  | user command error: exit status 1; > ```. This is only the top of the error. Farther down, we see. ```;  Warning: failed to run `@example` block in src/generated/shallow_water_Bickley_jet.md:70-77; --;  |  ```@example shallow_water_Bickley_jet;  |  model = ShallowWaterModel(architecture = GPU(),;  |  timestepper = :RungeKutta3,;  |  advection = WENO5(),;  |  grid = grid,;  |  gravitational_acceleration = g,;  |  coriolis = FPlane(f=f));  |  ```;  |  c.value = CUDA error (code 100, CUDA_ERROR_NO_DEVICE);  |  @ Documenter.Expanders /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Expanders.jl:563; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887500390
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887500390:1337,Availability,error,error,1337,"> Copied below.; > ; > ```; > ERROR: LoadError: `makedocs` encountered an error. Terminating build; > --; >  | Stacktrace:; >  | [1] error(s::String); >  | @ Base ./error.jl:33; >  | [2] runner(#unused#::Type{Documenter.Builder.RenderDocument}, doc::Documenter.Documents.Document); >  | @ Documenter.Builder /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Builder.jl:255; >  | [3] dispatch(#unused#::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Documents.Document); >  | @ Documenter.Utilities.Selectors /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Utilities/Selectors.jl:170; >  | [4] #2; >  | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:257 [inlined]; >  | [5] cd(f::Documenter.var""#2#3""{Documenter.Documents.Document}, dir::String); >  | @ Base.Filesystem ./file.jl:106; >  | [6] #makedocs#1; >  | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:256 [inlined]; >  | [7] top-level scope; >  | @ ~/builds/tartarus-9/clima/oceananigans/docs/make.jl:155; >  | in expression starting at /var/lib/buildkite-agent/builds/tartarus-9/clima/oceananigans/docs/make.jl:155; >  |  Error: The command exited with status 1; >  | user command error: exit status 1; > ```. This is only the top of the error. Farther down, we see. ```;  Warning: failed to run `@example` block in src/generated/shallow_water_Bickley_jet.md:70-77; --;  |  ```@example shallow_water_Bickley_jet;  |  model = ShallowWaterModel(architecture = GPU(),;  |  timestepper = :RungeKutta3,;  |  advection = WENO5(),;  |  grid = grid,;  |  gravitational_acceleration = g,;  |  coriolis = FPlane(f=f));  |  ```;  |  c.value = CUDA error (code 100, CUDA_ERROR_NO_DEVICE);  |  @ Documenter.Expanders /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Expanders.jl:563; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887500390
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887500390:1352,Availability,down,down,1352,"> Copied below.; > ; > ```; > ERROR: LoadError: `makedocs` encountered an error. Terminating build; > --; >  | Stacktrace:; >  | [1] error(s::String); >  | @ Base ./error.jl:33; >  | [2] runner(#unused#::Type{Documenter.Builder.RenderDocument}, doc::Documenter.Documents.Document); >  | @ Documenter.Builder /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Builder.jl:255; >  | [3] dispatch(#unused#::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Documents.Document); >  | @ Documenter.Utilities.Selectors /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Utilities/Selectors.jl:170; >  | [4] #2; >  | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:257 [inlined]; >  | [5] cd(f::Documenter.var""#2#3""{Documenter.Documents.Document}, dir::String); >  | @ Base.Filesystem ./file.jl:106; >  | [6] #makedocs#1; >  | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:256 [inlined]; >  | [7] top-level scope; >  | @ ~/builds/tartarus-9/clima/oceananigans/docs/make.jl:155; >  | in expression starting at /var/lib/buildkite-agent/builds/tartarus-9/clima/oceananigans/docs/make.jl:155; >  |  Error: The command exited with status 1; >  | user command error: exit status 1; > ```. This is only the top of the error. Farther down, we see. ```;  Warning: failed to run `@example` block in src/generated/shallow_water_Bickley_jet.md:70-77; --;  |  ```@example shallow_water_Bickley_jet;  |  model = ShallowWaterModel(architecture = GPU(),;  |  timestepper = :RungeKutta3,;  |  advection = WENO5(),;  |  grid = grid,;  |  gravitational_acceleration = g,;  |  coriolis = FPlane(f=f));  |  ```;  |  c.value = CUDA error (code 100, CUDA_ERROR_NO_DEVICE);  |  @ Documenter.Expanders /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Expanders.jl:563; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887500390
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887500390:1755,Availability,error,error,1755,"> Copied below.; > ; > ```; > ERROR: LoadError: `makedocs` encountered an error. Terminating build; > --; >  | Stacktrace:; >  | [1] error(s::String); >  | @ Base ./error.jl:33; >  | [2] runner(#unused#::Type{Documenter.Builder.RenderDocument}, doc::Documenter.Documents.Document); >  | @ Documenter.Builder /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Builder.jl:255; >  | [3] dispatch(#unused#::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Documents.Document); >  | @ Documenter.Utilities.Selectors /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Utilities/Selectors.jl:170; >  | [4] #2; >  | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:257 [inlined]; >  | [5] cd(f::Documenter.var""#2#3""{Documenter.Documents.Document}, dir::String); >  | @ Base.Filesystem ./file.jl:106; >  | [6] #makedocs#1; >  | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:256 [inlined]; >  | [7] top-level scope; >  | @ ~/builds/tartarus-9/clima/oceananigans/docs/make.jl:155; >  | in expression starting at /var/lib/buildkite-agent/builds/tartarus-9/clima/oceananigans/docs/make.jl:155; >  |  Error: The command exited with status 1; >  | user command error: exit status 1; > ```. This is only the top of the error. Farther down, we see. ```;  Warning: failed to run `@example` block in src/generated/shallow_water_Bickley_jet.md:70-77; --;  |  ```@example shallow_water_Bickley_jet;  |  model = ShallowWaterModel(architecture = GPU(),;  |  timestepper = :RungeKutta3,;  |  advection = WENO5(),;  |  grid = grid,;  |  gravitational_acceleration = g,;  |  coriolis = FPlane(f=f));  |  ```;  |  c.value = CUDA error (code 100, CUDA_ERROR_NO_DEVICE);  |  @ Documenter.Expanders /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Expanders.jl:563; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887500390
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887500390:37,Performance,Load,LoadError,37,"> Copied below.; > ; > ```; > ERROR: LoadError: `makedocs` encountered an error. Terminating build; > --; >  | Stacktrace:; >  | [1] error(s::String); >  | @ Base ./error.jl:33; >  | [2] runner(#unused#::Type{Documenter.Builder.RenderDocument}, doc::Documenter.Documents.Document); >  | @ Documenter.Builder /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Builder.jl:255; >  | [3] dispatch(#unused#::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Documents.Document); >  | @ Documenter.Utilities.Selectors /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Utilities/Selectors.jl:170; >  | [4] #2; >  | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:257 [inlined]; >  | [5] cd(f::Documenter.var""#2#3""{Documenter.Documents.Document}, dir::String); >  | @ Base.Filesystem ./file.jl:106; >  | [6] #makedocs#1; >  | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:256 [inlined]; >  | [7] top-level scope; >  | @ ~/builds/tartarus-9/clima/oceananigans/docs/make.jl:155; >  | in expression starting at /var/lib/buildkite-agent/builds/tartarus-9/clima/oceananigans/docs/make.jl:155; >  |  Error: The command exited with status 1; >  | user command error: exit status 1; > ```. This is only the top of the error. Farther down, we see. ```;  Warning: failed to run `@example` block in src/generated/shallow_water_Bickley_jet.md:70-77; --;  |  ```@example shallow_water_Bickley_jet;  |  model = ShallowWaterModel(architecture = GPU(),;  |  timestepper = :RungeKutta3,;  |  advection = WENO5(),;  |  grid = grid,;  |  gravitational_acceleration = g,;  |  coriolis = FPlane(f=f));  |  ```;  |  c.value = CUDA error (code 100, CUDA_ERROR_NO_DEVICE);  |  @ Documenter.Expanders /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Expanders.jl:563; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887500390
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-899928441:571,Deployability,toggle,toggle,571,"@francispoulin @glwagner @ali-ramadhan @christophernhill ; I took a look at all the benchmarking scripts in our benchmarks folder and realized that many of them are very similar and can be unified. For example, the single script for shallow water model's strong and weak scaling differ only by one substring. ; The latest commit I pushed to this branch unifies all of the launcher and single scripts for shallow water model into three scripts. Now, at the top of the launcher script `distributed_shallow_water_model.jl`, there are two boolean variables that the user can toggle for strong vs weak scaling and mpi vs threaded parallel execution. Everything including output graphs, HTML tables, and info messages also change accordingly based on the two booleans. There are some other features that Francis and I have discussed but would like your approval first before adding them in.; Other possible additions to the script can include a for loop which wraps around the whole launcher script which loops through the strong/weak scaling and mpi/threaded parallelism options to allow for running 4 benchmarks at once. Another possible addition is to have what model is benchmarked also be an option. Granted, I could just copy and paste the shallow water model scripts and replace all instances of `shallow water` with `nonhydrostatic` or `hydrostatic` and tune some options a little bit, but then this would again cause avoidable clutter. Having what model is benchmarked as an easily changeable option can be achieved through a model setup function that dispatches what model is initialized based on a custom model type object that's passed to it. Everything else would be cosmetic formatting of outputs and info messages.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-899928441
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-899928441:703,Integrability,message,messages,703,"@francispoulin @glwagner @ali-ramadhan @christophernhill ; I took a look at all the benchmarking scripts in our benchmarks folder and realized that many of them are very similar and can be unified. For example, the single script for shallow water model's strong and weak scaling differ only by one substring. ; The latest commit I pushed to this branch unifies all of the launcher and single scripts for shallow water model into three scripts. Now, at the top of the launcher script `distributed_shallow_water_model.jl`, there are two boolean variables that the user can toggle for strong vs weak scaling and mpi vs threaded parallel execution. Everything including output graphs, HTML tables, and info messages also change accordingly based on the two booleans. There are some other features that Francis and I have discussed but would like your approval first before adding them in.; Other possible additions to the script can include a for loop which wraps around the whole launcher script which loops through the strong/weak scaling and mpi/threaded parallelism options to allow for running 4 benchmarks at once. Another possible addition is to have what model is benchmarked also be an option. Granted, I could just copy and paste the shallow water model scripts and replace all instances of `shallow water` with `nonhydrostatic` or `hydrostatic` and tune some options a little bit, but then this would again cause avoidable clutter. Having what model is benchmarked as an easily changeable option can be achieved through a model setup function that dispatches what model is initialized based on a custom model type object that's passed to it. Everything else would be cosmetic formatting of outputs and info messages.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-899928441
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-899928441:954,Integrability,wrap,wraps,954,"@francispoulin @glwagner @ali-ramadhan @christophernhill ; I took a look at all the benchmarking scripts in our benchmarks folder and realized that many of them are very similar and can be unified. For example, the single script for shallow water model's strong and weak scaling differ only by one substring. ; The latest commit I pushed to this branch unifies all of the launcher and single scripts for shallow water model into three scripts. Now, at the top of the launcher script `distributed_shallow_water_model.jl`, there are two boolean variables that the user can toggle for strong vs weak scaling and mpi vs threaded parallel execution. Everything including output graphs, HTML tables, and info messages also change accordingly based on the two booleans. There are some other features that Francis and I have discussed but would like your approval first before adding them in.; Other possible additions to the script can include a for loop which wraps around the whole launcher script which loops through the strong/weak scaling and mpi/threaded parallelism options to allow for running 4 benchmarks at once. Another possible addition is to have what model is benchmarked also be an option. Granted, I could just copy and paste the shallow water model scripts and replace all instances of `shallow water` with `nonhydrostatic` or `hydrostatic` and tune some options a little bit, but then this would again cause avoidable clutter. Having what model is benchmarked as an easily changeable option can be achieved through a model setup function that dispatches what model is initialized based on a custom model type object that's passed to it. Everything else would be cosmetic formatting of outputs and info messages.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-899928441
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-899928441:1714,Integrability,message,messages,1714,"@francispoulin @glwagner @ali-ramadhan @christophernhill ; I took a look at all the benchmarking scripts in our benchmarks folder and realized that many of them are very similar and can be unified. For example, the single script for shallow water model's strong and weak scaling differ only by one substring. ; The latest commit I pushed to this branch unifies all of the launcher and single scripts for shallow water model into three scripts. Now, at the top of the launcher script `distributed_shallow_water_model.jl`, there are two boolean variables that the user can toggle for strong vs weak scaling and mpi vs threaded parallel execution. Everything including output graphs, HTML tables, and info messages also change accordingly based on the two booleans. There are some other features that Francis and I have discussed but would like your approval first before adding them in.; Other possible additions to the script can include a for loop which wraps around the whole launcher script which loops through the strong/weak scaling and mpi/threaded parallelism options to allow for running 4 benchmarks at once. Another possible addition is to have what model is benchmarked also be an option. Granted, I could just copy and paste the shallow water model scripts and replace all instances of `shallow water` with `nonhydrostatic` or `hydrostatic` and tune some options a little bit, but then this would again cause avoidable clutter. Having what model is benchmarked as an easily changeable option can be achieved through a model setup function that dispatches what model is initialized based on a custom model type object that's passed to it. Everything else would be cosmetic formatting of outputs and info messages.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-899928441
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-899928441:543,Modifiability,variab,variables,543,"@francispoulin @glwagner @ali-ramadhan @christophernhill ; I took a look at all the benchmarking scripts in our benchmarks folder and realized that many of them are very similar and can be unified. For example, the single script for shallow water model's strong and weak scaling differ only by one substring. ; The latest commit I pushed to this branch unifies all of the launcher and single scripts for shallow water model into three scripts. Now, at the top of the launcher script `distributed_shallow_water_model.jl`, there are two boolean variables that the user can toggle for strong vs weak scaling and mpi vs threaded parallel execution. Everything including output graphs, HTML tables, and info messages also change accordingly based on the two booleans. There are some other features that Francis and I have discussed but would like your approval first before adding them in.; Other possible additions to the script can include a for loop which wraps around the whole launcher script which loops through the strong/weak scaling and mpi/threaded parallelism options to allow for running 4 benchmarks at once. Another possible addition is to have what model is benchmarked also be an option. Granted, I could just copy and paste the shallow water model scripts and replace all instances of `shallow water` with `nonhydrostatic` or `hydrostatic` and tune some options a little bit, but then this would again cause avoidable clutter. Having what model is benchmarked as an easily changeable option can be achieved through a model setup function that dispatches what model is initialized based on a custom model type object that's passed to it. Everything else would be cosmetic formatting of outputs and info messages.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-899928441
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-899928441:1356,Performance,tune,tune,1356,"@francispoulin @glwagner @ali-ramadhan @christophernhill ; I took a look at all the benchmarking scripts in our benchmarks folder and realized that many of them are very similar and can be unified. For example, the single script for shallow water model's strong and weak scaling differ only by one substring. ; The latest commit I pushed to this branch unifies all of the launcher and single scripts for shallow water model into three scripts. Now, at the top of the launcher script `distributed_shallow_water_model.jl`, there are two boolean variables that the user can toggle for strong vs weak scaling and mpi vs threaded parallel execution. Everything including output graphs, HTML tables, and info messages also change accordingly based on the two booleans. There are some other features that Francis and I have discussed but would like your approval first before adding them in.; Other possible additions to the script can include a for loop which wraps around the whole launcher script which loops through the strong/weak scaling and mpi/threaded parallelism options to allow for running 4 benchmarks at once. Another possible addition is to have what model is benchmarked also be an option. Granted, I could just copy and paste the shallow water model scripts and replace all instances of `shallow water` with `nonhydrostatic` or `hydrostatic` and tune some options a little bit, but then this would again cause avoidable clutter. Having what model is benchmarked as an easily changeable option can be achieved through a model setup function that dispatches what model is initialized based on a custom model type object that's passed to it. Everything else would be cosmetic formatting of outputs and info messages.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-899928441
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-899928441:1420,Safety,avoid,avoidable,1420,"@francispoulin @glwagner @ali-ramadhan @christophernhill ; I took a look at all the benchmarking scripts in our benchmarks folder and realized that many of them are very similar and can be unified. For example, the single script for shallow water model's strong and weak scaling differ only by one substring. ; The latest commit I pushed to this branch unifies all of the launcher and single scripts for shallow water model into three scripts. Now, at the top of the launcher script `distributed_shallow_water_model.jl`, there are two boolean variables that the user can toggle for strong vs weak scaling and mpi vs threaded parallel execution. Everything including output graphs, HTML tables, and info messages also change accordingly based on the two booleans. There are some other features that Francis and I have discussed but would like your approval first before adding them in.; Other possible additions to the script can include a for loop which wraps around the whole launcher script which loops through the strong/weak scaling and mpi/threaded parallelism options to allow for running 4 benchmarks at once. Another possible addition is to have what model is benchmarked also be an option. Granted, I could just copy and paste the shallow water model scripts and replace all instances of `shallow water` with `nonhydrostatic` or `hydrostatic` and tune some options a little bit, but then this would again cause avoidable clutter. Having what model is benchmarked as an easily changeable option can be achieved through a model setup function that dispatches what model is initialized based on a custom model type object that's passed to it. Everything else would be cosmetic formatting of outputs and info messages.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-899928441
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-899928441:84,Testability,benchmark,benchmarking,84,"@francispoulin @glwagner @ali-ramadhan @christophernhill ; I took a look at all the benchmarking scripts in our benchmarks folder and realized that many of them are very similar and can be unified. For example, the single script for shallow water model's strong and weak scaling differ only by one substring. ; The latest commit I pushed to this branch unifies all of the launcher and single scripts for shallow water model into three scripts. Now, at the top of the launcher script `distributed_shallow_water_model.jl`, there are two boolean variables that the user can toggle for strong vs weak scaling and mpi vs threaded parallel execution. Everything including output graphs, HTML tables, and info messages also change accordingly based on the two booleans. There are some other features that Francis and I have discussed but would like your approval first before adding them in.; Other possible additions to the script can include a for loop which wraps around the whole launcher script which loops through the strong/weak scaling and mpi/threaded parallelism options to allow for running 4 benchmarks at once. Another possible addition is to have what model is benchmarked also be an option. Granted, I could just copy and paste the shallow water model scripts and replace all instances of `shallow water` with `nonhydrostatic` or `hydrostatic` and tune some options a little bit, but then this would again cause avoidable clutter. Having what model is benchmarked as an easily changeable option can be achieved through a model setup function that dispatches what model is initialized based on a custom model type object that's passed to it. Everything else would be cosmetic formatting of outputs and info messages.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-899928441
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-899928441:112,Testability,benchmark,benchmarks,112,"@francispoulin @glwagner @ali-ramadhan @christophernhill ; I took a look at all the benchmarking scripts in our benchmarks folder and realized that many of them are very similar and can be unified. For example, the single script for shallow water model's strong and weak scaling differ only by one substring. ; The latest commit I pushed to this branch unifies all of the launcher and single scripts for shallow water model into three scripts. Now, at the top of the launcher script `distributed_shallow_water_model.jl`, there are two boolean variables that the user can toggle for strong vs weak scaling and mpi vs threaded parallel execution. Everything including output graphs, HTML tables, and info messages also change accordingly based on the two booleans. There are some other features that Francis and I have discussed but would like your approval first before adding them in.; Other possible additions to the script can include a for loop which wraps around the whole launcher script which loops through the strong/weak scaling and mpi/threaded parallelism options to allow for running 4 benchmarks at once. Another possible addition is to have what model is benchmarked also be an option. Granted, I could just copy and paste the shallow water model scripts and replace all instances of `shallow water` with `nonhydrostatic` or `hydrostatic` and tune some options a little bit, but then this would again cause avoidable clutter. Having what model is benchmarked as an easily changeable option can be achieved through a model setup function that dispatches what model is initialized based on a custom model type object that's passed to it. Everything else would be cosmetic formatting of outputs and info messages.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-899928441
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-899928441:1097,Testability,benchmark,benchmarks,1097,"@francispoulin @glwagner @ali-ramadhan @christophernhill ; I took a look at all the benchmarking scripts in our benchmarks folder and realized that many of them are very similar and can be unified. For example, the single script for shallow water model's strong and weak scaling differ only by one substring. ; The latest commit I pushed to this branch unifies all of the launcher and single scripts for shallow water model into three scripts. Now, at the top of the launcher script `distributed_shallow_water_model.jl`, there are two boolean variables that the user can toggle for strong vs weak scaling and mpi vs threaded parallel execution. Everything including output graphs, HTML tables, and info messages also change accordingly based on the two booleans. There are some other features that Francis and I have discussed but would like your approval first before adding them in.; Other possible additions to the script can include a for loop which wraps around the whole launcher script which loops through the strong/weak scaling and mpi/threaded parallelism options to allow for running 4 benchmarks at once. Another possible addition is to have what model is benchmarked also be an option. Granted, I could just copy and paste the shallow water model scripts and replace all instances of `shallow water` with `nonhydrostatic` or `hydrostatic` and tune some options a little bit, but then this would again cause avoidable clutter. Having what model is benchmarked as an easily changeable option can be achieved through a model setup function that dispatches what model is initialized based on a custom model type object that's passed to it. Everything else would be cosmetic formatting of outputs and info messages.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-899928441
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-899928441:1168,Testability,benchmark,benchmarked,1168,"@francispoulin @glwagner @ali-ramadhan @christophernhill ; I took a look at all the benchmarking scripts in our benchmarks folder and realized that many of them are very similar and can be unified. For example, the single script for shallow water model's strong and weak scaling differ only by one substring. ; The latest commit I pushed to this branch unifies all of the launcher and single scripts for shallow water model into three scripts. Now, at the top of the launcher script `distributed_shallow_water_model.jl`, there are two boolean variables that the user can toggle for strong vs weak scaling and mpi vs threaded parallel execution. Everything including output graphs, HTML tables, and info messages also change accordingly based on the two booleans. There are some other features that Francis and I have discussed but would like your approval first before adding them in.; Other possible additions to the script can include a for loop which wraps around the whole launcher script which loops through the strong/weak scaling and mpi/threaded parallelism options to allow for running 4 benchmarks at once. Another possible addition is to have what model is benchmarked also be an option. Granted, I could just copy and paste the shallow water model scripts and replace all instances of `shallow water` with `nonhydrostatic` or `hydrostatic` and tune some options a little bit, but then this would again cause avoidable clutter. Having what model is benchmarked as an easily changeable option can be achieved through a model setup function that dispatches what model is initialized based on a custom model type object that's passed to it. Everything else would be cosmetic formatting of outputs and info messages.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-899928441
https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-899928441:1460,Testability,benchmark,benchmarked,1460,"@francispoulin @glwagner @ali-ramadhan @christophernhill ; I took a look at all the benchmarking scripts in our benchmarks folder and realized that many of them are very similar and can be unified. For example, the single script for shallow water model's strong and weak scaling differ only by one substring. ; The latest commit I pushed to this branch unifies all of the launcher and single scripts for shallow water model into three scripts. Now, at the top of the launcher script `distributed_shallow_water_model.jl`, there are two boolean variables that the user can toggle for strong vs weak scaling and mpi vs threaded parallel execution. Everything including output graphs, HTML tables, and info messages also change accordingly based on the two booleans. There are some other features that Francis and I have discussed but would like your approval first before adding them in.; Other possible additions to the script can include a for loop which wraps around the whole launcher script which loops through the strong/weak scaling and mpi/threaded parallelism options to allow for running 4 benchmarks at once. Another possible addition is to have what model is benchmarked also be an option. Granted, I could just copy and paste the shallow water model scripts and replace all instances of `shallow water` with `nonhydrostatic` or `hydrostatic` and tune some options a little bit, but then this would again cause avoidable clutter. Having what model is benchmarked as an easily changeable option can be achieved through a model setup function that dispatches what model is initialized based on a custom model type object that's passed to it. Everything else would be cosmetic formatting of outputs and info messages.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-899928441
https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-884370736:34,Availability,down,down,34,"The fact that the efficiency goes down to 40% for 2 gpus says that it's actually running slower than on one core. Certainly suboptimal. I'm sure we can do better, and we will.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-884370736
https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885260173:259,Usability,learn,learn,259,"I have tried running the library `ImplicitGlobalGrid.jl`in 1, 2 and 4 gpus and have actually found rather bad scaling as well, 57 and 35 percent. I have created an issue and hope they might have some suggestions as to how to improve the results. Maybe what I learn there might be transferable to Oceananigans?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885260173
https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885287770:268,Usability,learn,learn,268,"> I have tried running the library `ImplicitGlobalGrid.jl`in 1, 2 and 4 gpus and have actually found rather bad scaling as well, 57 and 35 percent.; > ; > I have created an issue and hope they might have some suggestions as to how to improve the results. Maybe what I learn there might be transferable to Oceananigans?. This then sounds to me like you don't have a working CUDA-aware MPI. IGG should show >90% efficiency",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885287770
https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885291310:260,Testability,test,tests,260,"As I said, please post your slurp script and other environment options. It is impossible to debug otherwise. I have an annotated slurp script here https://github.com/CliMA/ClimateMachine.jl/wiki/Satori-Cluster which is what I used a while back for GPU scaling tests. A mossconfigured MPI can easily manifest itself as scaling this poor.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885291310
https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885334231:560,Availability,down,downloaded,560,"@hennyg888 thanks posting this. a few thoughts - . I assume what @hennyg888 is running is based on this https://github.com/christophernhill/onan-jcon2021-bits/blob/main/run/satori/run-on-bench-on-rhel7-satori-with-mpi ? . There are quite a few things to double (triple) check. 1. **are you running on multiple GPUs?** ; There is some obscure foo for that here ( https://github.com/christophernhill/ImplicitGlobalGrid.jl/blob/5e4fd0698b7087467d9314bfa253d6bc9a09a40a/diffusion3D_multigpu_CuArrays_novis.jl#L21 ) that is not in Oceananigans or ImplicitGlobal as downloaded. Its not really particularly documented anywhere either (except in a blog post for this https://github.com/NVIDIA-developer-blog/code-samples/blob/master/posts/cuda-aware-mpi-example/src/CUDA_Aware_MPI.c as far as I can tell)! Without this bit you may end up running all ranks on the same GPU. The blog post here https://developer.nvidia.com/blog/benchmarking-cuda-aware-mpi/ gives a bit of background. . 2. **is there anything else running on the node when you test?** ; When I looked earlier in the week satori had become annoyingly busy. You need to request an exclusive node - and then wait unfortunately because of every else using. If you skip asking for exclusive you may end up sharing node - which is OK for getting work done, but confusing for benchmarking. . 3. **as @vchuravy mentions you may or may not be using messaging that goes direct GPU to GPU?** ; There is an issue with recent CUDA.jl that makes that hard (possibly not even possible). We are working to resolve that. @vchuravy has a suggested fix, but I found that caused other problems. The ImplicitGlobal team found @vchuravy fix to work, but with a very recent version of CUDA.jl where I think it isn't supposed to work - so they may have been mistaken. I was planning to look at this a bit more after having coffee with a Nvidia colleague who is involved in all this tomorrow. . The ImplciitGlobalGris stuff should get reasonable behavior with the `selec",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885334231
https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885334231:918,Testability,benchmark,benchmarking-cuda-aware-mpi,918,"@hennyg888 thanks posting this. a few thoughts - . I assume what @hennyg888 is running is based on this https://github.com/christophernhill/onan-jcon2021-bits/blob/main/run/satori/run-on-bench-on-rhel7-satori-with-mpi ? . There are quite a few things to double (triple) check. 1. **are you running on multiple GPUs?** ; There is some obscure foo for that here ( https://github.com/christophernhill/ImplicitGlobalGrid.jl/blob/5e4fd0698b7087467d9314bfa253d6bc9a09a40a/diffusion3D_multigpu_CuArrays_novis.jl#L21 ) that is not in Oceananigans or ImplicitGlobal as downloaded. Its not really particularly documented anywhere either (except in a blog post for this https://github.com/NVIDIA-developer-blog/code-samples/blob/master/posts/cuda-aware-mpi-example/src/CUDA_Aware_MPI.c as far as I can tell)! Without this bit you may end up running all ranks on the same GPU. The blog post here https://developer.nvidia.com/blog/benchmarking-cuda-aware-mpi/ gives a bit of background. . 2. **is there anything else running on the node when you test?** ; When I looked earlier in the week satori had become annoyingly busy. You need to request an exclusive node - and then wait unfortunately because of every else using. If you skip asking for exclusive you may end up sharing node - which is OK for getting work done, but confusing for benchmarking. . 3. **as @vchuravy mentions you may or may not be using messaging that goes direct GPU to GPU?** ; There is an issue with recent CUDA.jl that makes that hard (possibly not even possible). We are working to resolve that. @vchuravy has a suggested fix, but I found that caused other problems. The ImplicitGlobal team found @vchuravy fix to work, but with a very recent version of CUDA.jl where I think it isn't supposed to work - so they may have been mistaken. I was planning to look at this a bit more after having coffee with a Nvidia colleague who is involved in all this tomorrow. . The ImplciitGlobalGris stuff should get reasonable behavior with the `selec",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885334231
https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885334231:1033,Testability,test,test,1033,"ts - . I assume what @hennyg888 is running is based on this https://github.com/christophernhill/onan-jcon2021-bits/blob/main/run/satori/run-on-bench-on-rhel7-satori-with-mpi ? . There are quite a few things to double (triple) check. 1. **are you running on multiple GPUs?** ; There is some obscure foo for that here ( https://github.com/christophernhill/ImplicitGlobalGrid.jl/blob/5e4fd0698b7087467d9314bfa253d6bc9a09a40a/diffusion3D_multigpu_CuArrays_novis.jl#L21 ) that is not in Oceananigans or ImplicitGlobal as downloaded. Its not really particularly documented anywhere either (except in a blog post for this https://github.com/NVIDIA-developer-blog/code-samples/blob/master/posts/cuda-aware-mpi-example/src/CUDA_Aware_MPI.c as far as I can tell)! Without this bit you may end up running all ranks on the same GPU. The blog post here https://developer.nvidia.com/blog/benchmarking-cuda-aware-mpi/ gives a bit of background. . 2. **is there anything else running on the node when you test?** ; When I looked earlier in the week satori had become annoyingly busy. You need to request an exclusive node - and then wait unfortunately because of every else using. If you skip asking for exclusive you may end up sharing node - which is OK for getting work done, but confusing for benchmarking. . 3. **as @vchuravy mentions you may or may not be using messaging that goes direct GPU to GPU?** ; There is an issue with recent CUDA.jl that makes that hard (possibly not even possible). We are working to resolve that. @vchuravy has a suggested fix, but I found that caused other problems. The ImplicitGlobal team found @vchuravy fix to work, but with a very recent version of CUDA.jl where I think it isn't supposed to work - so they may have been mistaken. I was planning to look at this a bit more after having coffee with a Nvidia colleague who is involved in all this tomorrow. . The ImplciitGlobalGris stuff should get reasonable behavior with the `selectDevices()` addition - but I think Oceananig",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885334231
https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885334231:1325,Testability,benchmark,benchmarking,1325,"ck. 1. **are you running on multiple GPUs?** ; There is some obscure foo for that here ( https://github.com/christophernhill/ImplicitGlobalGrid.jl/blob/5e4fd0698b7087467d9314bfa253d6bc9a09a40a/diffusion3D_multigpu_CuArrays_novis.jl#L21 ) that is not in Oceananigans or ImplicitGlobal as downloaded. Its not really particularly documented anywhere either (except in a blog post for this https://github.com/NVIDIA-developer-blog/code-samples/blob/master/posts/cuda-aware-mpi-example/src/CUDA_Aware_MPI.c as far as I can tell)! Without this bit you may end up running all ranks on the same GPU. The blog post here https://developer.nvidia.com/blog/benchmarking-cuda-aware-mpi/ gives a bit of background. . 2. **is there anything else running on the node when you test?** ; When I looked earlier in the week satori had become annoyingly busy. You need to request an exclusive node - and then wait unfortunately because of every else using. If you skip asking for exclusive you may end up sharing node - which is OK for getting work done, but confusing for benchmarking. . 3. **as @vchuravy mentions you may or may not be using messaging that goes direct GPU to GPU?** ; There is an issue with recent CUDA.jl that makes that hard (possibly not even possible). We are working to resolve that. @vchuravy has a suggested fix, but I found that caused other problems. The ImplicitGlobal team found @vchuravy fix to work, but with a very recent version of CUDA.jl where I think it isn't supposed to work - so they may have been mistaken. I was planning to look at this a bit more after having coffee with a Nvidia colleague who is involved in all this tomorrow. . The ImplciitGlobalGris stuff should get reasonable behavior with the `selectDevices()` addition - but I think Oceananigans.jl may have some other problem too, related to passing @view indexing of arrays directly into the MPI calls. So good results for Oceananigans may require some other work too - which @glwagner is looking at. . Lots of details",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885334231
https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885336918:391,Availability,down,downloaded,391,"> I have tried running the library `ImplicitGlobalGrid.jl`in 1, 2 and 4 gpus and have actually found rather bad scaling as well, 57 and 35 percent.; > ; > I have created an issue and hope they might have some suggestions as to how to improve the results. Maybe what I learn there might be transferable to Oceananigans?. @francispoulin (see my above comment). I think ImplictGlobalGrid.jl as downloaded is not configured to run across multiple GPUs. I added a line in a fork here ( https://github.com/christophernhill/ImplicitGlobalGrid.jl/blob/5e4fd0698b7087467d9314bfa253d6bc9a09a40a/diffusion3D_multigpu_CuArrays_novis.jl#L21 ) that is needed. With that I saw reasonable weak scaling - even with broken CUDA aware MPI support. Oceananigans.jl has some other things going on. I agree profiling with nvprof/nsight would be great. This link https://github.com/mit-satori/getting-started/blob/master/tutorial-examples/nvprof-profiling/Satori_NVProf_Intro.pdf and this https://mit-satori.github.io/tutorial-examples/nvprof-profiling/index.html?highlight=profiling might be helpful to get started. The slides also have links to various NVidia bits of documentation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885336918
https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885336918:409,Modifiability,config,configured,409,"> I have tried running the library `ImplicitGlobalGrid.jl`in 1, 2 and 4 gpus and have actually found rather bad scaling as well, 57 and 35 percent.; > ; > I have created an issue and hope they might have some suggestions as to how to improve the results. Maybe what I learn there might be transferable to Oceananigans?. @francispoulin (see my above comment). I think ImplictGlobalGrid.jl as downloaded is not configured to run across multiple GPUs. I added a line in a fork here ( https://github.com/christophernhill/ImplicitGlobalGrid.jl/blob/5e4fd0698b7087467d9314bfa253d6bc9a09a40a/diffusion3D_multigpu_CuArrays_novis.jl#L21 ) that is needed. With that I saw reasonable weak scaling - even with broken CUDA aware MPI support. Oceananigans.jl has some other things going on. I agree profiling with nvprof/nsight would be great. This link https://github.com/mit-satori/getting-started/blob/master/tutorial-examples/nvprof-profiling/Satori_NVProf_Intro.pdf and this https://mit-satori.github.io/tutorial-examples/nvprof-profiling/index.html?highlight=profiling might be helpful to get started. The slides also have links to various NVidia bits of documentation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885336918
https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885336918:268,Usability,learn,learn,268,"> I have tried running the library `ImplicitGlobalGrid.jl`in 1, 2 and 4 gpus and have actually found rather bad scaling as well, 57 and 35 percent.; > ; > I have created an issue and hope they might have some suggestions as to how to improve the results. Maybe what I learn there might be transferable to Oceananigans?. @francispoulin (see my above comment). I think ImplictGlobalGrid.jl as downloaded is not configured to run across multiple GPUs. I added a line in a fork here ( https://github.com/christophernhill/ImplicitGlobalGrid.jl/blob/5e4fd0698b7087467d9314bfa253d6bc9a09a40a/diffusion3D_multigpu_CuArrays_novis.jl#L21 ) that is needed. With that I saw reasonable weak scaling - even with broken CUDA aware MPI support. Oceananigans.jl has some other things going on. I agree profiling with nvprof/nsight would be great. This link https://github.com/mit-satori/getting-started/blob/master/tutorial-examples/nvprof-profiling/Satori_NVProf_Intro.pdf and this https://mit-satori.github.io/tutorial-examples/nvprof-profiling/index.html?highlight=profiling might be helpful to get started. The slides also have links to various NVidia bits of documentation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885336918
https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885359367:268,Usability,learn,learn,268,"> > I have tried running the library `ImplicitGlobalGrid.jl`in 1, 2 and 4 gpus and have actually found rather bad scaling as well, 57 and 35 percent.; > > I have created an issue and hope they might have some suggestions as to how to improve the results. Maybe what I learn there might be transferable to Oceananigans?; > ; > This then sounds to me like you don't have a working CUDA-aware MPI. IGG should show >90% efficiency. Thanks @vchuravy . The runs for IGG were on a server that has CUDA-aware MPI, so that's not the problem. As @christophernhill points out, there are a lot of other possibilities though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885359367
https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885360274:463,Availability,down,down,463,"> As I said, please post your slurp script and other environment options. It is impossible to debug otherwise.; > ; > I have an annotated slurp script here https://github.com/CliMA/ClimateMachine.jl/wiki/Satori-Cluster which is what I used a while back for GPU scaling tests. A mossconfigured MPI can easily manifest itself as scaling this poor. @hennyg888 has been very busy this week so hasn't had a chance to response. The slurm script that he used was passed down from @christophernhill , and I will let him share that with you, but it might not happen until Monday. But I suppose I should learn to start running stuff on Satori as that is something that everyone else can use and people understand the configuration. I'll try to do that on Monday.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885360274
https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885360274:707,Deployability,configurat,configuration,707,"> As I said, please post your slurp script and other environment options. It is impossible to debug otherwise.; > ; > I have an annotated slurp script here https://github.com/CliMA/ClimateMachine.jl/wiki/Satori-Cluster which is what I used a while back for GPU scaling tests. A mossconfigured MPI can easily manifest itself as scaling this poor. @hennyg888 has been very busy this week so hasn't had a chance to response. The slurm script that he used was passed down from @christophernhill , and I will let him share that with you, but it might not happen until Monday. But I suppose I should learn to start running stuff on Satori as that is something that everyone else can use and people understand the configuration. I'll try to do that on Monday.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885360274
https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885360274:707,Modifiability,config,configuration,707,"> As I said, please post your slurp script and other environment options. It is impossible to debug otherwise.; > ; > I have an annotated slurp script here https://github.com/CliMA/ClimateMachine.jl/wiki/Satori-Cluster which is what I used a while back for GPU scaling tests. A mossconfigured MPI can easily manifest itself as scaling this poor. @hennyg888 has been very busy this week so hasn't had a chance to response. The slurm script that he used was passed down from @christophernhill , and I will let him share that with you, but it might not happen until Monday. But I suppose I should learn to start running stuff on Satori as that is something that everyone else can use and people understand the configuration. I'll try to do that on Monday.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885360274
https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885360274:269,Testability,test,tests,269,"> As I said, please post your slurp script and other environment options. It is impossible to debug otherwise.; > ; > I have an annotated slurp script here https://github.com/CliMA/ClimateMachine.jl/wiki/Satori-Cluster which is what I used a while back for GPU scaling tests. A mossconfigured MPI can easily manifest itself as scaling this poor. @hennyg888 has been very busy this week so hasn't had a chance to response. The slurm script that he used was passed down from @christophernhill , and I will let him share that with you, but it might not happen until Monday. But I suppose I should learn to start running stuff on Satori as that is something that everyone else can use and people understand the configuration. I'll try to do that on Monday.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885360274
https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885360274:594,Usability,learn,learn,594,"> As I said, please post your slurp script and other environment options. It is impossible to debug otherwise.; > ; > I have an annotated slurp script here https://github.com/CliMA/ClimateMachine.jl/wiki/Satori-Cluster which is what I used a while back for GPU scaling tests. A mossconfigured MPI can easily manifest itself as scaling this poor. @hennyg888 has been very busy this week so hasn't had a chance to response. The slurm script that he used was passed down from @christophernhill , and I will let him share that with you, but it might not happen until Monday. But I suppose I should learn to start running stuff on Satori as that is something that everyone else can use and people understand the configuration. I'll try to do that on Monday.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885360274
https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885360570:397,Availability,down,downloaded,397,"> > I have tried running the library `ImplicitGlobalGrid.jl`in 1, 2 and 4 gpus and have actually found rather bad scaling as well, 57 and 35 percent.; > > I have created an issue and hope they might have some suggestions as to how to improve the results. Maybe what I learn there might be transferable to Oceananigans?; > ; > @francispoulin (see my above comment). I think ImplictGlobalGrid.jl as downloaded is not configured to run across multiple GPUs. I added a line in a fork here ( https://github.com/christophernhill/ImplicitGlobalGrid.jl/blob/5e4fd0698b7087467d9314bfa253d6bc9a09a40a/diffusion3D_multigpu_CuArrays_novis.jl#L21 ) that is needed. With that I saw reasonable weak scaling - even with broken CUDA aware MPI support. Oceananigans.jl has some other things going on.; > ; > I agree profiling with nvprof/nsight would be great. This link https://github.com/mit-satori/getting-started/blob/master/tutorial-examples/nvprof-profiling/Satori_NVProf_Intro.pdf and this https://mit-satori.github.io/tutorial-examples/nvprof-profiling/index.html?highlight=profiling might be helpful to get started. The slides also have links to various NVidia bits of documentation. Thanks @christophernhill for all this information. This will be most helpful. Unfortunately, tomorrow I am busy from 9am to 5pm so I don't think I can zoom, but maybe on Monday? I'll try and look into these resources before hand.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885360570
https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885360570:415,Modifiability,config,configured,415,"> > I have tried running the library `ImplicitGlobalGrid.jl`in 1, 2 and 4 gpus and have actually found rather bad scaling as well, 57 and 35 percent.; > > I have created an issue and hope they might have some suggestions as to how to improve the results. Maybe what I learn there might be transferable to Oceananigans?; > ; > @francispoulin (see my above comment). I think ImplictGlobalGrid.jl as downloaded is not configured to run across multiple GPUs. I added a line in a fork here ( https://github.com/christophernhill/ImplicitGlobalGrid.jl/blob/5e4fd0698b7087467d9314bfa253d6bc9a09a40a/diffusion3D_multigpu_CuArrays_novis.jl#L21 ) that is needed. With that I saw reasonable weak scaling - even with broken CUDA aware MPI support. Oceananigans.jl has some other things going on.; > ; > I agree profiling with nvprof/nsight would be great. This link https://github.com/mit-satori/getting-started/blob/master/tutorial-examples/nvprof-profiling/Satori_NVProf_Intro.pdf and this https://mit-satori.github.io/tutorial-examples/nvprof-profiling/index.html?highlight=profiling might be helpful to get started. The slides also have links to various NVidia bits of documentation. Thanks @christophernhill for all this information. This will be most helpful. Unfortunately, tomorrow I am busy from 9am to 5pm so I don't think I can zoom, but maybe on Monday? I'll try and look into these resources before hand.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885360570
https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885360570:268,Usability,learn,learn,268,"> > I have tried running the library `ImplicitGlobalGrid.jl`in 1, 2 and 4 gpus and have actually found rather bad scaling as well, 57 and 35 percent.; > > I have created an issue and hope they might have some suggestions as to how to improve the results. Maybe what I learn there might be transferable to Oceananigans?; > ; > @francispoulin (see my above comment). I think ImplictGlobalGrid.jl as downloaded is not configured to run across multiple GPUs. I added a line in a fork here ( https://github.com/christophernhill/ImplicitGlobalGrid.jl/blob/5e4fd0698b7087467d9314bfa253d6bc9a09a40a/diffusion3D_multigpu_CuArrays_novis.jl#L21 ) that is needed. With that I saw reasonable weak scaling - even with broken CUDA aware MPI support. Oceananigans.jl has some other things going on.; > ; > I agree profiling with nvprof/nsight would be great. This link https://github.com/mit-satori/getting-started/blob/master/tutorial-examples/nvprof-profiling/Satori_NVProf_Intro.pdf and this https://mit-satori.github.io/tutorial-examples/nvprof-profiling/index.html?highlight=profiling might be helpful to get started. The slides also have links to various NVidia bits of documentation. Thanks @christophernhill for all this information. This will be most helpful. Unfortunately, tomorrow I am busy from 9am to 5pm so I don't think I can zoom, but maybe on Monday? I'll try and look into these resources before hand.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885360570
https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885658285:70,Modifiability,config,configured,70,Might make sense to figure out how to `@assert` that the benchmark is configured correctly?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885658285
https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885658285:40,Testability,assert,assert,40,Might make sense to figure out how to `@assert` that the benchmark is configured correctly?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885658285
https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885658285:57,Testability,benchmark,benchmark,57,Might make sense to figure out how to `@assert` that the benchmark is configured correctly?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885658285
https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885799405:218,Performance,perform,performing,218,"@christophernhill : I wanted to confirm that I took your clever idea of using `select_device()` and added that into my code. When I ran it on 1, 2 and 4 GPUs I was able to get efficiences of 97 percent. So the code is performing very well, and the server can be efficent on multi GPUs. . The link to where the function is defined is copied below. Is this something that is done automatically in Oceananigans through `AbstractKernels.jl` or something else?. https://github.com/christophernhill/ImplicitGlobalGrid.jl/blob/5e4fd0698b7087467d9314bfa253d6bc9a09a40a/src/select_device.jl. In chatting with the developers of `ImplicitGlobalGrid.jl` they mentioned that to get efficiency I should use something called `@hide_communication` in `ParallelKernel.jl`. Again, I don't pretend to understand what this does but wanted to share the information I was given. https://github.com/omlins/ParallelStencil.jl/blob/main/src/ParallelKernel/hide_communication.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885799405
https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885901320:178,Performance,optimiz,optimize,178,"Another thought for @christophernhill . At the talk today on `ImplicitGlobalGrid.jl`, they were using `@view` in the simplest code but they dropped it as soon as they started to optimize the code. I believe they started using `LazyArrays.jl`. I don't know what it is but I suspect it doesn't have the problems that `@view` might have.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885901320
https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885901320:117,Usability,simpl,simplest,117,"Another thought for @christophernhill . At the talk today on `ImplicitGlobalGrid.jl`, they were using `@view` in the simplest code but they dropped it as soon as they started to optimize the code. I believe they started using `LazyArrays.jl`. I don't know what it is but I suspect it doesn't have the problems that `@view` might have.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885901320
https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885935875:185,Performance,optimiz,optimize,185,"> Another thought for @christophernhill; > ; > At the talk today on `ImplicitGlobalGrid.jl`, they were using `@view` in the simplest code but they dropped it as soon as they started to optimize the code. I believe they started using `LazyArrays.jl`. I don't know what it is but I suspect it doesn't have the problems that `@view` might have. We think that we cannot send non-contiguous data over MPI between GPUs (only CPUs). Thus certain `view`s will not work. Possibly in this case the data is transferred to CPU, sent over MPI, and then copied back to the GPU (slow).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885935875
https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885935875:124,Usability,simpl,simplest,124,"> Another thought for @christophernhill; > ; > At the talk today on `ImplicitGlobalGrid.jl`, they were using `@view` in the simplest code but they dropped it as soon as they started to optimize the code. I believe they started using `LazyArrays.jl`. I don't know what it is but I suspect it doesn't have the problems that `@view` might have. We think that we cannot send non-contiguous data over MPI between GPUs (only CPUs). Thus certain `view`s will not work. Possibly in this case the data is transferred to CPU, sent over MPI, and then copied back to the GPU (slow).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885935875
https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885972875:185,Performance,optimiz,optimize,185,"> Another thought for @christophernhill; > ; > At the talk today on `ImplicitGlobalGrid.jl`, they were using `@view` in the simplest code but they dropped it as soon as they started to optimize the code. I believe they started using `LazyArrays.jl`. I don't know what it is but I suspect it doesn't have the problems that `@view` might have. @francispoulin thanks. I think we probably just want to do some buffer. I looked at LazyArrays.jl and I could imagine how that could maybe also be included, but I suspect the main thing is having a buffer (which https://github.com/eth-cscs/ImplicitGlobalGrid.jl has). I don't see any sign of LazyArrays in https://github.com/eth-cscs/ImplicitGlobalGrid.jl code! We can check with Ludovic though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885972875
https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885972875:124,Usability,simpl,simplest,124,"> Another thought for @christophernhill; > ; > At the talk today on `ImplicitGlobalGrid.jl`, they were using `@view` in the simplest code but they dropped it as soon as they started to optimize the code. I believe they started using `LazyArrays.jl`. I don't know what it is but I suspect it doesn't have the problems that `@view` might have. @francispoulin thanks. I think we probably just want to do some buffer. I looked at LazyArrays.jl and I could imagine how that could maybe also be included, but I suspect the main thing is having a buffer (which https://github.com/eth-cscs/ImplicitGlobalGrid.jl has). I don't see any sign of LazyArrays in https://github.com/eth-cscs/ImplicitGlobalGrid.jl code! We can check with Ludovic though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885972875
https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-886074108:536,Usability,simpl,simple,536,"> @francispoulin thanks. I think we probably just want to do some buffer. I looked at LazyArrays.jl and I could imagine how that could maybe also be included, but I suspect the main thing is having a buffer (which https://github.com/eth-cscs/ImplicitGlobalGrid.jl has). I don't see any sign of LazyArrays in https://github.com/eth-cscs/ImplicitGlobalGrid.jl code! We can check with Ludovic though. Thanks for looking at this @christophernhill and sorry that I misquoted. At the JuliaCon talk yesterday, they started off talking about a simple repo and then ended up talking about `ImplicitGlobalGrid.jl`. The link I should have given was [this](https://github.com/omlins/parallel-gpu-workshop-JuliaCon21). . If you think that buffering is the way to go then I'm certainly happy to give that a try. Maybe we can have a zoom meeting this week to discuss in more detail?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-886074108
https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-887163300:2169,Testability,test,test,2169,"s was a page taken out of `ImplicitGlobalGrid.jl`'s book, more specifically https://github.com/eth-cscs/ImplicitGlobalGrid.jl/blob/master/src/select_device.jl.; Much better results:; <html>; <body>; <!--StartFragment-->. size | ranks | min | median | mean | max | memory | allocs | samples; -- | -- | -- | -- | -- | -- | -- | -- | --; (4096, 256) | (1, 1) | 2.702 ms | 2.728 ms | 2.801 ms | 3.446 ms | 2.03 MiB | 5535 | 10; (4096, 512) | (1, 2) | 3.510 ms | 3.612 ms | 4.287 ms | 16.546 ms | 2.03 MiB | 5859 | 20; (4096, 768) | (1, 3) | 3.553 ms | 3.653 ms | 5.195 ms | 39.152 ms | 2.03 MiB | 5859 | 30. <!--EndFragment-->; </body>; </html>; <html>; <body>; <!--StartFragment-->. size | ranks | slowdown | efficiency | memory | allocs; -- | -- | -- | -- | -- | --; (4096, 256) | (1, 1) | 1.0 | 1.0 | 1.0 | 1.0; (4096, 512) | (1, 2) | 1.32399 | 0.755293 | 1.00271 | 1.05854; (4096, 768) | (1, 3) | 1.33901 | 0.746818 | 1.00271 | 1.05854. <!--EndFragment-->; </body>; </html>; I could only get up to 3 GPUs because I'm still doing this on only one node. I will try to do more ranks and GPUs once more significant changes than my single line of code is added. ; This was done on Satori with setup instructions shown here: . https://github.com/christophernhill/onan-jcon2021-bits/blob/main/run/satori/run-on-bench-on-rhel7-satori-with-mpi; The better efficiency is not caused by a slowdown on the non-MPI case either. Both this result and the original one posted above had median one-rank times of around 2.7ms. System info:; ```; Julia Version 1.6.2; Commit 1b93d53fc4 (2021-07-14 15:36 UTC); Platform Info:; OS: Linux (powerpc64le-unknown-linux-gnu); CPU: unknown; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, pwr9); Environment:; JULIA_MPI_PATH = /home/software/spack/openmpi/3.1.4-nhjzelonyovxks5ydtrxehceqxsbf7ik; JULIA_CUDA_USE_BINARYBUILDER = false; JULIA_DEPOT_PATH = /nobackup/users/henryguo/projects/henry-test/Oceananigans.jl/benchmark/.julia; GPU: Tesla V100-SXM2-32GB; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-887163300
https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-887163300:2190,Testability,benchmark,benchmark,2190,"s was a page taken out of `ImplicitGlobalGrid.jl`'s book, more specifically https://github.com/eth-cscs/ImplicitGlobalGrid.jl/blob/master/src/select_device.jl.; Much better results:; <html>; <body>; <!--StartFragment-->. size | ranks | min | median | mean | max | memory | allocs | samples; -- | -- | -- | -- | -- | -- | -- | -- | --; (4096, 256) | (1, 1) | 2.702 ms | 2.728 ms | 2.801 ms | 3.446 ms | 2.03 MiB | 5535 | 10; (4096, 512) | (1, 2) | 3.510 ms | 3.612 ms | 4.287 ms | 16.546 ms | 2.03 MiB | 5859 | 20; (4096, 768) | (1, 3) | 3.553 ms | 3.653 ms | 5.195 ms | 39.152 ms | 2.03 MiB | 5859 | 30. <!--EndFragment-->; </body>; </html>; <html>; <body>; <!--StartFragment-->. size | ranks | slowdown | efficiency | memory | allocs; -- | -- | -- | -- | -- | --; (4096, 256) | (1, 1) | 1.0 | 1.0 | 1.0 | 1.0; (4096, 512) | (1, 2) | 1.32399 | 0.755293 | 1.00271 | 1.05854; (4096, 768) | (1, 3) | 1.33901 | 0.746818 | 1.00271 | 1.05854. <!--EndFragment-->; </body>; </html>; I could only get up to 3 GPUs because I'm still doing this on only one node. I will try to do more ranks and GPUs once more significant changes than my single line of code is added. ; This was done on Satori with setup instructions shown here: . https://github.com/christophernhill/onan-jcon2021-bits/blob/main/run/satori/run-on-bench-on-rhel7-satori-with-mpi; The better efficiency is not caused by a slowdown on the non-MPI case either. Both this result and the original one posted above had median one-rank times of around 2.7ms. System info:; ```; Julia Version 1.6.2; Commit 1b93d53fc4 (2021-07-14 15:36 UTC); Platform Info:; OS: Linux (powerpc64le-unknown-linux-gnu); CPU: unknown; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, pwr9); Environment:; JULIA_MPI_PATH = /home/software/spack/openmpi/3.1.4-nhjzelonyovxks5ydtrxehceqxsbf7ik; JULIA_CUDA_USE_BINARYBUILDER = false; JULIA_DEPOT_PATH = /nobackup/users/henryguo/projects/henry-test/Oceananigans.jl/benchmark/.julia; GPU: Tesla V100-SXM2-32GB; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-887163300
https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-887396112:216,Testability,log,log,216,@hennyg888 good to see that helped. . I think there is a CUDA.versioninfo() ( https://github.com/JuliaGPU/CUDA.jl/blob/4985b0d5827f776683edb702ff296dcb59ba1097/src/utilities.jl#L42 ) function that would be useful to log along side `System info:`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-887396112
https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-887431593:653,Availability,down,down,653,"That is a huge leap forward @hennyg888 and great to see! Before we were at 50% and now we are at 75%. An increase of 50%, which is pretty huge all things considered. I like @christophernhill 's suggest of adding the version info. Yesterday when we talked the consensus was that one major problem was how we do buffering. As a silly experiment, what if we redo this without updating any halos, ever. Physically, it's going to be wrong but do we get another huge increase in the efficiency? If the efficiency gets close to 100% then in my mind that validate the hypothesis. If not, then that would signify there is another bottleneck that we need to hunt down.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-887431593
https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-887431593:621,Performance,bottleneck,bottleneck,621,"That is a huge leap forward @hennyg888 and great to see! Before we were at 50% and now we are at 75%. An increase of 50%, which is pretty huge all things considered. I like @christophernhill 's suggest of adding the version info. Yesterday when we talked the consensus was that one major problem was how we do buffering. As a silly experiment, what if we redo this without updating any halos, ever. Physically, it's going to be wrong but do we get another huge increase in the efficiency? If the efficiency gets close to 100% then in my mind that validate the hypothesis. If not, then that would signify there is another bottleneck that we need to hunt down.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-887431593
https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-887431593:547,Security,validat,validate,547,"That is a huge leap forward @hennyg888 and great to see! Before we were at 50% and now we are at 75%. An increase of 50%, which is pretty huge all things considered. I like @christophernhill 's suggest of adding the version info. Yesterday when we talked the consensus was that one major problem was how we do buffering. As a silly experiment, what if we redo this without updating any halos, ever. Physically, it's going to be wrong but do we get another huge increase in the efficiency? If the efficiency gets close to 100% then in my mind that validate the hypothesis. If not, then that would signify there is another bottleneck that we need to hunt down.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-887431593
https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-887833700:850,Testability,benchmark,benchmark,850,"Apologies for not participating in this issue and for possibly being the cause of the issue via sending/receiving views... If we have to send contiguous data we could just modify the [`underlying_*_boundary` functions](https://github.com/CliMA/Oceananigans.jl/blob/master/src/Distributed/distributed_utils.jl#L83-L99) to convert the view into a contiguous array. Receiving is done straight into the halo view (a trick(?) that seems to work nicely on the CPU), so we would probably need to create a new buffer of the right size to receive into and then copy it into the halo: https://github.com/CliMA/Oceananigans.jl/blob/master/src/Distributed/halo_communication.jl#L162-L166. Also not sure if relevant but I remember @hennyg888 and @francispoulin suggesting that placing an `MPI.Barrier()` at the end of each time step helped with a certain scaling benchmark?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-887833700
https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-887933846:2032,Availability,avail,available,2032,"2 to remove filling halo regions and buffering between ranks.; This gave perfect efficiency up to 3 ranks. This was mainly done to locate where possible bottlenecks are and not a legitimate change to the code. It was expected that buffering is what's causing efficiency decreases, and this confirms that there are no other additional undetected causes for efficiency drops.; <html>; <body>; <!--StartFragment-->. size | ranks | slowdown | efficiency | memory | allocs; -- | -- | -- | -- | -- | --; (4096, 256) | (1, 1) | 1.0 | 1.0 | 1.0 | 1.0; (4096, 512) | (1, 2) | 0.988079 | 1.01206 | 1.06328 | 1.0406; (4096, 768) | (1, 3) | 0.992832 | 1.00722 | 1.06328 | 1.0406. <!--EndFragment-->; </body>; </html>. system environment and CUDA.versioninfo():; ```; Oceananigans v0.60.0; Julia Version 1.6.2; Commit 1b93d53fc4 (2021-07-14 15:36 UTC); Platform Info:; OS: Linux (powerpc64le-unknown-linux-gnu); CPU: unknown; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, pwr9); Environment:; JULIA_MPI_PATH = /home/software/spack/openmpi/3.1.4-nhjzelonyovxks5ydtrxehceqxsbf7ik; JULIA_CUDA_USE_BINARYBUILDER = false; JULIA_DEPOT_PATH = /nobackup/users/henryguo/projects/henry-test/.julia; GPU: Tesla V100-SXM2-32GB. CUDA toolkit 10.1.243, local installation; CUDA driver 10.2.0; NVIDIA driver 440.64.0; Libraries: ; - CUBLAS: 10.2.2; - CURAND: 10.1.1; - CUFFT: 10.1.1; - CUSOLVER: 10.2.0; - CUSPARSE: 10.3.0; - CUPTI: 12.0.0; - NVML: 10.0.0+440.64.0; - CUDNN: missing; - CUTENSOR: missing; Toolchain:; - Julia: 1.6.2; - LLVM: 11.0.1; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4; - Device capability support: sm_30, sm_32, sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75; Environment:; - JULIA_CUDA_USE_BINARYBUILDER: false; 3 devices:; 0: Tesla V100-SXM2-32GB (sm_70, 31.738 GiB / 31.749 GiB available); 1: Tesla V100-SXM2-32GB (sm_70, 31.738 GiB / 31.749 GiB available); 2: Tesla V100-SXM2-32GB (sm_70, 31.738 GiB / 31.749 GiB available); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-887933846
https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-887933846:2100,Availability,avail,available,2100,"2 to remove filling halo regions and buffering between ranks.; This gave perfect efficiency up to 3 ranks. This was mainly done to locate where possible bottlenecks are and not a legitimate change to the code. It was expected that buffering is what's causing efficiency decreases, and this confirms that there are no other additional undetected causes for efficiency drops.; <html>; <body>; <!--StartFragment-->. size | ranks | slowdown | efficiency | memory | allocs; -- | -- | -- | -- | -- | --; (4096, 256) | (1, 1) | 1.0 | 1.0 | 1.0 | 1.0; (4096, 512) | (1, 2) | 0.988079 | 1.01206 | 1.06328 | 1.0406; (4096, 768) | (1, 3) | 0.992832 | 1.00722 | 1.06328 | 1.0406. <!--EndFragment-->; </body>; </html>. system environment and CUDA.versioninfo():; ```; Oceananigans v0.60.0; Julia Version 1.6.2; Commit 1b93d53fc4 (2021-07-14 15:36 UTC); Platform Info:; OS: Linux (powerpc64le-unknown-linux-gnu); CPU: unknown; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, pwr9); Environment:; JULIA_MPI_PATH = /home/software/spack/openmpi/3.1.4-nhjzelonyovxks5ydtrxehceqxsbf7ik; JULIA_CUDA_USE_BINARYBUILDER = false; JULIA_DEPOT_PATH = /nobackup/users/henryguo/projects/henry-test/.julia; GPU: Tesla V100-SXM2-32GB. CUDA toolkit 10.1.243, local installation; CUDA driver 10.2.0; NVIDIA driver 440.64.0; Libraries: ; - CUBLAS: 10.2.2; - CURAND: 10.1.1; - CUFFT: 10.1.1; - CUSOLVER: 10.2.0; - CUSPARSE: 10.3.0; - CUPTI: 12.0.0; - NVML: 10.0.0+440.64.0; - CUDNN: missing; - CUTENSOR: missing; Toolchain:; - Julia: 1.6.2; - LLVM: 11.0.1; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4; - Device capability support: sm_30, sm_32, sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75; Environment:; - JULIA_CUDA_USE_BINARYBUILDER: false; 3 devices:; 0: Tesla V100-SXM2-32GB (sm_70, 31.738 GiB / 31.749 GiB available); 1: Tesla V100-SXM2-32GB (sm_70, 31.738 GiB / 31.749 GiB available); 2: Tesla V100-SXM2-32GB (sm_70, 31.738 GiB / 31.749 GiB available); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-887933846
https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-887933846:2168,Availability,avail,available,2168,"2 to remove filling halo regions and buffering between ranks.; This gave perfect efficiency up to 3 ranks. This was mainly done to locate where possible bottlenecks are and not a legitimate change to the code. It was expected that buffering is what's causing efficiency decreases, and this confirms that there are no other additional undetected causes for efficiency drops.; <html>; <body>; <!--StartFragment-->. size | ranks | slowdown | efficiency | memory | allocs; -- | -- | -- | -- | -- | --; (4096, 256) | (1, 1) | 1.0 | 1.0 | 1.0 | 1.0; (4096, 512) | (1, 2) | 0.988079 | 1.01206 | 1.06328 | 1.0406; (4096, 768) | (1, 3) | 0.992832 | 1.00722 | 1.06328 | 1.0406. <!--EndFragment-->; </body>; </html>. system environment and CUDA.versioninfo():; ```; Oceananigans v0.60.0; Julia Version 1.6.2; Commit 1b93d53fc4 (2021-07-14 15:36 UTC); Platform Info:; OS: Linux (powerpc64le-unknown-linux-gnu); CPU: unknown; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, pwr9); Environment:; JULIA_MPI_PATH = /home/software/spack/openmpi/3.1.4-nhjzelonyovxks5ydtrxehceqxsbf7ik; JULIA_CUDA_USE_BINARYBUILDER = false; JULIA_DEPOT_PATH = /nobackup/users/henryguo/projects/henry-test/.julia; GPU: Tesla V100-SXM2-32GB. CUDA toolkit 10.1.243, local installation; CUDA driver 10.2.0; NVIDIA driver 440.64.0; Libraries: ; - CUBLAS: 10.2.2; - CURAND: 10.1.1; - CUFFT: 10.1.1; - CUSOLVER: 10.2.0; - CUSPARSE: 10.3.0; - CUPTI: 12.0.0; - NVML: 10.0.0+440.64.0; - CUDNN: missing; - CUTENSOR: missing; Toolchain:; - Julia: 1.6.2; - LLVM: 11.0.1; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4; - Device capability support: sm_30, sm_32, sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75; Environment:; - JULIA_CUDA_USE_BINARYBUILDER: false; 3 devices:; 0: Tesla V100-SXM2-32GB (sm_70, 31.738 GiB / 31.749 GiB available); 1: Tesla V100-SXM2-32GB (sm_70, 31.738 GiB / 31.749 GiB available); 2: Tesla V100-SXM2-32GB (sm_70, 31.738 GiB / 31.749 GiB available); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-887933846
https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-887933846:1433,Deployability,install,installation,1433,"2 to remove filling halo regions and buffering between ranks.; This gave perfect efficiency up to 3 ranks. This was mainly done to locate where possible bottlenecks are and not a legitimate change to the code. It was expected that buffering is what's causing efficiency decreases, and this confirms that there are no other additional undetected causes for efficiency drops.; <html>; <body>; <!--StartFragment-->. size | ranks | slowdown | efficiency | memory | allocs; -- | -- | -- | -- | -- | --; (4096, 256) | (1, 1) | 1.0 | 1.0 | 1.0 | 1.0; (4096, 512) | (1, 2) | 0.988079 | 1.01206 | 1.06328 | 1.0406; (4096, 768) | (1, 3) | 0.992832 | 1.00722 | 1.06328 | 1.0406. <!--EndFragment-->; </body>; </html>. system environment and CUDA.versioninfo():; ```; Oceananigans v0.60.0; Julia Version 1.6.2; Commit 1b93d53fc4 (2021-07-14 15:36 UTC); Platform Info:; OS: Linux (powerpc64le-unknown-linux-gnu); CPU: unknown; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, pwr9); Environment:; JULIA_MPI_PATH = /home/software/spack/openmpi/3.1.4-nhjzelonyovxks5ydtrxehceqxsbf7ik; JULIA_CUDA_USE_BINARYBUILDER = false; JULIA_DEPOT_PATH = /nobackup/users/henryguo/projects/henry-test/.julia; GPU: Tesla V100-SXM2-32GB. CUDA toolkit 10.1.243, local installation; CUDA driver 10.2.0; NVIDIA driver 440.64.0; Libraries: ; - CUBLAS: 10.2.2; - CURAND: 10.1.1; - CUFFT: 10.1.1; - CUSOLVER: 10.2.0; - CUSPARSE: 10.3.0; - CUPTI: 12.0.0; - NVML: 10.0.0+440.64.0; - CUDNN: missing; - CUTENSOR: missing; Toolchain:; - Julia: 1.6.2; - LLVM: 11.0.1; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4; - Device capability support: sm_30, sm_32, sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75; Environment:; - JULIA_CUDA_USE_BINARYBUILDER: false; 3 devices:; 0: Tesla V100-SXM2-32GB (sm_70, 31.738 GiB / 31.749 GiB available); 1: Tesla V100-SXM2-32GB (sm_70, 31.738 GiB / 31.749 GiB available); 2: Tesla V100-SXM2-32GB (sm_70, 31.738 GiB / 31.749 GiB available); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-887933846
https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-887933846:336,Performance,bottleneck,bottlenecks,336,"As suggested by @francispoulin, the following was commented out https://github.com/CliMA/Oceananigans.jl/blob/master/src/Models/ShallowWaterModels/update_shallow_water_state.jl#L19-L22 to remove filling halo regions and buffering between ranks.; This gave perfect efficiency up to 3 ranks. This was mainly done to locate where possible bottlenecks are and not a legitimate change to the code. It was expected that buffering is what's causing efficiency decreases, and this confirms that there are no other additional undetected causes for efficiency drops.; <html>; <body>; <!--StartFragment-->. size | ranks | slowdown | efficiency | memory | allocs; -- | -- | -- | -- | -- | --; (4096, 256) | (1, 1) | 1.0 | 1.0 | 1.0 | 1.0; (4096, 512) | (1, 2) | 0.988079 | 1.01206 | 1.06328 | 1.0406; (4096, 768) | (1, 3) | 0.992832 | 1.00722 | 1.06328 | 1.0406. <!--EndFragment-->; </body>; </html>. system environment and CUDA.versioninfo():; ```; Oceananigans v0.60.0; Julia Version 1.6.2; Commit 1b93d53fc4 (2021-07-14 15:36 UTC); Platform Info:; OS: Linux (powerpc64le-unknown-linux-gnu); CPU: unknown; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, pwr9); Environment:; JULIA_MPI_PATH = /home/software/spack/openmpi/3.1.4-nhjzelonyovxks5ydtrxehceqxsbf7ik; JULIA_CUDA_USE_BINARYBUILDER = false; JULIA_DEPOT_PATH = /nobackup/users/henryguo/projects/henry-test/.julia; GPU: Tesla V100-SXM2-32GB. CUDA toolkit 10.1.243, local installation; CUDA driver 10.2.0; NVIDIA driver 440.64.0; Libraries: ; - CUBLAS: 10.2.2; - CURAND: 10.1.1; - CUFFT: 10.1.1; - CUSOLVER: 10.2.0; - CUSPARSE: 10.3.0; - CUPTI: 12.0.0; - NVML: 10.0.0+440.64.0; - CUDNN: missing; - CUTENSOR: missing; Toolchain:; - Julia: 1.6.2; - LLVM: 11.0.1; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4; - Device capability support: sm_30, sm_32, sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75; Environment:; - JULIA_CUDA_USE_BINARYBUILDER: false; 3 devices:; 0: Tesla V100-SXM2-32GB (",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-887933846
https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-887933846:1364,Testability,test,test,1364,"2 to remove filling halo regions and buffering between ranks.; This gave perfect efficiency up to 3 ranks. This was mainly done to locate where possible bottlenecks are and not a legitimate change to the code. It was expected that buffering is what's causing efficiency decreases, and this confirms that there are no other additional undetected causes for efficiency drops.; <html>; <body>; <!--StartFragment-->. size | ranks | slowdown | efficiency | memory | allocs; -- | -- | -- | -- | -- | --; (4096, 256) | (1, 1) | 1.0 | 1.0 | 1.0 | 1.0; (4096, 512) | (1, 2) | 0.988079 | 1.01206 | 1.06328 | 1.0406; (4096, 768) | (1, 3) | 0.992832 | 1.00722 | 1.06328 | 1.0406. <!--EndFragment-->; </body>; </html>. system environment and CUDA.versioninfo():; ```; Oceananigans v0.60.0; Julia Version 1.6.2; Commit 1b93d53fc4 (2021-07-14 15:36 UTC); Platform Info:; OS: Linux (powerpc64le-unknown-linux-gnu); CPU: unknown; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, pwr9); Environment:; JULIA_MPI_PATH = /home/software/spack/openmpi/3.1.4-nhjzelonyovxks5ydtrxehceqxsbf7ik; JULIA_CUDA_USE_BINARYBUILDER = false; JULIA_DEPOT_PATH = /nobackup/users/henryguo/projects/henry-test/.julia; GPU: Tesla V100-SXM2-32GB. CUDA toolkit 10.1.243, local installation; CUDA driver 10.2.0; NVIDIA driver 440.64.0; Libraries: ; - CUBLAS: 10.2.2; - CURAND: 10.1.1; - CUFFT: 10.1.1; - CUSOLVER: 10.2.0; - CUSPARSE: 10.3.0; - CUPTI: 12.0.0; - NVML: 10.0.0+440.64.0; - CUDNN: missing; - CUTENSOR: missing; Toolchain:; - Julia: 1.6.2; - LLVM: 11.0.1; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4; - Device capability support: sm_30, sm_32, sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75; Environment:; - JULIA_CUDA_USE_BINARYBUILDER: false; 3 devices:; 0: Tesla V100-SXM2-32GB (sm_70, 31.738 GiB / 31.749 GiB available); 1: Tesla V100-SXM2-32GB (sm_70, 31.738 GiB / 31.749 GiB available); 2: Tesla V100-SXM2-32GB (sm_70, 31.738 GiB / 31.749 GiB available); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-887933846
https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-888342252:399,Energy Efficiency,efficient,efficient,399,"> Thanks @hennyg888 for confirming this. The result is as it should be and I think you have confirmed that when we get the buffer working for the MPI, that should drasatically improve the scaling on multi GPUs. I guess I'd say that we have confirmed its the MPI communication / halo filling that causes a drop in efficiency. Next we have to figure out if we can design a communication system that's efficient! Contiguous buffers are promising but not guaranteed I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-888342252
https://github.com/CliMA/Oceananigans.jl/pull/1884#issuecomment-884797579:219,Energy Efficiency,efficient,efficient,219,"The change is great!. Before merging, the code needs to be proofread to remove formatting inconsistencies. I may not have caught all of them, so I think it'd be good to look over every file individually. It may be more efficient in the future to issue search and replace in individual files, so the change sites can be inspected at that time (except in lucky cases where the replaced pattern has the same number of characters as the original one, like incompressible -> nonhydrostatic).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1884#issuecomment-884797579
https://github.com/CliMA/Oceananigans.jl/pull/1884#issuecomment-884919176:17,Energy Efficiency,efficient,efficient,17,"> It may be more efficient in the future to issue search and replace in individual files, so the change sites can be inspected at that time (except in lucky cases where the replaced pattern has the same number of characters as the original one, like incompressible -> nonhydrostatic). I actually did that and fixed most of the formatting by hand. The thing is that I think you're way more attentive to the formatting than I am :joy:, so there were some things that I completely missed and others that I saw but thought were fine. . For example the 4-col indentation for arguments, which I didn't know was a thing. The way that Oceananigans indents some stuff (by aligning the equals sign) is very unique and I had never seen it before so I may not have caught all the rules yet. (I always use the [python standard](https://www.python.org/dev/peps/pep-0008/) for all my code, which is easier to enforce and automatize I think.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1884#issuecomment-884919176
https://github.com/CliMA/Oceananigans.jl/issues/1885#issuecomment-884941870:59,Testability,Test,Test,59,"I don't pretend to understand the 3 different options but `Test.@inferred` seems to work nicely, and it's the one that I understand best. Maybe this is something worth starting with unless someone has reasons to think ether of the two other options are better?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1885#issuecomment-884941870
https://github.com/CliMA/Oceananigans.jl/issues/1885#issuecomment-1479895705:202,Availability,error,error,202,"I'm closing this issue because I'm judging that it's not of current, timely relevance to Oceananigans development. If you would like to make it a higher priority or if you think the issue was closed in error please feel free to re-open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1885#issuecomment-1479895705
https://github.com/CliMA/Oceananigans.jl/pull/1888#issuecomment-885008488:120,Availability,mask,masking,120,"> The plume emerging from the tracer is due to leakage right? It's a nice way to visualize it quickly. Yes. Without the masking, the 0 concentration in the cylinder just leaks out until it's replaced by the fluid concentration. You can see it in this one:. https://user-images.githubusercontent.com/67593861/126666332-df00dec5-3c1c-4d17-9c67-cf7fdc4bd26a.mp4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1888#issuecomment-885008488
https://github.com/CliMA/Oceananigans.jl/pull/1888#issuecomment-885164695:129,Availability,mask,masking,129,"> > The plume emerging from the tracer is due to leakage right? It's a nice way to visualize it quickly.; > ; > Yes. Without the masking, the 0 concentration in the cylinder just leaks out until it's replaced by the fluid concentration. You can see it in this one:; > ; > contours_tracer_Nh_1000_5thOrder.mp4. Hmm, that's another way to visualize the leakage.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1888#issuecomment-885164695
https://github.com/CliMA/Oceananigans.jl/issues/1889#issuecomment-885268477:583,Availability,down,downsides,583,"> When the model is created the velocities and tracers are initialized to 0 so I think the diffusivity is zero then (typically...)? I believe this is the case in your example --- isn't it correct that the diffusivities are zero?. Not in this case because it ends up not adding the molecular viscosity. > To cover the case that explicit tracer and velocity fields are supplied to a model with non-zero values, we could call update_state! in the constructor --- not a bad idea at all. That just requires changing this line:. I think this makes things more intuitive, no? Are there any downsides besides a slightly longer building time for `model`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1889#issuecomment-885268477
https://github.com/CliMA/Oceananigans.jl/issues/1889#issuecomment-885268477:554,Usability,intuit,intuitive,554,"> When the model is created the velocities and tracers are initialized to 0 so I think the diffusivity is zero then (typically...)? I believe this is the case in your example --- isn't it correct that the diffusivities are zero?. Not in this case because it ends up not adding the molecular viscosity. > To cover the case that explicit tracer and velocity fields are supplied to a model with non-zero values, we could call update_state! in the constructor --- not a bad idea at all. That just requires changing this line:. I think this makes things more intuitive, no? Are there any downsides besides a slightly longer building time for `model`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1889#issuecomment-885268477
https://github.com/CliMA/Oceananigans.jl/issues/1889#issuecomment-885340708:62,Availability,down,downsides,62,"> I think this makes things more intuitive, no? Are there any downsides besides a slightly longer building time for `model`?. There's no downside. `update_state!` has to be efficient for the model to run so I don't think there's a performance issue. I think it's more ""correct"", since without that call the auxiliary state may be wrong initially.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1889#issuecomment-885340708
https://github.com/CliMA/Oceananigans.jl/issues/1889#issuecomment-885340708:137,Availability,down,downside,137,"> I think this makes things more intuitive, no? Are there any downsides besides a slightly longer building time for `model`?. There's no downside. `update_state!` has to be efficient for the model to run so I don't think there's a performance issue. I think it's more ""correct"", since without that call the auxiliary state may be wrong initially.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1889#issuecomment-885340708
https://github.com/CliMA/Oceananigans.jl/issues/1889#issuecomment-885340708:173,Energy Efficiency,efficient,efficient,173,"> I think this makes things more intuitive, no? Are there any downsides besides a slightly longer building time for `model`?. There's no downside. `update_state!` has to be efficient for the model to run so I don't think there's a performance issue. I think it's more ""correct"", since without that call the auxiliary state may be wrong initially.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1889#issuecomment-885340708
https://github.com/CliMA/Oceananigans.jl/issues/1889#issuecomment-885340708:231,Performance,perform,performance,231,"> I think this makes things more intuitive, no? Are there any downsides besides a slightly longer building time for `model`?. There's no downside. `update_state!` has to be efficient for the model to run so I don't think there's a performance issue. I think it's more ""correct"", since without that call the auxiliary state may be wrong initially.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1889#issuecomment-885340708
https://github.com/CliMA/Oceananigans.jl/issues/1889#issuecomment-885340708:33,Usability,intuit,intuitive,33,"> I think this makes things more intuitive, no? Are there any downsides besides a slightly longer building time for `model`?. There's no downside. `update_state!` has to be efficient for the model to run so I don't think there's a performance issue. I think it's more ""correct"", since without that call the auxiliary state may be wrong initially.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1889#issuecomment-885340708
https://github.com/CliMA/Oceananigans.jl/pull/1891#issuecomment-885565947:196,Testability,test,tests,196,@tomchor I think I know what I need to do to resolve the issues. Do you mind if I send commits to this PR?. Basically we have built models in a way that would not withstand time stepping (but the tests passed because we never tried to time step). We just need to stop running those tests. Also `restore_from_checkpoint` should be skipped (and the whole feature deprecated).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1891#issuecomment-885565947
https://github.com/CliMA/Oceananigans.jl/pull/1891#issuecomment-885565947:282,Testability,test,tests,282,@tomchor I think I know what I need to do to resolve the issues. Do you mind if I send commits to this PR?. Basically we have built models in a way that would not withstand time stepping (but the tests passed because we never tried to time step). We just need to stop running those tests. Also `restore_from_checkpoint` should be skipped (and the whole feature deprecated).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1891#issuecomment-885565947
https://github.com/CliMA/Oceananigans.jl/pull/1891#issuecomment-885628607:204,Testability,test,tests,204,"> @tomchor I think I know what I need to do to resolve the issues. Do you mind if I send commits to this PR?; > ; > Basically we have built models in a way that would not withstand time stepping (but the tests passed because we never tried to time step). We just need to stop running those tests. Also `restore_from_checkpoint` should be skipped (and the whole feature deprecated). Please, commit away! And thanks",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1891#issuecomment-885628607
https://github.com/CliMA/Oceananigans.jl/pull/1891#issuecomment-885628607:290,Testability,test,tests,290,"> @tomchor I think I know what I need to do to resolve the issues. Do you mind if I send commits to this PR?; > ; > Basically we have built models in a way that would not withstand time stepping (but the tests passed because we never tried to time step). We just need to stop running those tests. Also `restore_from_checkpoint` should be skipped (and the whole feature deprecated). Please, commit away! And thanks",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1891#issuecomment-885628607
https://github.com/CliMA/Oceananigans.jl/pull/1891#issuecomment-885660090:453,Availability,checkpoint,checkpoint,453,"> > @tomchor I think I know what I need to do to resolve the issues. Do you mind if I send commits to this PR?; > > Basically we have built models in a way that would not withstand time stepping (but the tests passed because we never tried to time step). We just need to stop running those tests. Also `restore_from_checkpoint` should be skipped (and the whole feature deprecated).; > ; > Please, commit away! And thanks. Gonna resolve the restore from checkpoint thing in a separate PR once and for all rather than fiddle around with it here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1891#issuecomment-885660090
https://github.com/CliMA/Oceananigans.jl/pull/1891#issuecomment-885660090:204,Testability,test,tests,204,"> > @tomchor I think I know what I need to do to resolve the issues. Do you mind if I send commits to this PR?; > > Basically we have built models in a way that would not withstand time stepping (but the tests passed because we never tried to time step). We just need to stop running those tests. Also `restore_from_checkpoint` should be skipped (and the whole feature deprecated).; > ; > Please, commit away! And thanks. Gonna resolve the restore from checkpoint thing in a separate PR once and for all rather than fiddle around with it here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1891#issuecomment-885660090
https://github.com/CliMA/Oceananigans.jl/pull/1891#issuecomment-885660090:290,Testability,test,tests,290,"> > @tomchor I think I know what I need to do to resolve the issues. Do you mind if I send commits to this PR?; > > Basically we have built models in a way that would not withstand time stepping (but the tests passed because we never tried to time step). We just need to stop running those tests. Also `restore_from_checkpoint` should be skipped (and the whole feature deprecated).; > ; > Please, commit away! And thanks. Gonna resolve the restore from checkpoint thing in a separate PR once and for all rather than fiddle around with it here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1891#issuecomment-885660090
https://github.com/CliMA/Oceananigans.jl/pull/1891#issuecomment-886840197:123,Deployability,patch,patch,123,Seems like @glwagner's nuking of `restore_from_checkpoint` worked well. I'm gonna merge this soon. Is this worth bumping a patch release since the initial diffusivities might be wrong without this?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1891#issuecomment-886840197
https://github.com/CliMA/Oceananigans.jl/pull/1891#issuecomment-886840197:129,Deployability,release,release,129,Seems like @glwagner's nuking of `restore_from_checkpoint` worked well. I'm gonna merge this soon. Is this worth bumping a patch release since the initial diffusivities might be wrong without this?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1891#issuecomment-886840197
https://github.com/CliMA/Oceananigans.jl/pull/1891#issuecomment-887484538:132,Deployability,patch,patch,132,"> Seems like @glwagner's nuking of `restore_from_checkpoint` worked well. I'm gonna merge this soon.; > ; > Is this worth bumping a patch release since the initial diffusivities might be wrong without this?. This is breaking, so I think we should bump a major release.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1891#issuecomment-887484538
https://github.com/CliMA/Oceananigans.jl/pull/1891#issuecomment-887484538:138,Deployability,release,release,138,"> Seems like @glwagner's nuking of `restore_from_checkpoint` worked well. I'm gonna merge this soon.; > ; > Is this worth bumping a patch release since the initial diffusivities might be wrong without this?. This is breaking, so I think we should bump a major release.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1891#issuecomment-887484538
https://github.com/CliMA/Oceananigans.jl/pull/1891#issuecomment-887484538:260,Deployability,release,release,260,"> Seems like @glwagner's nuking of `restore_from_checkpoint` worked well. I'm gonna merge this soon.; > ; > Is this worth bumping a patch release since the initial diffusivities might be wrong without this?. This is breaking, so I think we should bump a major release.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1891#issuecomment-887484538
https://github.com/CliMA/Oceananigans.jl/pull/1891#issuecomment-887894341:53,Deployability,release,release,53,">This is breaking, so I think we should bump a major release. Bumped and merged. @glwagner I'm waiting for https://github.com/CliMA/Oceananigans.jl/pull/1892 to be merged as well before actually tagging a new release, but feel free to go ahead and just tag one if that's not good practice.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1891#issuecomment-887894341
https://github.com/CliMA/Oceananigans.jl/pull/1891#issuecomment-887894341:209,Deployability,release,release,209,">This is breaking, so I think we should bump a major release. Bumped and merged. @glwagner I'm waiting for https://github.com/CliMA/Oceananigans.jl/pull/1892 to be merged as well before actually tagging a new release, but feel free to go ahead and just tag one if that's not good practice.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1891#issuecomment-887894341
https://github.com/CliMA/Oceananigans.jl/pull/1891#issuecomment-887904401:36,Deployability,release,release,36,Probably best if we can access this release through the registry right? Why wait?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1891#issuecomment-887904401
https://github.com/CliMA/Oceananigans.jl/pull/1891#issuecomment-887904401:24,Security,access,access,24,Probably best if we can access this release through the registry right? Why wait?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1891#issuecomment-887904401
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886096063:371,Usability,simpl,simple,371,"From #1372:. > On the other hand, it's a bit confusing that all Coriolis forces ultimately represent a ""background rotation rate""... Yeah I agree this might make it a bit confusing. For now I didn't delete anything and created `GeneralFPlane` as a placeholder. Would it be too bad to just have `FPlane` and let it default to `rotation_axis=ZDIrection()`? I think this is simple and would do the job well enough.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886096063
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886097464:5,Modifiability,refactor,refactoring,5,"On a refactoring note, currently `ZDirection` is defined here https://github.com/CliMA/Oceananigans.jl/blob/fafdf3c7caa6aa1431b9d6437036794ec5dcb8fc/src/BuoyancyModels/buoyancy.jl#L6. Which is after `Coriolis/coriolis.jl` is compiled. I think it makes more sense to move this definition to `Grids`. Everyone okay with that? That way any other module can use it (and I can use in Coriolis). I also think would be useful to use something like `validate_vertical_unit_vector()` to validate the rotation axis: https://github.com/CliMA/Oceananigans.jl/blob/fafdf3c7caa6aa1431b9d6437036794ec5dcb8fc/src/BuoyancyModels/buoyancy.jl#L37. So I was thinking of moving this to `Utils` (or maybe even `Grids`?) and renaming it to `validate_unit_vector()`. Since this would be refactoring code, I'll wait for some feedback before doing these modifications.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886097464
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886097464:763,Modifiability,refactor,refactoring,763,"On a refactoring note, currently `ZDirection` is defined here https://github.com/CliMA/Oceananigans.jl/blob/fafdf3c7caa6aa1431b9d6437036794ec5dcb8fc/src/BuoyancyModels/buoyancy.jl#L6. Which is after `Coriolis/coriolis.jl` is compiled. I think it makes more sense to move this definition to `Grids`. Everyone okay with that? That way any other module can use it (and I can use in Coriolis). I also think would be useful to use something like `validate_vertical_unit_vector()` to validate the rotation axis: https://github.com/CliMA/Oceananigans.jl/blob/fafdf3c7caa6aa1431b9d6437036794ec5dcb8fc/src/BuoyancyModels/buoyancy.jl#L37. So I was thinking of moving this to `Utils` (or maybe even `Grids`?) and renaming it to `validate_unit_vector()`. Since this would be refactoring code, I'll wait for some feedback before doing these modifications.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886097464
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886097464:478,Security,validat,validate,478,"On a refactoring note, currently `ZDirection` is defined here https://github.com/CliMA/Oceananigans.jl/blob/fafdf3c7caa6aa1431b9d6437036794ec5dcb8fc/src/BuoyancyModels/buoyancy.jl#L6. Which is after `Coriolis/coriolis.jl` is compiled. I think it makes more sense to move this definition to `Grids`. Everyone okay with that? That way any other module can use it (and I can use in Coriolis). I also think would be useful to use something like `validate_vertical_unit_vector()` to validate the rotation axis: https://github.com/CliMA/Oceananigans.jl/blob/fafdf3c7caa6aa1431b9d6437036794ec5dcb8fc/src/BuoyancyModels/buoyancy.jl#L37. So I was thinking of moving this to `Utils` (or maybe even `Grids`?) and renaming it to `validate_unit_vector()`. Since this would be refactoring code, I'll wait for some feedback before doing these modifications.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886097464
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886097464:800,Usability,feedback,feedback,800,"On a refactoring note, currently `ZDirection` is defined here https://github.com/CliMA/Oceananigans.jl/blob/fafdf3c7caa6aa1431b9d6437036794ec5dcb8fc/src/BuoyancyModels/buoyancy.jl#L6. Which is after `Coriolis/coriolis.jl` is compiled. I think it makes more sense to move this definition to `Grids`. Everyone okay with that? That way any other module can use it (and I can use in Coriolis). I also think would be useful to use something like `validate_vertical_unit_vector()` to validate the rotation axis: https://github.com/CliMA/Oceananigans.jl/blob/fafdf3c7caa6aa1431b9d6437036794ec5dcb8fc/src/BuoyancyModels/buoyancy.jl#L37. So I was thinking of moving this to `Utils` (or maybe even `Grids`?) and renaming it to `validate_unit_vector()`. Since this would be refactoring code, I'll wait for some feedback before doing these modifications.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886097464
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886217879:283,Integrability,depend,depends,283,"Thanks for creating this @tomchor , I think this is a neat idea. To help me think about how this should look, could you help me find an example you want want to do this? . I can imagine that maybe you would want a general fplane and general nontraditional fplane as well. I guess it depends on the physical set up.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886217879
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886257814:457,Availability,avail,available,457,"> To help me think about how this should look, could you help me find an example you want want to do this?. Sure thing! The example I'm developing this for specifically is a tilted bottom boundary layer. (https://github.com/CliMA/Oceananigans.jl/pull/1498). Over there I'm tilting the domain by tilting the gravity vector, really. However, to ""properly"" tilt the domain I'd need to tilt Coriolis too. In this case I'd need a x-component to `f`, which isn't available through `FPlane` or `NonTraditionalFPlane`. Thus, with this addition I'd be able to write something like. ```julia; const _rad = 0.2 # radians; const g = (sin(_rad), 0, cos(_rad)) # domain tilt. buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=g) # Tilt gravity vector; coriolis = GeneralFPlane(coriolis_frequency=1e-4, rotation_axes=g) # Tilt rotation vector; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886257814
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886258285:113,Integrability,depend,depends,113,"> I can imagine that maybe you would want a general fplane and general nontraditional fplane as well. I guess it depends on the physical set up. I'm actually not sure. All that `NonTraditionalFPlane` does is to tilt the rotation axis of an f-plane based on latitude. So it just projects some component of `f` onto the `y` direction. `GeneralFPlane` (or whatever we end up calling it) can tilt the rotation axis in any arbitrary direction, so it can already do what `NonTraditionalFPlane` does (and more). So really (imho) I don't see much use for `NonTraditionalFPlane` after this gets implemented, except maybe as a convenience function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886258285
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886716989:115,Integrability,depend,depends,115,"> > I can imagine that maybe you would want a general fplane and general nontraditional fplane as well. I guess it depends on the physical set up.; > ; > I'm actually not sure. All that `NonTraditionalFPlane` does is to tilt the rotation axis of an f-plane based on latitude. So it just projects some component of `f` onto the `y` direction. `GeneralFPlane` (or whatever we end up calling it) can tilt the rotation axis in any arbitrary direction, so it can already do what `NonTraditionalFPlane` does (and more). So really (imho) I don't see much use for `NonTraditionalFPlane` after this gets implemented, except maybe as a convenience function. This should definitely replace `NonTraditionalFPlane`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886716989
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887056354:188,Integrability,interface,interface,188,"As of right now, as far as I can tell, `GeneralFPlane` is working and `NonTraditionalFPlane` got dumped. I'd like to get some feedback before I start changing the docs if that's okay. The interface I implemented is a bit simpler than `NonTraditionalFPlane` but I think that's okay. I'd like some feedback there if possible. Arguments now are:. - `coriolis_frequency` (instead of simply `f`). Defaults to `2`; - `rotation_axis` (defaults to `ZDirection`); - `latitude` for convenience (which overwrites `rotation_axis`). I'm a bit unsure if I should keep this one. Maybe we should keep it simple since anyone can figure out `f` based on latitude easily. Questions:. - Should we keep the original `FPlane`? I think we could scrap it and only keep this one (which would then be renamed `FPlane`); - I didn't see any tests that `FPlane` or any other Coriolis implementation is dynamically correct. Should we implement a test to see if our rotation implementations are actually doing what they're supposed to?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887056354
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887056354:814,Testability,test,tests,814,"As of right now, as far as I can tell, `GeneralFPlane` is working and `NonTraditionalFPlane` got dumped. I'd like to get some feedback before I start changing the docs if that's okay. The interface I implemented is a bit simpler than `NonTraditionalFPlane` but I think that's okay. I'd like some feedback there if possible. Arguments now are:. - `coriolis_frequency` (instead of simply `f`). Defaults to `2`; - `rotation_axis` (defaults to `ZDirection`); - `latitude` for convenience (which overwrites `rotation_axis`). I'm a bit unsure if I should keep this one. Maybe we should keep it simple since anyone can figure out `f` based on latitude easily. Questions:. - Should we keep the original `FPlane`? I think we could scrap it and only keep this one (which would then be renamed `FPlane`); - I didn't see any tests that `FPlane` or any other Coriolis implementation is dynamically correct. Should we implement a test to see if our rotation implementations are actually doing what they're supposed to?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887056354
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887056354:917,Testability,test,test,917,"As of right now, as far as I can tell, `GeneralFPlane` is working and `NonTraditionalFPlane` got dumped. I'd like to get some feedback before I start changing the docs if that's okay. The interface I implemented is a bit simpler than `NonTraditionalFPlane` but I think that's okay. I'd like some feedback there if possible. Arguments now are:. - `coriolis_frequency` (instead of simply `f`). Defaults to `2`; - `rotation_axis` (defaults to `ZDirection`); - `latitude` for convenience (which overwrites `rotation_axis`). I'm a bit unsure if I should keep this one. Maybe we should keep it simple since anyone can figure out `f` based on latitude easily. Questions:. - Should we keep the original `FPlane`? I think we could scrap it and only keep this one (which would then be renamed `FPlane`); - I didn't see any tests that `FPlane` or any other Coriolis implementation is dynamically correct. Should we implement a test to see if our rotation implementations are actually doing what they're supposed to?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887056354
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887056354:126,Usability,feedback,feedback,126,"As of right now, as far as I can tell, `GeneralFPlane` is working and `NonTraditionalFPlane` got dumped. I'd like to get some feedback before I start changing the docs if that's okay. The interface I implemented is a bit simpler than `NonTraditionalFPlane` but I think that's okay. I'd like some feedback there if possible. Arguments now are:. - `coriolis_frequency` (instead of simply `f`). Defaults to `2`; - `rotation_axis` (defaults to `ZDirection`); - `latitude` for convenience (which overwrites `rotation_axis`). I'm a bit unsure if I should keep this one. Maybe we should keep it simple since anyone can figure out `f` based on latitude easily. Questions:. - Should we keep the original `FPlane`? I think we could scrap it and only keep this one (which would then be renamed `FPlane`); - I didn't see any tests that `FPlane` or any other Coriolis implementation is dynamically correct. Should we implement a test to see if our rotation implementations are actually doing what they're supposed to?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887056354
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887056354:221,Usability,simpl,simpler,221,"As of right now, as far as I can tell, `GeneralFPlane` is working and `NonTraditionalFPlane` got dumped. I'd like to get some feedback before I start changing the docs if that's okay. The interface I implemented is a bit simpler than `NonTraditionalFPlane` but I think that's okay. I'd like some feedback there if possible. Arguments now are:. - `coriolis_frequency` (instead of simply `f`). Defaults to `2`; - `rotation_axis` (defaults to `ZDirection`); - `latitude` for convenience (which overwrites `rotation_axis`). I'm a bit unsure if I should keep this one. Maybe we should keep it simple since anyone can figure out `f` based on latitude easily. Questions:. - Should we keep the original `FPlane`? I think we could scrap it and only keep this one (which would then be renamed `FPlane`); - I didn't see any tests that `FPlane` or any other Coriolis implementation is dynamically correct. Should we implement a test to see if our rotation implementations are actually doing what they're supposed to?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887056354
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887056354:296,Usability,feedback,feedback,296,"As of right now, as far as I can tell, `GeneralFPlane` is working and `NonTraditionalFPlane` got dumped. I'd like to get some feedback before I start changing the docs if that's okay. The interface I implemented is a bit simpler than `NonTraditionalFPlane` but I think that's okay. I'd like some feedback there if possible. Arguments now are:. - `coriolis_frequency` (instead of simply `f`). Defaults to `2`; - `rotation_axis` (defaults to `ZDirection`); - `latitude` for convenience (which overwrites `rotation_axis`). I'm a bit unsure if I should keep this one. Maybe we should keep it simple since anyone can figure out `f` based on latitude easily. Questions:. - Should we keep the original `FPlane`? I think we could scrap it and only keep this one (which would then be renamed `FPlane`); - I didn't see any tests that `FPlane` or any other Coriolis implementation is dynamically correct. Should we implement a test to see if our rotation implementations are actually doing what they're supposed to?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887056354
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887056354:379,Usability,simpl,simply,379,"As of right now, as far as I can tell, `GeneralFPlane` is working and `NonTraditionalFPlane` got dumped. I'd like to get some feedback before I start changing the docs if that's okay. The interface I implemented is a bit simpler than `NonTraditionalFPlane` but I think that's okay. I'd like some feedback there if possible. Arguments now are:. - `coriolis_frequency` (instead of simply `f`). Defaults to `2`; - `rotation_axis` (defaults to `ZDirection`); - `latitude` for convenience (which overwrites `rotation_axis`). I'm a bit unsure if I should keep this one. Maybe we should keep it simple since anyone can figure out `f` based on latitude easily. Questions:. - Should we keep the original `FPlane`? I think we could scrap it and only keep this one (which would then be renamed `FPlane`); - I didn't see any tests that `FPlane` or any other Coriolis implementation is dynamically correct. Should we implement a test to see if our rotation implementations are actually doing what they're supposed to?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887056354
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887056354:589,Usability,simpl,simple,589,"As of right now, as far as I can tell, `GeneralFPlane` is working and `NonTraditionalFPlane` got dumped. I'd like to get some feedback before I start changing the docs if that's okay. The interface I implemented is a bit simpler than `NonTraditionalFPlane` but I think that's okay. I'd like some feedback there if possible. Arguments now are:. - `coriolis_frequency` (instead of simply `f`). Defaults to `2`; - `rotation_axis` (defaults to `ZDirection`); - `latitude` for convenience (which overwrites `rotation_axis`). I'm a bit unsure if I should keep this one. Maybe we should keep it simple since anyone can figure out `f` based on latitude easily. Questions:. - Should we keep the original `FPlane`? I think we could scrap it and only keep this one (which would then be renamed `FPlane`); - I didn't see any tests that `FPlane` or any other Coriolis implementation is dynamically correct. Should we implement a test to see if our rotation implementations are actually doing what they're supposed to?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887056354
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887460578:388,Security,validat,validate,388,"Thoughts on your questions:. - I can imagine some people would prefer to type `FPlane` instead fo `GeneralFPlane`. Maybe we could keep the name of the former but get it to call the latter? Bascially keep the name but none of the code, as having fewer functions seems like a good idea.; - We could look at a propagating internal wave and measure it's phase speed. That would be one way to validate the Corioilis parameter, but maybe more complicated than other examples.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887460578
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887512348:335,Usability,feedback,feedback,335,"> > Closes #1372; > > For now I just wanted to save up the calculations. Once we decide how to implement the feature I'll finish the PR.; > ; > I've been asked to review --- is this still the state of this PR?. No it's not. Thanks, I forgot to change that. . It's now ready for review with the caveat that I'd like to wait until I get feedback on how it's working to change the docs if that's okay, as per [this comment](https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887056354). I just wanna make sure you're all okay with the changes in functionality. But lmk if that's not okay and I'll change the docs too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887512348
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887527990:197,Integrability,interface,interface,197,"> As of right now, as far as I can tell, `GeneralFPlane` is working and `NonTraditionalFPlane` got dumped. I'd like to get some feedback before I start changing the docs if that's okay.; > ; > The interface I implemented is a bit simpler than `NonTraditionalFPlane` but I think that's okay. I'd like some feedback there if possible. Arguments now are:; > ; > * `coriolis_frequency` (instead of simply `f`). Defaults to `2`; > * `rotation_axis` (defaults to `ZDirection`); > * `latitude` for convenience (which overwrites `rotation_axis`). I'm a bit unsure if I should keep this one. Maybe we should keep it simple since anyone can figure out `f` based on latitude easily.; > ; > Questions:; > ; > * Should we keep the original `FPlane`? I think we could scrap it and only keep this one (which would then be renamed `FPlane`); > * I didn't see any tests that `FPlane` or any other Coriolis implementation is dynamically correct. Should we implement a test to see if our rotation implementations are actually doing what they're supposed to?. For API this is what I suggest:. Three ""modes"":. 1. A ""primitive"" mode whereby fx, fy, fz are all explicitly provided.; 2. A ""general rotation"" mode whereby `rotation_axis` and `rotation_rate` are provided. `fx`, `fy`, and `fz` are then calculated as a convenience.; 3. A ""tangent plane"" mode whereby `latitude` and `rotation_rate` are provided. This mode calculates `rotation_axis` based on `latitude` (and assuming that `y` is north-south). The code might look something like. ```julia; zero_if_nothing(f) = f; zero_if_nothing(::Nothing) = 0. function ConstantBackgroundRotation(FT=Float64; fx=nothing, fy=nothing, fz=nothing, rotation_rate=_Earth, rotation_axis=nothing, latitude=nothing). if latitude !=nothing; isnothing(rotation_axis) && throw(ArgumentError(""Cannot specify latitude and rotation axis."")); all(isnothing.((fx, fy, fz)) || throw(ArgumentError(""Cannot specify latitude and (fx, fy, fz)."")); # calculate rotation axis; end. if rotation_axis",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887527990
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887527990:2335,Performance,optimiz,optimization,2335," based on latitude easily.; > ; > Questions:; > ; > * Should we keep the original `FPlane`? I think we could scrap it and only keep this one (which would then be renamed `FPlane`); > * I didn't see any tests that `FPlane` or any other Coriolis implementation is dynamically correct. Should we implement a test to see if our rotation implementations are actually doing what they're supposed to?. For API this is what I suggest:. Three ""modes"":. 1. A ""primitive"" mode whereby fx, fy, fz are all explicitly provided.; 2. A ""general rotation"" mode whereby `rotation_axis` and `rotation_rate` are provided. `fx`, `fy`, and `fz` are then calculated as a convenience.; 3. A ""tangent plane"" mode whereby `latitude` and `rotation_rate` are provided. This mode calculates `rotation_axis` based on `latitude` (and assuming that `y` is north-south). The code might look something like. ```julia; zero_if_nothing(f) = f; zero_if_nothing(::Nothing) = 0. function ConstantBackgroundRotation(FT=Float64; fx=nothing, fy=nothing, fz=nothing, rotation_rate=_Earth, rotation_axis=nothing, latitude=nothing). if latitude !=nothing; isnothing(rotation_axis) && throw(ArgumentError(""Cannot specify latitude and rotation axis."")); all(isnothing.((fx, fy, fz)) || throw(ArgumentError(""Cannot specify latitude and (fx, fy, fz)."")); # calculate rotation axis; end. if rotation_axis != nothing; all(isnothing.((fx, fy, fz)) || throw(ArgumentError(""Cannot specify rotation_axis and (fx, fy, fz)."")); # calculate fx, fy, fz; end. fx, fy, fz = zero_if_nothing.((fx, fy, fz)) # set default fx, fy, fz. return ConstantBackgroundRotation(FT(fx), FT(fy), FT(fz)); end; ```. There's also the possibility of a somewhat minor optimization by keeping the possibility that `fx, fy, fz` might be `nothing`, and eliding the associated Coriolis operations in kernel functions for that case. This requires the struct to accomodate different types for each of them. I think `GeneralFPlane` is ambiguous, so I propose using a more specific name.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887527990
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887527990:848,Testability,test,tests,848,"> As of right now, as far as I can tell, `GeneralFPlane` is working and `NonTraditionalFPlane` got dumped. I'd like to get some feedback before I start changing the docs if that's okay.; > ; > The interface I implemented is a bit simpler than `NonTraditionalFPlane` but I think that's okay. I'd like some feedback there if possible. Arguments now are:; > ; > * `coriolis_frequency` (instead of simply `f`). Defaults to `2`; > * `rotation_axis` (defaults to `ZDirection`); > * `latitude` for convenience (which overwrites `rotation_axis`). I'm a bit unsure if I should keep this one. Maybe we should keep it simple since anyone can figure out `f` based on latitude easily.; > ; > Questions:; > ; > * Should we keep the original `FPlane`? I think we could scrap it and only keep this one (which would then be renamed `FPlane`); > * I didn't see any tests that `FPlane` or any other Coriolis implementation is dynamically correct. Should we implement a test to see if our rotation implementations are actually doing what they're supposed to?. For API this is what I suggest:. Three ""modes"":. 1. A ""primitive"" mode whereby fx, fy, fz are all explicitly provided.; 2. A ""general rotation"" mode whereby `rotation_axis` and `rotation_rate` are provided. `fx`, `fy`, and `fz` are then calculated as a convenience.; 3. A ""tangent plane"" mode whereby `latitude` and `rotation_rate` are provided. This mode calculates `rotation_axis` based on `latitude` (and assuming that `y` is north-south). The code might look something like. ```julia; zero_if_nothing(f) = f; zero_if_nothing(::Nothing) = 0. function ConstantBackgroundRotation(FT=Float64; fx=nothing, fy=nothing, fz=nothing, rotation_rate=_Earth, rotation_axis=nothing, latitude=nothing). if latitude !=nothing; isnothing(rotation_axis) && throw(ArgumentError(""Cannot specify latitude and rotation axis."")); all(isnothing.((fx, fy, fz)) || throw(ArgumentError(""Cannot specify latitude and (fx, fy, fz)."")); # calculate rotation axis; end. if rotation_axis",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887527990
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887527990:951,Testability,test,test,951,"> As of right now, as far as I can tell, `GeneralFPlane` is working and `NonTraditionalFPlane` got dumped. I'd like to get some feedback before I start changing the docs if that's okay.; > ; > The interface I implemented is a bit simpler than `NonTraditionalFPlane` but I think that's okay. I'd like some feedback there if possible. Arguments now are:; > ; > * `coriolis_frequency` (instead of simply `f`). Defaults to `2`; > * `rotation_axis` (defaults to `ZDirection`); > * `latitude` for convenience (which overwrites `rotation_axis`). I'm a bit unsure if I should keep this one. Maybe we should keep it simple since anyone can figure out `f` based on latitude easily.; > ; > Questions:; > ; > * Should we keep the original `FPlane`? I think we could scrap it and only keep this one (which would then be renamed `FPlane`); > * I didn't see any tests that `FPlane` or any other Coriolis implementation is dynamically correct. Should we implement a test to see if our rotation implementations are actually doing what they're supposed to?. For API this is what I suggest:. Three ""modes"":. 1. A ""primitive"" mode whereby fx, fy, fz are all explicitly provided.; 2. A ""general rotation"" mode whereby `rotation_axis` and `rotation_rate` are provided. `fx`, `fy`, and `fz` are then calculated as a convenience.; 3. A ""tangent plane"" mode whereby `latitude` and `rotation_rate` are provided. This mode calculates `rotation_axis` based on `latitude` (and assuming that `y` is north-south). The code might look something like. ```julia; zero_if_nothing(f) = f; zero_if_nothing(::Nothing) = 0. function ConstantBackgroundRotation(FT=Float64; fx=nothing, fy=nothing, fz=nothing, rotation_rate=_Earth, rotation_axis=nothing, latitude=nothing). if latitude !=nothing; isnothing(rotation_axis) && throw(ArgumentError(""Cannot specify latitude and rotation axis."")); all(isnothing.((fx, fy, fz)) || throw(ArgumentError(""Cannot specify latitude and (fx, fy, fz)."")); # calculate rotation axis; end. if rotation_axis",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887527990
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887527990:128,Usability,feedback,feedback,128,"> As of right now, as far as I can tell, `GeneralFPlane` is working and `NonTraditionalFPlane` got dumped. I'd like to get some feedback before I start changing the docs if that's okay.; > ; > The interface I implemented is a bit simpler than `NonTraditionalFPlane` but I think that's okay. I'd like some feedback there if possible. Arguments now are:; > ; > * `coriolis_frequency` (instead of simply `f`). Defaults to `2`; > * `rotation_axis` (defaults to `ZDirection`); > * `latitude` for convenience (which overwrites `rotation_axis`). I'm a bit unsure if I should keep this one. Maybe we should keep it simple since anyone can figure out `f` based on latitude easily.; > ; > Questions:; > ; > * Should we keep the original `FPlane`? I think we could scrap it and only keep this one (which would then be renamed `FPlane`); > * I didn't see any tests that `FPlane` or any other Coriolis implementation is dynamically correct. Should we implement a test to see if our rotation implementations are actually doing what they're supposed to?. For API this is what I suggest:. Three ""modes"":. 1. A ""primitive"" mode whereby fx, fy, fz are all explicitly provided.; 2. A ""general rotation"" mode whereby `rotation_axis` and `rotation_rate` are provided. `fx`, `fy`, and `fz` are then calculated as a convenience.; 3. A ""tangent plane"" mode whereby `latitude` and `rotation_rate` are provided. This mode calculates `rotation_axis` based on `latitude` (and assuming that `y` is north-south). The code might look something like. ```julia; zero_if_nothing(f) = f; zero_if_nothing(::Nothing) = 0. function ConstantBackgroundRotation(FT=Float64; fx=nothing, fy=nothing, fz=nothing, rotation_rate=_Earth, rotation_axis=nothing, latitude=nothing). if latitude !=nothing; isnothing(rotation_axis) && throw(ArgumentError(""Cannot specify latitude and rotation axis."")); all(isnothing.((fx, fy, fz)) || throw(ArgumentError(""Cannot specify latitude and (fx, fy, fz)."")); # calculate rotation axis; end. if rotation_axis",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887527990
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887527990:230,Usability,simpl,simpler,230,"> As of right now, as far as I can tell, `GeneralFPlane` is working and `NonTraditionalFPlane` got dumped. I'd like to get some feedback before I start changing the docs if that's okay.; > ; > The interface I implemented is a bit simpler than `NonTraditionalFPlane` but I think that's okay. I'd like some feedback there if possible. Arguments now are:; > ; > * `coriolis_frequency` (instead of simply `f`). Defaults to `2`; > * `rotation_axis` (defaults to `ZDirection`); > * `latitude` for convenience (which overwrites `rotation_axis`). I'm a bit unsure if I should keep this one. Maybe we should keep it simple since anyone can figure out `f` based on latitude easily.; > ; > Questions:; > ; > * Should we keep the original `FPlane`? I think we could scrap it and only keep this one (which would then be renamed `FPlane`); > * I didn't see any tests that `FPlane` or any other Coriolis implementation is dynamically correct. Should we implement a test to see if our rotation implementations are actually doing what they're supposed to?. For API this is what I suggest:. Three ""modes"":. 1. A ""primitive"" mode whereby fx, fy, fz are all explicitly provided.; 2. A ""general rotation"" mode whereby `rotation_axis` and `rotation_rate` are provided. `fx`, `fy`, and `fz` are then calculated as a convenience.; 3. A ""tangent plane"" mode whereby `latitude` and `rotation_rate` are provided. This mode calculates `rotation_axis` based on `latitude` (and assuming that `y` is north-south). The code might look something like. ```julia; zero_if_nothing(f) = f; zero_if_nothing(::Nothing) = 0. function ConstantBackgroundRotation(FT=Float64; fx=nothing, fy=nothing, fz=nothing, rotation_rate=_Earth, rotation_axis=nothing, latitude=nothing). if latitude !=nothing; isnothing(rotation_axis) && throw(ArgumentError(""Cannot specify latitude and rotation axis."")); all(isnothing.((fx, fy, fz)) || throw(ArgumentError(""Cannot specify latitude and (fx, fy, fz)."")); # calculate rotation axis; end. if rotation_axis",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887527990
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887527990:305,Usability,feedback,feedback,305,"> As of right now, as far as I can tell, `GeneralFPlane` is working and `NonTraditionalFPlane` got dumped. I'd like to get some feedback before I start changing the docs if that's okay.; > ; > The interface I implemented is a bit simpler than `NonTraditionalFPlane` but I think that's okay. I'd like some feedback there if possible. Arguments now are:; > ; > * `coriolis_frequency` (instead of simply `f`). Defaults to `2`; > * `rotation_axis` (defaults to `ZDirection`); > * `latitude` for convenience (which overwrites `rotation_axis`). I'm a bit unsure if I should keep this one. Maybe we should keep it simple since anyone can figure out `f` based on latitude easily.; > ; > Questions:; > ; > * Should we keep the original `FPlane`? I think we could scrap it and only keep this one (which would then be renamed `FPlane`); > * I didn't see any tests that `FPlane` or any other Coriolis implementation is dynamically correct. Should we implement a test to see if our rotation implementations are actually doing what they're supposed to?. For API this is what I suggest:. Three ""modes"":. 1. A ""primitive"" mode whereby fx, fy, fz are all explicitly provided.; 2. A ""general rotation"" mode whereby `rotation_axis` and `rotation_rate` are provided. `fx`, `fy`, and `fz` are then calculated as a convenience.; 3. A ""tangent plane"" mode whereby `latitude` and `rotation_rate` are provided. This mode calculates `rotation_axis` based on `latitude` (and assuming that `y` is north-south). The code might look something like. ```julia; zero_if_nothing(f) = f; zero_if_nothing(::Nothing) = 0. function ConstantBackgroundRotation(FT=Float64; fx=nothing, fy=nothing, fz=nothing, rotation_rate=_Earth, rotation_axis=nothing, latitude=nothing). if latitude !=nothing; isnothing(rotation_axis) && throw(ArgumentError(""Cannot specify latitude and rotation axis."")); all(isnothing.((fx, fy, fz)) || throw(ArgumentError(""Cannot specify latitude and (fx, fy, fz)."")); # calculate rotation axis; end. if rotation_axis",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887527990
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887527990:394,Usability,simpl,simply,394,"> As of right now, as far as I can tell, `GeneralFPlane` is working and `NonTraditionalFPlane` got dumped. I'd like to get some feedback before I start changing the docs if that's okay.; > ; > The interface I implemented is a bit simpler than `NonTraditionalFPlane` but I think that's okay. I'd like some feedback there if possible. Arguments now are:; > ; > * `coriolis_frequency` (instead of simply `f`). Defaults to `2`; > * `rotation_axis` (defaults to `ZDirection`); > * `latitude` for convenience (which overwrites `rotation_axis`). I'm a bit unsure if I should keep this one. Maybe we should keep it simple since anyone can figure out `f` based on latitude easily.; > ; > Questions:; > ; > * Should we keep the original `FPlane`? I think we could scrap it and only keep this one (which would then be renamed `FPlane`); > * I didn't see any tests that `FPlane` or any other Coriolis implementation is dynamically correct. Should we implement a test to see if our rotation implementations are actually doing what they're supposed to?. For API this is what I suggest:. Three ""modes"":. 1. A ""primitive"" mode whereby fx, fy, fz are all explicitly provided.; 2. A ""general rotation"" mode whereby `rotation_axis` and `rotation_rate` are provided. `fx`, `fy`, and `fz` are then calculated as a convenience.; 3. A ""tangent plane"" mode whereby `latitude` and `rotation_rate` are provided. This mode calculates `rotation_axis` based on `latitude` (and assuming that `y` is north-south). The code might look something like. ```julia; zero_if_nothing(f) = f; zero_if_nothing(::Nothing) = 0. function ConstantBackgroundRotation(FT=Float64; fx=nothing, fy=nothing, fz=nothing, rotation_rate=_Earth, rotation_axis=nothing, latitude=nothing). if latitude !=nothing; isnothing(rotation_axis) && throw(ArgumentError(""Cannot specify latitude and rotation axis."")); all(isnothing.((fx, fy, fz)) || throw(ArgumentError(""Cannot specify latitude and (fx, fy, fz)."")); # calculate rotation axis; end. if rotation_axis",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887527990
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887527990:608,Usability,simpl,simple,608,"> As of right now, as far as I can tell, `GeneralFPlane` is working and `NonTraditionalFPlane` got dumped. I'd like to get some feedback before I start changing the docs if that's okay.; > ; > The interface I implemented is a bit simpler than `NonTraditionalFPlane` but I think that's okay. I'd like some feedback there if possible. Arguments now are:; > ; > * `coriolis_frequency` (instead of simply `f`). Defaults to `2`; > * `rotation_axis` (defaults to `ZDirection`); > * `latitude` for convenience (which overwrites `rotation_axis`). I'm a bit unsure if I should keep this one. Maybe we should keep it simple since anyone can figure out `f` based on latitude easily.; > ; > Questions:; > ; > * Should we keep the original `FPlane`? I think we could scrap it and only keep this one (which would then be renamed `FPlane`); > * I didn't see any tests that `FPlane` or any other Coriolis implementation is dynamically correct. Should we implement a test to see if our rotation implementations are actually doing what they're supposed to?. For API this is what I suggest:. Three ""modes"":. 1. A ""primitive"" mode whereby fx, fy, fz are all explicitly provided.; 2. A ""general rotation"" mode whereby `rotation_axis` and `rotation_rate` are provided. `fx`, `fy`, and `fz` are then calculated as a convenience.; 3. A ""tangent plane"" mode whereby `latitude` and `rotation_rate` are provided. This mode calculates `rotation_axis` based on `latitude` (and assuming that `y` is north-south). The code might look something like. ```julia; zero_if_nothing(f) = f; zero_if_nothing(::Nothing) = 0. function ConstantBackgroundRotation(FT=Float64; fx=nothing, fy=nothing, fz=nothing, rotation_rate=_Earth, rotation_axis=nothing, latitude=nothing). if latitude !=nothing; isnothing(rotation_axis) && throw(ArgumentError(""Cannot specify latitude and rotation axis."")); all(isnothing.((fx, fy, fz)) || throw(ArgumentError(""Cannot specify latitude and (fx, fy, fz)."")); # calculate rotation axis; end. if rotation_axis",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887527990
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887537661:661,Usability,simpl,simplified,661,"> For API this is what I suggest:; > ; > Three ""modes"":; > ; > 1. A ""primitive"" mode whereby fx, fy, fz are all explicitly provided.; > 2. A ""general rotation"" mode whereby `rotation_axis` and `rotation_rate` are provided. `fx`, `fy`, and `fz` are then calculated as a convenience.; > 3. A ""tangent plane"" mode whereby `latitude` and `rotation_rate` are provided. This mode calculates `rotation_axis` based on `latitude` (and assuming that `y` is north-south). Thanks for the suggestion. That was kind of the API for `NonTradFPlane`. I actually think three modes is kinda overkill and it makes the constructor function unnecessarily complicated (which is why I simplified it this time), especially since it's really not hard to calculate one mode from another one. I'd suggest keeping two of them as a compromise: ""general rotation"" (to match the API in `Buoyancy`) and ""tangent plane"". What do you think?. > I think `GeneralFPlane` is ambiguous, so I propose using a more specific name. I completely agree. I used `GeneralFPlane` more as placeholder. But as you pointed out in #1372, `ConstantBackgroundRotation` is also kinda ambiguous since every rotation we have is technically a constant background rotation at its core. How about get descriptive and call it `ArbitraryAxisFPlane`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887537661
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887606452:676,Usability,simpl,simplified,676,"> > For API this is what I suggest:; > > Three ""modes"":; > > ; > > 1. A ""primitive"" mode whereby fx, fy, fz are all explicitly provided.; > > 2. A ""general rotation"" mode whereby `rotation_axis` and `rotation_rate` are provided. `fx`, `fy`, and `fz` are then calculated as a convenience.; > > 3. A ""tangent plane"" mode whereby `latitude` and `rotation_rate` are provided. This mode calculates `rotation_axis` based on `latitude` (and assuming that `y` is north-south).; > ; > Thanks for the suggestion. That was kind of the API for `NonTradFPlane`. I actually think three modes is kinda overkill and it makes the constructor function unnecessarily complicated (which is why I simplified it this time), especially since it's really not hard to calculate one mode from another one. I'd suggest keeping two of them as a compromise: ""general rotation"" (to match the API in `Buoyancy`) and ""tangent plane"". What do you think?; > ; > > I think `GeneralFPlane` is ambiguous, so I propose using a more specific name.; > ; > I completely agree. I used `GeneralFPlane` more as placeholder. But as you pointed out in #1372, `ConstantBackgroundRotation` is also kinda ambiguous since every rotation we have is technically a constant background rotation at its core. How about get descriptive and call it `ArbitraryAxisFPlane`?. I made my suggestion because I disagree that supporting those keyword arguments is overkill. I am arguing that the complexity of the constructor is justified because. 1) not supporting this API moves part of the ""complexity"" from the constructor into user scripts, which is very undesirable in general; 2) having a consistent API with `FPlane` and `BetaPlane` (which both support a `latitude` keyword argument) is important; 3) I think it really is a useful and friendly simplification to abstract the projection of the rotation axis into a plane tangent with a spherical surface (I have personally benefited from this abstraction for setting up examples like the one proposed in #1744",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887606452
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887606452:1787,Usability,simpl,simplification,1787," `y` is north-south).; > ; > Thanks for the suggestion. That was kind of the API for `NonTradFPlane`. I actually think three modes is kinda overkill and it makes the constructor function unnecessarily complicated (which is why I simplified it this time), especially since it's really not hard to calculate one mode from another one. I'd suggest keeping two of them as a compromise: ""general rotation"" (to match the API in `Buoyancy`) and ""tangent plane"". What do you think?; > ; > > I think `GeneralFPlane` is ambiguous, so I propose using a more specific name.; > ; > I completely agree. I used `GeneralFPlane` more as placeholder. But as you pointed out in #1372, `ConstantBackgroundRotation` is also kinda ambiguous since every rotation we have is technically a constant background rotation at its core. How about get descriptive and call it `ArbitraryAxisFPlane`?. I made my suggestion because I disagree that supporting those keyword arguments is overkill. I am arguing that the complexity of the constructor is justified because. 1) not supporting this API moves part of the ""complexity"" from the constructor into user scripts, which is very undesirable in general; 2) having a consistent API with `FPlane` and `BetaPlane` (which both support a `latitude` keyword argument) is important; 3) I think it really is a useful and friendly simplification to abstract the projection of the rotation axis into a plane tangent with a spherical surface (I have personally benefited from this abstraction for setting up examples like the one proposed in #1744, which I feel implies that many other users will also benefit). As for a name, maybe `RectilinearCoriolis`? This contrasts with `BetaPlane`, which is specific to rectilinear grids but isn't a constant background rotation rate, and `HydrostaticSphericalCoriolis`, which is for hydrostatic fluids in spherical shells. `FPlane` overlaps but we can concede this point because it's so common (and perhaps discuss eliminating `FPlane` in a future PR).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887606452
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887626059:483,Usability,simpl,simplification,483,"> I made my suggestion because I disagree that supporting those keyword arguments is overkill. I am arguing that the complexity of the constructor is justified because; > ; > 1. not supporting this API moves part of the ""complexity"" from the constructor into user scripts, which is very undesirable in general; > 2. having a consistent API with `FPlane` and `BetaPlane` (which both support a `latitude` keyword argument) is important; > 3. I think it really is a useful and friendly simplification to abstract the projection of the rotation axis into a plane tangent with a spherical surface (I have personally benefited from this abstraction for setting up examples like the one proposed in [Overturning, eddying channel example following Abernathey et al. 2011#1744](https://github.com/CliMA/Oceananigans.jl/pull/1744), which I feel implies that many other users will also benefit). Fair enough. I was leaning towards simplicity as per our last conversation about simplifying the code to make it easier for development and (mostly) because I think a sine/cosine multiplication doesn't add much complexity on the user side. But it seems I'm voted out so I'll implement those functionalities back :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887626059
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887626059:921,Usability,simpl,simplicity,921,"> I made my suggestion because I disagree that supporting those keyword arguments is overkill. I am arguing that the complexity of the constructor is justified because; > ; > 1. not supporting this API moves part of the ""complexity"" from the constructor into user scripts, which is very undesirable in general; > 2. having a consistent API with `FPlane` and `BetaPlane` (which both support a `latitude` keyword argument) is important; > 3. I think it really is a useful and friendly simplification to abstract the projection of the rotation axis into a plane tangent with a spherical surface (I have personally benefited from this abstraction for setting up examples like the one proposed in [Overturning, eddying channel example following Abernathey et al. 2011#1744](https://github.com/CliMA/Oceananigans.jl/pull/1744), which I feel implies that many other users will also benefit). Fair enough. I was leaning towards simplicity as per our last conversation about simplifying the code to make it easier for development and (mostly) because I think a sine/cosine multiplication doesn't add much complexity on the user side. But it seems I'm voted out so I'll implement those functionalities back :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887626059
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887626059:967,Usability,simpl,simplifying,967,"> I made my suggestion because I disagree that supporting those keyword arguments is overkill. I am arguing that the complexity of the constructor is justified because; > ; > 1. not supporting this API moves part of the ""complexity"" from the constructor into user scripts, which is very undesirable in general; > 2. having a consistent API with `FPlane` and `BetaPlane` (which both support a `latitude` keyword argument) is important; > 3. I think it really is a useful and friendly simplification to abstract the projection of the rotation axis into a plane tangent with a spherical surface (I have personally benefited from this abstraction for setting up examples like the one proposed in [Overturning, eddying channel example following Abernathey et al. 2011#1744](https://github.com/CliMA/Oceananigans.jl/pull/1744), which I feel implies that many other users will also benefit). Fair enough. I was leaning towards simplicity as per our last conversation about simplifying the code to make it easier for development and (mostly) because I think a sine/cosine multiplication doesn't add much complexity on the user side. But it seems I'm voted out so I'll implement those functionalities back :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887626059
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887649059:1959,Usability,clear,clear,1959," > ; > The thing is that `BetaPlane` is also a ""rectilinear Coriolis"" since it's a Coriolis implementation meant for rectilinear grids, no? I'm not very familiar with the implementation of the Coriolis acc in spherical grids, but if I understand correctly you can't use `FPlane` or `BetaPlane` on spherical grids?; > ; > If that's true, maybe we aim for consistency with the rectilinear grids for now and rename things to; > ; > * `RectilinearGridFPlane` (this one); > * `RectilinearGridBetaPlane` (what is now `BetaPlane`); > * Keep `FPlane` for now because, like you said, it's an easy name that's very commonly used; > ; > I do think that it's important to keep ""f-plane"" in the name of this implementation somewhere instead of just ""Coriolis"" because there are different approximations one can make when implementing the Coriolis acc, so it'd help to be specific. The f-plane refers to a tangent plane approximation for a fluid contained in a spherical shell. However, this type is more general than that case (this was also a problem with the undecorated `FPlane` type), and can be used to model any rotating fluid in a rectilinear domain with an arbitrary axis of rotation. Therefore, I argue not using `FPlane` in the name of this type. `BetaPlane` has no meaning outside of rectilinear geometries, therefore I propose not adding the superfluous `RectilinearGrid` in front of `BetaPlane`. As for `Grid` or not, the meaning of `RectilinearGrid` is specific to Oceananigans. However, the term ""rectilinear"" has a distinct meaning apart from ""grids"". Here, I think its clear if the name refers to the coordinate system (rather than the grid or mesh), I think I prefer simply ""RectilinearCoriolis"". Otherwise, we will also need to consider how to devise a similar name for ""HydrostaticSphericalCoriolis"" that somehow references the handful of grid types that we permit for in spherical domains. That said, RectilinearCoriolis is not perfect (its obscure), so I think there is room for improvement.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887649059
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887649059:2058,Usability,simpl,simply,2058," > ; > The thing is that `BetaPlane` is also a ""rectilinear Coriolis"" since it's a Coriolis implementation meant for rectilinear grids, no? I'm not very familiar with the implementation of the Coriolis acc in spherical grids, but if I understand correctly you can't use `FPlane` or `BetaPlane` on spherical grids?; > ; > If that's true, maybe we aim for consistency with the rectilinear grids for now and rename things to; > ; > * `RectilinearGridFPlane` (this one); > * `RectilinearGridBetaPlane` (what is now `BetaPlane`); > * Keep `FPlane` for now because, like you said, it's an easy name that's very commonly used; > ; > I do think that it's important to keep ""f-plane"" in the name of this implementation somewhere instead of just ""Coriolis"" because there are different approximations one can make when implementing the Coriolis acc, so it'd help to be specific. The f-plane refers to a tangent plane approximation for a fluid contained in a spherical shell. However, this type is more general than that case (this was also a problem with the undecorated `FPlane` type), and can be used to model any rotating fluid in a rectilinear domain with an arbitrary axis of rotation. Therefore, I argue not using `FPlane` in the name of this type. `BetaPlane` has no meaning outside of rectilinear geometries, therefore I propose not adding the superfluous `RectilinearGrid` in front of `BetaPlane`. As for `Grid` or not, the meaning of `RectilinearGrid` is specific to Oceananigans. However, the term ""rectilinear"" has a distinct meaning apart from ""grids"". Here, I think its clear if the name refers to the coordinate system (rather than the grid or mesh), I think I prefer simply ""RectilinearCoriolis"". Otherwise, we will also need to consider how to devise a similar name for ""HydrostaticSphericalCoriolis"" that somehow references the handful of grid types that we permit for in spherical domains. That said, RectilinearCoriolis is not perfect (its obscure), so I think there is room for improvement.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887649059
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887679066:555,Usability,simpl,simply,555,"My two cents. Both the f-plane and beta-plane approximations approximate the Coriolis pseudo-force from a spherical coordiante, using latitude \varphi, to a planar geometry using typicallay y and z. Since they are both approximations into a plane (which could be tilted as this PR is trying to do) how about `ConstantPlanarCoriolis` for `f-plane` and `LinearPlanarCoriolis` for `beta-plane`? . In Calculus, these approximations can be thought of as a constant approximation (`f-plane`) or linear approximation (`beta-plane`). Another idea is to call them simply `ConstantCoriolis` and `LinearCoriois`. . I agree that `Grid` is not really relevant since we always use a grid. Also, `Rectilinear` does not seem as descriptive as",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887679066
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887679972:113,Usability,simpl,simple,113,It seemed that @tomchor and I both came up with the idea of `ConstantCoriolis` within a short span of time. It's simple and accurate.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887679972
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887762725:549,Safety,avoid,avoid,549,"> Is it possible to calculate the components `fx, fy, fz` on the fly? Also, can we infer `rotation_axis` from user-specified `fx, fy, fz`? If so, we can have one type for a constant rotation rate (storing just the parameters `rotation_axis` and `rotation_rate`), and use it for both Cartesian / rectilinear and spherical geometries. EDIT: this might be a bad idea if it adds functions like sin / cos to kernels. If we do need to pre-calculate fx, fy, fz, I think we should somehow indicate that this type is specifically Cartesian or rectilinear to avoid confusion with its spherical-geometry counterpart... unfortuntately, because its annoying.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887762725
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887764088:850,Usability,clear,clear,850,"> Is it possible to calculate the components `fx, fy, fz` on the fly? Also, can we infer `rotation_axis` from user-specified `fx, fy, fz`? If so, we can have one type for a constant rotation rate (storing just the parameters `rotation_axis` and `rotation_rate`), and use it for both Cartesian / rectilinear and spherical geometries. We definitely can do those things, I'm just not sure how it'll work with kernels. Unless I'm missing something:. ```julia; fx = 2rotation_rate * rotation_axis[1]; fy = 2rotation_rate * rotation_axis[2]; fz = 2rotation_rate * rotation_axis[3]; ```. and then to get `rotation_axis`:. ```julia; rotation_axis = [fx, fy, fz] ./ (fx^2 + fy^2 + fz^2); ```. This would be kind of a big change though, no? Is it worth doing it in this PR?. Also, we'd need to make the difference between rotation rate and Coriolis frequency clear (meaning `f = 2rotation_rate`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887764088
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887771743:901,Usability,clear,clear,901,"> > Is it possible to calculate the components `fx, fy, fz` on the fly? Also, can we infer `rotation_axis` from user-specified `fx, fy, fz`? If so, we can have one type for a constant rotation rate (storing just the parameters `rotation_axis` and `rotation_rate`), and use it for both Cartesian / rectilinear and spherical geometries.; > ; > We definitely can do those things, I'm just not sure how it'll work with kernels. Unless I'm missing something:; > ; > ```julia; > fx = 2rotation_rate * rotation_axis[1]; > fy = 2rotation_rate * rotation_axis[2]; > fz = 2rotation_rate * rotation_axis[3]; > ```; > ; > and then to get `rotation_axis`:; > ; > ```julia; > rotation_axis = [fx, fy, fz] ./ (fx^2 + fy^2 + fz^2); > ```; > ; > This would be kind of a big change though, no? Is it worth doing it in this PR?; > ; > Also, we'd need to make the difference between rotation rate and Coriolis frequency clear (meaning `f = 2rotation_rate`). Well, that would be just fine for kernels (only change is that we need to use a tuple rather than array, so `(fx, fy, fz)` rather than `[fx, fy, fz]`). But again I think about it a bit more and one annoyance is that we need a version that makes the hydrostatic approximation. *sigh* so maybe we are back to something cumbersome like `ConstantCartesianCoriolis`...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887771743
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887917497:11,Testability,test,tests,11,"If all the tests pass then this PR is ready for its final review. Notes:. - I implemented the 3-input-modes functionality that @glwagner suggested and added tests to make sure it's working properly; - @francispoulin and I independently came up with the name `ConstantCoriolis` so I went with that name for now (as opposed to the a-bit-more-obscure `ConstantCartesianCoriolis`). Let me know if anyone objects and it should be easy to change it to something else.; - Changed the docs accordingly in model_setup/coriolis and physics/coriolis (also fixed a couple of typos), but let me know if there's somewhere else in the docs where this should be changed",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887917497
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887917497:157,Testability,test,tests,157,"If all the tests pass then this PR is ready for its final review. Notes:. - I implemented the 3-input-modes functionality that @glwagner suggested and added tests to make sure it's working properly; - @francispoulin and I independently came up with the name `ConstantCoriolis` so I went with that name for now (as opposed to the a-bit-more-obscure `ConstantCartesianCoriolis`). Let me know if anyone objects and it should be easy to change it to something else.; - Changed the docs accordingly in model_setup/coriolis and physics/coriolis (also fixed a couple of typos), but let me know if there's somewhere else in the docs where this should be changed",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887917497
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888380511:948,Modifiability,refactor,refactoring,948,"> Ah sorry I really do think it would be confusing to users that one has to use HydrostaticSphericalCoriolis on grids that have spherical coordinate systems; and that the ""constant Coriolis"" type only applies to Cartesian coordinate systems :-( don't others agree?. I do agree it's a bit confusing, but IMO it's also obscure to name it `ConstantCartesianCoriolis`. As a user I'm thinking what's a cartesian Coriolis? And I definitely wouldn't make the leap in reasoning that `ConstantCartesianCoriolis` is meant to be used with _rectilinear grids_ (none of those two words appears in the name). Which is I suggested a few posts back to use the (very verbose) `ConstantRectlinearGridCoriolis` or something to that effect. > Sorry this is becoming laborious... if the name is changed to include Cartesian then we can merge this and discuss further in an issue. I'm okay with this. It seems like the background rotation implementation could use a big refactoring, which is kind of outside the scope of this PR anyway.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888380511
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888381697:213,Usability,clear,clear,213,"> We all agree that we need different Coriolis functions for Cartesian and Spherical coordinates. Why do we need different functions or nonhydrostatic (and shallow water I presumme) and hydrostatic?. I'm also not clear, although I'm assuming that it has to do with `w` being treated differently (since `w` appears in the equations for the horizontal rotation components). @glwagner can you clarify?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888381697
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888419861:1078,Energy Efficiency,energy,energy,1078,"> > We all agree that we need different Coriolis functions for Cartesian and Spherical coordinates. Why do we need different functions or nonhydrostatic (and shallow water I presumme) and hydrostatic?; > ; > I'm also not clear, although I'm assuming that it has to do with `w` being treated differently (since `w` appears in the equations for the horizontal rotation components). @glwagner can you clarify?. Yes, when we make the hydrostatic approximation, we assume that the aspect ratio is thin and H/L is small. The hydrostatic assumption specifically refers to the use of this scaling in the vertical momentum equation (reducing it to a diagnostic equation for hydrostatic pressure). This same scaling applied to the Coriolis force leads to the ""traditional"" approximation such that Coriolis terms involving the _vertical_ velocity are neglected from the horizontal momentum equations (likewise, the terms involving the horizontal momentum are neglected from the vertical momentum balance; neglecting these terms must be made consistently for the system to conserve kinetic energy). This thin-aspect-ratio approximation (probably best to avoid implicating ""tradition"" in model formulation...) also needs to be invoked to justify ""f-plane"" and ""beta-plane"" approximations to the Coriolis term when the numerical model is supposed to approximate oceanic motion away from the poles. (The so-called ""non-traditional"" terms --- the projection of the planetary vorticity into horizontal directions --- have been variously found to have a small effect on turbulent boundary layer motions. This is probably because the effect of Coriolis forces is most pronounced at the largest scales, and the effect of the horizontal Coriolis components on large scale vertical motions is suppressed by the presence of an impenetrable surface at the top and bottom.). In Oceananigans, we have to express this notion with a _type_ to avoid adding spurious terms to the horizontal momentum equations that depend on the ve",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888419861
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888419861:1985,Integrability,depend,depend,1985,"that we need different Coriolis functions for Cartesian and Spherical coordinates. Why do we need different functions or nonhydrostatic (and shallow water I presumme) and hydrostatic?; > ; > I'm also not clear, although I'm assuming that it has to do with `w` being treated differently (since `w` appears in the equations for the horizontal rotation components). @glwagner can you clarify?. Yes, when we make the hydrostatic approximation, we assume that the aspect ratio is thin and H/L is small. The hydrostatic assumption specifically refers to the use of this scaling in the vertical momentum equation (reducing it to a diagnostic equation for hydrostatic pressure). This same scaling applied to the Coriolis force leads to the ""traditional"" approximation such that Coriolis terms involving the _vertical_ velocity are neglected from the horizontal momentum equations (likewise, the terms involving the horizontal momentum are neglected from the vertical momentum balance; neglecting these terms must be made consistently for the system to conserve kinetic energy). This thin-aspect-ratio approximation (probably best to avoid implicating ""tradition"" in model formulation...) also needs to be invoked to justify ""f-plane"" and ""beta-plane"" approximations to the Coriolis term when the numerical model is supposed to approximate oceanic motion away from the poles. (The so-called ""non-traditional"" terms --- the projection of the planetary vorticity into horizontal directions --- have been variously found to have a small effect on turbulent boundary layer motions. This is probably because the effect of Coriolis forces is most pronounced at the largest scales, and the effect of the horizontal Coriolis components on large scale vertical motions is suppressed by the presence of an impenetrable surface at the top and bottom.). In Oceananigans, we have to express this notion with a _type_ to avoid adding spurious terms to the horizontal momentum equations that depend on the vertical velocity.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888419861
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888419861:1142,Safety,avoid,avoid,1142,"that we need different Coriolis functions for Cartesian and Spherical coordinates. Why do we need different functions or nonhydrostatic (and shallow water I presumme) and hydrostatic?; > ; > I'm also not clear, although I'm assuming that it has to do with `w` being treated differently (since `w` appears in the equations for the horizontal rotation components). @glwagner can you clarify?. Yes, when we make the hydrostatic approximation, we assume that the aspect ratio is thin and H/L is small. The hydrostatic assumption specifically refers to the use of this scaling in the vertical momentum equation (reducing it to a diagnostic equation for hydrostatic pressure). This same scaling applied to the Coriolis force leads to the ""traditional"" approximation such that Coriolis terms involving the _vertical_ velocity are neglected from the horizontal momentum equations (likewise, the terms involving the horizontal momentum are neglected from the vertical momentum balance; neglecting these terms must be made consistently for the system to conserve kinetic energy). This thin-aspect-ratio approximation (probably best to avoid implicating ""tradition"" in model formulation...) also needs to be invoked to justify ""f-plane"" and ""beta-plane"" approximations to the Coriolis term when the numerical model is supposed to approximate oceanic motion away from the poles. (The so-called ""non-traditional"" terms --- the projection of the planetary vorticity into horizontal directions --- have been variously found to have a small effect on turbulent boundary layer motions. This is probably because the effect of Coriolis forces is most pronounced at the largest scales, and the effect of the horizontal Coriolis components on large scale vertical motions is suppressed by the presence of an impenetrable surface at the top and bottom.). In Oceananigans, we have to express this notion with a _type_ to avoid adding spurious terms to the horizontal momentum equations that depend on the vertical velocity.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888419861
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888419861:1915,Safety,avoid,avoid,1915,"that we need different Coriolis functions for Cartesian and Spherical coordinates. Why do we need different functions or nonhydrostatic (and shallow water I presumme) and hydrostatic?; > ; > I'm also not clear, although I'm assuming that it has to do with `w` being treated differently (since `w` appears in the equations for the horizontal rotation components). @glwagner can you clarify?. Yes, when we make the hydrostatic approximation, we assume that the aspect ratio is thin and H/L is small. The hydrostatic assumption specifically refers to the use of this scaling in the vertical momentum equation (reducing it to a diagnostic equation for hydrostatic pressure). This same scaling applied to the Coriolis force leads to the ""traditional"" approximation such that Coriolis terms involving the _vertical_ velocity are neglected from the horizontal momentum equations (likewise, the terms involving the horizontal momentum are neglected from the vertical momentum balance; neglecting these terms must be made consistently for the system to conserve kinetic energy). This thin-aspect-ratio approximation (probably best to avoid implicating ""tradition"" in model formulation...) also needs to be invoked to justify ""f-plane"" and ""beta-plane"" approximations to the Coriolis term when the numerical model is supposed to approximate oceanic motion away from the poles. (The so-called ""non-traditional"" terms --- the projection of the planetary vorticity into horizontal directions --- have been variously found to have a small effect on turbulent boundary layer motions. This is probably because the effect of Coriolis forces is most pronounced at the largest scales, and the effect of the horizontal Coriolis components on large scale vertical motions is suppressed by the presence of an impenetrable surface at the top and bottom.). In Oceananigans, we have to express this notion with a _type_ to avoid adding spurious terms to the horizontal momentum equations that depend on the vertical velocity.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888419861
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888419861:221,Usability,clear,clear,221,"> > We all agree that we need different Coriolis functions for Cartesian and Spherical coordinates. Why do we need different functions or nonhydrostatic (and shallow water I presumme) and hydrostatic?; > ; > I'm also not clear, although I'm assuming that it has to do with `w` being treated differently (since `w` appears in the equations for the horizontal rotation components). @glwagner can you clarify?. Yes, when we make the hydrostatic approximation, we assume that the aspect ratio is thin and H/L is small. The hydrostatic assumption specifically refers to the use of this scaling in the vertical momentum equation (reducing it to a diagnostic equation for hydrostatic pressure). This same scaling applied to the Coriolis force leads to the ""traditional"" approximation such that Coriolis terms involving the _vertical_ velocity are neglected from the horizontal momentum equations (likewise, the terms involving the horizontal momentum are neglected from the vertical momentum balance; neglecting these terms must be made consistently for the system to conserve kinetic energy). This thin-aspect-ratio approximation (probably best to avoid implicating ""tradition"" in model formulation...) also needs to be invoked to justify ""f-plane"" and ""beta-plane"" approximations to the Coriolis term when the numerical model is supposed to approximate oceanic motion away from the poles. (The so-called ""non-traditional"" terms --- the projection of the planetary vorticity into horizontal directions --- have been variously found to have a small effect on turbulent boundary layer motions. This is probably because the effect of Coriolis forces is most pronounced at the largest scales, and the effect of the horizontal Coriolis components on large scale vertical motions is suppressed by the presence of an impenetrable surface at the top and bottom.). In Oceananigans, we have to express this notion with a _type_ to avoid adding spurious terms to the horizontal momentum equations that depend on the ve",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888419861
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888444391:580,Integrability,depend,depends,580,"> @glwagner : I understand what you are saying about the traditional approximation.; > ; > If we include the non-tradidtional terms, we obtain the Quasi-Hydrostatic model, as discussed in the MITgcm. This is something we can solve in the `HydrostaticModel`, right?; > ; > I'm not suggesting we change the name of the model but I thought we could use this in either model, but maybe there's a problem because of the pressure solve, which might not allow for this?. We could indeed implement such a model; it would not be very difficult. It would mean that the hydrostatic pressure depends on the `coriolis` type. Such a modification to the hydrostatic pressure integral is also needed to introduce surface wave effects via the Craik-Leibovich approximation to a hydrostatic model (this effects can be interpreted as a modification to the background rotation rate of the fluid, with the vertical derivative of the Stokes drift acting as the Coriolis vector).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888444391
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888464586:118,Integrability,depend,depends,118,"> We could indeed implement such a model; it would not be very difficult. It would mean that the hydrostatic pressure depends on the `coriolis` type.; > ; > Such a modification to the hydrostatic pressure integral is also needed to introduce surface wave effects via the Craik-Leibovich approximation to a hydrostatic model (this effects can be interpreted as a modification to the background rotation rate of the fluid, with the vertical derivative of the Stokes drift acting as the Coriolis vector). Okay, so a longer term plan. For the moment we need that `HydrostaticModel` uses traditional f- or beta-plane, or something that does the same thing. It is `NonhydrostaticModel` that will allow for more types of coriolis terms. Understood.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888464586
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888491064:120,Integrability,depend,depends,120,"> > We could indeed implement such a model; it would not be very difficult. It would mean that the hydrostatic pressure depends on the `coriolis` type.; > > Such a modification to the hydrostatic pressure integral is also needed to introduce surface wave effects via the Craik-Leibovich approximation to a hydrostatic model (this effects can be interpreted as a modification to the background rotation rate of the fluid, with the vertical derivative of the Stokes drift acting as the Coriolis vector).; > ; > Okay, so a longer term plan.; > ; > For the moment we need that `HydrostaticModel` uses traditional f- or beta-plane, or something that does the same thing. It is `NonhydrostaticModel` that will allow for more types of coriolis terms. Understood. Note too that the problem is really specific to a spherical geometry. In a rectangular geometry, a thin aspect ratio approximation is mathematically equivalent to a change in the axis of rotation. In a spherical geometry this is no longer possible and we need to explicitly state that we are making a hydrostatic approximation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888491064
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888495033:376,Availability,toler,tolerance,376,"Added some dynamics tests for Coriolis with this last commit. It two a 0-D case for half an inertial period with a rotation about the `z` axis and `x` axis and then compares both to make sure they produce the same result (but rotated). There's one part that tests if the total velocity magnitude is approximately unchanged (magnitude=1), which relies on an implicit arbitrary tolerance which might be bad. I'd curious about your feedback on that one. > if the name is changed to include Cartesian then we can merge this and discuss further in an issue. Per the comment above I'm going to change the name to `ConstantCartesianCoriolis` and (provided the tests all pass and you're okay with my new test addition) I'll proceed to merge this into master and open an issue to further discuss the issues that emerged here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888495033
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888495033:20,Testability,test,tests,20,"Added some dynamics tests for Coriolis with this last commit. It two a 0-D case for half an inertial period with a rotation about the `z` axis and `x` axis and then compares both to make sure they produce the same result (but rotated). There's one part that tests if the total velocity magnitude is approximately unchanged (magnitude=1), which relies on an implicit arbitrary tolerance which might be bad. I'd curious about your feedback on that one. > if the name is changed to include Cartesian then we can merge this and discuss further in an issue. Per the comment above I'm going to change the name to `ConstantCartesianCoriolis` and (provided the tests all pass and you're okay with my new test addition) I'll proceed to merge this into master and open an issue to further discuss the issues that emerged here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888495033
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888495033:258,Testability,test,tests,258,"Added some dynamics tests for Coriolis with this last commit. It two a 0-D case for half an inertial period with a rotation about the `z` axis and `x` axis and then compares both to make sure they produce the same result (but rotated). There's one part that tests if the total velocity magnitude is approximately unchanged (magnitude=1), which relies on an implicit arbitrary tolerance which might be bad. I'd curious about your feedback on that one. > if the name is changed to include Cartesian then we can merge this and discuss further in an issue. Per the comment above I'm going to change the name to `ConstantCartesianCoriolis` and (provided the tests all pass and you're okay with my new test addition) I'll proceed to merge this into master and open an issue to further discuss the issues that emerged here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888495033
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888495033:653,Testability,test,tests,653,"Added some dynamics tests for Coriolis with this last commit. It two a 0-D case for half an inertial period with a rotation about the `z` axis and `x` axis and then compares both to make sure they produce the same result (but rotated). There's one part that tests if the total velocity magnitude is approximately unchanged (magnitude=1), which relies on an implicit arbitrary tolerance which might be bad. I'd curious about your feedback on that one. > if the name is changed to include Cartesian then we can merge this and discuss further in an issue. Per the comment above I'm going to change the name to `ConstantCartesianCoriolis` and (provided the tests all pass and you're okay with my new test addition) I'll proceed to merge this into master and open an issue to further discuss the issues that emerged here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888495033
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888495033:696,Testability,test,test,696,"Added some dynamics tests for Coriolis with this last commit. It two a 0-D case for half an inertial period with a rotation about the `z` axis and `x` axis and then compares both to make sure they produce the same result (but rotated). There's one part that tests if the total velocity magnitude is approximately unchanged (magnitude=1), which relies on an implicit arbitrary tolerance which might be bad. I'd curious about your feedback on that one. > if the name is changed to include Cartesian then we can merge this and discuss further in an issue. Per the comment above I'm going to change the name to `ConstantCartesianCoriolis` and (provided the tests all pass and you're okay with my new test addition) I'll proceed to merge this into master and open an issue to further discuss the issues that emerged here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888495033
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888495033:429,Usability,feedback,feedback,429,"Added some dynamics tests for Coriolis with this last commit. It two a 0-D case for half an inertial period with a rotation about the `z` axis and `x` axis and then compares both to make sure they produce the same result (but rotated). There's one part that tests if the total velocity magnitude is approximately unchanged (magnitude=1), which relies on an implicit arbitrary tolerance which might be bad. I'd curious about your feedback on that one. > if the name is changed to include Cartesian then we can merge this and discuss further in an issue. Per the comment above I'm going to change the name to `ConstantCartesianCoriolis` and (provided the tests all pass and you're okay with my new test addition) I'll proceed to merge this into master and open an issue to further discuss the issues that emerged here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888495033
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888549957:385,Availability,toler,tolerance,385,"> Added some dynamics tests for Coriolis with this last commit. It two a 0-D case for half an inertial period with a rotation about the `z` axis and `x` axis and then compares both to make sure they produce the same result (but rotated).; > ; > There's one part that tests if the total velocity magnitude is approximately unchanged (magnitude=1), which relies on an implicit arbitrary tolerance which might be bad. I'd curious about your feedback on that one.; > ; > > if the name is changed to include Cartesian then we can merge this and discuss further in an issue.; > ; > Per the comment above I'm going to change the name to `ConstantCartesianCoriolis` and (provided the tests all pass and you're okay with my new test addition) I'll proceed to merge this into master and open an issue to further discuss the issues that emerged here. For physics tests we can't avoid introducing an arbitrary tolerance. So its ok. That's one reason why physics tests in CI are a bit problematic and we also need validation tests analyzed by humans.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888549957
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888549957:898,Availability,toler,tolerance,898,"> Added some dynamics tests for Coriolis with this last commit. It two a 0-D case for half an inertial period with a rotation about the `z` axis and `x` axis and then compares both to make sure they produce the same result (but rotated).; > ; > There's one part that tests if the total velocity magnitude is approximately unchanged (magnitude=1), which relies on an implicit arbitrary tolerance which might be bad. I'd curious about your feedback on that one.; > ; > > if the name is changed to include Cartesian then we can merge this and discuss further in an issue.; > ; > Per the comment above I'm going to change the name to `ConstantCartesianCoriolis` and (provided the tests all pass and you're okay with my new test addition) I'll proceed to merge this into master and open an issue to further discuss the issues that emerged here. For physics tests we can't avoid introducing an arbitrary tolerance. So its ok. That's one reason why physics tests in CI are a bit problematic and we also need validation tests analyzed by humans.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888549957
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888549957:867,Safety,avoid,avoid,867,"> Added some dynamics tests for Coriolis with this last commit. It two a 0-D case for half an inertial period with a rotation about the `z` axis and `x` axis and then compares both to make sure they produce the same result (but rotated).; > ; > There's one part that tests if the total velocity magnitude is approximately unchanged (magnitude=1), which relies on an implicit arbitrary tolerance which might be bad. I'd curious about your feedback on that one.; > ; > > if the name is changed to include Cartesian then we can merge this and discuss further in an issue.; > ; > Per the comment above I'm going to change the name to `ConstantCartesianCoriolis` and (provided the tests all pass and you're okay with my new test addition) I'll proceed to merge this into master and open an issue to further discuss the issues that emerged here. For physics tests we can't avoid introducing an arbitrary tolerance. So its ok. That's one reason why physics tests in CI are a bit problematic and we also need validation tests analyzed by humans.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888549957
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888549957:1001,Security,validat,validation,1001,"> Added some dynamics tests for Coriolis with this last commit. It two a 0-D case for half an inertial period with a rotation about the `z` axis and `x` axis and then compares both to make sure they produce the same result (but rotated).; > ; > There's one part that tests if the total velocity magnitude is approximately unchanged (magnitude=1), which relies on an implicit arbitrary tolerance which might be bad. I'd curious about your feedback on that one.; > ; > > if the name is changed to include Cartesian then we can merge this and discuss further in an issue.; > ; > Per the comment above I'm going to change the name to `ConstantCartesianCoriolis` and (provided the tests all pass and you're okay with my new test addition) I'll proceed to merge this into master and open an issue to further discuss the issues that emerged here. For physics tests we can't avoid introducing an arbitrary tolerance. So its ok. That's one reason why physics tests in CI are a bit problematic and we also need validation tests analyzed by humans.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888549957
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888549957:22,Testability,test,tests,22,"> Added some dynamics tests for Coriolis with this last commit. It two a 0-D case for half an inertial period with a rotation about the `z` axis and `x` axis and then compares both to make sure they produce the same result (but rotated).; > ; > There's one part that tests if the total velocity magnitude is approximately unchanged (magnitude=1), which relies on an implicit arbitrary tolerance which might be bad. I'd curious about your feedback on that one.; > ; > > if the name is changed to include Cartesian then we can merge this and discuss further in an issue.; > ; > Per the comment above I'm going to change the name to `ConstantCartesianCoriolis` and (provided the tests all pass and you're okay with my new test addition) I'll proceed to merge this into master and open an issue to further discuss the issues that emerged here. For physics tests we can't avoid introducing an arbitrary tolerance. So its ok. That's one reason why physics tests in CI are a bit problematic and we also need validation tests analyzed by humans.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888549957
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888549957:267,Testability,test,tests,267,"> Added some dynamics tests for Coriolis with this last commit. It two a 0-D case for half an inertial period with a rotation about the `z` axis and `x` axis and then compares both to make sure they produce the same result (but rotated).; > ; > There's one part that tests if the total velocity magnitude is approximately unchanged (magnitude=1), which relies on an implicit arbitrary tolerance which might be bad. I'd curious about your feedback on that one.; > ; > > if the name is changed to include Cartesian then we can merge this and discuss further in an issue.; > ; > Per the comment above I'm going to change the name to `ConstantCartesianCoriolis` and (provided the tests all pass and you're okay with my new test addition) I'll proceed to merge this into master and open an issue to further discuss the issues that emerged here. For physics tests we can't avoid introducing an arbitrary tolerance. So its ok. That's one reason why physics tests in CI are a bit problematic and we also need validation tests analyzed by humans.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888549957
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888549957:676,Testability,test,tests,676,"> Added some dynamics tests for Coriolis with this last commit. It two a 0-D case for half an inertial period with a rotation about the `z` axis and `x` axis and then compares both to make sure they produce the same result (but rotated).; > ; > There's one part that tests if the total velocity magnitude is approximately unchanged (magnitude=1), which relies on an implicit arbitrary tolerance which might be bad. I'd curious about your feedback on that one.; > ; > > if the name is changed to include Cartesian then we can merge this and discuss further in an issue.; > ; > Per the comment above I'm going to change the name to `ConstantCartesianCoriolis` and (provided the tests all pass and you're okay with my new test addition) I'll proceed to merge this into master and open an issue to further discuss the issues that emerged here. For physics tests we can't avoid introducing an arbitrary tolerance. So its ok. That's one reason why physics tests in CI are a bit problematic and we also need validation tests analyzed by humans.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888549957
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888549957:719,Testability,test,test,719,"> Added some dynamics tests for Coriolis with this last commit. It two a 0-D case for half an inertial period with a rotation about the `z` axis and `x` axis and then compares both to make sure they produce the same result (but rotated).; > ; > There's one part that tests if the total velocity magnitude is approximately unchanged (magnitude=1), which relies on an implicit arbitrary tolerance which might be bad. I'd curious about your feedback on that one.; > ; > > if the name is changed to include Cartesian then we can merge this and discuss further in an issue.; > ; > Per the comment above I'm going to change the name to `ConstantCartesianCoriolis` and (provided the tests all pass and you're okay with my new test addition) I'll proceed to merge this into master and open an issue to further discuss the issues that emerged here. For physics tests we can't avoid introducing an arbitrary tolerance. So its ok. That's one reason why physics tests in CI are a bit problematic and we also need validation tests analyzed by humans.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888549957
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888549957:852,Testability,test,tests,852,"> Added some dynamics tests for Coriolis with this last commit. It two a 0-D case for half an inertial period with a rotation about the `z` axis and `x` axis and then compares both to make sure they produce the same result (but rotated).; > ; > There's one part that tests if the total velocity magnitude is approximately unchanged (magnitude=1), which relies on an implicit arbitrary tolerance which might be bad. I'd curious about your feedback on that one.; > ; > > if the name is changed to include Cartesian then we can merge this and discuss further in an issue.; > ; > Per the comment above I'm going to change the name to `ConstantCartesianCoriolis` and (provided the tests all pass and you're okay with my new test addition) I'll proceed to merge this into master and open an issue to further discuss the issues that emerged here. For physics tests we can't avoid introducing an arbitrary tolerance. So its ok. That's one reason why physics tests in CI are a bit problematic and we also need validation tests analyzed by humans.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888549957
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888549957:950,Testability,test,tests,950,"> Added some dynamics tests for Coriolis with this last commit. It two a 0-D case for half an inertial period with a rotation about the `z` axis and `x` axis and then compares both to make sure they produce the same result (but rotated).; > ; > There's one part that tests if the total velocity magnitude is approximately unchanged (magnitude=1), which relies on an implicit arbitrary tolerance which might be bad. I'd curious about your feedback on that one.; > ; > > if the name is changed to include Cartesian then we can merge this and discuss further in an issue.; > ; > Per the comment above I'm going to change the name to `ConstantCartesianCoriolis` and (provided the tests all pass and you're okay with my new test addition) I'll proceed to merge this into master and open an issue to further discuss the issues that emerged here. For physics tests we can't avoid introducing an arbitrary tolerance. So its ok. That's one reason why physics tests in CI are a bit problematic and we also need validation tests analyzed by humans.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888549957
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888549957:1012,Testability,test,tests,1012,"> Added some dynamics tests for Coriolis with this last commit. It two a 0-D case for half an inertial period with a rotation about the `z` axis and `x` axis and then compares both to make sure they produce the same result (but rotated).; > ; > There's one part that tests if the total velocity magnitude is approximately unchanged (magnitude=1), which relies on an implicit arbitrary tolerance which might be bad. I'd curious about your feedback on that one.; > ; > > if the name is changed to include Cartesian then we can merge this and discuss further in an issue.; > ; > Per the comment above I'm going to change the name to `ConstantCartesianCoriolis` and (provided the tests all pass and you're okay with my new test addition) I'll proceed to merge this into master and open an issue to further discuss the issues that emerged here. For physics tests we can't avoid introducing an arbitrary tolerance. So its ok. That's one reason why physics tests in CI are a bit problematic and we also need validation tests analyzed by humans.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888549957
https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888549957:438,Usability,feedback,feedback,438,"> Added some dynamics tests for Coriolis with this last commit. It two a 0-D case for half an inertial period with a rotation about the `z` axis and `x` axis and then compares both to make sure they produce the same result (but rotated).; > ; > There's one part that tests if the total velocity magnitude is approximately unchanged (magnitude=1), which relies on an implicit arbitrary tolerance which might be bad. I'd curious about your feedback on that one.; > ; > > if the name is changed to include Cartesian then we can merge this and discuss further in an issue.; > ; > Per the comment above I'm going to change the name to `ConstantCartesianCoriolis` and (provided the tests all pass and you're okay with my new test addition) I'll proceed to merge this into master and open an issue to further discuss the issues that emerged here. For physics tests we can't avoid introducing an arbitrary tolerance. So its ok. That's one reason why physics tests in CI are a bit problematic and we also need validation tests analyzed by humans.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-888549957
https://github.com/CliMA/Oceananigans.jl/pull/1893#issuecomment-886143177:155,Availability,checkpoint,checkpointer,155,"> After this passes, would we want to include this in the docs somewhere? If yes do you have an example in mind?. This PR updates the docs for recommended checkpointer usage!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1893#issuecomment-886143177
https://github.com/CliMA/Oceananigans.jl/pull/1893#issuecomment-886143177:122,Deployability,update,updates,122,"> After this passes, would we want to include this in the docs somewhere? If yes do you have an example in mind?. This PR updates the docs for recommended checkpointer usage!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1893#issuecomment-886143177
https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885815090:151,Deployability,update,updates,151,"Basically a ""callback"" is a way to run any function that takes a `Simulation` as an argument at a given schedule? Be it a function that prints things, updates model parameters (like `TimeStepWizard`) or whatever?. If so, I'm very much onboard with this feature :+1:",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885815090
https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885815090:104,Energy Efficiency,schedul,schedule,104,"Basically a ""callback"" is a way to run any function that takes a `Simulation` as an argument at a given schedule? Be it a function that prints things, updates model parameters (like `TimeStepWizard`) or whatever?. If so, I'm very much onboard with this feature :+1:",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885815090
https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885836832:213,Energy Efficiency,schedul,schedule,213,"Seems like a good idea but let me make sure I understand it. If I take your example and modify it slightly, change 10 to 1, should it give output everytime step?. ```; progress_callback = Callback(print_progress, schedule=IterationInterval(10)); run!(simulation, callbacks=[progress_callback]); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885836832
https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885845028:153,Deployability,update,updates,153,"> Basically a ""callback"" is a way to run any function that takes a `Simulation` as an argument at a given schedule? Be it a function that prints things, updates model parameters (like `TimeStepWizard`) or whatever?; > ; > If so, I'm very much onboard with this feature . Yeah... ""callback"" is an annoyingly obtuse but somehow standard name for this kind of thing. https://en.wikipedia.org/wiki/Callback_(computer_programming). https://trixi-framework.github.io/Trixi.jl/stable/callbacks/. We could be rebels and call this something else. Like `Callafter`, or something we come up with. If `TimeStepWizard` is a `Callback`, it updates the time step in `Simulation`. But this feature can also be used to do things like update an array that holds boundary fluxes. This could be used to couple two domains together (this application is why I want to implement this now).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885845028
https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885845028:627,Deployability,update,updates,627,"> Basically a ""callback"" is a way to run any function that takes a `Simulation` as an argument at a given schedule? Be it a function that prints things, updates model parameters (like `TimeStepWizard`) or whatever?; > ; > If so, I'm very much onboard with this feature . Yeah... ""callback"" is an annoyingly obtuse but somehow standard name for this kind of thing. https://en.wikipedia.org/wiki/Callback_(computer_programming). https://trixi-framework.github.io/Trixi.jl/stable/callbacks/. We could be rebels and call this something else. Like `Callafter`, or something we come up with. If `TimeStepWizard` is a `Callback`, it updates the time step in `Simulation`. But this feature can also be used to do things like update an array that holds boundary fluxes. This could be used to couple two domains together (this application is why I want to implement this now).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885845028
https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885845028:718,Deployability,update,update,718,"> Basically a ""callback"" is a way to run any function that takes a `Simulation` as an argument at a given schedule? Be it a function that prints things, updates model parameters (like `TimeStepWizard`) or whatever?; > ; > If so, I'm very much onboard with this feature . Yeah... ""callback"" is an annoyingly obtuse but somehow standard name for this kind of thing. https://en.wikipedia.org/wiki/Callback_(computer_programming). https://trixi-framework.github.io/Trixi.jl/stable/callbacks/. We could be rebels and call this something else. Like `Callafter`, or something we come up with. If `TimeStepWizard` is a `Callback`, it updates the time step in `Simulation`. But this feature can also be used to do things like update an array that holds boundary fluxes. This could be used to couple two domains together (this application is why I want to implement this now).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885845028
https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885845028:106,Energy Efficiency,schedul,schedule,106,"> Basically a ""callback"" is a way to run any function that takes a `Simulation` as an argument at a given schedule? Be it a function that prints things, updates model parameters (like `TimeStepWizard`) or whatever?; > ; > If so, I'm very much onboard with this feature . Yeah... ""callback"" is an annoyingly obtuse but somehow standard name for this kind of thing. https://en.wikipedia.org/wiki/Callback_(computer_programming). https://trixi-framework.github.io/Trixi.jl/stable/callbacks/. We could be rebels and call this something else. Like `Callafter`, or something we come up with. If `TimeStepWizard` is a `Callback`, it updates the time step in `Simulation`. But this feature can also be used to do things like update an array that holds boundary fluxes. This could be used to couple two domains together (this application is why I want to implement this now).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885845028
https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885845455:230,Energy Efficiency,schedul,schedule,230,"> Seems like a good idea but let me make sure I understand it.; > ; > If I take your example and modify it slightly, change 10 to 1, should it give output everytime step?; > ; > ```; > progress_callback = Callback(print_progress, schedule=IterationInterval(10)); > run!(simulation, callbacks=[progress_callback]); > ```. That's right. `Callback.func` is called on `schedule`. `schedule=IterationInterval(1)` means it's called every time-step.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885845455
https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885845455:365,Energy Efficiency,schedul,schedule,365,"> Seems like a good idea but let me make sure I understand it.; > ; > If I take your example and modify it slightly, change 10 to 1, should it give output everytime step?; > ; > ```; > progress_callback = Callback(print_progress, schedule=IterationInterval(10)); > run!(simulation, callbacks=[progress_callback]); > ```. That's right. `Callback.func` is called on `schedule`. `schedule=IterationInterval(1)` means it's called every time-step.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885845455
https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885845455:377,Energy Efficiency,schedul,schedule,377,"> Seems like a good idea but let me make sure I understand it.; > ; > If I take your example and modify it slightly, change 10 to 1, should it give output everytime step?; > ; > ```; > progress_callback = Callback(print_progress, schedule=IterationInterval(10)); > run!(simulation, callbacks=[progress_callback]); > ```. That's right. `Callback.func` is called on `schedule`. `schedule=IterationInterval(1)` means it's called every time-step.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885845455
https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885853182:120,Usability,clear,clearest,120,"> Yeah... ""callback"" is an annoyingly obtuse but somehow standard name for this kind of thing. Yeah, definitely not the clearest name... but if it's standard I guess it's good to keep it. This sounds like it's unambiguously positive though! Nice contribution",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885853182
https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885969109:288,Deployability,integrat,integrator,288,@glwagner at some point it might good to think about whether exposing similar interfaces to DiffEq ( e.g. https://diffeq.sciml.ai/dev/features/callback_functions/#The-Callback-Types ) makes sense. Probably for the future. . Same could go for run! (e.g. https://diffeq.sciml.ai/dev/basics/integrator/#Initialization-and-Stepping ) too?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885969109
https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885969109:78,Integrability,interface,interfaces,78,@glwagner at some point it might good to think about whether exposing similar interfaces to DiffEq ( e.g. https://diffeq.sciml.ai/dev/features/callback_functions/#The-Callback-Types ) makes sense. Probably for the future. . Same could go for run! (e.g. https://diffeq.sciml.ai/dev/basics/integrator/#Initialization-and-Stepping ) too?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885969109
https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885969109:288,Integrability,integrat,integrator,288,@glwagner at some point it might good to think about whether exposing similar interfaces to DiffEq ( e.g. https://diffeq.sciml.ai/dev/features/callback_functions/#The-Callback-Types ) makes sense. Probably for the future. . Same could go for run! (e.g. https://diffeq.sciml.ai/dev/basics/integrator/#Initialization-and-Stepping ) too?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885969109
https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885979847:295,Deployability,integrat,integrator,295,"> @glwagner at some point it might good to think about whether exposing similar interfaces to DiffEq ( e.g. https://diffeq.sciml.ai/dev/features/callback_functions/#The-Callback-Types ) makes sense. Probably for the future.; > ; > Same could go for run! (e.g. https://diffeq.sciml.ai/dev/basics/integrator/#Initialization-and-Stepping ) too?. Ah wow, that is epic. I think what's implemented here is more or less analogous to `DiscreteCallback`. Reading over the features there makes me realize that we probably want to ""align"" the time-step (somehow, similar to the root finding feature that's provided for DiffEq) for callbacks. We align time-steps for output, but not for callbacks (yet). That would be nice to add. I think we could also add an analog of the ""continuous callback"" --- to the models, not the simulations --- that's executed during `update_state!`, and therefore can be thought of as a function that ""continuously"" (eg valid at every moment in time) modifies the state of the model. Perhaps `StateModifier` or something like that? These objects would not have a schedule since they'd always be executed. Initialization and finalization might be good wishlist features too for both.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885979847
https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885979847:763,Deployability,continuous,continuous,763,"> @glwagner at some point it might good to think about whether exposing similar interfaces to DiffEq ( e.g. https://diffeq.sciml.ai/dev/features/callback_functions/#The-Callback-Types ) makes sense. Probably for the future.; > ; > Same could go for run! (e.g. https://diffeq.sciml.ai/dev/basics/integrator/#Initialization-and-Stepping ) too?. Ah wow, that is epic. I think what's implemented here is more or less analogous to `DiscreteCallback`. Reading over the features there makes me realize that we probably want to ""align"" the time-step (somehow, similar to the root finding feature that's provided for DiffEq) for callbacks. We align time-steps for output, but not for callbacks (yet). That would be nice to add. I think we could also add an analog of the ""continuous callback"" --- to the models, not the simulations --- that's executed during `update_state!`, and therefore can be thought of as a function that ""continuously"" (eg valid at every moment in time) modifies the state of the model. Perhaps `StateModifier` or something like that? These objects would not have a schedule since they'd always be executed. Initialization and finalization might be good wishlist features too for both.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885979847
https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885979847:919,Deployability,continuous,continuously,919,"> @glwagner at some point it might good to think about whether exposing similar interfaces to DiffEq ( e.g. https://diffeq.sciml.ai/dev/features/callback_functions/#The-Callback-Types ) makes sense. Probably for the future.; > ; > Same could go for run! (e.g. https://diffeq.sciml.ai/dev/basics/integrator/#Initialization-and-Stepping ) too?. Ah wow, that is epic. I think what's implemented here is more or less analogous to `DiscreteCallback`. Reading over the features there makes me realize that we probably want to ""align"" the time-step (somehow, similar to the root finding feature that's provided for DiffEq) for callbacks. We align time-steps for output, but not for callbacks (yet). That would be nice to add. I think we could also add an analog of the ""continuous callback"" --- to the models, not the simulations --- that's executed during `update_state!`, and therefore can be thought of as a function that ""continuously"" (eg valid at every moment in time) modifies the state of the model. Perhaps `StateModifier` or something like that? These objects would not have a schedule since they'd always be executed. Initialization and finalization might be good wishlist features too for both.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885979847
https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885979847:1080,Energy Efficiency,schedul,schedule,1080,"> @glwagner at some point it might good to think about whether exposing similar interfaces to DiffEq ( e.g. https://diffeq.sciml.ai/dev/features/callback_functions/#The-Callback-Types ) makes sense. Probably for the future.; > ; > Same could go for run! (e.g. https://diffeq.sciml.ai/dev/basics/integrator/#Initialization-and-Stepping ) too?. Ah wow, that is epic. I think what's implemented here is more or less analogous to `DiscreteCallback`. Reading over the features there makes me realize that we probably want to ""align"" the time-step (somehow, similar to the root finding feature that's provided for DiffEq) for callbacks. We align time-steps for output, but not for callbacks (yet). That would be nice to add. I think we could also add an analog of the ""continuous callback"" --- to the models, not the simulations --- that's executed during `update_state!`, and therefore can be thought of as a function that ""continuously"" (eg valid at every moment in time) modifies the state of the model. Perhaps `StateModifier` or something like that? These objects would not have a schedule since they'd always be executed. Initialization and finalization might be good wishlist features too for both.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885979847
https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885979847:80,Integrability,interface,interfaces,80,"> @glwagner at some point it might good to think about whether exposing similar interfaces to DiffEq ( e.g. https://diffeq.sciml.ai/dev/features/callback_functions/#The-Callback-Types ) makes sense. Probably for the future.; > ; > Same could go for run! (e.g. https://diffeq.sciml.ai/dev/basics/integrator/#Initialization-and-Stepping ) too?. Ah wow, that is epic. I think what's implemented here is more or less analogous to `DiscreteCallback`. Reading over the features there makes me realize that we probably want to ""align"" the time-step (somehow, similar to the root finding feature that's provided for DiffEq) for callbacks. We align time-steps for output, but not for callbacks (yet). That would be nice to add. I think we could also add an analog of the ""continuous callback"" --- to the models, not the simulations --- that's executed during `update_state!`, and therefore can be thought of as a function that ""continuously"" (eg valid at every moment in time) modifies the state of the model. Perhaps `StateModifier` or something like that? These objects would not have a schedule since they'd always be executed. Initialization and finalization might be good wishlist features too for both.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885979847
https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885979847:295,Integrability,integrat,integrator,295,"> @glwagner at some point it might good to think about whether exposing similar interfaces to DiffEq ( e.g. https://diffeq.sciml.ai/dev/features/callback_functions/#The-Callback-Types ) makes sense. Probably for the future.; > ; > Same could go for run! (e.g. https://diffeq.sciml.ai/dev/basics/integrator/#Initialization-and-Stepping ) too?. Ah wow, that is epic. I think what's implemented here is more or less analogous to `DiscreteCallback`. Reading over the features there makes me realize that we probably want to ""align"" the time-step (somehow, similar to the root finding feature that's provided for DiffEq) for callbacks. We align time-steps for output, but not for callbacks (yet). That would be nice to add. I think we could also add an analog of the ""continuous callback"" --- to the models, not the simulations --- that's executed during `update_state!`, and therefore can be thought of as a function that ""continuously"" (eg valid at every moment in time) modifies the state of the model. Perhaps `StateModifier` or something like that? These objects would not have a schedule since they'd always be executed. Initialization and finalization might be good wishlist features too for both.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1894#issuecomment-885979847
https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001102006:871,Availability,recover,recover,871,"Probably related:. I saw the new `Simulation` API and the new `Callback` idea. This brought a change: the old way of building a Simulation included a `parameters` arguments. This `parameters` was accesible from the `progress` function. With the new way, we build callbacks and then register them, but there is no way to pass additional parameters to it. . In one of my usages I was hacking a progress function https://github.com/aramirezreyes/RamirezReyes_ShallowWaterInFPlane/blob/c1971c0cb3fc99fbb2dbf3303a8fd60b17a59d5a/scripts/run_oceananigans_example_cpu.jl#L101 to update some arrays on a parameterization. Unfortunately, this depended on the `parameters` argument. The more generalized idea of the `callbacks` is very elegant and works nice, but it loses some power from the lack of ability to add additional parameters to the callback function. Is there a way to recover this ability? (there are other ways of getting it to work but having it in the design would be nice).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001102006
https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001102006:571,Deployability,update,update,571,"Probably related:. I saw the new `Simulation` API and the new `Callback` idea. This brought a change: the old way of building a Simulation included a `parameters` arguments. This `parameters` was accesible from the `progress` function. With the new way, we build callbacks and then register them, but there is no way to pass additional parameters to it. . In one of my usages I was hacking a progress function https://github.com/aramirezreyes/RamirezReyes_ShallowWaterInFPlane/blob/c1971c0cb3fc99fbb2dbf3303a8fd60b17a59d5a/scripts/run_oceananigans_example_cpu.jl#L101 to update some arrays on a parameterization. Unfortunately, this depended on the `parameters` argument. The more generalized idea of the `callbacks` is very elegant and works nice, but it loses some power from the lack of ability to add additional parameters to the callback function. Is there a way to recover this ability? (there are other ways of getting it to work but having it in the design would be nice).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001102006
https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001102006:767,Energy Efficiency,power,power,767,"Probably related:. I saw the new `Simulation` API and the new `Callback` idea. This brought a change: the old way of building a Simulation included a `parameters` arguments. This `parameters` was accesible from the `progress` function. With the new way, we build callbacks and then register them, but there is no way to pass additional parameters to it. . In one of my usages I was hacking a progress function https://github.com/aramirezreyes/RamirezReyes_ShallowWaterInFPlane/blob/c1971c0cb3fc99fbb2dbf3303a8fd60b17a59d5a/scripts/run_oceananigans_example_cpu.jl#L101 to update some arrays on a parameterization. Unfortunately, this depended on the `parameters` argument. The more generalized idea of the `callbacks` is very elegant and works nice, but it loses some power from the lack of ability to add additional parameters to the callback function. Is there a way to recover this ability? (there are other ways of getting it to work but having it in the design would be nice).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001102006
https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001102006:633,Integrability,depend,depended,633,"Probably related:. I saw the new `Simulation` API and the new `Callback` idea. This brought a change: the old way of building a Simulation included a `parameters` arguments. This `parameters` was accesible from the `progress` function. With the new way, we build callbacks and then register them, but there is no way to pass additional parameters to it. . In one of my usages I was hacking a progress function https://github.com/aramirezreyes/RamirezReyes_ShallowWaterInFPlane/blob/c1971c0cb3fc99fbb2dbf3303a8fd60b17a59d5a/scripts/run_oceananigans_example_cpu.jl#L101 to update some arrays on a parameterization. Unfortunately, this depended on the `parameters` argument. The more generalized idea of the `callbacks` is very elegant and works nice, but it loses some power from the lack of ability to add additional parameters to the callback function. Is there a way to recover this ability? (there are other ways of getting it to work but having it in the design would be nice).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001102006
https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001102006:595,Modifiability,parameteriz,parameterization,595,"Probably related:. I saw the new `Simulation` API and the new `Callback` idea. This brought a change: the old way of building a Simulation included a `parameters` arguments. This `parameters` was accesible from the `progress` function. With the new way, we build callbacks and then register them, but there is no way to pass additional parameters to it. . In one of my usages I was hacking a progress function https://github.com/aramirezreyes/RamirezReyes_ShallowWaterInFPlane/blob/c1971c0cb3fc99fbb2dbf3303a8fd60b17a59d5a/scripts/run_oceananigans_example_cpu.jl#L101 to update some arrays on a parameterization. Unfortunately, this depended on the `parameters` argument. The more generalized idea of the `callbacks` is very elegant and works nice, but it loses some power from the lack of ability to add additional parameters to the callback function. Is there a way to recover this ability? (there are other ways of getting it to work but having it in the design would be nice).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001102006
https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001102006:871,Safety,recover,recover,871,"Probably related:. I saw the new `Simulation` API and the new `Callback` idea. This brought a change: the old way of building a Simulation included a `parameters` arguments. This `parameters` was accesible from the `progress` function. With the new way, we build callbacks and then register them, but there is no way to pass additional parameters to it. . In one of my usages I was hacking a progress function https://github.com/aramirezreyes/RamirezReyes_ShallowWaterInFPlane/blob/c1971c0cb3fc99fbb2dbf3303a8fd60b17a59d5a/scripts/run_oceananigans_example_cpu.jl#L101 to update some arrays on a parameterization. Unfortunately, this depended on the `parameters` argument. The more generalized idea of the `callbacks` is very elegant and works nice, but it loses some power from the lack of ability to add additional parameters to the callback function. Is there a way to recover this ability? (there are other ways of getting it to work but having it in the design would be nice).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001102006
https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001249751:25,Modifiability,parameteriz,parameterized,25,I opened a new issue for parameterized Callbacks --- check out #2127,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001249751
https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-888691225:37,Testability,benchmark,benchmarking,37,@hennyg888 I think this is ready for benchmarking.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-888691225
https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-889077963:129,Availability,Error,Error,129,"I guess here is a problem with `heuristic_workgroup`. ```; Time stepping NonhydrostaticModel: Time stepping NonhydrostaticModel: Error During Test at Time stepping NonhydrostaticModel: Time stepping NonhydrostaticModel: Error During Test at Error During TestError During Test at at /var/lib/buildkite-agent/builds/tartarus-2/clima/oceananigans/test/test_distributed_models.jl:481;  | Got exception outside of a @test;  | MethodError: no method matching heuristic_workgroup(::MultiCPU{RegularRectilinearGrid{Float64, Periodic, Periodic, Periodic, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Oceananigans.Distributed.RankConnectivity{Nothing, Nothing, Int64, Int64, Nothing, Nothing}, MPI.Comm}, ::Int64, ::Int64, ::Int64);  | Closest candidates are:;  | heuristic_workgroup(::GPU, ::Any, ::Any, ::Any) at /var/lib/buildkite-agent/builds/tartarus-2/clima/oceananigans/src/Utils/kernel_launching.jl:12;  | heuristic_workgroup(::CPU, ::Any, ::Any, ::Any) at /var/lib/buildkite-agent/builds/tartarus-2/clima/oceananigans/src/Utils/kernel_launching.jl:26; ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-889077963
https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-889077963:220,Availability,Error,Error,220,"I guess here is a problem with `heuristic_workgroup`. ```; Time stepping NonhydrostaticModel: Time stepping NonhydrostaticModel: Error During Test at Time stepping NonhydrostaticModel: Time stepping NonhydrostaticModel: Error During Test at Error During TestError During Test at at /var/lib/buildkite-agent/builds/tartarus-2/clima/oceananigans/test/test_distributed_models.jl:481;  | Got exception outside of a @test;  | MethodError: no method matching heuristic_workgroup(::MultiCPU{RegularRectilinearGrid{Float64, Periodic, Periodic, Periodic, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Oceananigans.Distributed.RankConnectivity{Nothing, Nothing, Int64, Int64, Nothing, Nothing}, MPI.Comm}, ::Int64, ::Int64, ::Int64);  | Closest candidates are:;  | heuristic_workgroup(::GPU, ::Any, ::Any, ::Any) at /var/lib/buildkite-agent/builds/tartarus-2/clima/oceananigans/src/Utils/kernel_launching.jl:12;  | heuristic_workgroup(::CPU, ::Any, ::Any, ::Any) at /var/lib/buildkite-agent/builds/tartarus-2/clima/oceananigans/src/Utils/kernel_launching.jl:26; ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-889077963
https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-889077963:241,Availability,Error,Error,241,"I guess here is a problem with `heuristic_workgroup`. ```; Time stepping NonhydrostaticModel: Time stepping NonhydrostaticModel: Error During Test at Time stepping NonhydrostaticModel: Time stepping NonhydrostaticModel: Error During Test at Error During TestError During Test at at /var/lib/buildkite-agent/builds/tartarus-2/clima/oceananigans/test/test_distributed_models.jl:481;  | Got exception outside of a @test;  | MethodError: no method matching heuristic_workgroup(::MultiCPU{RegularRectilinearGrid{Float64, Periodic, Periodic, Periodic, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Oceananigans.Distributed.RankConnectivity{Nothing, Nothing, Int64, Int64, Nothing, Nothing}, MPI.Comm}, ::Int64, ::Int64, ::Int64);  | Closest candidates are:;  | heuristic_workgroup(::GPU, ::Any, ::Any, ::Any) at /var/lib/buildkite-agent/builds/tartarus-2/clima/oceananigans/src/Utils/kernel_launching.jl:12;  | heuristic_workgroup(::CPU, ::Any, ::Any, ::Any) at /var/lib/buildkite-agent/builds/tartarus-2/clima/oceananigans/src/Utils/kernel_launching.jl:26; ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-889077963
https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-889077963:142,Testability,Test,Test,142,"I guess here is a problem with `heuristic_workgroup`. ```; Time stepping NonhydrostaticModel: Time stepping NonhydrostaticModel: Error During Test at Time stepping NonhydrostaticModel: Time stepping NonhydrostaticModel: Error During Test at Error During TestError During Test at at /var/lib/buildkite-agent/builds/tartarus-2/clima/oceananigans/test/test_distributed_models.jl:481;  | Got exception outside of a @test;  | MethodError: no method matching heuristic_workgroup(::MultiCPU{RegularRectilinearGrid{Float64, Periodic, Periodic, Periodic, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Oceananigans.Distributed.RankConnectivity{Nothing, Nothing, Int64, Int64, Nothing, Nothing}, MPI.Comm}, ::Int64, ::Int64, ::Int64);  | Closest candidates are:;  | heuristic_workgroup(::GPU, ::Any, ::Any, ::Any) at /var/lib/buildkite-agent/builds/tartarus-2/clima/oceananigans/src/Utils/kernel_launching.jl:12;  | heuristic_workgroup(::CPU, ::Any, ::Any, ::Any) at /var/lib/buildkite-agent/builds/tartarus-2/clima/oceananigans/src/Utils/kernel_launching.jl:26; ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-889077963
https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-889077963:233,Testability,Test,Test,233,"I guess here is a problem with `heuristic_workgroup`. ```; Time stepping NonhydrostaticModel: Time stepping NonhydrostaticModel: Error During Test at Time stepping NonhydrostaticModel: Time stepping NonhydrostaticModel: Error During Test at Error During TestError During Test at at /var/lib/buildkite-agent/builds/tartarus-2/clima/oceananigans/test/test_distributed_models.jl:481;  | Got exception outside of a @test;  | MethodError: no method matching heuristic_workgroup(::MultiCPU{RegularRectilinearGrid{Float64, Periodic, Periodic, Periodic, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Oceananigans.Distributed.RankConnectivity{Nothing, Nothing, Int64, Int64, Nothing, Nothing}, MPI.Comm}, ::Int64, ::Int64, ::Int64);  | Closest candidates are:;  | heuristic_workgroup(::GPU, ::Any, ::Any, ::Any) at /var/lib/buildkite-agent/builds/tartarus-2/clima/oceananigans/src/Utils/kernel_launching.jl:12;  | heuristic_workgroup(::CPU, ::Any, ::Any, ::Any) at /var/lib/buildkite-agent/builds/tartarus-2/clima/oceananigans/src/Utils/kernel_launching.jl:26; ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-889077963
https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-889077963:254,Testability,Test,TestError,254,"I guess here is a problem with `heuristic_workgroup`. ```; Time stepping NonhydrostaticModel: Time stepping NonhydrostaticModel: Error During Test at Time stepping NonhydrostaticModel: Time stepping NonhydrostaticModel: Error During Test at Error During TestError During Test at at /var/lib/buildkite-agent/builds/tartarus-2/clima/oceananigans/test/test_distributed_models.jl:481;  | Got exception outside of a @test;  | MethodError: no method matching heuristic_workgroup(::MultiCPU{RegularRectilinearGrid{Float64, Periodic, Periodic, Periodic, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Oceananigans.Distributed.RankConnectivity{Nothing, Nothing, Int64, Int64, Nothing, Nothing}, MPI.Comm}, ::Int64, ::Int64, ::Int64);  | Closest candidates are:;  | heuristic_workgroup(::GPU, ::Any, ::Any, ::Any) at /var/lib/buildkite-agent/builds/tartarus-2/clima/oceananigans/src/Utils/kernel_launching.jl:12;  | heuristic_workgroup(::CPU, ::Any, ::Any, ::Any) at /var/lib/buildkite-agent/builds/tartarus-2/clima/oceananigans/src/Utils/kernel_launching.jl:26; ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-889077963
https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-889077963:271,Testability,Test,Test,271,"I guess here is a problem with `heuristic_workgroup`. ```; Time stepping NonhydrostaticModel: Time stepping NonhydrostaticModel: Error During Test at Time stepping NonhydrostaticModel: Time stepping NonhydrostaticModel: Error During Test at Error During TestError During Test at at /var/lib/buildkite-agent/builds/tartarus-2/clima/oceananigans/test/test_distributed_models.jl:481;  | Got exception outside of a @test;  | MethodError: no method matching heuristic_workgroup(::MultiCPU{RegularRectilinearGrid{Float64, Periodic, Periodic, Periodic, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Oceananigans.Distributed.RankConnectivity{Nothing, Nothing, Int64, Int64, Nothing, Nothing}, MPI.Comm}, ::Int64, ::Int64, ::Int64);  | Closest candidates are:;  | heuristic_workgroup(::GPU, ::Any, ::Any, ::Any) at /var/lib/buildkite-agent/builds/tartarus-2/clima/oceananigans/src/Utils/kernel_launching.jl:12;  | heuristic_workgroup(::CPU, ::Any, ::Any, ::Any) at /var/lib/buildkite-agent/builds/tartarus-2/clima/oceananigans/src/Utils/kernel_launching.jl:26; ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-889077963
https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-889077963:344,Testability,test,test,344,"I guess here is a problem with `heuristic_workgroup`. ```; Time stepping NonhydrostaticModel: Time stepping NonhydrostaticModel: Error During Test at Time stepping NonhydrostaticModel: Time stepping NonhydrostaticModel: Error During Test at Error During TestError During Test at at /var/lib/buildkite-agent/builds/tartarus-2/clima/oceananigans/test/test_distributed_models.jl:481;  | Got exception outside of a @test;  | MethodError: no method matching heuristic_workgroup(::MultiCPU{RegularRectilinearGrid{Float64, Periodic, Periodic, Periodic, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Oceananigans.Distributed.RankConnectivity{Nothing, Nothing, Int64, Int64, Nothing, Nothing}, MPI.Comm}, ::Int64, ::Int64, ::Int64);  | Closest candidates are:;  | heuristic_workgroup(::GPU, ::Any, ::Any, ::Any) at /var/lib/buildkite-agent/builds/tartarus-2/clima/oceananigans/src/Utils/kernel_launching.jl:12;  | heuristic_workgroup(::CPU, ::Any, ::Any, ::Any) at /var/lib/buildkite-agent/builds/tartarus-2/clima/oceananigans/src/Utils/kernel_launching.jl:26; ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-889077963
https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-889077963:413,Testability,test,test,413,"I guess here is a problem with `heuristic_workgroup`. ```; Time stepping NonhydrostaticModel: Time stepping NonhydrostaticModel: Error During Test at Time stepping NonhydrostaticModel: Time stepping NonhydrostaticModel: Error During Test at Error During TestError During Test at at /var/lib/buildkite-agent/builds/tartarus-2/clima/oceananigans/test/test_distributed_models.jl:481;  | Got exception outside of a @test;  | MethodError: no method matching heuristic_workgroup(::MultiCPU{RegularRectilinearGrid{Float64, Periodic, Periodic, Periodic, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, Int64, Tuple{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Oceananigans.Distributed.RankConnectivity{Nothing, Nothing, Int64, Int64, Nothing, Nothing}, MPI.Comm}, ::Int64, ::Int64, ::Int64);  | Closest candidates are:;  | heuristic_workgroup(::GPU, ::Any, ::Any, ::Any) at /var/lib/buildkite-agent/builds/tartarus-2/clima/oceananigans/src/Utils/kernel_launching.jl:12;  | heuristic_workgroup(::CPU, ::Any, ::Any, ::Any) at /var/lib/buildkite-agent/builds/tartarus-2/clima/oceananigans/src/Utils/kernel_launching.jl:26; ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-889077963
https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-889297504:90,Testability,test,tests,90,"> Might be good to see if this speeds things up before merging too. I agree. Now that the tests all pass, @henry888, would you mind giving this a try when you have a chance?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-889297504
https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-889983514:29,Testability,benchmark,benchmarks,29,"@glwagner the multithreading benchmarks for the 2d shallow water model does not seem to have changed. It's roughly the same as those shown in #1861.; <html>; <body>; <!--StartFragment-->. size | threads | slowdown | efficiency | memory | allocs; -- | -- | -- | -- | -- | --; (8192, 512) | 1 | 1.0 | 1.0 | 1.0 | 1.0; (8192, 1024) | 2 | 1.98316 | 0.504246 | 12.1409 | 434.108; (8192, 2048) | 4 | 1.60839 | 0.621741 | 9.73477 | 331.135; (8192, 4096) | 8 | 1.52129 | 0.657337 | 10.2977 | 332.526; (8192, 8192) | 16 | 1.73345 | 0.576883 | 11.7069 | 340.188; (8192, 16384) | 32 | 2.26084 | 0.442313 | 17.1668 | 470.216. <!--EndFragment-->; </body>; </html>. I'm also running another multithreading benchmark right now with the 3d nonhydrostatic model. Hopefully the new CPU workgroup grouping will show up better there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-889983514
https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-889983514:692,Testability,benchmark,benchmark,692,"@glwagner the multithreading benchmarks for the 2d shallow water model does not seem to have changed. It's roughly the same as those shown in #1861.; <html>; <body>; <!--StartFragment-->. size | threads | slowdown | efficiency | memory | allocs; -- | -- | -- | -- | -- | --; (8192, 512) | 1 | 1.0 | 1.0 | 1.0 | 1.0; (8192, 1024) | 2 | 1.98316 | 0.504246 | 12.1409 | 434.108; (8192, 2048) | 4 | 1.60839 | 0.621741 | 9.73477 | 331.135; (8192, 4096) | 8 | 1.52129 | 0.657337 | 10.2977 | 332.526; (8192, 8192) | 16 | 1.73345 | 0.576883 | 11.7069 | 340.188; (8192, 16384) | 32 | 2.26084 | 0.442313 | 17.1668 | 470.216. <!--EndFragment-->; </body>; </html>. I'm also running another multithreading benchmark right now with the 3d nonhydrostatic model. Hopefully the new CPU workgroup grouping will show up better there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-889983514
https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-889996343:31,Testability,benchmark,benchmarks,31,"> @glwagner the multithreading benchmarks for the 2d shallow water model does not seem to have changed. It's roughly the same as those shown in #1861.; > ; > size	threads	slowdown	efficiency	memory	allocs; > (8192, 512)	1	1.0	1.0	1.0	1.0; > (8192, 1024)	2	1.98316	0.504246	12.1409	434.108; > (8192, 2048)	4	1.60839	0.621741	9.73477	331.135; > (8192, 4096)	8	1.52129	0.657337	10.2977	332.526; > (8192, 8192)	16	1.73345	0.576883	11.7069	340.188; > (8192, 16384)	32	2.26084	0.442313	17.1668	470.216; > I'm also running another multithreading benchmark right now with the 3d nonhydrostatic model. Hopefully the new CPU workgroup grouping will show up better there. Thanks @hennyg888 !. I don't understand the non-monotonic behavior. What could explain this? It smells funny... Does it make sense to run a strong scaling experiment as well to try to de-confuse the situation?. I wonder if we should actually precompute and store the thread-block layout in the `CPU` architecture type. That would allow us to more easily experiment with different layouts and also would allow users to tweak the layout if something wasn't working. @christophernhill thoughts about that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-889996343
https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-889996343:539,Testability,benchmark,benchmark,539,"> @glwagner the multithreading benchmarks for the 2d shallow water model does not seem to have changed. It's roughly the same as those shown in #1861.; > ; > size	threads	slowdown	efficiency	memory	allocs; > (8192, 512)	1	1.0	1.0	1.0	1.0; > (8192, 1024)	2	1.98316	0.504246	12.1409	434.108; > (8192, 2048)	4	1.60839	0.621741	9.73477	331.135; > (8192, 4096)	8	1.52129	0.657337	10.2977	332.526; > (8192, 8192)	16	1.73345	0.576883	11.7069	340.188; > (8192, 16384)	32	2.26084	0.442313	17.1668	470.216; > I'm also running another multithreading benchmark right now with the 3d nonhydrostatic model. Hopefully the new CPU workgroup grouping will show up better there. Thanks @hennyg888 !. I don't understand the non-monotonic behavior. What could explain this? It smells funny... Does it make sense to run a strong scaling experiment as well to try to de-confuse the situation?. I wonder if we should actually precompute and store the thread-block layout in the `CPU` architecture type. That would allow us to more easily experiment with different layouts and also would allow users to tweak the layout if something wasn't working. @christophernhill thoughts about that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-889996343
https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-890008703:47,Testability,benchmark,benchmark,47,I just finished a strong scaling multithreaded benchmark with the nonhydrostatic model with grid size being 256 cubed.; I'll venture a wild guess and say that the weak scaling shallow water model's efficiency change is not monotonic due to smaller grid sizes not saturating the CPUs. Not sure if that's still a possible explanation when the grid size scales proportional to number of threads in weak scaling. Here are the strong scaling nonhydrostatic results. I'm currently working on converting the script to do weak scaling to see if a small grid size with too many threads is what's causing very low efficiencies towards the end.; <html>; <body>; <!--StartFragment-->. size | threads | slowdown | efficiency | memory | allocs; -- | -- | -- | -- | -- | --; 256 | 1 | 1.0 | 1.0 | 1.0 | 1.0; 256 | 2 | 0.992966 | 0.503542 | 4.14014 | 152.109; 256 | 4 | 0.501089 | 0.498913 | 2.17724 | 50.2532; 256 | 8 | 0.324366 | 0.385367 | 1.94899 | 29.191; 256 | 16 | 0.244788 | 0.255323 | 2.12262 | 18.2106; 256 | 32 | 0.263339 | 0.118668 | 2.87624 | 16.3167. <!--EndFragment-->; </body>; </html>,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-890008703
https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-890027183:49,Testability,benchmark,benchmark,49,"> I just finished a strong scaling multithreaded benchmark with the nonhydrostatic model with grid size being 256 cubed.; > I'll venture a wild guess and say that the weak scaling shallow water model's efficiency change is not monotonic due to smaller grid sizes not saturating the CPUs. Not sure if that's still a possible explanation when the grid size scales proportional to number of threads in weak scaling.; > ; > Here are the strong scaling nonhydrostatic results. I'm currently working on converting the script to do weak scaling to see if a small grid size with too many threads is what's causing very low efficiencies towards the end.; > ; > size	threads	slowdown	efficiency	memory	allocs; > 256	1	1.0	1.0	1.0	1.0; > 256	2	0.992966	0.503542	4.14014	152.109; > 256	4	0.501089	0.498913	2.17724	50.2532; > 256	8	0.324366	0.385367	1.94899	29.191; > 256	16	0.244788	0.255323	2.12262	18.2106; > 256	32	0.263339	0.118668	2.87624	16.3167. Excellent, nice results!. Same weird behavior --- the timing is identical from 1 to 2 threads; only at 4 threads do we get speed up (but its by a factor of 1/2 rather than 1/4). With 16 threads the model is 4x faster. Hmm... can we do better?. > Strange that strong scaling looks more monotonic than the weak scaling. True that the model doesn't actually _slow down_ from 1 to 2 threads. That would be crazy... As for problem size, I'd be surprised if the CPU isn't saturated. These are ""big"" by my metric, but maybe my metric isn't good...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-890027183
https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-890031307:101,Performance,tune,tune,101,Might have something to do with how many threads are running on how many physical cores. I'll try to tune how the threaded processes are launched and specify one thread per core more clearly. Hyperthreading seems to be what enables 2 threads to run on one core. There should be options to disable it either through slurm or julia.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-890031307
https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-890031307:183,Usability,clear,clearly,183,Might have something to do with how many threads are running on how many physical cores. I'll try to tune how the threaded processes are launched and specify one thread per core more clearly. Hyperthreading seems to be what enables 2 threads to run on one core. There should be options to disable it either through slurm or julia.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-890031307
https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-958088865:17,Performance,perform,performance,17,"Since there's no performance benefit, I'm closing this. We can revisit `heuristic_workgroup` in the future.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1902#issuecomment-958088865
https://github.com/CliMA/Oceananigans.jl/pull/1903#issuecomment-930278040:82,Deployability,release,release,82,@navidcy Yes sorry. Looks like tests are passing. Once they do I'll merge and tag/release v0.63.1.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1903#issuecomment-930278040
https://github.com/CliMA/Oceananigans.jl/pull/1903#issuecomment-930278040:31,Testability,test,tests,31,@navidcy Yes sorry. Looks like tests are passing. Once they do I'll merge and tag/release v0.63.1.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1903#issuecomment-930278040
https://github.com/CliMA/Oceananigans.jl/issues/1904#issuecomment-888606546:326,Energy Efficiency,efficient,efficient,326,> The difficulties I could perceive are that different grids require different calculations so we'd need to dispatch on grid type. I think this is ok. We can dispatch on _both_ the grid (and its associated coordinate system) and `typeof(coriolis)` to infer the Coriolis model. I think such a design is good because it is code-efficient.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1904#issuecomment-888606546
https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889189927:2134,Performance,perform,performs,2134,"d, apparently, ` = S_ij S_ij` (if we believe we understand the notation here):. https://github.com/CliMA/Oceananigans.jl/blob/32c5c5a2d0f441a4b663866d511807d0f9413c90/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl#L97. This means that our formula is identical to Pressel et al (2015), but the constant is wrong: Pressel proposes `Cs=0.17`, and we have a default of `Cs=0.23`:. https://github.com/CliMA/Oceananigans.jl/blob/32c5c5a2d0f441a4b663866d511807d0f9413c90/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl#L63-L64. Amusingly, . ```julia; julia> 0.165 * sqrt(2); 0.23334523779156072; ```. which is probably not a coincidence. However, I'm not sure how an extra factor of `sqrt(2)` snuck into our constant. As for _clarification_, I don't have much to offer. Perhaps the constant was taken from some reference that used a different formulation than either us or Pressel et al. 2015. Nobody has submitted a validation test for this closure so I don't think we know how it performs. As a historical note, the paper cited by both Pressel et al (2015) and us is Lilly (1962), which does indeed use the same formulation:. ![image](https://user-images.githubusercontent.com/15271942/127507507-c7d11dfc-733a-4472-8216-dca4e5844b3f.png). where. ![image](https://user-images.githubusercontent.com/15271942/127507737-94aa05d4-6fa5-4d38-9a9d-b1bbcc8a1e79.png). @tomchor I can't tell if the formula you've pasted is actually different from ours (or what the definition of `|S|` is). Where does it come from?. It'd be fine to change the constant because there's no validation test. So the best we can do is theorize, and theorization on this issue suggests changing the default to `C=0.17`. If one wanted to set up a validation test, it could be nice to reproduce [Compte-Bellot and Corrsin (1964)](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/abs/simple-eulerian-time-correlation-of-fulland-narrowband-velocity-si",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889189927
https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889189927:2069,Security,validat,validation,2069,"d, apparently, ` = S_ij S_ij` (if we believe we understand the notation here):. https://github.com/CliMA/Oceananigans.jl/blob/32c5c5a2d0f441a4b663866d511807d0f9413c90/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl#L97. This means that our formula is identical to Pressel et al (2015), but the constant is wrong: Pressel proposes `Cs=0.17`, and we have a default of `Cs=0.23`:. https://github.com/CliMA/Oceananigans.jl/blob/32c5c5a2d0f441a4b663866d511807d0f9413c90/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl#L63-L64. Amusingly, . ```julia; julia> 0.165 * sqrt(2); 0.23334523779156072; ```. which is probably not a coincidence. However, I'm not sure how an extra factor of `sqrt(2)` snuck into our constant. As for _clarification_, I don't have much to offer. Perhaps the constant was taken from some reference that used a different formulation than either us or Pressel et al. 2015. Nobody has submitted a validation test for this closure so I don't think we know how it performs. As a historical note, the paper cited by both Pressel et al (2015) and us is Lilly (1962), which does indeed use the same formulation:. ![image](https://user-images.githubusercontent.com/15271942/127507507-c7d11dfc-733a-4472-8216-dca4e5844b3f.png). where. ![image](https://user-images.githubusercontent.com/15271942/127507737-94aa05d4-6fa5-4d38-9a9d-b1bbcc8a1e79.png). @tomchor I can't tell if the formula you've pasted is actually different from ours (or what the definition of `|S|` is). Where does it come from?. It'd be fine to change the constant because there's no validation test. So the best we can do is theorize, and theorization on this issue suggests changing the default to `C=0.17`. If one wanted to set up a validation test, it could be nice to reproduce [Compte-Bellot and Corrsin (1964)](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/abs/simple-eulerian-time-correlation-of-fulland-narrowband-velocity-si",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889189927
https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889189927:2715,Security,validat,validation,2715,"`julia; julia> 0.165 * sqrt(2); 0.23334523779156072; ```. which is probably not a coincidence. However, I'm not sure how an extra factor of `sqrt(2)` snuck into our constant. As for _clarification_, I don't have much to offer. Perhaps the constant was taken from some reference that used a different formulation than either us or Pressel et al. 2015. Nobody has submitted a validation test for this closure so I don't think we know how it performs. As a historical note, the paper cited by both Pressel et al (2015) and us is Lilly (1962), which does indeed use the same formulation:. ![image](https://user-images.githubusercontent.com/15271942/127507507-c7d11dfc-733a-4472-8216-dca4e5844b3f.png). where. ![image](https://user-images.githubusercontent.com/15271942/127507737-94aa05d4-6fa5-4d38-9a9d-b1bbcc8a1e79.png). @tomchor I can't tell if the formula you've pasted is actually different from ours (or what the definition of `|S|` is). Where does it come from?. It'd be fine to change the constant because there's no validation test. So the best we can do is theorize, and theorization on this issue suggests changing the default to `C=0.17`. If one wanted to set up a validation test, it could be nice to reproduce [Compte-Bellot and Corrsin (1964)](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/abs/simple-eulerian-time-correlation-of-fulland-narrowband-velocity-signals-in-gridgenerated-isotropic-turbulence/A3D7B0DD621DE46CB6CC543F65A66F93) (this wasn't possible when the closures were written because we didn't support triply periodic domains, but is possible now). This could also be used to validate Anisotropic Minimum Dissipation. Here's a figure with such a comparison from [Rozema et al 2015](https://aip.scitation.org/doi/pdf/10.1063/1.4928700):. ![image](https://user-images.githubusercontent.com/15271942/127508527-e5f7d150-56c4-4949-ad8e-90d67fdbee64.png). I believe for shear flows it has also been found that the constant needs to be as small as `C=0.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889189927
https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889189927:2867,Security,validat,validation,2867," factor of `sqrt(2)` snuck into our constant. As for _clarification_, I don't have much to offer. Perhaps the constant was taken from some reference that used a different formulation than either us or Pressel et al. 2015. Nobody has submitted a validation test for this closure so I don't think we know how it performs. As a historical note, the paper cited by both Pressel et al (2015) and us is Lilly (1962), which does indeed use the same formulation:. ![image](https://user-images.githubusercontent.com/15271942/127507507-c7d11dfc-733a-4472-8216-dca4e5844b3f.png). where. ![image](https://user-images.githubusercontent.com/15271942/127507737-94aa05d4-6fa5-4d38-9a9d-b1bbcc8a1e79.png). @tomchor I can't tell if the formula you've pasted is actually different from ours (or what the definition of `|S|` is). Where does it come from?. It'd be fine to change the constant because there's no validation test. So the best we can do is theorize, and theorization on this issue suggests changing the default to `C=0.17`. If one wanted to set up a validation test, it could be nice to reproduce [Compte-Bellot and Corrsin (1964)](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/abs/simple-eulerian-time-correlation-of-fulland-narrowband-velocity-signals-in-gridgenerated-isotropic-turbulence/A3D7B0DD621DE46CB6CC543F65A66F93) (this wasn't possible when the closures were written because we didn't support triply periodic domains, but is possible now). This could also be used to validate Anisotropic Minimum Dissipation. Here's a figure with such a comparison from [Rozema et al 2015](https://aip.scitation.org/doi/pdf/10.1063/1.4928700):. ![image](https://user-images.githubusercontent.com/15271942/127508527-e5f7d150-56c4-4949-ad8e-90d67fdbee64.png). I believe for shear flows it has also been found that the constant needs to be as small as `C=0.1` or smaller? It'd be nice to mention and cite these in the docstring as well, if we can find those references. Hope that helps!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889189927
https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889189927:3325,Security,validat,validate,3325," factor of `sqrt(2)` snuck into our constant. As for _clarification_, I don't have much to offer. Perhaps the constant was taken from some reference that used a different formulation than either us or Pressel et al. 2015. Nobody has submitted a validation test for this closure so I don't think we know how it performs. As a historical note, the paper cited by both Pressel et al (2015) and us is Lilly (1962), which does indeed use the same formulation:. ![image](https://user-images.githubusercontent.com/15271942/127507507-c7d11dfc-733a-4472-8216-dca4e5844b3f.png). where. ![image](https://user-images.githubusercontent.com/15271942/127507737-94aa05d4-6fa5-4d38-9a9d-b1bbcc8a1e79.png). @tomchor I can't tell if the formula you've pasted is actually different from ours (or what the definition of `|S|` is). Where does it come from?. It'd be fine to change the constant because there's no validation test. So the best we can do is theorize, and theorization on this issue suggests changing the default to `C=0.17`. If one wanted to set up a validation test, it could be nice to reproduce [Compte-Bellot and Corrsin (1964)](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/abs/simple-eulerian-time-correlation-of-fulland-narrowband-velocity-signals-in-gridgenerated-isotropic-turbulence/A3D7B0DD621DE46CB6CC543F65A66F93) (this wasn't possible when the closures were written because we didn't support triply periodic domains, but is possible now). This could also be used to validate Anisotropic Minimum Dissipation. Here's a figure with such a comparison from [Rozema et al 2015](https://aip.scitation.org/doi/pdf/10.1063/1.4928700):. ![image](https://user-images.githubusercontent.com/15271942/127508527-e5f7d150-56c4-4949-ad8e-90d67fdbee64.png). I believe for shear flows it has also been found that the constant needs to be as small as `C=0.1` or smaller? It'd be nice to mention and cite these in the docstring as well, if we can find those references. Hope that helps!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889189927
https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889189927:2080,Testability,test,test,2080,"d, apparently, ` = S_ij S_ij` (if we believe we understand the notation here):. https://github.com/CliMA/Oceananigans.jl/blob/32c5c5a2d0f441a4b663866d511807d0f9413c90/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl#L97. This means that our formula is identical to Pressel et al (2015), but the constant is wrong: Pressel proposes `Cs=0.17`, and we have a default of `Cs=0.23`:. https://github.com/CliMA/Oceananigans.jl/blob/32c5c5a2d0f441a4b663866d511807d0f9413c90/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl#L63-L64. Amusingly, . ```julia; julia> 0.165 * sqrt(2); 0.23334523779156072; ```. which is probably not a coincidence. However, I'm not sure how an extra factor of `sqrt(2)` snuck into our constant. As for _clarification_, I don't have much to offer. Perhaps the constant was taken from some reference that used a different formulation than either us or Pressel et al. 2015. Nobody has submitted a validation test for this closure so I don't think we know how it performs. As a historical note, the paper cited by both Pressel et al (2015) and us is Lilly (1962), which does indeed use the same formulation:. ![image](https://user-images.githubusercontent.com/15271942/127507507-c7d11dfc-733a-4472-8216-dca4e5844b3f.png). where. ![image](https://user-images.githubusercontent.com/15271942/127507737-94aa05d4-6fa5-4d38-9a9d-b1bbcc8a1e79.png). @tomchor I can't tell if the formula you've pasted is actually different from ours (or what the definition of `|S|` is). Where does it come from?. It'd be fine to change the constant because there's no validation test. So the best we can do is theorize, and theorization on this issue suggests changing the default to `C=0.17`. If one wanted to set up a validation test, it could be nice to reproduce [Compte-Bellot and Corrsin (1964)](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/abs/simple-eulerian-time-correlation-of-fulland-narrowband-velocity-si",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889189927
https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889189927:2726,Testability,test,test,2726,"`julia; julia> 0.165 * sqrt(2); 0.23334523779156072; ```. which is probably not a coincidence. However, I'm not sure how an extra factor of `sqrt(2)` snuck into our constant. As for _clarification_, I don't have much to offer. Perhaps the constant was taken from some reference that used a different formulation than either us or Pressel et al. 2015. Nobody has submitted a validation test for this closure so I don't think we know how it performs. As a historical note, the paper cited by both Pressel et al (2015) and us is Lilly (1962), which does indeed use the same formulation:. ![image](https://user-images.githubusercontent.com/15271942/127507507-c7d11dfc-733a-4472-8216-dca4e5844b3f.png). where. ![image](https://user-images.githubusercontent.com/15271942/127507737-94aa05d4-6fa5-4d38-9a9d-b1bbcc8a1e79.png). @tomchor I can't tell if the formula you've pasted is actually different from ours (or what the definition of `|S|` is). Where does it come from?. It'd be fine to change the constant because there's no validation test. So the best we can do is theorize, and theorization on this issue suggests changing the default to `C=0.17`. If one wanted to set up a validation test, it could be nice to reproduce [Compte-Bellot and Corrsin (1964)](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/abs/simple-eulerian-time-correlation-of-fulland-narrowband-velocity-signals-in-gridgenerated-isotropic-turbulence/A3D7B0DD621DE46CB6CC543F65A66F93) (this wasn't possible when the closures were written because we didn't support triply periodic domains, but is possible now). This could also be used to validate Anisotropic Minimum Dissipation. Here's a figure with such a comparison from [Rozema et al 2015](https://aip.scitation.org/doi/pdf/10.1063/1.4928700):. ![image](https://user-images.githubusercontent.com/15271942/127508527-e5f7d150-56c4-4949-ad8e-90d67fdbee64.png). I believe for shear flows it has also been found that the constant needs to be as small as `C=0.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889189927
https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889189927:2878,Testability,test,test,2878," factor of `sqrt(2)` snuck into our constant. As for _clarification_, I don't have much to offer. Perhaps the constant was taken from some reference that used a different formulation than either us or Pressel et al. 2015. Nobody has submitted a validation test for this closure so I don't think we know how it performs. As a historical note, the paper cited by both Pressel et al (2015) and us is Lilly (1962), which does indeed use the same formulation:. ![image](https://user-images.githubusercontent.com/15271942/127507507-c7d11dfc-733a-4472-8216-dca4e5844b3f.png). where. ![image](https://user-images.githubusercontent.com/15271942/127507737-94aa05d4-6fa5-4d38-9a9d-b1bbcc8a1e79.png). @tomchor I can't tell if the formula you've pasted is actually different from ours (or what the definition of `|S|` is). Where does it come from?. It'd be fine to change the constant because there's no validation test. So the best we can do is theorize, and theorization on this issue suggests changing the default to `C=0.17`. If one wanted to set up a validation test, it could be nice to reproduce [Compte-Bellot and Corrsin (1964)](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/abs/simple-eulerian-time-correlation-of-fulland-narrowband-velocity-signals-in-gridgenerated-isotropic-turbulence/A3D7B0DD621DE46CB6CC543F65A66F93) (this wasn't possible when the closures were written because we didn't support triply periodic domains, but is possible now). This could also be used to validate Anisotropic Minimum Dissipation. Here's a figure with such a comparison from [Rozema et al 2015](https://aip.scitation.org/doi/pdf/10.1063/1.4928700):. ![image](https://user-images.githubusercontent.com/15271942/127508527-e5f7d150-56c4-4949-ad8e-90d67fdbee64.png). I believe for shear flows it has also been found that the constant needs to be as small as `C=0.1` or smaller? It'd be nice to mention and cite these in the docstring as well, if we can find those references. Hope that helps!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889189927
https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889189927:3028,Usability,simpl,simple-eulerian-time-correlation-of-fulland-narrowband-velocity-signals-in-gridgenerated-isotropic-turbulence,3028," factor of `sqrt(2)` snuck into our constant. As for _clarification_, I don't have much to offer. Perhaps the constant was taken from some reference that used a different formulation than either us or Pressel et al. 2015. Nobody has submitted a validation test for this closure so I don't think we know how it performs. As a historical note, the paper cited by both Pressel et al (2015) and us is Lilly (1962), which does indeed use the same formulation:. ![image](https://user-images.githubusercontent.com/15271942/127507507-c7d11dfc-733a-4472-8216-dca4e5844b3f.png). where. ![image](https://user-images.githubusercontent.com/15271942/127507737-94aa05d4-6fa5-4d38-9a9d-b1bbcc8a1e79.png). @tomchor I can't tell if the formula you've pasted is actually different from ours (or what the definition of `|S|` is). Where does it come from?. It'd be fine to change the constant because there's no validation test. So the best we can do is theorize, and theorization on this issue suggests changing the default to `C=0.17`. If one wanted to set up a validation test, it could be nice to reproduce [Compte-Bellot and Corrsin (1964)](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/abs/simple-eulerian-time-correlation-of-fulland-narrowband-velocity-signals-in-gridgenerated-isotropic-turbulence/A3D7B0DD621DE46CB6CC543F65A66F93) (this wasn't possible when the closures were written because we didn't support triply periodic domains, but is possible now). This could also be used to validate Anisotropic Minimum Dissipation. Here's a figure with such a comparison from [Rozema et al 2015](https://aip.scitation.org/doi/pdf/10.1063/1.4928700):. ![image](https://user-images.githubusercontent.com/15271942/127508527-e5f7d150-56c4-4949-ad8e-90d67fdbee64.png). I believe for shear flows it has also been found that the constant needs to be as small as `C=0.1` or smaller? It'd be nice to mention and cite these in the docstring as well, if we can find those references. Hope that helps!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889189927
https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889239321:434,Security,validat,validation,434,"> @tomchor I can't tell if the formula you've pasted is actually different from ours (or what the definition of |S| is). Where does it come from?. That was my bad, forgot to cite the source. It comes from [Chamecki et al. 2019](https://agupubs.onlinelibrary.wiley.com/doi/abs/10.1029/2019RG000655). But you're right that the definition is identical. I misinterpreted the code. > It'd be fine to change the constant because there's no validation test. I indeed think we should change constant default to match the most common value used in the literature. I'd also like to change the notation used in the code from `` to `\Upsilon`, so as to match [the docs](https://clima.github.io/OceananigansDocumentation/stable/physics/turbulence_closures/) (just to make the code easier for contributors). I'll open a PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889239321
https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889239321:445,Testability,test,test,445,"> @tomchor I can't tell if the formula you've pasted is actually different from ours (or what the definition of |S| is). Where does it come from?. That was my bad, forgot to cite the source. It comes from [Chamecki et al. 2019](https://agupubs.onlinelibrary.wiley.com/doi/abs/10.1029/2019RG000655). But you're right that the definition is identical. I misinterpreted the code. > It'd be fine to change the constant because there's no validation test. I indeed think we should change constant default to match the most common value used in the literature. I'd also like to change the notation used in the code from `` to `\Upsilon`, so as to match [the docs](https://clima.github.io/OceananigansDocumentation/stable/physics/turbulence_closures/) (just to make the code easier for contributors). I'll open a PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889239321
https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889254094:15,Deployability,update,update,15,"Sounds good to update the code! Perhaps we should also add a warning or note of some kind about the lack of validation (we've taken to doing this recently and I think it's a good thing). @navidcy would be happy not to use ``!. `\Upsilon` is disturbingly similar to ""Y"":. ```julia; julia>  = 1; 1; ```. maybe there's a better choice? We could also change the docs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889254094
https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889254094:108,Security,validat,validation,108,"Sounds good to update the code! Perhaps we should also add a warning or note of some kind about the lack of validation (we've taken to doing this recently and I think it's a good thing). @navidcy would be happy not to use ``!. `\Upsilon` is disturbingly similar to ""Y"":. ```julia; julia>  = 1; 1; ```. maybe there's a better choice? We could also change the docs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889254094
https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889257253:17,Deployability,update,update,17,"> Sounds good to update the code! Perhaps we should also add a warning or note of some kind about the lack of validation (we've taken to doing this recently and I think it's a good thing).; > ; > @navidcy would be happy not to use ``!; > ; > `\Upsilon` is disturbingly similar to ""Y"":; > ; > ```julia; > julia>  = 1; > 1; > ```; > ; > maybe there's a better choice? We could also change the docs. Yeah, and I ended up realizing the same thing. I changed the docs instead.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889257253
https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889257253:110,Security,validat,validation,110,"> Sounds good to update the code! Perhaps we should also add a warning or note of some kind about the lack of validation (we've taken to doing this recently and I think it's a good thing).; > ; > @navidcy would be happy not to use ``!; > ; > `\Upsilon` is disturbingly similar to ""Y"":; > ; > ```julia; > julia>  = 1; > 1; > ```; > ; > maybe there's a better choice? We could also change the docs. Yeah, and I ended up realizing the same thing. I changed the docs instead.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1907#issuecomment-889257253
https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889288420:202,Modifiability,variab,variable,202,"I made one extra change which is that I don't call `N^2 / S^2` a Richardson number anymore. Since the denominator is a strain rate, not the _vertical_ shear, I think it's odd to call it `Ri`. Also that variable (whatever you call it) only appears 3 times briefly so there's no need to give it a name. It appears that our buoyancy modification doesn't really match Pressel's or Lilly's since we use an arbitrary `C_b` while they proposed to use `1/Pr_t`. @glwagner Is there any reference for that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889288420
https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889293513:185,Energy Efficiency,energy,energy,185,"I don't mind if we call it ""Ri"" or not. The Richardson number has several interpretations and formulations; one interpretation is that it generally measures the ratio between potential energy and kinetic energy in the flow (this physical interpretation motivates its use in the ""stability correction"" proposed by Lilly 1962). The ""rate of strain definition"" limits to the ""typical"" oceanographic definition (also the quantity that arises in Kelvin-Helmholtz instability) for parallel laminar flow. Lilly 1962 used ""Richardson number"" and the symbol ""Ri"" to refer to this quantity:. ![image](https://user-images.githubusercontent.com/15271942/127530131-043ec421-8d7b-4420-9d75-5fd5aed36af3.png). For me, it's a natural generalization of the Richarsdon number that applies in unidirectional / laminar flow, so I feel it's nice notation. But not using it is ok too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889293513
https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889293513:204,Energy Efficiency,energy,energy,204,"I don't mind if we call it ""Ri"" or not. The Richardson number has several interpretations and formulations; one interpretation is that it generally measures the ratio between potential energy and kinetic energy in the flow (this physical interpretation motivates its use in the ""stability correction"" proposed by Lilly 1962). The ""rate of strain definition"" limits to the ""typical"" oceanographic definition (also the quantity that arises in Kelvin-Helmholtz instability) for parallel laminar flow. Lilly 1962 used ""Richardson number"" and the symbol ""Ri"" to refer to this quantity:. ![image](https://user-images.githubusercontent.com/15271942/127530131-043ec421-8d7b-4420-9d75-5fd5aed36af3.png). For me, it's a natural generalization of the Richarsdon number that applies in unidirectional / laminar flow, so I feel it's nice notation. But not using it is ok too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889293513
https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889295372:204,Modifiability,variab,variable,204,"> I made one extra change which is that I don't call `N^2 / S^2` a Richardson number anymore. Since the denominator is a strain rate, not the _vertical_ shear, I think it's odd to call it `Ri`. Also that variable (whatever you call it) only appears 3 times briefly so there's no need to give it a name.; > ; > It appears that our buoyancy modification doesn't really match Pressel's or Lilly's since we use an arbitrary `C_b` while they proposed to use `1/Pr_t`. @glwagner Is there any reference for that?. I don't quite understand the question --- what would you like a reference for?. It looks like for `Cb=0`, the reference is the original Smagorinsky paper, whereas for `Cb=1/Pr` one uses the model proposed by Lilly (1962). A number in between represents something different from either --- are you wondering if there are papers out there that have used `Cb` other than 0 or `1/Pr`? As to that I don't know. We could change the default from `Cb=1` to `Cb=1/Pr` or `Cb=0`... ? The default `Pr` is `Pr=1` but I suppose one might inadvertently change `Pr` but leave `Cb=1` which would lead to a different LES model than proposed by Lilly (1962).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889295372
https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889307399:206,Modifiability,variab,variable,206,"> > I made one extra change which is that I don't call `N^2 / S^2` a Richardson number anymore. Since the denominator is a strain rate, not the _vertical_ shear, I think it's odd to call it `Ri`. Also that variable (whatever you call it) only appears 3 times briefly so there's no need to give it a name.; > > It appears that our buoyancy modification doesn't really match Pressel's or Lilly's since we use an arbitrary `C_b` while they proposed to use `1/Pr_t`. @glwagner Is there any reference for that?; > ; > I don't quite understand the question --- what would you like a reference for?; > ; > It looks like for `Cb=0`, the reference is the original Smagorinsky paper, whereas for `Cb=1/Pr` one uses the model proposed by Lilly (1962). A number in between represents something different from either --- are you wondering if there are papers out there that have used `Cb` other than 0 or `1/Pr`? As to that I don't know.; > ; > We could change the default from `Cb=1` to `Cb=1/Pr` or `Cb=0`... ? The default `Pr` is `Pr=1` but I suppose one might inadvertently change `Pr` but leave `Cb=1` which would lead to a different LES model than proposed by Lilly (1962). Apparently my explanation wasn't needed! Yes, that's what I mean. I propose we either get rid of `C_b` and just use `1/Pr_t` or make it clear in the docs and docstring that we offer an extra degree of freedom, but that the model as proposed has `C_b=1/Pr_t`. I'm not sure which one is best since I do like the idea of Oceananigans allowing for easy (customization), but also that favors mistakes by un-attentive users (such as myself haha).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889307399
https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889307399:1303,Usability,clear,clear,1303,"> > I made one extra change which is that I don't call `N^2 / S^2` a Richardson number anymore. Since the denominator is a strain rate, not the _vertical_ shear, I think it's odd to call it `Ri`. Also that variable (whatever you call it) only appears 3 times briefly so there's no need to give it a name.; > > It appears that our buoyancy modification doesn't really match Pressel's or Lilly's since we use an arbitrary `C_b` while they proposed to use `1/Pr_t`. @glwagner Is there any reference for that?; > ; > I don't quite understand the question --- what would you like a reference for?; > ; > It looks like for `Cb=0`, the reference is the original Smagorinsky paper, whereas for `Cb=1/Pr` one uses the model proposed by Lilly (1962). A number in between represents something different from either --- are you wondering if there are papers out there that have used `Cb` other than 0 or `1/Pr`? As to that I don't know.; > ; > We could change the default from `Cb=1` to `Cb=1/Pr` or `Cb=0`... ? The default `Pr` is `Pr=1` but I suppose one might inadvertently change `Pr` but leave `Cb=1` which would lead to a different LES model than proposed by Lilly (1962). Apparently my explanation wasn't needed! Yes, that's what I mean. I propose we either get rid of `C_b` and just use `1/Pr_t` or make it clear in the docs and docstring that we offer an extra degree of freedom, but that the model as proposed has `C_b=1/Pr_t`. I'm not sure which one is best since I do like the idea of Oceananigans allowing for easy (customization), but also that favors mistakes by un-attentive users (such as myself haha).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889307399
https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889331619:751,Availability,down,downside,751,"It seems like [these tests](https://buildkite.com/clima/oceananigans/builds/3559#6c943ada-d478-430c-b154-31160f8a3c3d) are failing because they compare the LES models with some pre-computed solutions: https://github.com/CliMA/Oceananigans.jl/blob/32c5c5a2d0f441a4b663866d511807d0f9413c90/test/regression_tests/ocean_large_eddy_simulation_regression_test.jl#L78. ~If I followed the code correctly, the LES models are looped through here: https://github.com/CliMA/Oceananigans.jl/blob/32c5c5a2d0f441a4b663866d511807d0f9413c90/test/test_turbulence_closures.jl#L4-L8~. ~which means that those are always run with the default values. Since we're comparing with pre-computed solutions, it'd be good to explicitly specify every closure's parameters, no? The downside is that we won't be able to automatically loop through th closure like this and have to specify them by hand.~",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889331619
https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889331619:21,Testability,test,tests,21,"It seems like [these tests](https://buildkite.com/clima/oceananigans/builds/3559#6c943ada-d478-430c-b154-31160f8a3c3d) are failing because they compare the LES models with some pre-computed solutions: https://github.com/CliMA/Oceananigans.jl/blob/32c5c5a2d0f441a4b663866d511807d0f9413c90/test/regression_tests/ocean_large_eddy_simulation_regression_test.jl#L78. ~If I followed the code correctly, the LES models are looped through here: https://github.com/CliMA/Oceananigans.jl/blob/32c5c5a2d0f441a4b663866d511807d0f9413c90/test/test_turbulence_closures.jl#L4-L8~. ~which means that those are always run with the default values. Since we're comparing with pre-computed solutions, it'd be good to explicitly specify every closure's parameters, no? The downside is that we won't be able to automatically loop through th closure like this and have to specify them by hand.~",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889331619
https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889331619:288,Testability,test,test,288,"It seems like [these tests](https://buildkite.com/clima/oceananigans/builds/3559#6c943ada-d478-430c-b154-31160f8a3c3d) are failing because they compare the LES models with some pre-computed solutions: https://github.com/CliMA/Oceananigans.jl/blob/32c5c5a2d0f441a4b663866d511807d0f9413c90/test/regression_tests/ocean_large_eddy_simulation_regression_test.jl#L78. ~If I followed the code correctly, the LES models are looped through here: https://github.com/CliMA/Oceananigans.jl/blob/32c5c5a2d0f441a4b663866d511807d0f9413c90/test/test_turbulence_closures.jl#L4-L8~. ~which means that those are always run with the default values. Since we're comparing with pre-computed solutions, it'd be good to explicitly specify every closure's parameters, no? The downside is that we won't be able to automatically loop through th closure like this and have to specify them by hand.~",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889331619
https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889331619:524,Testability,test,test,524,"It seems like [these tests](https://buildkite.com/clima/oceananigans/builds/3559#6c943ada-d478-430c-b154-31160f8a3c3d) are failing because they compare the LES models with some pre-computed solutions: https://github.com/CliMA/Oceananigans.jl/blob/32c5c5a2d0f441a4b663866d511807d0f9413c90/test/regression_tests/ocean_large_eddy_simulation_regression_test.jl#L78. ~If I followed the code correctly, the LES models are looped through here: https://github.com/CliMA/Oceananigans.jl/blob/32c5c5a2d0f441a4b663866d511807d0f9413c90/test/test_turbulence_closures.jl#L4-L8~. ~which means that those are always run with the default values. Since we're comparing with pre-computed solutions, it'd be good to explicitly specify every closure's parameters, no? The downside is that we won't be able to automatically loop through th closure like this and have to specify them by hand.~",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889331619
https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889333799:1494,Availability,error,error,1494,"> So it seems that our model has an extra degree of freedom that neither Lilly nor Pressel propose. Quite! Though Lilly admits that his model amounts to ""little more than a scaling argument"" and that both `Pr_t` and the model ""constant"" are themselves unknown functions. So I actually think there is room to interpret Lilly as proposing a whole family of models. Since time is finite only one has been tested I guess (and also the structure of the model is questionable, so people have moved on to other formulations...). > I propose we either get rid of `C_b` and just use `1/Pr_t` or make it clear in the docs and docstring that we offer an extra degree of freedom, but that the model as proposed has `C_b=1/Pr_t`. I'm not sure which one is best since I do like the idea of Oceananigans allowing for easy (customization), but also that favors mistakes by un-attentive users (such as myself haha). Does the default `Cb = 1/Pr` both retain flexibility and also reduce the chances of unexpected behavior / mistakes?. If we get rid of `Cb` then we may want to introduce an alternative way to eliminate the buoyancy correction entirely (currently achievable with `Cb=0`). A further caveat is that using `1/Pr` only applies if `Pr` is the same for all tracers and if a linear equation of state links tracers to buoyancy. With nonlinear equations of state it's unclear what to use for `Cb`. I believe we also allow a different `Pr` for every tracer. In this case the default `Cb=1/Pr` will throw an error (probably a good thing, since you'd have to decide what to use for `Cb` in this case).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889333799
https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889333799:961,Energy Efficiency,reduce,reduce,961,"> So it seems that our model has an extra degree of freedom that neither Lilly nor Pressel propose. Quite! Though Lilly admits that his model amounts to ""little more than a scaling argument"" and that both `Pr_t` and the model ""constant"" are themselves unknown functions. So I actually think there is room to interpret Lilly as proposing a whole family of models. Since time is finite only one has been tested I guess (and also the structure of the model is questionable, so people have moved on to other formulations...). > I propose we either get rid of `C_b` and just use `1/Pr_t` or make it clear in the docs and docstring that we offer an extra degree of freedom, but that the model as proposed has `C_b=1/Pr_t`. I'm not sure which one is best since I do like the idea of Oceananigans allowing for easy (customization), but also that favors mistakes by un-attentive users (such as myself haha). Does the default `Cb = 1/Pr` both retain flexibility and also reduce the chances of unexpected behavior / mistakes?. If we get rid of `Cb` then we may want to introduce an alternative way to eliminate the buoyancy correction entirely (currently achievable with `Cb=0`). A further caveat is that using `1/Pr` only applies if `Pr` is the same for all tracers and if a linear equation of state links tracers to buoyancy. With nonlinear equations of state it's unclear what to use for `Cb`. I believe we also allow a different `Pr` for every tracer. In this case the default `Cb=1/Pr` will throw an error (probably a good thing, since you'd have to decide what to use for `Cb` in this case).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889333799
https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889333799:402,Testability,test,tested,402,"> So it seems that our model has an extra degree of freedom that neither Lilly nor Pressel propose. Quite! Though Lilly admits that his model amounts to ""little more than a scaling argument"" and that both `Pr_t` and the model ""constant"" are themselves unknown functions. So I actually think there is room to interpret Lilly as proposing a whole family of models. Since time is finite only one has been tested I guess (and also the structure of the model is questionable, so people have moved on to other formulations...). > I propose we either get rid of `C_b` and just use `1/Pr_t` or make it clear in the docs and docstring that we offer an extra degree of freedom, but that the model as proposed has `C_b=1/Pr_t`. I'm not sure which one is best since I do like the idea of Oceananigans allowing for easy (customization), but also that favors mistakes by un-attentive users (such as myself haha). Does the default `Cb = 1/Pr` both retain flexibility and also reduce the chances of unexpected behavior / mistakes?. If we get rid of `Cb` then we may want to introduce an alternative way to eliminate the buoyancy correction entirely (currently achievable with `Cb=0`). A further caveat is that using `1/Pr` only applies if `Pr` is the same for all tracers and if a linear equation of state links tracers to buoyancy. With nonlinear equations of state it's unclear what to use for `Cb`. I believe we also allow a different `Pr` for every tracer. In this case the default `Cb=1/Pr` will throw an error (probably a good thing, since you'd have to decide what to use for `Cb` in this case).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889333799
https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889333799:594,Usability,clear,clear,594,"> So it seems that our model has an extra degree of freedom that neither Lilly nor Pressel propose. Quite! Though Lilly admits that his model amounts to ""little more than a scaling argument"" and that both `Pr_t` and the model ""constant"" are themselves unknown functions. So I actually think there is room to interpret Lilly as proposing a whole family of models. Since time is finite only one has been tested I guess (and also the structure of the model is questionable, so people have moved on to other formulations...). > I propose we either get rid of `C_b` and just use `1/Pr_t` or make it clear in the docs and docstring that we offer an extra degree of freedom, but that the model as proposed has `C_b=1/Pr_t`. I'm not sure which one is best since I do like the idea of Oceananigans allowing for easy (customization), but also that favors mistakes by un-attentive users (such as myself haha). Does the default `Cb = 1/Pr` both retain flexibility and also reduce the chances of unexpected behavior / mistakes?. If we get rid of `Cb` then we may want to introduce an alternative way to eliminate the buoyancy correction entirely (currently achievable with `Cb=0`). A further caveat is that using `1/Pr` only applies if `Pr` is the same for all tracers and if a linear equation of state links tracers to buoyancy. With nonlinear equations of state it's unclear what to use for `Cb`. I believe we also allow a different `Pr` for every tracer. In this case the default `Cb=1/Pr` will throw an error (probably a good thing, since you'd have to decide what to use for `Cb` in this case).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889333799
https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889334946:780,Availability,down,downside,780,"> It seems like [these tests](https://buildkite.com/clima/oceananigans/builds/3559#6c943ada-d478-430c-b154-31160f8a3c3d) are failing because they compare the LES models with some pre-computed solutions:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/32c5c5a2d0f441a4b663866d511807d0f9413c90/test/regression_tests/ocean_large_eddy_simulation_regression_test.jl#L78; > ; > ~If I followed the code correctly, the LES models are looped through here: ~; > ; > https://github.com/CliMA/Oceananigans.jl/blob/32c5c5a2d0f441a4b663866d511807d0f9413c90/test/test_turbulence_closures.jl#L4-L8; > ; > ~which means that those are always run with the default values. Since we're comparing with pre-computed solutions, it'd be good to explicitly specify every closure's parameters, no? The downside is that we won't be able to automatically loop through th closure like this and have to specify them by hand.~. True, we have to regenerate the test data to make this change to the default if we want to continue using the default in the regression test. As a quick fix we could change the regression test to use `C=0.23`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889334946
https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889334946:23,Testability,test,tests,23,"> It seems like [these tests](https://buildkite.com/clima/oceananigans/builds/3559#6c943ada-d478-430c-b154-31160f8a3c3d) are failing because they compare the LES models with some pre-computed solutions:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/32c5c5a2d0f441a4b663866d511807d0f9413c90/test/regression_tests/ocean_large_eddy_simulation_regression_test.jl#L78; > ; > ~If I followed the code correctly, the LES models are looped through here: ~; > ; > https://github.com/CliMA/Oceananigans.jl/blob/32c5c5a2d0f441a4b663866d511807d0f9413c90/test/test_turbulence_closures.jl#L4-L8; > ; > ~which means that those are always run with the default values. Since we're comparing with pre-computed solutions, it'd be good to explicitly specify every closure's parameters, no? The downside is that we won't be able to automatically loop through th closure like this and have to specify them by hand.~. True, we have to regenerate the test data to make this change to the default if we want to continue using the default in the regression test. As a quick fix we could change the regression test to use `C=0.23`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889334946
https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889334946:297,Testability,test,test,297,"> It seems like [these tests](https://buildkite.com/clima/oceananigans/builds/3559#6c943ada-d478-430c-b154-31160f8a3c3d) are failing because they compare the LES models with some pre-computed solutions:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/32c5c5a2d0f441a4b663866d511807d0f9413c90/test/regression_tests/ocean_large_eddy_simulation_regression_test.jl#L78; > ; > ~If I followed the code correctly, the LES models are looped through here: ~; > ; > https://github.com/CliMA/Oceananigans.jl/blob/32c5c5a2d0f441a4b663866d511807d0f9413c90/test/test_turbulence_closures.jl#L4-L8; > ; > ~which means that those are always run with the default values. Since we're comparing with pre-computed solutions, it'd be good to explicitly specify every closure's parameters, no? The downside is that we won't be able to automatically loop through th closure like this and have to specify them by hand.~. True, we have to regenerate the test data to make this change to the default if we want to continue using the default in the regression test. As a quick fix we could change the regression test to use `C=0.23`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889334946
https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889334946:548,Testability,test,test,548,"> It seems like [these tests](https://buildkite.com/clima/oceananigans/builds/3559#6c943ada-d478-430c-b154-31160f8a3c3d) are failing because they compare the LES models with some pre-computed solutions:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/32c5c5a2d0f441a4b663866d511807d0f9413c90/test/regression_tests/ocean_large_eddy_simulation_regression_test.jl#L78; > ; > ~If I followed the code correctly, the LES models are looped through here: ~; > ; > https://github.com/CliMA/Oceananigans.jl/blob/32c5c5a2d0f441a4b663866d511807d0f9413c90/test/test_turbulence_closures.jl#L4-L8; > ; > ~which means that those are always run with the default values. Since we're comparing with pre-computed solutions, it'd be good to explicitly specify every closure's parameters, no? The downside is that we won't be able to automatically loop through th closure like this and have to specify them by hand.~. True, we have to regenerate the test data to make this change to the default if we want to continue using the default in the regression test. As a quick fix we could change the regression test to use `C=0.23`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889334946
https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889334946:933,Testability,test,test,933,"> It seems like [these tests](https://buildkite.com/clima/oceananigans/builds/3559#6c943ada-d478-430c-b154-31160f8a3c3d) are failing because they compare the LES models with some pre-computed solutions:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/32c5c5a2d0f441a4b663866d511807d0f9413c90/test/regression_tests/ocean_large_eddy_simulation_regression_test.jl#L78; > ; > ~If I followed the code correctly, the LES models are looped through here: ~; > ; > https://github.com/CliMA/Oceananigans.jl/blob/32c5c5a2d0f441a4b663866d511807d0f9413c90/test/test_turbulence_closures.jl#L4-L8; > ; > ~which means that those are always run with the default values. Since we're comparing with pre-computed solutions, it'd be good to explicitly specify every closure's parameters, no? The downside is that we won't be able to automatically loop through th closure like this and have to specify them by hand.~. True, we have to regenerate the test data to make this change to the default if we want to continue using the default in the regression test. As a quick fix we could change the regression test to use `C=0.23`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889334946
https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889334946:1037,Testability,test,test,1037,"> It seems like [these tests](https://buildkite.com/clima/oceananigans/builds/3559#6c943ada-d478-430c-b154-31160f8a3c3d) are failing because they compare the LES models with some pre-computed solutions:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/32c5c5a2d0f441a4b663866d511807d0f9413c90/test/regression_tests/ocean_large_eddy_simulation_regression_test.jl#L78; > ; > ~If I followed the code correctly, the LES models are looped through here: ~; > ; > https://github.com/CliMA/Oceananigans.jl/blob/32c5c5a2d0f441a4b663866d511807d0f9413c90/test/test_turbulence_closures.jl#L4-L8; > ; > ~which means that those are always run with the default values. Since we're comparing with pre-computed solutions, it'd be good to explicitly specify every closure's parameters, no? The downside is that we won't be able to automatically loop through th closure like this and have to specify them by hand.~. True, we have to regenerate the test data to make this change to the default if we want to continue using the default in the regression test. As a quick fix we could change the regression test to use `C=0.23`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889334946
https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889334946:1089,Testability,test,test,1089,"> It seems like [these tests](https://buildkite.com/clima/oceananigans/builds/3559#6c943ada-d478-430c-b154-31160f8a3c3d) are failing because they compare the LES models with some pre-computed solutions:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/32c5c5a2d0f441a4b663866d511807d0f9413c90/test/regression_tests/ocean_large_eddy_simulation_regression_test.jl#L78; > ; > ~If I followed the code correctly, the LES models are looped through here: ~; > ; > https://github.com/CliMA/Oceananigans.jl/blob/32c5c5a2d0f441a4b663866d511807d0f9413c90/test/test_turbulence_closures.jl#L4-L8; > ; > ~which means that those are always run with the default values. Since we're comparing with pre-computed solutions, it'd be good to explicitly specify every closure's parameters, no? The downside is that we won't be able to automatically loop through th closure like this and have to specify them by hand.~. True, we have to regenerate the test data to make this change to the default if we want to continue using the default in the regression test. As a quick fix we could change the regression test to use `C=0.23`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889334946
https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889335843:610,Availability,error,error,610,"> Does the default `Cb = 1/Pr` both retain flexibility and also reduce the chances of unexpected behavior / mistakes?; > ; > If we get rid of `Cb` then we may want to introduce an alternative way to eliminate the buoyancy correction entirely (currently achievable with `Cb=0`).; > ; > A further caveat is that using `1/Pr` only applies if `Pr` is the same for all tracers and if a linear equation of state links tracers to buoyancy. With nonlinear equations of state it's unclear what to use for `Cb`. I believe we also allow a different `Pr` for every tracer. In this case the default `Cb=1/Pr` will throw an error (probably a good thing, since you'd have to decide what to use for `Cb` in this case). Good points. Based on these points I'd argue for us to keep things as it is but include a comment about this in the docstring / docs. Agreed?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889335843
https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889335843:64,Energy Efficiency,reduce,reduce,64,"> Does the default `Cb = 1/Pr` both retain flexibility and also reduce the chances of unexpected behavior / mistakes?; > ; > If we get rid of `Cb` then we may want to introduce an alternative way to eliminate the buoyancy correction entirely (currently achievable with `Cb=0`).; > ; > A further caveat is that using `1/Pr` only applies if `Pr` is the same for all tracers and if a linear equation of state links tracers to buoyancy. With nonlinear equations of state it's unclear what to use for `Cb`. I believe we also allow a different `Pr` for every tracer. In this case the default `Cb=1/Pr` will throw an error (probably a good thing, since you'd have to decide what to use for `Cb` in this case). Good points. Based on these points I'd argue for us to keep things as it is but include a comment about this in the docstring / docs. Agreed?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889335843
https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889336429:50,Testability,test,test,50,You can change the closure used in the regression test by changing this line:. https://github.com/CliMA/Oceananigans.jl/blob/32c5c5a2d0f441a4b663866d511807d0f9413c90/test/test_regression.jl#L74,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889336429
https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889336429:166,Testability,test,test,166,You can change the closure used in the regression test by changing this line:. https://github.com/CliMA/Oceananigans.jl/blob/32c5c5a2d0f441a4b663866d511807d0f9413c90/test/test_regression.jl#L74,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889336429
https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889336673:52,Testability,test,test,52,> You can change the closure used in the regression test by changing this line:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/32c5c5a2d0f441a4b663866d511807d0f9413c90/test/test_regression.jl#L74. Just did 2 min ago :),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889336673
https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889336673:174,Testability,test,test,174,> You can change the closure used in the regression test by changing this line:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/32c5c5a2d0f441a4b663866d511807d0f9413c90/test/test_regression.jl#L74. Just did 2 min ago :),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889336673
https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889336992:608,Availability,error,error,608,"> > Does the default `Cb = 1/Pr` both retain flexibility and also reduce the chances of unexpected behavior / mistakes?; > > If we get rid of `Cb` then we may want to introduce an alternative way to eliminate the buoyancy correction entirely (currently achievable with `Cb=0`).; > > A further caveat is that using `1/Pr` only applies if `Pr` is the same for all tracers and if a linear equation of state links tracers to buoyancy. With nonlinear equations of state it's unclear what to use for `Cb`. I believe we also allow a different `Pr` for every tracer. In this case the default `Cb=1/Pr` will throw an error (probably a good thing, since you'd have to decide what to use for `Cb` in this case).; > ; > Good points. Based on these points I'd argue for us to keep things as it is but include a comment about this in the docstring / docs.; > ; > Agreed?. Fine by me. I also think `Cb=1/Pr` would be a good choice and retains current defaults.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889336992
https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889336992:66,Energy Efficiency,reduce,reduce,66,"> > Does the default `Cb = 1/Pr` both retain flexibility and also reduce the chances of unexpected behavior / mistakes?; > > If we get rid of `Cb` then we may want to introduce an alternative way to eliminate the buoyancy correction entirely (currently achievable with `Cb=0`).; > > A further caveat is that using `1/Pr` only applies if `Pr` is the same for all tracers and if a linear equation of state links tracers to buoyancy. With nonlinear equations of state it's unclear what to use for `Cb`. I believe we also allow a different `Pr` for every tracer. In this case the default `Cb=1/Pr` will throw an error (probably a good thing, since you'd have to decide what to use for `Cb` in this case).; > ; > Good points. Based on these points I'd argue for us to keep things as it is but include a comment about this in the docstring / docs.; > ; > Agreed?. Fine by me. I also think `Cb=1/Pr` would be a good choice and retains current defaults.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889336992
https://github.com/CliMA/Oceananigans.jl/issues/1909#issuecomment-889256150:52,Deployability,upgrade,upgrade,52,This might coincide with tartarus' operating system upgrade.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1909#issuecomment-889256150
https://github.com/CliMA/Oceananigans.jl/issues/1909#issuecomment-899744147:54,Deployability,deploy,deploy,54,"For future reference, I believe that updating the ssh deploy keys requires two things:. 1. Access to tartarus; 2. Admin privileges on the documentation repo, https://github.com/CliMA/OceananigansDocumentation. The [`Documenter.jl` documentation for generating deploy keys](https://juliadocs.github.io/Documenter.jl/stable/man/hosting/#travis-ssh) reads confusingly because we don't use Travis CI, but I do think we need to do something like what's outlined.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1909#issuecomment-899744147
https://github.com/CliMA/Oceananigans.jl/issues/1909#issuecomment-899744147:260,Deployability,deploy,deploy,260,"For future reference, I believe that updating the ssh deploy keys requires two things:. 1. Access to tartarus; 2. Admin privileges on the documentation repo, https://github.com/CliMA/OceananigansDocumentation. The [`Documenter.jl` documentation for generating deploy keys](https://juliadocs.github.io/Documenter.jl/stable/man/hosting/#travis-ssh) reads confusingly because we don't use Travis CI, but I do think we need to do something like what's outlined.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1909#issuecomment-899744147
https://github.com/CliMA/Oceananigans.jl/issues/1909#issuecomment-899744147:91,Security,Access,Access,91,"For future reference, I believe that updating the ssh deploy keys requires two things:. 1. Access to tartarus; 2. Admin privileges on the documentation repo, https://github.com/CliMA/OceananigansDocumentation. The [`Documenter.jl` documentation for generating deploy keys](https://juliadocs.github.io/Documenter.jl/stable/man/hosting/#travis-ssh) reads confusingly because we don't use Travis CI, but I do think we need to do something like what's outlined.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1909#issuecomment-899744147
https://github.com/CliMA/Oceananigans.jl/issues/1909#issuecomment-901149073:34,Energy Efficiency,adapt,adapt,34,"We also need to figure out how to adapt instruction 2:. <img width=""851"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/129913721-0a12190d-af28-43c6-9070-92eb9e8f5a25.png"">. to buildkite.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1909#issuecomment-901149073
https://github.com/CliMA/Oceananigans.jl/issues/1909#issuecomment-901149073:34,Modifiability,adapt,adapt,34,"We also need to figure out how to adapt instruction 2:. <img width=""851"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/129913721-0a12190d-af28-43c6-9070-92eb9e8f5a25.png"">. to buildkite.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1909#issuecomment-901149073
https://github.com/CliMA/Oceananigans.jl/issues/1909#issuecomment-901384701:86,Modifiability,variab,variable,86,"For future reference, instead of the second step above, we need to add an environment variable `DOCUMENTEY_KEY=path_to_long_private_key` to the file `/etc/buildkite-agent/hooks/environment` (which may not exist yet).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1909#issuecomment-901384701
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890017453:1072,Deployability,continuous,continuous,1072,"Heh, well the `stratified_fluid_remains_at_rest_with_tilted_gravity_temperature_tracer` test fails. The log suggests that the problem is confined to a few grid points, since the mean is correct:. ```; [2021/07/29 16:10:56.038] INFO Simulation is stopping. Model time 1 hour has hit or exceeded simulation stop time 1 hour.; --;  | [2021/07/29 16:10:57.288] INFO Tz * g[2] = 0.0001065658790393914, mean(y_T) = 0.0001065658790360618,  = 3.32959842423014e-15 at t = 1 hour with =1;  | [2021/07/29 16:10:57.288] INFO Tz * g[3] = 0.006105155121314884, mean(z_T) = 0.006105155121314366,  = 5.178149575790769e-16 at t = 1 hour with =1;  | Tilted gravity: Test Failed at /var/lib/buildkite-agent/builds/tartarus-5/clima/oceananigans/test/test_dynamics.jl:290;  | Expression: all(Tz * g[2] . interior(y_T)); ```. https://github.com/CliMA/Oceananigans.jl/blob/9ecddac3fe2666e05f21e51b81ec2c403094e5ea/test/test_dynamics.jl#L241. I am skeptical about the value of this test. In general, discretizations _do not necessarily_ represent the balance states of the continuous systems they approximate. Thus in general this test should fail! It will succeed of course in the case that the discrete system shares a balanced state with the continuous state. I think this is flawed as a _test_ because, while certainly formulating discrete systems that share balanced states with their continuous systems is _desirable_, I'm not sure it's something we want to guarantee via CI. We should be allowed to violate this prescription if the discrete system has other _more important_ desirable properties. It could be a nice validation test though. In this particular case, the nonhydrostatic useful is most often used for simulations of _vigorous_ turbulence in which weak flows induced by a violation of hydrostatic balance are likely irrelevant.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890017453
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890017453:1244,Deployability,continuous,continuous,1244,"Heh, well the `stratified_fluid_remains_at_rest_with_tilted_gravity_temperature_tracer` test fails. The log suggests that the problem is confined to a few grid points, since the mean is correct:. ```; [2021/07/29 16:10:56.038] INFO Simulation is stopping. Model time 1 hour has hit or exceeded simulation stop time 1 hour.; --;  | [2021/07/29 16:10:57.288] INFO Tz * g[2] = 0.0001065658790393914, mean(y_T) = 0.0001065658790360618,  = 3.32959842423014e-15 at t = 1 hour with =1;  | [2021/07/29 16:10:57.288] INFO Tz * g[3] = 0.006105155121314884, mean(z_T) = 0.006105155121314366,  = 5.178149575790769e-16 at t = 1 hour with =1;  | Tilted gravity: Test Failed at /var/lib/buildkite-agent/builds/tartarus-5/clima/oceananigans/test/test_dynamics.jl:290;  | Expression: all(Tz * g[2] . interior(y_T)); ```. https://github.com/CliMA/Oceananigans.jl/blob/9ecddac3fe2666e05f21e51b81ec2c403094e5ea/test/test_dynamics.jl#L241. I am skeptical about the value of this test. In general, discretizations _do not necessarily_ represent the balance states of the continuous systems they approximate. Thus in general this test should fail! It will succeed of course in the case that the discrete system shares a balanced state with the continuous state. I think this is flawed as a _test_ because, while certainly formulating discrete systems that share balanced states with their continuous systems is _desirable_, I'm not sure it's something we want to guarantee via CI. We should be allowed to violate this prescription if the discrete system has other _more important_ desirable properties. It could be a nice validation test though. In this particular case, the nonhydrostatic useful is most often used for simulations of _vigorous_ turbulence in which weak flows induced by a violation of hydrostatic balance are likely irrelevant.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890017453
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890017453:1389,Deployability,continuous,continuous,1389,"Heh, well the `stratified_fluid_remains_at_rest_with_tilted_gravity_temperature_tracer` test fails. The log suggests that the problem is confined to a few grid points, since the mean is correct:. ```; [2021/07/29 16:10:56.038] INFO Simulation is stopping. Model time 1 hour has hit or exceeded simulation stop time 1 hour.; --;  | [2021/07/29 16:10:57.288] INFO Tz * g[2] = 0.0001065658790393914, mean(y_T) = 0.0001065658790360618,  = 3.32959842423014e-15 at t = 1 hour with =1;  | [2021/07/29 16:10:57.288] INFO Tz * g[3] = 0.006105155121314884, mean(z_T) = 0.006105155121314366,  = 5.178149575790769e-16 at t = 1 hour with =1;  | Tilted gravity: Test Failed at /var/lib/buildkite-agent/builds/tartarus-5/clima/oceananigans/test/test_dynamics.jl:290;  | Expression: all(Tz * g[2] . interior(y_T)); ```. https://github.com/CliMA/Oceananigans.jl/blob/9ecddac3fe2666e05f21e51b81ec2c403094e5ea/test/test_dynamics.jl#L241. I am skeptical about the value of this test. In general, discretizations _do not necessarily_ represent the balance states of the continuous systems they approximate. Thus in general this test should fail! It will succeed of course in the case that the discrete system shares a balanced state with the continuous state. I think this is flawed as a _test_ because, while certainly formulating discrete systems that share balanced states with their continuous systems is _desirable_, I'm not sure it's something we want to guarantee via CI. We should be allowed to violate this prescription if the discrete system has other _more important_ desirable properties. It could be a nice validation test though. In this particular case, the nonhydrostatic useful is most often used for simulations of _vigorous_ turbulence in which weak flows induced by a violation of hydrostatic balance are likely irrelevant.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890017453
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890017453:1622,Security,validat,validation,1622,"Heh, well the `stratified_fluid_remains_at_rest_with_tilted_gravity_temperature_tracer` test fails. The log suggests that the problem is confined to a few grid points, since the mean is correct:. ```; [2021/07/29 16:10:56.038] INFO Simulation is stopping. Model time 1 hour has hit or exceeded simulation stop time 1 hour.; --;  | [2021/07/29 16:10:57.288] INFO Tz * g[2] = 0.0001065658790393914, mean(y_T) = 0.0001065658790360618,  = 3.32959842423014e-15 at t = 1 hour with =1;  | [2021/07/29 16:10:57.288] INFO Tz * g[3] = 0.006105155121314884, mean(z_T) = 0.006105155121314366,  = 5.178149575790769e-16 at t = 1 hour with =1;  | Tilted gravity: Test Failed at /var/lib/buildkite-agent/builds/tartarus-5/clima/oceananigans/test/test_dynamics.jl:290;  | Expression: all(Tz * g[2] . interior(y_T)); ```. https://github.com/CliMA/Oceananigans.jl/blob/9ecddac3fe2666e05f21e51b81ec2c403094e5ea/test/test_dynamics.jl#L241. I am skeptical about the value of this test. In general, discretizations _do not necessarily_ represent the balance states of the continuous systems they approximate. Thus in general this test should fail! It will succeed of course in the case that the discrete system shares a balanced state with the continuous state. I think this is flawed as a _test_ because, while certainly formulating discrete systems that share balanced states with their continuous systems is _desirable_, I'm not sure it's something we want to guarantee via CI. We should be allowed to violate this prescription if the discrete system has other _more important_ desirable properties. It could be a nice validation test though. In this particular case, the nonhydrostatic useful is most often used for simulations of _vigorous_ turbulence in which weak flows induced by a violation of hydrostatic balance are likely irrelevant.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890017453
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890017453:88,Testability,test,test,88,"Heh, well the `stratified_fluid_remains_at_rest_with_tilted_gravity_temperature_tracer` test fails. The log suggests that the problem is confined to a few grid points, since the mean is correct:. ```; [2021/07/29 16:10:56.038] INFO Simulation is stopping. Model time 1 hour has hit or exceeded simulation stop time 1 hour.; --;  | [2021/07/29 16:10:57.288] INFO Tz * g[2] = 0.0001065658790393914, mean(y_T) = 0.0001065658790360618,  = 3.32959842423014e-15 at t = 1 hour with =1;  | [2021/07/29 16:10:57.288] INFO Tz * g[3] = 0.006105155121314884, mean(z_T) = 0.006105155121314366,  = 5.178149575790769e-16 at t = 1 hour with =1;  | Tilted gravity: Test Failed at /var/lib/buildkite-agent/builds/tartarus-5/clima/oceananigans/test/test_dynamics.jl:290;  | Expression: all(Tz * g[2] . interior(y_T)); ```. https://github.com/CliMA/Oceananigans.jl/blob/9ecddac3fe2666e05f21e51b81ec2c403094e5ea/test/test_dynamics.jl#L241. I am skeptical about the value of this test. In general, discretizations _do not necessarily_ represent the balance states of the continuous systems they approximate. Thus in general this test should fail! It will succeed of course in the case that the discrete system shares a balanced state with the continuous state. I think this is flawed as a _test_ because, while certainly formulating discrete systems that share balanced states with their continuous systems is _desirable_, I'm not sure it's something we want to guarantee via CI. We should be allowed to violate this prescription if the discrete system has other _more important_ desirable properties. It could be a nice validation test though. In this particular case, the nonhydrostatic useful is most often used for simulations of _vigorous_ turbulence in which weak flows induced by a violation of hydrostatic balance are likely irrelevant.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890017453
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890017453:104,Testability,log,log,104,"Heh, well the `stratified_fluid_remains_at_rest_with_tilted_gravity_temperature_tracer` test fails. The log suggests that the problem is confined to a few grid points, since the mean is correct:. ```; [2021/07/29 16:10:56.038] INFO Simulation is stopping. Model time 1 hour has hit or exceeded simulation stop time 1 hour.; --;  | [2021/07/29 16:10:57.288] INFO Tz * g[2] = 0.0001065658790393914, mean(y_T) = 0.0001065658790360618,  = 3.32959842423014e-15 at t = 1 hour with =1;  | [2021/07/29 16:10:57.288] INFO Tz * g[3] = 0.006105155121314884, mean(z_T) = 0.006105155121314366,  = 5.178149575790769e-16 at t = 1 hour with =1;  | Tilted gravity: Test Failed at /var/lib/buildkite-agent/builds/tartarus-5/clima/oceananigans/test/test_dynamics.jl:290;  | Expression: all(Tz * g[2] . interior(y_T)); ```. https://github.com/CliMA/Oceananigans.jl/blob/9ecddac3fe2666e05f21e51b81ec2c403094e5ea/test/test_dynamics.jl#L241. I am skeptical about the value of this test. In general, discretizations _do not necessarily_ represent the balance states of the continuous systems they approximate. Thus in general this test should fail! It will succeed of course in the case that the discrete system shares a balanced state with the continuous state. I think this is flawed as a _test_ because, while certainly formulating discrete systems that share balanced states with their continuous systems is _desirable_, I'm not sure it's something we want to guarantee via CI. We should be allowed to violate this prescription if the discrete system has other _more important_ desirable properties. It could be a nice validation test though. In this particular case, the nonhydrostatic useful is most often used for simulations of _vigorous_ turbulence in which weak flows induced by a violation of hydrostatic balance are likely irrelevant.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890017453
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890017453:665,Testability,Test,Test,665,"Heh, well the `stratified_fluid_remains_at_rest_with_tilted_gravity_temperature_tracer` test fails. The log suggests that the problem is confined to a few grid points, since the mean is correct:. ```; [2021/07/29 16:10:56.038] INFO Simulation is stopping. Model time 1 hour has hit or exceeded simulation stop time 1 hour.; --;  | [2021/07/29 16:10:57.288] INFO Tz * g[2] = 0.0001065658790393914, mean(y_T) = 0.0001065658790360618,  = 3.32959842423014e-15 at t = 1 hour with =1;  | [2021/07/29 16:10:57.288] INFO Tz * g[3] = 0.006105155121314884, mean(z_T) = 0.006105155121314366,  = 5.178149575790769e-16 at t = 1 hour with =1;  | Tilted gravity: Test Failed at /var/lib/buildkite-agent/builds/tartarus-5/clima/oceananigans/test/test_dynamics.jl:290;  | Expression: all(Tz * g[2] . interior(y_T)); ```. https://github.com/CliMA/Oceananigans.jl/blob/9ecddac3fe2666e05f21e51b81ec2c403094e5ea/test/test_dynamics.jl#L241. I am skeptical about the value of this test. In general, discretizations _do not necessarily_ represent the balance states of the continuous systems they approximate. Thus in general this test should fail! It will succeed of course in the case that the discrete system shares a balanced state with the continuous state. I think this is flawed as a _test_ because, while certainly formulating discrete systems that share balanced states with their continuous systems is _desirable_, I'm not sure it's something we want to guarantee via CI. We should be allowed to violate this prescription if the discrete system has other _more important_ desirable properties. It could be a nice validation test though. In this particular case, the nonhydrostatic useful is most often used for simulations of _vigorous_ turbulence in which weak flows induced by a violation of hydrostatic balance are likely irrelevant.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890017453
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890017453:742,Testability,test,test,742,"Heh, well the `stratified_fluid_remains_at_rest_with_tilted_gravity_temperature_tracer` test fails. The log suggests that the problem is confined to a few grid points, since the mean is correct:. ```; [2021/07/29 16:10:56.038] INFO Simulation is stopping. Model time 1 hour has hit or exceeded simulation stop time 1 hour.; --;  | [2021/07/29 16:10:57.288] INFO Tz * g[2] = 0.0001065658790393914, mean(y_T) = 0.0001065658790360618,  = 3.32959842423014e-15 at t = 1 hour with =1;  | [2021/07/29 16:10:57.288] INFO Tz * g[3] = 0.006105155121314884, mean(z_T) = 0.006105155121314366,  = 5.178149575790769e-16 at t = 1 hour with =1;  | Tilted gravity: Test Failed at /var/lib/buildkite-agent/builds/tartarus-5/clima/oceananigans/test/test_dynamics.jl:290;  | Expression: all(Tz * g[2] . interior(y_T)); ```. https://github.com/CliMA/Oceananigans.jl/blob/9ecddac3fe2666e05f21e51b81ec2c403094e5ea/test/test_dynamics.jl#L241. I am skeptical about the value of this test. In general, discretizations _do not necessarily_ represent the balance states of the continuous systems they approximate. Thus in general this test should fail! It will succeed of course in the case that the discrete system shares a balanced state with the continuous state. I think this is flawed as a _test_ because, while certainly formulating discrete systems that share balanced states with their continuous systems is _desirable_, I'm not sure it's something we want to guarantee via CI. We should be allowed to violate this prescription if the discrete system has other _more important_ desirable properties. It could be a nice validation test though. In this particular case, the nonhydrostatic useful is most often used for simulations of _vigorous_ turbulence in which weak flows induced by a violation of hydrostatic balance are likely irrelevant.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890017453
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890017453:914,Testability,test,test,914,"Heh, well the `stratified_fluid_remains_at_rest_with_tilted_gravity_temperature_tracer` test fails. The log suggests that the problem is confined to a few grid points, since the mean is correct:. ```; [2021/07/29 16:10:56.038] INFO Simulation is stopping. Model time 1 hour has hit or exceeded simulation stop time 1 hour.; --;  | [2021/07/29 16:10:57.288] INFO Tz * g[2] = 0.0001065658790393914, mean(y_T) = 0.0001065658790360618,  = 3.32959842423014e-15 at t = 1 hour with =1;  | [2021/07/29 16:10:57.288] INFO Tz * g[3] = 0.006105155121314884, mean(z_T) = 0.006105155121314366,  = 5.178149575790769e-16 at t = 1 hour with =1;  | Tilted gravity: Test Failed at /var/lib/buildkite-agent/builds/tartarus-5/clima/oceananigans/test/test_dynamics.jl:290;  | Expression: all(Tz * g[2] . interior(y_T)); ```. https://github.com/CliMA/Oceananigans.jl/blob/9ecddac3fe2666e05f21e51b81ec2c403094e5ea/test/test_dynamics.jl#L241. I am skeptical about the value of this test. In general, discretizations _do not necessarily_ represent the balance states of the continuous systems they approximate. Thus in general this test should fail! It will succeed of course in the case that the discrete system shares a balanced state with the continuous state. I think this is flawed as a _test_ because, while certainly formulating discrete systems that share balanced states with their continuous systems is _desirable_, I'm not sure it's something we want to guarantee via CI. We should be allowed to violate this prescription if the discrete system has other _more important_ desirable properties. It could be a nice validation test though. In this particular case, the nonhydrostatic useful is most often used for simulations of _vigorous_ turbulence in which weak flows induced by a violation of hydrostatic balance are likely irrelevant.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890017453
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890017453:981,Testability,test,test,981,"Heh, well the `stratified_fluid_remains_at_rest_with_tilted_gravity_temperature_tracer` test fails. The log suggests that the problem is confined to a few grid points, since the mean is correct:. ```; [2021/07/29 16:10:56.038] INFO Simulation is stopping. Model time 1 hour has hit or exceeded simulation stop time 1 hour.; --;  | [2021/07/29 16:10:57.288] INFO Tz * g[2] = 0.0001065658790393914, mean(y_T) = 0.0001065658790360618,  = 3.32959842423014e-15 at t = 1 hour with =1;  | [2021/07/29 16:10:57.288] INFO Tz * g[3] = 0.006105155121314884, mean(z_T) = 0.006105155121314366,  = 5.178149575790769e-16 at t = 1 hour with =1;  | Tilted gravity: Test Failed at /var/lib/buildkite-agent/builds/tartarus-5/clima/oceananigans/test/test_dynamics.jl:290;  | Expression: all(Tz * g[2] . interior(y_T)); ```. https://github.com/CliMA/Oceananigans.jl/blob/9ecddac3fe2666e05f21e51b81ec2c403094e5ea/test/test_dynamics.jl#L241. I am skeptical about the value of this test. In general, discretizations _do not necessarily_ represent the balance states of the continuous systems they approximate. Thus in general this test should fail! It will succeed of course in the case that the discrete system shares a balanced state with the continuous state. I think this is flawed as a _test_ because, while certainly formulating discrete systems that share balanced states with their continuous systems is _desirable_, I'm not sure it's something we want to guarantee via CI. We should be allowed to violate this prescription if the discrete system has other _more important_ desirable properties. It could be a nice validation test though. In this particular case, the nonhydrostatic useful is most often used for simulations of _vigorous_ turbulence in which weak flows induced by a violation of hydrostatic balance are likely irrelevant.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890017453
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890017453:1130,Testability,test,test,1130,"Heh, well the `stratified_fluid_remains_at_rest_with_tilted_gravity_temperature_tracer` test fails. The log suggests that the problem is confined to a few grid points, since the mean is correct:. ```; [2021/07/29 16:10:56.038] INFO Simulation is stopping. Model time 1 hour has hit or exceeded simulation stop time 1 hour.; --;  | [2021/07/29 16:10:57.288] INFO Tz * g[2] = 0.0001065658790393914, mean(y_T) = 0.0001065658790360618,  = 3.32959842423014e-15 at t = 1 hour with =1;  | [2021/07/29 16:10:57.288] INFO Tz * g[3] = 0.006105155121314884, mean(z_T) = 0.006105155121314366,  = 5.178149575790769e-16 at t = 1 hour with =1;  | Tilted gravity: Test Failed at /var/lib/buildkite-agent/builds/tartarus-5/clima/oceananigans/test/test_dynamics.jl:290;  | Expression: all(Tz * g[2] . interior(y_T)); ```. https://github.com/CliMA/Oceananigans.jl/blob/9ecddac3fe2666e05f21e51b81ec2c403094e5ea/test/test_dynamics.jl#L241. I am skeptical about the value of this test. In general, discretizations _do not necessarily_ represent the balance states of the continuous systems they approximate. Thus in general this test should fail! It will succeed of course in the case that the discrete system shares a balanced state with the continuous state. I think this is flawed as a _test_ because, while certainly formulating discrete systems that share balanced states with their continuous systems is _desirable_, I'm not sure it's something we want to guarantee via CI. We should be allowed to violate this prescription if the discrete system has other _more important_ desirable properties. It could be a nice validation test though. In this particular case, the nonhydrostatic useful is most often used for simulations of _vigorous_ turbulence in which weak flows induced by a violation of hydrostatic balance are likely irrelevant.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890017453
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890017453:1633,Testability,test,test,1633,"Heh, well the `stratified_fluid_remains_at_rest_with_tilted_gravity_temperature_tracer` test fails. The log suggests that the problem is confined to a few grid points, since the mean is correct:. ```; [2021/07/29 16:10:56.038] INFO Simulation is stopping. Model time 1 hour has hit or exceeded simulation stop time 1 hour.; --;  | [2021/07/29 16:10:57.288] INFO Tz * g[2] = 0.0001065658790393914, mean(y_T) = 0.0001065658790360618,  = 3.32959842423014e-15 at t = 1 hour with =1;  | [2021/07/29 16:10:57.288] INFO Tz * g[3] = 0.006105155121314884, mean(z_T) = 0.006105155121314366,  = 5.178149575790769e-16 at t = 1 hour with =1;  | Tilted gravity: Test Failed at /var/lib/buildkite-agent/builds/tartarus-5/clima/oceananigans/test/test_dynamics.jl:290;  | Expression: all(Tz * g[2] . interior(y_T)); ```. https://github.com/CliMA/Oceananigans.jl/blob/9ecddac3fe2666e05f21e51b81ec2c403094e5ea/test/test_dynamics.jl#L241. I am skeptical about the value of this test. In general, discretizations _do not necessarily_ represent the balance states of the continuous systems they approximate. Thus in general this test should fail! It will succeed of course in the case that the discrete system shares a balanced state with the continuous state. I think this is flawed as a _test_ because, while certainly formulating discrete systems that share balanced states with their continuous systems is _desirable_, I'm not sure it's something we want to guarantee via CI. We should be allowed to violate this prescription if the discrete system has other _more important_ desirable properties. It could be a nice validation test though. In this particular case, the nonhydrostatic useful is most often used for simulations of _vigorous_ turbulence in which weak flows induced by a violation of hydrostatic balance are likely irrelevant.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890017453
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890023558:553,Availability,error,error,553,"The change in this PR might conceivably produce changes in the dynamics because it changes the temporal discretization of the system. In particular, the pressure correction method corresponds to a first-order backward Euler discretziation of the pressure gradient term. On the other hand, since we calculate the hydrostatic pressure analytically coincident with other terms on the right hand side, it's treated with an _explicit_ discretization (though the discretization is still first-order for the quasi-Adams-Bashforth scheme, it can have different error properties). Which time discretization is better? I don't know...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890023558
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890024609:160,Testability,test,test,160,"@tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890024609
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890024609:227,Testability,test,test,227,"@tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890024609
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890024609:259,Testability,test,test,259,"@tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890024609
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890043769:513,Availability,error,error,513,"> @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason. I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that. So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890043769
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890043769:646,Availability,error,error,646,"> @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason. I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that. So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890043769
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890043769:371,Deployability,continuous,continuous,371,"> @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason. I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that. So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890043769
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890043769:162,Testability,test,test,162,"> @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason. I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that. So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890043769
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890043769:229,Testability,test,test,229,"> @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason. I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that. So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890043769
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890043769:261,Testability,test,test,261,"> @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason. I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that. So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890043769
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890043769:481,Testability,test,test,481,"> @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason. I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that. So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890043769
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890043769:572,Testability,test,test,572,"> @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason. I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that. So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890043769
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890043769:704,Testability,test,tests,704,"> @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason. I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that. So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890043769
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890043769:758,Testability,test,test,758,"> @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason. I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that. So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890043769
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890043769:813,Testability,test,test,813,"> @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason. I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that. So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890043769
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890043769:806,Usability,simpl,simple,806,"> @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason. I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that. So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890043769
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586:522,Availability,error,error,522,"> > @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason.; > ; > I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that.; > ; > So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation. Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient. More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586:662,Availability,error,error,662,"> > @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason.; > ; > I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that.; > ; > So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation. Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient. More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586:1256,Availability,error,error,1256,"> > @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason.; > ; > I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that.; > ; > So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation. Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient. More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586:380,Deployability,continuous,continuous,380,"> > @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason.; > ; > I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that.; > ; > So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation. Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient. More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586:1302,Deployability,integrat,integration,1302,"> > @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason.; > ; > I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that.; > ; > So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation. Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient. More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586:1397,Deployability,continuous,continuous,1397,"> > @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason.; > ; > I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that.; > ; > So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation. Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient. More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586:1302,Integrability,integrat,integration,1302,"> > @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason.; > ; > I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that.; > ; > So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation. Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient. More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586:1438,Security,validat,validation,1438,"> > @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason.; > ; > I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that.; > ; > So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation. Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient. More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586:164,Testability,test,test,164,"> > @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason.; > ; > I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that.; > ; > So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation. Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient. More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586:231,Testability,test,test,231,"> > @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason.; > ; > I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that.; > ; > So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation. Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient. More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586:263,Testability,test,test,263,"> > @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason.; > ; > I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that.; > ; > So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation. Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient. More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586:490,Testability,test,test,490,"> > @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason.; > ; > I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that.; > ; > So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation. Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient. More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586:581,Testability,test,test,581,"> > @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason.; > ; > I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that.; > ; > So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation. Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient. More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586:720,Testability,test,tests,720,"> > @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason.; > ; > I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that.; > ; > So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation. Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient. More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586:774,Testability,test,test,774,"> > @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason.; > ; > I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that.; > ; > So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation. Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient. More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586:829,Testability,test,test,829,"> > @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason.; > ; > I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that.; > ; > So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation. Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient. More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586:1120,Testability,test,test,1120,"> > @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason.; > ; > I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that.; > ; > So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation. Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient. More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586:1216,Testability,test,test,1216,"> > @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason.; > ; > I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that.; > ; > So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation. Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient. More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586:1314,Testability,test,tests,1314,"> > @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason.; > ; > I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that.; > ; > So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation. Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient. More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586:1326,Testability,test,testing,1326,"> > @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason.; > ; > I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that.; > ; > So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation. Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient. More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586:1449,Testability,test,test,1449,"> > @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason.; > ; > I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that.; > ; > So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation. Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient. More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586:822,Usability,simpl,simple,822,"> > @tomchor since you're the main person using the tilted gravity feature, I'm wondering if you can help provide some insight into this ""stratified fluid at rest"" test. The main issue is that the dynamics can be ""correct"" but the test can fail. I feel its a bad test for this reason.; > ; > I don't have much to add to the discussion. I agree with you that a balanced state in a continuous system doesn't necessarily translate exactly to a discrete one. When I (or Ali?) came up with this test I figured this translation error would be small enough to be acceptable, and when the test actually passed I was happy enough with that.; > ; > So if this translation error is indeed large enough with the new solver that the tests don't pass I'm very much okay with changing the test. I can't, for the moment, think of another simple test to replace it though. My best guess is to do something similar to what I did for the rotated Coriolis: solve a system with gravity pointing upwards and then the same system with gravity pointing to the `x` or `y` direction and see if they match after the proper rotation. Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient. More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890058586
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890083027:152,Availability,error,error,152,"> Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient.; > ; > More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think. Yeah, if you think that's enough for CI then I'm definitely okay with that!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890083027
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890083027:205,Deployability,integrat,integration,205,"> Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient.; > ; > More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think. Yeah, if you think that's enough for CI then I'm definitely okay with that!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890083027
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890083027:300,Deployability,continuous,continuous,300,"> Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient.; > ; > More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think. Yeah, if you think that's enough for CI then I'm definitely okay with that!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890083027
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890083027:205,Integrability,integrat,integration,205,"> Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient.; > ; > More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think. Yeah, if you think that's enough for CI then I'm definitely okay with that!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890083027
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890083027:341,Security,validat,validation,341,"> Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient.; > ; > More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think. Yeah, if you think that's enough for CI then I'm definitely okay with that!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890083027
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890083027:16,Testability,test,test,16,"> Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient.; > ; > More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think. Yeah, if you think that's enough for CI then I'm definitely okay with that!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890083027
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890083027:112,Testability,test,test,112,"> Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient.; > ; > More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think. Yeah, if you think that's enough for CI then I'm definitely okay with that!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890083027
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890083027:217,Testability,test,tests,217,"> Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient.; > ; > More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think. Yeah, if you think that's enough for CI then I'm definitely okay with that!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890083027
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890083027:229,Testability,test,testing,229,"> Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient.; > ; > More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think. Yeah, if you think that's enough for CI then I'm definitely okay with that!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890083027
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890083027:352,Testability,test,test,352,"> Can't we just test directly that the output of `x_dot_b` is as expected (as well as the others)? Along with a test that the constructor works without error this seems sufficient.; > ; > More complicated integration tests, like testing that the discrete system has a balanced state analogous to the continuous one, seem better suited for a validation test, I think. Yeah, if you think that's enough for CI then I'm definitely okay with that!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-890083027
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-913791965:281,Availability,down,downside,281,"Removed the ""fluid at rest"" test that was failing and included another (simpler) one for tilted buoyancy along with constructors. The new test checks that `x_dot_g_b`, etc., match for two different domains: one with z-aligned gravity and another with y-aligned gravity. . The only downside is that I only included the `x_dot_g_b` test for `model=BuoyancyTracer()`. Another separate test is needed for `model=SeawaterBuoyancy()` if we think that's necessary. (Constructors are tested for both models, though.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-913791965
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-913791965:28,Testability,test,test,28,"Removed the ""fluid at rest"" test that was failing and included another (simpler) one for tilted buoyancy along with constructors. The new test checks that `x_dot_g_b`, etc., match for two different domains: one with z-aligned gravity and another with y-aligned gravity. . The only downside is that I only included the `x_dot_g_b` test for `model=BuoyancyTracer()`. Another separate test is needed for `model=SeawaterBuoyancy()` if we think that's necessary. (Constructors are tested for both models, though.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-913791965
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-913791965:138,Testability,test,test,138,"Removed the ""fluid at rest"" test that was failing and included another (simpler) one for tilted buoyancy along with constructors. The new test checks that `x_dot_g_b`, etc., match for two different domains: one with z-aligned gravity and another with y-aligned gravity. . The only downside is that I only included the `x_dot_g_b` test for `model=BuoyancyTracer()`. Another separate test is needed for `model=SeawaterBuoyancy()` if we think that's necessary. (Constructors are tested for both models, though.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-913791965
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-913791965:330,Testability,test,test,330,"Removed the ""fluid at rest"" test that was failing and included another (simpler) one for tilted buoyancy along with constructors. The new test checks that `x_dot_g_b`, etc., match for two different domains: one with z-aligned gravity and another with y-aligned gravity. . The only downside is that I only included the `x_dot_g_b` test for `model=BuoyancyTracer()`. Another separate test is needed for `model=SeawaterBuoyancy()` if we think that's necessary. (Constructors are tested for both models, though.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-913791965
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-913791965:382,Testability,test,test,382,"Removed the ""fluid at rest"" test that was failing and included another (simpler) one for tilted buoyancy along with constructors. The new test checks that `x_dot_g_b`, etc., match for two different domains: one with z-aligned gravity and another with y-aligned gravity. . The only downside is that I only included the `x_dot_g_b` test for `model=BuoyancyTracer()`. Another separate test is needed for `model=SeawaterBuoyancy()` if we think that's necessary. (Constructors are tested for both models, though.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-913791965
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-913791965:476,Testability,test,tested,476,"Removed the ""fluid at rest"" test that was failing and included another (simpler) one for tilted buoyancy along with constructors. The new test checks that `x_dot_g_b`, etc., match for two different domains: one with z-aligned gravity and another with y-aligned gravity. . The only downside is that I only included the `x_dot_g_b` test for `model=BuoyancyTracer()`. Another separate test is needed for `model=SeawaterBuoyancy()` if we think that's necessary. (Constructors are tested for both models, though.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-913791965
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-913791965:72,Usability,simpl,simpler,72,"Removed the ""fluid at rest"" test that was failing and included another (simpler) one for tilted buoyancy along with constructors. The new test checks that `x_dot_g_b`, etc., match for two different domains: one with z-aligned gravity and another with y-aligned gravity. . The only downside is that I only included the `x_dot_g_b` test for `model=BuoyancyTracer()`. Another separate test is needed for `model=SeawaterBuoyancy()` if we think that's necessary. (Constructors are tested for both models, though.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-913791965
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-914363399:288,Availability,down,downside,288,"> Removed the ""fluid at rest"" test that was failing and included another (simpler) one for tilted buoyancy along with constructors. The new test checks that `x_dot_g_b`, etc., match for two different domains: one with z-aligned gravity and another with y-aligned gravity.; > ; > The only downside is that I only included the `x_dot_g_b` test for `model=BuoyancyTracer()`. Another separate test is needed for `model=SeawaterBuoyancy()` if we think that's necessary.; > ; > (Constructors are tested for both models, though.). Thanks @tomchor !!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-914363399
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-914363399:30,Testability,test,test,30,"> Removed the ""fluid at rest"" test that was failing and included another (simpler) one for tilted buoyancy along with constructors. The new test checks that `x_dot_g_b`, etc., match for two different domains: one with z-aligned gravity and another with y-aligned gravity.; > ; > The only downside is that I only included the `x_dot_g_b` test for `model=BuoyancyTracer()`. Another separate test is needed for `model=SeawaterBuoyancy()` if we think that's necessary.; > ; > (Constructors are tested for both models, though.). Thanks @tomchor !!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-914363399
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-914363399:140,Testability,test,test,140,"> Removed the ""fluid at rest"" test that was failing and included another (simpler) one for tilted buoyancy along with constructors. The new test checks that `x_dot_g_b`, etc., match for two different domains: one with z-aligned gravity and another with y-aligned gravity.; > ; > The only downside is that I only included the `x_dot_g_b` test for `model=BuoyancyTracer()`. Another separate test is needed for `model=SeawaterBuoyancy()` if we think that's necessary.; > ; > (Constructors are tested for both models, though.). Thanks @tomchor !!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-914363399
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-914363399:337,Testability,test,test,337,"> Removed the ""fluid at rest"" test that was failing and included another (simpler) one for tilted buoyancy along with constructors. The new test checks that `x_dot_g_b`, etc., match for two different domains: one with z-aligned gravity and another with y-aligned gravity.; > ; > The only downside is that I only included the `x_dot_g_b` test for `model=BuoyancyTracer()`. Another separate test is needed for `model=SeawaterBuoyancy()` if we think that's necessary.; > ; > (Constructors are tested for both models, though.). Thanks @tomchor !!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-914363399
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-914363399:389,Testability,test,test,389,"> Removed the ""fluid at rest"" test that was failing and included another (simpler) one for tilted buoyancy along with constructors. The new test checks that `x_dot_g_b`, etc., match for two different domains: one with z-aligned gravity and another with y-aligned gravity.; > ; > The only downside is that I only included the `x_dot_g_b` test for `model=BuoyancyTracer()`. Another separate test is needed for `model=SeawaterBuoyancy()` if we think that's necessary.; > ; > (Constructors are tested for both models, though.). Thanks @tomchor !!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-914363399
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-914363399:490,Testability,test,tested,490,"> Removed the ""fluid at rest"" test that was failing and included another (simpler) one for tilted buoyancy along with constructors. The new test checks that `x_dot_g_b`, etc., match for two different domains: one with z-aligned gravity and another with y-aligned gravity.; > ; > The only downside is that I only included the `x_dot_g_b` test for `model=BuoyancyTracer()`. Another separate test is needed for `model=SeawaterBuoyancy()` if we think that's necessary.; > ; > (Constructors are tested for both models, though.). Thanks @tomchor !!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-914363399
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-914363399:74,Usability,simpl,simpler,74,"> Removed the ""fluid at rest"" test that was failing and included another (simpler) one for tilted buoyancy along with constructors. The new test checks that `x_dot_g_b`, etc., match for two different domains: one with z-aligned gravity and another with y-aligned gravity.; > ; > The only downside is that I only included the `x_dot_g_b` test for `model=BuoyancyTracer()`. Another separate test is needed for `model=SeawaterBuoyancy()` if we think that's necessary.; > ; > (Constructors are tested for both models, though.). Thanks @tomchor !!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-914363399
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-994942677:4,Availability,error,errors,4,"The errors of the `cpu-simulation-tests` are of this kind:. ```julia; JLD2 output writer [CPU]: Test Failed at /var/lib/buildkite-agent/builds/tartarus-2/clima/oceananigans/test/test_jld2_output_writer.jl:135; --;  | Expression: wT == zero(FT);  | Evaluated: -1.2037062f-34 == 0.0; ```. which is something that should be solved by replacing `==` with `\approx`, but I wonder why this used to pass before but isn't passing now. In other words: I'm not sure if merely replacing equality with approximate equality is the right way to solve this test.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-994942677
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-994942677:34,Testability,test,tests,34,"The errors of the `cpu-simulation-tests` are of this kind:. ```julia; JLD2 output writer [CPU]: Test Failed at /var/lib/buildkite-agent/builds/tartarus-2/clima/oceananigans/test/test_jld2_output_writer.jl:135; --;  | Expression: wT == zero(FT);  | Evaluated: -1.2037062f-34 == 0.0; ```. which is something that should be solved by replacing `==` with `\approx`, but I wonder why this used to pass before but isn't passing now. In other words: I'm not sure if merely replacing equality with approximate equality is the right way to solve this test.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-994942677
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-994942677:96,Testability,Test,Test,96,"The errors of the `cpu-simulation-tests` are of this kind:. ```julia; JLD2 output writer [CPU]: Test Failed at /var/lib/buildkite-agent/builds/tartarus-2/clima/oceananigans/test/test_jld2_output_writer.jl:135; --;  | Expression: wT == zero(FT);  | Evaluated: -1.2037062f-34 == 0.0; ```. which is something that should be solved by replacing `==` with `\approx`, but I wonder why this used to pass before but isn't passing now. In other words: I'm not sure if merely replacing equality with approximate equality is the right way to solve this test.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-994942677
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-994942677:173,Testability,test,test,173,"The errors of the `cpu-simulation-tests` are of this kind:. ```julia; JLD2 output writer [CPU]: Test Failed at /var/lib/buildkite-agent/builds/tartarus-2/clima/oceananigans/test/test_jld2_output_writer.jl:135; --;  | Expression: wT == zero(FT);  | Evaluated: -1.2037062f-34 == 0.0; ```. which is something that should be solved by replacing `==` with `\approx`, but I wonder why this used to pass before but isn't passing now. In other words: I'm not sure if merely replacing equality with approximate equality is the right way to solve this test.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-994942677
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-994942677:544,Testability,test,test,544,"The errors of the `cpu-simulation-tests` are of this kind:. ```julia; JLD2 output writer [CPU]: Test Failed at /var/lib/buildkite-agent/builds/tartarus-2/clima/oceananigans/test/test_jld2_output_writer.jl:135; --;  | Expression: wT == zero(FT);  | Evaluated: -1.2037062f-34 == 0.0; ```. which is something that should be solved by replacing `==` with `\approx`, but I wonder why this used to pass before but isn't passing now. In other words: I'm not sure if merely replacing equality with approximate equality is the right way to solve this test.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-994942677
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-996061267:163,Testability,test,tests,163,> Is this a GPU problem? Is it still there when running on CPUs? We had some very early issues with this. Ali may remember.; > [](#). The equality failing in the tests happens for both CPUs and GPUs. The artifacts that appear in some simulations were only tested in CPUs I think. So it seems that GPUs aren't to blame here.Both issues (,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-996061267
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-996061267:257,Testability,test,tested,257,> Is this a GPU problem? Is it still there when running on CPUs? We had some very early issues with this. Ali may remember.; > [](#). The equality failing in the tests happens for both CPUs and GPUs. The artifacts that appear in some simulations were only tested in CPUs I think. So it seems that GPUs aren't to blame here.Both issues (,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-996061267
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-997111065:161,Testability,test,tests,161,"> Is this a GPU problem? Is it still there when running on CPUs? We had some very early issues with this. Ali may remember. I may not have been around for those tests! Here we're trying a different numerical algorithm that doesn't separate the hydrostatic and non-hydrostatic pressure. The numerics is different this way --- the non-hydrostatic pressure is in some sense treated ""implicitly"" (eg computed at t^{n+1} in order to advance the velocity field from n to n+1). The hydrostatic pressure, before this PR, was computed explicitly, at time-step t^n. The difference between the two numerical schemes could explain the issue @tomchor's observed (or there could be another bug).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-997111065
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-1106777287:67,Deployability,update,update,67,Unfortunately the PR previews are no longer showing so I'll try to update this PR...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-1106777287
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-1480029672:264,Deployability,integrat,integrating,264,"> Looks like this is a bad idea, so I'm closing. I'm not sure it's a bad idea. I've been having some issues with spurious waves in rotated domains and I'm thinking this might be the cause. (Since we're modifying the direction gravity is acting on, but we're still integrating the pressure in the model's z direction.). I still haven't been able to test my rotated domain on this branch, so I'm not sure. But if indeed this is the culprit, it might be a good idea to have a flag that turns the hydrostatic separation off for rotated domains.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-1480029672
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-1480029672:264,Integrability,integrat,integrating,264,"> Looks like this is a bad idea, so I'm closing. I'm not sure it's a bad idea. I've been having some issues with spurious waves in rotated domains and I'm thinking this might be the cause. (Since we're modifying the direction gravity is acting on, but we're still integrating the pressure in the model's z direction.). I still haven't been able to test my rotated domain on this branch, so I'm not sure. But if indeed this is the culprit, it might be a good idea to have a flag that turns the hydrostatic separation off for rotated domains.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-1480029672
https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-1480029672:348,Testability,test,test,348,"> Looks like this is a bad idea, so I'm closing. I'm not sure it's a bad idea. I've been having some issues with spurious waves in rotated domains and I'm thinking this might be the cause. (Since we're modifying the direction gravity is acting on, but we're still integrating the pressure in the model's z direction.). I still haven't been able to test my rotated domain on this branch, so I'm not sure. But if indeed this is the culprit, it might be a good idea to have a flag that turns the hydrostatic separation off for rotated domains.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910#issuecomment-1480029672
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890001070:690,Testability,benchmark,benchmark,690,"Nice, thanks!. I'm pretty surprised that `ab2_step_field!` dominates the cost. `ab2_step_field!` is this simple function:. https://github.com/CliMA/Oceananigans.jl/blob/9ecddac3fe2666e05f21e51b81ec2c403094e5ea/src/TimeSteppers/quasi_adams_bashforth_2.jl#L121. which seems much cheaper than something like `calculate_Gu!`. What's going on?. I'm also noticing that function is a bit sketchy because it uses the type of `` to convert `1.5` and `0.5`. This is fine if `` is a floating point number, but not otherwise... it should probably use `eltype(U)`. . How did you run the profiler? Does it make sense to add a new `profile` directory to the source code (or maybe just add something to `benchmark/`)?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890001070
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890001070:105,Usability,simpl,simple,105,"Nice, thanks!. I'm pretty surprised that `ab2_step_field!` dominates the cost. `ab2_step_field!` is this simple function:. https://github.com/CliMA/Oceananigans.jl/blob/9ecddac3fe2666e05f21e51b81ec2c403094e5ea/src/TimeSteppers/quasi_adams_bashforth_2.jl#L121. which seems much cheaper than something like `calculate_Gu!`. What's going on?. I'm also noticing that function is a bit sketchy because it uses the type of `` to convert `1.5` and `0.5`. This is fine if `` is a floating point number, but not otherwise... it should probably use `eltype(U)`. . How did you run the profiler? Does it make sense to add a new `profile` directory to the source code (or maybe just add something to `benchmark/`)?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890001070
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890002262:235,Performance,load,loaded,235,"Might be worthwhile to profile with `timestepper=:RungeKutta3` as a sanity check, considering that this benchmark suggests a simple time-stepping function is 12% (!) of the cost. Another thought --- we should probably benchmark ""fully loaded"" models that at least use WENO advection (and perhaps some turbulence closure?), since that's more realistic. I think most usage of `NonhydrostaticModel` also has one tracer, rather than two (someday, we should change that default...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890002262
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890002262:68,Safety,sanity check,sanity check,68,"Might be worthwhile to profile with `timestepper=:RungeKutta3` as a sanity check, considering that this benchmark suggests a simple time-stepping function is 12% (!) of the cost. Another thought --- we should probably benchmark ""fully loaded"" models that at least use WENO advection (and perhaps some turbulence closure?), since that's more realistic. I think most usage of `NonhydrostaticModel` also has one tracer, rather than two (someday, we should change that default...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890002262
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890002262:104,Testability,benchmark,benchmark,104,"Might be worthwhile to profile with `timestepper=:RungeKutta3` as a sanity check, considering that this benchmark suggests a simple time-stepping function is 12% (!) of the cost. Another thought --- we should probably benchmark ""fully loaded"" models that at least use WENO advection (and perhaps some turbulence closure?), since that's more realistic. I think most usage of `NonhydrostaticModel` also has one tracer, rather than two (someday, we should change that default...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890002262
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890002262:218,Testability,benchmark,benchmark,218,"Might be worthwhile to profile with `timestepper=:RungeKutta3` as a sanity check, considering that this benchmark suggests a simple time-stepping function is 12% (!) of the cost. Another thought --- we should probably benchmark ""fully loaded"" models that at least use WENO advection (and perhaps some turbulence closure?), since that's more realistic. I think most usage of `NonhydrostaticModel` also has one tracer, rather than two (someday, we should change that default...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890002262
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890002262:125,Usability,simpl,simple,125,"Might be worthwhile to profile with `timestepper=:RungeKutta3` as a sanity check, considering that this benchmark suggests a simple time-stepping function is 12% (!) of the cost. Another thought --- we should probably benchmark ""fully loaded"" models that at least use WENO advection (and perhaps some turbulence closure?), since that's more realistic. I think most usage of `NonhydrostaticModel` also has one tracer, rather than two (someday, we should change that default...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890002262
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890004382:228,Integrability,depend,dependent,228,"I just edited an old benchmarkable incompressible model script to only have the model setup and time stepping. I did not profile from the start, and only profiled the time_step! function line.; I feel like the profiles are more dependent on which system have which profiler, so it might make sense to just add a few simple scripts in `benchmark` that just consist of model setup and timestep and those can be called profiliables/benchmarkables.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890004382
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890004382:21,Testability,benchmark,benchmarkable,21,"I just edited an old benchmarkable incompressible model script to only have the model setup and time stepping. I did not profile from the start, and only profiled the time_step! function line.; I feel like the profiles are more dependent on which system have which profiler, so it might make sense to just add a few simple scripts in `benchmark` that just consist of model setup and timestep and those can be called profiliables/benchmarkables.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890004382
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890004382:335,Testability,benchmark,benchmark,335,"I just edited an old benchmarkable incompressible model script to only have the model setup and time stepping. I did not profile from the start, and only profiled the time_step! function line.; I feel like the profiles are more dependent on which system have which profiler, so it might make sense to just add a few simple scripts in `benchmark` that just consist of model setup and timestep and those can be called profiliables/benchmarkables.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890004382
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890004382:429,Testability,benchmark,benchmarkables,429,"I just edited an old benchmarkable incompressible model script to only have the model setup and time stepping. I did not profile from the start, and only profiled the time_step! function line.; I feel like the profiles are more dependent on which system have which profiler, so it might make sense to just add a few simple scripts in `benchmark` that just consist of model setup and timestep and those can be called profiliables/benchmarkables.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890004382
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890004382:316,Usability,simpl,simple,316,"I just edited an old benchmarkable incompressible model script to only have the model setup and time stepping. I did not profile from the start, and only profiled the time_step! function line.; I feel like the profiles are more dependent on which system have which profiler, so it might make sense to just add a few simple scripts in `benchmark` that just consist of model setup and timestep and those can be called profiliables/benchmarkables.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890004382
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890025103:232,Integrability,depend,dependent,232,"> I just edited an old benchmarkable incompressible model script to only have the model setup and time stepping. I did not profile from the start, and only profiled the time_step! function line.; > I feel like the profiles are more dependent on which system have which profiler, so it might make sense to just add a few simple scripts in `benchmark` that just consist of model setup and timestep and those can be called profiliables/benchmarkables. Ok! I can help with that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890025103
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890025103:23,Testability,benchmark,benchmarkable,23,"> I just edited an old benchmarkable incompressible model script to only have the model setup and time stepping. I did not profile from the start, and only profiled the time_step! function line.; > I feel like the profiles are more dependent on which system have which profiler, so it might make sense to just add a few simple scripts in `benchmark` that just consist of model setup and timestep and those can be called profiliables/benchmarkables. Ok! I can help with that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890025103
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890025103:339,Testability,benchmark,benchmark,339,"> I just edited an old benchmarkable incompressible model script to only have the model setup and time stepping. I did not profile from the start, and only profiled the time_step! function line.; > I feel like the profiles are more dependent on which system have which profiler, so it might make sense to just add a few simple scripts in `benchmark` that just consist of model setup and timestep and those can be called profiliables/benchmarkables. Ok! I can help with that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890025103
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890025103:433,Testability,benchmark,benchmarkables,433,"> I just edited an old benchmarkable incompressible model script to only have the model setup and time stepping. I did not profile from the start, and only profiled the time_step! function line.; > I feel like the profiles are more dependent on which system have which profiler, so it might make sense to just add a few simple scripts in `benchmark` that just consist of model setup and timestep and those can be called profiliables/benchmarkables. Ok! I can help with that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890025103
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890025103:320,Usability,simpl,simple,320,"> I just edited an old benchmarkable incompressible model script to only have the model setup and time stepping. I did not profile from the start, and only profiled the time_step! function line.; > I feel like the profiles are more dependent on which system have which profiler, so it might make sense to just add a few simple scripts in `benchmark` that just consist of model setup and timestep and those can be called profiliables/benchmarkables. Ok! I can help with that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890025103
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890029727:168,Availability,down,down,168,"@hennyg888 etc.. - this looks great. If we can get some scripts together then we can start automating some of this so we can see how things change, as well as tracking down anomalies. . CUDA.jl has a chart ( https://speed.juliagpu.org/changes/?exe=6&env=1&tre=50 ) that shows timing trends for different bits of the system. Not sure how they generate this!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890029727
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890071837:97,Testability,Benchmark,BenchmarkTools,97,"Here's the code used for the profiling.; ```; push!(LOAD_PATH, joinpath(@__DIR__, "".."")). #using BenchmarkTools; using CUDA; using Oceananigans; using Benchmarks. # Benchmark parameters. Arch = GPU; FT = Float64; N = 128. print_system_info(). # Define benchmarks. @info ""Setting up benchmark: ($Arch, $FT, $N)..."". grid = RegularRectilinearGrid(FT, size=(N, N, N), extent=(1, 1, 1)); model = NonhydrostaticModel(architecture=Arch(), grid=grid). @info ""warming up"". time_step!(model, 1). CUDA.@profile time_step!(model, 10000). @info ""done profiling ($Arch, $FT, $N)""; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890071837
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890071837:151,Testability,Benchmark,Benchmarks,151,"Here's the code used for the profiling.; ```; push!(LOAD_PATH, joinpath(@__DIR__, "".."")). #using BenchmarkTools; using CUDA; using Oceananigans; using Benchmarks. # Benchmark parameters. Arch = GPU; FT = Float64; N = 128. print_system_info(). # Define benchmarks. @info ""Setting up benchmark: ($Arch, $FT, $N)..."". grid = RegularRectilinearGrid(FT, size=(N, N, N), extent=(1, 1, 1)); model = NonhydrostaticModel(architecture=Arch(), grid=grid). @info ""warming up"". time_step!(model, 1). CUDA.@profile time_step!(model, 10000). @info ""done profiling ($Arch, $FT, $N)""; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890071837
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890071837:165,Testability,Benchmark,Benchmark,165,"Here's the code used for the profiling.; ```; push!(LOAD_PATH, joinpath(@__DIR__, "".."")). #using BenchmarkTools; using CUDA; using Oceananigans; using Benchmarks. # Benchmark parameters. Arch = GPU; FT = Float64; N = 128. print_system_info(). # Define benchmarks. @info ""Setting up benchmark: ($Arch, $FT, $N)..."". grid = RegularRectilinearGrid(FT, size=(N, N, N), extent=(1, 1, 1)); model = NonhydrostaticModel(architecture=Arch(), grid=grid). @info ""warming up"". time_step!(model, 1). CUDA.@profile time_step!(model, 10000). @info ""done profiling ($Arch, $FT, $N)""; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890071837
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890071837:252,Testability,benchmark,benchmarks,252,"Here's the code used for the profiling.; ```; push!(LOAD_PATH, joinpath(@__DIR__, "".."")). #using BenchmarkTools; using CUDA; using Oceananigans; using Benchmarks. # Benchmark parameters. Arch = GPU; FT = Float64; N = 128. print_system_info(). # Define benchmarks. @info ""Setting up benchmark: ($Arch, $FT, $N)..."". grid = RegularRectilinearGrid(FT, size=(N, N, N), extent=(1, 1, 1)); model = NonhydrostaticModel(architecture=Arch(), grid=grid). @info ""warming up"". time_step!(model, 1). CUDA.@profile time_step!(model, 10000). @info ""done profiling ($Arch, $FT, $N)""; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890071837
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890071837:282,Testability,benchmark,benchmark,282,"Here's the code used for the profiling.; ```; push!(LOAD_PATH, joinpath(@__DIR__, "".."")). #using BenchmarkTools; using CUDA; using Oceananigans; using Benchmarks. # Benchmark parameters. Arch = GPU; FT = Float64; N = 128. print_system_info(). # Define benchmarks. @info ""Setting up benchmark: ($Arch, $FT, $N)..."". grid = RegularRectilinearGrid(FT, size=(N, N, N), extent=(1, 1, 1)); model = NonhydrostaticModel(architecture=Arch(), grid=grid). @info ""warming up"". time_step!(model, 1). CUDA.@profile time_step!(model, 10000). @info ""done profiling ($Arch, $FT, $N)""; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-890071837
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-892297846:31932,Integrability,contract,contract,31932,"m::Simulation{NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w, :b), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.Offs...; 781 0 @Base/boot.jl 360 eval; 781 0 @Base/loading.jl 1116 include_string(mapexpr::typeof(identity), mod::Module, code::String, filename::String); 781 0 @Base/loading.jl 1170 _include(mapexpr::Function, mod::Module, _path::String); 781 0 @Base/Base.jl 386 include(mod::Module, _path::String); 781 0 @Base/client.jl 285 exec_options(opts::Base.JLOptions); 781 0 @Base/client.jl 485 _start(); 796 796 @Cassette/src/context.jl ? overdub; 821 0 @Oceananigans/src/Advection/topologically_conditional_interpolation.jl 36 _right_biased_interpolate_y(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePreci...; 821 0 @Oceananigans/src/Advection/upwind_biased_advective_fluxes.jl 85 overdub; 860 860 @KernelAbstractions/src/compiler/contract.jl 18 sub_float_contract; 860 0 @KernelAbstractions/src/compiler.jl 46 overdub; 873 0 @Oceananigans/src/Advection/weno_fifth_order.jl 148 overdub; 879 0 @Oceananigans/src/Operators/difference_operators.jl 23 y(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.Twice...; 903 0 @Oceananigans/src/Advection/topologically_conditional_interpolation.jl 36 _right_biased_interpolate_y(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePreci...; 903 0 @Oceananigans/src/Advection/upwind_biased_advective_fluxes.jl 31 overdub; 911 0 @Oceananigans/src/Advection/topologically_conditional_interpolation.jl 36 _left_biased_interpolate_x(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, Offs",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-892297846
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-892297846:38491,Integrability,contract,contract,38491,"wicePrecision{Float64}, Base.Twice...; 1363 0 @Oceananigans/src/Advection/momentum_advection_operators.jl 8 _advective_momentum_flux_Uu(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecisio...; 1363 0 @Oceananigans/src/Advection/momentum_advection_operators.jl 8 overdub; 1363 0 @Oceananigans/src/Operators/difference_operators.jl 21 x(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.Twice...; 1372 0 @Oceananigans/src/Operators/difference_operators.jl 21 overdub; 1602 0 @Oceananigans/src/Operators/difference_operators.jl 20 x(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.Twice...; 1681 1681 @KernelAbstractions/src/compiler/contract.jl 18 mul_float_contract; 1681 0 @KernelAbstractions/src/compiler.jl 47 overdub; 1714 0 @Oceananigans/src/Advection/momentum_advection_operators.jl 9 _advective_momentum_flux_Vu(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecisio...; 1714 0 @Oceananigans/src/Advection/momentum_advection_operators.jl 9 overdub; 1714 0 @Oceananigans/src/Operators/difference_operators.jl 23 y(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.Twice...; 1781 0 @Oceananigans/src/Advection/momentum_advection_operators.jl 13 _advective_momentum_flux_Vv(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecisio...; 1781 0 @Oceananigan",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-892297846
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-892297846:41498,Integrability,contract,contract,41498,"70 0 @Oceananigans/src/Advection/momentum_advection_operators.jl 17 _advective_momentum_flux_Vw(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecisio...; 1970 0 @Oceananigans/src/Advection/momentum_advection_operators.jl 17 overdub; 1970 0 @Oceananigans/src/Operators/difference_operators.jl 23 y(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.Twice...; 2094 0 @Oceananigans/src/Advection/weno_fifth_order.jl 226 overdub; 2183 0 @Base/operators.jl 560 +(::Float64, ::Float64, ::Float64); 2262 0 @Base/operators.jl 560 overdub; 2381 0 @Oceananigans/src/Advection/weno_fifth_order.jl 216 overdub; 2395 0 @Oceananigans/src/Advection/weno_fifth_order.jl 211 overdub; 2471 0 @Oceananigans/src/Advection/weno_fifth_order.jl 231 overdub; 3033 3033 @KernelAbstractions/src/compiler/contract.jl 18 add_float_contract; 3033 0 @KernelAbstractions/src/compiler.jl 45 overdub; 3688 0 @Oceananigans/src/Operators/difference_operators.jl 26 overdub; 4069 0 @Oceananigans/src/Advection/tracer_advection_operators.jl 28 div_Uc(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.Twic...; 4069 0 @Oceananigans/src/Advection/tracer_advection_operators.jl 28 overdub; 4202 0 @Oceananigans/src/Models/NonhydrostaticModels/velocity_and_tracer_tendencies.jl 186 overdub; 4469 4469 @Oceananigans/src/Advection/topologically_conditional_interpolation.jl ? overdub; 4570 0 @Oceananigans/src/Advection/momentum_advection_operators.jl 57 div_u(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.Twic...; 4570 0 @Oce",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-892297846
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-892297846:31141,Performance,load,loading,31141,"Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecisi...; 763 0 @Oceananigans/src/Advection/weno_fifth_order.jl 211 left_biased_interpolate_x(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecisi...; 768 0 @Oceananigans/src/Advection/topologically_conditional_interpolation.jl 36 _right_biased_interpolate_x(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePreci...; 768 0 @Oceananigans/src/Advection/upwind_biased_advective_fluxes.jl 49 overdub; 781 0 @Oceananigans/src/Simulations/run.jl 127 run!(sim::Simulation{NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w, :b), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.Offs...; 781 0 @Base/boot.jl 360 eval; 781 0 @Base/loading.jl 1116 include_string(mapexpr::typeof(identity), mod::Module, code::String, filename::String); 781 0 @Base/loading.jl 1170 _include(mapexpr::Function, mod::Module, _path::String); 781 0 @Base/Base.jl 386 include(mod::Module, _path::String); 781 0 @Base/client.jl 285 exec_options(opts::Base.JLOptions); 781 0 @Base/client.jl 485 _start(); 796 796 @Cassette/src/context.jl ? overdub; 821 0 @Oceananigans/src/Advection/topologically_conditional_interpolation.jl 36 _right_biased_interpolate_y(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePreci...; 821 0 @Oceananigans/src/Advection/upwind_biased_advective_fluxes.jl 85 overdub; 860 860 @KernelAbstractions/src/compiler/contract.jl 18 sub_float_contract; 860 0 @KernelAbstractions/src/compiler.jl 46 overdub; 873 0 @Oceananigans/src/Advection/weno_fifth_order.jl 148 overdub; 879 0 @Oceananigans/src/Operators/difference_",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-892297846
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-892297846:31257,Performance,load,loading,31257,"n{Float64, Base.TwicePrecisi...; 763 0 @Oceananigans/src/Advection/weno_fifth_order.jl 211 left_biased_interpolate_x(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecisi...; 768 0 @Oceananigans/src/Advection/topologically_conditional_interpolation.jl 36 _right_biased_interpolate_x(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePreci...; 768 0 @Oceananigans/src/Advection/upwind_biased_advective_fluxes.jl 49 overdub; 781 0 @Oceananigans/src/Simulations/run.jl 127 run!(sim::Simulation{NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w, :b), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.Offs...; 781 0 @Base/boot.jl 360 eval; 781 0 @Base/loading.jl 1116 include_string(mapexpr::typeof(identity), mod::Module, code::String, filename::String); 781 0 @Base/loading.jl 1170 _include(mapexpr::Function, mod::Module, _path::String); 781 0 @Base/Base.jl 386 include(mod::Module, _path::String); 781 0 @Base/client.jl 285 exec_options(opts::Base.JLOptions); 781 0 @Base/client.jl 485 _start(); 796 796 @Cassette/src/context.jl ? overdub; 821 0 @Oceananigans/src/Advection/topologically_conditional_interpolation.jl 36 _right_biased_interpolate_y(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePreci...; 821 0 @Oceananigans/src/Advection/upwind_biased_advective_fluxes.jl 85 overdub; 860 860 @KernelAbstractions/src/compiler/contract.jl 18 sub_float_contract; 860 0 @KernelAbstractions/src/compiler.jl 46 overdub; 873 0 @Oceananigans/src/Advection/weno_fifth_order.jl 148 overdub; 879 0 @Oceananigans/src/Operators/difference_operators.jl 23 y(::Int64, ::Int64, ::Int64, ::RegularRectilinearGrid{",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-892297846
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-892672795:301,Testability,benchmark,benchmarking,301,"No worries don't apologies! I made the same mistake after reading [Hendrik Ranocha's blog post](https://ranocha.de/blog/Optimizing_EC_Trixi) and seeing. ![image](https://user-images.githubusercontent.com/15271942/128191753-8febcd84-8230-4def-ba80-8aaf848b92a0.png). But this is actually the output of benchmarking on individual components of the time-stepping scheme. I think it'd be a good idea to setup similar microbenchmarks of the time-stepping components (`update_state!`, `calculate_tendencies!`, etc). This is not quite the same as profiling but yields slightly more precise and also more digestible information about timings and relative cost of things per time-step.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-892672795
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-892703448:535,Safety,avoid,avoid,535,> @hennyg888 I think we need line info (not just file) to precisely interpret the profiling results?. If you scroll right in my big block of text you can see a column that shows the line number and function name in the file specified in the file column that's visible without scrolling. Please see the full file attached below. Might be easier to view or reformat than the embedded code block above.; [nonhydrostatic_profile_flat.txt](https://github.com/CliMA/Oceananigans.jl/files/6931920/nonhydrostatic_profile_flat.txt). I tried to avoid flame graphs and go for something as close to percentages as I could so I went with the default output. I'll add in StatProfilerHTML.jl outputs as well since the flame graphs and html files do look very neat. In the very last row there's a total snapshots count of 24177. Dividing the counts shown in the left-most column by this number should give the percentage time spent on this line or in any functions executed by this line.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-892703448
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-893914746:1172,Availability,avail,available,1172,"g 128^3. Now it seems that timestepping takes less than 5% of the time and what should be taking up the largest chunks of time are doing so.; ```; Oceananigans v0.60.0; Julia Version 1.6.2; Commit 1b93d53fc4 (2021-07-14 15:36 UTC); Platform Info:; OS: Linux (powerpc64le-unknown-linux-gnu); CPU: unknown; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, pwr9); GPU: Tesla V100-SXM2-32GB. CUDA toolkit 10.2.89, local installation; CUDA driver 10.2.0; NVIDIA driver 440.64.0. Libraries: ; - CUBLAS: 10.2.2; - CURAND: 10.1.2; - CUFFT: 10.1.2; - CUSOLVER: 10.3.0; - CUSPARSE: 10.3.1; - CUPTI: 12.0.0; - NVML: 10.0.0+440.64.0; - CUDNN: missing; - CUTENSOR: missing. Toolchain:; - Julia: 1.6.2; - LLVM: 11.0.1; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4, 6.5; - Device capability support: sm_30, sm_32, sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75. 2 devices:; 0: Tesla V100-SXM2-32GB (sm_70, 4.367 GiB / 31.749 GiB available); 1: Tesla V100-SXM2-32GB (sm_70, 4.805 GiB / 31.749 GiB available); nothing. [2021/08/05 12:11:43.425] INFO Setting up benchmark: (GPU, Float64, 128)...; [2021/08/05 12:12:45.688] INFO warming up; [2021/08/05 12:15:06.837] INFO Simulation is stopping. Model iteration 1 has hit or exceeded simulation stop iteration 1.; [2021/08/05 12:15:07.841] INFO Simulation is stopping. Model iteration 11 has hit or exceeded simulation stop iteration 11.; [2021/08/05 12:15:10.060] INFO done profiling (GPU, Float64, 128); ==45925== Profiling application: /nobackup/users/henryguo/projects/henry-test/julia-1.6.2/bin/julia --project nonhydrostatic_profiler.jl; ==45925== Profiling result:; Type Time(%) Time Calls Avg Min Max Name; GPU activities: 20.46% 17.966ms 10 1.7966ms 1.7946ms 1.7987ms _Z23julia_gpu_calculate_Gv_7ContextI14__CUDACtx_Namevv14__PassType_257v12DisableHooksE18_gpu_calculate_Gv_16CompilerMetadataI10StaticSizeI15_128__128__128_E12DynamicCheckvv7NDRangeILi3ES5_I11_8__8__128_ES5_I11_16__16__1_EvvEE",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-893914746
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-893914746:1239,Availability,avail,available,1239,"n 5% of the time and what should be taking up the largest chunks of time are doing so.; ```; Oceananigans v0.60.0; Julia Version 1.6.2; Commit 1b93d53fc4 (2021-07-14 15:36 UTC); Platform Info:; OS: Linux (powerpc64le-unknown-linux-gnu); CPU: unknown; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, pwr9); GPU: Tesla V100-SXM2-32GB. CUDA toolkit 10.2.89, local installation; CUDA driver 10.2.0; NVIDIA driver 440.64.0. Libraries: ; - CUBLAS: 10.2.2; - CURAND: 10.1.2; - CUFFT: 10.1.2; - CUSOLVER: 10.3.0; - CUSPARSE: 10.3.1; - CUPTI: 12.0.0; - NVML: 10.0.0+440.64.0; - CUDNN: missing; - CUTENSOR: missing. Toolchain:; - Julia: 1.6.2; - LLVM: 11.0.1; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4, 6.5; - Device capability support: sm_30, sm_32, sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75. 2 devices:; 0: Tesla V100-SXM2-32GB (sm_70, 4.367 GiB / 31.749 GiB available); 1: Tesla V100-SXM2-32GB (sm_70, 4.805 GiB / 31.749 GiB available); nothing. [2021/08/05 12:11:43.425] INFO Setting up benchmark: (GPU, Float64, 128)...; [2021/08/05 12:12:45.688] INFO warming up; [2021/08/05 12:15:06.837] INFO Simulation is stopping. Model iteration 1 has hit or exceeded simulation stop iteration 1.; [2021/08/05 12:15:07.841] INFO Simulation is stopping. Model iteration 11 has hit or exceeded simulation stop iteration 11.; [2021/08/05 12:15:10.060] INFO done profiling (GPU, Float64, 128); ==45925== Profiling application: /nobackup/users/henryguo/projects/henry-test/julia-1.6.2/bin/julia --project nonhydrostatic_profiler.jl; ==45925== Profiling result:; Type Time(%) Time Calls Avg Min Max Name; GPU activities: 20.46% 17.966ms 10 1.7966ms 1.7946ms 1.7987ms _Z23julia_gpu_calculate_Gv_7ContextI14__CUDACtx_Namevv14__PassType_257v12DisableHooksE18_gpu_calculate_Gv_16CompilerMetadataI10StaticSizeI15_128__128__128_E12DynamicCheckvv7NDRangeILi3ES5_I11_8__8__128_ES5_I11_16__16__1_EvvEE11OffsetArrayI7Float64Li3E13CuDeviceArrayIS9_Li3ELi1EE",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-893914746
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-893914746:622,Deployability,install,installation,622,"Profiling results for the nonhydrostatic model on GPU with the script found in #1914.; This was done on Satori, and with the WENO5 advection scheme and AB2 timestepper with the grid size being 128^3. Now it seems that timestepping takes less than 5% of the time and what should be taking up the largest chunks of time are doing so.; ```; Oceananigans v0.60.0; Julia Version 1.6.2; Commit 1b93d53fc4 (2021-07-14 15:36 UTC); Platform Info:; OS: Linux (powerpc64le-unknown-linux-gnu); CPU: unknown; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, pwr9); GPU: Tesla V100-SXM2-32GB. CUDA toolkit 10.2.89, local installation; CUDA driver 10.2.0; NVIDIA driver 440.64.0. Libraries: ; - CUBLAS: 10.2.2; - CURAND: 10.1.2; - CUFFT: 10.1.2; - CUSOLVER: 10.3.0; - CUSPARSE: 10.3.1; - CUPTI: 12.0.0; - NVML: 10.0.0+440.64.0; - CUDNN: missing; - CUTENSOR: missing. Toolchain:; - Julia: 1.6.2; - LLVM: 11.0.1; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4, 6.5; - Device capability support: sm_30, sm_32, sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75. 2 devices:; 0: Tesla V100-SXM2-32GB (sm_70, 4.367 GiB / 31.749 GiB available); 1: Tesla V100-SXM2-32GB (sm_70, 4.805 GiB / 31.749 GiB available); nothing. [2021/08/05 12:11:43.425] INFO Setting up benchmark: (GPU, Float64, 128)...; [2021/08/05 12:12:45.688] INFO warming up; [2021/08/05 12:15:06.837] INFO Simulation is stopping. Model iteration 1 has hit or exceeded simulation stop iteration 1.; [2021/08/05 12:15:07.841] INFO Simulation is stopping. Model iteration 11 has hit or exceeded simulation stop iteration 11.; [2021/08/05 12:15:10.060] INFO done profiling (GPU, Float64, 128); ==45925== Profiling application: /nobackup/users/henryguo/projects/henry-test/julia-1.6.2/bin/julia --project nonhydrostatic_profiler.jl; ==45925== Profiling result:; Type Time(%) Time Calls Avg Min Max Name; GPU activities: 20.46% 17.966ms 10 1.7966ms 1.7946ms 1.7987ms _Z23julia_gpu_calculate_Gv_7Context",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-893914746
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-893914746:1302,Testability,benchmark,benchmark,1302,"ks of time are doing so.; ```; Oceananigans v0.60.0; Julia Version 1.6.2; Commit 1b93d53fc4 (2021-07-14 15:36 UTC); Platform Info:; OS: Linux (powerpc64le-unknown-linux-gnu); CPU: unknown; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, pwr9); GPU: Tesla V100-SXM2-32GB. CUDA toolkit 10.2.89, local installation; CUDA driver 10.2.0; NVIDIA driver 440.64.0. Libraries: ; - CUBLAS: 10.2.2; - CURAND: 10.1.2; - CUFFT: 10.1.2; - CUSOLVER: 10.3.0; - CUSPARSE: 10.3.1; - CUPTI: 12.0.0; - NVML: 10.0.0+440.64.0; - CUDNN: missing; - CUTENSOR: missing. Toolchain:; - Julia: 1.6.2; - LLVM: 11.0.1; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4, 6.5; - Device capability support: sm_30, sm_32, sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75. 2 devices:; 0: Tesla V100-SXM2-32GB (sm_70, 4.367 GiB / 31.749 GiB available); 1: Tesla V100-SXM2-32GB (sm_70, 4.805 GiB / 31.749 GiB available); nothing. [2021/08/05 12:11:43.425] INFO Setting up benchmark: (GPU, Float64, 128)...; [2021/08/05 12:12:45.688] INFO warming up; [2021/08/05 12:15:06.837] INFO Simulation is stopping. Model iteration 1 has hit or exceeded simulation stop iteration 1.; [2021/08/05 12:15:07.841] INFO Simulation is stopping. Model iteration 11 has hit or exceeded simulation stop iteration 11.; [2021/08/05 12:15:10.060] INFO done profiling (GPU, Float64, 128); ==45925== Profiling application: /nobackup/users/henryguo/projects/henry-test/julia-1.6.2/bin/julia --project nonhydrostatic_profiler.jl; ==45925== Profiling result:; Type Time(%) Time Calls Avg Min Max Name; GPU activities: 20.46% 17.966ms 10 1.7966ms 1.7946ms 1.7987ms _Z23julia_gpu_calculate_Gv_7ContextI14__CUDACtx_Namevv14__PassType_257v12DisableHooksE18_gpu_calculate_Gv_16CompilerMetadataI10StaticSizeI15_128__128__128_E12DynamicCheckvv7NDRangeILi3ES5_I11_8__8__128_ES5_I11_16__16__1_EvvEE11OffsetArrayI7Float64Li3E13CuDeviceArrayIS9_Li3ELi1EEE22RegularRectilinearGridIS9_8PeriodicS12_7BoundedS8_IS9_Li1E1",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-893914746
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-893914746:1768,Testability,test,test,1768,"RAND: 10.1.2; - CUFFT: 10.1.2; - CUSOLVER: 10.3.0; - CUSPARSE: 10.3.1; - CUPTI: 12.0.0; - NVML: 10.0.0+440.64.0; - CUDNN: missing; - CUTENSOR: missing. Toolchain:; - Julia: 1.6.2; - LLVM: 11.0.1; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4, 6.5; - Device capability support: sm_30, sm_32, sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75. 2 devices:; 0: Tesla V100-SXM2-32GB (sm_70, 4.367 GiB / 31.749 GiB available); 1: Tesla V100-SXM2-32GB (sm_70, 4.805 GiB / 31.749 GiB available); nothing. [2021/08/05 12:11:43.425] INFO Setting up benchmark: (GPU, Float64, 128)...; [2021/08/05 12:12:45.688] INFO warming up; [2021/08/05 12:15:06.837] INFO Simulation is stopping. Model iteration 1 has hit or exceeded simulation stop iteration 1.; [2021/08/05 12:15:07.841] INFO Simulation is stopping. Model iteration 11 has hit or exceeded simulation stop iteration 11.; [2021/08/05 12:15:10.060] INFO done profiling (GPU, Float64, 128); ==45925== Profiling application: /nobackup/users/henryguo/projects/henry-test/julia-1.6.2/bin/julia --project nonhydrostatic_profiler.jl; ==45925== Profiling result:; Type Time(%) Time Calls Avg Min Max Name; GPU activities: 20.46% 17.966ms 10 1.7966ms 1.7946ms 1.7987ms _Z23julia_gpu_calculate_Gv_7ContextI14__CUDACtx_Namevv14__PassType_257v12DisableHooksE18_gpu_calculate_Gv_16CompilerMetadataI10StaticSizeI15_128__128__128_E12DynamicCheckvv7NDRangeILi3ES5_I11_8__8__128_ES5_I11_16__16__1_EvvEE11OffsetArrayI7Float64Li3E13CuDeviceArrayIS9_Li3ELi1EEE22RegularRectilinearGridIS9_8PeriodicS12_7BoundedS8_IS9_Li1E12StepRangeLenIS9_14TwicePrecisionIS9_ES15_IS9_EEEE5WENO5vv20IsotropicDiffusivityI26ExplicitTimeDiscretizationS9_10NamedTupleI5__b__5TupleIS9_EEE8BuoyancyI14BuoyancyTracer10ZDirectionES19_I23__velocities___tracers_S20_IS19_I12__u___v___w_S20_I9ZeroFieldS24_S24_EES19_I5__b__S20_IS24_EEEES19_I12__u___v___w_S20_IS8_IS9_Li3ES10_IS9_Li3ELi1EEES8_IS9_Li3ES10_IS9_Li3ELi1EEES8_IS9_Li3ES10_IS9_Li3ELi1EEEEES19_I5__b",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-893914746
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-894239292:1344,Performance,perform,performance,1344,"> @glwagner I also ran into some problems using `StatProfilerHTML.jl` to make flame graphs for CPU profiles. This is from the same script used to obtain the results above and shown in #1914 and it's a 128^3 nonhydrostatic model. The flame graphs don't display the function names, and all I can see is ""overdub"". By hovering my mouse over the slabs and going up each flame stack I can usually find a function name that makes sense somewhere but that prevents us from making at-a-glance analysis of the profile flame graph.; > ![image](https://user-images.githubusercontent.com/45054739/128443657-7b18d4f9-0168-4bee-b85b-2ade021165d3.png); > I thought that this might have something to do with profiling `run(simulation, 10)` instead of a for loop of `time_step!(model,1)` but apparently the result is the same for both cases. I believe this is inevitable, because all our kernels are compiled through `Cassette.jl`, which ""overdubs"" the julia compiler when compiling functions tagged with `@kernel` (the majority of our expensive kernels). This is part of the design of `KernelAbstractions.jl`... Really great work @hennyg888. Perhaps the complexity of our function calls via `KernelAbstractions.jl` argues for a better profiling approach? Is there a way to ""filter"" the profiled output to remove data? . I think the next step towards improving performance is to figure out how to optimize the tendency calculations for CPU or GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-894239292
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-894239292:1380,Performance,optimiz,optimize,1380,"> @glwagner I also ran into some problems using `StatProfilerHTML.jl` to make flame graphs for CPU profiles. This is from the same script used to obtain the results above and shown in #1914 and it's a 128^3 nonhydrostatic model. The flame graphs don't display the function names, and all I can see is ""overdub"". By hovering my mouse over the slabs and going up each flame stack I can usually find a function name that makes sense somewhere but that prevents us from making at-a-glance analysis of the profile flame graph.; > ![image](https://user-images.githubusercontent.com/45054739/128443657-7b18d4f9-0168-4bee-b85b-2ade021165d3.png); > I thought that this might have something to do with profiling `run(simulation, 10)` instead of a for loop of `time_step!(model,1)` but apparently the result is the same for both cases. I believe this is inevitable, because all our kernels are compiled through `Cassette.jl`, which ""overdubs"" the julia compiler when compiling functions tagged with `@kernel` (the majority of our expensive kernels). This is part of the design of `KernelAbstractions.jl`... Really great work @hennyg888. Perhaps the complexity of our function calls via `KernelAbstractions.jl` argues for a better profiling approach? Is there a way to ""filter"" the profiled output to remove data? . I think the next step towards improving performance is to figure out how to optimize the tendency calculations for CPU or GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-894239292
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-894291059:749,Availability,down,down,749,"> @christophernhill do you think you could produce a script with non-trivial dynamics involving the `HydrostaticFreeSurfaceModel` and the implicit solver?; > ; > We should also come up with something that exercises the tridiagonal solver on a vertically-stretched grid. @glwagner @francispoulin and @hennyg888, we could start from https://github.com/CliMA/Oceananigans.jl/blob/master/validation/barotropic_gyre/barotropic_gyre.jl ? I'll check that it is still healthy. We can make the number of points bigger or smaller to look at problem size. Do we want to also try `RegularLatitudeLongitudeGrid` or should we do a box first . This also has an `ImmersedBoundaryGrid` bump in the domain - we can get rid of that for now, but could include that too down the road. . We should be able to add some vertical levels to this and turn on some implicit vertical diffusion - which is another tridiagonal solve?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-894291059
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-894291059:384,Security,validat,validation,384,"> @christophernhill do you think you could produce a script with non-trivial dynamics involving the `HydrostaticFreeSurfaceModel` and the implicit solver?; > ; > We should also come up with something that exercises the tridiagonal solver on a vertically-stretched grid. @glwagner @francispoulin and @hennyg888, we could start from https://github.com/CliMA/Oceananigans.jl/blob/master/validation/barotropic_gyre/barotropic_gyre.jl ? I'll check that it is still healthy. We can make the number of points bigger or smaller to look at problem size. Do we want to also try `RegularLatitudeLongitudeGrid` or should we do a box first . This also has an `ImmersedBoundaryGrid` bump in the domain - we can get rid of that for now, but could include that too down the road. . We should be able to add some vertical levels to this and turn on some implicit vertical diffusion - which is another tridiagonal solve?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-894291059
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-894596840:174,Testability,benchmark,benchmarking,174,@glwagner @francispoulin and @hennyg888 I added #1928 toward being able to do a meaningful `HydrostaticFreeSurface`. When #1928 is fixed we should be good to add a setup for benchmarking. ,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-894596840
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-894674873:80,Deployability,Continuous,ContinuousBoundaryFunction,80,"@christophernhill is it possible to come up with a benchmark that does not use `ContinuousBoundaryFunction`, thereby avoiding the bug in #1928 ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-894674873
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-894674873:117,Safety,avoid,avoiding,117,"@christophernhill is it possible to come up with a benchmark that does not use `ContinuousBoundaryFunction`, thereby avoiding the bug in #1928 ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-894674873
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-894674873:51,Testability,benchmark,benchmark,51,"@christophernhill is it possible to come up with a benchmark that does not use `ContinuousBoundaryFunction`, thereby avoiding the bug in #1928 ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-894674873
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-895239884:111,Testability,benchmark,benchmarking,111,@christophernhill : I see that #1928 has now been merged. Do you have an example that you would like us to try benchmarking?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-895239884
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-898095311:1852,Availability,avail,available,1852,"status of the cuda streams so larger grids taking more time to run the kernels than launching the kernels may have something to do with it.; ```; Oceananigans v0.61.0; Julia Version 1.6.2; Commit 1b93d53fc4 (2021-07-14 15:36 UTC); Platform Info:; OS: Linux (powerpc64le-unknown-linux-gnu); CPU: unknown; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, pwr9); GPU: Tesla V100-SXM2-32GB. CUDA toolkit 10.2.89, local installation; CUDA driver 10.2.0; NVIDIA driver 440.64.0. Libraries: ; - CUBLAS: 10.2.2; - CURAND: 10.1.2; - CUFFT: 10.1.2; - CUSOLVER: 10.3.0; - CUSPARSE: 10.3.1; - CUPTI: 12.0.0; - NVML: 10.0.0+440.64.0; - CUDNN: missing; - CUTENSOR: missing. Toolchain:; - Julia: 1.6.2; - LLVM: 11.0.1; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4, 6.5; - Device capability support: sm_30, sm_32, sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75. 2 devices:; 0: Tesla V100-SXM2-32GB (sm_70, 31.432 GiB / 31.749 GiB available); 1: Tesla V100-SXM2-32GB (sm_70, 31.738 GiB / 31.749 GiB available); nothing. [2021/08/11 22:39:51.084] INFO Setting up benchmark: (GPU, Float64, 2048)...; [2021/08/11 22:40:32.330] INFO warming up; [2021/08/11 22:41:32.311] INFO Simulation is stopping. Model iteration 1 has hit or exceeded simulation stop iteration 1.; [2021/08/11 22:41:32.729] WARN Calling CUDA.@profile only informs an external profiler to start.; The user is responsible for launching Julia under a CUDA profiler. It is recommended to use Nsight Systems, which supports interactive profiling:; $ nsys launch julia -@-> /home/henryguo/.julia/packages/CUDA/CtvPY/lib/cudadrv/profile.jl:71; [2021/08/11 22:41:32.777] INFO Simulation is stopping. Model iteration 11 has hit or exceeded simulation stop iteration 11.; [2021/08/11 22:41:34.842] INFO done profiling (GPU, Float64, 2048); ==41185== Profiling application: /nobackup/users/henryguo/projects/henry-test/julia-1.6.2/bin/julia --project shallow_water_profiler.jl; ==41185== Profilin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-898095311
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-898095311:1920,Availability,avail,available,1920,"time to run the kernels than launching the kernels may have something to do with it.; ```; Oceananigans v0.61.0; Julia Version 1.6.2; Commit 1b93d53fc4 (2021-07-14 15:36 UTC); Platform Info:; OS: Linux (powerpc64le-unknown-linux-gnu); CPU: unknown; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, pwr9); GPU: Tesla V100-SXM2-32GB. CUDA toolkit 10.2.89, local installation; CUDA driver 10.2.0; NVIDIA driver 440.64.0. Libraries: ; - CUBLAS: 10.2.2; - CURAND: 10.1.2; - CUFFT: 10.1.2; - CUSOLVER: 10.3.0; - CUSPARSE: 10.3.1; - CUPTI: 12.0.0; - NVML: 10.0.0+440.64.0; - CUDNN: missing; - CUTENSOR: missing. Toolchain:; - Julia: 1.6.2; - LLVM: 11.0.1; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4, 6.5; - Device capability support: sm_30, sm_32, sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75. 2 devices:; 0: Tesla V100-SXM2-32GB (sm_70, 31.432 GiB / 31.749 GiB available); 1: Tesla V100-SXM2-32GB (sm_70, 31.738 GiB / 31.749 GiB available); nothing. [2021/08/11 22:39:51.084] INFO Setting up benchmark: (GPU, Float64, 2048)...; [2021/08/11 22:40:32.330] INFO warming up; [2021/08/11 22:41:32.311] INFO Simulation is stopping. Model iteration 1 has hit or exceeded simulation stop iteration 1.; [2021/08/11 22:41:32.729] WARN Calling CUDA.@profile only informs an external profiler to start.; The user is responsible for launching Julia under a CUDA profiler. It is recommended to use Nsight Systems, which supports interactive profiling:; $ nsys launch julia -@-> /home/henryguo/.julia/packages/CUDA/CtvPY/lib/cudadrv/profile.jl:71; [2021/08/11 22:41:32.777] INFO Simulation is stopping. Model iteration 11 has hit or exceeded simulation stop iteration 11.; [2021/08/11 22:41:34.842] INFO done profiling (GPU, Float64, 2048); ==41185== Profiling application: /nobackup/users/henryguo/projects/henry-test/julia-1.6.2/bin/julia --project shallow_water_profiler.jl; ==41185== Profiling result:; Type Time(%) Time Calls Avg Min Max Name; G",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-898095311
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-898095311:1301,Deployability,install,installation,1301,"her grid resolutions profiled had about the same GPU activities result as shown below and so only one set is shown. As far as @francispoulin and I know, the GPU activities seem to be correct, with what should be taking up the most time doing so.; However, for API calls, results differ a lot based on grid resolution. As the grid increases in size, `cuStreamQuery` and eventually `cuCtxGetCurrent` becomes the dominant API call. See below the API call profile result tables for the different grid sizes. It seems that `cuStreamQuery` is what is checking on the status of the cuda streams so larger grids taking more time to run the kernels than launching the kernels may have something to do with it.; ```; Oceananigans v0.61.0; Julia Version 1.6.2; Commit 1b93d53fc4 (2021-07-14 15:36 UTC); Platform Info:; OS: Linux (powerpc64le-unknown-linux-gnu); CPU: unknown; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, pwr9); GPU: Tesla V100-SXM2-32GB. CUDA toolkit 10.2.89, local installation; CUDA driver 10.2.0; NVIDIA driver 440.64.0. Libraries: ; - CUBLAS: 10.2.2; - CURAND: 10.1.2; - CUFFT: 10.1.2; - CUSOLVER: 10.3.0; - CUSPARSE: 10.3.1; - CUPTI: 12.0.0; - NVML: 10.0.0+440.64.0; - CUDNN: missing; - CUTENSOR: missing. Toolchain:; - Julia: 1.6.2; - LLVM: 11.0.1; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4, 6.5; - Device capability support: sm_30, sm_32, sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75. 2 devices:; 0: Tesla V100-SXM2-32GB (sm_70, 31.432 GiB / 31.749 GiB available); 1: Tesla V100-SXM2-32GB (sm_70, 31.738 GiB / 31.749 GiB available); nothing. [2021/08/11 22:39:51.084] INFO Setting up benchmark: (GPU, Float64, 2048)...; [2021/08/11 22:40:32.330] INFO warming up; [2021/08/11 22:41:32.311] INFO Simulation is stopping. Model iteration 1 has hit or exceeded simulation stop iteration 1.; [2021/08/11 22:41:32.729] WARN Calling CUDA.@profile only informs an external profiler to start.; The user is responsible for ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-898095311
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-898095311:161,Testability,log,login-,161,"@christophernhill @glwagner @ali-ramadhan ; I obtained some interesting results from profiling the shallow water model running on GPU. This was done on Satori's login-002.; The gist of it is that varying gird sizes does not change GPU activities except when the grid size gets very small e.g. 128 x 128. All other grid resolutions profiled had about the same GPU activities result as shown below and so only one set is shown. As far as @francispoulin and I know, the GPU activities seem to be correct, with what should be taking up the most time doing so.; However, for API calls, results differ a lot based on grid resolution. As the grid increases in size, `cuStreamQuery` and eventually `cuCtxGetCurrent` becomes the dominant API call. See below the API call profile result tables for the different grid sizes. It seems that `cuStreamQuery` is what is checking on the status of the cuda streams so larger grids taking more time to run the kernels than launching the kernels may have something to do with it.; ```; Oceananigans v0.61.0; Julia Version 1.6.2; Commit 1b93d53fc4 (2021-07-14 15:36 UTC); Platform Info:; OS: Linux (powerpc64le-unknown-linux-gnu); CPU: unknown; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, pwr9); GPU: Tesla V100-SXM2-32GB. CUDA toolkit 10.2.89, local installation; CUDA driver 10.2.0; NVIDIA driver 440.64.0. Libraries: ; - CUBLAS: 10.2.2; - CURAND: 10.1.2; - CUFFT: 10.1.2; - CUSOLVER: 10.3.0; - CUSPARSE: 10.3.1; - CUPTI: 12.0.0; - NVML: 10.0.0+440.64.0; - CUDNN: missing; - CUTENSOR: missing. Toolchain:; - Julia: 1.6.2; - LLVM: 11.0.1; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4, 6.5; - Device capability support: sm_30, sm_32, sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75. 2 devices:; 0: Tesla V100-SXM2-32GB (sm_70, 31.432 GiB / 31.749 GiB available); 1: Tesla V100-SXM2-32GB (sm_70, 31.738 GiB / 31.749 GiB available); nothing. [2021/08/11 22:39:51.084] INFO Setting up benchmark: (GPU, F",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-898095311
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-898095311:1983,Testability,benchmark,benchmark,1983,"mething to do with it.; ```; Oceananigans v0.61.0; Julia Version 1.6.2; Commit 1b93d53fc4 (2021-07-14 15:36 UTC); Platform Info:; OS: Linux (powerpc64le-unknown-linux-gnu); CPU: unknown; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, pwr9); GPU: Tesla V100-SXM2-32GB. CUDA toolkit 10.2.89, local installation; CUDA driver 10.2.0; NVIDIA driver 440.64.0. Libraries: ; - CUBLAS: 10.2.2; - CURAND: 10.1.2; - CUFFT: 10.1.2; - CUSOLVER: 10.3.0; - CUSPARSE: 10.3.1; - CUPTI: 12.0.0; - NVML: 10.0.0+440.64.0; - CUDNN: missing; - CUTENSOR: missing. Toolchain:; - Julia: 1.6.2; - LLVM: 11.0.1; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4, 6.5; - Device capability support: sm_30, sm_32, sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75. 2 devices:; 0: Tesla V100-SXM2-32GB (sm_70, 31.432 GiB / 31.749 GiB available); 1: Tesla V100-SXM2-32GB (sm_70, 31.738 GiB / 31.749 GiB available); nothing. [2021/08/11 22:39:51.084] INFO Setting up benchmark: (GPU, Float64, 2048)...; [2021/08/11 22:40:32.330] INFO warming up; [2021/08/11 22:41:32.311] INFO Simulation is stopping. Model iteration 1 has hit or exceeded simulation stop iteration 1.; [2021/08/11 22:41:32.729] WARN Calling CUDA.@profile only informs an external profiler to start.; The user is responsible for launching Julia under a CUDA profiler. It is recommended to use Nsight Systems, which supports interactive profiling:; $ nsys launch julia -@-> /home/henryguo/.julia/packages/CUDA/CtvPY/lib/cudadrv/profile.jl:71; [2021/08/11 22:41:32.777] INFO Simulation is stopping. Model iteration 11 has hit or exceeded simulation stop iteration 11.; [2021/08/11 22:41:34.842] INFO done profiling (GPU, Float64, 2048); ==41185== Profiling application: /nobackup/users/henryguo/projects/henry-test/julia-1.6.2/bin/julia --project shallow_water_profiler.jl; ==41185== Profiling result:; Type Time(%) Time Calls Avg Min Max Name; GPU activities: 36.32% 15.483ms 10 1.5483ms 1.5398ms 1.5571ms _Z",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-898095311
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-898095311:2790,Testability,test,test,2790,"m_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75. 2 devices:; 0: Tesla V100-SXM2-32GB (sm_70, 31.432 GiB / 31.749 GiB available); 1: Tesla V100-SXM2-32GB (sm_70, 31.738 GiB / 31.749 GiB available); nothing. [2021/08/11 22:39:51.084] INFO Setting up benchmark: (GPU, Float64, 2048)...; [2021/08/11 22:40:32.330] INFO warming up; [2021/08/11 22:41:32.311] INFO Simulation is stopping. Model iteration 1 has hit or exceeded simulation stop iteration 1.; [2021/08/11 22:41:32.729] WARN Calling CUDA.@profile only informs an external profiler to start.; The user is responsible for launching Julia under a CUDA profiler. It is recommended to use Nsight Systems, which supports interactive profiling:; $ nsys launch julia -@-> /home/henryguo/.julia/packages/CUDA/CtvPY/lib/cudadrv/profile.jl:71; [2021/08/11 22:41:32.777] INFO Simulation is stopping. Model iteration 11 has hit or exceeded simulation stop iteration 11.; [2021/08/11 22:41:34.842] INFO done profiling (GPU, Float64, 2048); ==41185== Profiling application: /nobackup/users/henryguo/projects/henry-test/julia-1.6.2/bin/julia --project shallow_water_profiler.jl; ==41185== Profiling result:; Type Time(%) Time Calls Avg Min Max Name; GPU activities: 36.32% 15.483ms 10 1.5483ms 1.5398ms 1.5571ms _Z24julia_gpu_calculate_Gvh_7ContextI14__CUDACtx_Namevv14__PassType_257v12DisableHooksE19_gpu_calculate_Gvh_16CompilerMetadataI10StaticSizeI15_2048__2048__1_E12DynamicCheckvv7NDRangeILi3ES5_I13_128__128__1_ES5_I11_16__16__1_EvvEE11OffsetArrayI7Float64Li3E13CuDeviceArrayIS9_Li3ELi1EEE22RegularRectilinearGridIS9_8PeriodicS12_4FlatS8_IS9_Li1E12StepRangeLenIS9_14TwicePrecisionIS9_ES15_IS9_EEEES9_5WENO5vvv10NamedTupleI14__uh___vh___h_5TupleIS8_IS9_Li3ES10_IS9_Li3ELi1EEES8_IS9_Li3ES10_IS9_Li3ELi1EEES8_IS9_Li3ES10_IS9_Li3ELi1EEEEES17_I2__S18_EvS17_I14__uh___vh___h_S18_I12_zeroforcingS19_S19_EES17_I27__time___iteration___stage_S18_IS9_5Int64S20_EE; 35.40% 15.088ms 10 1.5088ms 1.5042ms 1.5122ms _Z24julia_gpu_calculate_Guh_7ContextI14__CUDACtx_Namevv",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-898095311
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-898103351:198,Performance,perform,performed,198,"@christophernhill I also took a look at the `GFlops.jl` package. As said on its homepage: ""GFlops.jl does not see what happens outside the realm of Julia code. It especially does not see operations performed in external libraries such as BLAS calls.""; It works similarly to the profile macro and it can count basic math operations performed by whatever follows the macro or benchmark it for its Flops metric. These doesn't seem to work with simulations but works fine for `time_step!(model, 1)` due to the benchmarking process performing many evaluations of the code.; For the nonhydrostatic model running on CPU, `@count_ops` did not produce any results for either the simulation run or the time_step!, and `@gflops` produced the results below for time step!:; ```; 0.02 GFlops, 0.04% peak (1.89e+07 flop, 1.01e+00 s); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-898103351
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-898103351:331,Performance,perform,performed,331,"@christophernhill I also took a look at the `GFlops.jl` package. As said on its homepage: ""GFlops.jl does not see what happens outside the realm of Julia code. It especially does not see operations performed in external libraries such as BLAS calls.""; It works similarly to the profile macro and it can count basic math operations performed by whatever follows the macro or benchmark it for its Flops metric. These doesn't seem to work with simulations but works fine for `time_step!(model, 1)` due to the benchmarking process performing many evaluations of the code.; For the nonhydrostatic model running on CPU, `@count_ops` did not produce any results for either the simulation run or the time_step!, and `@gflops` produced the results below for time step!:; ```; 0.02 GFlops, 0.04% peak (1.89e+07 flop, 1.01e+00 s); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-898103351
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-898103351:527,Performance,perform,performing,527,"@christophernhill I also took a look at the `GFlops.jl` package. As said on its homepage: ""GFlops.jl does not see what happens outside the realm of Julia code. It especially does not see operations performed in external libraries such as BLAS calls.""; It works similarly to the profile macro and it can count basic math operations performed by whatever follows the macro or benchmark it for its Flops metric. These doesn't seem to work with simulations but works fine for `time_step!(model, 1)` due to the benchmarking process performing many evaluations of the code.; For the nonhydrostatic model running on CPU, `@count_ops` did not produce any results for either the simulation run or the time_step!, and `@gflops` produced the results below for time step!:; ```; 0.02 GFlops, 0.04% peak (1.89e+07 flop, 1.01e+00 s); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-898103351
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-898103351:374,Testability,benchmark,benchmark,374,"@christophernhill I also took a look at the `GFlops.jl` package. As said on its homepage: ""GFlops.jl does not see what happens outside the realm of Julia code. It especially does not see operations performed in external libraries such as BLAS calls.""; It works similarly to the profile macro and it can count basic math operations performed by whatever follows the macro or benchmark it for its Flops metric. These doesn't seem to work with simulations but works fine for `time_step!(model, 1)` due to the benchmarking process performing many evaluations of the code.; For the nonhydrostatic model running on CPU, `@count_ops` did not produce any results for either the simulation run or the time_step!, and `@gflops` produced the results below for time step!:; ```; 0.02 GFlops, 0.04% peak (1.89e+07 flop, 1.01e+00 s); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-898103351
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-898103351:506,Testability,benchmark,benchmarking,506,"@christophernhill I also took a look at the `GFlops.jl` package. As said on its homepage: ""GFlops.jl does not see what happens outside the realm of Julia code. It especially does not see operations performed in external libraries such as BLAS calls.""; It works similarly to the profile macro and it can count basic math operations performed by whatever follows the macro or benchmark it for its Flops metric. These doesn't seem to work with simulations but works fine for `time_step!(model, 1)` due to the benchmarking process performing many evaluations of the code.; For the nonhydrostatic model running on CPU, `@count_ops` did not produce any results for either the simulation run or the time_step!, and `@gflops` produced the results below for time step!:; ```; 0.02 GFlops, 0.04% peak (1.89e+07 flop, 1.01e+00 s); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-898103351
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654:1916,Availability,error,error,1916,"o @maleadt on the Julia slack's GPU channel and in regards to the shallow water model profiles:. > Don't focus on time spent in API calls to much. since GPU execution is asynchronous, you'll have to synchronize at some point, and that API call will then 'soak up' time until the stream has finished executing. and here that's literally the synchronize function, which is implemented using cuStreamQuery: https://github.com/JuliaGPU/CUDA.jl/blob/2b3ec03ff9774b65541fc88dd6b0f1f7aea5d9e0/lib/cudadrv/stream.jl#L115-L144. >use a timeline profiler (i.e. NSNight Systems) to profile your app, or nvpp if you really want to use the old profiler toolchain. plain nvprof results are too simple once your application hits some level of complexity. >now, it is possible that our CPU-side implementation of synchronize does too many API calls and could be optimized a little, but in the end the call serves to wait until the GPU has finished so it probably doesn't matter much. if it does, e.g. because you want to perform other useful work on another CPU task concurrently, you could try to profile that in isolation and file an issue. Essentially, Tim explains that `cuStreamQuery` takes up more time as the grid size increases because it's called in the synchronize function. The synchronize function as shown in the link above tends to be called more and soaks up more waiting time the bigger the problem hence why it scales positively to grid size. ; Taking a closer look at the shallow water gpu profiling results above, it seems that `cuStreamQuery` takes up a lot of time in the finer resolution runs because it is called many times and not because each call takes a lot of time. For example, in the 16k case, `cuSteamQuery` is called three order of magnitudes more times than `cuLaunchKernel` while both calls are measured in microseconds. ; I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my profiling.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654:1940,Availability,error,error,1940,"o @maleadt on the Julia slack's GPU channel and in regards to the shallow water model profiles:. > Don't focus on time spent in API calls to much. since GPU execution is asynchronous, you'll have to synchronize at some point, and that API call will then 'soak up' time until the stream has finished executing. and here that's literally the synchronize function, which is implemented using cuStreamQuery: https://github.com/JuliaGPU/CUDA.jl/blob/2b3ec03ff9774b65541fc88dd6b0f1f7aea5d9e0/lib/cudadrv/stream.jl#L115-L144. >use a timeline profiler (i.e. NSNight Systems) to profile your app, or nvpp if you really want to use the old profiler toolchain. plain nvprof results are too simple once your application hits some level of complexity. >now, it is possible that our CPU-side implementation of synchronize does too many API calls and could be optimized a little, but in the end the call serves to wait until the GPU has finished so it probably doesn't matter much. if it does, e.g. because you want to perform other useful work on another CPU task concurrently, you could try to profile that in isolation and file an issue. Essentially, Tim explains that `cuStreamQuery` takes up more time as the grid size increases because it's called in the synchronize function. The synchronize function as shown in the link above tends to be called more and soaks up more waiting time the bigger the problem hence why it scales positively to grid size. ; Taking a closer look at the shallow water gpu profiling results above, it seems that `cuStreamQuery` takes up a lot of time in the finer resolution runs because it is called many times and not because each call takes a lot of time. For example, in the 16k case, `cuSteamQuery` is called three order of magnitudes more times than `cuLaunchKernel` while both calls are measured in microseconds. ; I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my profiling.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654:1967,Availability,error,error,1967,"o @maleadt on the Julia slack's GPU channel and in regards to the shallow water model profiles:. > Don't focus on time spent in API calls to much. since GPU execution is asynchronous, you'll have to synchronize at some point, and that API call will then 'soak up' time until the stream has finished executing. and here that's literally the synchronize function, which is implemented using cuStreamQuery: https://github.com/JuliaGPU/CUDA.jl/blob/2b3ec03ff9774b65541fc88dd6b0f1f7aea5d9e0/lib/cudadrv/stream.jl#L115-L144. >use a timeline profiler (i.e. NSNight Systems) to profile your app, or nvpp if you really want to use the old profiler toolchain. plain nvprof results are too simple once your application hits some level of complexity. >now, it is possible that our CPU-side implementation of synchronize does too many API calls and could be optimized a little, but in the end the call serves to wait until the GPU has finished so it probably doesn't matter much. if it does, e.g. because you want to perform other useful work on another CPU task concurrently, you could try to profile that in isolation and file an issue. Essentially, Tim explains that `cuStreamQuery` takes up more time as the grid size increases because it's called in the synchronize function. The synchronize function as shown in the link above tends to be called more and soaks up more waiting time the bigger the problem hence why it scales positively to grid size. ; Taking a closer look at the shallow water gpu profiling results above, it seems that `cuStreamQuery` takes up a lot of time in the finer resolution runs because it is called many times and not because each call takes a lot of time. For example, in the 16k case, `cuSteamQuery` is called three order of magnitudes more times than `cuLaunchKernel` while both calls are measured in microseconds. ; I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my profiling.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654:1987,Availability,error,error,1987,"o @maleadt on the Julia slack's GPU channel and in regards to the shallow water model profiles:. > Don't focus on time spent in API calls to much. since GPU execution is asynchronous, you'll have to synchronize at some point, and that API call will then 'soak up' time until the stream has finished executing. and here that's literally the synchronize function, which is implemented using cuStreamQuery: https://github.com/JuliaGPU/CUDA.jl/blob/2b3ec03ff9774b65541fc88dd6b0f1f7aea5d9e0/lib/cudadrv/stream.jl#L115-L144. >use a timeline profiler (i.e. NSNight Systems) to profile your app, or nvpp if you really want to use the old profiler toolchain. plain nvprof results are too simple once your application hits some level of complexity. >now, it is possible that our CPU-side implementation of synchronize does too many API calls and could be optimized a little, but in the end the call serves to wait until the GPU has finished so it probably doesn't matter much. if it does, e.g. because you want to perform other useful work on another CPU task concurrently, you could try to profile that in isolation and file an issue. Essentially, Tim explains that `cuStreamQuery` takes up more time as the grid size increases because it's called in the synchronize function. The synchronize function as shown in the link above tends to be called more and soaks up more waiting time the bigger the problem hence why it scales positively to grid size. ; Taking a closer look at the shallow water gpu profiling results above, it seems that `cuStreamQuery` takes up a lot of time in the finer resolution runs because it is called many times and not because each call takes a lot of time. For example, in the 16k case, `cuSteamQuery` is called three order of magnitudes more times than `cuLaunchKernel` while both calls are measured in microseconds. ; I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my profiling.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654:210,Integrability,synchroniz,synchronize,210,"According to @maleadt on the Julia slack's GPU channel and in regards to the shallow water model profiles:. > Don't focus on time spent in API calls to much. since GPU execution is asynchronous, you'll have to synchronize at some point, and that API call will then 'soak up' time until the stream has finished executing. and here that's literally the synchronize function, which is implemented using cuStreamQuery: https://github.com/JuliaGPU/CUDA.jl/blob/2b3ec03ff9774b65541fc88dd6b0f1f7aea5d9e0/lib/cudadrv/stream.jl#L115-L144. >use a timeline profiler (i.e. NSNight Systems) to profile your app, or nvpp if you really want to use the old profiler toolchain. plain nvprof results are too simple once your application hits some level of complexity. >now, it is possible that our CPU-side implementation of synchronize does too many API calls and could be optimized a little, but in the end the call serves to wait until the GPU has finished so it probably doesn't matter much. if it does, e.g. because you want to perform other useful work on another CPU task concurrently, you could try to profile that in isolation and file an issue. Essentially, Tim explains that `cuStreamQuery` takes up more time as the grid size increases because it's called in the synchronize function. The synchronize function as shown in the link above tends to be called more and soaks up more waiting time the bigger the problem hence why it scales positively to grid size. ; Taking a closer look at the shallow water gpu profiling results above, it seems that `cuStreamQuery` takes up a lot of time in the finer resolution runs because it is called many times and not because each call takes a lot of time. For example, in the 16k case, `cuSteamQuery` is called three order of magnitudes more times than `cuLaunchKernel` while both calls are measured in microseconds. ; I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654:351,Integrability,synchroniz,synchronize,351,"According to @maleadt on the Julia slack's GPU channel and in regards to the shallow water model profiles:. > Don't focus on time spent in API calls to much. since GPU execution is asynchronous, you'll have to synchronize at some point, and that API call will then 'soak up' time until the stream has finished executing. and here that's literally the synchronize function, which is implemented using cuStreamQuery: https://github.com/JuliaGPU/CUDA.jl/blob/2b3ec03ff9774b65541fc88dd6b0f1f7aea5d9e0/lib/cudadrv/stream.jl#L115-L144. >use a timeline profiler (i.e. NSNight Systems) to profile your app, or nvpp if you really want to use the old profiler toolchain. plain nvprof results are too simple once your application hits some level of complexity. >now, it is possible that our CPU-side implementation of synchronize does too many API calls and could be optimized a little, but in the end the call serves to wait until the GPU has finished so it probably doesn't matter much. if it does, e.g. because you want to perform other useful work on another CPU task concurrently, you could try to profile that in isolation and file an issue. Essentially, Tim explains that `cuStreamQuery` takes up more time as the grid size increases because it's called in the synchronize function. The synchronize function as shown in the link above tends to be called more and soaks up more waiting time the bigger the problem hence why it scales positively to grid size. ; Taking a closer look at the shallow water gpu profiling results above, it seems that `cuStreamQuery` takes up a lot of time in the finer resolution runs because it is called many times and not because each call takes a lot of time. For example, in the 16k case, `cuSteamQuery` is called three order of magnitudes more times than `cuLaunchKernel` while both calls are measured in microseconds. ; I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654:807,Integrability,synchroniz,synchronize,807,"According to @maleadt on the Julia slack's GPU channel and in regards to the shallow water model profiles:. > Don't focus on time spent in API calls to much. since GPU execution is asynchronous, you'll have to synchronize at some point, and that API call will then 'soak up' time until the stream has finished executing. and here that's literally the synchronize function, which is implemented using cuStreamQuery: https://github.com/JuliaGPU/CUDA.jl/blob/2b3ec03ff9774b65541fc88dd6b0f1f7aea5d9e0/lib/cudadrv/stream.jl#L115-L144. >use a timeline profiler (i.e. NSNight Systems) to profile your app, or nvpp if you really want to use the old profiler toolchain. plain nvprof results are too simple once your application hits some level of complexity. >now, it is possible that our CPU-side implementation of synchronize does too many API calls and could be optimized a little, but in the end the call serves to wait until the GPU has finished so it probably doesn't matter much. if it does, e.g. because you want to perform other useful work on another CPU task concurrently, you could try to profile that in isolation and file an issue. Essentially, Tim explains that `cuStreamQuery` takes up more time as the grid size increases because it's called in the synchronize function. The synchronize function as shown in the link above tends to be called more and soaks up more waiting time the bigger the problem hence why it scales positively to grid size. ; Taking a closer look at the shallow water gpu profiling results above, it seems that `cuStreamQuery` takes up a lot of time in the finer resolution runs because it is called many times and not because each call takes a lot of time. For example, in the 16k case, `cuSteamQuery` is called three order of magnitudes more times than `cuLaunchKernel` while both calls are measured in microseconds. ; I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654:1257,Integrability,synchroniz,synchronize,1257,"o @maleadt on the Julia slack's GPU channel and in regards to the shallow water model profiles:. > Don't focus on time spent in API calls to much. since GPU execution is asynchronous, you'll have to synchronize at some point, and that API call will then 'soak up' time until the stream has finished executing. and here that's literally the synchronize function, which is implemented using cuStreamQuery: https://github.com/JuliaGPU/CUDA.jl/blob/2b3ec03ff9774b65541fc88dd6b0f1f7aea5d9e0/lib/cudadrv/stream.jl#L115-L144. >use a timeline profiler (i.e. NSNight Systems) to profile your app, or nvpp if you really want to use the old profiler toolchain. plain nvprof results are too simple once your application hits some level of complexity. >now, it is possible that our CPU-side implementation of synchronize does too many API calls and could be optimized a little, but in the end the call serves to wait until the GPU has finished so it probably doesn't matter much. if it does, e.g. because you want to perform other useful work on another CPU task concurrently, you could try to profile that in isolation and file an issue. Essentially, Tim explains that `cuStreamQuery` takes up more time as the grid size increases because it's called in the synchronize function. The synchronize function as shown in the link above tends to be called more and soaks up more waiting time the bigger the problem hence why it scales positively to grid size. ; Taking a closer look at the shallow water gpu profiling results above, it seems that `cuStreamQuery` takes up a lot of time in the finer resolution runs because it is called many times and not because each call takes a lot of time. For example, in the 16k case, `cuSteamQuery` is called three order of magnitudes more times than `cuLaunchKernel` while both calls are measured in microseconds. ; I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my profiling.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654:1283,Integrability,synchroniz,synchronize,1283,"o @maleadt on the Julia slack's GPU channel and in regards to the shallow water model profiles:. > Don't focus on time spent in API calls to much. since GPU execution is asynchronous, you'll have to synchronize at some point, and that API call will then 'soak up' time until the stream has finished executing. and here that's literally the synchronize function, which is implemented using cuStreamQuery: https://github.com/JuliaGPU/CUDA.jl/blob/2b3ec03ff9774b65541fc88dd6b0f1f7aea5d9e0/lib/cudadrv/stream.jl#L115-L144. >use a timeline profiler (i.e. NSNight Systems) to profile your app, or nvpp if you really want to use the old profiler toolchain. plain nvprof results are too simple once your application hits some level of complexity. >now, it is possible that our CPU-side implementation of synchronize does too many API calls and could be optimized a little, but in the end the call serves to wait until the GPU has finished so it probably doesn't matter much. if it does, e.g. because you want to perform other useful work on another CPU task concurrently, you could try to profile that in isolation and file an issue. Essentially, Tim explains that `cuStreamQuery` takes up more time as the grid size increases because it's called in the synchronize function. The synchronize function as shown in the link above tends to be called more and soaks up more waiting time the bigger the problem hence why it scales positively to grid size. ; Taking a closer look at the shallow water gpu profiling results above, it seems that `cuStreamQuery` takes up a lot of time in the finer resolution runs because it is called many times and not because each call takes a lot of time. For example, in the 16k case, `cuSteamQuery` is called three order of magnitudes more times than `cuLaunchKernel` while both calls are measured in microseconds. ; I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my profiling.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654:856,Performance,optimiz,optimized,856,"According to @maleadt on the Julia slack's GPU channel and in regards to the shallow water model profiles:. > Don't focus on time spent in API calls to much. since GPU execution is asynchronous, you'll have to synchronize at some point, and that API call will then 'soak up' time until the stream has finished executing. and here that's literally the synchronize function, which is implemented using cuStreamQuery: https://github.com/JuliaGPU/CUDA.jl/blob/2b3ec03ff9774b65541fc88dd6b0f1f7aea5d9e0/lib/cudadrv/stream.jl#L115-L144. >use a timeline profiler (i.e. NSNight Systems) to profile your app, or nvpp if you really want to use the old profiler toolchain. plain nvprof results are too simple once your application hits some level of complexity. >now, it is possible that our CPU-side implementation of synchronize does too many API calls and could be optimized a little, but in the end the call serves to wait until the GPU has finished so it probably doesn't matter much. if it does, e.g. because you want to perform other useful work on another CPU task concurrently, you could try to profile that in isolation and file an issue. Essentially, Tim explains that `cuStreamQuery` takes up more time as the grid size increases because it's called in the synchronize function. The synchronize function as shown in the link above tends to be called more and soaks up more waiting time the bigger the problem hence why it scales positively to grid size. ; Taking a closer look at the shallow water gpu profiling results above, it seems that `cuStreamQuery` takes up a lot of time in the finer resolution runs because it is called many times and not because each call takes a lot of time. For example, in the 16k case, `cuSteamQuery` is called three order of magnitudes more times than `cuLaunchKernel` while both calls are measured in microseconds. ; I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654:1015,Performance,perform,perform,1015,"o @maleadt on the Julia slack's GPU channel and in regards to the shallow water model profiles:. > Don't focus on time spent in API calls to much. since GPU execution is asynchronous, you'll have to synchronize at some point, and that API call will then 'soak up' time until the stream has finished executing. and here that's literally the synchronize function, which is implemented using cuStreamQuery: https://github.com/JuliaGPU/CUDA.jl/blob/2b3ec03ff9774b65541fc88dd6b0f1f7aea5d9e0/lib/cudadrv/stream.jl#L115-L144. >use a timeline profiler (i.e. NSNight Systems) to profile your app, or nvpp if you really want to use the old profiler toolchain. plain nvprof results are too simple once your application hits some level of complexity. >now, it is possible that our CPU-side implementation of synchronize does too many API calls and could be optimized a little, but in the end the call serves to wait until the GPU has finished so it probably doesn't matter much. if it does, e.g. because you want to perform other useful work on another CPU task concurrently, you could try to profile that in isolation and file an issue. Essentially, Tim explains that `cuStreamQuery` takes up more time as the grid size increases because it's called in the synchronize function. The synchronize function as shown in the link above tends to be called more and soaks up more waiting time the bigger the problem hence why it scales positively to grid size. ; Taking a closer look at the shallow water gpu profiling results above, it seems that `cuStreamQuery` takes up a lot of time in the finer resolution runs because it is called many times and not because each call takes a lot of time. For example, in the 16k case, `cuSteamQuery` is called three order of magnitudes more times than `cuLaunchKernel` while both calls are measured in microseconds. ; I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my profiling.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654:1061,Performance,concurren,concurrently,1061,"o @maleadt on the Julia slack's GPU channel and in regards to the shallow water model profiles:. > Don't focus on time spent in API calls to much. since GPU execution is asynchronous, you'll have to synchronize at some point, and that API call will then 'soak up' time until the stream has finished executing. and here that's literally the synchronize function, which is implemented using cuStreamQuery: https://github.com/JuliaGPU/CUDA.jl/blob/2b3ec03ff9774b65541fc88dd6b0f1f7aea5d9e0/lib/cudadrv/stream.jl#L115-L144. >use a timeline profiler (i.e. NSNight Systems) to profile your app, or nvpp if you really want to use the old profiler toolchain. plain nvprof results are too simple once your application hits some level of complexity. >now, it is possible that our CPU-side implementation of synchronize does too many API calls and could be optimized a little, but in the end the call serves to wait until the GPU has finished so it probably doesn't matter much. if it does, e.g. because you want to perform other useful work on another CPU task concurrently, you could try to profile that in isolation and file an issue. Essentially, Tim explains that `cuStreamQuery` takes up more time as the grid size increases because it's called in the synchronize function. The synchronize function as shown in the link above tends to be called more and soaks up more waiting time the bigger the problem hence why it scales positively to grid size. ; Taking a closer look at the shallow water gpu profiling results above, it seems that `cuStreamQuery` takes up a lot of time in the finer resolution runs because it is called many times and not because each call takes a lot of time. For example, in the 16k case, `cuSteamQuery` is called three order of magnitudes more times than `cuLaunchKernel` while both calls are measured in microseconds. ; I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my profiling.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654:690,Usability,simpl,simple,690,"According to @maleadt on the Julia slack's GPU channel and in regards to the shallow water model profiles:. > Don't focus on time spent in API calls to much. since GPU execution is asynchronous, you'll have to synchronize at some point, and that API call will then 'soak up' time until the stream has finished executing. and here that's literally the synchronize function, which is implemented using cuStreamQuery: https://github.com/JuliaGPU/CUDA.jl/blob/2b3ec03ff9774b65541fc88dd6b0f1f7aea5d9e0/lib/cudadrv/stream.jl#L115-L144. >use a timeline profiler (i.e. NSNight Systems) to profile your app, or nvpp if you really want to use the old profiler toolchain. plain nvprof results are too simple once your application hits some level of complexity. >now, it is possible that our CPU-side implementation of synchronize does too many API calls and could be optimized a little, but in the end the call serves to wait until the GPU has finished so it probably doesn't matter much. if it does, e.g. because you want to perform other useful work on another CPU task concurrently, you could try to profile that in isolation and file an issue. Essentially, Tim explains that `cuStreamQuery` takes up more time as the grid size increases because it's called in the synchronize function. The synchronize function as shown in the link above tends to be called more and soaks up more waiting time the bigger the problem hence why it scales positively to grid size. ; Taking a closer look at the shallow water gpu profiling results above, it seems that `cuStreamQuery` takes up a lot of time in the finer resolution runs because it is called many times and not because each call takes a lot of time. For example, in the 16k case, `cuSteamQuery` is called three order of magnitudes more times than `cuLaunchKernel` while both calls are measured in microseconds. ; I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-900059869:67,Availability,error,error,67,"> I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my profiling. I didn't know this was a KA.jl-based GPU workload when commenting on Slack. The dependency/event model of KernelAbstractions.jl also uses stream queries (i.e. `cuStreamQuery`) when selecting a new stream. Maybe that's the source of these calls. It'd be good to figure out where they come from: if it's from CUDA.jl, and thus presumably because of calling the `synchronize` function, (1) why are you synchronizing that much [1], and if it's for good reasons (2) does it hurt performance and should we tweak our `synchronize` implementation to perform fewer stream queries?. [1]: some synchronization happens implicitly, e.g. when copying memory to or from the CPU (https://github.com/JuliaGPU/CUDA.jl/blob/6758fcab7ae0d72659a1ca0d56ad2c86d3b451f1/src/array.jl#L385-L399). One way to avoid some of those synchronizations, is by using pinned memory, but that's up to the application.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-900059869
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-900059869:91,Availability,error,error,91,"> I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my profiling. I didn't know this was a KA.jl-based GPU workload when commenting on Slack. The dependency/event model of KernelAbstractions.jl also uses stream queries (i.e. `cuStreamQuery`) when selecting a new stream. Maybe that's the source of these calls. It'd be good to figure out where they come from: if it's from CUDA.jl, and thus presumably because of calling the `synchronize` function, (1) why are you synchronizing that much [1], and if it's for good reasons (2) does it hurt performance and should we tweak our `synchronize` implementation to perform fewer stream queries?. [1]: some synchronization happens implicitly, e.g. when copying memory to or from the CPU (https://github.com/JuliaGPU/CUDA.jl/blob/6758fcab7ae0d72659a1ca0d56ad2c86d3b451f1/src/array.jl#L385-L399). One way to avoid some of those synchronizations, is by using pinned memory, but that's up to the application.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-900059869
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-900059869:118,Availability,error,error,118,"> I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my profiling. I didn't know this was a KA.jl-based GPU workload when commenting on Slack. The dependency/event model of KernelAbstractions.jl also uses stream queries (i.e. `cuStreamQuery`) when selecting a new stream. Maybe that's the source of these calls. It'd be good to figure out where they come from: if it's from CUDA.jl, and thus presumably because of calling the `synchronize` function, (1) why are you synchronizing that much [1], and if it's for good reasons (2) does it hurt performance and should we tweak our `synchronize` implementation to perform fewer stream queries?. [1]: some synchronization happens implicitly, e.g. when copying memory to or from the CPU (https://github.com/JuliaGPU/CUDA.jl/blob/6758fcab7ae0d72659a1ca0d56ad2c86d3b451f1/src/array.jl#L385-L399). One way to avoid some of those synchronizations, is by using pinned memory, but that's up to the application.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-900059869
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-900059869:138,Availability,error,error,138,"> I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my profiling. I didn't know this was a KA.jl-based GPU workload when commenting on Slack. The dependency/event model of KernelAbstractions.jl also uses stream queries (i.e. `cuStreamQuery`) when selecting a new stream. Maybe that's the source of these calls. It'd be good to figure out where they come from: if it's from CUDA.jl, and thus presumably because of calling the `synchronize` function, (1) why are you synchronizing that much [1], and if it's for good reasons (2) does it hurt performance and should we tweak our `synchronize` implementation to perform fewer stream queries?. [1]: some synchronization happens implicitly, e.g. when copying memory to or from the CPU (https://github.com/JuliaGPU/CUDA.jl/blob/6758fcab7ae0d72659a1ca0d56ad2c86d3b451f1/src/array.jl#L385-L399). One way to avoid some of those synchronizations, is by using pinned memory, but that's up to the application.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-900059869
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-900059869:243,Integrability,depend,dependency,243,"> I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my profiling. I didn't know this was a KA.jl-based GPU workload when commenting on Slack. The dependency/event model of KernelAbstractions.jl also uses stream queries (i.e. `cuStreamQuery`) when selecting a new stream. Maybe that's the source of these calls. It'd be good to figure out where they come from: if it's from CUDA.jl, and thus presumably because of calling the `synchronize` function, (1) why are you synchronizing that much [1], and if it's for good reasons (2) does it hurt performance and should we tweak our `synchronize` implementation to perform fewer stream queries?. [1]: some synchronization happens implicitly, e.g. when copying memory to or from the CPU (https://github.com/JuliaGPU/CUDA.jl/blob/6758fcab7ae0d72659a1ca0d56ad2c86d3b451f1/src/array.jl#L385-L399). One way to avoid some of those synchronizations, is by using pinned memory, but that's up to the application.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-900059869
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-900059869:523,Integrability,synchroniz,synchronize,523,"> I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my profiling. I didn't know this was a KA.jl-based GPU workload when commenting on Slack. The dependency/event model of KernelAbstractions.jl also uses stream queries (i.e. `cuStreamQuery`) when selecting a new stream. Maybe that's the source of these calls. It'd be good to figure out where they come from: if it's from CUDA.jl, and thus presumably because of calling the `synchronize` function, (1) why are you synchronizing that much [1], and if it's for good reasons (2) does it hurt performance and should we tweak our `synchronize` implementation to perform fewer stream queries?. [1]: some synchronization happens implicitly, e.g. when copying memory to or from the CPU (https://github.com/JuliaGPU/CUDA.jl/blob/6758fcab7ae0d72659a1ca0d56ad2c86d3b451f1/src/array.jl#L385-L399). One way to avoid some of those synchronizations, is by using pinned memory, but that's up to the application.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-900059869
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-900059869:562,Integrability,synchroniz,synchronizing,562,"> I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my profiling. I didn't know this was a KA.jl-based GPU workload when commenting on Slack. The dependency/event model of KernelAbstractions.jl also uses stream queries (i.e. `cuStreamQuery`) when selecting a new stream. Maybe that's the source of these calls. It'd be good to figure out where they come from: if it's from CUDA.jl, and thus presumably because of calling the `synchronize` function, (1) why are you synchronizing that much [1], and if it's for good reasons (2) does it hurt performance and should we tweak our `synchronize` implementation to perform fewer stream queries?. [1]: some synchronization happens implicitly, e.g. when copying memory to or from the CPU (https://github.com/JuliaGPU/CUDA.jl/blob/6758fcab7ae0d72659a1ca0d56ad2c86d3b451f1/src/array.jl#L385-L399). One way to avoid some of those synchronizations, is by using pinned memory, but that's up to the application.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-900059869
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-900059869:674,Integrability,synchroniz,synchronize,674,"> I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my profiling. I didn't know this was a KA.jl-based GPU workload when commenting on Slack. The dependency/event model of KernelAbstractions.jl also uses stream queries (i.e. `cuStreamQuery`) when selecting a new stream. Maybe that's the source of these calls. It'd be good to figure out where they come from: if it's from CUDA.jl, and thus presumably because of calling the `synchronize` function, (1) why are you synchronizing that much [1], and if it's for good reasons (2) does it hurt performance and should we tweak our `synchronize` implementation to perform fewer stream queries?. [1]: some synchronization happens implicitly, e.g. when copying memory to or from the CPU (https://github.com/JuliaGPU/CUDA.jl/blob/6758fcab7ae0d72659a1ca0d56ad2c86d3b451f1/src/array.jl#L385-L399). One way to avoid some of those synchronizations, is by using pinned memory, but that's up to the application.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-900059869
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-900059869:746,Integrability,synchroniz,synchronization,746,"> I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my profiling. I didn't know this was a KA.jl-based GPU workload when commenting on Slack. The dependency/event model of KernelAbstractions.jl also uses stream queries (i.e. `cuStreamQuery`) when selecting a new stream. Maybe that's the source of these calls. It'd be good to figure out where they come from: if it's from CUDA.jl, and thus presumably because of calling the `synchronize` function, (1) why are you synchronizing that much [1], and if it's for good reasons (2) does it hurt performance and should we tweak our `synchronize` implementation to perform fewer stream queries?. [1]: some synchronization happens implicitly, e.g. when copying memory to or from the CPU (https://github.com/JuliaGPU/CUDA.jl/blob/6758fcab7ae0d72659a1ca0d56ad2c86d3b451f1/src/array.jl#L385-L399). One way to avoid some of those synchronizations, is by using pinned memory, but that's up to the application.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-900059869
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-900059869:965,Integrability,synchroniz,synchronizations,965,"> I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my profiling. I didn't know this was a KA.jl-based GPU workload when commenting on Slack. The dependency/event model of KernelAbstractions.jl also uses stream queries (i.e. `cuStreamQuery`) when selecting a new stream. Maybe that's the source of these calls. It'd be good to figure out where they come from: if it's from CUDA.jl, and thus presumably because of calling the `synchronize` function, (1) why are you synchronizing that much [1], and if it's for good reasons (2) does it hurt performance and should we tweak our `synchronize` implementation to perform fewer stream queries?. [1]: some synchronization happens implicitly, e.g. when copying memory to or from the CPU (https://github.com/JuliaGPU/CUDA.jl/blob/6758fcab7ae0d72659a1ca0d56ad2c86d3b451f1/src/array.jl#L385-L399). One way to avoid some of those synchronizations, is by using pinned memory, but that's up to the application.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-900059869
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-900059869:637,Performance,perform,performance,637,"> I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my profiling. I didn't know this was a KA.jl-based GPU workload when commenting on Slack. The dependency/event model of KernelAbstractions.jl also uses stream queries (i.e. `cuStreamQuery`) when selecting a new stream. Maybe that's the source of these calls. It'd be good to figure out where they come from: if it's from CUDA.jl, and thus presumably because of calling the `synchronize` function, (1) why are you synchronizing that much [1], and if it's for good reasons (2) does it hurt performance and should we tweak our `synchronize` implementation to perform fewer stream queries?. [1]: some synchronization happens implicitly, e.g. when copying memory to or from the CPU (https://github.com/JuliaGPU/CUDA.jl/blob/6758fcab7ae0d72659a1ca0d56ad2c86d3b451f1/src/array.jl#L385-L399). One way to avoid some of those synchronizations, is by using pinned memory, but that's up to the application.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-900059869
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-900059869:705,Performance,perform,perform,705,"> I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my profiling. I didn't know this was a KA.jl-based GPU workload when commenting on Slack. The dependency/event model of KernelAbstractions.jl also uses stream queries (i.e. `cuStreamQuery`) when selecting a new stream. Maybe that's the source of these calls. It'd be good to figure out where they come from: if it's from CUDA.jl, and thus presumably because of calling the `synchronize` function, (1) why are you synchronizing that much [1], and if it's for good reasons (2) does it hurt performance and should we tweak our `synchronize` implementation to perform fewer stream queries?. [1]: some synchronization happens implicitly, e.g. when copying memory to or from the CPU (https://github.com/JuliaGPU/CUDA.jl/blob/6758fcab7ae0d72659a1ca0d56ad2c86d3b451f1/src/array.jl#L385-L399). One way to avoid some of those synchronizations, is by using pinned memory, but that's up to the application.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-900059869
https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-900059869:945,Safety,avoid,avoid,945,"> I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my profiling. I didn't know this was a KA.jl-based GPU workload when commenting on Slack. The dependency/event model of KernelAbstractions.jl also uses stream queries (i.e. `cuStreamQuery`) when selecting a new stream. Maybe that's the source of these calls. It'd be good to figure out where they come from: if it's from CUDA.jl, and thus presumably because of calling the `synchronize` function, (1) why are you synchronizing that much [1], and if it's for good reasons (2) does it hurt performance and should we tweak our `synchronize` implementation to perform fewer stream queries?. [1]: some synchronization happens implicitly, e.g. when copying memory to or from the CPU (https://github.com/JuliaGPU/CUDA.jl/blob/6758fcab7ae0d72659a1ca0d56ad2c86d3b451f1/src/array.jl#L385-L399). One way to avoid some of those synchronizations, is by using pinned memory, but that's up to the application.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-900059869
https://github.com/CliMA/Oceananigans.jl/pull/1913#issuecomment-890011382:22,Availability,error,errors,22,"I see that one of the errors is `UndefVarError: device_event not defined`, which I suppose means we need to load it?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1913#issuecomment-890011382
https://github.com/CliMA/Oceananigans.jl/pull/1913#issuecomment-890011382:108,Performance,load,load,108,"I see that one of the errors is `UndefVarError: device_event not defined`, which I suppose means we need to load it?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1913#issuecomment-890011382
https://github.com/CliMA/Oceananigans.jl/pull/1913#issuecomment-890028428:24,Availability,error,errors,24,"> I see that one of the errors is `UndefVarError: device_event not defined`, which I suppose means we need to load it?. Indeed, I'll fix that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1913#issuecomment-890028428
https://github.com/CliMA/Oceananigans.jl/pull/1913#issuecomment-890028428:110,Performance,load,load,110,"> I see that one of the errors is `UndefVarError: device_event not defined`, which I suppose means we need to load it?. Indeed, I'll fix that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1913#issuecomment-890028428
https://github.com/CliMA/Oceananigans.jl/pull/1914#issuecomment-983923996:42,Testability,test,tests,42,I think we should close this PR since the tests are failing. We can easily reproduce this script in the future if we need to.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1914#issuecomment-983923996
https://github.com/CliMA/Oceananigans.jl/pull/1915#issuecomment-890429515:2264,Availability,down,download,2264,"s --project -e 'using Pkg; Pkg.instantiate(; verbose=true)';  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using Pkg; Pkg.precompile()';  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using Pkg; Pkg.status()';  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using Pkg; Pkg.test()';  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using MPI; MPI.install_mpiexecjl()';  | --2021-07-31 21:29:43-- https://julialang-s3.julialang.org/bin/linux/x64/1.6/julia-1.6.1-linux-x86_64.tar.gz;  | Resolving julialang-s3.julialang.org (julialang-s3.julialang.org)... 199.232.38.49, 2a04:4e42:46::561;  | Connecting to julialang-s3.julialang.org (julialang-s3.julialang.org)\|199.232.38.49\|:443... connected.;  | HTTP request sent, awaiting response... 304 Not Modified;  | File /storage7/buildkite-agent/julia-1.6.1-linux-x86_64.tar.gz not modified on server. Omitting download.;  | ;  | Downloading artifact: MPICH;  | Downloading artifact: MPICH;  | ERROR: Unable to automatically install 'MPICH' from '/storage7/buildkite-agent/.julia-3575/packages/MPICH_jll/6N1Sn/Artifacts.toml';  | Stacktrace:;  | [1] error(s::String);  | @ Base ./error.jl:33;  | [2] ensure_artifact_installed(name::String, meta::Dict{String, Any}, artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, verbose::Bool, quiet_download::Bool, io::Base.TTY);  | @ Pkg.Artifacts /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:443;  | [3] ensure_all_artifacts_installed(artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, pkg_uuid::Nothing, include_lazy::Bool, verbose::Bool, quiet_download::Bool, io::Base.TTY);  | @ Pkg.Artifacts /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:508;  | [4] download_artifacts(ctx::Pkg.Types.Context, pkg_roots::Vector{String}; platform::Base.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1915#issuecomment-890429515
https://github.com/CliMA/Oceananigans.jl/pull/1915#issuecomment-890429515:2286,Availability,Down,Downloading,2286,"t/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using Pkg; Pkg.precompile()';  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using Pkg; Pkg.status()';  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using Pkg; Pkg.test()';  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using MPI; MPI.install_mpiexecjl()';  | --2021-07-31 21:29:43-- https://julialang-s3.julialang.org/bin/linux/x64/1.6/julia-1.6.1-linux-x86_64.tar.gz;  | Resolving julialang-s3.julialang.org (julialang-s3.julialang.org)... 199.232.38.49, 2a04:4e42:46::561;  | Connecting to julialang-s3.julialang.org (julialang-s3.julialang.org)\|199.232.38.49\|:443... connected.;  | HTTP request sent, awaiting response... 304 Not Modified;  | File /storage7/buildkite-agent/julia-1.6.1-linux-x86_64.tar.gz not modified on server. Omitting download.;  | ;  | Downloading artifact: MPICH;  | Downloading artifact: MPICH;  | ERROR: Unable to automatically install 'MPICH' from '/storage7/buildkite-agent/.julia-3575/packages/MPICH_jll/6N1Sn/Artifacts.toml';  | Stacktrace:;  | [1] error(s::String);  | @ Base ./error.jl:33;  | [2] ensure_artifact_installed(name::String, meta::Dict{String, Any}, artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, verbose::Bool, quiet_download::Bool, io::Base.TTY);  | @ Pkg.Artifacts /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:443;  | [3] ensure_all_artifacts_installed(artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, pkg_uuid::Nothing, include_lazy::Bool, verbose::Bool, quiet_download::Bool, io::Base.TTY);  | @ Pkg.Artifacts /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:508;  | [4] download_artifacts(ctx::Pkg.Types.Context, pkg_roots::Vector{String}; platform::Base.BinaryPlatforms.Platform, verbose::Bool, io::Base.TTY);  | @ Pkg.Operations /buildworker",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1915#issuecomment-890429515
https://github.com/CliMA/Oceananigans.jl/pull/1915#issuecomment-890429515:2319,Availability,Down,Downloading,2319,"t/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using Pkg; Pkg.precompile()';  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using Pkg; Pkg.status()';  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using Pkg; Pkg.test()';  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using MPI; MPI.install_mpiexecjl()';  | --2021-07-31 21:29:43-- https://julialang-s3.julialang.org/bin/linux/x64/1.6/julia-1.6.1-linux-x86_64.tar.gz;  | Resolving julialang-s3.julialang.org (julialang-s3.julialang.org)... 199.232.38.49, 2a04:4e42:46::561;  | Connecting to julialang-s3.julialang.org (julialang-s3.julialang.org)\|199.232.38.49\|:443... connected.;  | HTTP request sent, awaiting response... 304 Not Modified;  | File /storage7/buildkite-agent/julia-1.6.1-linux-x86_64.tar.gz not modified on server. Omitting download.;  | ;  | Downloading artifact: MPICH;  | Downloading artifact: MPICH;  | ERROR: Unable to automatically install 'MPICH' from '/storage7/buildkite-agent/.julia-3575/packages/MPICH_jll/6N1Sn/Artifacts.toml';  | Stacktrace:;  | [1] error(s::String);  | @ Base ./error.jl:33;  | [2] ensure_artifact_installed(name::String, meta::Dict{String, Any}, artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, verbose::Bool, quiet_download::Bool, io::Base.TTY);  | @ Pkg.Artifacts /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:443;  | [3] ensure_all_artifacts_installed(artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, pkg_uuid::Nothing, include_lazy::Bool, verbose::Bool, quiet_download::Bool, io::Base.TTY);  | @ Pkg.Artifacts /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:508;  | [4] download_artifacts(ctx::Pkg.Types.Context, pkg_roots::Vector{String}; platform::Base.BinaryPlatforms.Platform, verbose::Bool, io::Base.TTY);  | @ Pkg.Operations /buildworker",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1915#issuecomment-890429515
https://github.com/CliMA/Oceananigans.jl/pull/1915#issuecomment-890429515:2352,Availability,ERROR,ERROR,2352,"t/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using Pkg; Pkg.precompile()';  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using Pkg; Pkg.status()';  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using Pkg; Pkg.test()';  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using MPI; MPI.install_mpiexecjl()';  | --2021-07-31 21:29:43-- https://julialang-s3.julialang.org/bin/linux/x64/1.6/julia-1.6.1-linux-x86_64.tar.gz;  | Resolving julialang-s3.julialang.org (julialang-s3.julialang.org)... 199.232.38.49, 2a04:4e42:46::561;  | Connecting to julialang-s3.julialang.org (julialang-s3.julialang.org)\|199.232.38.49\|:443... connected.;  | HTTP request sent, awaiting response... 304 Not Modified;  | File /storage7/buildkite-agent/julia-1.6.1-linux-x86_64.tar.gz not modified on server. Omitting download.;  | ;  | Downloading artifact: MPICH;  | Downloading artifact: MPICH;  | ERROR: Unable to automatically install 'MPICH' from '/storage7/buildkite-agent/.julia-3575/packages/MPICH_jll/6N1Sn/Artifacts.toml';  | Stacktrace:;  | [1] error(s::String);  | @ Base ./error.jl:33;  | [2] ensure_artifact_installed(name::String, meta::Dict{String, Any}, artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, verbose::Bool, quiet_download::Bool, io::Base.TTY);  | @ Pkg.Artifacts /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:443;  | [3] ensure_all_artifacts_installed(artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, pkg_uuid::Nothing, include_lazy::Bool, verbose::Bool, quiet_download::Bool, io::Base.TTY);  | @ Pkg.Artifacts /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:508;  | [4] download_artifacts(ctx::Pkg.Types.Context, pkg_roots::Vector{String}; platform::Base.BinaryPlatforms.Platform, verbose::Bool, io::Base.TTY);  | @ Pkg.Operations /buildworker",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1915#issuecomment-890429515
https://github.com/CliMA/Oceananigans.jl/pull/1915#issuecomment-890429515:2510,Availability,error,error,2510,"ject -e 'using Pkg; Pkg.status()';  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using Pkg; Pkg.test()';  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using MPI; MPI.install_mpiexecjl()';  | --2021-07-31 21:29:43-- https://julialang-s3.julialang.org/bin/linux/x64/1.6/julia-1.6.1-linux-x86_64.tar.gz;  | Resolving julialang-s3.julialang.org (julialang-s3.julialang.org)... 199.232.38.49, 2a04:4e42:46::561;  | Connecting to julialang-s3.julialang.org (julialang-s3.julialang.org)\|199.232.38.49\|:443... connected.;  | HTTP request sent, awaiting response... 304 Not Modified;  | File /storage7/buildkite-agent/julia-1.6.1-linux-x86_64.tar.gz not modified on server. Omitting download.;  | ;  | Downloading artifact: MPICH;  | Downloading artifact: MPICH;  | ERROR: Unable to automatically install 'MPICH' from '/storage7/buildkite-agent/.julia-3575/packages/MPICH_jll/6N1Sn/Artifacts.toml';  | Stacktrace:;  | [1] error(s::String);  | @ Base ./error.jl:33;  | [2] ensure_artifact_installed(name::String, meta::Dict{String, Any}, artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, verbose::Bool, quiet_download::Bool, io::Base.TTY);  | @ Pkg.Artifacts /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:443;  | [3] ensure_all_artifacts_installed(artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, pkg_uuid::Nothing, include_lazy::Bool, verbose::Bool, quiet_download::Bool, io::Base.TTY);  | @ Pkg.Artifacts /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:508;  | [4] download_artifacts(ctx::Pkg.Types.Context, pkg_roots::Vector{String}; platform::Base.BinaryPlatforms.Platform, verbose::Bool, io::Base.TTY);  | @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:706;  | [5] download_artifacts(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Typ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1915#issuecomment-890429515
https://github.com/CliMA/Oceananigans.jl/pull/1915#issuecomment-890429515:2541,Availability,error,error,2541,"  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using Pkg; Pkg.test()';  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using MPI; MPI.install_mpiexecjl()';  | --2021-07-31 21:29:43-- https://julialang-s3.julialang.org/bin/linux/x64/1.6/julia-1.6.1-linux-x86_64.tar.gz;  | Resolving julialang-s3.julialang.org (julialang-s3.julialang.org)... 199.232.38.49, 2a04:4e42:46::561;  | Connecting to julialang-s3.julialang.org (julialang-s3.julialang.org)\|199.232.38.49\|:443... connected.;  | HTTP request sent, awaiting response... 304 Not Modified;  | File /storage7/buildkite-agent/julia-1.6.1-linux-x86_64.tar.gz not modified on server. Omitting download.;  | ;  | Downloading artifact: MPICH;  | Downloading artifact: MPICH;  | ERROR: Unable to automatically install 'MPICH' from '/storage7/buildkite-agent/.julia-3575/packages/MPICH_jll/6N1Sn/Artifacts.toml';  | Stacktrace:;  | [1] error(s::String);  | @ Base ./error.jl:33;  | [2] ensure_artifact_installed(name::String, meta::Dict{String, Any}, artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, verbose::Bool, quiet_download::Bool, io::Base.TTY);  | @ Pkg.Artifacts /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:443;  | [3] ensure_all_artifacts_installed(artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, pkg_uuid::Nothing, include_lazy::Bool, verbose::Bool, quiet_download::Bool, io::Base.TTY);  | @ Pkg.Artifacts /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:508;  | [4] download_artifacts(ctx::Pkg.Types.Context, pkg_roots::Vector{String}; platform::Base.BinaryPlatforms.Platform, verbose::Bool, io::Base.TTY);  | @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:706;  | [5] download_artifacts(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; platform::Base.Bin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1915#issuecomment-890429515
https://github.com/CliMA/Oceananigans.jl/pull/1915#issuecomment-890429515:4370,Availability,Error,Error,4370,"PICH_jll/6N1Sn/Artifacts.toml';  | Stacktrace:;  | [1] error(s::String);  | @ Base ./error.jl:33;  | [2] ensure_artifact_installed(name::String, meta::Dict{String, Any}, artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, verbose::Bool, quiet_download::Bool, io::Base.TTY);  | @ Pkg.Artifacts /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:443;  | [3] ensure_all_artifacts_installed(artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, pkg_uuid::Nothing, include_lazy::Bool, verbose::Bool, quiet_download::Bool, io::Base.TTY);  | @ Pkg.Artifacts /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:508;  | [4] download_artifacts(ctx::Pkg.Types.Context, pkg_roots::Vector{String}; platform::Base.BinaryPlatforms.Platform, verbose::Bool, io::Base.TTY);  | @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:706;  | [5] download_artifacts(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; platform::Base.BinaryPlatforms.Platform, julia_version::VersionNumber, verbose::Bool, io::Base.TTY);  | @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:683;  | [6] instantiate(ctx::Pkg.Types.Context; manifest::Nothing, update_registry::Bool, verbose::Bool, platform::Base.BinaryPlatforms.Platform, allow_autoprecomp::Bool, kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}});  | @ Pkg.API /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:1391;  | [7] instantiate(; kwargs::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:verbose,), Tuple{Bool}}});  | @ Pkg.API /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:1300;  | [8] top-level scope;  | @ none:1;  |  Error: The command exited with status 1;  | user command error: exit status 1. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1915#issuecomment-890429515
https://github.com/CliMA/Oceananigans.jl/pull/1915#issuecomment-890429515:4428,Availability,error,error,4428,"PICH_jll/6N1Sn/Artifacts.toml';  | Stacktrace:;  | [1] error(s::String);  | @ Base ./error.jl:33;  | [2] ensure_artifact_installed(name::String, meta::Dict{String, Any}, artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, verbose::Bool, quiet_download::Bool, io::Base.TTY);  | @ Pkg.Artifacts /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:443;  | [3] ensure_all_artifacts_installed(artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, pkg_uuid::Nothing, include_lazy::Bool, verbose::Bool, quiet_download::Bool, io::Base.TTY);  | @ Pkg.Artifacts /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:508;  | [4] download_artifacts(ctx::Pkg.Types.Context, pkg_roots::Vector{String}; platform::Base.BinaryPlatforms.Platform, verbose::Bool, io::Base.TTY);  | @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:706;  | [5] download_artifacts(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; platform::Base.BinaryPlatforms.Platform, julia_version::VersionNumber, verbose::Bool, io::Base.TTY);  | @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:683;  | [6] instantiate(ctx::Pkg.Types.Context; manifest::Nothing, update_registry::Bool, verbose::Bool, platform::Base.BinaryPlatforms.Platform, allow_autoprecomp::Bool, kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}});  | @ Pkg.API /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:1391;  | [7] instantiate(; kwargs::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:verbose,), Tuple{Bool}}});  | @ Pkg.API /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:1300;  | [8] top-level scope;  | @ none:1;  |  Error: The command exited with status 1;  | user command error: exit status 1. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1915#issuecomment-890429515
https://github.com/CliMA/Oceananigans.jl/pull/1915#issuecomment-890429515:2383,Deployability,install,install,2383,"t/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using Pkg; Pkg.precompile()';  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using Pkg; Pkg.status()';  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using Pkg; Pkg.test()';  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using MPI; MPI.install_mpiexecjl()';  | --2021-07-31 21:29:43-- https://julialang-s3.julialang.org/bin/linux/x64/1.6/julia-1.6.1-linux-x86_64.tar.gz;  | Resolving julialang-s3.julialang.org (julialang-s3.julialang.org)... 199.232.38.49, 2a04:4e42:46::561;  | Connecting to julialang-s3.julialang.org (julialang-s3.julialang.org)\|199.232.38.49\|:443... connected.;  | HTTP request sent, awaiting response... 304 Not Modified;  | File /storage7/buildkite-agent/julia-1.6.1-linux-x86_64.tar.gz not modified on server. Omitting download.;  | ;  | Downloading artifact: MPICH;  | Downloading artifact: MPICH;  | ERROR: Unable to automatically install 'MPICH' from '/storage7/buildkite-agent/.julia-3575/packages/MPICH_jll/6N1Sn/Artifacts.toml';  | Stacktrace:;  | [1] error(s::String);  | @ Base ./error.jl:33;  | [2] ensure_artifact_installed(name::String, meta::Dict{String, Any}, artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, verbose::Bool, quiet_download::Bool, io::Base.TTY);  | @ Pkg.Artifacts /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:443;  | [3] ensure_all_artifacts_installed(artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, pkg_uuid::Nothing, include_lazy::Bool, verbose::Bool, quiet_download::Bool, io::Base.TTY);  | @ Pkg.Artifacts /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:508;  | [4] download_artifacts(ctx::Pkg.Types.Context, pkg_roots::Vector{String}; platform::Base.BinaryPlatforms.Platform, verbose::Bool, io::Base.TTY);  | @ Pkg.Operations /buildworker",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1915#issuecomment-890429515
https://github.com/CliMA/Oceananigans.jl/pull/1915#issuecomment-890429515:1641,Testability,test,test,1641,"dius: 3px; min-height: 85px; color: white; font-size: 12px; padding: 0px 0px 15px; width: 1108px;""><div class=""JobLogOutputComponent__Body"" style=""box-sizing: border-box; font-family: SFMono-Regular, Monaco, Menlo, Consolas, &quot;Liberation Mono&quot;, Courier, monospace;"">. $ trap 'kill -- $' INT TERM QUIT; wget -N -P /storage7/buildkite-agent https://julialang-s3.julialang.org/bin/linux/x64/1.6/julia-1.6.1-linux-x86_64.tar.gz.  | tar xf /storage7/buildkite-agent/julia-1.6.1-linux-x86_64.tar.gz -C /storage7/buildkite-agent;  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using Pkg; Pkg.instantiate(; verbose=true)';  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using Pkg; Pkg.precompile()';  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using Pkg; Pkg.status()';  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using Pkg; Pkg.test()';  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using MPI; MPI.install_mpiexecjl()';  | --2021-07-31 21:29:43-- https://julialang-s3.julialang.org/bin/linux/x64/1.6/julia-1.6.1-linux-x86_64.tar.gz;  | Resolving julialang-s3.julialang.org (julialang-s3.julialang.org)... 199.232.38.49, 2a04:4e42:46::561;  | Connecting to julialang-s3.julialang.org (julialang-s3.julialang.org)\|199.232.38.49\|:443... connected.;  | HTTP request sent, awaiting response... 304 Not Modified;  | File /storage7/buildkite-agent/julia-1.6.1-linux-x86_64.tar.gz not modified on server. Omitting download.;  | ;  | Downloading artifact: MPICH;  | Downloading artifact: MPICH;  | ERROR: Unable to automatically install 'MPICH' from '/storage7/buildkite-agent/.julia-3575/packages/MPICH_jll/6N1Sn/Artifacts.toml';  | Stacktrace:;  | [1] error(s::String);  | @ Base ./error.jl:33;  | [2] ensure_artifact_installed(name::String, meta::Dict{String, Any}, artifacts_toml::String; platform::Base",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1915#issuecomment-890429515
https://github.com/CliMA/Oceananigans.jl/pull/1915#issuecomment-890522628:2306,Availability,down,download,2306,"ing Pkg; Pkg.instantiate(; verbose=true)'; >  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using Pkg; Pkg.precompile()'; >  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using Pkg; Pkg.status()'; >  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using Pkg; Pkg.test()'; >  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using MPI; MPI.install_mpiexecjl()'; >  | --2021-07-31 21:29:43-- https://julialang-s3.julialang.org/bin/linux/x64/1.6/julia-1.6.1-linux-x86_64.tar.gz; >  | Resolving julialang-s3.julialang.org (julialang-s3.julialang.org)... 199.232.38.49, 2a04:4e42:46::561; >  | Connecting to julialang-s3.julialang.org (julialang-s3.julialang.org)\|199.232.38.49\|:443... connected.; >  | HTTP request sent, awaiting response... 304 Not Modified; >  | File /storage7/buildkite-agent/julia-1.6.1-linux-x86_64.tar.gz not modified on server. Omitting download.; >  | ; >  | Downloading artifact: MPICH; >  | Downloading artifact: MPICH; >  | ERROR: Unable to automatically install 'MPICH' from '/storage7/buildkite-agent/.julia-3575/packages/MPICH_jll/6N1Sn/Artifacts.toml'; >  | Stacktrace:; >  | [1] error(s::String); >  | @ Base ./error.jl:33; >  | [2] ensure_artifact_installed(name::String, meta::Dict{String, Any}, artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, verbose::Bool, quiet_download::Bool, io::Base.TTY); >  | @ Pkg.Artifacts /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:443; >  | [3] ensure_all_artifacts_installed(artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, pkg_uuid::Nothing, include_lazy::Bool, verbose::Bool, quiet_download::Bool, io::Base.TTY); >  | @ Pkg.Artifacts /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:508; >  | [4] download_artifacts(ctx::Pkg.Types.Context, pkg_roots::Vector{",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1915#issuecomment-890522628
https://github.com/CliMA/Oceananigans.jl/pull/1915#issuecomment-890522628:2332,Availability,Down,Downloading,2332,"lia -O0 --color=yes --project -e 'using Pkg; Pkg.precompile()'; >  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using Pkg; Pkg.status()'; >  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using Pkg; Pkg.test()'; >  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using MPI; MPI.install_mpiexecjl()'; >  | --2021-07-31 21:29:43-- https://julialang-s3.julialang.org/bin/linux/x64/1.6/julia-1.6.1-linux-x86_64.tar.gz; >  | Resolving julialang-s3.julialang.org (julialang-s3.julialang.org)... 199.232.38.49, 2a04:4e42:46::561; >  | Connecting to julialang-s3.julialang.org (julialang-s3.julialang.org)\|199.232.38.49\|:443... connected.; >  | HTTP request sent, awaiting response... 304 Not Modified; >  | File /storage7/buildkite-agent/julia-1.6.1-linux-x86_64.tar.gz not modified on server. Omitting download.; >  | ; >  | Downloading artifact: MPICH; >  | Downloading artifact: MPICH; >  | ERROR: Unable to automatically install 'MPICH' from '/storage7/buildkite-agent/.julia-3575/packages/MPICH_jll/6N1Sn/Artifacts.toml'; >  | Stacktrace:; >  | [1] error(s::String); >  | @ Base ./error.jl:33; >  | [2] ensure_artifact_installed(name::String, meta::Dict{String, Any}, artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, verbose::Bool, quiet_download::Bool, io::Base.TTY); >  | @ Pkg.Artifacts /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:443; >  | [3] ensure_all_artifacts_installed(artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, pkg_uuid::Nothing, include_lazy::Bool, verbose::Bool, quiet_download::Bool, io::Base.TTY); >  | @ Pkg.Artifacts /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:508; >  | [4] download_artifacts(ctx::Pkg.Types.Context, pkg_roots::Vector{String}; platform::Base.BinaryPlatforms.Platform, verbose::Bool, io::Base.TTY); >  | @ Pkg.O",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1915#issuecomment-890522628
https://github.com/CliMA/Oceananigans.jl/pull/1915#issuecomment-890522628:2367,Availability,Down,Downloading,2367,"lia -O0 --color=yes --project -e 'using Pkg; Pkg.precompile()'; >  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using Pkg; Pkg.status()'; >  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using Pkg; Pkg.test()'; >  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using MPI; MPI.install_mpiexecjl()'; >  | --2021-07-31 21:29:43-- https://julialang-s3.julialang.org/bin/linux/x64/1.6/julia-1.6.1-linux-x86_64.tar.gz; >  | Resolving julialang-s3.julialang.org (julialang-s3.julialang.org)... 199.232.38.49, 2a04:4e42:46::561; >  | Connecting to julialang-s3.julialang.org (julialang-s3.julialang.org)\|199.232.38.49\|:443... connected.; >  | HTTP request sent, awaiting response... 304 Not Modified; >  | File /storage7/buildkite-agent/julia-1.6.1-linux-x86_64.tar.gz not modified on server. Omitting download.; >  | ; >  | Downloading artifact: MPICH; >  | Downloading artifact: MPICH; >  | ERROR: Unable to automatically install 'MPICH' from '/storage7/buildkite-agent/.julia-3575/packages/MPICH_jll/6N1Sn/Artifacts.toml'; >  | Stacktrace:; >  | [1] error(s::String); >  | @ Base ./error.jl:33; >  | [2] ensure_artifact_installed(name::String, meta::Dict{String, Any}, artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, verbose::Bool, quiet_download::Bool, io::Base.TTY); >  | @ Pkg.Artifacts /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:443; >  | [3] ensure_all_artifacts_installed(artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, pkg_uuid::Nothing, include_lazy::Bool, verbose::Bool, quiet_download::Bool, io::Base.TTY); >  | @ Pkg.Artifacts /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:508; >  | [4] download_artifacts(ctx::Pkg.Types.Context, pkg_roots::Vector{String}; platform::Base.BinaryPlatforms.Platform, verbose::Bool, io::Base.TTY); >  | @ Pkg.O",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1915#issuecomment-890522628
https://github.com/CliMA/Oceananigans.jl/pull/1915#issuecomment-890522628:2402,Availability,ERROR,ERROR,2402,"lia -O0 --color=yes --project -e 'using Pkg; Pkg.precompile()'; >  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using Pkg; Pkg.status()'; >  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using Pkg; Pkg.test()'; >  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using MPI; MPI.install_mpiexecjl()'; >  | --2021-07-31 21:29:43-- https://julialang-s3.julialang.org/bin/linux/x64/1.6/julia-1.6.1-linux-x86_64.tar.gz; >  | Resolving julialang-s3.julialang.org (julialang-s3.julialang.org)... 199.232.38.49, 2a04:4e42:46::561; >  | Connecting to julialang-s3.julialang.org (julialang-s3.julialang.org)\|199.232.38.49\|:443... connected.; >  | HTTP request sent, awaiting response... 304 Not Modified; >  | File /storage7/buildkite-agent/julia-1.6.1-linux-x86_64.tar.gz not modified on server. Omitting download.; >  | ; >  | Downloading artifact: MPICH; >  | Downloading artifact: MPICH; >  | ERROR: Unable to automatically install 'MPICH' from '/storage7/buildkite-agent/.julia-3575/packages/MPICH_jll/6N1Sn/Artifacts.toml'; >  | Stacktrace:; >  | [1] error(s::String); >  | @ Base ./error.jl:33; >  | [2] ensure_artifact_installed(name::String, meta::Dict{String, Any}, artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, verbose::Bool, quiet_download::Bool, io::Base.TTY); >  | @ Pkg.Artifacts /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:443; >  | [3] ensure_all_artifacts_installed(artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, pkg_uuid::Nothing, include_lazy::Bool, verbose::Bool, quiet_download::Bool, io::Base.TTY); >  | @ Pkg.Artifacts /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:508; >  | [4] download_artifacts(ctx::Pkg.Types.Context, pkg_roots::Vector{String}; platform::Base.BinaryPlatforms.Platform, verbose::Bool, io::Base.TTY); >  | @ Pkg.O",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1915#issuecomment-890522628
https://github.com/CliMA/Oceananigans.jl/pull/1915#issuecomment-890522628:2564,Availability,error,error,2564,"tatus()'; >  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using Pkg; Pkg.test()'; >  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using MPI; MPI.install_mpiexecjl()'; >  | --2021-07-31 21:29:43-- https://julialang-s3.julialang.org/bin/linux/x64/1.6/julia-1.6.1-linux-x86_64.tar.gz; >  | Resolving julialang-s3.julialang.org (julialang-s3.julialang.org)... 199.232.38.49, 2a04:4e42:46::561; >  | Connecting to julialang-s3.julialang.org (julialang-s3.julialang.org)\|199.232.38.49\|:443... connected.; >  | HTTP request sent, awaiting response... 304 Not Modified; >  | File /storage7/buildkite-agent/julia-1.6.1-linux-x86_64.tar.gz not modified on server. Omitting download.; >  | ; >  | Downloading artifact: MPICH; >  | Downloading artifact: MPICH; >  | ERROR: Unable to automatically install 'MPICH' from '/storage7/buildkite-agent/.julia-3575/packages/MPICH_jll/6N1Sn/Artifacts.toml'; >  | Stacktrace:; >  | [1] error(s::String); >  | @ Base ./error.jl:33; >  | [2] ensure_artifact_installed(name::String, meta::Dict{String, Any}, artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, verbose::Bool, quiet_download::Bool, io::Base.TTY); >  | @ Pkg.Artifacts /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:443; >  | [3] ensure_all_artifacts_installed(artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, pkg_uuid::Nothing, include_lazy::Bool, verbose::Bool, quiet_download::Bool, io::Base.TTY); >  | @ Pkg.Artifacts /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:508; >  | [4] download_artifacts(ctx::Pkg.Types.Context, pkg_roots::Vector{String}; platform::Base.BinaryPlatforms.Platform, verbose::Bool, io::Base.TTY); >  | @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:706; >  | [5] download_artifacts(ctx::Pkg.Types.Context, pkg",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1915#issuecomment-890522628
https://github.com/CliMA/Oceananigans.jl/pull/1915#issuecomment-890522628:2597,Availability,error,error,2597,"gent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using Pkg; Pkg.test()'; >  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using MPI; MPI.install_mpiexecjl()'; >  | --2021-07-31 21:29:43-- https://julialang-s3.julialang.org/bin/linux/x64/1.6/julia-1.6.1-linux-x86_64.tar.gz; >  | Resolving julialang-s3.julialang.org (julialang-s3.julialang.org)... 199.232.38.49, 2a04:4e42:46::561; >  | Connecting to julialang-s3.julialang.org (julialang-s3.julialang.org)\|199.232.38.49\|:443... connected.; >  | HTTP request sent, awaiting response... 304 Not Modified; >  | File /storage7/buildkite-agent/julia-1.6.1-linux-x86_64.tar.gz not modified on server. Omitting download.; >  | ; >  | Downloading artifact: MPICH; >  | Downloading artifact: MPICH; >  | ERROR: Unable to automatically install 'MPICH' from '/storage7/buildkite-agent/.julia-3575/packages/MPICH_jll/6N1Sn/Artifacts.toml'; >  | Stacktrace:; >  | [1] error(s::String); >  | @ Base ./error.jl:33; >  | [2] ensure_artifact_installed(name::String, meta::Dict{String, Any}, artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, verbose::Bool, quiet_download::Bool, io::Base.TTY); >  | @ Pkg.Artifacts /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:443; >  | [3] ensure_all_artifacts_installed(artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, pkg_uuid::Nothing, include_lazy::Bool, verbose::Bool, quiet_download::Bool, io::Base.TTY); >  | @ Pkg.Artifacts /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:508; >  | [4] download_artifacts(ctx::Pkg.Types.Context, pkg_roots::Vector{String}; platform::Base.BinaryPlatforms.Platform, verbose::Bool, io::Base.TTY); >  | @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:706; >  | [5] download_artifacts(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; plat",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1915#issuecomment-890522628
https://github.com/CliMA/Oceananigans.jl/pull/1915#issuecomment-890522628:4456,Availability,Error,Error,4456,"; >  | [2] ensure_artifact_installed(name::String, meta::Dict{String, Any}, artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, verbose::Bool, quiet_download::Bool, io::Base.TTY); >  | @ Pkg.Artifacts /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:443; >  | [3] ensure_all_artifacts_installed(artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, pkg_uuid::Nothing, include_lazy::Bool, verbose::Bool, quiet_download::Bool, io::Base.TTY); >  | @ Pkg.Artifacts /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:508; >  | [4] download_artifacts(ctx::Pkg.Types.Context, pkg_roots::Vector{String}; platform::Base.BinaryPlatforms.Platform, verbose::Bool, io::Base.TTY); >  | @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:706; >  | [5] download_artifacts(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; platform::Base.BinaryPlatforms.Platform, julia_version::VersionNumber, verbose::Bool, io::Base.TTY); >  | @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:683; >  | [6] instantiate(ctx::Pkg.Types.Context; manifest::Nothing, update_registry::Bool, verbose::Bool, platform::Base.BinaryPlatforms.Platform, allow_autoprecomp::Bool, kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); >  | @ Pkg.API /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:1391; >  | [7] instantiate(; kwargs::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:verbose,), Tuple{Bool}}}); >  | @ Pkg.API /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:1300; >  | [8] top-level scope; >  | @ none:1; >  |  Error: The command exited with status 1; >  | user command error: exit status 1; > ```. The reason for the failure eludes me. But I will try something.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1915#issuecomment-890522628
https://github.com/CliMA/Oceananigans.jl/pull/1915#issuecomment-890522628:4516,Availability,error,error,4516,"; >  | [2] ensure_artifact_installed(name::String, meta::Dict{String, Any}, artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, verbose::Bool, quiet_download::Bool, io::Base.TTY); >  | @ Pkg.Artifacts /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:443; >  | [3] ensure_all_artifacts_installed(artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, pkg_uuid::Nothing, include_lazy::Bool, verbose::Bool, quiet_download::Bool, io::Base.TTY); >  | @ Pkg.Artifacts /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:508; >  | [4] download_artifacts(ctx::Pkg.Types.Context, pkg_roots::Vector{String}; platform::Base.BinaryPlatforms.Platform, verbose::Bool, io::Base.TTY); >  | @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:706; >  | [5] download_artifacts(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; platform::Base.BinaryPlatforms.Platform, julia_version::VersionNumber, verbose::Bool, io::Base.TTY); >  | @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:683; >  | [6] instantiate(ctx::Pkg.Types.Context; manifest::Nothing, update_registry::Bool, verbose::Bool, platform::Base.BinaryPlatforms.Platform, allow_autoprecomp::Bool, kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); >  | @ Pkg.API /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:1391; >  | [7] instantiate(; kwargs::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:verbose,), Tuple{Bool}}}); >  | @ Pkg.API /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:1300; >  | [8] top-level scope; >  | @ none:1; >  |  Error: The command exited with status 1; >  | user command error: exit status 1; > ```. The reason for the failure eludes me. But I will try something.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1915#issuecomment-890522628
https://github.com/CliMA/Oceananigans.jl/pull/1915#issuecomment-890522628:4564,Availability,failure,failure,4564,"; >  | [2] ensure_artifact_installed(name::String, meta::Dict{String, Any}, artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, verbose::Bool, quiet_download::Bool, io::Base.TTY); >  | @ Pkg.Artifacts /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:443; >  | [3] ensure_all_artifacts_installed(artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, pkg_uuid::Nothing, include_lazy::Bool, verbose::Bool, quiet_download::Bool, io::Base.TTY); >  | @ Pkg.Artifacts /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:508; >  | [4] download_artifacts(ctx::Pkg.Types.Context, pkg_roots::Vector{String}; platform::Base.BinaryPlatforms.Platform, verbose::Bool, io::Base.TTY); >  | @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:706; >  | [5] download_artifacts(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; platform::Base.BinaryPlatforms.Platform, julia_version::VersionNumber, verbose::Bool, io::Base.TTY); >  | @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Operations.jl:683; >  | [6] instantiate(ctx::Pkg.Types.Context; manifest::Nothing, update_registry::Bool, verbose::Bool, platform::Base.BinaryPlatforms.Platform, allow_autoprecomp::Bool, kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); >  | @ Pkg.API /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:1391; >  | [7] instantiate(; kwargs::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:verbose,), Tuple{Bool}}}); >  | @ Pkg.API /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:1300; >  | [8] top-level scope; >  | @ none:1; >  |  Error: The command exited with status 1; >  | user command error: exit status 1; > ```. The reason for the failure eludes me. But I will try something.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1915#issuecomment-890522628
https://github.com/CliMA/Oceananigans.jl/pull/1915#issuecomment-890522628:2433,Deployability,install,install,2433,"lia -O0 --color=yes --project -e 'using Pkg; Pkg.precompile()'; >  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using Pkg; Pkg.status()'; >  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using Pkg; Pkg.test()'; >  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using MPI; MPI.install_mpiexecjl()'; >  | --2021-07-31 21:29:43-- https://julialang-s3.julialang.org/bin/linux/x64/1.6/julia-1.6.1-linux-x86_64.tar.gz; >  | Resolving julialang-s3.julialang.org (julialang-s3.julialang.org)... 199.232.38.49, 2a04:4e42:46::561; >  | Connecting to julialang-s3.julialang.org (julialang-s3.julialang.org)\|199.232.38.49\|:443... connected.; >  | HTTP request sent, awaiting response... 304 Not Modified; >  | File /storage7/buildkite-agent/julia-1.6.1-linux-x86_64.tar.gz not modified on server. Omitting download.; >  | ; >  | Downloading artifact: MPICH; >  | Downloading artifact: MPICH; >  | ERROR: Unable to automatically install 'MPICH' from '/storage7/buildkite-agent/.julia-3575/packages/MPICH_jll/6N1Sn/Artifacts.toml'; >  | Stacktrace:; >  | [1] error(s::String); >  | @ Base ./error.jl:33; >  | [2] ensure_artifact_installed(name::String, meta::Dict{String, Any}, artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, verbose::Bool, quiet_download::Bool, io::Base.TTY); >  | @ Pkg.Artifacts /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:443; >  | [3] ensure_all_artifacts_installed(artifacts_toml::String; platform::Base.BinaryPlatforms.Platform, pkg_uuid::Nothing, include_lazy::Bool, verbose::Bool, quiet_download::Bool, io::Base.TTY); >  | @ Pkg.Artifacts /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Artifacts.jl:508; >  | [4] download_artifacts(ctx::Pkg.Types.Context, pkg_roots::Vector{String}; platform::Base.BinaryPlatforms.Platform, verbose::Bool, io::Base.TTY); >  | @ Pkg.O",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1915#issuecomment-890522628
https://github.com/CliMA/Oceananigans.jl/pull/1915#issuecomment-890522628:1671,Testability,test,test,1671,": 85px; color: white; font-size: 12px; padding: 0px 0px 15px; width: 1108px;""><div class=""JobLogOutputComponent__Body"" style=""box-sizing: border-box; font-family: SFMono-Regular, Monaco, Menlo, Consolas, &quot;Liberation Mono&quot;, Courier, monospace;"">; > ; > $ trap 'kill -- $' INT TERM QUIT; wget -N -P /storage7/buildkite-agent https://julialang-s3.julialang.org/bin/linux/x64/1.6/julia-1.6.1-linux-x86_64.tar.gz; > ; >  | tar xf /storage7/buildkite-agent/julia-1.6.1-linux-x86_64.tar.gz -C /storage7/buildkite-agent; >  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using Pkg; Pkg.instantiate(; verbose=true)'; >  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using Pkg; Pkg.precompile()'; >  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using Pkg; Pkg.status()'; >  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using Pkg; Pkg.test()'; >  | /storage7/buildkite-agent/julia-1.6.1/bin/julia -O0 --color=yes --project -e 'using MPI; MPI.install_mpiexecjl()'; >  | --2021-07-31 21:29:43-- https://julialang-s3.julialang.org/bin/linux/x64/1.6/julia-1.6.1-linux-x86_64.tar.gz; >  | Resolving julialang-s3.julialang.org (julialang-s3.julialang.org)... 199.232.38.49, 2a04:4e42:46::561; >  | Connecting to julialang-s3.julialang.org (julialang-s3.julialang.org)\|199.232.38.49\|:443... connected.; >  | HTTP request sent, awaiting response... 304 Not Modified; >  | File /storage7/buildkite-agent/julia-1.6.1-linux-x86_64.tar.gz not modified on server. Omitting download.; >  | ; >  | Downloading artifact: MPICH; >  | Downloading artifact: MPICH; >  | ERROR: Unable to automatically install 'MPICH' from '/storage7/buildkite-agent/.julia-3575/packages/MPICH_jll/6N1Sn/Artifacts.toml'; >  | Stacktrace:; >  | [1] error(s::String); >  | @ Base ./error.jl:33; >  | [2] ensure_artifact_installed(name::String, meta::Dict{String, Any}, artifacts_t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1915#issuecomment-890522628
https://github.com/CliMA/Oceananigans.jl/pull/1916#issuecomment-923634278:170,Security,validat,validation,170,"> was [4b82c4c](https://github.com/CliMA/Oceananigans.jl/commit/4b82c4cc90a2d6a4b016149db0f75ad2ad2d43af) appropriate? perhaps I messed up?. I think this PR just added a validation tests? I'm not totally sure, but it's not super important either way since we don't really need such a validation test.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1916#issuecomment-923634278
https://github.com/CliMA/Oceananigans.jl/pull/1916#issuecomment-923634278:284,Security,validat,validation,284,"> was [4b82c4c](https://github.com/CliMA/Oceananigans.jl/commit/4b82c4cc90a2d6a4b016149db0f75ad2ad2d43af) appropriate? perhaps I messed up?. I think this PR just added a validation tests? I'm not totally sure, but it's not super important either way since we don't really need such a validation test.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1916#issuecomment-923634278
https://github.com/CliMA/Oceananigans.jl/pull/1916#issuecomment-923634278:181,Testability,test,tests,181,"> was [4b82c4c](https://github.com/CliMA/Oceananigans.jl/commit/4b82c4cc90a2d6a4b016149db0f75ad2ad2d43af) appropriate? perhaps I messed up?. I think this PR just added a validation tests? I'm not totally sure, but it's not super important either way since we don't really need such a validation test.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1916#issuecomment-923634278
https://github.com/CliMA/Oceananigans.jl/pull/1916#issuecomment-923634278:295,Testability,test,test,295,"> was [4b82c4c](https://github.com/CliMA/Oceananigans.jl/commit/4b82c4cc90a2d6a4b016149db0f75ad2ad2d43af) appropriate? perhaps I messed up?. I think this PR just added a validation tests? I'm not totally sure, but it's not super important either way since we don't really need such a validation test.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1916#issuecomment-923634278
https://github.com/CliMA/Oceananigans.jl/pull/1917#issuecomment-890587470:8,Testability,test,tests,8,"All CPU tests don't even run... It's been happening past few days. Same, e.g., in #1915..",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1917#issuecomment-890587470
https://github.com/CliMA/Oceananigans.jl/issues/1918#issuecomment-1480582640:202,Availability,error,error,202,"I'm closing this issue because I'm judging that it's not of current, timely relevance to Oceananigans development. If you would like to make it a higher priority or if you think the issue was closed in error please feel free to re-open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1918#issuecomment-1480582640
https://github.com/CliMA/Oceananigans.jl/issues/1919#issuecomment-891426665:324,Performance,bottleneck,bottleneck,324,Yeah this is pretty worrying... I'm pretty sure this is the cause of https://github.com/CliMA/Oceananigans.jl/issues/1420 which has been open for a while so this slowdown must have been around for a while (and just flew under the radar). [Profiling](https://docs.julialang.org/en/v1/manual/profile/) might help pinpoint the bottleneck.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1919#issuecomment-891426665
https://github.com/CliMA/Oceananigans.jl/issues/1919#issuecomment-891443627:279,Performance,bottleneck,bottleneck,279,"> Yeah this is pretty worrying... I'm pretty sure this is the cause of #1420 which has been open for a while so this slowdown must have been around for a while (and just flew under the radar). [Profiling](https://docs.julialang.org/en/v1/manual/profile/) might help pinpoint the bottleneck. It looks like there are some extra temporary arrays being created for the cases with non-trivial (although still pretty trivial) indexing patterns. Profiling could be good - also just turning off as much as possible and then building up from the FFT alone, simple stencil etc... - if that is possible?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1919#issuecomment-891443627
https://github.com/CliMA/Oceananigans.jl/issues/1919#issuecomment-891443627:548,Usability,simpl,simple,548,"> Yeah this is pretty worrying... I'm pretty sure this is the cause of #1420 which has been open for a while so this slowdown must have been around for a while (and just flew under the radar). [Profiling](https://docs.julialang.org/en/v1/manual/profile/) might help pinpoint the bottleneck. It looks like there are some extra temporary arrays being created for the cases with non-trivial (although still pretty trivial) indexing patterns. Profiling could be good - also just turning off as much as possible and then building up from the FFT alone, simple stencil etc... - if that is possible?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1919#issuecomment-891443627
https://github.com/CliMA/Oceananigans.jl/issues/1919#issuecomment-891521065:281,Performance,bottleneck,bottleneck,281,"> > Yeah this is pretty worrying... I'm pretty sure this is the cause of #1420 which has been open for a while so this slowdown must have been around for a while (and just flew under the radar). [Profiling](https://docs.julialang.org/en/v1/manual/profile/) might help pinpoint the bottleneck.; > ; > It looks like there are some extra temporary arrays being created for the cases with non-trivial (although still pretty trivial) indexing patterns. Profiling could be good - also just turning off as much as possible and then building up from the FFT alone, simple stencil etc... - if that is possible?. I did try with a different advection scheme (and `halo_size=(1, 1, 1)`) and the allocations were mitigated. This and @tomchor's result suggests that halo filling for periodic directions is a likely culprit. Profiling is a good idea. I also had the thought of commenting out much of the time-stepping loop and building up to try to pinpoint which functions trigger allocations as @christophernhill suggests.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1919#issuecomment-891521065
https://github.com/CliMA/Oceananigans.jl/issues/1919#issuecomment-891521065:557,Usability,simpl,simple,557,"> > Yeah this is pretty worrying... I'm pretty sure this is the cause of #1420 which has been open for a while so this slowdown must have been around for a while (and just flew under the radar). [Profiling](https://docs.julialang.org/en/v1/manual/profile/) might help pinpoint the bottleneck.; > ; > It looks like there are some extra temporary arrays being created for the cases with non-trivial (although still pretty trivial) indexing patterns. Profiling could be good - also just turning off as much as possible and then building up from the FFT alone, simple stencil etc... - if that is possible?. I did try with a different advection scheme (and `halo_size=(1, 1, 1)`) and the allocations were mitigated. This and @tomchor's result suggests that halo filling for periodic directions is a likely culprit. Profiling is a good idea. I also had the thought of commenting out much of the time-stepping loop and building up to try to pinpoint which functions trigger allocations as @christophernhill suggests.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1919#issuecomment-891521065
https://github.com/CliMA/Oceananigans.jl/issues/1919#issuecomment-891863904:160,Availability,down,down,160,"Glad someone found this and we are discussing it. Maybe a silly question but what happens when we have purely 1D problems in `x`, `y` and `z`? If we get a slow down in `z` then maybe that is an even more MWE?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1919#issuecomment-891863904
https://github.com/CliMA/Oceananigans.jl/pull/1920#issuecomment-891514571:256,Availability,error,error,256,> > There is something fishy with MPI.jl..; > ; > CPU or GPU (or both!) ?. There are only `CPU distributed tests` and they are failing before they even start:; https://buildkite.com/clima/oceananigans/builds/3587#c5384940-778a-42c1-842b-c57c1209b786. This error beats me. :(,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1920#issuecomment-891514571
https://github.com/CliMA/Oceananigans.jl/pull/1920#issuecomment-891514571:107,Testability,test,tests,107,> > There is something fishy with MPI.jl..; > ; > CPU or GPU (or both!) ?. There are only `CPU distributed tests` and they are failing before they even start:; https://buildkite.com/clima/oceananigans/builds/3587#c5384940-778a-42c1-842b-c57c1209b786. This error beats me. :(,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1920#issuecomment-891514571
https://github.com/CliMA/Oceananigans.jl/pull/1920#issuecomment-891780863:282,Availability,error,error,282,"> > > There is something fishy with MPI.jl..; > > ; > > ; > > CPU or GPU (or both!) ?; > ; > There are only `CPU distributed tests` and they are failing before they even start:; > https://buildkite.com/clima/oceananigans/builds/3587#c5384940-778a-42c1-842b-c57c1209b786; > ; > This error beats me. :(. I think it's a problem (bug?) with `MPI.jl` or something else outside Oceananigans. The error seems to suggest that some package associated with MPICH_jll thinks we are on MacOS. It's surprising because we didn't upgrade packages. However, we are running on a new system (shiny Ubuntu 20.04) and that may be the issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1920#issuecomment-891780863
https://github.com/CliMA/Oceananigans.jl/pull/1920#issuecomment-891780863:390,Availability,error,error,390,"> > > There is something fishy with MPI.jl..; > > ; > > ; > > CPU or GPU (or both!) ?; > ; > There are only `CPU distributed tests` and they are failing before they even start:; > https://buildkite.com/clima/oceananigans/builds/3587#c5384940-778a-42c1-842b-c57c1209b786; > ; > This error beats me. :(. I think it's a problem (bug?) with `MPI.jl` or something else outside Oceananigans. The error seems to suggest that some package associated with MPICH_jll thinks we are on MacOS. It's surprising because we didn't upgrade packages. However, we are running on a new system (shiny Ubuntu 20.04) and that may be the issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1920#issuecomment-891780863
https://github.com/CliMA/Oceananigans.jl/pull/1920#issuecomment-891780863:515,Deployability,upgrade,upgrade,515,"> > > There is something fishy with MPI.jl..; > > ; > > ; > > CPU or GPU (or both!) ?; > ; > There are only `CPU distributed tests` and they are failing before they even start:; > https://buildkite.com/clima/oceananigans/builds/3587#c5384940-778a-42c1-842b-c57c1209b786; > ; > This error beats me. :(. I think it's a problem (bug?) with `MPI.jl` or something else outside Oceananigans. The error seems to suggest that some package associated with MPICH_jll thinks we are on MacOS. It's surprising because we didn't upgrade packages. However, we are running on a new system (shiny Ubuntu 20.04) and that may be the issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1920#issuecomment-891780863
https://github.com/CliMA/Oceananigans.jl/pull/1920#issuecomment-891780863:125,Testability,test,tests,125,"> > > There is something fishy with MPI.jl..; > > ; > > ; > > CPU or GPU (or both!) ?; > ; > There are only `CPU distributed tests` and they are failing before they even start:; > https://buildkite.com/clima/oceananigans/builds/3587#c5384940-778a-42c1-842b-c57c1209b786; > ; > This error beats me. :(. I think it's a problem (bug?) with `MPI.jl` or something else outside Oceananigans. The error seems to suggest that some package associated with MPICH_jll thinks we are on MacOS. It's surprising because we didn't upgrade packages. However, we are running on a new system (shiny Ubuntu 20.04) and that may be the issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1920#issuecomment-891780863
https://github.com/CliMA/Oceananigans.jl/pull/1923#issuecomment-892358642:235,Testability,test,tests,235,Looks like there's still work to do... I also realized that I forget a subtlety regarding the corners and periodic halo filling. I'm going to have to launch the kernels for periodic halo filling a bit differently to get the regression tests to pass.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1923#issuecomment-892358642
https://github.com/CliMA/Oceananigans.jl/issues/1927#issuecomment-894675637:618,Deployability,update,updated,618,"I think ""resolution"" is ordinary usage, in the sense of. https://en.wikipedia.org/wiki/Image_resolution#Pixel_count. I do agree though that the term ""resolution"" has several definitions, which is a reason to consider changing to more precise terminology. The keyword argument to grid constructors is `size`, so that's a good choice. I think the distinction between ""grid size"" and ""halo size"" is ambiguous (isn't the halo part of the grid?) But perhaps we can reinforce these notions with more distinct terminology (eg using just ""size"" and just ""halo"" rather than ""halo size""). All of the grid constructors should be updated with this change.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1927#issuecomment-894675637
https://github.com/CliMA/Oceananigans.jl/pull/1928#issuecomment-894599227:96,Deployability,Continuous,ContinuousBoundaryFunction,96,@navidcy do you remember how we fixed this? I think we just have to generalize the functors for ContinuousBoundaryFunction.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1928#issuecomment-894599227
https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-895617555:241,Availability,checkpoint,checkpointing,241,"I don't use JLD2 files at all so it would be good if someone else chimed in here. That said, JLD2 is a native Julia format and apparently it lets you save much more stuff to the disk much easier than a NetCDF file, which is probably why the checkpointing feature uses JLD2 and not NetCDF. So I don't think we even want a NetCDF-based. . That said, JLD2 is [HDF5-comptible](https://github.com/JuliaIO/JLD2.jl) so if you want to open the checkpoint files for whatever reason you can use any HDF5 library in any software you want. Like you, I don't use JLD2. So when I run a simulation that will take too long I set-up my checkpointer (which is for picking up a simulation only) and a `NetCDFOutputWriter` to open the results somewhere else. Cheers",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-895617555
https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-895617555:436,Availability,checkpoint,checkpoint,436,"I don't use JLD2 files at all so it would be good if someone else chimed in here. That said, JLD2 is a native Julia format and apparently it lets you save much more stuff to the disk much easier than a NetCDF file, which is probably why the checkpointing feature uses JLD2 and not NetCDF. So I don't think we even want a NetCDF-based. . That said, JLD2 is [HDF5-comptible](https://github.com/JuliaIO/JLD2.jl) so if you want to open the checkpoint files for whatever reason you can use any HDF5 library in any software you want. Like you, I don't use JLD2. So when I run a simulation that will take too long I set-up my checkpointer (which is for picking up a simulation only) and a `NetCDFOutputWriter` to open the results somewhere else. Cheers",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-895617555
https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-895617555:619,Availability,checkpoint,checkpointer,619,"I don't use JLD2 files at all so it would be good if someone else chimed in here. That said, JLD2 is a native Julia format and apparently it lets you save much more stuff to the disk much easier than a NetCDF file, which is probably why the checkpointing feature uses JLD2 and not NetCDF. So I don't think we even want a NetCDF-based. . That said, JLD2 is [HDF5-comptible](https://github.com/JuliaIO/JLD2.jl) so if you want to open the checkpoint files for whatever reason you can use any HDF5 library in any software you want. Like you, I don't use JLD2. So when I run a simulation that will take too long I set-up my checkpointer (which is for picking up a simulation only) and a `NetCDFOutputWriter` to open the results somewhere else. Cheers",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-895617555
https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-896044154:219,Availability,checkpoint,checkpointer,219,"No problem! The docs have a few examples help. You can see the NetCDF examples [here](https://clima.github.io/OceananigansDocumentation/v0.60.0/model_setup/output_writers/#Examples). And you can see the options for the checkpointer [here](https://clima.github.io/OceananigansDocumentation/v0.60.0/appendix/library/#Oceananigans.OutputWriters.Checkpointer-Tuple{Any}). A pseudo-code that illustrates how you could do it is:. ```julia; using Oceananigans; # create grid; # create model; # create simulation. outputs = (u=model.velocities.u, v=model.velocities.v) # for example. # Add the netcdf output; simulation.output_writers[:netcdf] = NetCDFOutputWriter(model, outputs,; filepath=""netcdf_output.nc"", schedule=TimeInterval(60)). # Add the checkpointer; simulation.output_writers[:checkpoint] = Checkpointer(model;; schedule = TimeInterval(18hours),; ). run!(simulation, pickup=true) # run with pickup=true and if a checkpointer is found, the simulation will pick up from there; ```. Right now we're facing a couple of [issues with our docs](https://github.com/CliMA/Oceananigans.jl/issues/1909) so the docs for the latest versions aren't being generated. So basically you should disregard the function `restore_from_checkpoint`. It doesn't exist anymore in the most current version of Oceananigans.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-896044154
https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-896044154:342,Availability,Checkpoint,Checkpointer-Tuple,342,"No problem! The docs have a few examples help. You can see the NetCDF examples [here](https://clima.github.io/OceananigansDocumentation/v0.60.0/model_setup/output_writers/#Examples). And you can see the options for the checkpointer [here](https://clima.github.io/OceananigansDocumentation/v0.60.0/appendix/library/#Oceananigans.OutputWriters.Checkpointer-Tuple{Any}). A pseudo-code that illustrates how you could do it is:. ```julia; using Oceananigans; # create grid; # create model; # create simulation. outputs = (u=model.velocities.u, v=model.velocities.v) # for example. # Add the netcdf output; simulation.output_writers[:netcdf] = NetCDFOutputWriter(model, outputs,; filepath=""netcdf_output.nc"", schedule=TimeInterval(60)). # Add the checkpointer; simulation.output_writers[:checkpoint] = Checkpointer(model;; schedule = TimeInterval(18hours),; ). run!(simulation, pickup=true) # run with pickup=true and if a checkpointer is found, the simulation will pick up from there; ```. Right now we're facing a couple of [issues with our docs](https://github.com/CliMA/Oceananigans.jl/issues/1909) so the docs for the latest versions aren't being generated. So basically you should disregard the function `restore_from_checkpoint`. It doesn't exist anymore in the most current version of Oceananigans.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-896044154
https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-896044154:741,Availability,checkpoint,checkpointer,741,"No problem! The docs have a few examples help. You can see the NetCDF examples [here](https://clima.github.io/OceananigansDocumentation/v0.60.0/model_setup/output_writers/#Examples). And you can see the options for the checkpointer [here](https://clima.github.io/OceananigansDocumentation/v0.60.0/appendix/library/#Oceananigans.OutputWriters.Checkpointer-Tuple{Any}). A pseudo-code that illustrates how you could do it is:. ```julia; using Oceananigans; # create grid; # create model; # create simulation. outputs = (u=model.velocities.u, v=model.velocities.v) # for example. # Add the netcdf output; simulation.output_writers[:netcdf] = NetCDFOutputWriter(model, outputs,; filepath=""netcdf_output.nc"", schedule=TimeInterval(60)). # Add the checkpointer; simulation.output_writers[:checkpoint] = Checkpointer(model;; schedule = TimeInterval(18hours),; ). run!(simulation, pickup=true) # run with pickup=true and if a checkpointer is found, the simulation will pick up from there; ```. Right now we're facing a couple of [issues with our docs](https://github.com/CliMA/Oceananigans.jl/issues/1909) so the docs for the latest versions aren't being generated. So basically you should disregard the function `restore_from_checkpoint`. It doesn't exist anymore in the most current version of Oceananigans.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-896044154
https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-896044154:782,Availability,checkpoint,checkpoint,782,"No problem! The docs have a few examples help. You can see the NetCDF examples [here](https://clima.github.io/OceananigansDocumentation/v0.60.0/model_setup/output_writers/#Examples). And you can see the options for the checkpointer [here](https://clima.github.io/OceananigansDocumentation/v0.60.0/appendix/library/#Oceananigans.OutputWriters.Checkpointer-Tuple{Any}). A pseudo-code that illustrates how you could do it is:. ```julia; using Oceananigans; # create grid; # create model; # create simulation. outputs = (u=model.velocities.u, v=model.velocities.v) # for example. # Add the netcdf output; simulation.output_writers[:netcdf] = NetCDFOutputWriter(model, outputs,; filepath=""netcdf_output.nc"", schedule=TimeInterval(60)). # Add the checkpointer; simulation.output_writers[:checkpoint] = Checkpointer(model;; schedule = TimeInterval(18hours),; ). run!(simulation, pickup=true) # run with pickup=true and if a checkpointer is found, the simulation will pick up from there; ```. Right now we're facing a couple of [issues with our docs](https://github.com/CliMA/Oceananigans.jl/issues/1909) so the docs for the latest versions aren't being generated. So basically you should disregard the function `restore_from_checkpoint`. It doesn't exist anymore in the most current version of Oceananigans.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-896044154
https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-896044154:796,Availability,Checkpoint,Checkpointer,796,"No problem! The docs have a few examples help. You can see the NetCDF examples [here](https://clima.github.io/OceananigansDocumentation/v0.60.0/model_setup/output_writers/#Examples). And you can see the options for the checkpointer [here](https://clima.github.io/OceananigansDocumentation/v0.60.0/appendix/library/#Oceananigans.OutputWriters.Checkpointer-Tuple{Any}). A pseudo-code that illustrates how you could do it is:. ```julia; using Oceananigans; # create grid; # create model; # create simulation. outputs = (u=model.velocities.u, v=model.velocities.v) # for example. # Add the netcdf output; simulation.output_writers[:netcdf] = NetCDFOutputWriter(model, outputs,; filepath=""netcdf_output.nc"", schedule=TimeInterval(60)). # Add the checkpointer; simulation.output_writers[:checkpoint] = Checkpointer(model;; schedule = TimeInterval(18hours),; ). run!(simulation, pickup=true) # run with pickup=true and if a checkpointer is found, the simulation will pick up from there; ```. Right now we're facing a couple of [issues with our docs](https://github.com/CliMA/Oceananigans.jl/issues/1909) so the docs for the latest versions aren't being generated. So basically you should disregard the function `restore_from_checkpoint`. It doesn't exist anymore in the most current version of Oceananigans.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-896044154
https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-896044154:917,Availability,checkpoint,checkpointer,917,"No problem! The docs have a few examples help. You can see the NetCDF examples [here](https://clima.github.io/OceananigansDocumentation/v0.60.0/model_setup/output_writers/#Examples). And you can see the options for the checkpointer [here](https://clima.github.io/OceananigansDocumentation/v0.60.0/appendix/library/#Oceananigans.OutputWriters.Checkpointer-Tuple{Any}). A pseudo-code that illustrates how you could do it is:. ```julia; using Oceananigans; # create grid; # create model; # create simulation. outputs = (u=model.velocities.u, v=model.velocities.v) # for example. # Add the netcdf output; simulation.output_writers[:netcdf] = NetCDFOutputWriter(model, outputs,; filepath=""netcdf_output.nc"", schedule=TimeInterval(60)). # Add the checkpointer; simulation.output_writers[:checkpoint] = Checkpointer(model;; schedule = TimeInterval(18hours),; ). run!(simulation, pickup=true) # run with pickup=true and if a checkpointer is found, the simulation will pick up from there; ```. Right now we're facing a couple of [issues with our docs](https://github.com/CliMA/Oceananigans.jl/issues/1909) so the docs for the latest versions aren't being generated. So basically you should disregard the function `restore_from_checkpoint`. It doesn't exist anymore in the most current version of Oceananigans.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-896044154
https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-896044154:703,Energy Efficiency,schedul,schedule,703,"No problem! The docs have a few examples help. You can see the NetCDF examples [here](https://clima.github.io/OceananigansDocumentation/v0.60.0/model_setup/output_writers/#Examples). And you can see the options for the checkpointer [here](https://clima.github.io/OceananigansDocumentation/v0.60.0/appendix/library/#Oceananigans.OutputWriters.Checkpointer-Tuple{Any}). A pseudo-code that illustrates how you could do it is:. ```julia; using Oceananigans; # create grid; # create model; # create simulation. outputs = (u=model.velocities.u, v=model.velocities.v) # for example. # Add the netcdf output; simulation.output_writers[:netcdf] = NetCDFOutputWriter(model, outputs,; filepath=""netcdf_output.nc"", schedule=TimeInterval(60)). # Add the checkpointer; simulation.output_writers[:checkpoint] = Checkpointer(model;; schedule = TimeInterval(18hours),; ). run!(simulation, pickup=true) # run with pickup=true and if a checkpointer is found, the simulation will pick up from there; ```. Right now we're facing a couple of [issues with our docs](https://github.com/CliMA/Oceananigans.jl/issues/1909) so the docs for the latest versions aren't being generated. So basically you should disregard the function `restore_from_checkpoint`. It doesn't exist anymore in the most current version of Oceananigans.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-896044154
https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-896044154:817,Energy Efficiency,schedul,schedule,817,"No problem! The docs have a few examples help. You can see the NetCDF examples [here](https://clima.github.io/OceananigansDocumentation/v0.60.0/model_setup/output_writers/#Examples). And you can see the options for the checkpointer [here](https://clima.github.io/OceananigansDocumentation/v0.60.0/appendix/library/#Oceananigans.OutputWriters.Checkpointer-Tuple{Any}). A pseudo-code that illustrates how you could do it is:. ```julia; using Oceananigans; # create grid; # create model; # create simulation. outputs = (u=model.velocities.u, v=model.velocities.v) # for example. # Add the netcdf output; simulation.output_writers[:netcdf] = NetCDFOutputWriter(model, outputs,; filepath=""netcdf_output.nc"", schedule=TimeInterval(60)). # Add the checkpointer; simulation.output_writers[:checkpoint] = Checkpointer(model;; schedule = TimeInterval(18hours),; ). run!(simulation, pickup=true) # run with pickup=true and if a checkpointer is found, the simulation will pick up from there; ```. Right now we're facing a couple of [issues with our docs](https://github.com/CliMA/Oceananigans.jl/issues/1909) so the docs for the latest versions aren't being generated. So basically you should disregard the function `restore_from_checkpoint`. It doesn't exist anymore in the most current version of Oceananigans.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-896044154
https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-899754924:109,Availability,checkpoint,checkpointing,109,"I think @tomchor is hitting on the right solution: we should separate ""output for analysis"" from ""output for checkpointing"", if possible. Typically we need output for analysis more frequently than output for checkpointing, and we don't require things like the tendency fields for analysis. This motivates creating multiple output writers that are dedicated to their specific tasks. . On the possibility of a NetCDF checkpointer: the first checkpointer design that utilized `restore_from_checkpoint` attempted to serialize as much of a model's data structures as possible. This requirement prevented us from using NetCDF and motivated using JLD2 (there are a few other data formats that can serialize, but JLD2 is fast, simple, and HDF5 compatible, which means it can be loaded from python with `h5py`). However, we now support a simpler paradigm whereby the original run script needs to be modified with `run!(simulation, pickup=true)` in order to ""pick up"" a simulation from a checkpoint. With this simpler design we require only all the prognostic fields and tendencies (for AB2) in the checkpointer file and we could in principle support NetCDF. This has the downside that it would require us to maintain more code. If you do need to inspect, plot, or analyze data in JLD2 files, check out the [JLD2 documentation](https://juliaio.github.io/JLD2.jl/dev/).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-899754924
https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-899754924:208,Availability,checkpoint,checkpointing,208,"I think @tomchor is hitting on the right solution: we should separate ""output for analysis"" from ""output for checkpointing"", if possible. Typically we need output for analysis more frequently than output for checkpointing, and we don't require things like the tendency fields for analysis. This motivates creating multiple output writers that are dedicated to their specific tasks. . On the possibility of a NetCDF checkpointer: the first checkpointer design that utilized `restore_from_checkpoint` attempted to serialize as much of a model's data structures as possible. This requirement prevented us from using NetCDF and motivated using JLD2 (there are a few other data formats that can serialize, but JLD2 is fast, simple, and HDF5 compatible, which means it can be loaded from python with `h5py`). However, we now support a simpler paradigm whereby the original run script needs to be modified with `run!(simulation, pickup=true)` in order to ""pick up"" a simulation from a checkpoint. With this simpler design we require only all the prognostic fields and tendencies (for AB2) in the checkpointer file and we could in principle support NetCDF. This has the downside that it would require us to maintain more code. If you do need to inspect, plot, or analyze data in JLD2 files, check out the [JLD2 documentation](https://juliaio.github.io/JLD2.jl/dev/).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-899754924
https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-899754924:415,Availability,checkpoint,checkpointer,415,"I think @tomchor is hitting on the right solution: we should separate ""output for analysis"" from ""output for checkpointing"", if possible. Typically we need output for analysis more frequently than output for checkpointing, and we don't require things like the tendency fields for analysis. This motivates creating multiple output writers that are dedicated to their specific tasks. . On the possibility of a NetCDF checkpointer: the first checkpointer design that utilized `restore_from_checkpoint` attempted to serialize as much of a model's data structures as possible. This requirement prevented us from using NetCDF and motivated using JLD2 (there are a few other data formats that can serialize, but JLD2 is fast, simple, and HDF5 compatible, which means it can be loaded from python with `h5py`). However, we now support a simpler paradigm whereby the original run script needs to be modified with `run!(simulation, pickup=true)` in order to ""pick up"" a simulation from a checkpoint. With this simpler design we require only all the prognostic fields and tendencies (for AB2) in the checkpointer file and we could in principle support NetCDF. This has the downside that it would require us to maintain more code. If you do need to inspect, plot, or analyze data in JLD2 files, check out the [JLD2 documentation](https://juliaio.github.io/JLD2.jl/dev/).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-899754924
https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-899754924:439,Availability,checkpoint,checkpointer,439,"I think @tomchor is hitting on the right solution: we should separate ""output for analysis"" from ""output for checkpointing"", if possible. Typically we need output for analysis more frequently than output for checkpointing, and we don't require things like the tendency fields for analysis. This motivates creating multiple output writers that are dedicated to their specific tasks. . On the possibility of a NetCDF checkpointer: the first checkpointer design that utilized `restore_from_checkpoint` attempted to serialize as much of a model's data structures as possible. This requirement prevented us from using NetCDF and motivated using JLD2 (there are a few other data formats that can serialize, but JLD2 is fast, simple, and HDF5 compatible, which means it can be loaded from python with `h5py`). However, we now support a simpler paradigm whereby the original run script needs to be modified with `run!(simulation, pickup=true)` in order to ""pick up"" a simulation from a checkpoint. With this simpler design we require only all the prognostic fields and tendencies (for AB2) in the checkpointer file and we could in principle support NetCDF. This has the downside that it would require us to maintain more code. If you do need to inspect, plot, or analyze data in JLD2 files, check out the [JLD2 documentation](https://juliaio.github.io/JLD2.jl/dev/).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-899754924
https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-899754924:978,Availability,checkpoint,checkpoint,978,"I think @tomchor is hitting on the right solution: we should separate ""output for analysis"" from ""output for checkpointing"", if possible. Typically we need output for analysis more frequently than output for checkpointing, and we don't require things like the tendency fields for analysis. This motivates creating multiple output writers that are dedicated to their specific tasks. . On the possibility of a NetCDF checkpointer: the first checkpointer design that utilized `restore_from_checkpoint` attempted to serialize as much of a model's data structures as possible. This requirement prevented us from using NetCDF and motivated using JLD2 (there are a few other data formats that can serialize, but JLD2 is fast, simple, and HDF5 compatible, which means it can be loaded from python with `h5py`). However, we now support a simpler paradigm whereby the original run script needs to be modified with `run!(simulation, pickup=true)` in order to ""pick up"" a simulation from a checkpoint. With this simpler design we require only all the prognostic fields and tendencies (for AB2) in the checkpointer file and we could in principle support NetCDF. This has the downside that it would require us to maintain more code. If you do need to inspect, plot, or analyze data in JLD2 files, check out the [JLD2 documentation](https://juliaio.github.io/JLD2.jl/dev/).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-899754924
https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-899754924:1089,Availability,checkpoint,checkpointer,1089,"I think @tomchor is hitting on the right solution: we should separate ""output for analysis"" from ""output for checkpointing"", if possible. Typically we need output for analysis more frequently than output for checkpointing, and we don't require things like the tendency fields for analysis. This motivates creating multiple output writers that are dedicated to their specific tasks. . On the possibility of a NetCDF checkpointer: the first checkpointer design that utilized `restore_from_checkpoint` attempted to serialize as much of a model's data structures as possible. This requirement prevented us from using NetCDF and motivated using JLD2 (there are a few other data formats that can serialize, but JLD2 is fast, simple, and HDF5 compatible, which means it can be loaded from python with `h5py`). However, we now support a simpler paradigm whereby the original run script needs to be modified with `run!(simulation, pickup=true)` in order to ""pick up"" a simulation from a checkpoint. With this simpler design we require only all the prognostic fields and tendencies (for AB2) in the checkpointer file and we could in principle support NetCDF. This has the downside that it would require us to maintain more code. If you do need to inspect, plot, or analyze data in JLD2 files, check out the [JLD2 documentation](https://juliaio.github.io/JLD2.jl/dev/).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-899754924
https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-899754924:1162,Availability,down,downside,1162,"I think @tomchor is hitting on the right solution: we should separate ""output for analysis"" from ""output for checkpointing"", if possible. Typically we need output for analysis more frequently than output for checkpointing, and we don't require things like the tendency fields for analysis. This motivates creating multiple output writers that are dedicated to their specific tasks. . On the possibility of a NetCDF checkpointer: the first checkpointer design that utilized `restore_from_checkpoint` attempted to serialize as much of a model's data structures as possible. This requirement prevented us from using NetCDF and motivated using JLD2 (there are a few other data formats that can serialize, but JLD2 is fast, simple, and HDF5 compatible, which means it can be loaded from python with `h5py`). However, we now support a simpler paradigm whereby the original run script needs to be modified with `run!(simulation, pickup=true)` in order to ""pick up"" a simulation from a checkpoint. With this simpler design we require only all the prognostic fields and tendencies (for AB2) in the checkpointer file and we could in principle support NetCDF. This has the downside that it would require us to maintain more code. If you do need to inspect, plot, or analyze data in JLD2 files, check out the [JLD2 documentation](https://juliaio.github.io/JLD2.jl/dev/).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-899754924
https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-899754924:770,Performance,load,loaded,770,"I think @tomchor is hitting on the right solution: we should separate ""output for analysis"" from ""output for checkpointing"", if possible. Typically we need output for analysis more frequently than output for checkpointing, and we don't require things like the tendency fields for analysis. This motivates creating multiple output writers that are dedicated to their specific tasks. . On the possibility of a NetCDF checkpointer: the first checkpointer design that utilized `restore_from_checkpoint` attempted to serialize as much of a model's data structures as possible. This requirement prevented us from using NetCDF and motivated using JLD2 (there are a few other data formats that can serialize, but JLD2 is fast, simple, and HDF5 compatible, which means it can be loaded from python with `h5py`). However, we now support a simpler paradigm whereby the original run script needs to be modified with `run!(simulation, pickup=true)` in order to ""pick up"" a simulation from a checkpoint. With this simpler design we require only all the prognostic fields and tendencies (for AB2) in the checkpointer file and we could in principle support NetCDF. This has the downside that it would require us to maintain more code. If you do need to inspect, plot, or analyze data in JLD2 files, check out the [JLD2 documentation](https://juliaio.github.io/JLD2.jl/dev/).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-899754924
https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-899754924:719,Usability,simpl,simple,719,"I think @tomchor is hitting on the right solution: we should separate ""output for analysis"" from ""output for checkpointing"", if possible. Typically we need output for analysis more frequently than output for checkpointing, and we don't require things like the tendency fields for analysis. This motivates creating multiple output writers that are dedicated to their specific tasks. . On the possibility of a NetCDF checkpointer: the first checkpointer design that utilized `restore_from_checkpoint` attempted to serialize as much of a model's data structures as possible. This requirement prevented us from using NetCDF and motivated using JLD2 (there are a few other data formats that can serialize, but JLD2 is fast, simple, and HDF5 compatible, which means it can be loaded from python with `h5py`). However, we now support a simpler paradigm whereby the original run script needs to be modified with `run!(simulation, pickup=true)` in order to ""pick up"" a simulation from a checkpoint. With this simpler design we require only all the prognostic fields and tendencies (for AB2) in the checkpointer file and we could in principle support NetCDF. This has the downside that it would require us to maintain more code. If you do need to inspect, plot, or analyze data in JLD2 files, check out the [JLD2 documentation](https://juliaio.github.io/JLD2.jl/dev/).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-899754924
https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-899754924:829,Usability,simpl,simpler,829,"I think @tomchor is hitting on the right solution: we should separate ""output for analysis"" from ""output for checkpointing"", if possible. Typically we need output for analysis more frequently than output for checkpointing, and we don't require things like the tendency fields for analysis. This motivates creating multiple output writers that are dedicated to their specific tasks. . On the possibility of a NetCDF checkpointer: the first checkpointer design that utilized `restore_from_checkpoint` attempted to serialize as much of a model's data structures as possible. This requirement prevented us from using NetCDF and motivated using JLD2 (there are a few other data formats that can serialize, but JLD2 is fast, simple, and HDF5 compatible, which means it can be loaded from python with `h5py`). However, we now support a simpler paradigm whereby the original run script needs to be modified with `run!(simulation, pickup=true)` in order to ""pick up"" a simulation from a checkpoint. With this simpler design we require only all the prognostic fields and tendencies (for AB2) in the checkpointer file and we could in principle support NetCDF. This has the downside that it would require us to maintain more code. If you do need to inspect, plot, or analyze data in JLD2 files, check out the [JLD2 documentation](https://juliaio.github.io/JLD2.jl/dev/).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-899754924
https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-899754924:1000,Usability,simpl,simpler,1000,"I think @tomchor is hitting on the right solution: we should separate ""output for analysis"" from ""output for checkpointing"", if possible. Typically we need output for analysis more frequently than output for checkpointing, and we don't require things like the tendency fields for analysis. This motivates creating multiple output writers that are dedicated to their specific tasks. . On the possibility of a NetCDF checkpointer: the first checkpointer design that utilized `restore_from_checkpoint` attempted to serialize as much of a model's data structures as possible. This requirement prevented us from using NetCDF and motivated using JLD2 (there are a few other data formats that can serialize, but JLD2 is fast, simple, and HDF5 compatible, which means it can be loaded from python with `h5py`). However, we now support a simpler paradigm whereby the original run script needs to be modified with `run!(simulation, pickup=true)` in order to ""pick up"" a simulation from a checkpoint. With this simpler design we require only all the prognostic fields and tendencies (for AB2) in the checkpointer file and we could in principle support NetCDF. This has the downside that it would require us to maintain more code. If you do need to inspect, plot, or analyze data in JLD2 files, check out the [JLD2 documentation](https://juliaio.github.io/JLD2.jl/dev/).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1929#issuecomment-899754924
https://github.com/CliMA/Oceananigans.jl/pull/1930#issuecomment-900770693:223,Testability,benchmark,benchmarks,223,"In the latest commit I added in the shallow water strong and weak and GPU scaling results. I also added in the nonhydrostatic CPU vs GPU results.; I feel like that certain graphs, such as the time graphs for the CPU vs GPU benchmarks may be unnecessary and can be removed, if anyone feels the same way then I'll go ahead and do it.; Other benchmarks yet to be added include the nonhydrostatic strong scaling results and the multithreading results. I am not sure if we think that the multithreading results are good enough to show yet. I personally think that there's room for improvement but current efficiencies are good enough to show already. Shown below are the current multithreading scaling efficiencies:; ```; Shallow water model weak multithreading scaling speedup; ;  size  threads  slowdown  efficiency  memory  allocs ; ;  (8192, 512)  1  1.0  1.0  1.0  1.0 ;  (8192, 1024)  2  2.04972  0.487872  13.2156  464.601 ;  (8192, 2048)  4  1.63302  0.612363  9.95278  327.951 ;  (8192, 4096)  8  1.62507  0.615359  11.9706  384.754 ;  (8192, 8192)  16  1.74747  0.572257  12.755  372.71 ;  (8192, 16384)  32  2.10486  0.47509  16.846  446.101 ; . Nonhydrostatic Strong Scaling Multithreading speedup; ;  size  threads  slowdown  efficiency  memory  allocs ; ;  256  1  1.0  1.0  1.0  1.0 ;  256  2  0.992966  0.503542  4.14014  152.109 ;  256  4  0.501089  0.498913  2.17724  50.2532 ;  256  8  0.324366  0.385367  1.94899  29.191 ;  256  16  0.244788  0.255323  2.12262  18.2106 ;  256  32  0.263339  0.118668  2.87624  16.3167 ; ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1930#issuecomment-900770693
https://github.com/CliMA/Oceananigans.jl/pull/1930#issuecomment-900770693:339,Testability,benchmark,benchmarks,339,"In the latest commit I added in the shallow water strong and weak and GPU scaling results. I also added in the nonhydrostatic CPU vs GPU results.; I feel like that certain graphs, such as the time graphs for the CPU vs GPU benchmarks may be unnecessary and can be removed, if anyone feels the same way then I'll go ahead and do it.; Other benchmarks yet to be added include the nonhydrostatic strong scaling results and the multithreading results. I am not sure if we think that the multithreading results are good enough to show yet. I personally think that there's room for improvement but current efficiencies are good enough to show already. Shown below are the current multithreading scaling efficiencies:; ```; Shallow water model weak multithreading scaling speedup; ;  size  threads  slowdown  efficiency  memory  allocs ; ;  (8192, 512)  1  1.0  1.0  1.0  1.0 ;  (8192, 1024)  2  2.04972  0.487872  13.2156  464.601 ;  (8192, 2048)  4  1.63302  0.612363  9.95278  327.951 ;  (8192, 4096)  8  1.62507  0.615359  11.9706  384.754 ;  (8192, 8192)  16  1.74747  0.572257  12.755  372.71 ;  (8192, 16384)  32  2.10486  0.47509  16.846  446.101 ; . Nonhydrostatic Strong Scaling Multithreading speedup; ;  size  threads  slowdown  efficiency  memory  allocs ; ;  256  1  1.0  1.0  1.0  1.0 ;  256  2  0.992966  0.503542  4.14014  152.109 ;  256  4  0.501089  0.498913  2.17724  50.2532 ;  256  8  0.324366  0.385367  1.94899  29.191 ;  256  16  0.244788  0.255323  2.12262  18.2106 ;  256  32  0.263339  0.118668  2.87624  16.3167 ; ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1930#issuecomment-900770693
https://github.com/CliMA/Oceananigans.jl/pull/1932#issuecomment-896350743:12,Testability,test,test,12,How about a test? If it's not trivial then don't worry.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1932#issuecomment-896350743
https://github.com/CliMA/Oceananigans.jl/pull/1932#issuecomment-896762413:443,Availability,error,error,443,"> How about a test? If it's not trivial then don't worry. I like the idea of a test. . One example could be the following:. 1. define the horizontal compoments of velocity to be random fields, ; 2. use this function is used to compute the vertical velocity,; 3. compute the divergnece of the resulting three-dimensional field and compute its norm (which should be zero). . If you do this for two different resolutions you should find that the error decreases with higher resolution. Do you think this would be of interest?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1932#issuecomment-896762413
https://github.com/CliMA/Oceananigans.jl/pull/1932#issuecomment-896762413:14,Testability,test,test,14,"> How about a test? If it's not trivial then don't worry. I like the idea of a test. . One example could be the following:. 1. define the horizontal compoments of velocity to be random fields, ; 2. use this function is used to compute the vertical velocity,; 3. compute the divergnece of the resulting three-dimensional field and compute its norm (which should be zero). . If you do this for two different resolutions you should find that the error decreases with higher resolution. Do you think this would be of interest?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1932#issuecomment-896762413
https://github.com/CliMA/Oceananigans.jl/pull/1932#issuecomment-896762413:79,Testability,test,test,79,"> How about a test? If it's not trivial then don't worry. I like the idea of a test. . One example could be the following:. 1. define the horizontal compoments of velocity to be random fields, ; 2. use this function is used to compute the vertical velocity,; 3. compute the divergnece of the resulting three-dimensional field and compute its norm (which should be zero). . If you do this for two different resolutions you should find that the error decreases with higher resolution. Do you think this would be of interest?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1932#issuecomment-896762413
https://github.com/CliMA/Oceananigans.jl/pull/1932#issuecomment-896867127:86,Testability,test,testing,86,"Bumped the version. I think it might take me a little while to get my head around the testing system, but I've left this editable by maintainers in case anyone else wants to quickly code up a test.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1932#issuecomment-896867127
https://github.com/CliMA/Oceananigans.jl/pull/1932#issuecomment-896867127:192,Testability,test,test,192,"Bumped the version. I think it might take me a little while to get my head around the testing system, but I've left this editable by maintainers in case anyone else wants to quickly code up a test.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1932#issuecomment-896867127
https://github.com/CliMA/Oceananigans.jl/pull/1932#issuecomment-896868081:471,Availability,error,error,471,"> > How about a test? If it's not trivial then don't worry.; > ; > I like the idea of a test.; > ; > One example could be the following:; > ; > 1. define the horizontal compoments of velocity to be random fields,; > 2. use this function is used to compute the vertical velocity,; > 3. compute the divergnece of the resulting three-dimensional field and compute its norm (which should be zero).; > ; > If you do this for two different resolutions you should find that the error decreases with higher resolution.; > ; > Do you think this would be of interest?. @francispoulin a test like that would be good. Sometimes things that are fixed have subsequently been re-broken - because they don't have unit test.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1932#issuecomment-896868081
https://github.com/CliMA/Oceananigans.jl/pull/1932#issuecomment-896868081:16,Testability,test,test,16,"> > How about a test? If it's not trivial then don't worry.; > ; > I like the idea of a test.; > ; > One example could be the following:; > ; > 1. define the horizontal compoments of velocity to be random fields,; > 2. use this function is used to compute the vertical velocity,; > 3. compute the divergnece of the resulting three-dimensional field and compute its norm (which should be zero).; > ; > If you do this for two different resolutions you should find that the error decreases with higher resolution.; > ; > Do you think this would be of interest?. @francispoulin a test like that would be good. Sometimes things that are fixed have subsequently been re-broken - because they don't have unit test.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1932#issuecomment-896868081
https://github.com/CliMA/Oceananigans.jl/pull/1932#issuecomment-896868081:88,Testability,test,test,88,"> > How about a test? If it's not trivial then don't worry.; > ; > I like the idea of a test.; > ; > One example could be the following:; > ; > 1. define the horizontal compoments of velocity to be random fields,; > 2. use this function is used to compute the vertical velocity,; > 3. compute the divergnece of the resulting three-dimensional field and compute its norm (which should be zero).; > ; > If you do this for two different resolutions you should find that the error decreases with higher resolution.; > ; > Do you think this would be of interest?. @francispoulin a test like that would be good. Sometimes things that are fixed have subsequently been re-broken - because they don't have unit test.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1932#issuecomment-896868081
https://github.com/CliMA/Oceananigans.jl/pull/1932#issuecomment-896868081:576,Testability,test,test,576,"> > How about a test? If it's not trivial then don't worry.; > ; > I like the idea of a test.; > ; > One example could be the following:; > ; > 1. define the horizontal compoments of velocity to be random fields,; > 2. use this function is used to compute the vertical velocity,; > 3. compute the divergnece of the resulting three-dimensional field and compute its norm (which should be zero).; > ; > If you do this for two different resolutions you should find that the error decreases with higher resolution.; > ; > Do you think this would be of interest?. @francispoulin a test like that would be good. Sometimes things that are fixed have subsequently been re-broken - because they don't have unit test.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1932#issuecomment-896868081
https://github.com/CliMA/Oceananigans.jl/pull/1932#issuecomment-896868081:702,Testability,test,test,702,"> > How about a test? If it's not trivial then don't worry.; > ; > I like the idea of a test.; > ; > One example could be the following:; > ; > 1. define the horizontal compoments of velocity to be random fields,; > 2. use this function is used to compute the vertical velocity,; > 3. compute the divergnece of the resulting three-dimensional field and compute its norm (which should be zero).; > ; > If you do this for two different resolutions you should find that the error decreases with higher resolution.; > ; > Do you think this would be of interest?. @francispoulin a test like that would be good. Sometimes things that are fixed have subsequently been re-broken - because they don't have unit test.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1932#issuecomment-896868081
https://github.com/CliMA/Oceananigans.jl/pull/1932#issuecomment-897173043:59,Testability,test,test,59,Another attitude is to merge this and start a new PR for a test...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1932#issuecomment-897173043
https://github.com/CliMA/Oceananigans.jl/pull/1932#issuecomment-897176439:41,Testability,test,test,41,"I am in favor of creating a new PR for a test, since it ideally would encompass an incompressibility test for both the hydrostatic and nonhydrostatic models",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1932#issuecomment-897176439
https://github.com/CliMA/Oceananigans.jl/pull/1932#issuecomment-897176439:101,Testability,test,test,101,"I am in favor of creating a new PR for a test, since it ideally would encompass an incompressibility test for both the hydrostatic and nonhydrostatic models",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1932#issuecomment-897176439
https://github.com/CliMA/Oceananigans.jl/issues/1934#issuecomment-899757319:3,Testability,test,test,3,We test that `NonhydrostaticModel` maintains incompressibility on both fully regular and vertically-stretched grids:. https://github.com/CliMA/Oceananigans.jl/blob/e929631eb3a233ae3f3358d2146e5d6004f9a06c/test/test_time_stepping.jl#L311-L341. We don't have tests for the hydrostatic model however. A similar but possibly slightly simpler test might test that `compute_w_from_continuity!` correctly calculates a vertical velocity field given some horizontally divergent horizontal velocity field.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1934#issuecomment-899757319
https://github.com/CliMA/Oceananigans.jl/issues/1934#issuecomment-899757319:205,Testability,test,test,205,We test that `NonhydrostaticModel` maintains incompressibility on both fully regular and vertically-stretched grids:. https://github.com/CliMA/Oceananigans.jl/blob/e929631eb3a233ae3f3358d2146e5d6004f9a06c/test/test_time_stepping.jl#L311-L341. We don't have tests for the hydrostatic model however. A similar but possibly slightly simpler test might test that `compute_w_from_continuity!` correctly calculates a vertical velocity field given some horizontally divergent horizontal velocity field.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1934#issuecomment-899757319
https://github.com/CliMA/Oceananigans.jl/issues/1934#issuecomment-899757319:257,Testability,test,tests,257,We test that `NonhydrostaticModel` maintains incompressibility on both fully regular and vertically-stretched grids:. https://github.com/CliMA/Oceananigans.jl/blob/e929631eb3a233ae3f3358d2146e5d6004f9a06c/test/test_time_stepping.jl#L311-L341. We don't have tests for the hydrostatic model however. A similar but possibly slightly simpler test might test that `compute_w_from_continuity!` correctly calculates a vertical velocity field given some horizontally divergent horizontal velocity field.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1934#issuecomment-899757319
https://github.com/CliMA/Oceananigans.jl/issues/1934#issuecomment-899757319:338,Testability,test,test,338,We test that `NonhydrostaticModel` maintains incompressibility on both fully regular and vertically-stretched grids:. https://github.com/CliMA/Oceananigans.jl/blob/e929631eb3a233ae3f3358d2146e5d6004f9a06c/test/test_time_stepping.jl#L311-L341. We don't have tests for the hydrostatic model however. A similar but possibly slightly simpler test might test that `compute_w_from_continuity!` correctly calculates a vertical velocity field given some horizontally divergent horizontal velocity field.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1934#issuecomment-899757319
https://github.com/CliMA/Oceananigans.jl/issues/1934#issuecomment-899757319:349,Testability,test,test,349,We test that `NonhydrostaticModel` maintains incompressibility on both fully regular and vertically-stretched grids:. https://github.com/CliMA/Oceananigans.jl/blob/e929631eb3a233ae3f3358d2146e5d6004f9a06c/test/test_time_stepping.jl#L311-L341. We don't have tests for the hydrostatic model however. A similar but possibly slightly simpler test might test that `compute_w_from_continuity!` correctly calculates a vertical velocity field given some horizontally divergent horizontal velocity field.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1934#issuecomment-899757319
https://github.com/CliMA/Oceananigans.jl/issues/1934#issuecomment-899757319:330,Usability,simpl,simpler,330,We test that `NonhydrostaticModel` maintains incompressibility on both fully regular and vertically-stretched grids:. https://github.com/CliMA/Oceananigans.jl/blob/e929631eb3a233ae3f3358d2146e5d6004f9a06c/test/test_time_stepping.jl#L311-L341. We don't have tests for the hydrostatic model however. A similar but possibly slightly simpler test might test that `compute_w_from_continuity!` correctly calculates a vertical velocity field given some horizontally divergent horizontal velocity field.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1934#issuecomment-899757319
https://github.com/CliMA/Oceananigans.jl/issues/1934#issuecomment-1479899194:15,Testability,test,tests,15,"So, we do have tests for incompressibilty",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1934#issuecomment-1479899194
https://github.com/CliMA/Oceananigans.jl/pull/1935#issuecomment-900444098:299,Availability,error,error,299,"> There is also already a 1D validation test for the immersed boundary --- I wonder if it also shows this bug:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/master/validation/immersed_boundaries/immersed_hydrostatic_diffusion.jl. @glwagner I'm not sure. I tried running it, but got an method error on the `HydrostaticFreeSurfaceModel`: _FreeSurface( ...) is ambiguous_",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1935#issuecomment-900444098
https://github.com/CliMA/Oceananigans.jl/pull/1935#issuecomment-900444098:29,Security,validat,validation,29,"> There is also already a 1D validation test for the immersed boundary --- I wonder if it also shows this bug:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/master/validation/immersed_boundaries/immersed_hydrostatic_diffusion.jl. @glwagner I'm not sure. I tried running it, but got an method error on the `HydrostaticFreeSurfaceModel`: _FreeSurface( ...) is ambiguous_",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1935#issuecomment-900444098
https://github.com/CliMA/Oceananigans.jl/pull/1935#issuecomment-900444098:171,Security,validat,validation,171,"> There is also already a 1D validation test for the immersed boundary --- I wonder if it also shows this bug:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/master/validation/immersed_boundaries/immersed_hydrostatic_diffusion.jl. @glwagner I'm not sure. I tried running it, but got an method error on the `HydrostaticFreeSurfaceModel`: _FreeSurface( ...) is ambiguous_",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1935#issuecomment-900444098
https://github.com/CliMA/Oceananigans.jl/pull/1935#issuecomment-900444098:40,Testability,test,test,40,"> There is also already a 1D validation test for the immersed boundary --- I wonder if it also shows this bug:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/master/validation/immersed_boundaries/immersed_hydrostatic_diffusion.jl. @glwagner I'm not sure. I tried running it, but got an method error on the `HydrostaticFreeSurfaceModel`: _FreeSurface( ...) is ambiguous_",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1935#issuecomment-900444098
https://github.com/CliMA/Oceananigans.jl/pull/1935#issuecomment-900464441:24,Deployability,patch,patch,24,We should also bump the patch version number by editing `Project.toml` so this gets captured by a tagged release I think. I can do that if you like!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1935#issuecomment-900464441
https://github.com/CliMA/Oceananigans.jl/pull/1935#issuecomment-900464441:105,Deployability,release,release,105,We should also bump the patch version number by editing `Project.toml` so this gets captured by a tagged release I think. I can do that if you like!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1935#issuecomment-900464441
https://github.com/CliMA/Oceananigans.jl/pull/1935#issuecomment-900465685:305,Availability,error,error,305,"> > There is also already a 1D validation test for the immersed boundary --- I wonder if it also shows this bug:; > > https://github.com/CliMA/Oceananigans.jl/blob/master/validation/immersed_boundaries/immersed_hydrostatic_diffusion.jl; > ; > @glwagner I'm not sure. I tried running it, but got an method error on the `HydrostaticFreeSurfaceModel`: _FreeSurface( ...) is ambiguous_. Looks like that validation experiment is missing . ```julia; pushfirst!(LOAD_PATH, joinpath(@__DIR__, "".."", "".."")); ```. ~~so it may have been using an old version of Oceananigans in your global environment!~~ EDIT: even if this were the case, I still get the error after adding an appropriate `pushfirst!`. I'll try to fix this separate from this PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1935#issuecomment-900465685
https://github.com/CliMA/Oceananigans.jl/pull/1935#issuecomment-900465685:643,Availability,error,error,643,"> > There is also already a 1D validation test for the immersed boundary --- I wonder if it also shows this bug:; > > https://github.com/CliMA/Oceananigans.jl/blob/master/validation/immersed_boundaries/immersed_hydrostatic_diffusion.jl; > ; > @glwagner I'm not sure. I tried running it, but got an method error on the `HydrostaticFreeSurfaceModel`: _FreeSurface( ...) is ambiguous_. Looks like that validation experiment is missing . ```julia; pushfirst!(LOAD_PATH, joinpath(@__DIR__, "".."", "".."")); ```. ~~so it may have been using an old version of Oceananigans in your global environment!~~ EDIT: even if this were the case, I still get the error after adding an appropriate `pushfirst!`. I'll try to fix this separate from this PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1935#issuecomment-900465685
https://github.com/CliMA/Oceananigans.jl/pull/1935#issuecomment-900465685:31,Security,validat,validation,31,"> > There is also already a 1D validation test for the immersed boundary --- I wonder if it also shows this bug:; > > https://github.com/CliMA/Oceananigans.jl/blob/master/validation/immersed_boundaries/immersed_hydrostatic_diffusion.jl; > ; > @glwagner I'm not sure. I tried running it, but got an method error on the `HydrostaticFreeSurfaceModel`: _FreeSurface( ...) is ambiguous_. Looks like that validation experiment is missing . ```julia; pushfirst!(LOAD_PATH, joinpath(@__DIR__, "".."", "".."")); ```. ~~so it may have been using an old version of Oceananigans in your global environment!~~ EDIT: even if this were the case, I still get the error after adding an appropriate `pushfirst!`. I'll try to fix this separate from this PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1935#issuecomment-900465685
https://github.com/CliMA/Oceananigans.jl/pull/1935#issuecomment-900465685:171,Security,validat,validation,171,"> > There is also already a 1D validation test for the immersed boundary --- I wonder if it also shows this bug:; > > https://github.com/CliMA/Oceananigans.jl/blob/master/validation/immersed_boundaries/immersed_hydrostatic_diffusion.jl; > ; > @glwagner I'm not sure. I tried running it, but got an method error on the `HydrostaticFreeSurfaceModel`: _FreeSurface( ...) is ambiguous_. Looks like that validation experiment is missing . ```julia; pushfirst!(LOAD_PATH, joinpath(@__DIR__, "".."", "".."")); ```. ~~so it may have been using an old version of Oceananigans in your global environment!~~ EDIT: even if this were the case, I still get the error after adding an appropriate `pushfirst!`. I'll try to fix this separate from this PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1935#issuecomment-900465685
https://github.com/CliMA/Oceananigans.jl/pull/1935#issuecomment-900465685:399,Security,validat,validation,399,"> > There is also already a 1D validation test for the immersed boundary --- I wonder if it also shows this bug:; > > https://github.com/CliMA/Oceananigans.jl/blob/master/validation/immersed_boundaries/immersed_hydrostatic_diffusion.jl; > ; > @glwagner I'm not sure. I tried running it, but got an method error on the `HydrostaticFreeSurfaceModel`: _FreeSurface( ...) is ambiguous_. Looks like that validation experiment is missing . ```julia; pushfirst!(LOAD_PATH, joinpath(@__DIR__, "".."", "".."")); ```. ~~so it may have been using an old version of Oceananigans in your global environment!~~ EDIT: even if this were the case, I still get the error after adding an appropriate `pushfirst!`. I'll try to fix this separate from this PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1935#issuecomment-900465685
https://github.com/CliMA/Oceananigans.jl/pull/1935#issuecomment-900465685:42,Testability,test,test,42,"> > There is also already a 1D validation test for the immersed boundary --- I wonder if it also shows this bug:; > > https://github.com/CliMA/Oceananigans.jl/blob/master/validation/immersed_boundaries/immersed_hydrostatic_diffusion.jl; > ; > @glwagner I'm not sure. I tried running it, but got an method error on the `HydrostaticFreeSurfaceModel`: _FreeSurface( ...) is ambiguous_. Looks like that validation experiment is missing . ```julia; pushfirst!(LOAD_PATH, joinpath(@__DIR__, "".."", "".."")); ```. ~~so it may have been using an old version of Oceananigans in your global environment!~~ EDIT: even if this were the case, I still get the error after adding an appropriate `pushfirst!`. I'll try to fix this separate from this PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1935#issuecomment-900465685
https://github.com/CliMA/Oceananigans.jl/pull/1935#issuecomment-900468098:21,Availability,error,error,21,"Bleh, I get the same error with `immersed_hydrostatic_diffusion.jl`. I think there's a bug in the constructor. Let's not worry about it here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1935#issuecomment-900468098
https://github.com/CliMA/Oceananigans.jl/pull/1935#issuecomment-900571106:26,Deployability,patch,patch,26,"> We should also bump the patch version number by editing `Project.toml` so this gets captured by a tagged release I think. I can do that if you like!. I'm not sure what you'd need to do here, so probably best for you to do that!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1935#issuecomment-900571106
https://github.com/CliMA/Oceananigans.jl/pull/1935#issuecomment-900571106:107,Deployability,release,release,107,"> We should also bump the patch version number by editing `Project.toml` so this gets captured by a tagged release I think. I can do that if you like!. I'm not sure what you'd need to do here, so probably best for you to do that!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1935#issuecomment-900571106
https://github.com/CliMA/Oceananigans.jl/pull/1935#issuecomment-900585787:30,Testability,test,tests,30,Yes! Probably should wait for tests to all pass so we can sleep easy but then good to merge for sure.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1935#issuecomment-900585787
https://github.com/CliMA/Oceananigans.jl/issues/1937#issuecomment-1479964929:202,Availability,error,error,202,"I'm closing this issue because I'm judging that it's not of current, timely relevance to Oceananigans development. If you would like to make it a higher priority or if you think the issue was closed in error please feel free to re-open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1937#issuecomment-1479964929
https://github.com/CliMA/Oceananigans.jl/issues/1938#issuecomment-1479964483:202,Availability,error,error,202,"I'm closing this issue because I'm judging that it's not of current, timely relevance to Oceananigans development. If you would like to make it a higher priority or if you think the issue was closed in error please feel free to re-open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1938#issuecomment-1479964483
https://github.com/CliMA/Oceananigans.jl/pull/1939#issuecomment-901387255:151,Availability,avail,available,151,"> I'm ok with exporting `KernelFunctionOperation` from the submodule `AbstractOperations`. But do we also want to export it from the top-level so it's available when we write `using Oceananigans`?. I'm okay with not exporting it to the top level, but then I guess we also wanna stop exporting `KernelComputedField` to the top level for consistency, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1939#issuecomment-901387255
https://github.com/CliMA/Oceananigans.jl/pull/1939#issuecomment-901395047:153,Availability,avail,available,153,"> > I'm ok with exporting `KernelFunctionOperation` from the submodule `AbstractOperations`. But do we also want to export it from the top-level so it's available when we write `using Oceananigans`?; > ; > I'm okay with not exporting it to the top level, but then I guess we also wanna stop exporting `KernelComputedField` to the top level for consistency, no?. I don't understand what you're saying, can you say it again a bit differently? My suggestion is to add `KernelFunctionOperation` to this line: https://github.com/CliMA/Oceananigans.jl/blob/22bcf3adc2fad0fda6b474aa08a84acd6c461478/src/Oceananigans.jl#L88. and therefore export it when users write `using Oceananigans`. EDIT: looks like you've done just that. @tomchor are you suggesting that we _not_ export it from `Oceananigans.AbstractOperations`? I'm agnostic on that point. We export many things from submodules, primarily as a convenience for developers. For example, both `Oceananigans` and `Oceananigans.Fields` exports `Field`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1939#issuecomment-901395047
https://github.com/CliMA/Oceananigans.jl/pull/1939#issuecomment-901399057:1360,Testability,test,tests,1360,"Can confirm that the docstring now works:. ```julia; help?> KernelFunctionOperation; search: KernelFunctionOperation. KernelFunctionOperation{LX, LY, LZ}(kernel_function, grid; architecture=nothing,; computed_dependencies=(), parameters=nothing). Constructs a KernelFunctionOperation at location (LX, LY, LZ) on grid an with an optional iterable of computed_dependencies and arbitrary parameters. With isnothing(parameters) (the default), kernel_function is called with. kernel_function(i, j, k, grid, computed_dependencies...). Otherwise kernel_function is called with. kernel_function(i, j, k, grid, computed_dependencies..., parameters). Examples; . Construct a kernel function operation that returns random numbers:. random_kernel_function(i, j, k, grid) = rand() # use CUDA.rand on the GPU; ; kernel_op = KernelFunctionOperation{Center, Center, Center}(random_kernel_function, grid; architecture=CPU()). Construct a kernel function operation using the vertical vorticity operator valid on curvilinear and cubed sphere grids:. using Oceananigans.Operators:  # called with signature (i, j, k, grid, u, v); ; grid = model.grid; u, v, w = model.velocities; ; _op = KernelFunctionOperation{Face, Face, Center}(, grid, computed_dependencies=(u, v)); ```. Also caught a couple of typos in the docstrng. We should be good to go when the tests pass",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1939#issuecomment-901399057
https://github.com/CliMA/Oceananigans.jl/pull/1940#issuecomment-901431732:115,Deployability,deploy,deployed,115,https://clima.github.io/OceananigansDocumentation/previews/PR1940. But the docs log will also say if that has been deployed or not. If there was a DOCUMENTER_KEY issue or something else...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1940#issuecomment-901431732
https://github.com/CliMA/Oceananigans.jl/pull/1940#issuecomment-901431732:80,Testability,log,log,80,https://clima.github.io/OceananigansDocumentation/previews/PR1940. But the docs log will also say if that has been deployed or not. If there was a DOCUMENTER_KEY issue or something else...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1940#issuecomment-901431732
https://github.com/CliMA/Oceananigans.jl/pull/1940#issuecomment-901439660:10,Testability,log,log,10,From the [log](https://buildkite.com/clima/oceananigans/builds/3685#e88e73f9-20e6-43c6-8c05-64c492318d38) I see that the DOCUMENTER_KEY is OK! But I think the first commit doesn't generate the preview (this was already the case previously when things were working). I pushed again something nothing really to see what happens!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1940#issuecomment-901439660
https://github.com/CliMA/Oceananigans.jl/issues/1941#issuecomment-1479944526:202,Availability,error,error,202,"I'm closing this issue because I'm judging that it's not of current, timely relevance to Oceananigans development. If you would like to make it a higher priority or if you think the issue was closed in error please feel free to re-open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1941#issuecomment-1479944526
https://github.com/CliMA/Oceananigans.jl/issues/1942#issuecomment-902680649:1198,Usability,simpl,simple,1198,"> What bit of the code do you think needs to be modified?. Good question! I think here:. https://github.com/CliMA/Oceananigans.jl/blob/79676db7707e1f4c4cb7d21b0924562d36b2790f/src/Fields/broadcasting_abstract_fields.jl#L20-L22. Here's how we figure that out. First we use `Meta.@lower` to find the code that runs when we use `.=`:. ```julia; julia> Meta.@lower c .= c0; :($(Expr(:thunk, CodeInfo(; @ none within `top-level scope'; 1  %1 = Base.broadcasted(Base.identity, c0);  %2 = Base.materialize!(c, %1);  return %2; )))); ```. Now we can build the operation and use `@which` to figure out what it calls:. ```julia; julia> bc = Base.broadcasted(Base.identity, c0); Base.Broadcast.Broadcasted(identity, ([0.9778532419793966]. [0.5210723026166955],)). julia> Base.materialize!(c, bc). julia> @which Base.materialize!(c, bc); materialize!(dest::Oceananigans.Fields.AbstractField, bc::Base.Broadcast.Broadcasted{var""#s183"", Axes, F, Args} where {var""#s183""<:Base.Broadcast.DefaultArrayStyle, Axes, F, Args<:Tuple}) in Oceananigans.Fields at /Users/gregorywagner/Projects/Oceananigans.jl/src/Fields/broadcasting_abstract_fields.jl:21; ```. The indicated line is the one I've posted. Might be as simple as defining. ```julia; @inline Base.Broadcast.materialize!(dest::AbstractField, bc::Broadcasted{<:DefaultArrayStyle}) =; Base.Broadcast.materialize!(interior(dest), bc); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1942#issuecomment-902680649
https://github.com/CliMA/Oceananigans.jl/issues/1942#issuecomment-902684023:52,Usability,guid,guiding,52,Wow! So many interesting things here and thanks for guiding me along the path to figure this out. . I will give this a try now and let you know if it resolves this problem.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1942#issuecomment-902684023
https://github.com/CliMA/Oceananigans.jl/issues/1942#issuecomment-902684253:19,Testability,test,test,19,Opened a PR with a test: https://github.com/CliMA/Oceananigans.jl/pull/1947,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1942#issuecomment-902684253
https://github.com/CliMA/Oceananigans.jl/issues/1942#issuecomment-1479909091:202,Availability,error,error,202,"I'm closing this issue because I'm judging that it's not of current, timely relevance to Oceananigans development. If you would like to make it a higher priority or if you think the issue was closed in error please feel free to re-open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1942#issuecomment-1479909091
https://github.com/CliMA/Oceananigans.jl/pull/1943#issuecomment-902000322:192,Energy Efficiency,efficient,efficiently,192,"Right, I think we should selectively and conservatively add features to docs to save users the pain of banging their heads against the wall with experimental stuff. It also helps us work more efficiently since if we decide to do things like change a filename associated with a feature, we don't have extra work to keep the docs up to date.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1943#issuecomment-902000322
https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902649636:99,Availability,error,error,99,"Are you sure this is exactly the same code that you ran? . I tried executing it as is and found an error on this line. ```; T_bcs = FieldBoundaryConditions( top = FluxBoundaryCondition(heatflux(t)),; bottom = GradientBoundaryCondition(dTdz)); ```. The error is the following:. ```; ERROR: UndefVarError: t not defined; Stacktrace:; [1] top-level scope; @ REPL[38]:1; [2] top-level scope; @ ~/.julia/packages/CUDA/fRSUT/src/initialization.jl:52; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902649636
https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902649636:252,Availability,error,error,252,"Are you sure this is exactly the same code that you ran? . I tried executing it as is and found an error on this line. ```; T_bcs = FieldBoundaryConditions( top = FluxBoundaryCondition(heatflux(t)),; bottom = GradientBoundaryCondition(dTdz)); ```. The error is the following:. ```; ERROR: UndefVarError: t not defined; Stacktrace:; [1] top-level scope; @ REPL[38]:1; [2] top-level scope; @ ~/.julia/packages/CUDA/fRSUT/src/initialization.jl:52; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902649636
https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902649636:282,Availability,ERROR,ERROR,282,"Are you sure this is exactly the same code that you ran? . I tried executing it as is and found an error on this line. ```; T_bcs = FieldBoundaryConditions( top = FluxBoundaryCondition(heatflux(t)),; bottom = GradientBoundaryCondition(dTdz)); ```. The error is the following:. ```; ERROR: UndefVarError: t not defined; Stacktrace:; [1] top-level scope; @ REPL[38]:1; [2] top-level scope; @ ~/.julia/packages/CUDA/fRSUT/src/initialization.jl:52; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902649636
https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902685609:128,Availability,error,error,128,"@Sumanshekhar17 can you write up a shorter example that does not involve data? Hopefully, as short as possible to reproduce the error. The code you've posted is too long to efficiently debug.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902685609
https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902685609:173,Energy Efficiency,efficient,efficiently,173,"@Sumanshekhar17 can you write up a shorter example that does not involve data? Hopefully, as short as possible to reproduce the error. The code you've posted is too long to efficiently debug.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902685609
https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902839166:106,Availability,error,error,106,"> Are you sure this is exactly the same code that you ran?; > ; > I tried executing it as is and found an error on this line; > ; > ```; > T_bcs = FieldBoundaryConditions( top = FluxBoundaryCondition(heatflux(t)),; > bottom = GradientBoundaryCondition(dTdz)); > ```; > ; > The error is the following:; > ; > ```; > ERROR: UndefVarError: t not defined; > Stacktrace:; > [1] top-level scope; > @ REPL[38]:1; > [2] top-level scope; > @ ~/.julia/packages/CUDA/fRSUT/src/initialization.jl:52; > ```. @francispoulin sorry, I did one mistake there. Though I am pasting a short code here which can produce the same error -; ```; using Printf; using Oceananigans; using Oceananigans.Units: minutes, hour, hours, day. const Nx=256; const Ny=256; const Nz=64. #Length of grid in south, north and vertical direction; const Lx=4; const Ly=4; const Lz=0.1. const S = 1.6 # Stretching factor; hyperbolically_spaced_nodes(k) = -Lz-Lz*(tanh(S * ( (-(k-Nz-1) ) / Nz - 1)) / tanh(S)); computational_grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; architecture = CPU(),; x = (0,Lx),; y = (0,Ly),; halo = (3, 3, 3),; z_faces = hyperbolically_spaced_nodes). #Coefficient of Thermal expansion; const alpha= 2e-4. #Coefficient of Salinity; const beta=8e-4; #heat flux; const Bo=3.6e-4; #coriolis parameter; const f=-0.5; #gravitational acceleration; const g=300. Q = Bo; const dTdz = 0 # K m; T_bcs = FieldBoundaryConditions(; top = FluxBoundaryCondition(Q),; bottom = GradientBoundaryCondition(dTdz)). const Q=0; u_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Q), bottom=ValueBoundaryCondition(0.0)); v_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Q), bottom=ValueBoundaryCondition(0.0)). buoyancy = SeawaterBuoyancy(gravitational_acceleration = g,equation_of_state=LinearEquationOfState(=alpha, =beta)). using Oceananigans.Advection; using Oceananigans.TurbulenceClosures. model = NonhydrostaticModel(architecture = CPU(),; advection = UpwindBiasedFifthOrder(),; timesteppe",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902839166
https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902839166:277,Availability,error,error,277,"> Are you sure this is exactly the same code that you ran?; > ; > I tried executing it as is and found an error on this line; > ; > ```; > T_bcs = FieldBoundaryConditions( top = FluxBoundaryCondition(heatflux(t)),; > bottom = GradientBoundaryCondition(dTdz)); > ```; > ; > The error is the following:; > ; > ```; > ERROR: UndefVarError: t not defined; > Stacktrace:; > [1] top-level scope; > @ REPL[38]:1; > [2] top-level scope; > @ ~/.julia/packages/CUDA/fRSUT/src/initialization.jl:52; > ```. @francispoulin sorry, I did one mistake there. Though I am pasting a short code here which can produce the same error -; ```; using Printf; using Oceananigans; using Oceananigans.Units: minutes, hour, hours, day. const Nx=256; const Ny=256; const Nz=64. #Length of grid in south, north and vertical direction; const Lx=4; const Ly=4; const Lz=0.1. const S = 1.6 # Stretching factor; hyperbolically_spaced_nodes(k) = -Lz-Lz*(tanh(S * ( (-(k-Nz-1) ) / Nz - 1)) / tanh(S)); computational_grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; architecture = CPU(),; x = (0,Lx),; y = (0,Ly),; halo = (3, 3, 3),; z_faces = hyperbolically_spaced_nodes). #Coefficient of Thermal expansion; const alpha= 2e-4. #Coefficient of Salinity; const beta=8e-4; #heat flux; const Bo=3.6e-4; #coriolis parameter; const f=-0.5; #gravitational acceleration; const g=300. Q = Bo; const dTdz = 0 # K m; T_bcs = FieldBoundaryConditions(; top = FluxBoundaryCondition(Q),; bottom = GradientBoundaryCondition(dTdz)). const Q=0; u_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Q), bottom=ValueBoundaryCondition(0.0)); v_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Q), bottom=ValueBoundaryCondition(0.0)). buoyancy = SeawaterBuoyancy(gravitational_acceleration = g,equation_of_state=LinearEquationOfState(=alpha, =beta)). using Oceananigans.Advection; using Oceananigans.TurbulenceClosures. model = NonhydrostaticModel(architecture = CPU(),; advection = UpwindBiasedFifthOrder(),; timesteppe",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902839166
https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902839166:315,Availability,ERROR,ERROR,315,"> Are you sure this is exactly the same code that you ran?; > ; > I tried executing it as is and found an error on this line; > ; > ```; > T_bcs = FieldBoundaryConditions( top = FluxBoundaryCondition(heatflux(t)),; > bottom = GradientBoundaryCondition(dTdz)); > ```; > ; > The error is the following:; > ; > ```; > ERROR: UndefVarError: t not defined; > Stacktrace:; > [1] top-level scope; > @ REPL[38]:1; > [2] top-level scope; > @ ~/.julia/packages/CUDA/fRSUT/src/initialization.jl:52; > ```. @francispoulin sorry, I did one mistake there. Though I am pasting a short code here which can produce the same error -; ```; using Printf; using Oceananigans; using Oceananigans.Units: minutes, hour, hours, day. const Nx=256; const Ny=256; const Nz=64. #Length of grid in south, north and vertical direction; const Lx=4; const Ly=4; const Lz=0.1. const S = 1.6 # Stretching factor; hyperbolically_spaced_nodes(k) = -Lz-Lz*(tanh(S * ( (-(k-Nz-1) ) / Nz - 1)) / tanh(S)); computational_grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; architecture = CPU(),; x = (0,Lx),; y = (0,Ly),; halo = (3, 3, 3),; z_faces = hyperbolically_spaced_nodes). #Coefficient of Thermal expansion; const alpha= 2e-4. #Coefficient of Salinity; const beta=8e-4; #heat flux; const Bo=3.6e-4; #coriolis parameter; const f=-0.5; #gravitational acceleration; const g=300. Q = Bo; const dTdz = 0 # K m; T_bcs = FieldBoundaryConditions(; top = FluxBoundaryCondition(Q),; bottom = GradientBoundaryCondition(dTdz)). const Q=0; u_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Q), bottom=ValueBoundaryCondition(0.0)); v_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Q), bottom=ValueBoundaryCondition(0.0)). buoyancy = SeawaterBuoyancy(gravitational_acceleration = g,equation_of_state=LinearEquationOfState(=alpha, =beta)). using Oceananigans.Advection; using Oceananigans.TurbulenceClosures. model = NonhydrostaticModel(architecture = CPU(),; advection = UpwindBiasedFifthOrder(),; timesteppe",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902839166
https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902839166:607,Availability,error,error,607,"> Are you sure this is exactly the same code that you ran?; > ; > I tried executing it as is and found an error on this line; > ; > ```; > T_bcs = FieldBoundaryConditions( top = FluxBoundaryCondition(heatflux(t)),; > bottom = GradientBoundaryCondition(dTdz)); > ```; > ; > The error is the following:; > ; > ```; > ERROR: UndefVarError: t not defined; > Stacktrace:; > [1] top-level scope; > @ REPL[38]:1; > [2] top-level scope; > @ ~/.julia/packages/CUDA/fRSUT/src/initialization.jl:52; > ```. @francispoulin sorry, I did one mistake there. Though I am pasting a short code here which can produce the same error -; ```; using Printf; using Oceananigans; using Oceananigans.Units: minutes, hour, hours, day. const Nx=256; const Ny=256; const Nz=64. #Length of grid in south, north and vertical direction; const Lx=4; const Ly=4; const Lz=0.1. const S = 1.6 # Stretching factor; hyperbolically_spaced_nodes(k) = -Lz-Lz*(tanh(S * ( (-(k-Nz-1) ) / Nz - 1)) / tanh(S)); computational_grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; architecture = CPU(),; x = (0,Lx),; y = (0,Ly),; halo = (3, 3, 3),; z_faces = hyperbolically_spaced_nodes). #Coefficient of Thermal expansion; const alpha= 2e-4. #Coefficient of Salinity; const beta=8e-4; #heat flux; const Bo=3.6e-4; #coriolis parameter; const f=-0.5; #gravitational acceleration; const g=300. Q = Bo; const dTdz = 0 # K m; T_bcs = FieldBoundaryConditions(; top = FluxBoundaryCondition(Q),; bottom = GradientBoundaryCondition(dTdz)). const Q=0; u_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Q), bottom=ValueBoundaryCondition(0.0)); v_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Q), bottom=ValueBoundaryCondition(0.0)). buoyancy = SeawaterBuoyancy(gravitational_acceleration = g,equation_of_state=LinearEquationOfState(=alpha, =beta)). using Oceananigans.Advection; using Oceananigans.TurbulenceClosures. model = NonhydrostaticModel(architecture = CPU(),; advection = UpwindBiasedFifthOrder(),; timesteppe",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902839166
https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902839166:3100,Energy Efficiency,schedul,schedule,3100,"s). #Coefficient of Thermal expansion; const alpha= 2e-4. #Coefficient of Salinity; const beta=8e-4; #heat flux; const Bo=3.6e-4; #coriolis parameter; const f=-0.5; #gravitational acceleration; const g=300. Q = Bo; const dTdz = 0 # K m; T_bcs = FieldBoundaryConditions(; top = FluxBoundaryCondition(Q),; bottom = GradientBoundaryCondition(dTdz)). const Q=0; u_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Q), bottom=ValueBoundaryCondition(0.0)); v_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Q), bottom=ValueBoundaryCondition(0.0)). buoyancy = SeawaterBuoyancy(gravitational_acceleration = g,equation_of_state=LinearEquationOfState(=alpha, =beta)). using Oceananigans.Advection; using Oceananigans.TurbulenceClosures. model = NonhydrostaticModel(architecture = CPU(),; advection = UpwindBiasedFifthOrder(),; timestepper = :RungeKutta3,; grid = computational_grid,; tracers = (:T, :S),; coriolis = FPlane(f=f),; buoyancy = buoyancy,; closure = SmagorinskyLilly(),; boundary_conditions = (u=u_bcs, v=v_bcs, T=T_bcs)); using Oceananigans.Diagnostics: accurate_cell_advection_timescale; wizard = TimeStepWizard(cfl=0.5,t=0.1, max_change=1.1, max_t=1minutes,cell_advection_timescale = accurate_cell_advection_timescale); start_time = time_ns() # so we can print the total elapsed wall time. # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, t: %s, wmax = %.1e ms, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard), maximum(abs, sim.model.velocities.w),; prettytime((time_ns() - start_time) * 1e-9)). simulation = Simulation(model,; t = wizard,; stop_time = 12minutes,; iteration_interval = 1,; progress = progress_message; ); fields = Dict(""u"" => model.velocities.u,""v"" => model.velocities.v,""w"" => model.velocities.w, ""T"" => model.tracers.T). simulation.output_writers[:fields] =; NetCDFOutputWriter(model, fields, filepath=""TestSetup.nc"",; schedule=TimeInterval(6) ); run!(simulation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902839166
https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902839166:2490,Integrability,message,message,2490,"s). #Coefficient of Thermal expansion; const alpha= 2e-4. #Coefficient of Salinity; const beta=8e-4; #heat flux; const Bo=3.6e-4; #coriolis parameter; const f=-0.5; #gravitational acceleration; const g=300. Q = Bo; const dTdz = 0 # K m; T_bcs = FieldBoundaryConditions(; top = FluxBoundaryCondition(Q),; bottom = GradientBoundaryCondition(dTdz)). const Q=0; u_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Q), bottom=ValueBoundaryCondition(0.0)); v_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Q), bottom=ValueBoundaryCondition(0.0)). buoyancy = SeawaterBuoyancy(gravitational_acceleration = g,equation_of_state=LinearEquationOfState(=alpha, =beta)). using Oceananigans.Advection; using Oceananigans.TurbulenceClosures. model = NonhydrostaticModel(architecture = CPU(),; advection = UpwindBiasedFifthOrder(),; timestepper = :RungeKutta3,; grid = computational_grid,; tracers = (:T, :S),; coriolis = FPlane(f=f),; buoyancy = buoyancy,; closure = SmagorinskyLilly(),; boundary_conditions = (u=u_bcs, v=v_bcs, T=T_bcs)); using Oceananigans.Diagnostics: accurate_cell_advection_timescale; wizard = TimeStepWizard(cfl=0.5,t=0.1, max_change=1.1, max_t=1minutes,cell_advection_timescale = accurate_cell_advection_timescale); start_time = time_ns() # so we can print the total elapsed wall time. # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, t: %s, wmax = %.1e ms, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard), maximum(abs, sim.model.velocities.w),; prettytime((time_ns() - start_time) * 1e-9)). simulation = Simulation(model,; t = wizard,; stop_time = 12minutes,; iteration_interval = 1,; progress = progress_message; ); fields = Dict(""u"" => model.velocities.u,""v"" => model.velocities.v,""w"" => model.velocities.w, ""T"" => model.tracers.T). simulation.output_writers[:fields] =; NetCDFOutputWriter(model, fields, filepath=""TestSetup.nc"",; schedule=TimeInterval(6) ); run!(simulation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902839166
https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902839166:3084,Testability,Test,TestSetup,3084,"s). #Coefficient of Thermal expansion; const alpha= 2e-4. #Coefficient of Salinity; const beta=8e-4; #heat flux; const Bo=3.6e-4; #coriolis parameter; const f=-0.5; #gravitational acceleration; const g=300. Q = Bo; const dTdz = 0 # K m; T_bcs = FieldBoundaryConditions(; top = FluxBoundaryCondition(Q),; bottom = GradientBoundaryCondition(dTdz)). const Q=0; u_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Q), bottom=ValueBoundaryCondition(0.0)); v_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Q), bottom=ValueBoundaryCondition(0.0)). buoyancy = SeawaterBuoyancy(gravitational_acceleration = g,equation_of_state=LinearEquationOfState(=alpha, =beta)). using Oceananigans.Advection; using Oceananigans.TurbulenceClosures. model = NonhydrostaticModel(architecture = CPU(),; advection = UpwindBiasedFifthOrder(),; timestepper = :RungeKutta3,; grid = computational_grid,; tracers = (:T, :S),; coriolis = FPlane(f=f),; buoyancy = buoyancy,; closure = SmagorinskyLilly(),; boundary_conditions = (u=u_bcs, v=v_bcs, T=T_bcs)); using Oceananigans.Diagnostics: accurate_cell_advection_timescale; wizard = TimeStepWizard(cfl=0.5,t=0.1, max_change=1.1, max_t=1minutes,cell_advection_timescale = accurate_cell_advection_timescale); start_time = time_ns() # so we can print the total elapsed wall time. # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, t: %s, wmax = %.1e ms, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard), maximum(abs, sim.model.velocities.w),; prettytime((time_ns() - start_time) * 1e-9)). simulation = Simulation(model,; t = wizard,; stop_time = 12minutes,; iteration_interval = 1,; progress = progress_message; ); fields = Dict(""u"" => model.velocities.u,""v"" => model.velocities.v,""w"" => model.velocities.w, ""T"" => model.tracers.T). simulation.output_writers[:fields] =; NetCDFOutputWriter(model, fields, filepath=""TestSetup.nc"",; schedule=TimeInterval(6) ); run!(simulation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902839166
https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902841030:459,Availability,ERROR,ERROR,459,"I think the problem is that `prettytime(wizard)` does not work. MWE:. ```julia; julia> using Oceananigans. julia> wizard = TimeStepWizard(cfl=0.1, t=1.0); TimeStepWizard{Float64, typeof(Oceananigans.Utils.cell_advection_timescale), typeof(Oceananigans.Simulations.infinite_diffusion_timescale)}(0.1, Inf, 2.0, 0.5, Inf, 0.0, 1.0, Oceananigans.Utils.cell_advection_timescale, Oceananigans.Simulations.infinite_diffusion_timescale). julia> prettytime(wizard); ERROR: MethodError: no method matching zero(::TimeStepWizard{Float64, typeof(Oceananigans.Utils.cell_advection_timescale), typeof(Oceananigans.Simulations.infinite_diffusion_timescale)}); Closest candidates are:; zero(::Union{Type{P}, P}) where P<:Dates.Period at /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.6/Dates/src/periods.jl:53; zero(::ArrayInterface.NDIndex{N, I} where I<:Tuple{Vararg{Any, N}}) where N at /Users/gregorywagner/.julia/packages/ArrayInterface/VFy81/src/ndindex.jl:95; zero(::LinearAlgebra.UniformScaling{T}) where T at /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/uniformscaling.jl:136; ...; Stacktrace:; [1] iszero(x::TimeStepWizard{Float64, typeof(Oceananigans.Utils.cell_advection_timescale), typeof(Oceananigans.Simulations.infinite_diffusion_timescale)}); @ Base ./number.jl:40; [2] prettytime(t::TimeStepWizard{Float64, typeof(Oceananigans.Utils.cell_advection_timescale), typeof(Oceananigans.Simulations.infinite_diffusion_timescale)}); @ Oceananigans.Utils ~/.julia/packages/Oceananigans/MRn50/src/Utils/pretty_time.jl:18; [3] top-level scope; @ REPL[3]:1; ```. I'm not sure what `prettytime(wizard)` should return --- I think this is expected.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902841030
https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902842128:31,Usability,simpl,simpler,31,Thanks @Sumanshekhar17 for the simpler example and @glwagner has answered your question I believe. Why don't you try it without `prettytime(wizard)` to see if that works?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-902842128
https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-903087954:497,Availability,error,error,497,"@francispoulin and @glwagner Thank you for this. before closing this issue I wanted to ask weather I have written my boundary condtion as a function `heatflux` is correct or not -; ```; function heatflux(x, y, z, t); if Q_net(t) <= 0; bias = 1; multiplier = 0; else; bias = 0; multiplier = 1; end. return bias*Q_cool; end; Temp_bc = FluxBoundaryCondition(heatflux); dTdz = 0; T_bcs = FieldBoundaryConditions( top = Temp_bc,; bottom = GradientBoundaryCondition(dTdz)); ```; I am constantly getting error stating that -; ```; TaskFailedException. nested task error: MethodError: no method matching heatflux(::Float64, ::Float64, ::Float64); Closest candidates are:; heatflux(::Any, ::Any, ::Any, ::Any) at In[9]:1; Stacktrace:; [1] call; @ C:\Users\My Account\.julia\packages\Cassette\r4kKQ\src\context.jl:456 [inlined]; [2] fallback; @ C:\Users\My Account\.julia\packages\Cassette\r4kKQ\src\context.jl:454 [inlined]; [3] _overdub_fallback(::Any, ::Vararg{Any, N} where N); @ C:\Users\My Account\.julia\packages\Cassette\r4kKQ\src\overdub.jl:585 [inlined]; [4] overdub; @ C:\Users\My Account\.julia\packages\Cassette\r4kKQ\src\overdub.jl:585 [inlined]; [5] overdub; @ C:\Users\My Account\.julia\packages\Oceananigans\To7WB\src\BoundaryConditions\continuous_boundary_function.jl:122 [inlined]; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-903087954
https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-903087954:557,Availability,error,error,557,"@francispoulin and @glwagner Thank you for this. before closing this issue I wanted to ask weather I have written my boundary condtion as a function `heatflux` is correct or not -; ```; function heatflux(x, y, z, t); if Q_net(t) <= 0; bias = 1; multiplier = 0; else; bias = 0; multiplier = 1; end. return bias*Q_cool; end; Temp_bc = FluxBoundaryCondition(heatflux); dTdz = 0; T_bcs = FieldBoundaryConditions( top = Temp_bc,; bottom = GradientBoundaryCondition(dTdz)); ```; I am constantly getting error stating that -; ```; TaskFailedException. nested task error: MethodError: no method matching heatflux(::Float64, ::Float64, ::Float64); Closest candidates are:; heatflux(::Any, ::Any, ::Any, ::Any) at In[9]:1; Stacktrace:; [1] call; @ C:\Users\My Account\.julia\packages\Cassette\r4kKQ\src\context.jl:456 [inlined]; [2] fallback; @ C:\Users\My Account\.julia\packages\Cassette\r4kKQ\src\context.jl:454 [inlined]; [3] _overdub_fallback(::Any, ::Vararg{Any, N} where N); @ C:\Users\My Account\.julia\packages\Cassette\r4kKQ\src\overdub.jl:585 [inlined]; [4] overdub; @ C:\Users\My Account\.julia\packages\Cassette\r4kKQ\src\overdub.jl:585 [inlined]; [5] overdub; @ C:\Users\My Account\.julia\packages\Oceananigans\To7WB\src\BoundaryConditions\continuous_boundary_function.jl:122 [inlined]; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1946#issuecomment-903087954
https://github.com/CliMA/Oceananigans.jl/pull/1947#issuecomment-902687574:12,Usability,simpl,simple,12,"I tried the simple example from #1942 and that worked great with this PR, so that's good news. Is there something in particular that you are expecting to fail? I will be keeping my fingers crossed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1947#issuecomment-902687574
https://github.com/CliMA/Oceananigans.jl/pull/1947#issuecomment-902688072:22,Testability,test,tests,22,"I expect 3 of these 4 tests to fail:. ```julia; grid = RegularRectilinearGrid(size=(2, 2, 2), extent=(1, 1, 1)). c = CenterField(CPU(), grid); random_column = reshape(rand(2), 1, 1, 2). c .= random_column # broadcast to every horizontal column in c. @test c[1, 1, 2:3] .== random_column; @test c[2, 1, 2:3] .== random_column; @test c[1, 2, 2:3] .== random_column; @test c[2, 2, 2:3] .== random_column; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1947#issuecomment-902688072
https://github.com/CliMA/Oceananigans.jl/pull/1947#issuecomment-902688072:251,Testability,test,test,251,"I expect 3 of these 4 tests to fail:. ```julia; grid = RegularRectilinearGrid(size=(2, 2, 2), extent=(1, 1, 1)). c = CenterField(CPU(), grid); random_column = reshape(rand(2), 1, 1, 2). c .= random_column # broadcast to every horizontal column in c. @test c[1, 1, 2:3] .== random_column; @test c[2, 1, 2:3] .== random_column; @test c[1, 2, 2:3] .== random_column; @test c[2, 2, 2:3] .== random_column; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1947#issuecomment-902688072
https://github.com/CliMA/Oceananigans.jl/pull/1947#issuecomment-902688072:289,Testability,test,test,289,"I expect 3 of these 4 tests to fail:. ```julia; grid = RegularRectilinearGrid(size=(2, 2, 2), extent=(1, 1, 1)). c = CenterField(CPU(), grid); random_column = reshape(rand(2), 1, 1, 2). c .= random_column # broadcast to every horizontal column in c. @test c[1, 1, 2:3] .== random_column; @test c[2, 1, 2:3] .== random_column; @test c[1, 2, 2:3] .== random_column; @test c[2, 2, 2:3] .== random_column; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1947#issuecomment-902688072
https://github.com/CliMA/Oceananigans.jl/pull/1947#issuecomment-902688072:327,Testability,test,test,327,"I expect 3 of these 4 tests to fail:. ```julia; grid = RegularRectilinearGrid(size=(2, 2, 2), extent=(1, 1, 1)). c = CenterField(CPU(), grid); random_column = reshape(rand(2), 1, 1, 2). c .= random_column # broadcast to every horizontal column in c. @test c[1, 1, 2:3] .== random_column; @test c[2, 1, 2:3] .== random_column; @test c[1, 2, 2:3] .== random_column; @test c[2, 2, 2:3] .== random_column; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1947#issuecomment-902688072
https://github.com/CliMA/Oceananigans.jl/pull/1947#issuecomment-902688072:365,Testability,test,test,365,"I expect 3 of these 4 tests to fail:. ```julia; grid = RegularRectilinearGrid(size=(2, 2, 2), extent=(1, 1, 1)). c = CenterField(CPU(), grid); random_column = reshape(rand(2), 1, 1, 2). c .= random_column # broadcast to every horizontal column in c. @test c[1, 1, 2:3] .== random_column; @test c[2, 1, 2:3] .== random_column; @test c[1, 2, 2:3] .== random_column; @test c[2, 2, 2:3] .== random_column; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1947#issuecomment-902688072
https://github.com/CliMA/Oceananigans.jl/pull/1947#issuecomment-902694311:39,Testability,test,test,39,"I think you mean something like. ```; @test c[1, 1, 1:2] == random_column[1, 1, :]; @test c[2, 1, 1:2] == random_column[1, 1, :]; @test c[1, 2, 1:2] == random_column[1, 1, :]; @test c[2, 2, 1:2] == random_column[1, 1, :]; ```; These all pass for me.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1947#issuecomment-902694311
https://github.com/CliMA/Oceananigans.jl/pull/1947#issuecomment-902694311:85,Testability,test,test,85,"I think you mean something like. ```; @test c[1, 1, 1:2] == random_column[1, 1, :]; @test c[2, 1, 1:2] == random_column[1, 1, :]; @test c[1, 2, 1:2] == random_column[1, 1, :]; @test c[2, 2, 1:2] == random_column[1, 1, :]; ```; These all pass for me.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1947#issuecomment-902694311
https://github.com/CliMA/Oceananigans.jl/pull/1947#issuecomment-902694311:131,Testability,test,test,131,"I think you mean something like. ```; @test c[1, 1, 1:2] == random_column[1, 1, :]; @test c[2, 1, 1:2] == random_column[1, 1, :]; @test c[1, 2, 1:2] == random_column[1, 1, :]; @test c[2, 2, 1:2] == random_column[1, 1, :]; ```; These all pass for me.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1947#issuecomment-902694311
https://github.com/CliMA/Oceananigans.jl/pull/1947#issuecomment-902694311:177,Testability,test,test,177,"I think you mean something like. ```; @test c[1, 1, 1:2] == random_column[1, 1, :]; @test c[2, 1, 1:2] == random_column[1, 1, :]; @test c[1, 2, 1:2] == random_column[1, 1, :]; @test c[2, 2, 1:2] == random_column[1, 1, :]; ```; These all pass for me.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1947#issuecomment-902694311
https://github.com/CliMA/Oceananigans.jl/issues/1948#issuecomment-902786645:14,Performance,perform,performance,14,So there is a performance issue with the FFT? How does `PencilFFTs` scale when run stand-alone?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1948#issuecomment-902786645
https://github.com/CliMA/Oceananigans.jl/issues/1948#issuecomment-1480133506:202,Availability,error,error,202,"I'm closing this issue because I'm judging that it's not of current, timely relevance to Oceananigans development. If you would like to make it a higher priority or if you think the issue was closed in error please feel free to re-open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1948#issuecomment-1480133506
https://github.com/CliMA/Oceananigans.jl/issues/1949#issuecomment-902789630:28,Testability,test,test,28,The documentation buildkite test was failing for #1930 already so I don't think that it is what broke it.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1949#issuecomment-902789630
https://github.com/CliMA/Oceananigans.jl/issues/1949#issuecomment-902790855:6,Deployability,update,updates,6,"#1930 updates the docs, so its highly probable that #1930 is what caused the failing docs build, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1949#issuecomment-902790855
https://github.com/CliMA/Oceananigans.jl/issues/1949#issuecomment-902874954:98,Deployability,update,updated,98,#1950 passed all tests and I approved and merged it. I'll open a new PR to add my branch with the updated benchmark docs back in.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1949#issuecomment-902874954
https://github.com/CliMA/Oceananigans.jl/issues/1949#issuecomment-902874954:17,Testability,test,tests,17,#1950 passed all tests and I approved and merged it. I'll open a new PR to add my branch with the updated benchmark docs back in.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1949#issuecomment-902874954
https://github.com/CliMA/Oceananigans.jl/issues/1949#issuecomment-902874954:106,Testability,benchmark,benchmark,106,#1950 passed all tests and I approved and merged it. I'll open a new PR to add my branch with the updated benchmark docs back in.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1949#issuecomment-902874954
https://github.com/CliMA/Oceananigans.jl/pull/1950#issuecomment-902850612:15,Testability,test,test,15,"Documentations test passed, seems like it was #1930 that was breaking it. All I did was edit the markdown file `benchmarks.md`. What could've broken it? @glwagner",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1950#issuecomment-902850612
https://github.com/CliMA/Oceananigans.jl/pull/1950#issuecomment-902850612:112,Testability,benchmark,benchmarks,112,"Documentations test passed, seems like it was #1930 that was breaking it. All I did was edit the markdown file `benchmarks.md`. What could've broken it? @glwagner",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1950#issuecomment-902850612
https://github.com/CliMA/Oceananigans.jl/pull/1950#issuecomment-902863446:26,Testability,benchmark,benchmarks,26,"I wonder if it considers `benchmarks.md` as part of the docs, which is not too crazy a thought. If so, then anyline in your file that is not consistent with markdown standard could cause a problem?. I would suggest trying viewing your file using a markdown program and see if it complains about any particular lines. Or, are there any lines that don't appear?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1950#issuecomment-902863446
https://github.com/CliMA/Oceananigans.jl/pull/1950#issuecomment-902884298:28,Testability,benchmark,benchmarks,28,"> I wonder if it considers `benchmarks.md` as part of the docs, which is not too crazy a thought. If so, then anyline in your file that is not consistent with markdown standard could cause a problem?; > ; > I would suggest trying viewing your file using a markdown program and see if it complains about any particular lines. Or, are there any lines that don't appear?. `benchmarks.md` is part of the docs: https://clima.github.io/OceananigansDocumentation/stable/appendix/benchmarks/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1950#issuecomment-902884298
https://github.com/CliMA/Oceananigans.jl/pull/1950#issuecomment-902884298:370,Testability,benchmark,benchmarks,370,"> I wonder if it considers `benchmarks.md` as part of the docs, which is not too crazy a thought. If so, then anyline in your file that is not consistent with markdown standard could cause a problem?; > ; > I would suggest trying viewing your file using a markdown program and see if it complains about any particular lines. Or, are there any lines that don't appear?. `benchmarks.md` is part of the docs: https://clima.github.io/OceananigansDocumentation/stable/appendix/benchmarks/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1950#issuecomment-902884298
https://github.com/CliMA/Oceananigans.jl/pull/1950#issuecomment-902884298:472,Testability,benchmark,benchmarks,472,"> I wonder if it considers `benchmarks.md` as part of the docs, which is not too crazy a thought. If so, then anyline in your file that is not consistent with markdown standard could cause a problem?; > ; > I would suggest trying viewing your file using a markdown program and see if it complains about any particular lines. Or, are there any lines that don't appear?. `benchmarks.md` is part of the docs: https://clima.github.io/OceananigansDocumentation/stable/appendix/benchmarks/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1950#issuecomment-902884298
https://github.com/CliMA/Oceananigans.jl/pull/1952#issuecomment-902908856:61,Testability,benchmark,benchmarks,61,Have you tried building the docs locally to see how the new `benchmarks.md` looks?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1952#issuecomment-902908856
https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-904165134:15,Availability,error,errors,15,"There are some errors that occurred right away, and I copied one below. Is this because of something in this PR or because of the system perhaps?. ```. ERROR: The following 1 direct dependency failed to precompile:; --;  | ;  | Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09];  | ;  | Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /storage5/buildkite-agent/.julia-3746/compiled/v1.6/Oceananigans/jl_IfcPYz.;  | ERROR: LoadError: LoadError: SystemError: opening file ""/var/lib/buildkite-agent/builds/tartarus-7/clima/oceananigans/src/Advection/upwind_biased_first_order.jl"": No such file or directory;  | Stacktrace:;  | [1] systemerror(p::String, errno::Int32; extrainfo::Nothing);  | @ Base ./error.jl:168;  | [2] #systemerror#62;  | @ ./error.jl:167 [inlined];  | [3] systemerror;  | @ ./error.jl:167 [inlined];  | [4] open(fname::String; lock::Bool, read::Nothing, write::Nothing, create::Nothing, truncate::Nothing, append::Nothing);  | @ Base ./iostream.jl:293;  | [5] open;  | @ ./iostream.jl:282 [inlined];  | [6] open(f::Base.var""#326#327""{String}, args::String; kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}});  | @ Base ./io.jl:328;  | [7] open;  | @ ./io.jl:328 [inlined];  | [8] read;  | @ ./io.jl:434 [inlined];  | [9] _include(mapexpr::Function, mod::Module, _path::String);  | @ Base ./loading.jl:1166;  | [10] include(mod::Module, _path::String);  | @ Base ./Base.jl:386;  | [11] include(x::String);  | @ Oceananigans.Advection ~/builds/tartarus-7/clima/oceananigans/src/Advection/Advection.jl:1;  | [12] top-level scope;  | @ ~/builds/tartarus-7/clima/oceananigans/src/Advection/Advection.jl:43;  | [13] include(mod::Module, _path::String);  | @ Base ./Base.jl:386;  | [14] include(x::String);  | @ Oceananigans ~/builds/tartarus-7/clima/oceananigans/src/Oceananigans.jl:1;  | [15] top-level scope;  | @ ~/builds/tartarus-7/clima/oceananigans/src/Oceananigans.jl:173;  | [16] i",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-904165134
https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-904165134:152,Availability,ERROR,ERROR,152,"There are some errors that occurred right away, and I copied one below. Is this because of something in this PR or because of the system perhaps?. ```. ERROR: The following 1 direct dependency failed to precompile:; --;  | ;  | Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09];  | ;  | Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /storage5/buildkite-agent/.julia-3746/compiled/v1.6/Oceananigans/jl_IfcPYz.;  | ERROR: LoadError: LoadError: SystemError: opening file ""/var/lib/buildkite-agent/builds/tartarus-7/clima/oceananigans/src/Advection/upwind_biased_first_order.jl"": No such file or directory;  | Stacktrace:;  | [1] systemerror(p::String, errno::Int32; extrainfo::Nothing);  | @ Base ./error.jl:168;  | [2] #systemerror#62;  | @ ./error.jl:167 [inlined];  | [3] systemerror;  | @ ./error.jl:167 [inlined];  | [4] open(fname::String; lock::Bool, read::Nothing, write::Nothing, create::Nothing, truncate::Nothing, append::Nothing);  | @ Base ./iostream.jl:293;  | [5] open;  | @ ./iostream.jl:282 [inlined];  | [6] open(f::Base.var""#326#327""{String}, args::String; kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}});  | @ Base ./io.jl:328;  | [7] open;  | @ ./io.jl:328 [inlined];  | [8] read;  | @ ./io.jl:434 [inlined];  | [9] _include(mapexpr::Function, mod::Module, _path::String);  | @ Base ./loading.jl:1166;  | [10] include(mod::Module, _path::String);  | @ Base ./Base.jl:386;  | [11] include(x::String);  | @ Oceananigans.Advection ~/builds/tartarus-7/clima/oceananigans/src/Advection/Advection.jl:1;  | [12] top-level scope;  | @ ~/builds/tartarus-7/clima/oceananigans/src/Advection/Advection.jl:43;  | [13] include(mod::Module, _path::String);  | @ Base ./Base.jl:386;  | [14] include(x::String);  | @ Oceananigans ~/builds/tartarus-7/clima/oceananigans/src/Oceananigans.jl:1;  | [15] top-level scope;  | @ ~/builds/tartarus-7/clima/oceananigans/src/Oceananigans.jl:173;  | [16] i",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-904165134
https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-904165134:452,Availability,ERROR,ERROR,452,"There are some errors that occurred right away, and I copied one below. Is this because of something in this PR or because of the system perhaps?. ```. ERROR: The following 1 direct dependency failed to precompile:; --;  | ;  | Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09];  | ;  | Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /storage5/buildkite-agent/.julia-3746/compiled/v1.6/Oceananigans/jl_IfcPYz.;  | ERROR: LoadError: LoadError: SystemError: opening file ""/var/lib/buildkite-agent/builds/tartarus-7/clima/oceananigans/src/Advection/upwind_biased_first_order.jl"": No such file or directory;  | Stacktrace:;  | [1] systemerror(p::String, errno::Int32; extrainfo::Nothing);  | @ Base ./error.jl:168;  | [2] #systemerror#62;  | @ ./error.jl:167 [inlined];  | [3] systemerror;  | @ ./error.jl:167 [inlined];  | [4] open(fname::String; lock::Bool, read::Nothing, write::Nothing, create::Nothing, truncate::Nothing, append::Nothing);  | @ Base ./iostream.jl:293;  | [5] open;  | @ ./iostream.jl:282 [inlined];  | [6] open(f::Base.var""#326#327""{String}, args::String; kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}});  | @ Base ./io.jl:328;  | [7] open;  | @ ./io.jl:328 [inlined];  | [8] read;  | @ ./io.jl:434 [inlined];  | [9] _include(mapexpr::Function, mod::Module, _path::String);  | @ Base ./loading.jl:1166;  | [10] include(mod::Module, _path::String);  | @ Base ./Base.jl:386;  | [11] include(x::String);  | @ Oceananigans.Advection ~/builds/tartarus-7/clima/oceananigans/src/Advection/Advection.jl:1;  | [12] top-level scope;  | @ ~/builds/tartarus-7/clima/oceananigans/src/Advection/Advection.jl:43;  | [13] include(mod::Module, _path::String);  | @ Base ./Base.jl:386;  | [14] include(x::String);  | @ Oceananigans ~/builds/tartarus-7/clima/oceananigans/src/Oceananigans.jl:1;  | [15] top-level scope;  | @ ~/builds/tartarus-7/clima/oceananigans/src/Oceananigans.jl:173;  | [16] i",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-904165134
https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-904165134:738,Availability,error,error,738,"There are some errors that occurred right away, and I copied one below. Is this because of something in this PR or because of the system perhaps?. ```. ERROR: The following 1 direct dependency failed to precompile:; --;  | ;  | Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09];  | ;  | Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /storage5/buildkite-agent/.julia-3746/compiled/v1.6/Oceananigans/jl_IfcPYz.;  | ERROR: LoadError: LoadError: SystemError: opening file ""/var/lib/buildkite-agent/builds/tartarus-7/clima/oceananigans/src/Advection/upwind_biased_first_order.jl"": No such file or directory;  | Stacktrace:;  | [1] systemerror(p::String, errno::Int32; extrainfo::Nothing);  | @ Base ./error.jl:168;  | [2] #systemerror#62;  | @ ./error.jl:167 [inlined];  | [3] systemerror;  | @ ./error.jl:167 [inlined];  | [4] open(fname::String; lock::Bool, read::Nothing, write::Nothing, create::Nothing, truncate::Nothing, append::Nothing);  | @ Base ./iostream.jl:293;  | [5] open;  | @ ./iostream.jl:282 [inlined];  | [6] open(f::Base.var""#326#327""{String}, args::String; kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}});  | @ Base ./io.jl:328;  | [7] open;  | @ ./io.jl:328 [inlined];  | [8] read;  | @ ./io.jl:434 [inlined];  | [9] _include(mapexpr::Function, mod::Module, _path::String);  | @ Base ./loading.jl:1166;  | [10] include(mod::Module, _path::String);  | @ Base ./Base.jl:386;  | [11] include(x::String);  | @ Oceananigans.Advection ~/builds/tartarus-7/clima/oceananigans/src/Advection/Advection.jl:1;  | [12] top-level scope;  | @ ~/builds/tartarus-7/clima/oceananigans/src/Advection/Advection.jl:43;  | [13] include(mod::Module, _path::String);  | @ Base ./Base.jl:386;  | [14] include(x::String);  | @ Oceananigans ~/builds/tartarus-7/clima/oceananigans/src/Oceananigans.jl:1;  | [15] top-level scope;  | @ ~/builds/tartarus-7/clima/oceananigans/src/Oceananigans.jl:173;  | [16] i",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-904165134
https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-904165134:785,Availability,error,error,785,"There are some errors that occurred right away, and I copied one below. Is this because of something in this PR or because of the system perhaps?. ```. ERROR: The following 1 direct dependency failed to precompile:; --;  | ;  | Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09];  | ;  | Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /storage5/buildkite-agent/.julia-3746/compiled/v1.6/Oceananigans/jl_IfcPYz.;  | ERROR: LoadError: LoadError: SystemError: opening file ""/var/lib/buildkite-agent/builds/tartarus-7/clima/oceananigans/src/Advection/upwind_biased_first_order.jl"": No such file or directory;  | Stacktrace:;  | [1] systemerror(p::String, errno::Int32; extrainfo::Nothing);  | @ Base ./error.jl:168;  | [2] #systemerror#62;  | @ ./error.jl:167 [inlined];  | [3] systemerror;  | @ ./error.jl:167 [inlined];  | [4] open(fname::String; lock::Bool, read::Nothing, write::Nothing, create::Nothing, truncate::Nothing, append::Nothing);  | @ Base ./iostream.jl:293;  | [5] open;  | @ ./iostream.jl:282 [inlined];  | [6] open(f::Base.var""#326#327""{String}, args::String; kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}});  | @ Base ./io.jl:328;  | [7] open;  | @ ./io.jl:328 [inlined];  | [8] read;  | @ ./io.jl:434 [inlined];  | [9] _include(mapexpr::Function, mod::Module, _path::String);  | @ Base ./loading.jl:1166;  | [10] include(mod::Module, _path::String);  | @ Base ./Base.jl:386;  | [11] include(x::String);  | @ Oceananigans.Advection ~/builds/tartarus-7/clima/oceananigans/src/Advection/Advection.jl:1;  | [12] top-level scope;  | @ ~/builds/tartarus-7/clima/oceananigans/src/Advection/Advection.jl:43;  | [13] include(mod::Module, _path::String);  | @ Base ./Base.jl:386;  | [14] include(x::String);  | @ Oceananigans ~/builds/tartarus-7/clima/oceananigans/src/Oceananigans.jl:1;  | [15] top-level scope;  | @ ~/builds/tartarus-7/clima/oceananigans/src/Oceananigans.jl:173;  | [16] i",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-904165134
https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-904165134:838,Availability,error,error,838,"There are some errors that occurred right away, and I copied one below. Is this because of something in this PR or because of the system perhaps?. ```. ERROR: The following 1 direct dependency failed to precompile:; --;  | ;  | Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09];  | ;  | Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /storage5/buildkite-agent/.julia-3746/compiled/v1.6/Oceananigans/jl_IfcPYz.;  | ERROR: LoadError: LoadError: SystemError: opening file ""/var/lib/buildkite-agent/builds/tartarus-7/clima/oceananigans/src/Advection/upwind_biased_first_order.jl"": No such file or directory;  | Stacktrace:;  | [1] systemerror(p::String, errno::Int32; extrainfo::Nothing);  | @ Base ./error.jl:168;  | [2] #systemerror#62;  | @ ./error.jl:167 [inlined];  | [3] systemerror;  | @ ./error.jl:167 [inlined];  | [4] open(fname::String; lock::Bool, read::Nothing, write::Nothing, create::Nothing, truncate::Nothing, append::Nothing);  | @ Base ./iostream.jl:293;  | [5] open;  | @ ./iostream.jl:282 [inlined];  | [6] open(f::Base.var""#326#327""{String}, args::String; kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}});  | @ Base ./io.jl:328;  | [7] open;  | @ ./io.jl:328 [inlined];  | [8] read;  | @ ./io.jl:434 [inlined];  | [9] _include(mapexpr::Function, mod::Module, _path::String);  | @ Base ./loading.jl:1166;  | [10] include(mod::Module, _path::String);  | @ Base ./Base.jl:386;  | [11] include(x::String);  | @ Oceananigans.Advection ~/builds/tartarus-7/clima/oceananigans/src/Advection/Advection.jl:1;  | [12] top-level scope;  | @ ~/builds/tartarus-7/clima/oceananigans/src/Advection/Advection.jl:43;  | [13] include(mod::Module, _path::String);  | @ Base ./Base.jl:386;  | [14] include(x::String);  | @ Oceananigans ~/builds/tartarus-7/clima/oceananigans/src/Oceananigans.jl:1;  | [15] top-level scope;  | @ ~/builds/tartarus-7/clima/oceananigans/src/Oceananigans.jl:173;  | [16] i",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-904165134
https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-904165134:3566,Availability,Error,Error,3566,"  | [12] top-level scope;  | @ ~/builds/tartarus-7/clima/oceananigans/src/Advection/Advection.jl:43;  | [13] include(mod::Module, _path::String);  | @ Base ./Base.jl:386;  | [14] include(x::String);  | @ Oceananigans ~/builds/tartarus-7/clima/oceananigans/src/Oceananigans.jl:1;  | [15] top-level scope;  | @ ~/builds/tartarus-7/clima/oceananigans/src/Oceananigans.jl:173;  | [16] include;  | @ ./Base.jl:386 [inlined];  | [17] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing);  | @ Base ./loading.jl:1235;  | [18] top-level scope;  | @ none:1;  | [19] eval;  | @ ./boot.jl:360 [inlined];  | [20] eval(x::Expr);  | @ Base.MainInclude ./client.jl:446;  | [21] top-level scope;  | @ none:1;  | in expression starting at /var/lib/buildkite-agent/builds/tartarus-7/clima/oceananigans/src/Advection/Advection.jl:1;  | in expression starting at /var/lib/buildkite-agent/builds/tartarus-7/clima/oceananigans/src/Oceananigans.jl:1;  | Stacktrace:;  | [1] pkgerror(msg::String);  | @ Pkg.Types /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Types.jl:55;  | [2] precompile(ctx::Pkg.Types.Context; internal_call::Bool, strict::Bool, kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}});  | @ Pkg.API /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:1265;  | [3] precompile;  | @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:921 [inlined];  | [4] #precompile#196;  | @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:919 [inlined];  | [5] precompile();  | @ Pkg.API /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:919;  | [6] top-level scope;  | @ none:1;  |  Error: The command exited with status 1. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-904165134
https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-904165134:182,Integrability,depend,dependency,182,"There are some errors that occurred right away, and I copied one below. Is this because of something in this PR or because of the system perhaps?. ```. ERROR: The following 1 direct dependency failed to precompile:; --;  | ;  | Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09];  | ;  | Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /storage5/buildkite-agent/.julia-3746/compiled/v1.6/Oceananigans/jl_IfcPYz.;  | ERROR: LoadError: LoadError: SystemError: opening file ""/var/lib/buildkite-agent/builds/tartarus-7/clima/oceananigans/src/Advection/upwind_biased_first_order.jl"": No such file or directory;  | Stacktrace:;  | [1] systemerror(p::String, errno::Int32; extrainfo::Nothing);  | @ Base ./error.jl:168;  | [2] #systemerror#62;  | @ ./error.jl:167 [inlined];  | [3] systemerror;  | @ ./error.jl:167 [inlined];  | [4] open(fname::String; lock::Bool, read::Nothing, write::Nothing, create::Nothing, truncate::Nothing, append::Nothing);  | @ Base ./iostream.jl:293;  | [5] open;  | @ ./iostream.jl:282 [inlined];  | [6] open(f::Base.var""#326#327""{String}, args::String; kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}});  | @ Base ./io.jl:328;  | [7] open;  | @ ./io.jl:328 [inlined];  | [8] read;  | @ ./io.jl:434 [inlined];  | [9] _include(mapexpr::Function, mod::Module, _path::String);  | @ Base ./loading.jl:1166;  | [10] include(mod::Module, _path::String);  | @ Base ./Base.jl:386;  | [11] include(x::String);  | @ Oceananigans.Advection ~/builds/tartarus-7/clima/oceananigans/src/Advection/Advection.jl:1;  | [12] top-level scope;  | @ ~/builds/tartarus-7/clima/oceananigans/src/Advection/Advection.jl:43;  | [13] include(mod::Module, _path::String);  | @ Base ./Base.jl:386;  | [14] include(x::String);  | @ Oceananigans ~/builds/tartarus-7/clima/oceananigans/src/Oceananigans.jl:1;  | [15] top-level scope;  | @ ~/builds/tartarus-7/clima/oceananigans/src/Oceananigans.jl:173;  | [16] i",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-904165134
https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-904165134:459,Performance,Load,LoadError,459,"There are some errors that occurred right away, and I copied one below. Is this because of something in this PR or because of the system perhaps?. ```. ERROR: The following 1 direct dependency failed to precompile:; --;  | ;  | Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09];  | ;  | Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /storage5/buildkite-agent/.julia-3746/compiled/v1.6/Oceananigans/jl_IfcPYz.;  | ERROR: LoadError: LoadError: SystemError: opening file ""/var/lib/buildkite-agent/builds/tartarus-7/clima/oceananigans/src/Advection/upwind_biased_first_order.jl"": No such file or directory;  | Stacktrace:;  | [1] systemerror(p::String, errno::Int32; extrainfo::Nothing);  | @ Base ./error.jl:168;  | [2] #systemerror#62;  | @ ./error.jl:167 [inlined];  | [3] systemerror;  | @ ./error.jl:167 [inlined];  | [4] open(fname::String; lock::Bool, read::Nothing, write::Nothing, create::Nothing, truncate::Nothing, append::Nothing);  | @ Base ./iostream.jl:293;  | [5] open;  | @ ./iostream.jl:282 [inlined];  | [6] open(f::Base.var""#326#327""{String}, args::String; kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}});  | @ Base ./io.jl:328;  | [7] open;  | @ ./io.jl:328 [inlined];  | [8] read;  | @ ./io.jl:434 [inlined];  | [9] _include(mapexpr::Function, mod::Module, _path::String);  | @ Base ./loading.jl:1166;  | [10] include(mod::Module, _path::String);  | @ Base ./Base.jl:386;  | [11] include(x::String);  | @ Oceananigans.Advection ~/builds/tartarus-7/clima/oceananigans/src/Advection/Advection.jl:1;  | [12] top-level scope;  | @ ~/builds/tartarus-7/clima/oceananigans/src/Advection/Advection.jl:43;  | [13] include(mod::Module, _path::String);  | @ Base ./Base.jl:386;  | [14] include(x::String);  | @ Oceananigans ~/builds/tartarus-7/clima/oceananigans/src/Oceananigans.jl:1;  | [15] top-level scope;  | @ ~/builds/tartarus-7/clima/oceananigans/src/Oceananigans.jl:173;  | [16] i",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-904165134
https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-904165134:470,Performance,Load,LoadError,470,"There are some errors that occurred right away, and I copied one below. Is this because of something in this PR or because of the system perhaps?. ```. ERROR: The following 1 direct dependency failed to precompile:; --;  | ;  | Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09];  | ;  | Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /storage5/buildkite-agent/.julia-3746/compiled/v1.6/Oceananigans/jl_IfcPYz.;  | ERROR: LoadError: LoadError: SystemError: opening file ""/var/lib/buildkite-agent/builds/tartarus-7/clima/oceananigans/src/Advection/upwind_biased_first_order.jl"": No such file or directory;  | Stacktrace:;  | [1] systemerror(p::String, errno::Int32; extrainfo::Nothing);  | @ Base ./error.jl:168;  | [2] #systemerror#62;  | @ ./error.jl:167 [inlined];  | [3] systemerror;  | @ ./error.jl:167 [inlined];  | [4] open(fname::String; lock::Bool, read::Nothing, write::Nothing, create::Nothing, truncate::Nothing, append::Nothing);  | @ Base ./iostream.jl:293;  | [5] open;  | @ ./iostream.jl:282 [inlined];  | [6] open(f::Base.var""#326#327""{String}, args::String; kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}});  | @ Base ./io.jl:328;  | [7] open;  | @ ./io.jl:328 [inlined];  | [8] read;  | @ ./io.jl:434 [inlined];  | [9] _include(mapexpr::Function, mod::Module, _path::String);  | @ Base ./loading.jl:1166;  | [10] include(mod::Module, _path::String);  | @ Base ./Base.jl:386;  | [11] include(x::String);  | @ Oceananigans.Advection ~/builds/tartarus-7/clima/oceananigans/src/Advection/Advection.jl:1;  | [12] top-level scope;  | @ ~/builds/tartarus-7/clima/oceananigans/src/Advection/Advection.jl:43;  | [13] include(mod::Module, _path::String);  | @ Base ./Base.jl:386;  | [14] include(x::String);  | @ Oceananigans ~/builds/tartarus-7/clima/oceananigans/src/Oceananigans.jl:1;  | [15] top-level scope;  | @ ~/builds/tartarus-7/clima/oceananigans/src/Oceananigans.jl:173;  | [16] i",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-904165134
https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-904165134:1395,Performance,load,loading,1395,"julia-3746/compiled/v1.6/Oceananigans/jl_IfcPYz.;  | ERROR: LoadError: LoadError: SystemError: opening file ""/var/lib/buildkite-agent/builds/tartarus-7/clima/oceananigans/src/Advection/upwind_biased_first_order.jl"": No such file or directory;  | Stacktrace:;  | [1] systemerror(p::String, errno::Int32; extrainfo::Nothing);  | @ Base ./error.jl:168;  | [2] #systemerror#62;  | @ ./error.jl:167 [inlined];  | [3] systemerror;  | @ ./error.jl:167 [inlined];  | [4] open(fname::String; lock::Bool, read::Nothing, write::Nothing, create::Nothing, truncate::Nothing, append::Nothing);  | @ Base ./iostream.jl:293;  | [5] open;  | @ ./iostream.jl:282 [inlined];  | [6] open(f::Base.var""#326#327""{String}, args::String; kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}});  | @ Base ./io.jl:328;  | [7] open;  | @ ./io.jl:328 [inlined];  | [8] read;  | @ ./io.jl:434 [inlined];  | [9] _include(mapexpr::Function, mod::Module, _path::String);  | @ Base ./loading.jl:1166;  | [10] include(mod::Module, _path::String);  | @ Base ./Base.jl:386;  | [11] include(x::String);  | @ Oceananigans.Advection ~/builds/tartarus-7/clima/oceananigans/src/Advection/Advection.jl:1;  | [12] top-level scope;  | @ ~/builds/tartarus-7/clima/oceananigans/src/Advection/Advection.jl:43;  | [13] include(mod::Module, _path::String);  | @ Base ./Base.jl:386;  | [14] include(x::String);  | @ Oceananigans ~/builds/tartarus-7/clima/oceananigans/src/Oceananigans.jl:1;  | [15] top-level scope;  | @ ~/builds/tartarus-7/clima/oceananigans/src/Oceananigans.jl:173;  | [16] include;  | @ ./Base.jl:386 [inlined];  | [17] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing);  | @ Base ./loading.jl:1235;  | [18] top-level scope;  | @ none:1;  | [19] eval;  | @ ./boot.jl:360 [inlined];  | [20] eval(x::Expr);",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-904165134
https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-904165134:2273,Performance,load,loading,2273,"| [8] read;  | @ ./io.jl:434 [inlined];  | [9] _include(mapexpr::Function, mod::Module, _path::String);  | @ Base ./loading.jl:1166;  | [10] include(mod::Module, _path::String);  | @ Base ./Base.jl:386;  | [11] include(x::String);  | @ Oceananigans.Advection ~/builds/tartarus-7/clima/oceananigans/src/Advection/Advection.jl:1;  | [12] top-level scope;  | @ ~/builds/tartarus-7/clima/oceananigans/src/Advection/Advection.jl:43;  | [13] include(mod::Module, _path::String);  | @ Base ./Base.jl:386;  | [14] include(x::String);  | @ Oceananigans ~/builds/tartarus-7/clima/oceananigans/src/Oceananigans.jl:1;  | [15] top-level scope;  | @ ~/builds/tartarus-7/clima/oceananigans/src/Oceananigans.jl:173;  | [16] include;  | @ ./Base.jl:386 [inlined];  | [17] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing);  | @ Base ./loading.jl:1235;  | [18] top-level scope;  | @ none:1;  | [19] eval;  | @ ./boot.jl:360 [inlined];  | [20] eval(x::Expr);  | @ Base.MainInclude ./client.jl:446;  | [21] top-level scope;  | @ none:1;  | in expression starting at /var/lib/buildkite-agent/builds/tartarus-7/clima/oceananigans/src/Advection/Advection.jl:1;  | in expression starting at /var/lib/buildkite-agent/builds/tartarus-7/clima/oceananigans/src/Oceananigans.jl:1;  | Stacktrace:;  | [1] pkgerror(msg::String);  | @ Pkg.Types /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/Types.jl:55;  | [2] precompile(ctx::Pkg.Types.Context; internal_call::Bool, strict::Bool, kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}});  | @ Pkg.API /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:1265;  | [3] precompile;  | @ /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/Pkg/src/API.jl:921 [inlined];  | [4] #prec",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-904165134
https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-905751368:24,Testability,test,test,24,I think we should add a test.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-905751368
https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-905752031:129,Testability,test,test,129,Add the first order scheme to this list:. https://github.com/CliMA/Oceananigans.jl/blob/77e2d1c8b6418db7ac7b4f4d6de0e362107c0942/test/test_time_stepping.jl#L207-L212,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-905752031
https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-905788744:137,Testability,test,test,137,> Add the first order scheme to this list:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/77e2d1c8b6418db7ac7b4f4d6de0e362107c0942/test/test_time_stepping.jl#L207-L212. Good idea! I added it and pushed the change.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-905788744
https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-905790061:26,Testability,test,test,26,"> I think we should add a test. We have the figure included here that tests that it has the correct convergence, but I am happy to add another test as well. What did you have in mind?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-905790061
https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-905790061:70,Testability,test,tests,70,"> I think we should add a test. We have the figure included here that tests that it has the correct convergence, but I am happy to add another test as well. What did you have in mind?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-905790061
https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-905790061:143,Testability,test,test,143,"> I think we should add a test. We have the figure included here that tests that it has the correct convergence, but I am happy to add another test as well. What did you have in mind?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-905790061
https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-906092342:28,Testability,test,test,28,"> > I think we should add a test.; > ; > We have the figure included here that tests that it has the correct convergence, but I am happy to add another test as well. What did you have in mind?. Yes for sure! The convergence plots illustrates that _this PR_ is functional. The test is different: it ensures that the code doesn't break in the _future_, since PRs cannot be merged in the future unless the tests pass. Nice work!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-906092342
https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-906092342:79,Testability,test,tests,79,"> > I think we should add a test.; > ; > We have the figure included here that tests that it has the correct convergence, but I am happy to add another test as well. What did you have in mind?. Yes for sure! The convergence plots illustrates that _this PR_ is functional. The test is different: it ensures that the code doesn't break in the _future_, since PRs cannot be merged in the future unless the tests pass. Nice work!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-906092342
https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-906092342:152,Testability,test,test,152,"> > I think we should add a test.; > ; > We have the figure included here that tests that it has the correct convergence, but I am happy to add another test as well. What did you have in mind?. Yes for sure! The convergence plots illustrates that _this PR_ is functional. The test is different: it ensures that the code doesn't break in the _future_, since PRs cannot be merged in the future unless the tests pass. Nice work!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-906092342
https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-906092342:276,Testability,test,test,276,"> > I think we should add a test.; > ; > We have the figure included here that tests that it has the correct convergence, but I am happy to add another test as well. What did you have in mind?. Yes for sure! The convergence plots illustrates that _this PR_ is functional. The test is different: it ensures that the code doesn't break in the _future_, since PRs cannot be merged in the future unless the tests pass. Nice work!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-906092342
https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-906092342:403,Testability,test,tests,403,"> > I think we should add a test.; > ; > We have the figure included here that tests that it has the correct convergence, but I am happy to add another test as well. What did you have in mind?. Yes for sure! The convergence plots illustrates that _this PR_ is functional. The test is different: it ensures that the code doesn't break in the _future_, since PRs cannot be merged in the future unless the tests pass. Nice work!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-906092342
https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-906436595:53,Testability,test,test,53,"@glwagner : did you want me to create an issue for a test for a future PR or create a test in this PR? I looked around and besides the convergence tests, I don't know whether we have tests for other advection schemes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-906436595
https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-906436595:86,Testability,test,test,86,"@glwagner : did you want me to create an issue for a test for a future PR or create a test in this PR? I looked around and besides the convergence tests, I don't know whether we have tests for other advection schemes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-906436595
https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-906436595:147,Testability,test,tests,147,"@glwagner : did you want me to create an issue for a test for a future PR or create a test in this PR? I looked around and besides the convergence tests, I don't know whether we have tests for other advection schemes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-906436595
https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-906436595:183,Testability,test,tests,183,"@glwagner : did you want me to create an issue for a test for a future PR or create a test in this PR? I looked around and besides the convergence tests, I don't know whether we have tests for other advection schemes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-906436595
https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-906479795:21,Testability,test,test,21,"But you did create a test! . ![image](https://user-images.githubusercontent.com/15271942/130984674-6d2e83da-b89e-4aff-9976-852227954ae3.png). It ran too:. https://buildkite.com/clima/oceananigans/builds/3769#6acfa109-0499-43fb-af7d-a7ec3172e1d4/40-331. This doesn't test correctness of course --- that's what the convergence test does. So now we have a unit test that ensures the code _runs_ (executed every PR), and a convergence test that ensures the code is _correct_ (executed optionally when we need to revalidate). I'm happy, merge away!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-906479795
https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-906479795:266,Testability,test,test,266,"But you did create a test! . ![image](https://user-images.githubusercontent.com/15271942/130984674-6d2e83da-b89e-4aff-9976-852227954ae3.png). It ran too:. https://buildkite.com/clima/oceananigans/builds/3769#6acfa109-0499-43fb-af7d-a7ec3172e1d4/40-331. This doesn't test correctness of course --- that's what the convergence test does. So now we have a unit test that ensures the code _runs_ (executed every PR), and a convergence test that ensures the code is _correct_ (executed optionally when we need to revalidate). I'm happy, merge away!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-906479795
https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-906479795:325,Testability,test,test,325,"But you did create a test! . ![image](https://user-images.githubusercontent.com/15271942/130984674-6d2e83da-b89e-4aff-9976-852227954ae3.png). It ran too:. https://buildkite.com/clima/oceananigans/builds/3769#6acfa109-0499-43fb-af7d-a7ec3172e1d4/40-331. This doesn't test correctness of course --- that's what the convergence test does. So now we have a unit test that ensures the code _runs_ (executed every PR), and a convergence test that ensures the code is _correct_ (executed optionally when we need to revalidate). I'm happy, merge away!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-906479795
https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-906479795:358,Testability,test,test,358,"But you did create a test! . ![image](https://user-images.githubusercontent.com/15271942/130984674-6d2e83da-b89e-4aff-9976-852227954ae3.png). It ran too:. https://buildkite.com/clima/oceananigans/builds/3769#6acfa109-0499-43fb-af7d-a7ec3172e1d4/40-331. This doesn't test correctness of course --- that's what the convergence test does. So now we have a unit test that ensures the code _runs_ (executed every PR), and a convergence test that ensures the code is _correct_ (executed optionally when we need to revalidate). I'm happy, merge away!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-906479795
https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-906479795:431,Testability,test,test,431,"But you did create a test! . ![image](https://user-images.githubusercontent.com/15271942/130984674-6d2e83da-b89e-4aff-9976-852227954ae3.png). It ran too:. https://buildkite.com/clima/oceananigans/builds/3769#6acfa109-0499-43fb-af7d-a7ec3172e1d4/40-331. This doesn't test correctness of course --- that's what the convergence test does. So now we have a unit test that ensures the code _runs_ (executed every PR), and a convergence test that ensures the code is _correct_ (executed optionally when we need to revalidate). I'm happy, merge away!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1957#issuecomment-906479795
https://github.com/CliMA/Oceananigans.jl/pull/1959#issuecomment-904624745:14,Testability,test,tests,14,We should add tests that ensure this remains function a la #1937,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1959#issuecomment-904624745
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-904920702:8,Deployability,Configurat,Configuration,8,## try. Configuration problem:; bors.toml: not found,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-904920702
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-904920702:8,Modifiability,Config,Configuration,8,## try. Configuration problem:; bors.toml: not found,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-904920702
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-905859491:99,Modifiability,refactor,refactor,99,Yeah for sure we should add docs before merging. This PR may be open for a bit because I'd like to refactor the tests. Right now they take almost 2 hours on average which I feel is much too slow.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-905859491
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-905859491:112,Testability,test,tests,112,Yeah for sure we should add docs before merging. This PR may be open for a bit because I'd like to refactor the tests. Right now they take almost 2 hours on average which I feel is much too slow.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-905859491
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778:547,Availability,error,error,547,"@navidcy it shouldn't impact developer workflow too much. When going over the test structure with @glwagner on Tues. I suggested the following restructuring:. * Break-out ""quick"" unit-tests to be run by github actions under a single configuration (ex: linux, julia 1.6) and be able to run them in parallel. We have a ""Team"" account donated by Github so we can have tons of concurrent GitHub actions so this is beneficial if you can take advantage (might be limited by compilation costs). These tests will be run for every PR push and fast fail on error.; * `bors try` trigger a more expensive CI job to be submitted to the cluster, allowing for GPU / MPI tests. The logic here is that if the cpu tests are not working then the GPU tests almost certainly won't so you can get away with executing them less often. We have a daemon running on the cluster that synchronizes the jobs from buildkite with the local slurm controller, so every step in the buildkite config is submitted as a separate slurm job and canceling buildkite jobs kills them with slum. What is nice about that setup is you can tailor the resources used for each buildkite step just as you would slurm (ex. ""gres:1"" for 1 gpu). You can run jobs on multiple ranks, multiple GPU's, different resource limits, timeouts, etc. basically anything you can pass through to as a cli argument to a slurm batch job is supported. Also it's running on a cluster so obviously your job parallelism is very good.; * `bors r+` trigger merging the PR into `main` branch. This serializes the commits to `main` (and roll-up concurrent PR's to be submitted) so that all merge commits will pass the tests. This is an opportunity to also maybe run more expensive tests (it's easy in buildkite to conditionally run steps if running on `staging` branch) because you'll probably only run the staging CI step one or at most a few times at the very end,. the general strategy is to tier the tests so that they get progressively more expensive and to maximize ci-p",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778:233,Deployability,configurat,configuration,233,"@navidcy it shouldn't impact developer workflow too much. When going over the test structure with @glwagner on Tues. I suggested the following restructuring:. * Break-out ""quick"" unit-tests to be run by github actions under a single configuration (ex: linux, julia 1.6) and be able to run them in parallel. We have a ""Team"" account donated by Github so we can have tons of concurrent GitHub actions so this is beneficial if you can take advantage (might be limited by compilation costs). These tests will be run for every PR push and fast fail on error.; * `bors try` trigger a more expensive CI job to be submitted to the cluster, allowing for GPU / MPI tests. The logic here is that if the cpu tests are not working then the GPU tests almost certainly won't so you can get away with executing them less often. We have a daemon running on the cluster that synchronizes the jobs from buildkite with the local slurm controller, so every step in the buildkite config is submitted as a separate slurm job and canceling buildkite jobs kills them with slum. What is nice about that setup is you can tailor the resources used for each buildkite step just as you would slurm (ex. ""gres:1"" for 1 gpu). You can run jobs on multiple ranks, multiple GPU's, different resource limits, timeouts, etc. basically anything you can pass through to as a cli argument to a slurm batch job is supported. Also it's running on a cluster so obviously your job parallelism is very good.; * `bors r+` trigger merging the PR into `main` branch. This serializes the commits to `main` (and roll-up concurrent PR's to be submitted) so that all merge commits will pass the tests. This is an opportunity to also maybe run more expensive tests (it's easy in buildkite to conditionally run steps if running on `staging` branch) because you'll probably only run the staging CI step one or at most a few times at the very end,. the general strategy is to tier the tests so that they get progressively more expensive and to maximize ci-p",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778:2015,Energy Efficiency,reduce,reduce,2015,"tructuring:. * Break-out ""quick"" unit-tests to be run by github actions under a single configuration (ex: linux, julia 1.6) and be able to run them in parallel. We have a ""Team"" account donated by Github so we can have tons of concurrent GitHub actions so this is beneficial if you can take advantage (might be limited by compilation costs). These tests will be run for every PR push and fast fail on error.; * `bors try` trigger a more expensive CI job to be submitted to the cluster, allowing for GPU / MPI tests. The logic here is that if the cpu tests are not working then the GPU tests almost certainly won't so you can get away with executing them less often. We have a daemon running on the cluster that synchronizes the jobs from buildkite with the local slurm controller, so every step in the buildkite config is submitted as a separate slurm job and canceling buildkite jobs kills them with slum. What is nice about that setup is you can tailor the resources used for each buildkite step just as you would slurm (ex. ""gres:1"" for 1 gpu). You can run jobs on multiple ranks, multiple GPU's, different resource limits, timeouts, etc. basically anything you can pass through to as a cli argument to a slurm batch job is supported. Also it's running on a cluster so obviously your job parallelism is very good.; * `bors r+` trigger merging the PR into `main` branch. This serializes the commits to `main` (and roll-up concurrent PR's to be submitted) so that all merge commits will pass the tests. This is an opportunity to also maybe run more expensive tests (it's easy in buildkite to conditionally run steps if running on `staging` branch) because you'll probably only run the staging CI step one or at most a few times at the very end,. the general strategy is to tier the tests so that they get progressively more expensive and to maximize ci-parallelism to reduce the overall time. @glwagner can control who on the project can submit bors jobs by editing the bors access control settings.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778:857,Integrability,synchroniz,synchronizes,857,"@navidcy it shouldn't impact developer workflow too much. When going over the test structure with @glwagner on Tues. I suggested the following restructuring:. * Break-out ""quick"" unit-tests to be run by github actions under a single configuration (ex: linux, julia 1.6) and be able to run them in parallel. We have a ""Team"" account donated by Github so we can have tons of concurrent GitHub actions so this is beneficial if you can take advantage (might be limited by compilation costs). These tests will be run for every PR push and fast fail on error.; * `bors try` trigger a more expensive CI job to be submitted to the cluster, allowing for GPU / MPI tests. The logic here is that if the cpu tests are not working then the GPU tests almost certainly won't so you can get away with executing them less often. We have a daemon running on the cluster that synchronizes the jobs from buildkite with the local slurm controller, so every step in the buildkite config is submitted as a separate slurm job and canceling buildkite jobs kills them with slum. What is nice about that setup is you can tailor the resources used for each buildkite step just as you would slurm (ex. ""gres:1"" for 1 gpu). You can run jobs on multiple ranks, multiple GPU's, different resource limits, timeouts, etc. basically anything you can pass through to as a cli argument to a slurm batch job is supported. Also it's running on a cluster so obviously your job parallelism is very good.; * `bors r+` trigger merging the PR into `main` branch. This serializes the commits to `main` (and roll-up concurrent PR's to be submitted) so that all merge commits will pass the tests. This is an opportunity to also maybe run more expensive tests (it's easy in buildkite to conditionally run steps if running on `staging` branch) because you'll probably only run the staging CI step one or at most a few times at the very end,. the general strategy is to tier the tests so that they get progressively more expensive and to maximize ci-p",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778:233,Modifiability,config,configuration,233,"@navidcy it shouldn't impact developer workflow too much. When going over the test structure with @glwagner on Tues. I suggested the following restructuring:. * Break-out ""quick"" unit-tests to be run by github actions under a single configuration (ex: linux, julia 1.6) and be able to run them in parallel. We have a ""Team"" account donated by Github so we can have tons of concurrent GitHub actions so this is beneficial if you can take advantage (might be limited by compilation costs). These tests will be run for every PR push and fast fail on error.; * `bors try` trigger a more expensive CI job to be submitted to the cluster, allowing for GPU / MPI tests. The logic here is that if the cpu tests are not working then the GPU tests almost certainly won't so you can get away with executing them less often. We have a daemon running on the cluster that synchronizes the jobs from buildkite with the local slurm controller, so every step in the buildkite config is submitted as a separate slurm job and canceling buildkite jobs kills them with slum. What is nice about that setup is you can tailor the resources used for each buildkite step just as you would slurm (ex. ""gres:1"" for 1 gpu). You can run jobs on multiple ranks, multiple GPU's, different resource limits, timeouts, etc. basically anything you can pass through to as a cli argument to a slurm batch job is supported. Also it's running on a cluster so obviously your job parallelism is very good.; * `bors r+` trigger merging the PR into `main` branch. This serializes the commits to `main` (and roll-up concurrent PR's to be submitted) so that all merge commits will pass the tests. This is an opportunity to also maybe run more expensive tests (it's easy in buildkite to conditionally run steps if running on `staging` branch) because you'll probably only run the staging CI step one or at most a few times at the very end,. the general strategy is to tier the tests so that they get progressively more expensive and to maximize ci-p",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778:958,Modifiability,config,config,958,"@navidcy it shouldn't impact developer workflow too much. When going over the test structure with @glwagner on Tues. I suggested the following restructuring:. * Break-out ""quick"" unit-tests to be run by github actions under a single configuration (ex: linux, julia 1.6) and be able to run them in parallel. We have a ""Team"" account donated by Github so we can have tons of concurrent GitHub actions so this is beneficial if you can take advantage (might be limited by compilation costs). These tests will be run for every PR push and fast fail on error.; * `bors try` trigger a more expensive CI job to be submitted to the cluster, allowing for GPU / MPI tests. The logic here is that if the cpu tests are not working then the GPU tests almost certainly won't so you can get away with executing them less often. We have a daemon running on the cluster that synchronizes the jobs from buildkite with the local slurm controller, so every step in the buildkite config is submitted as a separate slurm job and canceling buildkite jobs kills them with slum. What is nice about that setup is you can tailor the resources used for each buildkite step just as you would slurm (ex. ""gres:1"" for 1 gpu). You can run jobs on multiple ranks, multiple GPU's, different resource limits, timeouts, etc. basically anything you can pass through to as a cli argument to a slurm batch job is supported. Also it's running on a cluster so obviously your job parallelism is very good.; * `bors r+` trigger merging the PR into `main` branch. This serializes the commits to `main` (and roll-up concurrent PR's to be submitted) so that all merge commits will pass the tests. This is an opportunity to also maybe run more expensive tests (it's easy in buildkite to conditionally run steps if running on `staging` branch) because you'll probably only run the staging CI step one or at most a few times at the very end,. the general strategy is to tier the tests so that they get progressively more expensive and to maximize ci-p",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778:373,Performance,concurren,concurrent,373,"@navidcy it shouldn't impact developer workflow too much. When going over the test structure with @glwagner on Tues. I suggested the following restructuring:. * Break-out ""quick"" unit-tests to be run by github actions under a single configuration (ex: linux, julia 1.6) and be able to run them in parallel. We have a ""Team"" account donated by Github so we can have tons of concurrent GitHub actions so this is beneficial if you can take advantage (might be limited by compilation costs). These tests will be run for every PR push and fast fail on error.; * `bors try` trigger a more expensive CI job to be submitted to the cluster, allowing for GPU / MPI tests. The logic here is that if the cpu tests are not working then the GPU tests almost certainly won't so you can get away with executing them less often. We have a daemon running on the cluster that synchronizes the jobs from buildkite with the local slurm controller, so every step in the buildkite config is submitted as a separate slurm job and canceling buildkite jobs kills them with slum. What is nice about that setup is you can tailor the resources used for each buildkite step just as you would slurm (ex. ""gres:1"" for 1 gpu). You can run jobs on multiple ranks, multiple GPU's, different resource limits, timeouts, etc. basically anything you can pass through to as a cli argument to a slurm batch job is supported. Also it's running on a cluster so obviously your job parallelism is very good.; * `bors r+` trigger merging the PR into `main` branch. This serializes the commits to `main` (and roll-up concurrent PR's to be submitted) so that all merge commits will pass the tests. This is an opportunity to also maybe run more expensive tests (it's easy in buildkite to conditionally run steps if running on `staging` branch) because you'll probably only run the staging CI step one or at most a few times at the very end,. the general strategy is to tier the tests so that they get progressively more expensive and to maximize ci-p",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778:1570,Performance,concurren,concurrent,1570,"tructuring:. * Break-out ""quick"" unit-tests to be run by github actions under a single configuration (ex: linux, julia 1.6) and be able to run them in parallel. We have a ""Team"" account donated by Github so we can have tons of concurrent GitHub actions so this is beneficial if you can take advantage (might be limited by compilation costs). These tests will be run for every PR push and fast fail on error.; * `bors try` trigger a more expensive CI job to be submitted to the cluster, allowing for GPU / MPI tests. The logic here is that if the cpu tests are not working then the GPU tests almost certainly won't so you can get away with executing them less often. We have a daemon running on the cluster that synchronizes the jobs from buildkite with the local slurm controller, so every step in the buildkite config is submitted as a separate slurm job and canceling buildkite jobs kills them with slum. What is nice about that setup is you can tailor the resources used for each buildkite step just as you would slurm (ex. ""gres:1"" for 1 gpu). You can run jobs on multiple ranks, multiple GPU's, different resource limits, timeouts, etc. basically anything you can pass through to as a cli argument to a slurm batch job is supported. Also it's running on a cluster so obviously your job parallelism is very good.; * `bors r+` trigger merging the PR into `main` branch. This serializes the commits to `main` (and roll-up concurrent PR's to be submitted) so that all merge commits will pass the tests. This is an opportunity to also maybe run more expensive tests (it's easy in buildkite to conditionally run steps if running on `staging` branch) because you'll probably only run the staging CI step one or at most a few times at the very end,. the general strategy is to tier the tests so that they get progressively more expensive and to maximize ci-parallelism to reduce the overall time. @glwagner can control who on the project can submit bors jobs by editing the bors access control settings.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778:1273,Safety,timeout,timeouts,1273,"tructuring:. * Break-out ""quick"" unit-tests to be run by github actions under a single configuration (ex: linux, julia 1.6) and be able to run them in parallel. We have a ""Team"" account donated by Github so we can have tons of concurrent GitHub actions so this is beneficial if you can take advantage (might be limited by compilation costs). These tests will be run for every PR push and fast fail on error.; * `bors try` trigger a more expensive CI job to be submitted to the cluster, allowing for GPU / MPI tests. The logic here is that if the cpu tests are not working then the GPU tests almost certainly won't so you can get away with executing them less often. We have a daemon running on the cluster that synchronizes the jobs from buildkite with the local slurm controller, so every step in the buildkite config is submitted as a separate slurm job and canceling buildkite jobs kills them with slum. What is nice about that setup is you can tailor the resources used for each buildkite step just as you would slurm (ex. ""gres:1"" for 1 gpu). You can run jobs on multiple ranks, multiple GPU's, different resource limits, timeouts, etc. basically anything you can pass through to as a cli argument to a slurm batch job is supported. Also it's running on a cluster so obviously your job parallelism is very good.; * `bors r+` trigger merging the PR into `main` branch. This serializes the commits to `main` (and roll-up concurrent PR's to be submitted) so that all merge commits will pass the tests. This is an opportunity to also maybe run more expensive tests (it's easy in buildkite to conditionally run steps if running on `staging` branch) because you'll probably only run the staging CI step one or at most a few times at the very end,. the general strategy is to tier the tests so that they get progressively more expensive and to maximize ci-parallelism to reduce the overall time. @glwagner can control who on the project can submit bors jobs by editing the bors access control settings.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778:2122,Security,access,access,2122,"tructuring:. * Break-out ""quick"" unit-tests to be run by github actions under a single configuration (ex: linux, julia 1.6) and be able to run them in parallel. We have a ""Team"" account donated by Github so we can have tons of concurrent GitHub actions so this is beneficial if you can take advantage (might be limited by compilation costs). These tests will be run for every PR push and fast fail on error.; * `bors try` trigger a more expensive CI job to be submitted to the cluster, allowing for GPU / MPI tests. The logic here is that if the cpu tests are not working then the GPU tests almost certainly won't so you can get away with executing them less often. We have a daemon running on the cluster that synchronizes the jobs from buildkite with the local slurm controller, so every step in the buildkite config is submitted as a separate slurm job and canceling buildkite jobs kills them with slum. What is nice about that setup is you can tailor the resources used for each buildkite step just as you would slurm (ex. ""gres:1"" for 1 gpu). You can run jobs on multiple ranks, multiple GPU's, different resource limits, timeouts, etc. basically anything you can pass through to as a cli argument to a slurm batch job is supported. Also it's running on a cluster so obviously your job parallelism is very good.; * `bors r+` trigger merging the PR into `main` branch. This serializes the commits to `main` (and roll-up concurrent PR's to be submitted) so that all merge commits will pass the tests. This is an opportunity to also maybe run more expensive tests (it's easy in buildkite to conditionally run steps if running on `staging` branch) because you'll probably only run the staging CI step one or at most a few times at the very end,. the general strategy is to tier the tests so that they get progressively more expensive and to maximize ci-parallelism to reduce the overall time. @glwagner can control who on the project can submit bors jobs by editing the bors access control settings.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778:78,Testability,test,test,78,"@navidcy it shouldn't impact developer workflow too much. When going over the test structure with @glwagner on Tues. I suggested the following restructuring:. * Break-out ""quick"" unit-tests to be run by github actions under a single configuration (ex: linux, julia 1.6) and be able to run them in parallel. We have a ""Team"" account donated by Github so we can have tons of concurrent GitHub actions so this is beneficial if you can take advantage (might be limited by compilation costs). These tests will be run for every PR push and fast fail on error.; * `bors try` trigger a more expensive CI job to be submitted to the cluster, allowing for GPU / MPI tests. The logic here is that if the cpu tests are not working then the GPU tests almost certainly won't so you can get away with executing them less often. We have a daemon running on the cluster that synchronizes the jobs from buildkite with the local slurm controller, so every step in the buildkite config is submitted as a separate slurm job and canceling buildkite jobs kills them with slum. What is nice about that setup is you can tailor the resources used for each buildkite step just as you would slurm (ex. ""gres:1"" for 1 gpu). You can run jobs on multiple ranks, multiple GPU's, different resource limits, timeouts, etc. basically anything you can pass through to as a cli argument to a slurm batch job is supported. Also it's running on a cluster so obviously your job parallelism is very good.; * `bors r+` trigger merging the PR into `main` branch. This serializes the commits to `main` (and roll-up concurrent PR's to be submitted) so that all merge commits will pass the tests. This is an opportunity to also maybe run more expensive tests (it's easy in buildkite to conditionally run steps if running on `staging` branch) because you'll probably only run the staging CI step one or at most a few times at the very end,. the general strategy is to tier the tests so that they get progressively more expensive and to maximize ci-p",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778:184,Testability,test,tests,184,"@navidcy it shouldn't impact developer workflow too much. When going over the test structure with @glwagner on Tues. I suggested the following restructuring:. * Break-out ""quick"" unit-tests to be run by github actions under a single configuration (ex: linux, julia 1.6) and be able to run them in parallel. We have a ""Team"" account donated by Github so we can have tons of concurrent GitHub actions so this is beneficial if you can take advantage (might be limited by compilation costs). These tests will be run for every PR push and fast fail on error.; * `bors try` trigger a more expensive CI job to be submitted to the cluster, allowing for GPU / MPI tests. The logic here is that if the cpu tests are not working then the GPU tests almost certainly won't so you can get away with executing them less often. We have a daemon running on the cluster that synchronizes the jobs from buildkite with the local slurm controller, so every step in the buildkite config is submitted as a separate slurm job and canceling buildkite jobs kills them with slum. What is nice about that setup is you can tailor the resources used for each buildkite step just as you would slurm (ex. ""gres:1"" for 1 gpu). You can run jobs on multiple ranks, multiple GPU's, different resource limits, timeouts, etc. basically anything you can pass through to as a cli argument to a slurm batch job is supported. Also it's running on a cluster so obviously your job parallelism is very good.; * `bors r+` trigger merging the PR into `main` branch. This serializes the commits to `main` (and roll-up concurrent PR's to be submitted) so that all merge commits will pass the tests. This is an opportunity to also maybe run more expensive tests (it's easy in buildkite to conditionally run steps if running on `staging` branch) because you'll probably only run the staging CI step one or at most a few times at the very end,. the general strategy is to tier the tests so that they get progressively more expensive and to maximize ci-p",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778:494,Testability,test,tests,494,"@navidcy it shouldn't impact developer workflow too much. When going over the test structure with @glwagner on Tues. I suggested the following restructuring:. * Break-out ""quick"" unit-tests to be run by github actions under a single configuration (ex: linux, julia 1.6) and be able to run them in parallel. We have a ""Team"" account donated by Github so we can have tons of concurrent GitHub actions so this is beneficial if you can take advantage (might be limited by compilation costs). These tests will be run for every PR push and fast fail on error.; * `bors try` trigger a more expensive CI job to be submitted to the cluster, allowing for GPU / MPI tests. The logic here is that if the cpu tests are not working then the GPU tests almost certainly won't so you can get away with executing them less often. We have a daemon running on the cluster that synchronizes the jobs from buildkite with the local slurm controller, so every step in the buildkite config is submitted as a separate slurm job and canceling buildkite jobs kills them with slum. What is nice about that setup is you can tailor the resources used for each buildkite step just as you would slurm (ex. ""gres:1"" for 1 gpu). You can run jobs on multiple ranks, multiple GPU's, different resource limits, timeouts, etc. basically anything you can pass through to as a cli argument to a slurm batch job is supported. Also it's running on a cluster so obviously your job parallelism is very good.; * `bors r+` trigger merging the PR into `main` branch. This serializes the commits to `main` (and roll-up concurrent PR's to be submitted) so that all merge commits will pass the tests. This is an opportunity to also maybe run more expensive tests (it's easy in buildkite to conditionally run steps if running on `staging` branch) because you'll probably only run the staging CI step one or at most a few times at the very end,. the general strategy is to tier the tests so that they get progressively more expensive and to maximize ci-p",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778:655,Testability,test,tests,655,"@navidcy it shouldn't impact developer workflow too much. When going over the test structure with @glwagner on Tues. I suggested the following restructuring:. * Break-out ""quick"" unit-tests to be run by github actions under a single configuration (ex: linux, julia 1.6) and be able to run them in parallel. We have a ""Team"" account donated by Github so we can have tons of concurrent GitHub actions so this is beneficial if you can take advantage (might be limited by compilation costs). These tests will be run for every PR push and fast fail on error.; * `bors try` trigger a more expensive CI job to be submitted to the cluster, allowing for GPU / MPI tests. The logic here is that if the cpu tests are not working then the GPU tests almost certainly won't so you can get away with executing them less often. We have a daemon running on the cluster that synchronizes the jobs from buildkite with the local slurm controller, so every step in the buildkite config is submitted as a separate slurm job and canceling buildkite jobs kills them with slum. What is nice about that setup is you can tailor the resources used for each buildkite step just as you would slurm (ex. ""gres:1"" for 1 gpu). You can run jobs on multiple ranks, multiple GPU's, different resource limits, timeouts, etc. basically anything you can pass through to as a cli argument to a slurm batch job is supported. Also it's running on a cluster so obviously your job parallelism is very good.; * `bors r+` trigger merging the PR into `main` branch. This serializes the commits to `main` (and roll-up concurrent PR's to be submitted) so that all merge commits will pass the tests. This is an opportunity to also maybe run more expensive tests (it's easy in buildkite to conditionally run steps if running on `staging` branch) because you'll probably only run the staging CI step one or at most a few times at the very end,. the general strategy is to tier the tests so that they get progressively more expensive and to maximize ci-p",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778:666,Testability,log,logic,666,"@navidcy it shouldn't impact developer workflow too much. When going over the test structure with @glwagner on Tues. I suggested the following restructuring:. * Break-out ""quick"" unit-tests to be run by github actions under a single configuration (ex: linux, julia 1.6) and be able to run them in parallel. We have a ""Team"" account donated by Github so we can have tons of concurrent GitHub actions so this is beneficial if you can take advantage (might be limited by compilation costs). These tests will be run for every PR push and fast fail on error.; * `bors try` trigger a more expensive CI job to be submitted to the cluster, allowing for GPU / MPI tests. The logic here is that if the cpu tests are not working then the GPU tests almost certainly won't so you can get away with executing them less often. We have a daemon running on the cluster that synchronizes the jobs from buildkite with the local slurm controller, so every step in the buildkite config is submitted as a separate slurm job and canceling buildkite jobs kills them with slum. What is nice about that setup is you can tailor the resources used for each buildkite step just as you would slurm (ex. ""gres:1"" for 1 gpu). You can run jobs on multiple ranks, multiple GPU's, different resource limits, timeouts, etc. basically anything you can pass through to as a cli argument to a slurm batch job is supported. Also it's running on a cluster so obviously your job parallelism is very good.; * `bors r+` trigger merging the PR into `main` branch. This serializes the commits to `main` (and roll-up concurrent PR's to be submitted) so that all merge commits will pass the tests. This is an opportunity to also maybe run more expensive tests (it's easy in buildkite to conditionally run steps if running on `staging` branch) because you'll probably only run the staging CI step one or at most a few times at the very end,. the general strategy is to tier the tests so that they get progressively more expensive and to maximize ci-p",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778:696,Testability,test,tests,696,"@navidcy it shouldn't impact developer workflow too much. When going over the test structure with @glwagner on Tues. I suggested the following restructuring:. * Break-out ""quick"" unit-tests to be run by github actions under a single configuration (ex: linux, julia 1.6) and be able to run them in parallel. We have a ""Team"" account donated by Github so we can have tons of concurrent GitHub actions so this is beneficial if you can take advantage (might be limited by compilation costs). These tests will be run for every PR push and fast fail on error.; * `bors try` trigger a more expensive CI job to be submitted to the cluster, allowing for GPU / MPI tests. The logic here is that if the cpu tests are not working then the GPU tests almost certainly won't so you can get away with executing them less often. We have a daemon running on the cluster that synchronizes the jobs from buildkite with the local slurm controller, so every step in the buildkite config is submitted as a separate slurm job and canceling buildkite jobs kills them with slum. What is nice about that setup is you can tailor the resources used for each buildkite step just as you would slurm (ex. ""gres:1"" for 1 gpu). You can run jobs on multiple ranks, multiple GPU's, different resource limits, timeouts, etc. basically anything you can pass through to as a cli argument to a slurm batch job is supported. Also it's running on a cluster so obviously your job parallelism is very good.; * `bors r+` trigger merging the PR into `main` branch. This serializes the commits to `main` (and roll-up concurrent PR's to be submitted) so that all merge commits will pass the tests. This is an opportunity to also maybe run more expensive tests (it's easy in buildkite to conditionally run steps if running on `staging` branch) because you'll probably only run the staging CI step one or at most a few times at the very end,. the general strategy is to tier the tests so that they get progressively more expensive and to maximize ci-p",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778:731,Testability,test,tests,731,"@navidcy it shouldn't impact developer workflow too much. When going over the test structure with @glwagner on Tues. I suggested the following restructuring:. * Break-out ""quick"" unit-tests to be run by github actions under a single configuration (ex: linux, julia 1.6) and be able to run them in parallel. We have a ""Team"" account donated by Github so we can have tons of concurrent GitHub actions so this is beneficial if you can take advantage (might be limited by compilation costs). These tests will be run for every PR push and fast fail on error.; * `bors try` trigger a more expensive CI job to be submitted to the cluster, allowing for GPU / MPI tests. The logic here is that if the cpu tests are not working then the GPU tests almost certainly won't so you can get away with executing them less often. We have a daemon running on the cluster that synchronizes the jobs from buildkite with the local slurm controller, so every step in the buildkite config is submitted as a separate slurm job and canceling buildkite jobs kills them with slum. What is nice about that setup is you can tailor the resources used for each buildkite step just as you would slurm (ex. ""gres:1"" for 1 gpu). You can run jobs on multiple ranks, multiple GPU's, different resource limits, timeouts, etc. basically anything you can pass through to as a cli argument to a slurm batch job is supported. Also it's running on a cluster so obviously your job parallelism is very good.; * `bors r+` trigger merging the PR into `main` branch. This serializes the commits to `main` (and roll-up concurrent PR's to be submitted) so that all merge commits will pass the tests. This is an opportunity to also maybe run more expensive tests (it's easy in buildkite to conditionally run steps if running on `staging` branch) because you'll probably only run the staging CI step one or at most a few times at the very end,. the general strategy is to tier the tests so that they get progressively more expensive and to maximize ci-p",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778:1643,Testability,test,tests,1643,"tructuring:. * Break-out ""quick"" unit-tests to be run by github actions under a single configuration (ex: linux, julia 1.6) and be able to run them in parallel. We have a ""Team"" account donated by Github so we can have tons of concurrent GitHub actions so this is beneficial if you can take advantage (might be limited by compilation costs). These tests will be run for every PR push and fast fail on error.; * `bors try` trigger a more expensive CI job to be submitted to the cluster, allowing for GPU / MPI tests. The logic here is that if the cpu tests are not working then the GPU tests almost certainly won't so you can get away with executing them less often. We have a daemon running on the cluster that synchronizes the jobs from buildkite with the local slurm controller, so every step in the buildkite config is submitted as a separate slurm job and canceling buildkite jobs kills them with slum. What is nice about that setup is you can tailor the resources used for each buildkite step just as you would slurm (ex. ""gres:1"" for 1 gpu). You can run jobs on multiple ranks, multiple GPU's, different resource limits, timeouts, etc. basically anything you can pass through to as a cli argument to a slurm batch job is supported. Also it's running on a cluster so obviously your job parallelism is very good.; * `bors r+` trigger merging the PR into `main` branch. This serializes the commits to `main` (and roll-up concurrent PR's to be submitted) so that all merge commits will pass the tests. This is an opportunity to also maybe run more expensive tests (it's easy in buildkite to conditionally run steps if running on `staging` branch) because you'll probably only run the staging CI step one or at most a few times at the very end,. the general strategy is to tier the tests so that they get progressively more expensive and to maximize ci-parallelism to reduce the overall time. @glwagner can control who on the project can submit bors jobs by editing the bors access control settings.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778:1706,Testability,test,tests,1706,"tructuring:. * Break-out ""quick"" unit-tests to be run by github actions under a single configuration (ex: linux, julia 1.6) and be able to run them in parallel. We have a ""Team"" account donated by Github so we can have tons of concurrent GitHub actions so this is beneficial if you can take advantage (might be limited by compilation costs). These tests will be run for every PR push and fast fail on error.; * `bors try` trigger a more expensive CI job to be submitted to the cluster, allowing for GPU / MPI tests. The logic here is that if the cpu tests are not working then the GPU tests almost certainly won't so you can get away with executing them less often. We have a daemon running on the cluster that synchronizes the jobs from buildkite with the local slurm controller, so every step in the buildkite config is submitted as a separate slurm job and canceling buildkite jobs kills them with slum. What is nice about that setup is you can tailor the resources used for each buildkite step just as you would slurm (ex. ""gres:1"" for 1 gpu). You can run jobs on multiple ranks, multiple GPU's, different resource limits, timeouts, etc. basically anything you can pass through to as a cli argument to a slurm batch job is supported. Also it's running on a cluster so obviously your job parallelism is very good.; * `bors r+` trigger merging the PR into `main` branch. This serializes the commits to `main` (and roll-up concurrent PR's to be submitted) so that all merge commits will pass the tests. This is an opportunity to also maybe run more expensive tests (it's easy in buildkite to conditionally run steps if running on `staging` branch) because you'll probably only run the staging CI step one or at most a few times at the very end,. the general strategy is to tier the tests so that they get progressively more expensive and to maximize ci-parallelism to reduce the overall time. @glwagner can control who on the project can submit bors jobs by editing the bors access control settings.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778:1929,Testability,test,tests,1929,"tructuring:. * Break-out ""quick"" unit-tests to be run by github actions under a single configuration (ex: linux, julia 1.6) and be able to run them in parallel. We have a ""Team"" account donated by Github so we can have tons of concurrent GitHub actions so this is beneficial if you can take advantage (might be limited by compilation costs). These tests will be run for every PR push and fast fail on error.; * `bors try` trigger a more expensive CI job to be submitted to the cluster, allowing for GPU / MPI tests. The logic here is that if the cpu tests are not working then the GPU tests almost certainly won't so you can get away with executing them less often. We have a daemon running on the cluster that synchronizes the jobs from buildkite with the local slurm controller, so every step in the buildkite config is submitted as a separate slurm job and canceling buildkite jobs kills them with slum. What is nice about that setup is you can tailor the resources used for each buildkite step just as you would slurm (ex. ""gres:1"" for 1 gpu). You can run jobs on multiple ranks, multiple GPU's, different resource limits, timeouts, etc. basically anything you can pass through to as a cli argument to a slurm batch job is supported. Also it's running on a cluster so obviously your job parallelism is very good.; * `bors r+` trigger merging the PR into `main` branch. This serializes the commits to `main` (and roll-up concurrent PR's to be submitted) so that all merge commits will pass the tests. This is an opportunity to also maybe run more expensive tests (it's easy in buildkite to conditionally run steps if running on `staging` branch) because you'll probably only run the staging CI step one or at most a few times at the very end,. the general strategy is to tier the tests so that they get progressively more expensive and to maximize ci-parallelism to reduce the overall time. @glwagner can control who on the project can submit bors jobs by editing the bors access control settings.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444:83,Deployability,integrat,integration,83,"@jakebolewski I'm wondering what you think about the strategy of running a few key integration tests via GitHub actions, in addition perhaps to unit tests that have low compilation costs. For example, we have a couple ""regression tests"" that ensure the output of a simulation is identical to one run previously. These regression tests are imprecise (we only know that something has changed, but can't identify exactly what it is), but nevertheless catch both obvious API bugs and subtle numerics bugs incurred by refactoring. Another nice feature is that regression tests invoke (or are supposed to invoke) configurations that are most common / most valuable to users. They are also relatively cheap since we load states from a file and run for 10-100 time-steps at modest resolutions, and there are a small number of them which mitigates compilation cost. When I undertake a major refactor I often find myself running regression tests first. Testing corner cases and/or catching bugs associated with interactions between model components in less-frequently used configurations requires more extensive testing (a combinatorial explosion of cases...) and incurs heavier compilation costs; so these are probably better tested via `bors try`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444:607,Deployability,configurat,configurations,607,"@jakebolewski I'm wondering what you think about the strategy of running a few key integration tests via GitHub actions, in addition perhaps to unit tests that have low compilation costs. For example, we have a couple ""regression tests"" that ensure the output of a simulation is identical to one run previously. These regression tests are imprecise (we only know that something has changed, but can't identify exactly what it is), but nevertheless catch both obvious API bugs and subtle numerics bugs incurred by refactoring. Another nice feature is that regression tests invoke (or are supposed to invoke) configurations that are most common / most valuable to users. They are also relatively cheap since we load states from a file and run for 10-100 time-steps at modest resolutions, and there are a small number of them which mitigates compilation cost. When I undertake a major refactor I often find myself running regression tests first. Testing corner cases and/or catching bugs associated with interactions between model components in less-frequently used configurations requires more extensive testing (a combinatorial explosion of cases...) and incurs heavier compilation costs; so these are probably better tested via `bors try`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444:1063,Deployability,configurat,configurations,1063,"@jakebolewski I'm wondering what you think about the strategy of running a few key integration tests via GitHub actions, in addition perhaps to unit tests that have low compilation costs. For example, we have a couple ""regression tests"" that ensure the output of a simulation is identical to one run previously. These regression tests are imprecise (we only know that something has changed, but can't identify exactly what it is), but nevertheless catch both obvious API bugs and subtle numerics bugs incurred by refactoring. Another nice feature is that regression tests invoke (or are supposed to invoke) configurations that are most common / most valuable to users. They are also relatively cheap since we load states from a file and run for 10-100 time-steps at modest resolutions, and there are a small number of them which mitigates compilation cost. When I undertake a major refactor I often find myself running regression tests first. Testing corner cases and/or catching bugs associated with interactions between model components in less-frequently used configurations requires more extensive testing (a combinatorial explosion of cases...) and incurs heavier compilation costs; so these are probably better tested via `bors try`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444:83,Integrability,integrat,integration,83,"@jakebolewski I'm wondering what you think about the strategy of running a few key integration tests via GitHub actions, in addition perhaps to unit tests that have low compilation costs. For example, we have a couple ""regression tests"" that ensure the output of a simulation is identical to one run previously. These regression tests are imprecise (we only know that something has changed, but can't identify exactly what it is), but nevertheless catch both obvious API bugs and subtle numerics bugs incurred by refactoring. Another nice feature is that regression tests invoke (or are supposed to invoke) configurations that are most common / most valuable to users. They are also relatively cheap since we load states from a file and run for 10-100 time-steps at modest resolutions, and there are a small number of them which mitigates compilation cost. When I undertake a major refactor I often find myself running regression tests first. Testing corner cases and/or catching bugs associated with interactions between model components in less-frequently used configurations requires more extensive testing (a combinatorial explosion of cases...) and incurs heavier compilation costs; so these are probably better tested via `bors try`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444:513,Modifiability,refactor,refactoring,513,"@jakebolewski I'm wondering what you think about the strategy of running a few key integration tests via GitHub actions, in addition perhaps to unit tests that have low compilation costs. For example, we have a couple ""regression tests"" that ensure the output of a simulation is identical to one run previously. These regression tests are imprecise (we only know that something has changed, but can't identify exactly what it is), but nevertheless catch both obvious API bugs and subtle numerics bugs incurred by refactoring. Another nice feature is that regression tests invoke (or are supposed to invoke) configurations that are most common / most valuable to users. They are also relatively cheap since we load states from a file and run for 10-100 time-steps at modest resolutions, and there are a small number of them which mitigates compilation cost. When I undertake a major refactor I often find myself running regression tests first. Testing corner cases and/or catching bugs associated with interactions between model components in less-frequently used configurations requires more extensive testing (a combinatorial explosion of cases...) and incurs heavier compilation costs; so these are probably better tested via `bors try`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444:607,Modifiability,config,configurations,607,"@jakebolewski I'm wondering what you think about the strategy of running a few key integration tests via GitHub actions, in addition perhaps to unit tests that have low compilation costs. For example, we have a couple ""regression tests"" that ensure the output of a simulation is identical to one run previously. These regression tests are imprecise (we only know that something has changed, but can't identify exactly what it is), but nevertheless catch both obvious API bugs and subtle numerics bugs incurred by refactoring. Another nice feature is that regression tests invoke (or are supposed to invoke) configurations that are most common / most valuable to users. They are also relatively cheap since we load states from a file and run for 10-100 time-steps at modest resolutions, and there are a small number of them which mitigates compilation cost. When I undertake a major refactor I often find myself running regression tests first. Testing corner cases and/or catching bugs associated with interactions between model components in less-frequently used configurations requires more extensive testing (a combinatorial explosion of cases...) and incurs heavier compilation costs; so these are probably better tested via `bors try`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444:882,Modifiability,refactor,refactor,882,"@jakebolewski I'm wondering what you think about the strategy of running a few key integration tests via GitHub actions, in addition perhaps to unit tests that have low compilation costs. For example, we have a couple ""regression tests"" that ensure the output of a simulation is identical to one run previously. These regression tests are imprecise (we only know that something has changed, but can't identify exactly what it is), but nevertheless catch both obvious API bugs and subtle numerics bugs incurred by refactoring. Another nice feature is that regression tests invoke (or are supposed to invoke) configurations that are most common / most valuable to users. They are also relatively cheap since we load states from a file and run for 10-100 time-steps at modest resolutions, and there are a small number of them which mitigates compilation cost. When I undertake a major refactor I often find myself running regression tests first. Testing corner cases and/or catching bugs associated with interactions between model components in less-frequently used configurations requires more extensive testing (a combinatorial explosion of cases...) and incurs heavier compilation costs; so these are probably better tested via `bors try`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444:1063,Modifiability,config,configurations,1063,"@jakebolewski I'm wondering what you think about the strategy of running a few key integration tests via GitHub actions, in addition perhaps to unit tests that have low compilation costs. For example, we have a couple ""regression tests"" that ensure the output of a simulation is identical to one run previously. These regression tests are imprecise (we only know that something has changed, but can't identify exactly what it is), but nevertheless catch both obvious API bugs and subtle numerics bugs incurred by refactoring. Another nice feature is that regression tests invoke (or are supposed to invoke) configurations that are most common / most valuable to users. They are also relatively cheap since we load states from a file and run for 10-100 time-steps at modest resolutions, and there are a small number of them which mitigates compilation cost. When I undertake a major refactor I often find myself running regression tests first. Testing corner cases and/or catching bugs associated with interactions between model components in less-frequently used configurations requires more extensive testing (a combinatorial explosion of cases...) and incurs heavier compilation costs; so these are probably better tested via `bors try`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444:709,Performance,load,load,709,"@jakebolewski I'm wondering what you think about the strategy of running a few key integration tests via GitHub actions, in addition perhaps to unit tests that have low compilation costs. For example, we have a couple ""regression tests"" that ensure the output of a simulation is identical to one run previously. These regression tests are imprecise (we only know that something has changed, but can't identify exactly what it is), but nevertheless catch both obvious API bugs and subtle numerics bugs incurred by refactoring. Another nice feature is that regression tests invoke (or are supposed to invoke) configurations that are most common / most valuable to users. They are also relatively cheap since we load states from a file and run for 10-100 time-steps at modest resolutions, and there are a small number of them which mitigates compilation cost. When I undertake a major refactor I often find myself running regression tests first. Testing corner cases and/or catching bugs associated with interactions between model components in less-frequently used configurations requires more extensive testing (a combinatorial explosion of cases...) and incurs heavier compilation costs; so these are probably better tested via `bors try`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444:95,Testability,test,tests,95,"@jakebolewski I'm wondering what you think about the strategy of running a few key integration tests via GitHub actions, in addition perhaps to unit tests that have low compilation costs. For example, we have a couple ""regression tests"" that ensure the output of a simulation is identical to one run previously. These regression tests are imprecise (we only know that something has changed, but can't identify exactly what it is), but nevertheless catch both obvious API bugs and subtle numerics bugs incurred by refactoring. Another nice feature is that regression tests invoke (or are supposed to invoke) configurations that are most common / most valuable to users. They are also relatively cheap since we load states from a file and run for 10-100 time-steps at modest resolutions, and there are a small number of them which mitigates compilation cost. When I undertake a major refactor I often find myself running regression tests first. Testing corner cases and/or catching bugs associated with interactions between model components in less-frequently used configurations requires more extensive testing (a combinatorial explosion of cases...) and incurs heavier compilation costs; so these are probably better tested via `bors try`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444:149,Testability,test,tests,149,"@jakebolewski I'm wondering what you think about the strategy of running a few key integration tests via GitHub actions, in addition perhaps to unit tests that have low compilation costs. For example, we have a couple ""regression tests"" that ensure the output of a simulation is identical to one run previously. These regression tests are imprecise (we only know that something has changed, but can't identify exactly what it is), but nevertheless catch both obvious API bugs and subtle numerics bugs incurred by refactoring. Another nice feature is that regression tests invoke (or are supposed to invoke) configurations that are most common / most valuable to users. They are also relatively cheap since we load states from a file and run for 10-100 time-steps at modest resolutions, and there are a small number of them which mitigates compilation cost. When I undertake a major refactor I often find myself running regression tests first. Testing corner cases and/or catching bugs associated with interactions between model components in less-frequently used configurations requires more extensive testing (a combinatorial explosion of cases...) and incurs heavier compilation costs; so these are probably better tested via `bors try`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444:230,Testability,test,tests,230,"@jakebolewski I'm wondering what you think about the strategy of running a few key integration tests via GitHub actions, in addition perhaps to unit tests that have low compilation costs. For example, we have a couple ""regression tests"" that ensure the output of a simulation is identical to one run previously. These regression tests are imprecise (we only know that something has changed, but can't identify exactly what it is), but nevertheless catch both obvious API bugs and subtle numerics bugs incurred by refactoring. Another nice feature is that regression tests invoke (or are supposed to invoke) configurations that are most common / most valuable to users. They are also relatively cheap since we load states from a file and run for 10-100 time-steps at modest resolutions, and there are a small number of them which mitigates compilation cost. When I undertake a major refactor I often find myself running regression tests first. Testing corner cases and/or catching bugs associated with interactions between model components in less-frequently used configurations requires more extensive testing (a combinatorial explosion of cases...) and incurs heavier compilation costs; so these are probably better tested via `bors try`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444:329,Testability,test,tests,329,"@jakebolewski I'm wondering what you think about the strategy of running a few key integration tests via GitHub actions, in addition perhaps to unit tests that have low compilation costs. For example, we have a couple ""regression tests"" that ensure the output of a simulation is identical to one run previously. These regression tests are imprecise (we only know that something has changed, but can't identify exactly what it is), but nevertheless catch both obvious API bugs and subtle numerics bugs incurred by refactoring. Another nice feature is that regression tests invoke (or are supposed to invoke) configurations that are most common / most valuable to users. They are also relatively cheap since we load states from a file and run for 10-100 time-steps at modest resolutions, and there are a small number of them which mitigates compilation cost. When I undertake a major refactor I often find myself running regression tests first. Testing corner cases and/or catching bugs associated with interactions between model components in less-frequently used configurations requires more extensive testing (a combinatorial explosion of cases...) and incurs heavier compilation costs; so these are probably better tested via `bors try`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444:566,Testability,test,tests,566,"@jakebolewski I'm wondering what you think about the strategy of running a few key integration tests via GitHub actions, in addition perhaps to unit tests that have low compilation costs. For example, we have a couple ""regression tests"" that ensure the output of a simulation is identical to one run previously. These regression tests are imprecise (we only know that something has changed, but can't identify exactly what it is), but nevertheless catch both obvious API bugs and subtle numerics bugs incurred by refactoring. Another nice feature is that regression tests invoke (or are supposed to invoke) configurations that are most common / most valuable to users. They are also relatively cheap since we load states from a file and run for 10-100 time-steps at modest resolutions, and there are a small number of them which mitigates compilation cost. When I undertake a major refactor I often find myself running regression tests first. Testing corner cases and/or catching bugs associated with interactions between model components in less-frequently used configurations requires more extensive testing (a combinatorial explosion of cases...) and incurs heavier compilation costs; so these are probably better tested via `bors try`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444:930,Testability,test,tests,930,"@jakebolewski I'm wondering what you think about the strategy of running a few key integration tests via GitHub actions, in addition perhaps to unit tests that have low compilation costs. For example, we have a couple ""regression tests"" that ensure the output of a simulation is identical to one run previously. These regression tests are imprecise (we only know that something has changed, but can't identify exactly what it is), but nevertheless catch both obvious API bugs and subtle numerics bugs incurred by refactoring. Another nice feature is that regression tests invoke (or are supposed to invoke) configurations that are most common / most valuable to users. They are also relatively cheap since we load states from a file and run for 10-100 time-steps at modest resolutions, and there are a small number of them which mitigates compilation cost. When I undertake a major refactor I often find myself running regression tests first. Testing corner cases and/or catching bugs associated with interactions between model components in less-frequently used configurations requires more extensive testing (a combinatorial explosion of cases...) and incurs heavier compilation costs; so these are probably better tested via `bors try`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444:943,Testability,Test,Testing,943,"@jakebolewski I'm wondering what you think about the strategy of running a few key integration tests via GitHub actions, in addition perhaps to unit tests that have low compilation costs. For example, we have a couple ""regression tests"" that ensure the output of a simulation is identical to one run previously. These regression tests are imprecise (we only know that something has changed, but can't identify exactly what it is), but nevertheless catch both obvious API bugs and subtle numerics bugs incurred by refactoring. Another nice feature is that regression tests invoke (or are supposed to invoke) configurations that are most common / most valuable to users. They are also relatively cheap since we load states from a file and run for 10-100 time-steps at modest resolutions, and there are a small number of them which mitigates compilation cost. When I undertake a major refactor I often find myself running regression tests first. Testing corner cases and/or catching bugs associated with interactions between model components in less-frequently used configurations requires more extensive testing (a combinatorial explosion of cases...) and incurs heavier compilation costs; so these are probably better tested via `bors try`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444:1102,Testability,test,testing,1102,"@jakebolewski I'm wondering what you think about the strategy of running a few key integration tests via GitHub actions, in addition perhaps to unit tests that have low compilation costs. For example, we have a couple ""regression tests"" that ensure the output of a simulation is identical to one run previously. These regression tests are imprecise (we only know that something has changed, but can't identify exactly what it is), but nevertheless catch both obvious API bugs and subtle numerics bugs incurred by refactoring. Another nice feature is that regression tests invoke (or are supposed to invoke) configurations that are most common / most valuable to users. They are also relatively cheap since we load states from a file and run for 10-100 time-steps at modest resolutions, and there are a small number of them which mitigates compilation cost. When I undertake a major refactor I often find myself running regression tests first. Testing corner cases and/or catching bugs associated with interactions between model components in less-frequently used configurations requires more extensive testing (a combinatorial explosion of cases...) and incurs heavier compilation costs; so these are probably better tested via `bors try`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444:1217,Testability,test,tested,1217,"@jakebolewski I'm wondering what you think about the strategy of running a few key integration tests via GitHub actions, in addition perhaps to unit tests that have low compilation costs. For example, we have a couple ""regression tests"" that ensure the output of a simulation is identical to one run previously. These regression tests are imprecise (we only know that something has changed, but can't identify exactly what it is), but nevertheless catch both obvious API bugs and subtle numerics bugs incurred by refactoring. Another nice feature is that regression tests invoke (or are supposed to invoke) configurations that are most common / most valuable to users. They are also relatively cheap since we load states from a file and run for 10-100 time-steps at modest resolutions, and there are a small number of them which mitigates compilation cost. When I undertake a major refactor I often find myself running regression tests first. Testing corner cases and/or catching bugs associated with interactions between model components in less-frequently used configurations requires more extensive testing (a combinatorial explosion of cases...) and incurs heavier compilation costs; so these are probably better tested via `bors try`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906584759:116,Availability,error,errors,116,"@glwagner that sounds like a good strategy, ideally you would want to front-load the most useful tests for catching errors to the degree possible (the whole goal here is to reduce iteration time). If using Linux we can have up to 60 concurrent actions going so spawning as many as is useful for reducing the iteration time is the correct strategy (probably you could set this up as a job matrix for compactness). If spawning up a ton of github actions you can maximize concurrency by killing stale jobs (old push commits) as we do here: https://github.com/CliMA/ClimaCore.jl/blob/main/.github/workflows/Linux-UnitTests.yml#L24",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906584759
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906584759:173,Energy Efficiency,reduce,reduce,173,"@glwagner that sounds like a good strategy, ideally you would want to front-load the most useful tests for catching errors to the degree possible (the whole goal here is to reduce iteration time). If using Linux we can have up to 60 concurrent actions going so spawning as many as is useful for reducing the iteration time is the correct strategy (probably you could set this up as a job matrix for compactness). If spawning up a ton of github actions you can maximize concurrency by killing stale jobs (old push commits) as we do here: https://github.com/CliMA/ClimaCore.jl/blob/main/.github/workflows/Linux-UnitTests.yml#L24",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906584759
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906584759:76,Performance,load,load,76,"@glwagner that sounds like a good strategy, ideally you would want to front-load the most useful tests for catching errors to the degree possible (the whole goal here is to reduce iteration time). If using Linux we can have up to 60 concurrent actions going so spawning as many as is useful for reducing the iteration time is the correct strategy (probably you could set this up as a job matrix for compactness). If spawning up a ton of github actions you can maximize concurrency by killing stale jobs (old push commits) as we do here: https://github.com/CliMA/ClimaCore.jl/blob/main/.github/workflows/Linux-UnitTests.yml#L24",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906584759
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906584759:233,Performance,concurren,concurrent,233,"@glwagner that sounds like a good strategy, ideally you would want to front-load the most useful tests for catching errors to the degree possible (the whole goal here is to reduce iteration time). If using Linux we can have up to 60 concurrent actions going so spawning as many as is useful for reducing the iteration time is the correct strategy (probably you could set this up as a job matrix for compactness). If spawning up a ton of github actions you can maximize concurrency by killing stale jobs (old push commits) as we do here: https://github.com/CliMA/ClimaCore.jl/blob/main/.github/workflows/Linux-UnitTests.yml#L24",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906584759
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906584759:469,Performance,concurren,concurrency,469,"@glwagner that sounds like a good strategy, ideally you would want to front-load the most useful tests for catching errors to the degree possible (the whole goal here is to reduce iteration time). If using Linux we can have up to 60 concurrent actions going so spawning as many as is useful for reducing the iteration time is the correct strategy (probably you could set this up as a job matrix for compactness). If spawning up a ton of github actions you can maximize concurrency by killing stale jobs (old push commits) as we do here: https://github.com/CliMA/ClimaCore.jl/blob/main/.github/workflows/Linux-UnitTests.yml#L24",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906584759
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906584759:97,Testability,test,tests,97,"@glwagner that sounds like a good strategy, ideally you would want to front-load the most useful tests for catching errors to the degree possible (the whole goal here is to reduce iteration time). If using Linux we can have up to 60 concurrent actions going so spawning as many as is useful for reducing the iteration time is the correct strategy (probably you could set this up as a job matrix for compactness). If spawning up a ton of github actions you can maximize concurrency by killing stale jobs (old push commits) as we do here: https://github.com/CliMA/ClimaCore.jl/blob/main/.github/workflows/Linux-UnitTests.yml#L24",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906584759
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906712815:154,Availability,avail,available,154,"@glwagner CUDA aware MPI is supported for 11.2 but it is only built against OpenMPI 4.1.0 and 4.1.1, I think we had previously 4.0.4. Also julia 1.6.2 is available.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906712815
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906714103:27,Performance,race condition,race conditions,27,looks like maybe some more race conditions on different hardware?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906714103
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906751484:156,Availability,avail,available,156,"> @glwagner CUDA aware MPI is supported for 11.2 but it is only built against OpenMPI 4.1.0 and 4.1.1, I think we had previously 4.0.4. Also julia 1.6.2 is available. good beta, I'll upgrade, thanks!. > looks like maybe some more race conditions on different hardware?. Heh yeah, pretty interesting. sverdrup is running on Quadro P6000 with CUDA 11; tartarus (where we sometimes run tests for development) has a Titan V, also I think with CUDA 11. These are running on a P100? With this new CI I'll need to make sure I can log in to central to debug.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906751484
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906751484:183,Deployability,upgrade,upgrade,183,"> @glwagner CUDA aware MPI is supported for 11.2 but it is only built against OpenMPI 4.1.0 and 4.1.1, I think we had previously 4.0.4. Also julia 1.6.2 is available. good beta, I'll upgrade, thanks!. > looks like maybe some more race conditions on different hardware?. Heh yeah, pretty interesting. sverdrup is running on Quadro P6000 with CUDA 11; tartarus (where we sometimes run tests for development) has a Titan V, also I think with CUDA 11. These are running on a P100? With this new CI I'll need to make sure I can log in to central to debug.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906751484
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906751484:230,Performance,race condition,race conditions,230,"> @glwagner CUDA aware MPI is supported for 11.2 but it is only built against OpenMPI 4.1.0 and 4.1.1, I think we had previously 4.0.4. Also julia 1.6.2 is available. good beta, I'll upgrade, thanks!. > looks like maybe some more race conditions on different hardware?. Heh yeah, pretty interesting. sverdrup is running on Quadro P6000 with CUDA 11; tartarus (where we sometimes run tests for development) has a Titan V, also I think with CUDA 11. These are running on a P100? With this new CI I'll need to make sure I can log in to central to debug.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906751484
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906751484:383,Testability,test,tests,383,"> @glwagner CUDA aware MPI is supported for 11.2 but it is only built against OpenMPI 4.1.0 and 4.1.1, I think we had previously 4.0.4. Also julia 1.6.2 is available. good beta, I'll upgrade, thanks!. > looks like maybe some more race conditions on different hardware?. Heh yeah, pretty interesting. sverdrup is running on Quadro P6000 with CUDA 11; tartarus (where we sometimes run tests for development) has a Titan V, also I think with CUDA 11. These are running on a P100? With this new CI I'll need to make sure I can log in to central to debug.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906751484
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906751484:523,Testability,log,log,523,"> @glwagner CUDA aware MPI is supported for 11.2 but it is only built against OpenMPI 4.1.0 and 4.1.1, I think we had previously 4.0.4. Also julia 1.6.2 is available. good beta, I'll upgrade, thanks!. > looks like maybe some more race conditions on different hardware?. Heh yeah, pretty interesting. sverdrup is running on Quadro P6000 with CUDA 11; tartarus (where we sometimes run tests for development) has a Titan V, also I think with CUDA 11. These are running on a P100? With this new CI I'll need to make sure I can log in to central to debug.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906751484
https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906765232:12,Modifiability,config,config,12,for the GPU config you can see the hardware it is being run on here:; https://buildkite.com/clima/oceananigans-central/builds/8#5ef96bf8-7b5f-47d3-84fd-726b4cb3fc33/9-11,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906765232
https://github.com/CliMA/Oceananigans.jl/issues/1965#issuecomment-906451914:598,Integrability,depend,dependent,598,"The argument `dims` indicates what dimensions to average over, where (1=x, 2=y, 3=z). So. ```julia; T_avg = AveragedField(model.tracers.T, dims=(1, 2)); ```. builds a field representing the _horizontal_ averaged of `model.tracers.T` over x and y (dimensions 1 and 2). `data` is an optional field that can be used to supply the underlying data for the `AveragedField` (useful if memory allocations are being carefully managed). `recompute_safely` is relevant only when `AveragedField` are used in other computations. In that case, the `AveragedField` will always be recomputed before computing it's dependent operation if `recompute_safely` is true. Otherwise, the `status` of `AveragedField` is checked and recompution is ""avoided"" when it seems safe to do so.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1965#issuecomment-906451914
https://github.com/CliMA/Oceananigans.jl/issues/1965#issuecomment-906451914:723,Safety,avoid,avoided,723,"The argument `dims` indicates what dimensions to average over, where (1=x, 2=y, 3=z). So. ```julia; T_avg = AveragedField(model.tracers.T, dims=(1, 2)); ```. builds a field representing the _horizontal_ averaged of `model.tracers.T` over x and y (dimensions 1 and 2). `data` is an optional field that can be used to supply the underlying data for the `AveragedField` (useful if memory allocations are being carefully managed). `recompute_safely` is relevant only when `AveragedField` are used in other computations. In that case, the `AveragedField` will always be recomputed before computing it's dependent operation if `recompute_safely` is true. Otherwise, the `status` of `AveragedField` is checked and recompution is ""avoided"" when it seems safe to do so.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1965#issuecomment-906451914
https://github.com/CliMA/Oceananigans.jl/issues/1965#issuecomment-906451914:746,Safety,safe,safe,746,"The argument `dims` indicates what dimensions to average over, where (1=x, 2=y, 3=z). So. ```julia; T_avg = AveragedField(model.tracers.T, dims=(1, 2)); ```. builds a field representing the _horizontal_ averaged of `model.tracers.T` over x and y (dimensions 1 and 2). `data` is an optional field that can be used to supply the underlying data for the `AveragedField` (useful if memory allocations are being carefully managed). `recompute_safely` is relevant only when `AveragedField` are used in other computations. In that case, the `AveragedField` will always be recomputed before computing it's dependent operation if `recompute_safely` is true. Otherwise, the `status` of `AveragedField` is checked and recompution is ""avoided"" when it seems safe to do so.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1965#issuecomment-906451914
https://github.com/CliMA/Oceananigans.jl/issues/1968#issuecomment-906604350:100,Availability,ERROR,ERROR,100,"Currently users get the more obscure `MethodError`:. ```julia; julia> fill_halo_regions!(, CPU()); ERROR: MethodError: no method matching fill_west_halo!(::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ::Oceananigans.BoundaryConditions.DefaultPrognosticFieldBoundaryCondition, ::CPU, ::KernelAbstractions.NoneEvent, ::ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1968#issuecomment-906604350
https://github.com/CliMA/Oceananigans.jl/issues/1968#issuecomment-1100254368:3,Security,validat,validate,3,We validate boundary conditions now!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1968#issuecomment-1100254368
https://github.com/CliMA/Oceananigans.jl/pull/1970#issuecomment-909450347:209,Availability,mask,masking,209,"Quick question: in what situations would this be needed? I've never used that function but from what I understand it's only used in immersed boundaries to force quantities to a certain value, no? But wouldn't masking something to `nan` propagate throughout the whole domain?. Unless maybe you wanna mask it to `nan` specifically to make sure it's not propagating outside of your immersed boundary?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1970#issuecomment-909450347
https://github.com/CliMA/Oceananigans.jl/pull/1970#issuecomment-909450347:299,Availability,mask,mask,299,"Quick question: in what situations would this be needed? I've never used that function but from what I understand it's only used in immersed boundaries to force quantities to a certain value, no? But wouldn't masking something to `nan` propagate throughout the whole domain?. Unless maybe you wanna mask it to `nan` specifically to make sure it's not propagating outside of your immersed boundary?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1970#issuecomment-909450347
https://github.com/CliMA/Oceananigans.jl/pull/1970#issuecomment-909480517:211,Availability,mask,masking,211,"> Quick question: in what situations would this be needed? I've never used that function but from what I understand it's only used in immersed boundaries to force quantities to a certain value, no? But wouldn't masking something to `nan` propagate throughout the whole domain?; > ; > Unless maybe you wanna mask it to `nan` specifically to make sure it's not propagating outside of your immersed boundary?. I think it's useful in user scripts for plotting purposes, mainly. But not useful in the source code as you point out.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1970#issuecomment-909480517
https://github.com/CliMA/Oceananigans.jl/pull/1970#issuecomment-909480517:307,Availability,mask,mask,307,"> Quick question: in what situations would this be needed? I've never used that function but from what I understand it's only used in immersed boundaries to force quantities to a certain value, no? But wouldn't masking something to `nan` propagate throughout the whole domain?; > ; > Unless maybe you wanna mask it to `nan` specifically to make sure it's not propagating outside of your immersed boundary?. I think it's useful in user scripts for plotting purposes, mainly. But not useful in the source code as you point out.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1970#issuecomment-909480517
https://github.com/CliMA/Oceananigans.jl/pull/1971#issuecomment-917318770:38,Testability,test,test,38,hm... shall I have a look? seems like test are failing?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1971#issuecomment-917318770
https://github.com/CliMA/Oceananigans.jl/pull/1971#issuecomment-917619883:40,Testability,test,test,40,> hm... shall I have a look? seems like test are failing?. I think the tests are failing because of some detail about how the simulations are stopped / time-step is aligned at the end of a run --- the overall design can be reviewed!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1971#issuecomment-917619883
https://github.com/CliMA/Oceananigans.jl/pull/1971#issuecomment-917619883:71,Testability,test,tests,71,> hm... shall I have a look? seems like test are failing?. I think the tests are failing because of some detail about how the simulations are stopped / time-step is aligned at the end of a run --- the overall design can be reviewed!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1971#issuecomment-917619883
https://github.com/CliMA/Oceananigans.jl/issues/1972#issuecomment-916410470:28,Modifiability,parameteriz,parameterization,28,The difference between this parameterization and the currently implemented `TwoDimensionalLeith` parameterization is that the diffusivities are user-provided rather than being a 3D field that's computed from the vorticity and divergence. That's why this parameterization is actually a simplification of `TwoDimensionalLeith`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1972#issuecomment-916410470
https://github.com/CliMA/Oceananigans.jl/issues/1972#issuecomment-916410470:97,Modifiability,parameteriz,parameterization,97,The difference between this parameterization and the currently implemented `TwoDimensionalLeith` parameterization is that the diffusivities are user-provided rather than being a 3D field that's computed from the vorticity and divergence. That's why this parameterization is actually a simplification of `TwoDimensionalLeith`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1972#issuecomment-916410470
https://github.com/CliMA/Oceananigans.jl/issues/1972#issuecomment-916410470:254,Modifiability,parameteriz,parameterization,254,The difference between this parameterization and the currently implemented `TwoDimensionalLeith` parameterization is that the diffusivities are user-provided rather than being a 3D field that's computed from the vorticity and divergence. That's why this parameterization is actually a simplification of `TwoDimensionalLeith`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1972#issuecomment-916410470
https://github.com/CliMA/Oceananigans.jl/issues/1972#issuecomment-916410470:285,Usability,simpl,simplification,285,The difference between this parameterization and the currently implemented `TwoDimensionalLeith` parameterization is that the diffusivities are user-provided rather than being a 3D field that's computed from the vorticity and divergence. That's why this parameterization is actually a simplification of `TwoDimensionalLeith`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1972#issuecomment-916410470
https://github.com/CliMA/Oceananigans.jl/issues/1974#issuecomment-917622445:135,Energy Efficiency,meter,meters,135,"Oh yeah right... Well, I don't know any ""good reference"". I've seen some people use an ad-hoc ""boundary layer depth"" of few tenth's of meters. In isopycnal coordinates (e.g. mom6) one uses the depth of the bottom layer, or an average of the fluid layers within e.g. 10 meters.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1974#issuecomment-917622445
https://github.com/CliMA/Oceananigans.jl/issues/1974#issuecomment-917622445:269,Energy Efficiency,meter,meters,269,"Oh yeah right... Well, I don't know any ""good reference"". I've seen some people use an ad-hoc ""boundary layer depth"" of few tenth's of meters. In isopycnal coordinates (e.g. mom6) one uses the depth of the bottom layer, or an average of the fluid layers within e.g. 10 meters.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1974#issuecomment-917622445
https://github.com/CliMA/Oceananigans.jl/issues/1974#issuecomment-917622445:247,Modifiability,layers,layers,247,"Oh yeah right... Well, I don't know any ""good reference"". I've seen some people use an ad-hoc ""boundary layer depth"" of few tenth's of meters. In isopycnal coordinates (e.g. mom6) one uses the depth of the bottom layer, or an average of the fluid layers within e.g. 10 meters.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1974#issuecomment-917622445
https://github.com/CliMA/Oceananigans.jl/issues/1980#issuecomment-918738850:139,Usability,simpl,simple,139,"@francispoulin you are in principle correct!. However, without the equality in the criterion, me and @glwagner were trying to setup a very simple, idealized example with linear background stratification and somehow the convective adjectment started working in the bottom of the ocean (!!) because the criterion was precisely zero there. This is the ""unphysical situation"" that @glwagner is referring to -- perhaps he can elaborate a bit more?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1980#issuecomment-918738850
https://github.com/CliMA/Oceananigans.jl/issues/1980#issuecomment-918755890:147,Usability,simpl,simple,147,"> @francispoulin you are in principle correct!; > ; > However, without the equality in the criterion, me and @glwagner were trying to setup a very simple, idealized example with linear background stratification and somehow the convective adjectment started working in the bottom of the ocean (!!) because the criterion was precisely zero there. This is the ""unphysical situation"" that @glwagner is referring to -- perhaps he can elaborate a bit more?. Interesting... I wouldn't think this would be a problem (although I definitely see how it can be). I'd be curious to see some animations of this if you have them ready. (Just out of curiosity; no need to post them if it'll take work...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1980#issuecomment-918755890
https://github.com/CliMA/Oceananigans.jl/issues/1980#issuecomment-919448746:220,Integrability,interface,interface,220,"There's another limitation of the current scheme that's worth mentioning. The scheme currently precomputes the 3D diffusivity / viscosity field at cell centers, which means that a cell is ""unstable"" if _either_ vertical interface has a negative buoyancy gradient. But what we really want to do is precompute _stability_ (or the buoyancy gradient), which is more naturally located at vertical cell interfaces. This provides the tracer diffusivity directly; the momentum diffusivity can be calculated by checking the stability of two neighboring regions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1980#issuecomment-919448746
https://github.com/CliMA/Oceananigans.jl/issues/1980#issuecomment-919448746:397,Integrability,interface,interfaces,397,"There's another limitation of the current scheme that's worth mentioning. The scheme currently precomputes the 3D diffusivity / viscosity field at cell centers, which means that a cell is ""unstable"" if _either_ vertical interface has a negative buoyancy gradient. But what we really want to do is precompute _stability_ (or the buoyancy gradient), which is more naturally located at vertical cell interfaces. This provides the tracer diffusivity directly; the momentum diffusivity can be calculated by checking the stability of two neighboring regions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1980#issuecomment-919448746
https://github.com/CliMA/Oceananigans.jl/issues/1981#issuecomment-918194547:669,Deployability,update,updated,669,"@ilyascfd welcome and thanks for opening this issue, it's very helpful!. The problem here is that `Value` is not exported by default when we write `using Oceananigans` anymore. As a result, these lines:. https://github.com/CliMA/Oceananigans.jl/blob/ff19b7e0d328557dc198eb23349db5eed0680c65/validation/stratified_couette_flow/stratified_couette_flow.jl#L103-L110. do not work. . The recommended syntax nowadays is, for example,. ```; bc = ValueBoundaryCondition(0); ```. rather than `BoundaryCondition(Value, 0)`. This change was made to avoid name conflicts with some common names in the Julia ecosystem (like `Flux`). But, it looks like the validation script was not updated when this change was made to our exported names. I opened a PR to fix it in #1982. You can fix the script yourself as well by replacing `BoundaryCondition(Value, ` with `ValueBoundaryCondition(`. PS @ilyascfd here are a few tips for writing issues that will help us solve your problem as fast as possible; * Include links to the lines that are failing so we don't have to look for them ourselves. Github is really handy for this!; * When including code in an issue, please format it with triple backticks (```). Note: we run this script during CI, so at first I was surprised that we hadn't caught this yet. But when we run the tests, we do indeed import `Oceananigans.BoundaryConditions.Value` via. https://github.com/CliMA/Oceananigans.jl/blob/ff19b7e0d328557dc198eb23349db5eed0680c65/test/runtests.jl#L20. and. https://github.com/CliMA/Oceananigans.jl/blob/ff19b7e0d328557dc198eb23349db5eed0680c65/src/BoundaryConditions/BoundaryConditions.jl#L3-L4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1981#issuecomment-918194547
https://github.com/CliMA/Oceananigans.jl/issues/1981#issuecomment-918194547:538,Safety,avoid,avoid,538,"@ilyascfd welcome and thanks for opening this issue, it's very helpful!. The problem here is that `Value` is not exported by default when we write `using Oceananigans` anymore. As a result, these lines:. https://github.com/CliMA/Oceananigans.jl/blob/ff19b7e0d328557dc198eb23349db5eed0680c65/validation/stratified_couette_flow/stratified_couette_flow.jl#L103-L110. do not work. . The recommended syntax nowadays is, for example,. ```; bc = ValueBoundaryCondition(0); ```. rather than `BoundaryCondition(Value, 0)`. This change was made to avoid name conflicts with some common names in the Julia ecosystem (like `Flux`). But, it looks like the validation script was not updated when this change was made to our exported names. I opened a PR to fix it in #1982. You can fix the script yourself as well by replacing `BoundaryCondition(Value, ` with `ValueBoundaryCondition(`. PS @ilyascfd here are a few tips for writing issues that will help us solve your problem as fast as possible; * Include links to the lines that are failing so we don't have to look for them ourselves. Github is really handy for this!; * When including code in an issue, please format it with triple backticks (```). Note: we run this script during CI, so at first I was surprised that we hadn't caught this yet. But when we run the tests, we do indeed import `Oceananigans.BoundaryConditions.Value` via. https://github.com/CliMA/Oceananigans.jl/blob/ff19b7e0d328557dc198eb23349db5eed0680c65/test/runtests.jl#L20. and. https://github.com/CliMA/Oceananigans.jl/blob/ff19b7e0d328557dc198eb23349db5eed0680c65/src/BoundaryConditions/BoundaryConditions.jl#L3-L4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1981#issuecomment-918194547
https://github.com/CliMA/Oceananigans.jl/issues/1981#issuecomment-918194547:291,Security,validat,validation,291,"@ilyascfd welcome and thanks for opening this issue, it's very helpful!. The problem here is that `Value` is not exported by default when we write `using Oceananigans` anymore. As a result, these lines:. https://github.com/CliMA/Oceananigans.jl/blob/ff19b7e0d328557dc198eb23349db5eed0680c65/validation/stratified_couette_flow/stratified_couette_flow.jl#L103-L110. do not work. . The recommended syntax nowadays is, for example,. ```; bc = ValueBoundaryCondition(0); ```. rather than `BoundaryCondition(Value, 0)`. This change was made to avoid name conflicts with some common names in the Julia ecosystem (like `Flux`). But, it looks like the validation script was not updated when this change was made to our exported names. I opened a PR to fix it in #1982. You can fix the script yourself as well by replacing `BoundaryCondition(Value, ` with `ValueBoundaryCondition(`. PS @ilyascfd here are a few tips for writing issues that will help us solve your problem as fast as possible; * Include links to the lines that are failing so we don't have to look for them ourselves. Github is really handy for this!; * When including code in an issue, please format it with triple backticks (```). Note: we run this script during CI, so at first I was surprised that we hadn't caught this yet. But when we run the tests, we do indeed import `Oceananigans.BoundaryConditions.Value` via. https://github.com/CliMA/Oceananigans.jl/blob/ff19b7e0d328557dc198eb23349db5eed0680c65/test/runtests.jl#L20. and. https://github.com/CliMA/Oceananigans.jl/blob/ff19b7e0d328557dc198eb23349db5eed0680c65/src/BoundaryConditions/BoundaryConditions.jl#L3-L4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1981#issuecomment-918194547
https://github.com/CliMA/Oceananigans.jl/issues/1981#issuecomment-918194547:643,Security,validat,validation,643,"@ilyascfd welcome and thanks for opening this issue, it's very helpful!. The problem here is that `Value` is not exported by default when we write `using Oceananigans` anymore. As a result, these lines:. https://github.com/CliMA/Oceananigans.jl/blob/ff19b7e0d328557dc198eb23349db5eed0680c65/validation/stratified_couette_flow/stratified_couette_flow.jl#L103-L110. do not work. . The recommended syntax nowadays is, for example,. ```; bc = ValueBoundaryCondition(0); ```. rather than `BoundaryCondition(Value, 0)`. This change was made to avoid name conflicts with some common names in the Julia ecosystem (like `Flux`). But, it looks like the validation script was not updated when this change was made to our exported names. I opened a PR to fix it in #1982. You can fix the script yourself as well by replacing `BoundaryCondition(Value, ` with `ValueBoundaryCondition(`. PS @ilyascfd here are a few tips for writing issues that will help us solve your problem as fast as possible; * Include links to the lines that are failing so we don't have to look for them ourselves. Github is really handy for this!; * When including code in an issue, please format it with triple backticks (```). Note: we run this script during CI, so at first I was surprised that we hadn't caught this yet. But when we run the tests, we do indeed import `Oceananigans.BoundaryConditions.Value` via. https://github.com/CliMA/Oceananigans.jl/blob/ff19b7e0d328557dc198eb23349db5eed0680c65/test/runtests.jl#L20. and. https://github.com/CliMA/Oceananigans.jl/blob/ff19b7e0d328557dc198eb23349db5eed0680c65/src/BoundaryConditions/BoundaryConditions.jl#L3-L4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1981#issuecomment-918194547
https://github.com/CliMA/Oceananigans.jl/issues/1981#issuecomment-918194547:1305,Testability,test,tests,1305,"@ilyascfd welcome and thanks for opening this issue, it's very helpful!. The problem here is that `Value` is not exported by default when we write `using Oceananigans` anymore. As a result, these lines:. https://github.com/CliMA/Oceananigans.jl/blob/ff19b7e0d328557dc198eb23349db5eed0680c65/validation/stratified_couette_flow/stratified_couette_flow.jl#L103-L110. do not work. . The recommended syntax nowadays is, for example,. ```; bc = ValueBoundaryCondition(0); ```. rather than `BoundaryCondition(Value, 0)`. This change was made to avoid name conflicts with some common names in the Julia ecosystem (like `Flux`). But, it looks like the validation script was not updated when this change was made to our exported names. I opened a PR to fix it in #1982. You can fix the script yourself as well by replacing `BoundaryCondition(Value, ` with `ValueBoundaryCondition(`. PS @ilyascfd here are a few tips for writing issues that will help us solve your problem as fast as possible; * Include links to the lines that are failing so we don't have to look for them ourselves. Github is really handy for this!; * When including code in an issue, please format it with triple backticks (```). Note: we run this script during CI, so at first I was surprised that we hadn't caught this yet. But when we run the tests, we do indeed import `Oceananigans.BoundaryConditions.Value` via. https://github.com/CliMA/Oceananigans.jl/blob/ff19b7e0d328557dc198eb23349db5eed0680c65/test/runtests.jl#L20. and. https://github.com/CliMA/Oceananigans.jl/blob/ff19b7e0d328557dc198eb23349db5eed0680c65/src/BoundaryConditions/BoundaryConditions.jl#L3-L4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1981#issuecomment-918194547
https://github.com/CliMA/Oceananigans.jl/issues/1981#issuecomment-918194547:1464,Testability,test,test,1464,"@ilyascfd welcome and thanks for opening this issue, it's very helpful!. The problem here is that `Value` is not exported by default when we write `using Oceananigans` anymore. As a result, these lines:. https://github.com/CliMA/Oceananigans.jl/blob/ff19b7e0d328557dc198eb23349db5eed0680c65/validation/stratified_couette_flow/stratified_couette_flow.jl#L103-L110. do not work. . The recommended syntax nowadays is, for example,. ```; bc = ValueBoundaryCondition(0); ```. rather than `BoundaryCondition(Value, 0)`. This change was made to avoid name conflicts with some common names in the Julia ecosystem (like `Flux`). But, it looks like the validation script was not updated when this change was made to our exported names. I opened a PR to fix it in #1982. You can fix the script yourself as well by replacing `BoundaryCondition(Value, ` with `ValueBoundaryCondition(`. PS @ilyascfd here are a few tips for writing issues that will help us solve your problem as fast as possible; * Include links to the lines that are failing so we don't have to look for them ourselves. Github is really handy for this!; * When including code in an issue, please format it with triple backticks (```). Note: we run this script during CI, so at first I was surprised that we hadn't caught this yet. But when we run the tests, we do indeed import `Oceananigans.BoundaryConditions.Value` via. https://github.com/CliMA/Oceananigans.jl/blob/ff19b7e0d328557dc198eb23349db5eed0680c65/test/runtests.jl#L20. and. https://github.com/CliMA/Oceananigans.jl/blob/ff19b7e0d328557dc198eb23349db5eed0680c65/src/BoundaryConditions/BoundaryConditions.jl#L3-L4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1981#issuecomment-918194547
https://github.com/CliMA/Oceananigans.jl/pull/1983#issuecomment-918420217:0,Deployability,Patch,Patch,0,Patch/minor release?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1983#issuecomment-918420217
https://github.com/CliMA/Oceananigans.jl/pull/1983#issuecomment-918420217:12,Deployability,release,release,12,Patch/minor release?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1983#issuecomment-918420217
https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-920113136:88,Performance,race condition,race condition,88,> Testing with validation/mesoscale/baroclinic_adjustment.jl seems to indicate that the race condition is eliminated from the changes to the fill_halo_region! function. Was there a race condition there?. Could you please point to the relevant issue describing the condition just for completeness?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-920113136
https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-920113136:181,Performance,race condition,race condition,181,> Testing with validation/mesoscale/baroclinic_adjustment.jl seems to indicate that the race condition is eliminated from the changes to the fill_halo_region! function. Was there a race condition there?. Could you please point to the relevant issue describing the condition just for completeness?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-920113136
https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-920113136:15,Security,validat,validation,15,> Testing with validation/mesoscale/baroclinic_adjustment.jl seems to indicate that the race condition is eliminated from the changes to the fill_halo_region! function. Was there a race condition there?. Could you please point to the relevant issue describing the condition just for completeness?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-920113136
https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-920113136:2,Testability,Test,Testing,2,> Testing with validation/mesoscale/baroclinic_adjustment.jl seems to indicate that the race condition is eliminated from the changes to the fill_halo_region! function. Was there a race condition there?. Could you please point to the relevant issue describing the condition just for completeness?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-920113136
https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-920473363:33,Deployability,update,update,33,"The issue was that, prior to the update the fill_halo_region! function, the test in validation/mesoscale/baroclinic_adjustment.jl , which in particular, uses the hydrostatic model with an explicit free surface, would produce different answers when run twice after several thousand timesteps. This typically happens when there is a race condition in the code and this particular one was hard to find since it occurs only after several timesteps have occurred. The reason for ""potential"" in the title of the PR is that I do not understand why this race condition exists in the first place, since I have not seen this in any other Oceananigans model, including Hydrostatic + Implicit Free Surface or the NonHydrostatic Model",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-920473363
https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-920473363:331,Performance,race condition,race condition,331,"The issue was that, prior to the update the fill_halo_region! function, the test in validation/mesoscale/baroclinic_adjustment.jl , which in particular, uses the hydrostatic model with an explicit free surface, would produce different answers when run twice after several thousand timesteps. This typically happens when there is a race condition in the code and this particular one was hard to find since it occurs only after several timesteps have occurred. The reason for ""potential"" in the title of the PR is that I do not understand why this race condition exists in the first place, since I have not seen this in any other Oceananigans model, including Hydrostatic + Implicit Free Surface or the NonHydrostatic Model",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-920473363
https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-920473363:546,Performance,race condition,race condition,546,"The issue was that, prior to the update the fill_halo_region! function, the test in validation/mesoscale/baroclinic_adjustment.jl , which in particular, uses the hydrostatic model with an explicit free surface, would produce different answers when run twice after several thousand timesteps. This typically happens when there is a race condition in the code and this particular one was hard to find since it occurs only after several timesteps have occurred. The reason for ""potential"" in the title of the PR is that I do not understand why this race condition exists in the first place, since I have not seen this in any other Oceananigans model, including Hydrostatic + Implicit Free Surface or the NonHydrostatic Model",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-920473363
https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-920473363:84,Security,validat,validation,84,"The issue was that, prior to the update the fill_halo_region! function, the test in validation/mesoscale/baroclinic_adjustment.jl , which in particular, uses the hydrostatic model with an explicit free surface, would produce different answers when run twice after several thousand timesteps. This typically happens when there is a race condition in the code and this particular one was hard to find since it occurs only after several timesteps have occurred. The reason for ""potential"" in the title of the PR is that I do not understand why this race condition exists in the first place, since I have not seen this in any other Oceananigans model, including Hydrostatic + Implicit Free Surface or the NonHydrostatic Model",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-920473363
https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-920473363:76,Testability,test,test,76,"The issue was that, prior to the update the fill_halo_region! function, the test in validation/mesoscale/baroclinic_adjustment.jl , which in particular, uses the hydrostatic model with an explicit free surface, would produce different answers when run twice after several thousand timesteps. This typically happens when there is a race condition in the code and this particular one was hard to find since it occurs only after several timesteps have occurred. The reason for ""potential"" in the title of the PR is that I do not understand why this race condition exists in the first place, since I have not seen this in any other Oceananigans model, including Hydrostatic + Implicit Free Surface or the NonHydrostatic Model",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-920473363
https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-921143865:1860,Availability,error,errors,1860,"ce to provide but I can describe the problem as I've seen it. Basically, very rare, subtle irregularities have been observed on the GPU when using `HydrostaticFreeSurfaceModel` in a `Periodic, Bounded, Bounded` configuration. I think that it is possible the main issue is an interaction (a read-write race condition) associated with both impenetrable boundary conditions and periodic boundary conditions that affects the 8 corner points. The race condition affects model trajectories via the Coriolis force (which is the only term as far as I know that touches the 8 ""corner"" points affected by this race condition). Because the race condition only manifests when a `Coriolis` or `VectorInvariant` stencil touches corner points, it may not affect _most_ `Periodic, Periodic, Bounded` models, which could explain why we haven't caught it. The reason it doesn't affect those models is because this race condition would only affect the corner points of `w`, which are not touched when using an `FPlane` Coriolis model. However, it's possible (I'm not sure) that the race condition could affect models using `NonTraditionalFPlane` in `Periodic, Periodic, Bounded` configurations. More generally, it will also affect models that are bounded in the `y`-direction, because in those models the corner points of the `y`-velocity are affected and also invoked when using `FPlane` or `BetaPlane` coriolis. That's as much as I know. It's very hard to gather information about this bug because it's so rare are subtle. In other words, only one grid point among 10,000 iterations might be affected, and the errors induced are very small. To find this issue, we have to run tens of thousands of iterations of identical models on the GPU, and then compare some statistic of the model (ideally the entire velocity field, but @sandreza has gotten away just comparing something like `[maximum(abs, u), maximum(abs, v), maximum(abs, w)]`). If there's no race condition, identical models should produce identical results.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-921143865
https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-921143865:478,Deployability,configurat,configuration,478,"@tomchor unfortunately we don't have an issue for this problem. @sandreza is it possible to open an issue to document the problem that we are seeing? In the case that this PR does not resolve the issue, we'd like to have an issue open... I don't have much hard evidence to provide but I can describe the problem as I've seen it. Basically, very rare, subtle irregularities have been observed on the GPU when using `HydrostaticFreeSurfaceModel` in a `Periodic, Bounded, Bounded` configuration. I think that it is possible the main issue is an interaction (a read-write race condition) associated with both impenetrable boundary conditions and periodic boundary conditions that affects the 8 corner points. The race condition affects model trajectories via the Coriolis force (which is the only term as far as I know that touches the 8 ""corner"" points affected by this race condition). Because the race condition only manifests when a `Coriolis` or `VectorInvariant` stencil touches corner points, it may not affect _most_ `Periodic, Periodic, Bounded` models, which could explain why we haven't caught it. The reason it doesn't affect those models is because this race condition would only affect the corner points of `w`, which are not touched when using an `FPlane` Coriolis model. However, it's possible (I'm not sure) that the race condition could affect models using `NonTraditionalFPlane` in `Periodic, Periodic, Bounded` configurations. More generally, it will also affect models that are bounded in the `y`-direction, because in those models the corner points of the `y`-velocity are affected and also invoked when using `FPlane` or `BetaPlane` coriolis. That's as much as I know. It's very hard to gather information about this bug because it's so rare are subtle. In other words, only one grid point among 10,000 iterations might be affected, and the errors induced are very small. To find this issue, we have to run tens of thousands of iterations of identical models on the GPU, and then co",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-921143865
https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-921143865:1427,Deployability,configurat,configurations,1427,"ce to provide but I can describe the problem as I've seen it. Basically, very rare, subtle irregularities have been observed on the GPU when using `HydrostaticFreeSurfaceModel` in a `Periodic, Bounded, Bounded` configuration. I think that it is possible the main issue is an interaction (a read-write race condition) associated with both impenetrable boundary conditions and periodic boundary conditions that affects the 8 corner points. The race condition affects model trajectories via the Coriolis force (which is the only term as far as I know that touches the 8 ""corner"" points affected by this race condition). Because the race condition only manifests when a `Coriolis` or `VectorInvariant` stencil touches corner points, it may not affect _most_ `Periodic, Periodic, Bounded` models, which could explain why we haven't caught it. The reason it doesn't affect those models is because this race condition would only affect the corner points of `w`, which are not touched when using an `FPlane` Coriolis model. However, it's possible (I'm not sure) that the race condition could affect models using `NonTraditionalFPlane` in `Periodic, Periodic, Bounded` configurations. More generally, it will also affect models that are bounded in the `y`-direction, because in those models the corner points of the `y`-velocity are affected and also invoked when using `FPlane` or `BetaPlane` coriolis. That's as much as I know. It's very hard to gather information about this bug because it's so rare are subtle. In other words, only one grid point among 10,000 iterations might be affected, and the errors induced are very small. To find this issue, we have to run tens of thousands of iterations of identical models on the GPU, and then compare some statistic of the model (ideally the entire velocity field, but @sandreza has gotten away just comparing something like `[maximum(abs, u), maximum(abs, v), maximum(abs, w)]`). If there's no race condition, identical models should produce identical results.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-921143865
https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-921143865:478,Modifiability,config,configuration,478,"@tomchor unfortunately we don't have an issue for this problem. @sandreza is it possible to open an issue to document the problem that we are seeing? In the case that this PR does not resolve the issue, we'd like to have an issue open... I don't have much hard evidence to provide but I can describe the problem as I've seen it. Basically, very rare, subtle irregularities have been observed on the GPU when using `HydrostaticFreeSurfaceModel` in a `Periodic, Bounded, Bounded` configuration. I think that it is possible the main issue is an interaction (a read-write race condition) associated with both impenetrable boundary conditions and periodic boundary conditions that affects the 8 corner points. The race condition affects model trajectories via the Coriolis force (which is the only term as far as I know that touches the 8 ""corner"" points affected by this race condition). Because the race condition only manifests when a `Coriolis` or `VectorInvariant` stencil touches corner points, it may not affect _most_ `Periodic, Periodic, Bounded` models, which could explain why we haven't caught it. The reason it doesn't affect those models is because this race condition would only affect the corner points of `w`, which are not touched when using an `FPlane` Coriolis model. However, it's possible (I'm not sure) that the race condition could affect models using `NonTraditionalFPlane` in `Periodic, Periodic, Bounded` configurations. More generally, it will also affect models that are bounded in the `y`-direction, because in those models the corner points of the `y`-velocity are affected and also invoked when using `FPlane` or `BetaPlane` coriolis. That's as much as I know. It's very hard to gather information about this bug because it's so rare are subtle. In other words, only one grid point among 10,000 iterations might be affected, and the errors induced are very small. To find this issue, we have to run tens of thousands of iterations of identical models on the GPU, and then co",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-921143865
https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-921143865:1427,Modifiability,config,configurations,1427,"ce to provide but I can describe the problem as I've seen it. Basically, very rare, subtle irregularities have been observed on the GPU when using `HydrostaticFreeSurfaceModel` in a `Periodic, Bounded, Bounded` configuration. I think that it is possible the main issue is an interaction (a read-write race condition) associated with both impenetrable boundary conditions and periodic boundary conditions that affects the 8 corner points. The race condition affects model trajectories via the Coriolis force (which is the only term as far as I know that touches the 8 ""corner"" points affected by this race condition). Because the race condition only manifests when a `Coriolis` or `VectorInvariant` stencil touches corner points, it may not affect _most_ `Periodic, Periodic, Bounded` models, which could explain why we haven't caught it. The reason it doesn't affect those models is because this race condition would only affect the corner points of `w`, which are not touched when using an `FPlane` Coriolis model. However, it's possible (I'm not sure) that the race condition could affect models using `NonTraditionalFPlane` in `Periodic, Periodic, Bounded` configurations. More generally, it will also affect models that are bounded in the `y`-direction, because in those models the corner points of the `y`-velocity are affected and also invoked when using `FPlane` or `BetaPlane` coriolis. That's as much as I know. It's very hard to gather information about this bug because it's so rare are subtle. In other words, only one grid point among 10,000 iterations might be affected, and the errors induced are very small. To find this issue, we have to run tens of thousands of iterations of identical models on the GPU, and then compare some statistic of the model (ideally the entire velocity field, but @sandreza has gotten away just comparing something like `[maximum(abs, u), maximum(abs, v), maximum(abs, w)]`). If there's no race condition, identical models should produce identical results.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-921143865
https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-921143865:568,Performance,race condition,race condition,568,"@tomchor unfortunately we don't have an issue for this problem. @sandreza is it possible to open an issue to document the problem that we are seeing? In the case that this PR does not resolve the issue, we'd like to have an issue open... I don't have much hard evidence to provide but I can describe the problem as I've seen it. Basically, very rare, subtle irregularities have been observed on the GPU when using `HydrostaticFreeSurfaceModel` in a `Periodic, Bounded, Bounded` configuration. I think that it is possible the main issue is an interaction (a read-write race condition) associated with both impenetrable boundary conditions and periodic boundary conditions that affects the 8 corner points. The race condition affects model trajectories via the Coriolis force (which is the only term as far as I know that touches the 8 ""corner"" points affected by this race condition). Because the race condition only manifests when a `Coriolis` or `VectorInvariant` stencil touches corner points, it may not affect _most_ `Periodic, Periodic, Bounded` models, which could explain why we haven't caught it. The reason it doesn't affect those models is because this race condition would only affect the corner points of `w`, which are not touched when using an `FPlane` Coriolis model. However, it's possible (I'm not sure) that the race condition could affect models using `NonTraditionalFPlane` in `Periodic, Periodic, Bounded` configurations. More generally, it will also affect models that are bounded in the `y`-direction, because in those models the corner points of the `y`-velocity are affected and also invoked when using `FPlane` or `BetaPlane` coriolis. That's as much as I know. It's very hard to gather information about this bug because it's so rare are subtle. In other words, only one grid point among 10,000 iterations might be affected, and the errors induced are very small. To find this issue, we have to run tens of thousands of iterations of identical models on the GPU, and then co",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-921143865
https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-921143865:709,Performance,race condition,race condition,709,"@tomchor unfortunately we don't have an issue for this problem. @sandreza is it possible to open an issue to document the problem that we are seeing? In the case that this PR does not resolve the issue, we'd like to have an issue open... I don't have much hard evidence to provide but I can describe the problem as I've seen it. Basically, very rare, subtle irregularities have been observed on the GPU when using `HydrostaticFreeSurfaceModel` in a `Periodic, Bounded, Bounded` configuration. I think that it is possible the main issue is an interaction (a read-write race condition) associated with both impenetrable boundary conditions and periodic boundary conditions that affects the 8 corner points. The race condition affects model trajectories via the Coriolis force (which is the only term as far as I know that touches the 8 ""corner"" points affected by this race condition). Because the race condition only manifests when a `Coriolis` or `VectorInvariant` stencil touches corner points, it may not affect _most_ `Periodic, Periodic, Bounded` models, which could explain why we haven't caught it. The reason it doesn't affect those models is because this race condition would only affect the corner points of `w`, which are not touched when using an `FPlane` Coriolis model. However, it's possible (I'm not sure) that the race condition could affect models using `NonTraditionalFPlane` in `Periodic, Periodic, Bounded` configurations. More generally, it will also affect models that are bounded in the `y`-direction, because in those models the corner points of the `y`-velocity are affected and also invoked when using `FPlane` or `BetaPlane` coriolis. That's as much as I know. It's very hard to gather information about this bug because it's so rare are subtle. In other words, only one grid point among 10,000 iterations might be affected, and the errors induced are very small. To find this issue, we have to run tens of thousands of iterations of identical models on the GPU, and then co",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-921143865
https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-921143865:867,Performance,race condition,race condition,867,"@tomchor unfortunately we don't have an issue for this problem. @sandreza is it possible to open an issue to document the problem that we are seeing? In the case that this PR does not resolve the issue, we'd like to have an issue open... I don't have much hard evidence to provide but I can describe the problem as I've seen it. Basically, very rare, subtle irregularities have been observed on the GPU when using `HydrostaticFreeSurfaceModel` in a `Periodic, Bounded, Bounded` configuration. I think that it is possible the main issue is an interaction (a read-write race condition) associated with both impenetrable boundary conditions and periodic boundary conditions that affects the 8 corner points. The race condition affects model trajectories via the Coriolis force (which is the only term as far as I know that touches the 8 ""corner"" points affected by this race condition). Because the race condition only manifests when a `Coriolis` or `VectorInvariant` stencil touches corner points, it may not affect _most_ `Periodic, Periodic, Bounded` models, which could explain why we haven't caught it. The reason it doesn't affect those models is because this race condition would only affect the corner points of `w`, which are not touched when using an `FPlane` Coriolis model. However, it's possible (I'm not sure) that the race condition could affect models using `NonTraditionalFPlane` in `Periodic, Periodic, Bounded` configurations. More generally, it will also affect models that are bounded in the `y`-direction, because in those models the corner points of the `y`-velocity are affected and also invoked when using `FPlane` or `BetaPlane` coriolis. That's as much as I know. It's very hard to gather information about this bug because it's so rare are subtle. In other words, only one grid point among 10,000 iterations might be affected, and the errors induced are very small. To find this issue, we have to run tens of thousands of iterations of identical models on the GPU, and then co",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-921143865
https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-921143865:896,Performance,race condition,race condition,896,"@tomchor unfortunately we don't have an issue for this problem. @sandreza is it possible to open an issue to document the problem that we are seeing? In the case that this PR does not resolve the issue, we'd like to have an issue open... I don't have much hard evidence to provide but I can describe the problem as I've seen it. Basically, very rare, subtle irregularities have been observed on the GPU when using `HydrostaticFreeSurfaceModel` in a `Periodic, Bounded, Bounded` configuration. I think that it is possible the main issue is an interaction (a read-write race condition) associated with both impenetrable boundary conditions and periodic boundary conditions that affects the 8 corner points. The race condition affects model trajectories via the Coriolis force (which is the only term as far as I know that touches the 8 ""corner"" points affected by this race condition). Because the race condition only manifests when a `Coriolis` or `VectorInvariant` stencil touches corner points, it may not affect _most_ `Periodic, Periodic, Bounded` models, which could explain why we haven't caught it. The reason it doesn't affect those models is because this race condition would only affect the corner points of `w`, which are not touched when using an `FPlane` Coriolis model. However, it's possible (I'm not sure) that the race condition could affect models using `NonTraditionalFPlane` in `Periodic, Periodic, Bounded` configurations. More generally, it will also affect models that are bounded in the `y`-direction, because in those models the corner points of the `y`-velocity are affected and also invoked when using `FPlane` or `BetaPlane` coriolis. That's as much as I know. It's very hard to gather information about this bug because it's so rare are subtle. In other words, only one grid point among 10,000 iterations might be affected, and the errors induced are very small. To find this issue, we have to run tens of thousands of iterations of identical models on the GPU, and then co",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-921143865
https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-921143865:1163,Performance,race condition,race condition,1163,"he issue, we'd like to have an issue open... I don't have much hard evidence to provide but I can describe the problem as I've seen it. Basically, very rare, subtle irregularities have been observed on the GPU when using `HydrostaticFreeSurfaceModel` in a `Periodic, Bounded, Bounded` configuration. I think that it is possible the main issue is an interaction (a read-write race condition) associated with both impenetrable boundary conditions and periodic boundary conditions that affects the 8 corner points. The race condition affects model trajectories via the Coriolis force (which is the only term as far as I know that touches the 8 ""corner"" points affected by this race condition). Because the race condition only manifests when a `Coriolis` or `VectorInvariant` stencil touches corner points, it may not affect _most_ `Periodic, Periodic, Bounded` models, which could explain why we haven't caught it. The reason it doesn't affect those models is because this race condition would only affect the corner points of `w`, which are not touched when using an `FPlane` Coriolis model. However, it's possible (I'm not sure) that the race condition could affect models using `NonTraditionalFPlane` in `Periodic, Periodic, Bounded` configurations. More generally, it will also affect models that are bounded in the `y`-direction, because in those models the corner points of the `y`-velocity are affected and also invoked when using `FPlane` or `BetaPlane` coriolis. That's as much as I know. It's very hard to gather information about this bug because it's so rare are subtle. In other words, only one grid point among 10,000 iterations might be affected, and the errors induced are very small. To find this issue, we have to run tens of thousands of iterations of identical models on the GPU, and then compare some statistic of the model (ideally the entire velocity field, but @sandreza has gotten away just comparing something like `[maximum(abs, u), maximum(abs, v), maximum(abs, w)]`). If the",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-921143865
https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-921143865:1330,Performance,race condition,race condition,1330,"ce to provide but I can describe the problem as I've seen it. Basically, very rare, subtle irregularities have been observed on the GPU when using `HydrostaticFreeSurfaceModel` in a `Periodic, Bounded, Bounded` configuration. I think that it is possible the main issue is an interaction (a read-write race condition) associated with both impenetrable boundary conditions and periodic boundary conditions that affects the 8 corner points. The race condition affects model trajectories via the Coriolis force (which is the only term as far as I know that touches the 8 ""corner"" points affected by this race condition). Because the race condition only manifests when a `Coriolis` or `VectorInvariant` stencil touches corner points, it may not affect _most_ `Periodic, Periodic, Bounded` models, which could explain why we haven't caught it. The reason it doesn't affect those models is because this race condition would only affect the corner points of `w`, which are not touched when using an `FPlane` Coriolis model. However, it's possible (I'm not sure) that the race condition could affect models using `NonTraditionalFPlane` in `Periodic, Periodic, Bounded` configurations. More generally, it will also affect models that are bounded in the `y`-direction, because in those models the corner points of the `y`-velocity are affected and also invoked when using `FPlane` or `BetaPlane` coriolis. That's as much as I know. It's very hard to gather information about this bug because it's so rare are subtle. In other words, only one grid point among 10,000 iterations might be affected, and the errors induced are very small. To find this issue, we have to run tens of thousands of iterations of identical models on the GPU, and then compare some statistic of the model (ideally the entire velocity field, but @sandreza has gotten away just comparing something like `[maximum(abs, u), maximum(abs, v), maximum(abs, w)]`). If there's no race condition, identical models should produce identical results.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-921143865
https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-921143865:2201,Performance,race condition,race condition,2201,"ce to provide but I can describe the problem as I've seen it. Basically, very rare, subtle irregularities have been observed on the GPU when using `HydrostaticFreeSurfaceModel` in a `Periodic, Bounded, Bounded` configuration. I think that it is possible the main issue is an interaction (a read-write race condition) associated with both impenetrable boundary conditions and periodic boundary conditions that affects the 8 corner points. The race condition affects model trajectories via the Coriolis force (which is the only term as far as I know that touches the 8 ""corner"" points affected by this race condition). Because the race condition only manifests when a `Coriolis` or `VectorInvariant` stencil touches corner points, it may not affect _most_ `Periodic, Periodic, Bounded` models, which could explain why we haven't caught it. The reason it doesn't affect those models is because this race condition would only affect the corner points of `w`, which are not touched when using an `FPlane` Coriolis model. However, it's possible (I'm not sure) that the race condition could affect models using `NonTraditionalFPlane` in `Periodic, Periodic, Bounded` configurations. More generally, it will also affect models that are bounded in the `y`-direction, because in those models the corner points of the `y`-velocity are affected and also invoked when using `FPlane` or `BetaPlane` coriolis. That's as much as I know. It's very hard to gather information about this bug because it's so rare are subtle. In other words, only one grid point among 10,000 iterations might be affected, and the errors induced are very small. To find this issue, we have to run tens of thousands of iterations of identical models on the GPU, and then compare some statistic of the model (ideally the entire velocity field, but @sandreza has gotten away just comparing something like `[maximum(abs, u), maximum(abs, v), maximum(abs, w)]`). If there's no race condition, identical models should produce identical results.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-921143865
https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-924068319:50,Deployability,update,update,50,I am running a few more times just to check. I'll update once the results are in.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-924068319
https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-924096447:106,Performance,race condition,race conditions,106,It seems to be good to merge! I have run at different resolutions and for longer times without seeing any race conditions,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-924096447
https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-924098157:40,Deployability,patch,patch,40,"Probably good to bump version and tag a patch release with this, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-924098157
https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-924098157:46,Deployability,release,release,46,"Probably good to bump version and tag a patch release with this, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-924098157
https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-924128314:8,Testability,test,tests,8,"Lots of tests are failing, though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-924128314
https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-924129306:42,Deployability,patch,patch,42,"> Probably good to bump version and tag a patch release with this, no?. Yes of course.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-924129306
https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-924129306:48,Deployability,release,release,48,"> Probably good to bump version and tag a patch release with this, no?. Yes of course.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-924129306
https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-926693915:82,Performance,race condition,race condition,82,@sandreza might be a good idea to code up the case we were using the diagnose the race condition as a test and see if we can catch the race condition in CI @ali-ramadhan,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-926693915
https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-926693915:135,Performance,race condition,race condition,135,@sandreza might be a good idea to code up the case we were using the diagnose the race condition as a test and see if we can catch the race condition in CI @ali-ramadhan,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-926693915
https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-926693915:102,Testability,test,test,102,@sandreza might be a good idea to code up the case we were using the diagnose the race condition as a test and see if we can catch the race condition in CI @ali-ramadhan,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-926693915
https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-926695971:84,Performance,race condition,race condition,84,> @sandreza might be a good idea to code up the case we were using the diagnose the race condition as a test and see if we can catch the race condition in CI @ali-ramadhan. Perhaps a regression test would work for this... and it'd be nice to have a regression test for the hydrostatic model too.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-926695971
https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-926695971:137,Performance,race condition,race condition,137,> @sandreza might be a good idea to code up the case we were using the diagnose the race condition as a test and see if we can catch the race condition in CI @ali-ramadhan. Perhaps a regression test would work for this... and it'd be nice to have a regression test for the hydrostatic model too.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-926695971
https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-926695971:104,Testability,test,test,104,> @sandreza might be a good idea to code up the case we were using the diagnose the race condition as a test and see if we can catch the race condition in CI @ali-ramadhan. Perhaps a regression test would work for this... and it'd be nice to have a regression test for the hydrostatic model too.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-926695971
https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-926695971:194,Testability,test,test,194,> @sandreza might be a good idea to code up the case we were using the diagnose the race condition as a test and see if we can catch the race condition in CI @ali-ramadhan. Perhaps a regression test would work for this... and it'd be nice to have a regression test for the hydrostatic model too.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-926695971
https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-926695971:260,Testability,test,test,260,> @sandreza might be a good idea to code up the case we were using the diagnose the race condition as a test and see if we can catch the race condition in CI @ali-ramadhan. Perhaps a regression test would work for this... and it'd be nice to have a regression test for the hydrostatic model too.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-926695971
https://github.com/CliMA/Oceananigans.jl/issues/1986#issuecomment-921618400:557,Integrability,wrap,wrapper,557,"`src/Fields/show_fields.jl` was. ```; import Oceananigans: short_show. location_str(::Type{Face}) = ""Face""; location_str(::Type{Center}) = ""Center""; location_str(::Type{Nothing}) = """". function show_size(field); Nx, Ny, Nz = size(field); return ""$Nx$Ny$Nz""; end. show_location(X, Y, Z) = ""($(location_str(X)), $(location_str(Y)), $(location_str(Z)))"". show_location(field::AbstractField{X, Y, Z}) where {X, Y, Z} = show_location(X, Y, Z). short_show(m::Missing) = ""$m"". short_show(field::AbstractField) = string(show_size(field), "" "", typeof(field).name.wrapper, "" located at "", show_location(field)); short_show(field::AveragedField) = string(show_size(field), "" "", ""AveragedField over dims=$(field.dims) located at "", show_location(field), "" of "", short_show(field.operand)); short_show(field::ComputedField) = string(show_size(field), "" "", ""ComputedField located at "", show_location(field), "" of "", short_show(field.operand)). Base.show(io::IO, field::AbstractField{X, Y, Z, A}) where {X, Y, Z, A} =; print(io, ""$(short_show(field))\n"",; "" architecture: $A\n"",; "" grid: $(short_show(field.grid))""). function Base.show(io::IO, field::Field); print(io, ""$(short_show(field))"", '\n',; "" data: "", summary(field.data), '\n',; "" grid: $(short_show(field.grid))"", '\n',; "" boundary conditions: $(short_show(field.boundary_conditions))""). return nothing; end. show_status(::Nothing) = ""nothing""; show_status(status) = ""time=$(status.time)"". function Base.show(io::IO, field::AveragedField); print(io, ""$(short_show(field))"", '\n',; "" data: "", summary(field.data), '\n',; "" grid: $(short_show(field.grid))"", '\n',; "" dims: $(field.dims)"", '\n',; "" operand: $(short_show(field.operand))"", '\n',; "" status: "", show_status(field.status)). return nothing; end. function Base.show(io::IO, field::ComputedField); print(io, ""$(short_show(field))"", '\n',; "" data: "", summary(field.data), '\n',; "" grid: $(short_show(field.grid))"", '\n',; "" operand: $(short_show(field.opera",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1986#issuecomment-921618400
https://github.com/CliMA/Oceananigans.jl/pull/1987#issuecomment-922972217:293,Usability,simpl,simply,293,"I didn't see any docstring explaining what's actually being done. Is it possible to add some? Maybe with a minimal example? (Unless I missed it, in which case please ignore the comment.). Also, if I understand correctly, this only regrids in the `z` direction, no? Can we change the same from simply `regrid` to something more specific? Like `regrid_z` or `vertical_regrid`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1987#issuecomment-922972217
https://github.com/CliMA/Oceananigans.jl/pull/1987#issuecomment-923014008:457,Availability,error,error,457,"> Also, if I understand correctly, this only regrids in the `z` direction, no? Can we change the same from simply `regrid` to something more specific? Like `regrid_z` or `vertical_regrid`?. The idea is that we will eventually support general regridding. In this PR, we only implement vertical regridding as a start. The next case to support would be regridding for Cartesian grids; after that, for curvilinear grids. We've attempted to write an informative error:. ```julia; msg = """"""Regridding; $(short_show(v)) on $(short_show(source_grid)); to $(short_show(u)) on $(short_show(target_grid)); is not supported.""""""; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1987#issuecomment-923014008
https://github.com/CliMA/Oceananigans.jl/pull/1987#issuecomment-923014008:107,Usability,simpl,simply,107,"> Also, if I understand correctly, this only regrids in the `z` direction, no? Can we change the same from simply `regrid` to something more specific? Like `regrid_z` or `vertical_regrid`?. The idea is that we will eventually support general regridding. In this PR, we only implement vertical regridding as a start. The next case to support would be regridding for Cartesian grids; after that, for curvilinear grids. We've attempted to write an informative error:. ```julia; msg = """"""Regridding; $(short_show(v)) on $(short_show(source_grid)); to $(short_show(u)) on $(short_show(target_grid)); is not supported.""""""; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1987#issuecomment-923014008
https://github.com/CliMA/Oceananigans.jl/pull/1987#issuecomment-923045151:465,Availability,error,error,465,"> > Also, if I understand correctly, this only regrids in the `z` direction, no? Can we change the same from simply `regrid` to something more specific? Like `regrid_z` or `vertical_regrid`?; > ; > The idea is that we will eventually support general regridding. In this PR, we only implement vertical regridding as a start. The next case to support would be regridding for Cartesian grids; after that, for curvilinear grids. We've attempted to write an informative error:; > ; > ```julia; > msg = """"""Regridding; > $(short_show(v)) on $(short_show(source_grid)); > to $(short_show(u)) on $(short_show(target_grid)); > is not supported.""""""; > ```. I see! I got a bit confused about this error because I'm not familiar with `SingleColumnGrid`, but it makes more sense now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1987#issuecomment-923045151
https://github.com/CliMA/Oceananigans.jl/pull/1987#issuecomment-923045151:685,Availability,error,error,685,"> > Also, if I understand correctly, this only regrids in the `z` direction, no? Can we change the same from simply `regrid` to something more specific? Like `regrid_z` or `vertical_regrid`?; > ; > The idea is that we will eventually support general regridding. In this PR, we only implement vertical regridding as a start. The next case to support would be regridding for Cartesian grids; after that, for curvilinear grids. We've attempted to write an informative error:; > ; > ```julia; > msg = """"""Regridding; > $(short_show(v)) on $(short_show(source_grid)); > to $(short_show(u)) on $(short_show(target_grid)); > is not supported.""""""; > ```. I see! I got a bit confused about this error because I'm not familiar with `SingleColumnGrid`, but it makes more sense now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1987#issuecomment-923045151
https://github.com/CliMA/Oceananigans.jl/pull/1987#issuecomment-923045151:109,Usability,simpl,simply,109,"> > Also, if I understand correctly, this only regrids in the `z` direction, no? Can we change the same from simply `regrid` to something more specific? Like `regrid_z` or `vertical_regrid`?; > ; > The idea is that we will eventually support general regridding. In this PR, we only implement vertical regridding as a start. The next case to support would be regridding for Cartesian grids; after that, for curvilinear grids. We've attempted to write an informative error:; > ; > ```julia; > msg = """"""Regridding; > $(short_show(v)) on $(short_show(source_grid)); > to $(short_show(u)) on $(short_show(target_grid)); > is not supported.""""""; > ```. I see! I got a bit confused about this error because I'm not familiar with `SingleColumnGrid`, but it makes more sense now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1987#issuecomment-923045151
https://github.com/CliMA/Oceananigans.jl/pull/1987#issuecomment-923295323:255,Safety,avoid,avoid,255,"> This looks good! I'll approve it now but I'll leave the following suggestions if you think they're helpful:; > ; > * Add brief docstrings with a quick example; > * Change the names from `u` and `v` in the functions to something more general in order to avoid confusion. Maybe `a`, `b` or some greek letters. (I'm assuming that this works for any `Field`s, no?). I agree. Sorry that seems ""rushed"" but we need this feature for some project. But I will put these as an issue!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1987#issuecomment-923295323
https://github.com/CliMA/Oceananigans.jl/pull/1987#issuecomment-923311897:263,Safety,avoid,avoid,263,"> > This looks good! I'll approve it now but I'll leave the following suggestions if you think they're helpful:; > > ; > > * Add brief docstrings with a quick example; > > * Change the names from `u` and `v` in the functions to something more general in order to avoid confusion. Maybe `a`, `b` or some greek letters. (I'm assuming that this works for any `Field`s, no?); > ; > I agree. Sorry that seems ""rushed"" but we need this feature for some project. But I will put these as an issue!. That's alright. Thanks for creating https://github.com/CliMA/Oceananigans.jl/issues/1991",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1987#issuecomment-923311897
https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-921755394:16,Availability,error,error,16,I looked at the error and see this but don't pretend to know why this has happened. ``` ; Checkpointer [GPU]: Test Failed at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-4/clima/oceananigans/test/test_checkpointer.jl:19;  | Expression: all(test_model.timestepper.G.w.data . true_model.timestepper.G.w.data); ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-921755394
https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-921755394:90,Availability,Checkpoint,Checkpointer,90,I looked at the error and see this but don't pretend to know why this has happened. ``` ; Checkpointer [GPU]: Test Failed at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-4/clima/oceananigans/test/test_checkpointer.jl:19;  | Expression: all(test_model.timestepper.G.w.data . true_model.timestepper.G.w.data); ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-921755394
https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-921755394:110,Testability,Test,Test,110,I looked at the error and see this but don't pretend to know why this has happened. ``` ; Checkpointer [GPU]: Test Failed at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-4/clima/oceananigans/test/test_checkpointer.jl:19;  | Expression: all(test_model.timestepper.G.w.data . true_model.timestepper.G.w.data); ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-921755394
https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-921755394:217,Testability,test,test,217,I looked at the error and see this but don't pretend to know why this has happened. ``` ; Checkpointer [GPU]: Test Failed at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-4/clima/oceananigans/test/test_checkpointer.jl:19;  | Expression: all(test_model.timestepper.G.w.data . true_model.timestepper.G.w.data); ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-921755394
https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-921807534:18,Availability,error,error,18,"> I looked at the error and see this but don't pretend to know why this has happened.; > ; > ```; > Checkpointer [GPU]: Test Failed at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-4/clima/oceananigans/test/test_checkpointer.jl:19; >  | Expression: all(test_model.timestepper.G.w.data . true_model.timestepper.G.w.data); > ```; > ```. Hmm yeah, the model output changed. Not sure what's causing this since I've never investigated the checkpointer. But the fact that the regression tests work points towards it being the checkpointer itself that changed, and not simulation results, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-921807534
https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-921807534:100,Availability,Checkpoint,Checkpointer,100,"> I looked at the error and see this but don't pretend to know why this has happened.; > ; > ```; > Checkpointer [GPU]: Test Failed at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-4/clima/oceananigans/test/test_checkpointer.jl:19; >  | Expression: all(test_model.timestepper.G.w.data . true_model.timestepper.G.w.data); > ```; > ```. Hmm yeah, the model output changed. Not sure what's causing this since I've never investigated the checkpointer. But the fact that the regression tests work points towards it being the checkpointer itself that changed, and not simulation results, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-921807534
https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-921807534:464,Availability,checkpoint,checkpointer,464,"> I looked at the error and see this but don't pretend to know why this has happened.; > ; > ```; > Checkpointer [GPU]: Test Failed at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-4/clima/oceananigans/test/test_checkpointer.jl:19; >  | Expression: all(test_model.timestepper.G.w.data . true_model.timestepper.G.w.data); > ```; > ```. Hmm yeah, the model output changed. Not sure what's causing this since I've never investigated the checkpointer. But the fact that the regression tests work points towards it being the checkpointer itself that changed, and not simulation results, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-921807534
https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-921807534:550,Availability,checkpoint,checkpointer,550,"> I looked at the error and see this but don't pretend to know why this has happened.; > ; > ```; > Checkpointer [GPU]: Test Failed at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-4/clima/oceananigans/test/test_checkpointer.jl:19; >  | Expression: all(test_model.timestepper.G.w.data . true_model.timestepper.G.w.data); > ```; > ```. Hmm yeah, the model output changed. Not sure what's causing this since I've never investigated the checkpointer. But the fact that the regression tests work points towards it being the checkpointer itself that changed, and not simulation results, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-921807534
https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-921807534:120,Testability,Test,Test,120,"> I looked at the error and see this but don't pretend to know why this has happened.; > ; > ```; > Checkpointer [GPU]: Test Failed at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-4/clima/oceananigans/test/test_checkpointer.jl:19; >  | Expression: all(test_model.timestepper.G.w.data . true_model.timestepper.G.w.data); > ```; > ```. Hmm yeah, the model output changed. Not sure what's causing this since I've never investigated the checkpointer. But the fact that the regression tests work points towards it being the checkpointer itself that changed, and not simulation results, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-921807534
https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-921807534:227,Testability,test,test,227,"> I looked at the error and see this but don't pretend to know why this has happened.; > ; > ```; > Checkpointer [GPU]: Test Failed at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-4/clima/oceananigans/test/test_checkpointer.jl:19; >  | Expression: all(test_model.timestepper.G.w.data . true_model.timestepper.G.w.data); > ```; > ```. Hmm yeah, the model output changed. Not sure what's causing this since I've never investigated the checkpointer. But the fact that the regression tests work points towards it being the checkpointer itself that changed, and not simulation results, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-921807534
https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-921807534:511,Testability,test,tests,511,"> I looked at the error and see this but don't pretend to know why this has happened.; > ; > ```; > Checkpointer [GPU]: Test Failed at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-4/clima/oceananigans/test/test_checkpointer.jl:19; >  | Expression: all(test_model.timestepper.G.w.data . true_model.timestepper.G.w.data); > ```; > ```. Hmm yeah, the model output changed. Not sure what's causing this since I've never investigated the checkpointer. But the fact that the regression tests work points towards it being the checkpointer itself that changed, and not simulation results, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-921807534
https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-922551284:40,Testability,test,tests,40,@glwagner any idea why `gpu-simulations-tests` fail?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-922551284
https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-924059212:42,Testability,test,tests,42,> @glwagner any idea why `gpu-simulations-tests` fail?. Which grid points are specifically failing in the test?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-924059212
https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-924059212:106,Testability,test,test,106,> @glwagner any idea why `gpu-simulations-tests` fail?. Which grid points are specifically failing in the test?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-924059212
https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-926918809:44,Testability,test,tests,44,> > @glwagner any idea why `gpu-simulations-tests` fail?; > ; > Which grid points are specifically failing in the test?. How does one go about and answers this question? The log is not informative... Shall I run the tests myself online and then printout the two arrays?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-926918809
https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-926918809:114,Testability,test,test,114,> > @glwagner any idea why `gpu-simulations-tests` fail?; > ; > Which grid points are specifically failing in the test?. How does one go about and answers this question? The log is not informative... Shall I run the tests myself online and then printout the two arrays?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-926918809
https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-926918809:174,Testability,log,log,174,> > @glwagner any idea why `gpu-simulations-tests` fail?; > ; > Which grid points are specifically failing in the test?. How does one go about and answers this question? The log is not informative... Shall I run the tests myself online and then printout the two arrays?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-926918809
https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-926918809:216,Testability,test,tests,216,> > @glwagner any idea why `gpu-simulations-tests` fail?; > ; > Which grid points are specifically failing in the test?. How does one go about and answers this question? The log is not informative... Shall I run the tests myself online and then printout the two arrays?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-926918809
https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-927960226:46,Testability,test,tests,46,"> > > @glwagner any idea why `gpu-simulations-tests` fail?; > > ; > > ; > > Which grid points are specifically failing in the test?; > ; > How does one go about and answers this question? The log is not informative... Shall I run the tests myself online and then printout the two arrays?. Yeah, that's what you have to do to determine it... not urgent though...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-927960226
https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-927960226:126,Testability,test,test,126,"> > > @glwagner any idea why `gpu-simulations-tests` fail?; > > ; > > ; > > Which grid points are specifically failing in the test?; > ; > How does one go about and answers this question? The log is not informative... Shall I run the tests myself online and then printout the two arrays?. Yeah, that's what you have to do to determine it... not urgent though...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-927960226
https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-927960226:192,Testability,log,log,192,"> > > @glwagner any idea why `gpu-simulations-tests` fail?; > > ; > > ; > > Which grid points are specifically failing in the test?; > ; > How does one go about and answers this question? The log is not informative... Shall I run the tests myself online and then printout the two arrays?. Yeah, that's what you have to do to determine it... not urgent though...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-927960226
https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-927960226:234,Testability,test,tests,234,"> > > @glwagner any idea why `gpu-simulations-tests` fail?; > > ; > > ; > > Which grid points are specifically failing in the test?; > ; > How does one go about and answers this question? The log is not informative... Shall I run the tests myself online and then printout the two arrays?. Yeah, that's what you have to do to determine it... not urgent though...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-927960226
https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-928225330:437,Performance,queue,queue,437,"> > > > @glwagner any idea why `gpu-simulations-tests` fail?; > > > ; > > > ; > > > Which grid points are specifically failing in the test?; > > ; > > ; > > How does one go about and answers this question? The log is not informative... Shall I run the tests myself online and then printout the two arrays?; > ; > Yeah, that's what you have to do to determine it... not urgent though... I tried to do that but the HPC at ANU when I use a queue with GPU access it does not have internet access. So it stops at `include(""data_dependencies.jl"")` line...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-928225330
https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-928225330:452,Security,access,access,452,"> > > > @glwagner any idea why `gpu-simulations-tests` fail?; > > > ; > > > ; > > > Which grid points are specifically failing in the test?; > > ; > > ; > > How does one go about and answers this question? The log is not informative... Shall I run the tests myself online and then printout the two arrays?; > ; > Yeah, that's what you have to do to determine it... not urgent though... I tried to do that but the HPC at ANU when I use a queue with GPU access it does not have internet access. So it stops at `include(""data_dependencies.jl"")` line...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-928225330
https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-928225330:485,Security,access,access,485,"> > > > @glwagner any idea why `gpu-simulations-tests` fail?; > > > ; > > > ; > > > Which grid points are specifically failing in the test?; > > ; > > ; > > How does one go about and answers this question? The log is not informative... Shall I run the tests myself online and then printout the two arrays?; > ; > Yeah, that's what you have to do to determine it... not urgent though... I tried to do that but the HPC at ANU when I use a queue with GPU access it does not have internet access. So it stops at `include(""data_dependencies.jl"")` line...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-928225330
https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-928225330:48,Testability,test,tests,48,"> > > > @glwagner any idea why `gpu-simulations-tests` fail?; > > > ; > > > ; > > > Which grid points are specifically failing in the test?; > > ; > > ; > > How does one go about and answers this question? The log is not informative... Shall I run the tests myself online and then printout the two arrays?; > ; > Yeah, that's what you have to do to determine it... not urgent though... I tried to do that but the HPC at ANU when I use a queue with GPU access it does not have internet access. So it stops at `include(""data_dependencies.jl"")` line...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-928225330
https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-928225330:134,Testability,test,test,134,"> > > > @glwagner any idea why `gpu-simulations-tests` fail?; > > > ; > > > ; > > > Which grid points are specifically failing in the test?; > > ; > > ; > > How does one go about and answers this question? The log is not informative... Shall I run the tests myself online and then printout the two arrays?; > ; > Yeah, that's what you have to do to determine it... not urgent though... I tried to do that but the HPC at ANU when I use a queue with GPU access it does not have internet access. So it stops at `include(""data_dependencies.jl"")` line...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-928225330
https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-928225330:210,Testability,log,log,210,"> > > > @glwagner any idea why `gpu-simulations-tests` fail?; > > > ; > > > ; > > > Which grid points are specifically failing in the test?; > > ; > > ; > > How does one go about and answers this question? The log is not informative... Shall I run the tests myself online and then printout the two arrays?; > ; > Yeah, that's what you have to do to determine it... not urgent though... I tried to do that but the HPC at ANU when I use a queue with GPU access it does not have internet access. So it stops at `include(""data_dependencies.jl"")` line...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-928225330
https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-928225330:252,Testability,test,tests,252,"> > > > @glwagner any idea why `gpu-simulations-tests` fail?; > > > ; > > > ; > > > Which grid points are specifically failing in the test?; > > ; > > ; > > How does one go about and answers this question? The log is not informative... Shall I run the tests myself online and then printout the two arrays?; > ; > Yeah, that's what you have to do to determine it... not urgent though... I tried to do that but the HPC at ANU when I use a queue with GPU access it does not have internet access. So it stops at `include(""data_dependencies.jl"")` line...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-928225330
https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-928250982:7,Availability,down,download,7,"If you download data on the login node it should work, because DataDeps doesn't need to download if the file is present",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-928250982
https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-928250982:88,Availability,down,download,88,"If you download data on the login node it should work, because DataDeps doesn't need to download if the file is present",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-928250982
https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-928250982:28,Testability,log,login,28,"If you download data on the login node it should work, because DataDeps doesn't need to download if the file is present",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-928250982
https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-930289400:156,Testability,test,tests-,156,@navidcy Due to #1995 is it worth pinning CUDA.jl to the current version? Might also _magically_ fix some GPU issues although I see that `cpu-time-stepping-tests-2` is also failing.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-930289400
https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-930528128:226,Availability,error,error,226,"> @navidcy Due to #1995 is it worth pinning CUDA.jl to the current version? Might also _magically_ fix some GPU issues although I see that `cpu-time-stepping-tests-2` is also failing. I'll try this. However, these GPU-related error started appearing in #1994 as well...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-930528128
https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-930528128:158,Testability,test,tests-,158,"> @navidcy Due to #1995 is it worth pinning CUDA.jl to the current version? Might also _magically_ fix some GPU issues although I see that `cpu-time-stepping-tests-2` is also failing. I'll try this. However, these GPU-related error started appearing in #1994 as well...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-930528128
https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-930576098:35,Testability,test,tests,35,"omg, @ali-ramadhan! gpu-simulation tests passed!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-930576098
https://github.com/CliMA/Oceananigans.jl/pull/1989#issuecomment-922527594:17,Testability,test,tests,17,"Btw, many of the tests might be ok to use `buoyancy=BuoyancyTracer()` or even `buoyancy=nothing` with `tracer=:c`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1989#issuecomment-922527594
https://github.com/CliMA/Oceananigans.jl/pull/1989#issuecomment-945152318:43,Availability,error,error,43,"It seems ths is pretty close, but I'm this error:. ```;  Debug: checking footnote links.; --;  |  @ Documenter.DocChecks /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/DocChecks.jl:110;  | [ Info: Populate: populating indices.;  | ERROR: LoadError: `makedocs` encountered an error. Terminating build;  | Stacktrace:;  | [1] error(s::String);  | @ Base ./error.jl:33;  | [2] runner(#unused#::Type{Documenter.Builder.RenderDocument}, doc::Documenter.Documents.Document);  | @ Documenter.Builder /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/Builder.jl:255;  | [3] dispatch(#unused#::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Documents.Document);  | @ Documenter.Utilities.Selectors /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/Utilities/Selectors.jl:170;  | [4] #2;  | @ /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/Documenter.jl:257 [inlined];  | [5] cd(f::Documenter.var""#2#3""{Documenter.Documents.Document}, dir::String);  | @ Base.Filesystem ./file.jl:106;  | [6] #makedocs#1;  | @ /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/Documenter.jl:256 [inlined];  | [7] top-level scope;  | @ ~/builds/tartarus-13/clima/oceananigans/docs/make.jl:155;  | in expression starting at /var/lib/buildkite-agent/builds/tartarus-13/clima/oceananigans/docs/make.jl:155;  |  Error: The command exited with status 1;  | user command error: exit status 1; ```. which doesn't really give me any information, so I'm unsure about how to proceed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1989#issuecomment-945152318
https://github.com/CliMA/Oceananigans.jl/pull/1989#issuecomment-945152318:257,Availability,ERROR,ERROR,257,"It seems ths is pretty close, but I'm this error:. ```;  Debug: checking footnote links.; --;  |  @ Documenter.DocChecks /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/DocChecks.jl:110;  | [ Info: Populate: populating indices.;  | ERROR: LoadError: `makedocs` encountered an error. Terminating build;  | Stacktrace:;  | [1] error(s::String);  | @ Base ./error.jl:33;  | [2] runner(#unused#::Type{Documenter.Builder.RenderDocument}, doc::Documenter.Documents.Document);  | @ Documenter.Builder /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/Builder.jl:255;  | [3] dispatch(#unused#::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Documents.Document);  | @ Documenter.Utilities.Selectors /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/Utilities/Selectors.jl:170;  | [4] #2;  | @ /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/Documenter.jl:257 [inlined];  | [5] cd(f::Documenter.var""#2#3""{Documenter.Documents.Document}, dir::String);  | @ Base.Filesystem ./file.jl:106;  | [6] #makedocs#1;  | @ /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/Documenter.jl:256 [inlined];  | [7] top-level scope;  | @ ~/builds/tartarus-13/clima/oceananigans/docs/make.jl:155;  | in expression starting at /var/lib/buildkite-agent/builds/tartarus-13/clima/oceananigans/docs/make.jl:155;  |  Error: The command exited with status 1;  | user command error: exit status 1; ```. which doesn't really give me any information, so I'm unsure about how to proceed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1989#issuecomment-945152318
https://github.com/CliMA/Oceananigans.jl/pull/1989#issuecomment-945152318:301,Availability,error,error,301,"It seems ths is pretty close, but I'm this error:. ```;  Debug: checking footnote links.; --;  |  @ Documenter.DocChecks /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/DocChecks.jl:110;  | [ Info: Populate: populating indices.;  | ERROR: LoadError: `makedocs` encountered an error. Terminating build;  | Stacktrace:;  | [1] error(s::String);  | @ Base ./error.jl:33;  | [2] runner(#unused#::Type{Documenter.Builder.RenderDocument}, doc::Documenter.Documents.Document);  | @ Documenter.Builder /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/Builder.jl:255;  | [3] dispatch(#unused#::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Documents.Document);  | @ Documenter.Utilities.Selectors /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/Utilities/Selectors.jl:170;  | [4] #2;  | @ /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/Documenter.jl:257 [inlined];  | [5] cd(f::Documenter.var""#2#3""{Documenter.Documents.Document}, dir::String);  | @ Base.Filesystem ./file.jl:106;  | [6] #makedocs#1;  | @ /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/Documenter.jl:256 [inlined];  | [7] top-level scope;  | @ ~/builds/tartarus-13/clima/oceananigans/docs/make.jl:155;  | in expression starting at /var/lib/buildkite-agent/builds/tartarus-13/clima/oceananigans/docs/make.jl:155;  |  Error: The command exited with status 1;  | user command error: exit status 1; ```. which doesn't really give me any information, so I'm unsure about how to proceed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1989#issuecomment-945152318
https://github.com/CliMA/Oceananigans.jl/pull/1989#issuecomment-945152318:352,Availability,error,error,352,"It seems ths is pretty close, but I'm this error:. ```;  Debug: checking footnote links.; --;  |  @ Documenter.DocChecks /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/DocChecks.jl:110;  | [ Info: Populate: populating indices.;  | ERROR: LoadError: `makedocs` encountered an error. Terminating build;  | Stacktrace:;  | [1] error(s::String);  | @ Base ./error.jl:33;  | [2] runner(#unused#::Type{Documenter.Builder.RenderDocument}, doc::Documenter.Documents.Document);  | @ Documenter.Builder /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/Builder.jl:255;  | [3] dispatch(#unused#::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Documents.Document);  | @ Documenter.Utilities.Selectors /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/Utilities/Selectors.jl:170;  | [4] #2;  | @ /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/Documenter.jl:257 [inlined];  | [5] cd(f::Documenter.var""#2#3""{Documenter.Documents.Document}, dir::String);  | @ Base.Filesystem ./file.jl:106;  | [6] #makedocs#1;  | @ /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/Documenter.jl:256 [inlined];  | [7] top-level scope;  | @ ~/builds/tartarus-13/clima/oceananigans/docs/make.jl:155;  | in expression starting at /var/lib/buildkite-agent/builds/tartarus-13/clima/oceananigans/docs/make.jl:155;  |  Error: The command exited with status 1;  | user command error: exit status 1; ```. which doesn't really give me any information, so I'm unsure about how to proceed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1989#issuecomment-945152318
https://github.com/CliMA/Oceananigans.jl/pull/1989#issuecomment-945152318:383,Availability,error,error,383,"It seems ths is pretty close, but I'm this error:. ```;  Debug: checking footnote links.; --;  |  @ Documenter.DocChecks /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/DocChecks.jl:110;  | [ Info: Populate: populating indices.;  | ERROR: LoadError: `makedocs` encountered an error. Terminating build;  | Stacktrace:;  | [1] error(s::String);  | @ Base ./error.jl:33;  | [2] runner(#unused#::Type{Documenter.Builder.RenderDocument}, doc::Documenter.Documents.Document);  | @ Documenter.Builder /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/Builder.jl:255;  | [3] dispatch(#unused#::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Documents.Document);  | @ Documenter.Utilities.Selectors /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/Utilities/Selectors.jl:170;  | [4] #2;  | @ /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/Documenter.jl:257 [inlined];  | [5] cd(f::Documenter.var""#2#3""{Documenter.Documents.Document}, dir::String);  | @ Base.Filesystem ./file.jl:106;  | [6] #makedocs#1;  | @ /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/Documenter.jl:256 [inlined];  | [7] top-level scope;  | @ ~/builds/tartarus-13/clima/oceananigans/docs/make.jl:155;  | in expression starting at /var/lib/buildkite-agent/builds/tartarus-13/clima/oceananigans/docs/make.jl:155;  |  Error: The command exited with status 1;  | user command error: exit status 1; ```. which doesn't really give me any information, so I'm unsure about how to proceed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1989#issuecomment-945152318
https://github.com/CliMA/Oceananigans.jl/pull/1989#issuecomment-945152318:1409,Availability,Error,Error,1409,"It seems ths is pretty close, but I'm this error:. ```;  Debug: checking footnote links.; --;  |  @ Documenter.DocChecks /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/DocChecks.jl:110;  | [ Info: Populate: populating indices.;  | ERROR: LoadError: `makedocs` encountered an error. Terminating build;  | Stacktrace:;  | [1] error(s::String);  | @ Base ./error.jl:33;  | [2] runner(#unused#::Type{Documenter.Builder.RenderDocument}, doc::Documenter.Documents.Document);  | @ Documenter.Builder /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/Builder.jl:255;  | [3] dispatch(#unused#::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Documents.Document);  | @ Documenter.Utilities.Selectors /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/Utilities/Selectors.jl:170;  | [4] #2;  | @ /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/Documenter.jl:257 [inlined];  | [5] cd(f::Documenter.var""#2#3""{Documenter.Documents.Document}, dir::String);  | @ Base.Filesystem ./file.jl:106;  | [6] #makedocs#1;  | @ /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/Documenter.jl:256 [inlined];  | [7] top-level scope;  | @ ~/builds/tartarus-13/clima/oceananigans/docs/make.jl:155;  | in expression starting at /var/lib/buildkite-agent/builds/tartarus-13/clima/oceananigans/docs/make.jl:155;  |  Error: The command exited with status 1;  | user command error: exit status 1; ```. which doesn't really give me any information, so I'm unsure about how to proceed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1989#issuecomment-945152318
https://github.com/CliMA/Oceananigans.jl/pull/1989#issuecomment-945152318:1467,Availability,error,error,1467,"It seems ths is pretty close, but I'm this error:. ```;  Debug: checking footnote links.; --;  |  @ Documenter.DocChecks /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/DocChecks.jl:110;  | [ Info: Populate: populating indices.;  | ERROR: LoadError: `makedocs` encountered an error. Terminating build;  | Stacktrace:;  | [1] error(s::String);  | @ Base ./error.jl:33;  | [2] runner(#unused#::Type{Documenter.Builder.RenderDocument}, doc::Documenter.Documents.Document);  | @ Documenter.Builder /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/Builder.jl:255;  | [3] dispatch(#unused#::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Documents.Document);  | @ Documenter.Utilities.Selectors /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/Utilities/Selectors.jl:170;  | [4] #2;  | @ /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/Documenter.jl:257 [inlined];  | [5] cd(f::Documenter.var""#2#3""{Documenter.Documents.Document}, dir::String);  | @ Base.Filesystem ./file.jl:106;  | [6] #makedocs#1;  | @ /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/Documenter.jl:256 [inlined];  | [7] top-level scope;  | @ ~/builds/tartarus-13/clima/oceananigans/docs/make.jl:155;  | in expression starting at /var/lib/buildkite-agent/builds/tartarus-13/clima/oceananigans/docs/make.jl:155;  |  Error: The command exited with status 1;  | user command error: exit status 1; ```. which doesn't really give me any information, so I'm unsure about how to proceed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1989#issuecomment-945152318
https://github.com/CliMA/Oceananigans.jl/pull/1989#issuecomment-945152318:264,Performance,Load,LoadError,264,"It seems ths is pretty close, but I'm this error:. ```;  Debug: checking footnote links.; --;  |  @ Documenter.DocChecks /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/DocChecks.jl:110;  | [ Info: Populate: populating indices.;  | ERROR: LoadError: `makedocs` encountered an error. Terminating build;  | Stacktrace:;  | [1] error(s::String);  | @ Base ./error.jl:33;  | [2] runner(#unused#::Type{Documenter.Builder.RenderDocument}, doc::Documenter.Documents.Document);  | @ Documenter.Builder /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/Builder.jl:255;  | [3] dispatch(#unused#::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Documents.Document);  | @ Documenter.Utilities.Selectors /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/Utilities/Selectors.jl:170;  | [4] #2;  | @ /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/Documenter.jl:257 [inlined];  | [5] cd(f::Documenter.var""#2#3""{Documenter.Documents.Document}, dir::String);  | @ Base.Filesystem ./file.jl:106;  | [6] #makedocs#1;  | @ /storage5/buildkite-agent/.julia-3990/packages/Documenter/R2HVS/src/Documenter.jl:256 [inlined];  | [7] top-level scope;  | @ ~/builds/tartarus-13/clima/oceananigans/docs/make.jl:155;  | in expression starting at /var/lib/buildkite-agent/builds/tartarus-13/clima/oceananigans/docs/make.jl:155;  |  Error: The command exited with status 1;  | user command error: exit status 1; ```. which doesn't really give me any information, so I'm unsure about how to proceed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1989#issuecomment-945152318
https://github.com/CliMA/Oceananigans.jl/pull/1989#issuecomment-969449993:523,Energy Efficiency,schedul,schedule,523,"> I haven't gone through everything but I get the feeling that there is a lot of leftover docstrings/docs that are related to the previous default T, S option. Am I right? We should have T, S where is needed for the demonstration, not just have it everywhere because it's a leftover from before.; > ; > I don't. @navidcy Thanks for the review! I think your message got a little cut in the end. But I totally agree. I have modified these instances where I identified them (for example in model_setup/tracers.md), but a busy schedule kept me from doing a more thorough search for occasions where these happen. I'll fix the ones you found and look for some more!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1989#issuecomment-969449993
https://github.com/CliMA/Oceananigans.jl/pull/1989#issuecomment-969449993:357,Integrability,message,message,357,"> I haven't gone through everything but I get the feeling that there is a lot of leftover docstrings/docs that are related to the previous default T, S option. Am I right? We should have T, S where is needed for the demonstration, not just have it everywhere because it's a leftover from before.; > ; > I don't. @navidcy Thanks for the review! I think your message got a little cut in the end. But I totally agree. I have modified these instances where I identified them (for example in model_setup/tracers.md), but a busy schedule kept me from doing a more thorough search for occasions where these happen. I'll fix the ones you found and look for some more!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1989#issuecomment-969449993
https://github.com/CliMA/Oceananigans.jl/pull/1989#issuecomment-969648031:357,Availability,error,errors,357,"A couple of notes:. I realized that the doctests in the NetCDFWriter docstring and the NetCDFWriter session in `model_setup` are pretty much the same. I think it's good that both have the information, but it would be nice if we could write that stuff only once and then automatically display in both places. Maybe something for a different PR?. I'm getting errors like the one below in the docs, indicating that there are some leftover files in the server:. ```;  Warning: fields.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file. You might experience errors when writing output if the existing file belonged to a different simulation!;  @ Oceananigans.OutputWriters ~/builds/tartarus-10/clima/oceananigans/src/OutputWriters/netcdf_output_writer.jl:290; ```. I thought these files were automatically deleted on the CI server. Is there anything I have to do to prevent them?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1989#issuecomment-969648031
https://github.com/CliMA/Oceananigans.jl/pull/1989#issuecomment-969648031:632,Availability,error,errors,632,"A couple of notes:. I realized that the doctests in the NetCDFWriter docstring and the NetCDFWriter session in `model_setup` are pretty much the same. I think it's good that both have the information, but it would be nice if we could write that stuff only once and then automatically display in both places. Maybe something for a different PR?. I'm getting errors like the one below in the docs, indicating that there are some leftover files in the server:. ```;  Warning: fields.nc already exists but no NetCDFOutputWriter mode was explicitly specified. Will default to mode = ""a"" to append to existing file. You might experience errors when writing output if the existing file belonged to a different simulation!;  @ Oceananigans.OutputWriters ~/builds/tartarus-10/clima/oceananigans/src/OutputWriters/netcdf_output_writer.jl:290; ```. I thought these files were automatically deleted on the CI server. Is there anything I have to do to prevent them?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1989#issuecomment-969648031
https://github.com/CliMA/Oceananigans.jl/pull/1989#issuecomment-971796207:248,Availability,avail,available,248,"Following the comments, I included a better discussion of models in the buoyancy section of model setup. I believe this is an improvement regardless of the default behavior, since we only mentioned `NonhydrostaticModel` before. The preview will be available here: https://clima.github.io/OceananigansDocumentation/previews/PR1989/model_setup/buoyancy_and_equation_of_state/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1989#issuecomment-971796207
https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970:1036,Availability,down,down,1036,"Yes we definitely need to speed up the tests. I think 95% of the time it takes to run tests is spent in compilation, however, so creating fewer models may not help much. Instead we may need to be more strategic with how we run tests, and perhaps also work on speeding up compilation time using something like [SnoopCompile.jl](https://github.com/timholy/SnoopCompile.jl). On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when `bors try` or `bors r+` is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster _and_ easier to maintain, if we are careful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970
https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970:1142,Availability,mainten,maintenance,1142,"Yes we definitely need to speed up the tests. I think 95% of the time it takes to run tests is spent in compilation, however, so creating fewer models may not help much. Instead we may need to be more strategic with how we run tests, and perhaps also work on speeding up compilation time using something like [SnoopCompile.jl](https://github.com/timholy/SnoopCompile.jl). On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when `bors try` or `bors r+` is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster _and_ easier to maintain, if we are careful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970
https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970:563,Deployability,integrat,integration,563,"Yes we definitely need to speed up the tests. I think 95% of the time it takes to run tests is spent in compilation, however, so creating fewer models may not help much. Instead we may need to be more strategic with how we run tests, and perhaps also work on speeding up compilation time using something like [SnoopCompile.jl](https://github.com/timholy/SnoopCompile.jl). On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when `bors try` or `bors r+` is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster _and_ easier to maintain, if we are careful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970
https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970:563,Integrability,integrat,integration,563,"Yes we definitely need to speed up the tests. I think 95% of the time it takes to run tests is spent in compilation, however, so creating fewer models may not help much. Instead we may need to be more strategic with how we run tests, and perhaps also work on speeding up compilation time using something like [SnoopCompile.jl](https://github.com/timholy/SnoopCompile.jl). On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when `bors try` or `bors r+` is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster _and_ easier to maintain, if we are careful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970
https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970:1065,Modifiability,rewrite,rewrite,1065,"Yes we definitely need to speed up the tests. I think 95% of the time it takes to run tests is spent in compilation, however, so creating fewer models may not help much. Instead we may need to be more strategic with how we run tests, and perhaps also work on speeding up compilation time using something like [SnoopCompile.jl](https://github.com/timholy/SnoopCompile.jl). On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when `bors try` or `bors r+` is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster _and_ easier to maintain, if we are careful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970
https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970:929,Security,validat,validation,929,"Yes we definitely need to speed up the tests. I think 95% of the time it takes to run tests is spent in compilation, however, so creating fewer models may not help much. Instead we may need to be more strategic with how we run tests, and perhaps also work on speeding up compilation time using something like [SnoopCompile.jl](https://github.com/timholy/SnoopCompile.jl). On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when `bors try` or `bors r+` is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster _and_ easier to maintain, if we are careful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970
https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970:39,Testability,test,tests,39,"Yes we definitely need to speed up the tests. I think 95% of the time it takes to run tests is spent in compilation, however, so creating fewer models may not help much. Instead we may need to be more strategic with how we run tests, and perhaps also work on speeding up compilation time using something like [SnoopCompile.jl](https://github.com/timholy/SnoopCompile.jl). On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when `bors try` or `bors r+` is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster _and_ easier to maintain, if we are careful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970
https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970:86,Testability,test,tests,86,"Yes we definitely need to speed up the tests. I think 95% of the time it takes to run tests is spent in compilation, however, so creating fewer models may not help much. Instead we may need to be more strategic with how we run tests, and perhaps also work on speeding up compilation time using something like [SnoopCompile.jl](https://github.com/timholy/SnoopCompile.jl). On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when `bors try` or `bors r+` is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster _and_ easier to maintain, if we are careful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970
https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970:227,Testability,test,tests,227,"Yes we definitely need to speed up the tests. I think 95% of the time it takes to run tests is spent in compilation, however, so creating fewer models may not help much. Instead we may need to be more strategic with how we run tests, and perhaps also work on speeding up compilation time using something like [SnoopCompile.jl](https://github.com/timholy/SnoopCompile.jl). On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when `bors try` or `bors r+` is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster _and_ easier to maintain, if we are careful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970
https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970:441,Testability,test,tests,441,"Yes we definitely need to speed up the tests. I think 95% of the time it takes to run tests is spent in compilation, however, so creating fewer models may not help much. Instead we may need to be more strategic with how we run tests, and perhaps also work on speeding up compilation time using something like [SnoopCompile.jl](https://github.com/timholy/SnoopCompile.jl). On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when `bors try` or `bors r+` is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster _and_ easier to maintain, if we are careful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970
https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970:492,Testability,test,tests,492,"Yes we definitely need to speed up the tests. I think 95% of the time it takes to run tests is spent in compilation, however, so creating fewer models may not help much. Instead we may need to be more strategic with how we run tests, and perhaps also work on speeding up compilation time using something like [SnoopCompile.jl](https://github.com/timholy/SnoopCompile.jl). On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when `bors try` or `bors r+` is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster _and_ easier to maintain, if we are careful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970
https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970:575,Testability,test,tests,575,"Yes we definitely need to speed up the tests. I think 95% of the time it takes to run tests is spent in compilation, however, so creating fewer models may not help much. Instead we may need to be more strategic with how we run tests, and perhaps also work on speeding up compilation time using something like [SnoopCompile.jl](https://github.com/timholy/SnoopCompile.jl). On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when `bors try` or `bors r+` is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster _and_ easier to maintain, if we are careful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970
https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970:825,Testability,test,tests,825,"Yes we definitely need to speed up the tests. I think 95% of the time it takes to run tests is spent in compilation, however, so creating fewer models may not help much. Instead we may need to be more strategic with how we run tests, and perhaps also work on speeding up compilation time using something like [SnoopCompile.jl](https://github.com/timholy/SnoopCompile.jl). On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when `bors try` or `bors r+` is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster _and_ easier to maintain, if we are careful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970
https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970:879,Testability,test,test,879,"Yes we definitely need to speed up the tests. I think 95% of the time it takes to run tests is spent in compilation, however, so creating fewer models may not help much. Instead we may need to be more strategic with how we run tests, and perhaps also work on speeding up compilation time using something like [SnoopCompile.jl](https://github.com/timholy/SnoopCompile.jl). On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when `bors try` or `bors r+` is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster _and_ easier to maintain, if we are careful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970
https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970:919,Testability,test,tests,919,"Yes we definitely need to speed up the tests. I think 95% of the time it takes to run tests is spent in compilation, however, so creating fewer models may not help much. Instead we may need to be more strategic with how we run tests, and perhaps also work on speeding up compilation time using something like [SnoopCompile.jl](https://github.com/timholy/SnoopCompile.jl). On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when `bors try` or `bors r+` is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster _and_ easier to maintain, if we are careful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970
https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970:1073,Testability,test,tests,1073,"Yes we definitely need to speed up the tests. I think 95% of the time it takes to run tests is spent in compilation, however, so creating fewer models may not help much. Instead we may need to be more strategic with how we run tests, and perhaps also work on speeding up compilation time using something like [SnoopCompile.jl](https://github.com/timholy/SnoopCompile.jl). On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when `bors try` or `bors r+` is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster _and_ easier to maintain, if we are careful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970
https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970:1168,Testability,test,test,1168,"Yes we definitely need to speed up the tests. I think 95% of the time it takes to run tests is spent in compilation, however, so creating fewer models may not help much. Instead we may need to be more strategic with how we run tests, and perhaps also work on speeding up compilation time using something like [SnoopCompile.jl](https://github.com/timholy/SnoopCompile.jl). On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when `bors try` or `bors r+` is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster _and_ easier to maintain, if we are careful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970
https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970:1254,Testability,test,tests,1254,"Yes we definitely need to speed up the tests. I think 95% of the time it takes to run tests is spent in compilation, however, so creating fewer models may not help much. Instead we may need to be more strategic with how we run tests, and perhaps also work on speeding up compilation time using something like [SnoopCompile.jl](https://github.com/timholy/SnoopCompile.jl). On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when `bors try` or `bors r+` is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster _and_ easier to maintain, if we are careful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970
https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970:1329,Testability,test,tests,1329,"Yes we definitely need to speed up the tests. I think 95% of the time it takes to run tests is spent in compilation, however, so creating fewer models may not help much. Instead we may need to be more strategic with how we run tests, and perhaps also work on speeding up compilation time using something like [SnoopCompile.jl](https://github.com/timholy/SnoopCompile.jl). On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when `bors try` or `bors r+` is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster _and_ easier to maintain, if we are careful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970
https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970:863,Usability,simpl,simplifying,863,"Yes we definitely need to speed up the tests. I think 95% of the time it takes to run tests is spent in compilation, however, so creating fewer models may not help much. Instead we may need to be more strategic with how we run tests, and perhaps also work on speeding up compilation time using something like [SnoopCompile.jl](https://github.com/timholy/SnoopCompile.jl). On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when `bors try` or `bors r+` is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster _and_ easier to maintain, if we are careful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970
https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440:702,Availability,down,down,702,">On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when bors try or bors r+ is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Definitely looking forward to that PR. > Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster and easier to maintain, if we are careful. I definitely agree with that. I just don't see how to do it. Being thorough with the tests (which I believe is something we want) necessarily comes with using the API many times, making changes to it a bit slower to implement, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440
https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440:808,Availability,mainten,maintenance,808,">On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when bors try or bors r+ is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Definitely looking forward to that PR. > Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster and easier to maintain, if we are careful. I definitely agree with that. I just don't see how to do it. Being thorough with the tests (which I believe is something we want) necessarily comes with using the API many times, making changes to it a bit slower to implement, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440
https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440:192,Deployability,integrat,integration,192,">On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when bors try or bors r+ is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Definitely looking forward to that PR. > Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster and easier to maintain, if we are careful. I definitely agree with that. I just don't see how to do it. Being thorough with the tests (which I believe is something we want) necessarily comes with using the API many times, making changes to it a bit slower to implement, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440
https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440:192,Integrability,integrat,integration,192,">On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when bors try or bors r+ is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Definitely looking forward to that PR. > Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster and easier to maintain, if we are careful. I definitely agree with that. I just don't see how to do it. Being thorough with the tests (which I believe is something we want) necessarily comes with using the API many times, making changes to it a bit slower to implement, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440
https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440:731,Modifiability,rewrite,rewrite,731,">On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when bors try or bors r+ is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Definitely looking forward to that PR. > Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster and easier to maintain, if we are careful. I definitely agree with that. I just don't see how to do it. Being thorough with the tests (which I believe is something we want) necessarily comes with using the API many times, making changes to it a bit slower to implement, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440
https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440:595,Security,validat,validation,595,">On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when bors try or bors r+ is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Definitely looking forward to that PR. > Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster and easier to maintain, if we are careful. I definitely agree with that. I just don't see how to do it. Being thorough with the tests (which I believe is something we want) necessarily comes with using the API many times, making changes to it a bit slower to implement, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440
https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440:70,Testability,test,tests,70,">On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when bors try or bors r+ is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Definitely looking forward to that PR. > Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster and easier to maintain, if we are careful. I definitely agree with that. I just don't see how to do it. Being thorough with the tests (which I believe is something we want) necessarily comes with using the API many times, making changes to it a bit slower to implement, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440
https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440:121,Testability,test,tests,121,">On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when bors try or bors r+ is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Definitely looking forward to that PR. > Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster and easier to maintain, if we are careful. I definitely agree with that. I just don't see how to do it. Being thorough with the tests (which I believe is something we want) necessarily comes with using the API many times, making changes to it a bit slower to implement, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440
https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440:204,Testability,test,tests,204,">On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when bors try or bors r+ is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Definitely looking forward to that PR. > Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster and easier to maintain, if we are careful. I definitely agree with that. I just don't see how to do it. Being thorough with the tests (which I believe is something we want) necessarily comes with using the API many times, making changes to it a bit slower to implement, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440
https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440:450,Testability,test,tests,450,">On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when bors try or bors r+ is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Definitely looking forward to that PR. > Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster and easier to maintain, if we are careful. I definitely agree with that. I just don't see how to do it. Being thorough with the tests (which I believe is something we want) necessarily comes with using the API many times, making changes to it a bit slower to implement, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440
https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440:545,Testability,test,test,545,">On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when bors try or bors r+ is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Definitely looking forward to that PR. > Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster and easier to maintain, if we are careful. I definitely agree with that. I just don't see how to do it. Being thorough with the tests (which I believe is something we want) necessarily comes with using the API many times, making changes to it a bit slower to implement, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440
https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440:585,Testability,test,tests,585,">On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when bors try or bors r+ is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Definitely looking forward to that PR. > Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster and easier to maintain, if we are careful. I definitely agree with that. I just don't see how to do it. Being thorough with the tests (which I believe is something we want) necessarily comes with using the API many times, making changes to it a bit slower to implement, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440
https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440:739,Testability,test,tests,739,">On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when bors try or bors r+ is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Definitely looking forward to that PR. > Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster and easier to maintain, if we are careful. I definitely agree with that. I just don't see how to do it. Being thorough with the tests (which I believe is something we want) necessarily comes with using the API many times, making changes to it a bit slower to implement, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440
https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440:834,Testability,test,test,834,">On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when bors try or bors r+ is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Definitely looking forward to that PR. > Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster and easier to maintain, if we are careful. I definitely agree with that. I just don't see how to do it. Being thorough with the tests (which I believe is something we want) necessarily comes with using the API many times, making changes to it a bit slower to implement, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440
https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440:920,Testability,test,tests,920,">On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when bors try or bors r+ is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Definitely looking forward to that PR. > Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster and easier to maintain, if we are careful. I definitely agree with that. I just don't see how to do it. Being thorough with the tests (which I believe is something we want) necessarily comes with using the API many times, making changes to it a bit slower to implement, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440
https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440:995,Testability,test,tests,995,">On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when bors try or bors r+ is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Definitely looking forward to that PR. > Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster and easier to maintain, if we are careful. I definitely agree with that. I just don't see how to do it. Being thorough with the tests (which I believe is something we want) necessarily comes with using the API many times, making changes to it a bit slower to implement, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440
https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440:1153,Testability,test,tests,1153,">On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when bors try or bors r+ is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Definitely looking forward to that PR. > Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster and easier to maintain, if we are careful. I definitely agree with that. I just don't see how to do it. Being thorough with the tests (which I believe is something we want) necessarily comes with using the API many times, making changes to it a bit slower to implement, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440
https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440:529,Usability,simpl,simplifying,529,">On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when bors try or bors r+ is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Definitely looking forward to that PR. > Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster and easier to maintain, if we are careful. I definitely agree with that. I just don't see how to do it. Being thorough with the tests (which I believe is something we want) necessarily comes with using the API many times, making changes to it a bit slower to implement, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440
https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922536029:305,Modifiability,maintainab,maintainable,305,"> I definitely agree with that. I just don't see how to do it. Being thorough with the tests (which I believe is something we want) necessarily comes with using the API many times, making changes to it a bit slower to implement, no?. I think many of the tests can probably be designed / written in a more maintainable way. There's a lot of boilerplate and copy-pasted code in the tests.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922536029
https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922536029:87,Testability,test,tests,87,"> I definitely agree with that. I just don't see how to do it. Being thorough with the tests (which I believe is something we want) necessarily comes with using the API many times, making changes to it a bit slower to implement, no?. I think many of the tests can probably be designed / written in a more maintainable way. There's a lot of boilerplate and copy-pasted code in the tests.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922536029
https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922536029:254,Testability,test,tests,254,"> I definitely agree with that. I just don't see how to do it. Being thorough with the tests (which I believe is something we want) necessarily comes with using the API many times, making changes to it a bit slower to implement, no?. I think many of the tests can probably be designed / written in a more maintainable way. There's a lot of boilerplate and copy-pasted code in the tests.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922536029
https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922536029:380,Testability,test,tests,380,"> I definitely agree with that. I just don't see how to do it. Being thorough with the tests (which I believe is something we want) necessarily comes with using the API many times, making changes to it a bit slower to implement, no?. I think many of the tests can probably be designed / written in a more maintainable way. There's a lot of boilerplate and copy-pasted code in the tests.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922536029
https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-1480583262:110,Testability,test,tests,110,"Should we close this? There's no real specific action we can take to close it, though certainly improving the tests should be an ongoing priority...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-1480583262
https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-924056580:95,Deployability,update,update,95,> very nice! Is tapering planned as being a part of this PR or will that be saved for a future update?. We need to discuss what the API for tapering would look like.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-924056580
https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-924418422:98,Safety,avoid,avoid,98,"May I ask why it was decided to not call it Gent-McWilliams? I agree that in general it's good to avoid people's names in things, but in this case (imo) it makes it so much more clear what closure this is since that's what people always call it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-924418422
https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-924418422:178,Usability,clear,clear,178,"May I ask why it was decided to not call it Gent-McWilliams? I agree that in general it's good to avoid people's names in things, but in this case (imo) it makes it so much more clear what closure this is since that's what people always call it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-924418422
https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-924962650:794,Modifiability,parameteriz,parameterization,794,"> May I ask why it was decided to not call it Gent-McWilliams? I agree that in general it's good to avoid people's names in things, but in this case (imo) it makes it so much more clear what closure this is since that's what people always call it. As far as I can tell when people say they use ""Gent-McWilliams"" they are referring to a constant skew diffusivity (typically 0.3 m^2 / s). But in this closure, the diffusivity can be an arbitrary function or field. If anything it would have to be `GentMcWilliamsRedi` since we include the symmetric component as well as the skew component. Still though, I think it's important to emphasize that this closure is more general than Gent-McWilliams; not least because the only point in implementing this scheme is to develop a new, better, different parameterization.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-924962650
https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-924962650:100,Safety,avoid,avoid,100,"> May I ask why it was decided to not call it Gent-McWilliams? I agree that in general it's good to avoid people's names in things, but in this case (imo) it makes it so much more clear what closure this is since that's what people always call it. As far as I can tell when people say they use ""Gent-McWilliams"" they are referring to a constant skew diffusivity (typically 0.3 m^2 / s). But in this closure, the diffusivity can be an arbitrary function or field. If anything it would have to be `GentMcWilliamsRedi` since we include the symmetric component as well as the skew component. Still though, I think it's important to emphasize that this closure is more general than Gent-McWilliams; not least because the only point in implementing this scheme is to develop a new, better, different parameterization.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-924962650
https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-924962650:180,Usability,clear,clear,180,"> May I ask why it was decided to not call it Gent-McWilliams? I agree that in general it's good to avoid people's names in things, but in this case (imo) it makes it so much more clear what closure this is since that's what people always call it. As far as I can tell when people say they use ""Gent-McWilliams"" they are referring to a constant skew diffusivity (typically 0.3 m^2 / s). But in this closure, the diffusivity can be an arbitrary function or field. If anything it would have to be `GentMcWilliamsRedi` since we include the symmetric component as well as the skew component. Still though, I think it's important to emphasize that this closure is more general than Gent-McWilliams; not least because the only point in implementing this scheme is to develop a new, better, different parameterization.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-924962650
https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-929553002:29,Availability,checkpoint,checkpointer,29,"oh, now tests related to the checkpointer started failing in this PR :(",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-929553002
https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-929553002:8,Testability,test,tests,8,"oh, now tests related to the checkpointer started failing in this PR :(",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-929553002
https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-930892328:171,Security,validat,validation,171,"OK, I feel this is ready to be merged. What you all think?. @sandreza, there is a slope limiter now. The Gerdes et al 1991. But others can be implemented. I'm running the validation exp with GM for 60 years to see how it looks...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-930892328
https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-944046907:69,Testability,test,tests,69,"@glwagner,. 1) Could you have a look at 6c4fa98 and 92ab919?. 2) The tests don't pass because the convenience functions I added in 92ab919 don't have a method for `::SeaWaterBuoyancy` yet! But I confirm that with `::BuoyancyTracer` it doesn't break. ```julia; julia> using Oceananigans; [ Info: Oceananigans will use 12 threads. julia> grid = RegularRectilinearGrid(Float64; size=(1, 1, 1), halo=(2, 2, 2), extent=(1, 2, 3)); RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}; domain: x  [0.0, 1.0], y  [0.0, 2.0], z  [-3.0, 0.0]; topology: (Periodic, Periodic, Bounded); size (Nx, Ny, Nz): (1, 1, 1); halo (Hx, Hy, Hz): (2, 2, 2); grid spacing (x, y, z): (1.0, 2.0, 3.0). julia> model = NonhydrostaticModel(grid=grid, architecture=CPU(),; closure=IsopycnalSkewSymmetricDiffusivity(), tracers=:b, buoyancy=BuoyancyTracer()); NonhydrostaticModel{CPU, Float64}(time = 0 seconds, iteration = 0);  grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1);  tracers: (:b,);  closure: IsopycnalSkewSymmetricDiffusivity{NamedTuple{(:b,), Tuple{Float64}}, NamedTuple{(:b,), Tuple{Float64}}, Oceananigans.TurbulenceClosures.SmallSlopeIsopycnalTensor{Int64}, Nothing};  buoyancy: BuoyancyTracer;  coriolis: Nothing. julia> time_step!(model, 1, euler=true). julia> ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-944046907
https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-971930449:1058,Modifiability,parameteriz,parameterization,1058,"Was just looking through this, and not sure if there is still room for comments from noobs (happy to be ignored). Would `tensor_diffusivity` be a good name - skewsymmetric seems a bit like saying that a T-junction is a left_right_turn. :) . > > May I ask why it was decided to not call it Gent-McWilliams? I agree that in general it's good to avoid people's names in things, but in this case (imo) it makes it so much more clear what closure this is since that's what people always call it.; > ; > As far as I can tell when people say they use ""Gent-McWilliams"" they are referring to a constant skew diffusivity (typically 0.3 m^2 / s). But in this closure, the diffusivity can be an arbitrary function or field.; > ; > If anything it would have to be `GentMcWilliamsRedi` since we include the symmetric component as well as the skew component.; > ; > Still though, I think it's important to emphasize that this closure is more general than Gent-McWilliams; not least because the only point in implementing this scheme is to develop a new, better, different parameterization.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-971930449
https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-971930449:343,Safety,avoid,avoid,343,"Was just looking through this, and not sure if there is still room for comments from noobs (happy to be ignored). Would `tensor_diffusivity` be a good name - skewsymmetric seems a bit like saying that a T-junction is a left_right_turn. :) . > > May I ask why it was decided to not call it Gent-McWilliams? I agree that in general it's good to avoid people's names in things, but in this case (imo) it makes it so much more clear what closure this is since that's what people always call it.; > ; > As far as I can tell when people say they use ""Gent-McWilliams"" they are referring to a constant skew diffusivity (typically 0.3 m^2 / s). But in this closure, the diffusivity can be an arbitrary function or field.; > ; > If anything it would have to be `GentMcWilliamsRedi` since we include the symmetric component as well as the skew component.; > ; > Still though, I think it's important to emphasize that this closure is more general than Gent-McWilliams; not least because the only point in implementing this scheme is to develop a new, better, different parameterization.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-971930449
https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-971930449:423,Usability,clear,clear,423,"Was just looking through this, and not sure if there is still room for comments from noobs (happy to be ignored). Would `tensor_diffusivity` be a good name - skewsymmetric seems a bit like saying that a T-junction is a left_right_turn. :) . > > May I ask why it was decided to not call it Gent-McWilliams? I agree that in general it's good to avoid people's names in things, but in this case (imo) it makes it so much more clear what closure this is since that's what people always call it.; > ; > As far as I can tell when people say they use ""Gent-McWilliams"" they are referring to a constant skew diffusivity (typically 0.3 m^2 / s). But in this closure, the diffusivity can be an arbitrary function or field.; > ; > If anything it would have to be `GentMcWilliamsRedi` since we include the symmetric component as well as the skew component.; > ; > Still though, I think it's important to emphasize that this closure is more general than Gent-McWilliams; not least because the only point in implementing this scheme is to develop a new, better, different parameterization.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-971930449
https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-972010093:476,Modifiability,variab,variables,476,"> Was just looking through this, and not sure if there is still room for comments from noobs (happy to be ignored). Would `tensor_diffusivity` be a good name - skewsymmetric seems a bit like saying that a T-junction is a left_right_turn. :). I see what you're saying @dhruvbalwada ... ! :-D Maybe `IsopycnalTensorDiffusivity` ? The thing is, when users build this closure they have the option only to set _coefficients_ (which may be constants or nonlinear functions of model variables) of two tensors --- an ""isopycnal rotation tensor"" that is symmetric and rotates a vector into the isopycnal plane, and another skew-symmetric or antisymmetric tensor. So the tensor is not general; it has a specific form... On the other hand I think we are leaning towards more substantial changes to this parameterization than would be covered by this name. So we could have one `IsopycnalTensorDiffusivity` corresponding only to the symmetric component, and another `GentMcWilliamsDiffusivity`(or something?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-972010093
https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-972010093:792,Modifiability,parameteriz,parameterization,792,"> Was just looking through this, and not sure if there is still room for comments from noobs (happy to be ignored). Would `tensor_diffusivity` be a good name - skewsymmetric seems a bit like saying that a T-junction is a left_right_turn. :). I see what you're saying @dhruvbalwada ... ! :-D Maybe `IsopycnalTensorDiffusivity` ? The thing is, when users build this closure they have the option only to set _coefficients_ (which may be constants or nonlinear functions of model variables) of two tensors --- an ""isopycnal rotation tensor"" that is symmetric and rotates a vector into the isopycnal plane, and another skew-symmetric or antisymmetric tensor. So the tensor is not general; it has a specific form... On the other hand I think we are leaning towards more substantial changes to this parameterization than would be covered by this name. So we could have one `IsopycnalTensorDiffusivity` corresponding only to the symmetric component, and another `GentMcWilliamsDiffusivity`(or something?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-972010093
https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-983330158:68,Availability,error,error,68,@glwagner could you run the `zonally_averaged_channel.jl`? I get an error I can't interpret. The error seems to be related to; https://github.com/CliMA/Oceananigans.jl/blob/c99e3e8b285d080016b84abc7c46cdb57ad823c1/validation/mesoscale_turbulence/zonally_averaged_channel.jl#L238-L273; because when I comment them out simulation runs!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-983330158
https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-983330158:97,Availability,error,error,97,@glwagner could you run the `zonally_averaged_channel.jl`? I get an error I can't interpret. The error seems to be related to; https://github.com/CliMA/Oceananigans.jl/blob/c99e3e8b285d080016b84abc7c46cdb57ad823c1/validation/mesoscale_turbulence/zonally_averaged_channel.jl#L238-L273; because when I comment them out simulation runs!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-983330158
https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-983330158:214,Security,validat,validation,214,@glwagner could you run the `zonally_averaged_channel.jl`? I get an error I can't interpret. The error seems to be related to; https://github.com/CliMA/Oceananigans.jl/blob/c99e3e8b285d080016b84abc7c46cdb57ad823c1/validation/mesoscale_turbulence/zonally_averaged_channel.jl#L238-L273; because when I comment them out simulation runs!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-983330158
https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-983957163:89,Availability,Error,Error,89,"Does this branch only work on 1.7? I'm getting. ```julia; (Oceananigans) pkg> resolve;  Error: Could not parse entry for `deps`;  @ Pkg.Types /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.6/Pkg/src/manifest.jl:150; ERROR: MethodError: no method matching get(::Pair{String, Any}, ::String, ::Nothing); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-983957163
https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-983957163:248,Availability,ERROR,ERROR,248,"Does this branch only work on 1.7? I'm getting. ```julia; (Oceananigans) pkg> resolve;  Error: Could not parse entry for `deps`;  @ Pkg.Types /Users/julia/buildbot/worker/package_macos64/build/usr/share/julia/stdlib/v1.6/Pkg/src/manifest.jl:150; ERROR: MethodError: no method matching get(::Pair{String, Any}, ::String, ::Nothing); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-983957163
https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-983989201:31,Availability,ERROR,ERROR,31,The tests also fail with. ```; ERROR: The manifest file you are using was most likely generated by a different version of Julia and is not compatible with this Julia version; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-983989201
https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-983989201:4,Testability,test,tests,4,The tests also fail with. ```; ERROR: The manifest file you are using was most likely generated by a different version of Julia and is not compatible with this Julia version; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-983989201
https://github.com/CliMA/Oceananigans.jl/issues/1995#issuecomment-930285553:32,Availability,error,error,32,Hmmm actually this GPU compiler error is different from the one in JuliaGPU/CUDA.jl#1169 although I could swear they were the same yesterday... Perhaps there are more issues (another reason to pin CUDA.jl)?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1995#issuecomment-930285553
https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933972103:145,Deployability,update,updates,145,"Well, we use `Manifest.toml` so that will pin CUDA to whatever version the manifest says so. So only think we shouldn't do is to merge a PR that updates the package version in Manifest.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933972103
https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237:3710,Availability,Down,Downloads,3710,ae029012] + Requires v1.1.3; [6038ab10] + Rotations v1.0.2; [1bc83da4] + SafeTestsets v0.0.1; [d496a93d] + SeawaterPolynomials v0.2.2; [276daf66] + SpecialFunctions v1.7.0; [aedffcd0] + Static v0.3.3; [90137ffa] + StaticArrays v1.2.13; [15972242] + StaticPermutations v0.3.0; [5e0ebb24] + Strided v1.1.2; [09ab397b] + StructArrays v0.6.3; [856f2bd8] + StructTypes v1.7.3; [3783bdb8] + TableTraits v1.0.1; [bd369af6] + Tables v1.6.0; [6aa5eb33] + TaylorSeries v0.10.13; [a759f4b9] + TimerOutputs v0.5.13; [3bb67fe8] + TranscodingStreams v0.9.6; [bc48ee85] + Tullio v0.3.2; [9d95972d] + TupleTools v1.3.0; [f5851436] + FFTW_jll v3.3.10+0; [0234f1f7] + HDF5_jll v1.12.0+1; [1d5cc7b8] + IntelOpenMP_jll v2018.0.3+2; [dad2f222] + LLVMExtra_jll v0.0.11+0; [856f044c] + MKL_jll v2021.1.1+2; [7cb0a576] + MPICH_jll v3.4.2+0; [9237b28f] + MicrosoftMPI_jll v10.1.3+0; [7243133f] + NetCDF_jll v400.702.400+0; [fe0851c0] + OpenMPI_jll v4.1.1+2; [458c3c95] + OpenSSL_jll v1.1.10+0; [efe28fd5] + OpenSpecFun_jll v0.5.5+0; [0dad84c5] + ArgTools; [56f22d72] + Artifacts; [2a0f44e3] + Base64; [ade2ca70] + Dates; [8bb1440f] + DelimitedFiles; [8ba89e20] + Distributed; [f43a241f] + Downloads; [b77e0a4c] + InteractiveUtils; [4af54fe1] + LazyArtifacts; [b27032c2] + LibCURL; [76f85450] + LibGit2; [8f399da3] + Libdl; [37e2e46d] + LinearAlgebra; [56ddb016] + Logging; [d6f4376e] + Markdown; [a63ad114] + Mmap; [ca575930] + NetworkOptions; [44cfe95a] + Pkg; [de0858da] + Printf; [3fa0cd96] + REPL; [9a3f8284] + Random; [ea8e919c] + SHA; [9e88b42a] + Serialization; [1a1011a3] + SharedArrays; [6462fe0b] + Sockets; [2f01184e] + SparseArrays; [10745b16] + Statistics; [fa267f1f] + TOML; [a4e569a6] + Tar; [8dfed614] + Test; [cf7118a7] + UUIDs; [4ec0a83e] + Unicode; [e66e0078] + CompilerSupportLibraries_jll; [deac9b47] + LibCURL_jll; [29816b5a] + LibSSH2_jll; [c8ffd9c3] + MbedTLS_jll; [14a3606d] + MozillaCACerts_jll; [05823500] + OpenLibm_jll; [83775a58] + Zlib_jll; [8e850ede] + nghttp2_jll; [3f19e933] + p7zip_jll; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237
https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237:22,Deployability,install,installs,22,"I'm pretty sure fresh installs don't necessarily reproduce the Manifest. I think unless you pin something, Pkg will try to get the latest set of packages that are still compatible. In fact, I don't think it's even recommended to add a Manifest with the github repo (at least not according to github: https://github.com/github/gitignore/blob/b0012e4930d0a8c350254a3caeedf7441ea286a3/Julia.gitignore#L20-L24). This is an example of a fresh Oceananigans install I just made. Notice it installed CUDA v3.4.2:. ```julia; (@v1.6) pkg> activate .; Activating new environment at `~/Dropbox/tests/fresh/Project.toml`. (fresh) pkg> add Oceananigans; Updating registry at `~/.julia/registries/General`; Resolving package versions...; Installed ChainRulesCore  v1.7.2; Installed Tables  v1.6.0; Installed Parsers  v2.0.5; Installed StaticArrays  v1.2.13; Updating `~/Dropbox/tests/fresh/Project.toml`; [9e8cae18] + Oceananigans v0.63.1; Updating `~/Dropbox/tests/fresh/Manifest.toml`; [621f4979] + AbstractFFTs v1.0.1; [79e6a3ab] + Adapt v3.3.1; [4fba245c] + ArrayInterface v3.1.33; [ab4f0b2a] + BFloat16s v0.1.0; [fa961155] + CEnum v0.4.1; [179af706] + CFTime v0.1.1; [052768ef] + CUDA v3.4.2; [72cfdca4] + CUDAKernels v0.3.0; [7057c7e9] + Cassette v0.3.9; [d360d2e6] + ChainRulesCore v1.7.2; [34da2185] + Compat v3.39.0; [a8cc5b0e] + Crayons v4.0.4; [7445602f] + CubedSphere v0.1.0; [9a962f9c] + DataAPI v1.9.0; [864edb3b] + DataStructures v0.18.10; [e2d170a0] + DataValueInterfaces v1.0.0; [b552c78f] + DiffRules v1.3.1; [ffbed154] + DocStringExtensions v0.8.5; [b305315f] + Elliptic v1.0.1; [e2ba6199] + ExprTools v0.1.6; [7a1cc6ca] + FFTW v1.4.5; [5789e2e9] + FileIO v1.11.1; [0c68f7d7] + GPUArrays v8.1.1; [61eb1bfa] + GPUCompiler v0.12.9; [c27321d9] + Glob v1.3.0; [615f187c] + IfElse v0.1.0; [92d709cd] + IrrationalConstants v0.1.0; [82899510] + IteratorInterfaceExtensions v1.0.0; [033835bb] + JLD2 v0.4.14; [692b3bcd] + JLLWrappers v1.3.0; [0f8b85d8] + JSON3 v1.9.1; [63c18a36] + Ke",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237
https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237:451,Deployability,install,install,451,"I'm pretty sure fresh installs don't necessarily reproduce the Manifest. I think unless you pin something, Pkg will try to get the latest set of packages that are still compatible. In fact, I don't think it's even recommended to add a Manifest with the github repo (at least not according to github: https://github.com/github/gitignore/blob/b0012e4930d0a8c350254a3caeedf7441ea286a3/Julia.gitignore#L20-L24). This is an example of a fresh Oceananigans install I just made. Notice it installed CUDA v3.4.2:. ```julia; (@v1.6) pkg> activate .; Activating new environment at `~/Dropbox/tests/fresh/Project.toml`. (fresh) pkg> add Oceananigans; Updating registry at `~/.julia/registries/General`; Resolving package versions...; Installed ChainRulesCore  v1.7.2; Installed Tables  v1.6.0; Installed Parsers  v2.0.5; Installed StaticArrays  v1.2.13; Updating `~/Dropbox/tests/fresh/Project.toml`; [9e8cae18] + Oceananigans v0.63.1; Updating `~/Dropbox/tests/fresh/Manifest.toml`; [621f4979] + AbstractFFTs v1.0.1; [79e6a3ab] + Adapt v3.3.1; [4fba245c] + ArrayInterface v3.1.33; [ab4f0b2a] + BFloat16s v0.1.0; [fa961155] + CEnum v0.4.1; [179af706] + CFTime v0.1.1; [052768ef] + CUDA v3.4.2; [72cfdca4] + CUDAKernels v0.3.0; [7057c7e9] + Cassette v0.3.9; [d360d2e6] + ChainRulesCore v1.7.2; [34da2185] + Compat v3.39.0; [a8cc5b0e] + Crayons v4.0.4; [7445602f] + CubedSphere v0.1.0; [9a962f9c] + DataAPI v1.9.0; [864edb3b] + DataStructures v0.18.10; [e2d170a0] + DataValueInterfaces v1.0.0; [b552c78f] + DiffRules v1.3.1; [ffbed154] + DocStringExtensions v0.8.5; [b305315f] + Elliptic v1.0.1; [e2ba6199] + ExprTools v0.1.6; [7a1cc6ca] + FFTW v1.4.5; [5789e2e9] + FileIO v1.11.1; [0c68f7d7] + GPUArrays v8.1.1; [61eb1bfa] + GPUCompiler v0.12.9; [c27321d9] + Glob v1.3.0; [615f187c] + IfElse v0.1.0; [92d709cd] + IrrationalConstants v0.1.0; [82899510] + IteratorInterfaceExtensions v1.0.0; [033835bb] + JLD2 v0.4.14; [692b3bcd] + JLLWrappers v1.3.0; [0f8b85d8] + JSON3 v1.9.1; [63c18a36] + Ke",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237
https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237:482,Deployability,install,installed,482,"I'm pretty sure fresh installs don't necessarily reproduce the Manifest. I think unless you pin something, Pkg will try to get the latest set of packages that are still compatible. In fact, I don't think it's even recommended to add a Manifest with the github repo (at least not according to github: https://github.com/github/gitignore/blob/b0012e4930d0a8c350254a3caeedf7441ea286a3/Julia.gitignore#L20-L24). This is an example of a fresh Oceananigans install I just made. Notice it installed CUDA v3.4.2:. ```julia; (@v1.6) pkg> activate .; Activating new environment at `~/Dropbox/tests/fresh/Project.toml`. (fresh) pkg> add Oceananigans; Updating registry at `~/.julia/registries/General`; Resolving package versions...; Installed ChainRulesCore  v1.7.2; Installed Tables  v1.6.0; Installed Parsers  v2.0.5; Installed StaticArrays  v1.2.13; Updating `~/Dropbox/tests/fresh/Project.toml`; [9e8cae18] + Oceananigans v0.63.1; Updating `~/Dropbox/tests/fresh/Manifest.toml`; [621f4979] + AbstractFFTs v1.0.1; [79e6a3ab] + Adapt v3.3.1; [4fba245c] + ArrayInterface v3.1.33; [ab4f0b2a] + BFloat16s v0.1.0; [fa961155] + CEnum v0.4.1; [179af706] + CFTime v0.1.1; [052768ef] + CUDA v3.4.2; [72cfdca4] + CUDAKernels v0.3.0; [7057c7e9] + Cassette v0.3.9; [d360d2e6] + ChainRulesCore v1.7.2; [34da2185] + Compat v3.39.0; [a8cc5b0e] + Crayons v4.0.4; [7445602f] + CubedSphere v0.1.0; [9a962f9c] + DataAPI v1.9.0; [864edb3b] + DataStructures v0.18.10; [e2d170a0] + DataValueInterfaces v1.0.0; [b552c78f] + DiffRules v1.3.1; [ffbed154] + DocStringExtensions v0.8.5; [b305315f] + Elliptic v1.0.1; [e2ba6199] + ExprTools v0.1.6; [7a1cc6ca] + FFTW v1.4.5; [5789e2e9] + FileIO v1.11.1; [0c68f7d7] + GPUArrays v8.1.1; [61eb1bfa] + GPUCompiler v0.12.9; [c27321d9] + Glob v1.3.0; [615f187c] + IfElse v0.1.0; [92d709cd] + IrrationalConstants v0.1.0; [82899510] + IteratorInterfaceExtensions v1.0.0; [033835bb] + JLD2 v0.4.14; [692b3bcd] + JLLWrappers v1.3.0; [0f8b85d8] + JSON3 v1.9.1; [63c18a36] + Ke",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237
https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237:723,Deployability,Install,Installed,723,"I'm pretty sure fresh installs don't necessarily reproduce the Manifest. I think unless you pin something, Pkg will try to get the latest set of packages that are still compatible. In fact, I don't think it's even recommended to add a Manifest with the github repo (at least not according to github: https://github.com/github/gitignore/blob/b0012e4930d0a8c350254a3caeedf7441ea286a3/Julia.gitignore#L20-L24). This is an example of a fresh Oceananigans install I just made. Notice it installed CUDA v3.4.2:. ```julia; (@v1.6) pkg> activate .; Activating new environment at `~/Dropbox/tests/fresh/Project.toml`. (fresh) pkg> add Oceananigans; Updating registry at `~/.julia/registries/General`; Resolving package versions...; Installed ChainRulesCore  v1.7.2; Installed Tables  v1.6.0; Installed Parsers  v2.0.5; Installed StaticArrays  v1.2.13; Updating `~/Dropbox/tests/fresh/Project.toml`; [9e8cae18] + Oceananigans v0.63.1; Updating `~/Dropbox/tests/fresh/Manifest.toml`; [621f4979] + AbstractFFTs v1.0.1; [79e6a3ab] + Adapt v3.3.1; [4fba245c] + ArrayInterface v3.1.33; [ab4f0b2a] + BFloat16s v0.1.0; [fa961155] + CEnum v0.4.1; [179af706] + CFTime v0.1.1; [052768ef] + CUDA v3.4.2; [72cfdca4] + CUDAKernels v0.3.0; [7057c7e9] + Cassette v0.3.9; [d360d2e6] + ChainRulesCore v1.7.2; [34da2185] + Compat v3.39.0; [a8cc5b0e] + Crayons v4.0.4; [7445602f] + CubedSphere v0.1.0; [9a962f9c] + DataAPI v1.9.0; [864edb3b] + DataStructures v0.18.10; [e2d170a0] + DataValueInterfaces v1.0.0; [b552c78f] + DiffRules v1.3.1; [ffbed154] + DocStringExtensions v0.8.5; [b305315f] + Elliptic v1.0.1; [e2ba6199] + ExprTools v0.1.6; [7a1cc6ca] + FFTW v1.4.5; [5789e2e9] + FileIO v1.11.1; [0c68f7d7] + GPUArrays v8.1.1; [61eb1bfa] + GPUCompiler v0.12.9; [c27321d9] + Glob v1.3.0; [615f187c] + IfElse v0.1.0; [92d709cd] + IrrationalConstants v0.1.0; [82899510] + IteratorInterfaceExtensions v1.0.0; [033835bb] + JLD2 v0.4.14; [692b3bcd] + JLLWrappers v1.3.0; [0f8b85d8] + JSON3 v1.9.1; [63c18a36] + Ke",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237
https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237:758,Deployability,Install,Installed,758,"I'm pretty sure fresh installs don't necessarily reproduce the Manifest. I think unless you pin something, Pkg will try to get the latest set of packages that are still compatible. In fact, I don't think it's even recommended to add a Manifest with the github repo (at least not according to github: https://github.com/github/gitignore/blob/b0012e4930d0a8c350254a3caeedf7441ea286a3/Julia.gitignore#L20-L24). This is an example of a fresh Oceananigans install I just made. Notice it installed CUDA v3.4.2:. ```julia; (@v1.6) pkg> activate .; Activating new environment at `~/Dropbox/tests/fresh/Project.toml`. (fresh) pkg> add Oceananigans; Updating registry at `~/.julia/registries/General`; Resolving package versions...; Installed ChainRulesCore  v1.7.2; Installed Tables  v1.6.0; Installed Parsers  v2.0.5; Installed StaticArrays  v1.2.13; Updating `~/Dropbox/tests/fresh/Project.toml`; [9e8cae18] + Oceananigans v0.63.1; Updating `~/Dropbox/tests/fresh/Manifest.toml`; [621f4979] + AbstractFFTs v1.0.1; [79e6a3ab] + Adapt v3.3.1; [4fba245c] + ArrayInterface v3.1.33; [ab4f0b2a] + BFloat16s v0.1.0; [fa961155] + CEnum v0.4.1; [179af706] + CFTime v0.1.1; [052768ef] + CUDA v3.4.2; [72cfdca4] + CUDAKernels v0.3.0; [7057c7e9] + Cassette v0.3.9; [d360d2e6] + ChainRulesCore v1.7.2; [34da2185] + Compat v3.39.0; [a8cc5b0e] + Crayons v4.0.4; [7445602f] + CubedSphere v0.1.0; [9a962f9c] + DataAPI v1.9.0; [864edb3b] + DataStructures v0.18.10; [e2d170a0] + DataValueInterfaces v1.0.0; [b552c78f] + DiffRules v1.3.1; [ffbed154] + DocStringExtensions v0.8.5; [b305315f] + Elliptic v1.0.1; [e2ba6199] + ExprTools v0.1.6; [7a1cc6ca] + FFTW v1.4.5; [5789e2e9] + FileIO v1.11.1; [0c68f7d7] + GPUArrays v8.1.1; [61eb1bfa] + GPUCompiler v0.12.9; [c27321d9] + Glob v1.3.0; [615f187c] + IfElse v0.1.0; [92d709cd] + IrrationalConstants v0.1.0; [82899510] + IteratorInterfaceExtensions v1.0.0; [033835bb] + JLD2 v0.4.14; [692b3bcd] + JLLWrappers v1.3.0; [0f8b85d8] + JSON3 v1.9.1; [63c18a36] + Ke",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237
https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237:793,Deployability,Install,Installed,793,"I'm pretty sure fresh installs don't necessarily reproduce the Manifest. I think unless you pin something, Pkg will try to get the latest set of packages that are still compatible. In fact, I don't think it's even recommended to add a Manifest with the github repo (at least not according to github: https://github.com/github/gitignore/blob/b0012e4930d0a8c350254a3caeedf7441ea286a3/Julia.gitignore#L20-L24). This is an example of a fresh Oceananigans install I just made. Notice it installed CUDA v3.4.2:. ```julia; (@v1.6) pkg> activate .; Activating new environment at `~/Dropbox/tests/fresh/Project.toml`. (fresh) pkg> add Oceananigans; Updating registry at `~/.julia/registries/General`; Resolving package versions...; Installed ChainRulesCore  v1.7.2; Installed Tables  v1.6.0; Installed Parsers  v2.0.5; Installed StaticArrays  v1.2.13; Updating `~/Dropbox/tests/fresh/Project.toml`; [9e8cae18] + Oceananigans v0.63.1; Updating `~/Dropbox/tests/fresh/Manifest.toml`; [621f4979] + AbstractFFTs v1.0.1; [79e6a3ab] + Adapt v3.3.1; [4fba245c] + ArrayInterface v3.1.33; [ab4f0b2a] + BFloat16s v0.1.0; [fa961155] + CEnum v0.4.1; [179af706] + CFTime v0.1.1; [052768ef] + CUDA v3.4.2; [72cfdca4] + CUDAKernels v0.3.0; [7057c7e9] + Cassette v0.3.9; [d360d2e6] + ChainRulesCore v1.7.2; [34da2185] + Compat v3.39.0; [a8cc5b0e] + Crayons v4.0.4; [7445602f] + CubedSphere v0.1.0; [9a962f9c] + DataAPI v1.9.0; [864edb3b] + DataStructures v0.18.10; [e2d170a0] + DataValueInterfaces v1.0.0; [b552c78f] + DiffRules v1.3.1; [ffbed154] + DocStringExtensions v0.8.5; [b305315f] + Elliptic v1.0.1; [e2ba6199] + ExprTools v0.1.6; [7a1cc6ca] + FFTW v1.4.5; [5789e2e9] + FileIO v1.11.1; [0c68f7d7] + GPUArrays v8.1.1; [61eb1bfa] + GPUCompiler v0.12.9; [c27321d9] + Glob v1.3.0; [615f187c] + IfElse v0.1.0; [92d709cd] + IrrationalConstants v0.1.0; [82899510] + IteratorInterfaceExtensions v1.0.0; [033835bb] + JLD2 v0.4.14; [692b3bcd] + JLLWrappers v1.3.0; [0f8b85d8] + JSON3 v1.9.1; [63c18a36] + Ke",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237
https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237:828,Deployability,Install,Installed,828,"I'm pretty sure fresh installs don't necessarily reproduce the Manifest. I think unless you pin something, Pkg will try to get the latest set of packages that are still compatible. In fact, I don't think it's even recommended to add a Manifest with the github repo (at least not according to github: https://github.com/github/gitignore/blob/b0012e4930d0a8c350254a3caeedf7441ea286a3/Julia.gitignore#L20-L24). This is an example of a fresh Oceananigans install I just made. Notice it installed CUDA v3.4.2:. ```julia; (@v1.6) pkg> activate .; Activating new environment at `~/Dropbox/tests/fresh/Project.toml`. (fresh) pkg> add Oceananigans; Updating registry at `~/.julia/registries/General`; Resolving package versions...; Installed ChainRulesCore  v1.7.2; Installed Tables  v1.6.0; Installed Parsers  v2.0.5; Installed StaticArrays  v1.2.13; Updating `~/Dropbox/tests/fresh/Project.toml`; [9e8cae18] + Oceananigans v0.63.1; Updating `~/Dropbox/tests/fresh/Manifest.toml`; [621f4979] + AbstractFFTs v1.0.1; [79e6a3ab] + Adapt v3.3.1; [4fba245c] + ArrayInterface v3.1.33; [ab4f0b2a] + BFloat16s v0.1.0; [fa961155] + CEnum v0.4.1; [179af706] + CFTime v0.1.1; [052768ef] + CUDA v3.4.2; [72cfdca4] + CUDAKernels v0.3.0; [7057c7e9] + Cassette v0.3.9; [d360d2e6] + ChainRulesCore v1.7.2; [34da2185] + Compat v3.39.0; [a8cc5b0e] + Crayons v4.0.4; [7445602f] + CubedSphere v0.1.0; [9a962f9c] + DataAPI v1.9.0; [864edb3b] + DataStructures v0.18.10; [e2d170a0] + DataValueInterfaces v1.0.0; [b552c78f] + DiffRules v1.3.1; [ffbed154] + DocStringExtensions v0.8.5; [b305315f] + Elliptic v1.0.1; [e2ba6199] + ExprTools v0.1.6; [7a1cc6ca] + FFTW v1.4.5; [5789e2e9] + FileIO v1.11.1; [0c68f7d7] + GPUArrays v8.1.1; [61eb1bfa] + GPUCompiler v0.12.9; [c27321d9] + Glob v1.3.0; [615f187c] + IfElse v0.1.0; [92d709cd] + IrrationalConstants v0.1.0; [82899510] + IteratorInterfaceExtensions v1.0.0; [033835bb] + JLD2 v0.4.14; [692b3bcd] + JLLWrappers v1.3.0; [0f8b85d8] + JSON3 v1.9.1; [63c18a36] + Ke",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237
https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237:1041,Energy Efficiency,Adapt,Adapt,1041,"necessarily reproduce the Manifest. I think unless you pin something, Pkg will try to get the latest set of packages that are still compatible. In fact, I don't think it's even recommended to add a Manifest with the github repo (at least not according to github: https://github.com/github/gitignore/blob/b0012e4930d0a8c350254a3caeedf7441ea286a3/Julia.gitignore#L20-L24). This is an example of a fresh Oceananigans install I just made. Notice it installed CUDA v3.4.2:. ```julia; (@v1.6) pkg> activate .; Activating new environment at `~/Dropbox/tests/fresh/Project.toml`. (fresh) pkg> add Oceananigans; Updating registry at `~/.julia/registries/General`; Resolving package versions...; Installed ChainRulesCore  v1.7.2; Installed Tables  v1.6.0; Installed Parsers  v2.0.5; Installed StaticArrays  v1.2.13; Updating `~/Dropbox/tests/fresh/Project.toml`; [9e8cae18] + Oceananigans v0.63.1; Updating `~/Dropbox/tests/fresh/Manifest.toml`; [621f4979] + AbstractFFTs v1.0.1; [79e6a3ab] + Adapt v3.3.1; [4fba245c] + ArrayInterface v3.1.33; [ab4f0b2a] + BFloat16s v0.1.0; [fa961155] + CEnum v0.4.1; [179af706] + CFTime v0.1.1; [052768ef] + CUDA v3.4.2; [72cfdca4] + CUDAKernels v0.3.0; [7057c7e9] + Cassette v0.3.9; [d360d2e6] + ChainRulesCore v1.7.2; [34da2185] + Compat v3.39.0; [a8cc5b0e] + Crayons v4.0.4; [7445602f] + CubedSphere v0.1.0; [9a962f9c] + DataAPI v1.9.0; [864edb3b] + DataStructures v0.18.10; [e2d170a0] + DataValueInterfaces v1.0.0; [b552c78f] + DiffRules v1.3.1; [ffbed154] + DocStringExtensions v0.8.5; [b305315f] + Elliptic v1.0.1; [e2ba6199] + ExprTools v0.1.6; [7a1cc6ca] + FFTW v1.4.5; [5789e2e9] + FileIO v1.11.1; [0c68f7d7] + GPUArrays v8.1.1; [61eb1bfa] + GPUCompiler v0.12.9; [c27321d9] + Glob v1.3.0; [615f187c] + IfElse v0.1.0; [92d709cd] + IrrationalConstants v0.1.0; [82899510] + IteratorInterfaceExtensions v1.0.0; [033835bb] + JLD2 v0.4.14; [692b3bcd] + JLLWrappers v1.3.0; [0f8b85d8] + JSON3 v1.9.1; [63c18a36] + KernelAbstractions v0.7.0; [929cbde3] +",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237
https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237:1041,Modifiability,Adapt,Adapt,1041,"necessarily reproduce the Manifest. I think unless you pin something, Pkg will try to get the latest set of packages that are still compatible. In fact, I don't think it's even recommended to add a Manifest with the github repo (at least not according to github: https://github.com/github/gitignore/blob/b0012e4930d0a8c350254a3caeedf7441ea286a3/Julia.gitignore#L20-L24). This is an example of a fresh Oceananigans install I just made. Notice it installed CUDA v3.4.2:. ```julia; (@v1.6) pkg> activate .; Activating new environment at `~/Dropbox/tests/fresh/Project.toml`. (fresh) pkg> add Oceananigans; Updating registry at `~/.julia/registries/General`; Resolving package versions...; Installed ChainRulesCore  v1.7.2; Installed Tables  v1.6.0; Installed Parsers  v2.0.5; Installed StaticArrays  v1.2.13; Updating `~/Dropbox/tests/fresh/Project.toml`; [9e8cae18] + Oceananigans v0.63.1; Updating `~/Dropbox/tests/fresh/Manifest.toml`; [621f4979] + AbstractFFTs v1.0.1; [79e6a3ab] + Adapt v3.3.1; [4fba245c] + ArrayInterface v3.1.33; [ab4f0b2a] + BFloat16s v0.1.0; [fa961155] + CEnum v0.4.1; [179af706] + CFTime v0.1.1; [052768ef] + CUDA v3.4.2; [72cfdca4] + CUDAKernels v0.3.0; [7057c7e9] + Cassette v0.3.9; [d360d2e6] + ChainRulesCore v1.7.2; [34da2185] + Compat v3.39.0; [a8cc5b0e] + Crayons v4.0.4; [7445602f] + CubedSphere v0.1.0; [9a962f9c] + DataAPI v1.9.0; [864edb3b] + DataStructures v0.18.10; [e2d170a0] + DataValueInterfaces v1.0.0; [b552c78f] + DiffRules v1.3.1; [ffbed154] + DocStringExtensions v0.8.5; [b305315f] + Elliptic v1.0.1; [e2ba6199] + ExprTools v0.1.6; [7a1cc6ca] + FFTW v1.4.5; [5789e2e9] + FileIO v1.11.1; [0c68f7d7] + GPUArrays v8.1.1; [61eb1bfa] + GPUCompiler v0.12.9; [c27321d9] + Glob v1.3.0; [615f187c] + IfElse v0.1.0; [92d709cd] + IrrationalConstants v0.1.0; [82899510] + IteratorInterfaceExtensions v1.0.0; [033835bb] + JLD2 v0.4.14; [692b3bcd] + JLLWrappers v1.3.0; [0f8b85d8] + JSON3 v1.9.1; [63c18a36] + KernelAbstractions v0.7.0; [929cbde3] +",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237
https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237:2619,Safety,Safe,SafeTestsets,2619,prTools v0.1.6; [7a1cc6ca] + FFTW v1.4.5; [5789e2e9] + FileIO v1.11.1; [0c68f7d7] + GPUArrays v8.1.1; [61eb1bfa] + GPUCompiler v0.12.9; [c27321d9] + Glob v1.3.0; [615f187c] + IfElse v0.1.0; [92d709cd] + IrrationalConstants v0.1.0; [82899510] + IteratorInterfaceExtensions v1.0.0; [033835bb] + JLD2 v0.4.14; [692b3bcd] + JLLWrappers v1.3.0; [0f8b85d8] + JSON3 v1.9.1; [63c18a36] + KernelAbstractions v0.7.0; [929cbde3] + LLVM v4.6.0; [2ab3a3ac] + LogExpFunctions v0.3.3; [da04e1cc] + MPI v0.19.0; [1914dd2f] + MacroTools v0.5.8; [85f8d34a] + NCDatasets v0.11.7; [77ba4419] + NaNMath v0.3.5; [9e8cae18] + Oceananigans v0.63.1; [6fe1bfb0] + OffsetArrays v1.10.7; [bac558e1] + OrderedCollections v1.4.1; [69de0a69] + Parsers v2.0.5; [0e08944d] + PencilArrays v0.10.0; [4a48f351] + PencilFFTs v0.12.5; [21216c6a] + Preferences v1.2.2; [74087812] + Random123 v1.4.2; [e6cf234a] + RandomNumbers v1.5.3; [189a3867] + Reexport v1.2.2; [ae029012] + Requires v1.1.3; [6038ab10] + Rotations v1.0.2; [1bc83da4] + SafeTestsets v0.0.1; [d496a93d] + SeawaterPolynomials v0.2.2; [276daf66] + SpecialFunctions v1.7.0; [aedffcd0] + Static v0.3.3; [90137ffa] + StaticArrays v1.2.13; [15972242] + StaticPermutations v0.3.0; [5e0ebb24] + Strided v1.1.2; [09ab397b] + StructArrays v0.6.3; [856f2bd8] + StructTypes v1.7.3; [3783bdb8] + TableTraits v1.0.1; [bd369af6] + Tables v1.6.0; [6aa5eb33] + TaylorSeries v0.10.13; [a759f4b9] + TimerOutputs v0.5.13; [3bb67fe8] + TranscodingStreams v0.9.6; [bc48ee85] + Tullio v0.3.2; [9d95972d] + TupleTools v1.3.0; [f5851436] + FFTW_jll v3.3.10+0; [0234f1f7] + HDF5_jll v1.12.0+1; [1d5cc7b8] + IntelOpenMP_jll v2018.0.3+2; [dad2f222] + LLVMExtra_jll v0.0.11+0; [856f044c] + MKL_jll v2021.1.1+2; [7cb0a576] + MPICH_jll v3.4.2+0; [9237b28f] + MicrosoftMPI_jll v10.1.3+0; [7243133f] + NetCDF_jll v400.702.400+0; [fe0851c0] + OpenMPI_jll v4.1.1+2; [458c3c95] + OpenSSL_jll v1.1.10+0; [efe28fd5] + OpenSpecFun_jll v0.5.5+0; [0dad84c5] + ArgTools; [56f22d72] + Artifacts; [2a0f44e3] + Base6,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237
https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237:582,Testability,test,tests,582,"I'm pretty sure fresh installs don't necessarily reproduce the Manifest. I think unless you pin something, Pkg will try to get the latest set of packages that are still compatible. In fact, I don't think it's even recommended to add a Manifest with the github repo (at least not according to github: https://github.com/github/gitignore/blob/b0012e4930d0a8c350254a3caeedf7441ea286a3/Julia.gitignore#L20-L24). This is an example of a fresh Oceananigans install I just made. Notice it installed CUDA v3.4.2:. ```julia; (@v1.6) pkg> activate .; Activating new environment at `~/Dropbox/tests/fresh/Project.toml`. (fresh) pkg> add Oceananigans; Updating registry at `~/.julia/registries/General`; Resolving package versions...; Installed ChainRulesCore  v1.7.2; Installed Tables  v1.6.0; Installed Parsers  v2.0.5; Installed StaticArrays  v1.2.13; Updating `~/Dropbox/tests/fresh/Project.toml`; [9e8cae18] + Oceananigans v0.63.1; Updating `~/Dropbox/tests/fresh/Manifest.toml`; [621f4979] + AbstractFFTs v1.0.1; [79e6a3ab] + Adapt v3.3.1; [4fba245c] + ArrayInterface v3.1.33; [ab4f0b2a] + BFloat16s v0.1.0; [fa961155] + CEnum v0.4.1; [179af706] + CFTime v0.1.1; [052768ef] + CUDA v3.4.2; [72cfdca4] + CUDAKernels v0.3.0; [7057c7e9] + Cassette v0.3.9; [d360d2e6] + ChainRulesCore v1.7.2; [34da2185] + Compat v3.39.0; [a8cc5b0e] + Crayons v4.0.4; [7445602f] + CubedSphere v0.1.0; [9a962f9c] + DataAPI v1.9.0; [864edb3b] + DataStructures v0.18.10; [e2d170a0] + DataValueInterfaces v1.0.0; [b552c78f] + DiffRules v1.3.1; [ffbed154] + DocStringExtensions v0.8.5; [b305315f] + Elliptic v1.0.1; [e2ba6199] + ExprTools v0.1.6; [7a1cc6ca] + FFTW v1.4.5; [5789e2e9] + FileIO v1.11.1; [0c68f7d7] + GPUArrays v8.1.1; [61eb1bfa] + GPUCompiler v0.12.9; [c27321d9] + Glob v1.3.0; [615f187c] + IfElse v0.1.0; [92d709cd] + IrrationalConstants v0.1.0; [82899510] + IteratorInterfaceExtensions v1.0.0; [033835bb] + JLD2 v0.4.14; [692b3bcd] + JLLWrappers v1.3.0; [0f8b85d8] + JSON3 v1.9.1; [63c18a36] + Ke",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237
https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237:884,Testability,test,tests,884,"I'm pretty sure fresh installs don't necessarily reproduce the Manifest. I think unless you pin something, Pkg will try to get the latest set of packages that are still compatible. In fact, I don't think it's even recommended to add a Manifest with the github repo (at least not according to github: https://github.com/github/gitignore/blob/b0012e4930d0a8c350254a3caeedf7441ea286a3/Julia.gitignore#L20-L24). This is an example of a fresh Oceananigans install I just made. Notice it installed CUDA v3.4.2:. ```julia; (@v1.6) pkg> activate .; Activating new environment at `~/Dropbox/tests/fresh/Project.toml`. (fresh) pkg> add Oceananigans; Updating registry at `~/.julia/registries/General`; Resolving package versions...; Installed ChainRulesCore  v1.7.2; Installed Tables  v1.6.0; Installed Parsers  v2.0.5; Installed StaticArrays  v1.2.13; Updating `~/Dropbox/tests/fresh/Project.toml`; [9e8cae18] + Oceananigans v0.63.1; Updating `~/Dropbox/tests/fresh/Manifest.toml`; [621f4979] + AbstractFFTs v1.0.1; [79e6a3ab] + Adapt v3.3.1; [4fba245c] + ArrayInterface v3.1.33; [ab4f0b2a] + BFloat16s v0.1.0; [fa961155] + CEnum v0.4.1; [179af706] + CFTime v0.1.1; [052768ef] + CUDA v3.4.2; [72cfdca4] + CUDAKernels v0.3.0; [7057c7e9] + Cassette v0.3.9; [d360d2e6] + ChainRulesCore v1.7.2; [34da2185] + Compat v3.39.0; [a8cc5b0e] + Crayons v4.0.4; [7445602f] + CubedSphere v0.1.0; [9a962f9c] + DataAPI v1.9.0; [864edb3b] + DataStructures v0.18.10; [e2d170a0] + DataValueInterfaces v1.0.0; [b552c78f] + DiffRules v1.3.1; [ffbed154] + DocStringExtensions v0.8.5; [b305315f] + Elliptic v1.0.1; [e2ba6199] + ExprTools v0.1.6; [7a1cc6ca] + FFTW v1.4.5; [5789e2e9] + FileIO v1.11.1; [0c68f7d7] + GPUArrays v8.1.1; [61eb1bfa] + GPUCompiler v0.12.9; [c27321d9] + Glob v1.3.0; [615f187c] + IfElse v0.1.0; [92d709cd] + IrrationalConstants v0.1.0; [82899510] + IteratorInterfaceExtensions v1.0.0; [033835bb] + JLD2 v0.4.14; [692b3bcd] + JLLWrappers v1.3.0; [0f8b85d8] + JSON3 v1.9.1; [63c18a36] + Ke",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237
https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237:966,Testability,test,tests,966,"I'm pretty sure fresh installs don't necessarily reproduce the Manifest. I think unless you pin something, Pkg will try to get the latest set of packages that are still compatible. In fact, I don't think it's even recommended to add a Manifest with the github repo (at least not according to github: https://github.com/github/gitignore/blob/b0012e4930d0a8c350254a3caeedf7441ea286a3/Julia.gitignore#L20-L24). This is an example of a fresh Oceananigans install I just made. Notice it installed CUDA v3.4.2:. ```julia; (@v1.6) pkg> activate .; Activating new environment at `~/Dropbox/tests/fresh/Project.toml`. (fresh) pkg> add Oceananigans; Updating registry at `~/.julia/registries/General`; Resolving package versions...; Installed ChainRulesCore  v1.7.2; Installed Tables  v1.6.0; Installed Parsers  v2.0.5; Installed StaticArrays  v1.2.13; Updating `~/Dropbox/tests/fresh/Project.toml`; [9e8cae18] + Oceananigans v0.63.1; Updating `~/Dropbox/tests/fresh/Manifest.toml`; [621f4979] + AbstractFFTs v1.0.1; [79e6a3ab] + Adapt v3.3.1; [4fba245c] + ArrayInterface v3.1.33; [ab4f0b2a] + BFloat16s v0.1.0; [fa961155] + CEnum v0.4.1; [179af706] + CFTime v0.1.1; [052768ef] + CUDA v3.4.2; [72cfdca4] + CUDAKernels v0.3.0; [7057c7e9] + Cassette v0.3.9; [d360d2e6] + ChainRulesCore v1.7.2; [34da2185] + Compat v3.39.0; [a8cc5b0e] + Crayons v4.0.4; [7445602f] + CubedSphere v0.1.0; [9a962f9c] + DataAPI v1.9.0; [864edb3b] + DataStructures v0.18.10; [e2d170a0] + DataValueInterfaces v1.0.0; [b552c78f] + DiffRules v1.3.1; [ffbed154] + DocStringExtensions v0.8.5; [b305315f] + Elliptic v1.0.1; [e2ba6199] + ExprTools v0.1.6; [7a1cc6ca] + FFTW v1.4.5; [5789e2e9] + FileIO v1.11.1; [0c68f7d7] + GPUArrays v8.1.1; [61eb1bfa] + GPUCompiler v0.12.9; [c27321d9] + Glob v1.3.0; [615f187c] + IfElse v0.1.0; [92d709cd] + IrrationalConstants v0.1.0; [82899510] + IteratorInterfaceExtensions v1.0.0; [033835bb] + JLD2 v0.4.14; [692b3bcd] + JLLWrappers v1.3.0; [0f8b85d8] + JSON3 v1.9.1; [63c18a36] + Ke",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237
https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237:2065,Testability,Log,LogExpFunctions,2065,+ ArrayInterface v3.1.33; [ab4f0b2a] + BFloat16s v0.1.0; [fa961155] + CEnum v0.4.1; [179af706] + CFTime v0.1.1; [052768ef] + CUDA v3.4.2; [72cfdca4] + CUDAKernels v0.3.0; [7057c7e9] + Cassette v0.3.9; [d360d2e6] + ChainRulesCore v1.7.2; [34da2185] + Compat v3.39.0; [a8cc5b0e] + Crayons v4.0.4; [7445602f] + CubedSphere v0.1.0; [9a962f9c] + DataAPI v1.9.0; [864edb3b] + DataStructures v0.18.10; [e2d170a0] + DataValueInterfaces v1.0.0; [b552c78f] + DiffRules v1.3.1; [ffbed154] + DocStringExtensions v0.8.5; [b305315f] + Elliptic v1.0.1; [e2ba6199] + ExprTools v0.1.6; [7a1cc6ca] + FFTW v1.4.5; [5789e2e9] + FileIO v1.11.1; [0c68f7d7] + GPUArrays v8.1.1; [61eb1bfa] + GPUCompiler v0.12.9; [c27321d9] + Glob v1.3.0; [615f187c] + IfElse v0.1.0; [92d709cd] + IrrationalConstants v0.1.0; [82899510] + IteratorInterfaceExtensions v1.0.0; [033835bb] + JLD2 v0.4.14; [692b3bcd] + JLLWrappers v1.3.0; [0f8b85d8] + JSON3 v1.9.1; [63c18a36] + KernelAbstractions v0.7.0; [929cbde3] + LLVM v4.6.0; [2ab3a3ac] + LogExpFunctions v0.3.3; [da04e1cc] + MPI v0.19.0; [1914dd2f] + MacroTools v0.5.8; [85f8d34a] + NCDatasets v0.11.7; [77ba4419] + NaNMath v0.3.5; [9e8cae18] + Oceananigans v0.63.1; [6fe1bfb0] + OffsetArrays v1.10.7; [bac558e1] + OrderedCollections v1.4.1; [69de0a69] + Parsers v2.0.5; [0e08944d] + PencilArrays v0.10.0; [4a48f351] + PencilFFTs v0.12.5; [21216c6a] + Preferences v1.2.2; [74087812] + Random123 v1.4.2; [e6cf234a] + RandomNumbers v1.5.3; [189a3867] + Reexport v1.2.2; [ae029012] + Requires v1.1.3; [6038ab10] + Rotations v1.0.2; [1bc83da4] + SafeTestsets v0.0.1; [d496a93d] + SeawaterPolynomials v0.2.2; [276daf66] + SpecialFunctions v1.7.0; [aedffcd0] + Static v0.3.3; [90137ffa] + StaticArrays v1.2.13; [15972242] + StaticPermutations v0.3.0; [5e0ebb24] + Strided v1.1.2; [09ab397b] + StructArrays v0.6.3; [856f2bd8] + StructTypes v1.7.3; [3783bdb8] + TableTraits v1.0.1; [bd369af6] + Tables v1.6.0; [6aa5eb33] + TaylorSeries v0.10.13; [a759f4b9] + TimerOutputs v0.5.13; [3bb67fe8] + Tran,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237
https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237:3885,Testability,Log,Logging,3885,ae029012] + Requires v1.1.3; [6038ab10] + Rotations v1.0.2; [1bc83da4] + SafeTestsets v0.0.1; [d496a93d] + SeawaterPolynomials v0.2.2; [276daf66] + SpecialFunctions v1.7.0; [aedffcd0] + Static v0.3.3; [90137ffa] + StaticArrays v1.2.13; [15972242] + StaticPermutations v0.3.0; [5e0ebb24] + Strided v1.1.2; [09ab397b] + StructArrays v0.6.3; [856f2bd8] + StructTypes v1.7.3; [3783bdb8] + TableTraits v1.0.1; [bd369af6] + Tables v1.6.0; [6aa5eb33] + TaylorSeries v0.10.13; [a759f4b9] + TimerOutputs v0.5.13; [3bb67fe8] + TranscodingStreams v0.9.6; [bc48ee85] + Tullio v0.3.2; [9d95972d] + TupleTools v1.3.0; [f5851436] + FFTW_jll v3.3.10+0; [0234f1f7] + HDF5_jll v1.12.0+1; [1d5cc7b8] + IntelOpenMP_jll v2018.0.3+2; [dad2f222] + LLVMExtra_jll v0.0.11+0; [856f044c] + MKL_jll v2021.1.1+2; [7cb0a576] + MPICH_jll v3.4.2+0; [9237b28f] + MicrosoftMPI_jll v10.1.3+0; [7243133f] + NetCDF_jll v400.702.400+0; [fe0851c0] + OpenMPI_jll v4.1.1+2; [458c3c95] + OpenSSL_jll v1.1.10+0; [efe28fd5] + OpenSpecFun_jll v0.5.5+0; [0dad84c5] + ArgTools; [56f22d72] + Artifacts; [2a0f44e3] + Base64; [ade2ca70] + Dates; [8bb1440f] + DelimitedFiles; [8ba89e20] + Distributed; [f43a241f] + Downloads; [b77e0a4c] + InteractiveUtils; [4af54fe1] + LazyArtifacts; [b27032c2] + LibCURL; [76f85450] + LibGit2; [8f399da3] + Libdl; [37e2e46d] + LinearAlgebra; [56ddb016] + Logging; [d6f4376e] + Markdown; [a63ad114] + Mmap; [ca575930] + NetworkOptions; [44cfe95a] + Pkg; [de0858da] + Printf; [3fa0cd96] + REPL; [9a3f8284] + Random; [ea8e919c] + SHA; [9e88b42a] + Serialization; [1a1011a3] + SharedArrays; [6462fe0b] + Sockets; [2f01184e] + SparseArrays; [10745b16] + Statistics; [fa267f1f] + TOML; [a4e569a6] + Tar; [8dfed614] + Test; [cf7118a7] + UUIDs; [4ec0a83e] + Unicode; [e66e0078] + CompilerSupportLibraries_jll; [deac9b47] + LibCURL_jll; [29816b5a] + LibSSH2_jll; [c8ffd9c3] + MbedTLS_jll; [14a3606d] + MozillaCACerts_jll; [05823500] + OpenLibm_jll; [83775a58] + Zlib_jll; [8e850ede] + nghttp2_jll; [3f19e933] + p7zip_jll; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237
https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237:4241,Testability,Test,Test,4241,ae029012] + Requires v1.1.3; [6038ab10] + Rotations v1.0.2; [1bc83da4] + SafeTestsets v0.0.1; [d496a93d] + SeawaterPolynomials v0.2.2; [276daf66] + SpecialFunctions v1.7.0; [aedffcd0] + Static v0.3.3; [90137ffa] + StaticArrays v1.2.13; [15972242] + StaticPermutations v0.3.0; [5e0ebb24] + Strided v1.1.2; [09ab397b] + StructArrays v0.6.3; [856f2bd8] + StructTypes v1.7.3; [3783bdb8] + TableTraits v1.0.1; [bd369af6] + Tables v1.6.0; [6aa5eb33] + TaylorSeries v0.10.13; [a759f4b9] + TimerOutputs v0.5.13; [3bb67fe8] + TranscodingStreams v0.9.6; [bc48ee85] + Tullio v0.3.2; [9d95972d] + TupleTools v1.3.0; [f5851436] + FFTW_jll v3.3.10+0; [0234f1f7] + HDF5_jll v1.12.0+1; [1d5cc7b8] + IntelOpenMP_jll v2018.0.3+2; [dad2f222] + LLVMExtra_jll v0.0.11+0; [856f044c] + MKL_jll v2021.1.1+2; [7cb0a576] + MPICH_jll v3.4.2+0; [9237b28f] + MicrosoftMPI_jll v10.1.3+0; [7243133f] + NetCDF_jll v400.702.400+0; [fe0851c0] + OpenMPI_jll v4.1.1+2; [458c3c95] + OpenSSL_jll v1.1.10+0; [efe28fd5] + OpenSpecFun_jll v0.5.5+0; [0dad84c5] + ArgTools; [56f22d72] + Artifacts; [2a0f44e3] + Base64; [ade2ca70] + Dates; [8bb1440f] + DelimitedFiles; [8ba89e20] + Distributed; [f43a241f] + Downloads; [b77e0a4c] + InteractiveUtils; [4af54fe1] + LazyArtifacts; [b27032c2] + LibCURL; [76f85450] + LibGit2; [8f399da3] + Libdl; [37e2e46d] + LinearAlgebra; [56ddb016] + Logging; [d6f4376e] + Markdown; [a63ad114] + Mmap; [ca575930] + NetworkOptions; [44cfe95a] + Pkg; [de0858da] + Printf; [3fa0cd96] + REPL; [9a3f8284] + Random; [ea8e919c] + SHA; [9e88b42a] + Serialization; [1a1011a3] + SharedArrays; [6462fe0b] + Sockets; [2f01184e] + SparseArrays; [10745b16] + Statistics; [fa267f1f] + TOML; [a4e569a6] + Tar; [8dfed614] + Test; [cf7118a7] + UUIDs; [4ec0a83e] + Unicode; [e66e0078] + CompilerSupportLibraries_jll; [deac9b47] + LibCURL_jll; [29816b5a] + LibSSH2_jll; [c8ffd9c3] + MbedTLS_jll; [14a3606d] + MozillaCACerts_jll; [05823500] + OpenLibm_jll; [83775a58] + Zlib_jll; [8e850ede] + nghttp2_jll; [3f19e933] + p7zip_jll; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237
https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-933991833:12,Deployability,patch,patch,12,Also bump a patch release.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-933991833
https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-933991833:18,Deployability,release,release,18,Also bump a patch release.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-933991833
https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-934858603:527,Energy Efficiency,Adapt,Adapt,527,"I'm not sure I follow then. Are you saying that you're not sure all the; versions in this range are bug-free? That being the case it's best to pin; it to a version we know is safe?. On Tue, Oct 5, 2021, 17:05 Gregory L. Wagner ***@***.***>; wrote:. > ***@***.**** commented on this pull request.; > ------------------------------; >; > In Project.toml; > <https://github.com/CliMA/Oceananigans.jl/pull/1997#discussion_r722703022>; > :; >; > > @@ -33,7 +33,7 @@ Tullio = ""bc48ee85-29a4-5162-ae0b-a64e1601d4bc""; >; > [compat]; > Adapt = ""^3""; > -CUDA = ""3""; > +CUDA = ""3.0.0 - 3.3.6""; >; > Note that Manifest.toml pins a specific version.; >; > Right, that's why I figured making it specific was the safest option.; >; > ; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/pull/1997#discussion_r722703022>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADEX5KRJ3DYWCNI4IRO6RNTUFNSC3ANCNFSM5FKUICWQ>; > .; > Triage notifications on the go with GitHub Mobile for iOS; > <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675>; > or Android; > <https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>.; >; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-934858603
https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-934858603:527,Modifiability,Adapt,Adapt,527,"I'm not sure I follow then. Are you saying that you're not sure all the; versions in this range are bug-free? That being the case it's best to pin; it to a version we know is safe?. On Tue, Oct 5, 2021, 17:05 Gregory L. Wagner ***@***.***>; wrote:. > ***@***.**** commented on this pull request.; > ------------------------------; >; > In Project.toml; > <https://github.com/CliMA/Oceananigans.jl/pull/1997#discussion_r722703022>; > :; >; > > @@ -33,7 +33,7 @@ Tullio = ""bc48ee85-29a4-5162-ae0b-a64e1601d4bc""; >; > [compat]; > Adapt = ""^3""; > -CUDA = ""3""; > +CUDA = ""3.0.0 - 3.3.6""; >; > Note that Manifest.toml pins a specific version.; >; > Right, that's why I figured making it specific was the safest option.; >; > ; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/pull/1997#discussion_r722703022>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADEX5KRJ3DYWCNI4IRO6RNTUFNSC3ANCNFSM5FKUICWQ>; > .; > Triage notifications on the go with GitHub Mobile for iOS; > <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675>; > or Android; > <https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>.; >; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-934858603
https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-934858603:175,Safety,safe,safe,175,"I'm not sure I follow then. Are you saying that you're not sure all the; versions in this range are bug-free? That being the case it's best to pin; it to a version we know is safe?. On Tue, Oct 5, 2021, 17:05 Gregory L. Wagner ***@***.***>; wrote:. > ***@***.**** commented on this pull request.; > ------------------------------; >; > In Project.toml; > <https://github.com/CliMA/Oceananigans.jl/pull/1997#discussion_r722703022>; > :; >; > > @@ -33,7 +33,7 @@ Tullio = ""bc48ee85-29a4-5162-ae0b-a64e1601d4bc""; >; > [compat]; > Adapt = ""^3""; > -CUDA = ""3""; > +CUDA = ""3.0.0 - 3.3.6""; >; > Note that Manifest.toml pins a specific version.; >; > Right, that's why I figured making it specific was the safest option.; >; > ; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/pull/1997#discussion_r722703022>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADEX5KRJ3DYWCNI4IRO6RNTUFNSC3ANCNFSM5FKUICWQ>; > .; > Triage notifications on the go with GitHub Mobile for iOS; > <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675>; > or Android; > <https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>.; >; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-934858603
https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-934858603:698,Safety,safe,safest,698,"I'm not sure I follow then. Are you saying that you're not sure all the; versions in this range are bug-free? That being the case it's best to pin; it to a version we know is safe?. On Tue, Oct 5, 2021, 17:05 Gregory L. Wagner ***@***.***>; wrote:. > ***@***.**** commented on this pull request.; > ------------------------------; >; > In Project.toml; > <https://github.com/CliMA/Oceananigans.jl/pull/1997#discussion_r722703022>; > :; >; > > @@ -33,7 +33,7 @@ Tullio = ""bc48ee85-29a4-5162-ae0b-a64e1601d4bc""; >; > [compat]; > Adapt = ""^3""; > -CUDA = ""3""; > +CUDA = ""3.0.0 - 3.3.6""; >; > Note that Manifest.toml pins a specific version.; >; > Right, that's why I figured making it specific was the safest option.; >; > ; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/pull/1997#discussion_r722703022>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADEX5KRJ3DYWCNI4IRO6RNTUFNSC3ANCNFSM5FKUICWQ>; > .; > Triage notifications on the go with GitHub Mobile for iOS; > <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675>; > or Android; > <https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>.; >; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-934858603
https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-935031502:524,Energy Efficiency,Adapt,Adapt,524,"> I'm not sure I follow then. Are you saying that you're not sure all the versions in this range are bug-free? That being the case it's best to pin it to a version we know is safe?; > [](#); > On Tue, Oct 5, 2021, 17:05 Gregory L. Wagner ***@***.***> wrote: ***@***.**** commented on this pull request. ------------------------------ In Project.toml <[#1997 (comment)](https://github.com/CliMA/Oceananigans.jl/pull/1997#discussion_r722703022)> : > @@ -33,7 +33,7 @@ Tullio = ""bc48ee85-29a4-5162-ae0b-a64e1601d4bc"" [compat] Adapt = ""^3"" -CUDA = ""3"" +CUDA = ""3.0.0 - 3.3.6"" Note that Manifest.toml pins a specific version. Right, that's why I figured making it specific was the safest option.  You are receiving this because you were mentioned. Reply to this email directly, view it on GitHub <[#1997 (comment)](https://github.com/CliMA/Oceananigans.jl/pull/1997#discussion_r722703022)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/ADEX5KRJ3DYWCNI4IRO6RNTUFNSC3ANCNFSM5FKUICWQ> . Triage notifications on the go with GitHub Mobile for iOS <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675> or Android <https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>. Oh, I just can't remember how far back we're able to go. But if you've gone to the effort to test a whole range of versions then certainly we might as well use a range, since it has the benefits you mentioned! My thought was just that it'd be quick and simple to pin to the version in the Manifest.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-935031502
https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-935031502:524,Modifiability,Adapt,Adapt,524,"> I'm not sure I follow then. Are you saying that you're not sure all the versions in this range are bug-free? That being the case it's best to pin it to a version we know is safe?; > [](#); > On Tue, Oct 5, 2021, 17:05 Gregory L. Wagner ***@***.***> wrote: ***@***.**** commented on this pull request. ------------------------------ In Project.toml <[#1997 (comment)](https://github.com/CliMA/Oceananigans.jl/pull/1997#discussion_r722703022)> : > @@ -33,7 +33,7 @@ Tullio = ""bc48ee85-29a4-5162-ae0b-a64e1601d4bc"" [compat] Adapt = ""^3"" -CUDA = ""3"" +CUDA = ""3.0.0 - 3.3.6"" Note that Manifest.toml pins a specific version. Right, that's why I figured making it specific was the safest option.  You are receiving this because you were mentioned. Reply to this email directly, view it on GitHub <[#1997 (comment)](https://github.com/CliMA/Oceananigans.jl/pull/1997#discussion_r722703022)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/ADEX5KRJ3DYWCNI4IRO6RNTUFNSC3ANCNFSM5FKUICWQ> . Triage notifications on the go with GitHub Mobile for iOS <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675> or Android <https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>. Oh, I just can't remember how far back we're able to go. But if you've gone to the effort to test a whole range of versions then certainly we might as well use a range, since it has the benefits you mentioned! My thought was just that it'd be quick and simple to pin to the version in the Manifest.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-935031502
https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-935031502:175,Safety,safe,safe,175,"> I'm not sure I follow then. Are you saying that you're not sure all the versions in this range are bug-free? That being the case it's best to pin it to a version we know is safe?; > [](#); > On Tue, Oct 5, 2021, 17:05 Gregory L. Wagner ***@***.***> wrote: ***@***.**** commented on this pull request. ------------------------------ In Project.toml <[#1997 (comment)](https://github.com/CliMA/Oceananigans.jl/pull/1997#discussion_r722703022)> : > @@ -33,7 +33,7 @@ Tullio = ""bc48ee85-29a4-5162-ae0b-a64e1601d4bc"" [compat] Adapt = ""^3"" -CUDA = ""3"" +CUDA = ""3.0.0 - 3.3.6"" Note that Manifest.toml pins a specific version. Right, that's why I figured making it specific was the safest option.  You are receiving this because you were mentioned. Reply to this email directly, view it on GitHub <[#1997 (comment)](https://github.com/CliMA/Oceananigans.jl/pull/1997#discussion_r722703022)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/ADEX5KRJ3DYWCNI4IRO6RNTUFNSC3ANCNFSM5FKUICWQ> . Triage notifications on the go with GitHub Mobile for iOS <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675> or Android <https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>. Oh, I just can't remember how far back we're able to go. But if you've gone to the effort to test a whole range of versions then certainly we might as well use a range, since it has the benefits you mentioned! My thought was just that it'd be quick and simple to pin to the version in the Manifest.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-935031502
https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-935031502:677,Safety,safe,safest,677,"> I'm not sure I follow then. Are you saying that you're not sure all the versions in this range are bug-free? That being the case it's best to pin it to a version we know is safe?; > [](#); > On Tue, Oct 5, 2021, 17:05 Gregory L. Wagner ***@***.***> wrote: ***@***.**** commented on this pull request. ------------------------------ In Project.toml <[#1997 (comment)](https://github.com/CliMA/Oceananigans.jl/pull/1997#discussion_r722703022)> : > @@ -33,7 +33,7 @@ Tullio = ""bc48ee85-29a4-5162-ae0b-a64e1601d4bc"" [compat] Adapt = ""^3"" -CUDA = ""3"" +CUDA = ""3.0.0 - 3.3.6"" Note that Manifest.toml pins a specific version. Right, that's why I figured making it specific was the safest option.  You are receiving this because you were mentioned. Reply to this email directly, view it on GitHub <[#1997 (comment)](https://github.com/CliMA/Oceananigans.jl/pull/1997#discussion_r722703022)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/ADEX5KRJ3DYWCNI4IRO6RNTUFNSC3ANCNFSM5FKUICWQ> . Triage notifications on the go with GitHub Mobile for iOS <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675> or Android <https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>. Oh, I just can't remember how far back we're able to go. But if you've gone to the effort to test a whole range of versions then certainly we might as well use a range, since it has the benefits you mentioned! My thought was just that it'd be quick and simple to pin to the version in the Manifest.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-935031502
https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-935031502:1409,Testability,test,test,1409,"> I'm not sure I follow then. Are you saying that you're not sure all the versions in this range are bug-free? That being the case it's best to pin it to a version we know is safe?; > [](#); > On Tue, Oct 5, 2021, 17:05 Gregory L. Wagner ***@***.***> wrote: ***@***.**** commented on this pull request. ------------------------------ In Project.toml <[#1997 (comment)](https://github.com/CliMA/Oceananigans.jl/pull/1997#discussion_r722703022)> : > @@ -33,7 +33,7 @@ Tullio = ""bc48ee85-29a4-5162-ae0b-a64e1601d4bc"" [compat] Adapt = ""^3"" -CUDA = ""3"" +CUDA = ""3.0.0 - 3.3.6"" Note that Manifest.toml pins a specific version. Right, that's why I figured making it specific was the safest option.  You are receiving this because you were mentioned. Reply to this email directly, view it on GitHub <[#1997 (comment)](https://github.com/CliMA/Oceananigans.jl/pull/1997#discussion_r722703022)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/ADEX5KRJ3DYWCNI4IRO6RNTUFNSC3ANCNFSM5FKUICWQ> . Triage notifications on the go with GitHub Mobile for iOS <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675> or Android <https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>. Oh, I just can't remember how far back we're able to go. But if you've gone to the effort to test a whole range of versions then certainly we might as well use a range, since it has the benefits you mentioned! My thought was just that it'd be quick and simple to pin to the version in the Manifest.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-935031502
https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-935031502:1569,Usability,simpl,simple,1569,"> I'm not sure I follow then. Are you saying that you're not sure all the versions in this range are bug-free? That being the case it's best to pin it to a version we know is safe?; > [](#); > On Tue, Oct 5, 2021, 17:05 Gregory L. Wagner ***@***.***> wrote: ***@***.**** commented on this pull request. ------------------------------ In Project.toml <[#1997 (comment)](https://github.com/CliMA/Oceananigans.jl/pull/1997#discussion_r722703022)> : > @@ -33,7 +33,7 @@ Tullio = ""bc48ee85-29a4-5162-ae0b-a64e1601d4bc"" [compat] Adapt = ""^3"" -CUDA = ""3"" +CUDA = ""3.0.0 - 3.3.6"" Note that Manifest.toml pins a specific version. Right, that's why I figured making it specific was the safest option.  You are receiving this because you were mentioned. Reply to this email directly, view it on GitHub <[#1997 (comment)](https://github.com/CliMA/Oceananigans.jl/pull/1997#discussion_r722703022)>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/ADEX5KRJ3DYWCNI4IRO6RNTUFNSC3ANCNFSM5FKUICWQ> . Triage notifications on the go with GitHub Mobile for iOS <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675> or Android <https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>. Oh, I just can't remember how far back we're able to go. But if you've gone to the effort to test a whole range of versions then certainly we might as well use a range, since it has the benefits you mentioned! My thought was just that it'd be quick and simple to pin to the version in the Manifest.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-935031502
https://github.com/CliMA/Oceananigans.jl/pull/1999#issuecomment-937048847:25,Usability,undo,undo,25,Closing this since it'll undo https://github.com/CliMA/Oceananigans.jl/pull/1997,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1999#issuecomment-937048847
https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-940781017:108,Testability,test,test,108,"Seems like this bit. https://github.com/CliMA/Oceananigans.jl/blob/29b4cf9e108ea4b72004fee940c66b706b138bbb/test/test_field.jl#L269-L272. runs on the `CPU unit tests`!. https://buildkite.com/clima/oceananigans/builds/3952#f28dce5a-3fa6-486c-9bb6-a543eb6face7. Anybody has any idea why?. cc: @ali-ramadhan, @glwagner",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-940781017
https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-940781017:160,Testability,test,tests,160,"Seems like this bit. https://github.com/CliMA/Oceananigans.jl/blob/29b4cf9e108ea4b72004fee940c66b706b138bbb/test/test_field.jl#L269-L272. runs on the `CPU unit tests`!. https://buildkite.com/clima/oceananigans/builds/3952#f28dce5a-3fa6-486c-9bb6-a543eb6face7. Anybody has any idea why?. cc: @ali-ramadhan, @glwagner",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-940781017
https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-941344608:40,Testability,test,tested,40,"Hummmm no, I don't. `cpudata` should be tested on the GPU. Where is that function used anyways?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-941344608
https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942845682:566,Availability,failure,failures,566,"Hmmm, should we be using [`CUDA.has_cuda_gpu`](https://cuda.juliagpu.org/dev/api/essentials/#CUDA.has_cuda_gpu) instead of [`CUDA.has_cuda`](https://cuda.juliagpu.org/dev/api/essentials/#CUDA.has_cuda)?. Since Tartarus actually has GPUs (we just hide them via an environment variable in CI, e.g. https://github.com/CliMA/Oceananigans.jl/blob/main/.buildkite/pipeline.yml#L77) I can see `CUDA.has_cuda_gpu` returning false (which we want) while `CUDA.has_cuda` would return true (not what we want). This might fix the unit tests (`test_field.jl`) but there are other failures that might not be related to this. Confusingly I see no recent changes in CUDA.jl that would lead to a difference in behavior for `has_cuda` (see changes for `src/initialization.jl`) but there were a lot of changes between v3.3.6 and v3.5.0 that I wouldn't understand: https://github.com/JuliaGPU/CUDA.jl/compare/v3.3.6...v3.5.0",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942845682
https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942845682:358,Deployability,pipeline,pipeline,358,"Hmmm, should we be using [`CUDA.has_cuda_gpu`](https://cuda.juliagpu.org/dev/api/essentials/#CUDA.has_cuda_gpu) instead of [`CUDA.has_cuda`](https://cuda.juliagpu.org/dev/api/essentials/#CUDA.has_cuda)?. Since Tartarus actually has GPUs (we just hide them via an environment variable in CI, e.g. https://github.com/CliMA/Oceananigans.jl/blob/main/.buildkite/pipeline.yml#L77) I can see `CUDA.has_cuda_gpu` returning false (which we want) while `CUDA.has_cuda` would return true (not what we want). This might fix the unit tests (`test_field.jl`) but there are other failures that might not be related to this. Confusingly I see no recent changes in CUDA.jl that would lead to a difference in behavior for `has_cuda` (see changes for `src/initialization.jl`) but there were a lot of changes between v3.3.6 and v3.5.0 that I wouldn't understand: https://github.com/JuliaGPU/CUDA.jl/compare/v3.3.6...v3.5.0",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942845682
https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942845682:275,Modifiability,variab,variable,275,"Hmmm, should we be using [`CUDA.has_cuda_gpu`](https://cuda.juliagpu.org/dev/api/essentials/#CUDA.has_cuda_gpu) instead of [`CUDA.has_cuda`](https://cuda.juliagpu.org/dev/api/essentials/#CUDA.has_cuda)?. Since Tartarus actually has GPUs (we just hide them via an environment variable in CI, e.g. https://github.com/CliMA/Oceananigans.jl/blob/main/.buildkite/pipeline.yml#L77) I can see `CUDA.has_cuda_gpu` returning false (which we want) while `CUDA.has_cuda` would return true (not what we want). This might fix the unit tests (`test_field.jl`) but there are other failures that might not be related to this. Confusingly I see no recent changes in CUDA.jl that would lead to a difference in behavior for `has_cuda` (see changes for `src/initialization.jl`) but there were a lot of changes between v3.3.6 and v3.5.0 that I wouldn't understand: https://github.com/JuliaGPU/CUDA.jl/compare/v3.3.6...v3.5.0",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942845682
https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942845682:522,Testability,test,tests,522,"Hmmm, should we be using [`CUDA.has_cuda_gpu`](https://cuda.juliagpu.org/dev/api/essentials/#CUDA.has_cuda_gpu) instead of [`CUDA.has_cuda`](https://cuda.juliagpu.org/dev/api/essentials/#CUDA.has_cuda)?. Since Tartarus actually has GPUs (we just hide them via an environment variable in CI, e.g. https://github.com/CliMA/Oceananigans.jl/blob/main/.buildkite/pipeline.yml#L77) I can see `CUDA.has_cuda_gpu` returning false (which we want) while `CUDA.has_cuda` would return true (not what we want). This might fix the unit tests (`test_field.jl`) but there are other failures that might not be related to this. Confusingly I see no recent changes in CUDA.jl that would lead to a difference in behavior for `has_cuda` (see changes for `src/initialization.jl`) but there were a lot of changes between v3.3.6 and v3.5.0 that I wouldn't understand: https://github.com/JuliaGPU/CUDA.jl/compare/v3.3.6...v3.5.0",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942845682
https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942848201:100,Availability,failure,failures,100,Ah actually we have 34 instances of `has_cuda` in the repo so it could perhaps explain a lot of the failures? https://github.com/CliMA/Oceananigans.jl/search?p=4&q=has_cuda,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942848201
https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942850898:35,Testability,test,test,35,Should I change everything in the `test` dir?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942850898
https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942852143:84,Testability,test,tests,84,"Yeah seems like it might be worth it to do a full search and replace, especially if tests pass right?. Since it seems that behavior has changed, I think there are some instances of `has_cuda` that should be `has_cuda_gpu` in `src/` that should also be changed. I guess the number of users hiding their GPUs while using Oceananigans is small, but it could affect CI in the future (or one of us on Tartarus).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942852143
https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942853591:52,Testability,test,tests,52,"OK, I changed only one now just want to see if unit tests on CPU pass. Although, with; https://github.com/CliMA/Oceananigans.jl/blob/a934f7ecbbeed50013b012ae230b1b6587e4e6aa/test/runtests.jl#L56; I'm wondering whether all CPU tests are actually being run with `arch = GPU()`....",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942853591
https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942853591:174,Testability,test,test,174,"OK, I changed only one now just want to see if unit tests on CPU pass. Although, with; https://github.com/CliMA/Oceananigans.jl/blob/a934f7ecbbeed50013b012ae230b1b6587e4e6aa/test/runtests.jl#L56; I'm wondering whether all CPU tests are actually being run with `arch = GPU()`....",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942853591
https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942853591:226,Testability,test,tests,226,"OK, I changed only one now just want to see if unit tests on CPU pass. Although, with; https://github.com/CliMA/Oceananigans.jl/blob/a934f7ecbbeed50013b012ae230b1b6587e4e6aa/test/runtests.jl#L56; I'm wondering whether all CPU tests are actually being run with `arch = GPU()`....",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942853591
https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942854704:189,Availability,failure,failures,189,"Ah haha right, feels like a lot more tests would have failed because of that though but it was only CPU tests groups that failed last time so maybe that line is responsible for most of the failures?. PS: Sorry for accidentally closing!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942854704
https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942854704:37,Testability,test,tests,37,"Ah haha right, feels like a lot more tests would have failed because of that though but it was only CPU tests groups that failed last time so maybe that line is responsible for most of the failures?. PS: Sorry for accidentally closing!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942854704
https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942854704:104,Testability,test,tests,104,"Ah haha right, feels like a lot more tests would have failed because of that though but it was only CPU tests groups that failed last time so maybe that line is responsible for most of the failures?. PS: Sorry for accidentally closing!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942854704
https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942860232:176,Availability,error,errors,176,"Ah CI doesn't even initialize on the CPU now... Kinda confused why tests were initially failing now since REPL suggests that CUDA.jl behavior actually hasn't changed (and also errors on `CUDA.has_cuda_gpu` like CI does now):. ```julia; shell> hostname; tartarus. julia> ENV[""CUDA_VISIBLE_DEVICES""]; ""-1"". julia> using CUDA. julia> CUDA.has_cuda(); false. julia> CUDA.has_cuda_gpu(); ERROR: CUDA error: initialization error (code 3, ERROR_NOT_INITIALIZED); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/error.jl:91; [2] macro expansion; @ ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/error.jl:101 [inlined]; [3] cuDeviceGetCount; @ ~/.julia/packages/CUDA/YpW0k/lib/utils/call.jl:26 [inlined]; [4] ndevices; @ ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/devices.jl:160 [inlined]; [5] length; @ ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/devices.jl:144 [inlined]; [6] has_cuda_gpu (repeats 2 times); @ ~/.julia/packages/CUDA/YpW0k/src/initialization.jl:136 [inlined]; [7] top-level scope; @ REPL[5]:1; [8] top-level scope; @ ~/.julia/packages/CUDA/YpW0k/src/initialization.jl:52; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942860232
https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942860232:383,Availability,ERROR,ERROR,383,"Ah CI doesn't even initialize on the CPU now... Kinda confused why tests were initially failing now since REPL suggests that CUDA.jl behavior actually hasn't changed (and also errors on `CUDA.has_cuda_gpu` like CI does now):. ```julia; shell> hostname; tartarus. julia> ENV[""CUDA_VISIBLE_DEVICES""]; ""-1"". julia> using CUDA. julia> CUDA.has_cuda(); false. julia> CUDA.has_cuda_gpu(); ERROR: CUDA error: initialization error (code 3, ERROR_NOT_INITIALIZED); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/error.jl:91; [2] macro expansion; @ ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/error.jl:101 [inlined]; [3] cuDeviceGetCount; @ ~/.julia/packages/CUDA/YpW0k/lib/utils/call.jl:26 [inlined]; [4] ndevices; @ ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/devices.jl:160 [inlined]; [5] length; @ ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/devices.jl:144 [inlined]; [6] has_cuda_gpu (repeats 2 times); @ ~/.julia/packages/CUDA/YpW0k/src/initialization.jl:136 [inlined]; [7] top-level scope; @ REPL[5]:1; [8] top-level scope; @ ~/.julia/packages/CUDA/YpW0k/src/initialization.jl:52; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942860232
https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942860232:395,Availability,error,error,395,"Ah CI doesn't even initialize on the CPU now... Kinda confused why tests were initially failing now since REPL suggests that CUDA.jl behavior actually hasn't changed (and also errors on `CUDA.has_cuda_gpu` like CI does now):. ```julia; shell> hostname; tartarus. julia> ENV[""CUDA_VISIBLE_DEVICES""]; ""-1"". julia> using CUDA. julia> CUDA.has_cuda(); false. julia> CUDA.has_cuda_gpu(); ERROR: CUDA error: initialization error (code 3, ERROR_NOT_INITIALIZED); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/error.jl:91; [2] macro expansion; @ ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/error.jl:101 [inlined]; [3] cuDeviceGetCount; @ ~/.julia/packages/CUDA/YpW0k/lib/utils/call.jl:26 [inlined]; [4] ndevices; @ ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/devices.jl:160 [inlined]; [5] length; @ ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/devices.jl:144 [inlined]; [6] has_cuda_gpu (repeats 2 times); @ ~/.julia/packages/CUDA/YpW0k/src/initialization.jl:136 [inlined]; [7] top-level scope; @ REPL[5]:1; [8] top-level scope; @ ~/.julia/packages/CUDA/YpW0k/src/initialization.jl:52; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942860232
https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942860232:417,Availability,error,error,417,"Ah CI doesn't even initialize on the CPU now... Kinda confused why tests were initially failing now since REPL suggests that CUDA.jl behavior actually hasn't changed (and also errors on `CUDA.has_cuda_gpu` like CI does now):. ```julia; shell> hostname; tartarus. julia> ENV[""CUDA_VISIBLE_DEVICES""]; ""-1"". julia> using CUDA. julia> CUDA.has_cuda(); false. julia> CUDA.has_cuda_gpu(); ERROR: CUDA error: initialization error (code 3, ERROR_NOT_INITIALIZED); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/error.jl:91; [2] macro expansion; @ ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/error.jl:101 [inlined]; [3] cuDeviceGetCount; @ ~/.julia/packages/CUDA/YpW0k/lib/utils/call.jl:26 [inlined]; [4] ndevices; @ ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/devices.jl:160 [inlined]; [5] length; @ ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/devices.jl:144 [inlined]; [6] has_cuda_gpu (repeats 2 times); @ ~/.julia/packages/CUDA/YpW0k/src/initialization.jl:136 [inlined]; [7] top-level scope; @ REPL[5]:1; [8] top-level scope; @ ~/.julia/packages/CUDA/YpW0k/src/initialization.jl:52; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942860232
https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942860232:564,Availability,error,error,564,"Ah CI doesn't even initialize on the CPU now... Kinda confused why tests were initially failing now since REPL suggests that CUDA.jl behavior actually hasn't changed (and also errors on `CUDA.has_cuda_gpu` like CI does now):. ```julia; shell> hostname; tartarus. julia> ENV[""CUDA_VISIBLE_DEVICES""]; ""-1"". julia> using CUDA. julia> CUDA.has_cuda(); false. julia> CUDA.has_cuda_gpu(); ERROR: CUDA error: initialization error (code 3, ERROR_NOT_INITIALIZED); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/error.jl:91; [2] macro expansion; @ ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/error.jl:101 [inlined]; [3] cuDeviceGetCount; @ ~/.julia/packages/CUDA/YpW0k/lib/utils/call.jl:26 [inlined]; [4] ndevices; @ ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/devices.jl:160 [inlined]; [5] length; @ ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/devices.jl:144 [inlined]; [6] has_cuda_gpu (repeats 2 times); @ ~/.julia/packages/CUDA/YpW0k/src/initialization.jl:136 [inlined]; [7] top-level scope; @ REPL[5]:1; [8] top-level scope; @ ~/.julia/packages/CUDA/YpW0k/src/initialization.jl:52; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942860232
https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942860232:641,Availability,error,error,641,"Ah CI doesn't even initialize on the CPU now... Kinda confused why tests were initially failing now since REPL suggests that CUDA.jl behavior actually hasn't changed (and also errors on `CUDA.has_cuda_gpu` like CI does now):. ```julia; shell> hostname; tartarus. julia> ENV[""CUDA_VISIBLE_DEVICES""]; ""-1"". julia> using CUDA. julia> CUDA.has_cuda(); false. julia> CUDA.has_cuda_gpu(); ERROR: CUDA error: initialization error (code 3, ERROR_NOT_INITIALIZED); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/error.jl:91; [2] macro expansion; @ ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/error.jl:101 [inlined]; [3] cuDeviceGetCount; @ ~/.julia/packages/CUDA/YpW0k/lib/utils/call.jl:26 [inlined]; [4] ndevices; @ ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/devices.jl:160 [inlined]; [5] length; @ ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/devices.jl:144 [inlined]; [6] has_cuda_gpu (repeats 2 times); @ ~/.julia/packages/CUDA/YpW0k/src/initialization.jl:136 [inlined]; [7] top-level scope; @ REPL[5]:1; [8] top-level scope; @ ~/.julia/packages/CUDA/YpW0k/src/initialization.jl:52; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942860232
https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942860232:67,Testability,test,tests,67,"Ah CI doesn't even initialize on the CPU now... Kinda confused why tests were initially failing now since REPL suggests that CUDA.jl behavior actually hasn't changed (and also errors on `CUDA.has_cuda_gpu` like CI does now):. ```julia; shell> hostname; tartarus. julia> ENV[""CUDA_VISIBLE_DEVICES""]; ""-1"". julia> using CUDA. julia> CUDA.has_cuda(); false. julia> CUDA.has_cuda_gpu(); ERROR: CUDA error: initialization error (code 3, ERROR_NOT_INITIALIZED); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/error.jl:91; [2] macro expansion; @ ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/error.jl:101 [inlined]; [3] cuDeviceGetCount; @ ~/.julia/packages/CUDA/YpW0k/lib/utils/call.jl:26 [inlined]; [4] ndevices; @ ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/devices.jl:160 [inlined]; [5] length; @ ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/devices.jl:144 [inlined]; [6] has_cuda_gpu (repeats 2 times); @ ~/.julia/packages/CUDA/YpW0k/src/initialization.jl:136 [inlined]; [7] top-level scope; @ REPL[5]:1; [8] top-level scope; @ ~/.julia/packages/CUDA/YpW0k/src/initialization.jl:52; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942860232
https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942875440:185,Availability,error,errors,185,"> Ah CI doesn't even initialize on the CPU now...; > ; > Kinda confused why tests were initially failing now since REPL suggests that CUDA.jl behavior actually hasn't changed (and also errors on `CUDA.has_cuda_gpu` like CI does now):; > ; > ```julia; > shell> hostname; > tartarus; > ; > julia> ENV[""CUDA_VISIBLE_DEVICES""]; > ""-1""; > ; > julia> using CUDA; > ; > julia> CUDA.has_cuda(); > false; > ; > julia> CUDA.has_cuda_gpu(); > ERROR: CUDA error: initialization error (code 3, ERROR_NOT_INITIALIZED); > Stacktrace:; > [1] throw_api_error(res::CUDA.cudaError_enum); > @ CUDA ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/error.jl:91; > [2] macro expansion; > @ ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/error.jl:101 [inlined]; > [3] cuDeviceGetCount; > @ ~/.julia/packages/CUDA/YpW0k/lib/utils/call.jl:26 [inlined]; > [4] ndevices; > @ ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/devices.jl:160 [inlined]; > [5] length; > @ ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/devices.jl:144 [inlined]; > [6] has_cuda_gpu (repeats 2 times); > @ ~/.julia/packages/CUDA/YpW0k/src/initialization.jl:136 [inlined]; > [7] top-level scope; > @ REPL[5]:1; > [8] top-level scope; > @ ~/.julia/packages/CUDA/YpW0k/src/initialization.jl:52; > ```. err, is this a bug in `CUDA.jl`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942875440
https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942875440:432,Availability,ERROR,ERROR,432,"> Ah CI doesn't even initialize on the CPU now...; > ; > Kinda confused why tests were initially failing now since REPL suggests that CUDA.jl behavior actually hasn't changed (and also errors on `CUDA.has_cuda_gpu` like CI does now):; > ; > ```julia; > shell> hostname; > tartarus; > ; > julia> ENV[""CUDA_VISIBLE_DEVICES""]; > ""-1""; > ; > julia> using CUDA; > ; > julia> CUDA.has_cuda(); > false; > ; > julia> CUDA.has_cuda_gpu(); > ERROR: CUDA error: initialization error (code 3, ERROR_NOT_INITIALIZED); > Stacktrace:; > [1] throw_api_error(res::CUDA.cudaError_enum); > @ CUDA ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/error.jl:91; > [2] macro expansion; > @ ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/error.jl:101 [inlined]; > [3] cuDeviceGetCount; > @ ~/.julia/packages/CUDA/YpW0k/lib/utils/call.jl:26 [inlined]; > [4] ndevices; > @ ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/devices.jl:160 [inlined]; > [5] length; > @ ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/devices.jl:144 [inlined]; > [6] has_cuda_gpu (repeats 2 times); > @ ~/.julia/packages/CUDA/YpW0k/src/initialization.jl:136 [inlined]; > [7] top-level scope; > @ REPL[5]:1; > [8] top-level scope; > @ ~/.julia/packages/CUDA/YpW0k/src/initialization.jl:52; > ```. err, is this a bug in `CUDA.jl`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942875440
https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942875440:444,Availability,error,error,444,"> Ah CI doesn't even initialize on the CPU now...; > ; > Kinda confused why tests were initially failing now since REPL suggests that CUDA.jl behavior actually hasn't changed (and also errors on `CUDA.has_cuda_gpu` like CI does now):; > ; > ```julia; > shell> hostname; > tartarus; > ; > julia> ENV[""CUDA_VISIBLE_DEVICES""]; > ""-1""; > ; > julia> using CUDA; > ; > julia> CUDA.has_cuda(); > false; > ; > julia> CUDA.has_cuda_gpu(); > ERROR: CUDA error: initialization error (code 3, ERROR_NOT_INITIALIZED); > Stacktrace:; > [1] throw_api_error(res::CUDA.cudaError_enum); > @ CUDA ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/error.jl:91; > [2] macro expansion; > @ ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/error.jl:101 [inlined]; > [3] cuDeviceGetCount; > @ ~/.julia/packages/CUDA/YpW0k/lib/utils/call.jl:26 [inlined]; > [4] ndevices; > @ ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/devices.jl:160 [inlined]; > [5] length; > @ ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/devices.jl:144 [inlined]; > [6] has_cuda_gpu (repeats 2 times); > @ ~/.julia/packages/CUDA/YpW0k/src/initialization.jl:136 [inlined]; > [7] top-level scope; > @ REPL[5]:1; > [8] top-level scope; > @ ~/.julia/packages/CUDA/YpW0k/src/initialization.jl:52; > ```. err, is this a bug in `CUDA.jl`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942875440
https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942875440:466,Availability,error,error,466,"> Ah CI doesn't even initialize on the CPU now...; > ; > Kinda confused why tests were initially failing now since REPL suggests that CUDA.jl behavior actually hasn't changed (and also errors on `CUDA.has_cuda_gpu` like CI does now):; > ; > ```julia; > shell> hostname; > tartarus; > ; > julia> ENV[""CUDA_VISIBLE_DEVICES""]; > ""-1""; > ; > julia> using CUDA; > ; > julia> CUDA.has_cuda(); > false; > ; > julia> CUDA.has_cuda_gpu(); > ERROR: CUDA error: initialization error (code 3, ERROR_NOT_INITIALIZED); > Stacktrace:; > [1] throw_api_error(res::CUDA.cudaError_enum); > @ CUDA ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/error.jl:91; > [2] macro expansion; > @ ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/error.jl:101 [inlined]; > [3] cuDeviceGetCount; > @ ~/.julia/packages/CUDA/YpW0k/lib/utils/call.jl:26 [inlined]; > [4] ndevices; > @ ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/devices.jl:160 [inlined]; > [5] length; > @ ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/devices.jl:144 [inlined]; > [6] has_cuda_gpu (repeats 2 times); > @ ~/.julia/packages/CUDA/YpW0k/src/initialization.jl:136 [inlined]; > [7] top-level scope; > @ REPL[5]:1; > [8] top-level scope; > @ ~/.julia/packages/CUDA/YpW0k/src/initialization.jl:52; > ```. err, is this a bug in `CUDA.jl`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942875440
https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942875440:619,Availability,error,error,619,"> Ah CI doesn't even initialize on the CPU now...; > ; > Kinda confused why tests were initially failing now since REPL suggests that CUDA.jl behavior actually hasn't changed (and also errors on `CUDA.has_cuda_gpu` like CI does now):; > ; > ```julia; > shell> hostname; > tartarus; > ; > julia> ENV[""CUDA_VISIBLE_DEVICES""]; > ""-1""; > ; > julia> using CUDA; > ; > julia> CUDA.has_cuda(); > false; > ; > julia> CUDA.has_cuda_gpu(); > ERROR: CUDA error: initialization error (code 3, ERROR_NOT_INITIALIZED); > Stacktrace:; > [1] throw_api_error(res::CUDA.cudaError_enum); > @ CUDA ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/error.jl:91; > [2] macro expansion; > @ ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/error.jl:101 [inlined]; > [3] cuDeviceGetCount; > @ ~/.julia/packages/CUDA/YpW0k/lib/utils/call.jl:26 [inlined]; > [4] ndevices; > @ ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/devices.jl:160 [inlined]; > [5] length; > @ ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/devices.jl:144 [inlined]; > [6] has_cuda_gpu (repeats 2 times); > @ ~/.julia/packages/CUDA/YpW0k/src/initialization.jl:136 [inlined]; > [7] top-level scope; > @ REPL[5]:1; > [8] top-level scope; > @ ~/.julia/packages/CUDA/YpW0k/src/initialization.jl:52; > ```. err, is this a bug in `CUDA.jl`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942875440
https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942875440:700,Availability,error,error,700,"> Ah CI doesn't even initialize on the CPU now...; > ; > Kinda confused why tests were initially failing now since REPL suggests that CUDA.jl behavior actually hasn't changed (and also errors on `CUDA.has_cuda_gpu` like CI does now):; > ; > ```julia; > shell> hostname; > tartarus; > ; > julia> ENV[""CUDA_VISIBLE_DEVICES""]; > ""-1""; > ; > julia> using CUDA; > ; > julia> CUDA.has_cuda(); > false; > ; > julia> CUDA.has_cuda_gpu(); > ERROR: CUDA error: initialization error (code 3, ERROR_NOT_INITIALIZED); > Stacktrace:; > [1] throw_api_error(res::CUDA.cudaError_enum); > @ CUDA ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/error.jl:91; > [2] macro expansion; > @ ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/error.jl:101 [inlined]; > [3] cuDeviceGetCount; > @ ~/.julia/packages/CUDA/YpW0k/lib/utils/call.jl:26 [inlined]; > [4] ndevices; > @ ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/devices.jl:160 [inlined]; > [5] length; > @ ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/devices.jl:144 [inlined]; > [6] has_cuda_gpu (repeats 2 times); > @ ~/.julia/packages/CUDA/YpW0k/src/initialization.jl:136 [inlined]; > [7] top-level scope; > @ REPL[5]:1; > [8] top-level scope; > @ ~/.julia/packages/CUDA/YpW0k/src/initialization.jl:52; > ```. err, is this a bug in `CUDA.jl`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942875440
https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942875440:76,Testability,test,tests,76,"> Ah CI doesn't even initialize on the CPU now...; > ; > Kinda confused why tests were initially failing now since REPL suggests that CUDA.jl behavior actually hasn't changed (and also errors on `CUDA.has_cuda_gpu` like CI does now):; > ; > ```julia; > shell> hostname; > tartarus; > ; > julia> ENV[""CUDA_VISIBLE_DEVICES""]; > ""-1""; > ; > julia> using CUDA; > ; > julia> CUDA.has_cuda(); > false; > ; > julia> CUDA.has_cuda_gpu(); > ERROR: CUDA error: initialization error (code 3, ERROR_NOT_INITIALIZED); > Stacktrace:; > [1] throw_api_error(res::CUDA.cudaError_enum); > @ CUDA ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/error.jl:91; > [2] macro expansion; > @ ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/error.jl:101 [inlined]; > [3] cuDeviceGetCount; > @ ~/.julia/packages/CUDA/YpW0k/lib/utils/call.jl:26 [inlined]; > [4] ndevices; > @ ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/devices.jl:160 [inlined]; > [5] length; > @ ~/.julia/packages/CUDA/YpW0k/lib/cudadrv/devices.jl:144 [inlined]; > [6] has_cuda_gpu (repeats 2 times); > @ ~/.julia/packages/CUDA/YpW0k/src/initialization.jl:136 [inlined]; > [7] top-level scope; > @ REPL[5]:1; > [8] top-level scope; > @ ~/.julia/packages/CUDA/YpW0k/src/initialization.jl:52; > ```. err, is this a bug in `CUDA.jl`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942875440
https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1043202547:154,Deployability,update,update,154,We would need CUDA 3.8.0 to develop multiGPU architectures without having to use MPI. . You mind if I revamp this PR and try to see what we need to do to update CUDA?; I think the tests not passing comes from the fact that we also need to update CUDAKernels to version 0.3.3 (we are now using 0.3.0). Actually for me everything works very good from main just switching to CUDA 3.8.0 and CUDAKernels 0.3.3,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1043202547
https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1043202547:239,Deployability,update,update,239,We would need CUDA 3.8.0 to develop multiGPU architectures without having to use MPI. . You mind if I revamp this PR and try to see what we need to do to update CUDA?; I think the tests not passing comes from the fact that we also need to update CUDAKernels to version 0.3.3 (we are now using 0.3.0). Actually for me everything works very good from main just switching to CUDA 3.8.0 and CUDAKernels 0.3.3,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1043202547
https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1043202547:180,Testability,test,tests,180,We would need CUDA 3.8.0 to develop multiGPU architectures without having to use MPI. . You mind if I revamp this PR and try to see what we need to do to update CUDA?; I think the tests not passing comes from the fact that we also need to update CUDAKernels to version 0.3.3 (we are now using 0.3.0). Actually for me everything works very good from main just switching to CUDA 3.8.0 and CUDAKernels 0.3.3,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1043202547
https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1043620708:115,Deployability,update,updated,115,@simone-silvestri if you can figure out the shenanigans with CUDA > 3.3.6 I'd be delighted! I just merged main and updated packages but I doubt that this is all what's needed.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1043620708
https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1044679744:727,Availability,down,down,727,"> We would need CUDA 3.8.0 to develop multiGPU architectures without having to use MPI.; > ; > You mind if I revamp this PR and try to see what we need to do to update CUDA? I think the tests not passing comes from the fact that we also need to update CUDAKernels to version 0.3.3 (we are now using 0.3.0); > ; > Actually for me everything works very good from main just switching to CUDA 3.8.0 and CUDAKernels 0.3.3. That is very exciting! Do you know of any scaling results that people have done using this multiGPU approach? I'd be keen to try this with Oceananigans when it's working. I know that we tried using MPI and GPU last summer and had some problems. One, getting it to work was a pain. Two, the effiicency dropped down to 60% when going fro 1 to 2 GPUs. I now we can do better, and maybe this is a way of doing that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1044679744
https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1044679744:161,Deployability,update,update,161,"> We would need CUDA 3.8.0 to develop multiGPU architectures without having to use MPI.; > ; > You mind if I revamp this PR and try to see what we need to do to update CUDA? I think the tests not passing comes from the fact that we also need to update CUDAKernels to version 0.3.3 (we are now using 0.3.0); > ; > Actually for me everything works very good from main just switching to CUDA 3.8.0 and CUDAKernels 0.3.3. That is very exciting! Do you know of any scaling results that people have done using this multiGPU approach? I'd be keen to try this with Oceananigans when it's working. I know that we tried using MPI and GPU last summer and had some problems. One, getting it to work was a pain. Two, the effiicency dropped down to 60% when going fro 1 to 2 GPUs. I now we can do better, and maybe this is a way of doing that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1044679744
https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1044679744:245,Deployability,update,update,245,"> We would need CUDA 3.8.0 to develop multiGPU architectures without having to use MPI.; > ; > You mind if I revamp this PR and try to see what we need to do to update CUDA? I think the tests not passing comes from the fact that we also need to update CUDAKernels to version 0.3.3 (we are now using 0.3.0); > ; > Actually for me everything works very good from main just switching to CUDA 3.8.0 and CUDAKernels 0.3.3. That is very exciting! Do you know of any scaling results that people have done using this multiGPU approach? I'd be keen to try this with Oceananigans when it's working. I know that we tried using MPI and GPU last summer and had some problems. One, getting it to work was a pain. Two, the effiicency dropped down to 60% when going fro 1 to 2 GPUs. I now we can do better, and maybe this is a way of doing that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1044679744
https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1044679744:186,Testability,test,tests,186,"> We would need CUDA 3.8.0 to develop multiGPU architectures without having to use MPI.; > ; > You mind if I revamp this PR and try to see what we need to do to update CUDA? I think the tests not passing comes from the fact that we also need to update CUDAKernels to version 0.3.3 (we are now using 0.3.0); > ; > Actually for me everything works very good from main just switching to CUDA 3.8.0 and CUDAKernels 0.3.3. That is very exciting! Do you know of any scaling results that people have done using this multiGPU approach? I'd be keen to try this with Oceananigans when it's working. I know that we tried using MPI and GPU last summer and had some problems. One, getting it to work was a pain. Two, the effiicency dropped down to 60% when going fro 1 to 2 GPUs. I now we can do better, and maybe this is a way of doing that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1044679744
https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1044738495:490,Integrability,message,message,490,"@navidcy I just did a lazy switch to CUDA 3.8.0 (and CUDAKernels 0.3.3) in my latest PR and it seems to be somewhat ok (for sure not all is required) but there are still some problems with `gpu_nonhydrostatic_regression` (an `device kernel invalid image`), `gpu_cubed_sphere`(an `out of bounds access`) (and for some weird reason distributed CPU??). I ll try to figure out a bit more... @francispoulin I don't have an indepth idea of the scaling but I with some basic trials I saw that the message passing is quite quick (the advantage is that is passes directly from GPU to GPU, which maybe is the same as cuda-aware MPI?). The advantage is surely the ease of implementing such a method",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1044738495
https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1044738495:294,Security,access,access,294,"@navidcy I just did a lazy switch to CUDA 3.8.0 (and CUDAKernels 0.3.3) in my latest PR and it seems to be somewhat ok (for sure not all is required) but there are still some problems with `gpu_nonhydrostatic_regression` (an `device kernel invalid image`), `gpu_cubed_sphere`(an `out of bounds access`) (and for some weird reason distributed CPU??). I ll try to figure out a bit more... @francispoulin I don't have an indepth idea of the scaling but I with some basic trials I saw that the message passing is quite quick (the advantage is that is passes directly from GPU to GPU, which maybe is the same as cuda-aware MPI?). The advantage is surely the ease of implementing such a method",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1044738495
https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1044990716:731,Availability,down,down,731,"> > We would need CUDA 3.8.0 to develop multiGPU architectures without having to use MPI.; > > You mind if I revamp this PR and try to see what we need to do to update CUDA? I think the tests not passing comes from the fact that we also need to update CUDAKernels to version 0.3.3 (we are now using 0.3.0); > > Actually for me everything works very good from main just switching to CUDA 3.8.0 and CUDAKernels 0.3.3; > ; > That is very exciting! Do you know of any scaling results that people have done using this multiGPU approach? I'd be keen to try this with Oceananigans when it's working. I know that we tried using MPI and GPU last summer and had some problems. One, getting it to work was a pain. Two, the effiicency dropped down to 60% when going fro 1 to 2 GPUs. I now we can do better, and maybe this is a way of doing that. One key problem to solve is that we cannot pass non-contiguous data between GPUs without scalar operations. This affects both ""direct"" communication via the CUDA.jl API and cuda-aware MPI. As a result passing non-continuous data is _extremely_ slow and is probably the primary reason for the abysmal multi-GPU scaling we saw. I believe @simone-silvestri is going to use a single layer buffer to pass halo data (copy halo to buffer, pass to buffer on remote device, then copy from remote buffer to remote halo). Once that's implemented we can potentially use the same code for a multi-node implementation via CUDA-aware MPI.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1044990716
https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1044990716:161,Deployability,update,update,161,"> > We would need CUDA 3.8.0 to develop multiGPU architectures without having to use MPI.; > > You mind if I revamp this PR and try to see what we need to do to update CUDA? I think the tests not passing comes from the fact that we also need to update CUDAKernels to version 0.3.3 (we are now using 0.3.0); > > Actually for me everything works very good from main just switching to CUDA 3.8.0 and CUDAKernels 0.3.3; > ; > That is very exciting! Do you know of any scaling results that people have done using this multiGPU approach? I'd be keen to try this with Oceananigans when it's working. I know that we tried using MPI and GPU last summer and had some problems. One, getting it to work was a pain. Two, the effiicency dropped down to 60% when going fro 1 to 2 GPUs. I now we can do better, and maybe this is a way of doing that. One key problem to solve is that we cannot pass non-contiguous data between GPUs without scalar operations. This affects both ""direct"" communication via the CUDA.jl API and cuda-aware MPI. As a result passing non-continuous data is _extremely_ slow and is probably the primary reason for the abysmal multi-GPU scaling we saw. I believe @simone-silvestri is going to use a single layer buffer to pass halo data (copy halo to buffer, pass to buffer on remote device, then copy from remote buffer to remote halo). Once that's implemented we can potentially use the same code for a multi-node implementation via CUDA-aware MPI.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1044990716
https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1044990716:245,Deployability,update,update,245,"> > We would need CUDA 3.8.0 to develop multiGPU architectures without having to use MPI.; > > You mind if I revamp this PR and try to see what we need to do to update CUDA? I think the tests not passing comes from the fact that we also need to update CUDAKernels to version 0.3.3 (we are now using 0.3.0); > > Actually for me everything works very good from main just switching to CUDA 3.8.0 and CUDAKernels 0.3.3; > ; > That is very exciting! Do you know of any scaling results that people have done using this multiGPU approach? I'd be keen to try this with Oceananigans when it's working. I know that we tried using MPI and GPU last summer and had some problems. One, getting it to work was a pain. Two, the effiicency dropped down to 60% when going fro 1 to 2 GPUs. I now we can do better, and maybe this is a way of doing that. One key problem to solve is that we cannot pass non-contiguous data between GPUs without scalar operations. This affects both ""direct"" communication via the CUDA.jl API and cuda-aware MPI. As a result passing non-continuous data is _extremely_ slow and is probably the primary reason for the abysmal multi-GPU scaling we saw. I believe @simone-silvestri is going to use a single layer buffer to pass halo data (copy halo to buffer, pass to buffer on remote device, then copy from remote buffer to remote halo). Once that's implemented we can potentially use the same code for a multi-node implementation via CUDA-aware MPI.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1044990716
https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1044990716:1047,Deployability,continuous,continuous,1047,"> > We would need CUDA 3.8.0 to develop multiGPU architectures without having to use MPI.; > > You mind if I revamp this PR and try to see what we need to do to update CUDA? I think the tests not passing comes from the fact that we also need to update CUDAKernels to version 0.3.3 (we are now using 0.3.0); > > Actually for me everything works very good from main just switching to CUDA 3.8.0 and CUDAKernels 0.3.3; > ; > That is very exciting! Do you know of any scaling results that people have done using this multiGPU approach? I'd be keen to try this with Oceananigans when it's working. I know that we tried using MPI and GPU last summer and had some problems. One, getting it to work was a pain. Two, the effiicency dropped down to 60% when going fro 1 to 2 GPUs. I now we can do better, and maybe this is a way of doing that. One key problem to solve is that we cannot pass non-contiguous data between GPUs without scalar operations. This affects both ""direct"" communication via the CUDA.jl API and cuda-aware MPI. As a result passing non-continuous data is _extremely_ slow and is probably the primary reason for the abysmal multi-GPU scaling we saw. I believe @simone-silvestri is going to use a single layer buffer to pass halo data (copy halo to buffer, pass to buffer on remote device, then copy from remote buffer to remote halo). Once that's implemented we can potentially use the same code for a multi-node implementation via CUDA-aware MPI.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1044990716
https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1044990716:186,Testability,test,tests,186,"> > We would need CUDA 3.8.0 to develop multiGPU architectures without having to use MPI.; > > You mind if I revamp this PR and try to see what we need to do to update CUDA? I think the tests not passing comes from the fact that we also need to update CUDAKernels to version 0.3.3 (we are now using 0.3.0); > > Actually for me everything works very good from main just switching to CUDA 3.8.0 and CUDAKernels 0.3.3; > ; > That is very exciting! Do you know of any scaling results that people have done using this multiGPU approach? I'd be keen to try this with Oceananigans when it's working. I know that we tried using MPI and GPU last summer and had some problems. One, getting it to work was a pain. Two, the effiicency dropped down to 60% when going fro 1 to 2 GPUs. I now we can do better, and maybe this is a way of doing that. One key problem to solve is that we cannot pass non-contiguous data between GPUs without scalar operations. This affects both ""direct"" communication via the CUDA.jl API and cuda-aware MPI. As a result passing non-continuous data is _extremely_ slow and is probably the primary reason for the abysmal multi-GPU scaling we saw. I believe @simone-silvestri is going to use a single layer buffer to pass halo data (copy halo to buffer, pass to buffer on remote device, then copy from remote buffer to remote halo). Once that's implemented we can potentially use the same code for a multi-node implementation via CUDA-aware MPI.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1044990716
https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1045537824:49,Deployability,upgrade,upgraded,49,@simone-silvestri I opened #2255 in which I just upgraded CUDA and CUDAKernels. Feel free to work on that and make it work? Then we can close this one.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1045537824
https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1045565235:51,Deployability,upgrade,upgraded,51,> @simone-silvestri I opened #2255 in which I just upgraded CUDA and CUDAKernels. Feel free to work on that and make it work? Then we can close this one. He probably wants to work on it at #2253 ?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1045565235
https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1045569215:53,Deployability,upgrade,upgraded,53,> > @simone-silvestri I opened #2255 in which I just upgraded CUDA and CUDAKernels. Feel free to work on that and make it work? Then we can close this one.; > ; > He probably wants to work on it at #2253 ?. Either! Feel free to close any PR is not needed!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-1045569215
https://github.com/CliMA/Oceananigans.jl/issues/2006#issuecomment-1479955890:58,Safety,avoid,avoid,58,"Let's table this, one nice thing about numbers is that we avoid the need for ""x"" and ""lambda""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2006#issuecomment-1479955890
https://github.com/CliMA/Oceananigans.jl/issues/2007#issuecomment-941336434:34,Deployability,update,updated,34,"Yeah, this is confusing. @navidcy updated the docs so that `\vec v = (u, v, w)` is three-dimensional, while `\vec u = (u, v)` is two-dimensional. Right now, we only support two-dimensional Stokes drift, so two-dimensionalization would be fine. In the future it's in principle possible to support Stokes drift with a vertical component, but there are some details regarding divergent Stokes drift fields / divergent Lagrangian-mean velocity fields that would have to be considered. Because of the complications of 3D Stokes drift maybe it's best to explicitly state that the Stokes drift is 2D (and use `\vec u^S`?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2007#issuecomment-941336434
https://github.com/CliMA/Oceananigans.jl/pull/2010#issuecomment-942659233:251,Safety,avoid,avoid,251,"Resolution is kinda used ambiguously, which is why we renamed ""resolution"" to ""size"", no?. While most people take ""resolution"" to mean grid spacing (myself included), as you yourself pointed out some can take it to mean grid size, so I feel we should avoid this word. I could just keep it as ""grid spacing"" which is absolutely clear and merge it as it is.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2010#issuecomment-942659233
https://github.com/CliMA/Oceananigans.jl/pull/2010#issuecomment-942659233:327,Usability,clear,clear,327,"Resolution is kinda used ambiguously, which is why we renamed ""resolution"" to ""size"", no?. While most people take ""resolution"" to mean grid spacing (myself included), as you yourself pointed out some can take it to mean grid size, so I feel we should avoid this word. I could just keep it as ""grid spacing"" which is absolutely clear and merge it as it is.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2010#issuecomment-942659233
https://github.com/CliMA/Oceananigans.jl/pull/2013#issuecomment-946211816:33,Testability,Test,Test,33,"This is the tentative plan: ; 1. Test the Split-Explicit time-stepping in standalone mode without the 3D model; 2. Write kernels and tests for computing vertical integrals of tendency terms; 3. Write the AB extrapolation function for the tendency terms; 4. Write the ""reconciliation"" kernel that takes away the barotropic component of the velocity field and adds in the new one; 5. Test everything together in various channel settings",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2013#issuecomment-946211816
https://github.com/CliMA/Oceananigans.jl/pull/2013#issuecomment-946211816:133,Testability,test,tests,133,"This is the tentative plan: ; 1. Test the Split-Explicit time-stepping in standalone mode without the 3D model; 2. Write kernels and tests for computing vertical integrals of tendency terms; 3. Write the AB extrapolation function for the tendency terms; 4. Write the ""reconciliation"" kernel that takes away the barotropic component of the velocity field and adds in the new one; 5. Test everything together in various channel settings",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2013#issuecomment-946211816
https://github.com/CliMA/Oceananigans.jl/pull/2013#issuecomment-946211816:382,Testability,Test,Test,382,"This is the tentative plan: ; 1. Test the Split-Explicit time-stepping in standalone mode without the 3D model; 2. Write kernels and tests for computing vertical integrals of tendency terms; 3. Write the AB extrapolation function for the tendency terms; 4. Write the ""reconciliation"" kernel that takes away the barotropic component of the velocity field and adds in the new one; 5. Test everything together in various channel settings",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2013#issuecomment-946211816
https://github.com/CliMA/Oceananigans.jl/pull/2013#issuecomment-1014927629:315,Testability,test,test,315,Just adding here as a small reminder: . Currently the split-explicit scheme does not seem to conserve to machine precision the free-surface height average (as it should). In the current iteration it only conserves to 8 digits. This is only when it is implemented as a part of the hydrostatic model. In a standalone test it does seem to conserve to machine precision. Once this issue is isolated and fixed I'd say it's good to go for merging,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2013#issuecomment-1014927629
https://github.com/CliMA/Oceananigans.jl/pull/2013#issuecomment-1014949521:322,Testability,test,test,322,> Just adding here as a small reminder:; > ; > Currently the split-explicit scheme does not seem to conserve to machine precision the free-surface height average (as it should). In the current iteration it only conserves to 8 digits. This is only when it is implemented as a part of the hydrostatic model. In a standalone test it does seem to conserve to machine precision. Once this issue is isolated and fixed I'd say it's good to go for merging. @sandreza are you using AB time-stepping in the standalone test?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2013#issuecomment-1014949521
https://github.com/CliMA/Oceananigans.jl/pull/2013#issuecomment-1014949521:508,Testability,test,test,508,> Just adding here as a small reminder:; > ; > Currently the split-explicit scheme does not seem to conserve to machine precision the free-surface height average (as it should). In the current iteration it only conserves to 8 digits. This is only when it is implemented as a part of the hydrostatic model. In a standalone test it does seem to conserve to machine precision. Once this issue is isolated and fixed I'd say it's good to go for merging. @sandreza are you using AB time-stepping in the standalone test?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2013#issuecomment-1014949521
https://github.com/CliMA/Oceananigans.jl/pull/2013#issuecomment-1014966091:36,Testability,test,test,36,> . With the geostrophic adjustment test the large timesteps are computed with AB2. The small substeps are computed using the method that @jm-c recommended. After doing some more testing it seems that the lack of conservation has been isolated to a topology with bounded directions. In the fully periodic case the eta field mean is conserved to machine precision,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2013#issuecomment-1014966091
https://github.com/CliMA/Oceananigans.jl/pull/2013#issuecomment-1014966091:179,Testability,test,testing,179,> . With the geostrophic adjustment test the large timesteps are computed with AB2. The small substeps are computed using the method that @jm-c recommended. After doing some more testing it seems that the lack of conservation has been isolated to a topology with bounded directions. In the fully periodic case the eta field mean is conserved to machine precision,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2013#issuecomment-1014966091
https://github.com/CliMA/Oceananigans.jl/pull/2013#issuecomment-1016554181:4,Testability,Test,Test,4,"> * Test the Split-Explicit time-stepping in standalone mode without the 3D model; > * Write kernels and tests for computing vertical integrals of tendency terms; > * Write the AB extrapolation function for the tendency terms; > * Write the ""reconciliation"" kernel that takes away the barotropic component of the velocity field and adds in the new one; > * Test everything together in various channel settings. This has all been done",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2013#issuecomment-1016554181
https://github.com/CliMA/Oceananigans.jl/pull/2013#issuecomment-1016554181:105,Testability,test,tests,105,"> * Test the Split-Explicit time-stepping in standalone mode without the 3D model; > * Write kernels and tests for computing vertical integrals of tendency terms; > * Write the AB extrapolation function for the tendency terms; > * Write the ""reconciliation"" kernel that takes away the barotropic component of the velocity field and adds in the new one; > * Test everything together in various channel settings. This has all been done",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2013#issuecomment-1016554181
https://github.com/CliMA/Oceananigans.jl/pull/2013#issuecomment-1016554181:357,Testability,Test,Test,357,"> * Test the Split-Explicit time-stepping in standalone mode without the 3D model; > * Write kernels and tests for computing vertical integrals of tendency terms; > * Write the AB extrapolation function for the tendency terms; > * Write the ""reconciliation"" kernel that takes away the barotropic component of the velocity field and adds in the new one; > * Test everything together in various channel settings. This has all been done",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2013#issuecomment-1016554181
https://github.com/CliMA/Oceananigans.jl/pull/2016#issuecomment-945829712:38,Testability,test,test,38,I guess we need a list of closures to test somewhere --- where should it go?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2016#issuecomment-945829712
https://github.com/CliMA/Oceananigans.jl/pull/2016#issuecomment-946342621:202,Availability,redundant,redundant,202,Hm... I also noticed they were defined here:; https://github.com/CliMA/Oceananigans.jl/blob/a3faff771f3dec60be12cc7fab8ebabeffc1657e/test/test_time_stepping.jl#L202; so I thought the code I removed was redundant. But perhaps some tests were using that... I'll look into it.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2016#issuecomment-946342621
https://github.com/CliMA/Oceananigans.jl/pull/2016#issuecomment-946342621:202,Safety,redund,redundant,202,Hm... I also noticed they were defined here:; https://github.com/CliMA/Oceananigans.jl/blob/a3faff771f3dec60be12cc7fab8ebabeffc1657e/test/test_time_stepping.jl#L202; so I thought the code I removed was redundant. But perhaps some tests were using that... I'll look into it.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2016#issuecomment-946342621
https://github.com/CliMA/Oceananigans.jl/pull/2016#issuecomment-946342621:133,Testability,test,test,133,Hm... I also noticed they were defined here:; https://github.com/CliMA/Oceananigans.jl/blob/a3faff771f3dec60be12cc7fab8ebabeffc1657e/test/test_time_stepping.jl#L202; so I thought the code I removed was redundant. But perhaps some tests were using that... I'll look into it.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2016#issuecomment-946342621
https://github.com/CliMA/Oceananigans.jl/pull/2016#issuecomment-946342621:230,Testability,test,tests,230,Hm... I also noticed they were defined here:; https://github.com/CliMA/Oceananigans.jl/blob/a3faff771f3dec60be12cc7fab8ebabeffc1657e/test/test_time_stepping.jl#L202; so I thought the code I removed was redundant. But perhaps some tests were using that... I'll look into it.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2016#issuecomment-946342621
https://github.com/CliMA/Oceananigans.jl/issues/2017#issuecomment-945745910:60,Modifiability,flexible,flexible,60,"@tomchor and @francispoulin (and more) should this include ""flexible"" (to convey the LES <-> general circulation, lab/theory simulations <-> exoplanets, etc.... )?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2017#issuecomment-945745910
https://github.com/CliMA/Oceananigans.jl/issues/2017#issuecomment-945819977:233,Modifiability,flexible,flexible,233,"I feel that labeling it ""weird"" is a harsh judgement. But I would say that using the word ""oceanic"" to describe software is ""quirky"". If folks prefer ""ocean-flavored"" (also quirky, just more characters), let's switch to that. Being ""flexible"" is probably one of our core philosophies as well so I agree with adding that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2017#issuecomment-945819977
https://github.com/CliMA/Oceananigans.jl/issues/2017#issuecomment-945841241:235,Modifiability,flexible,flexible,235,"> I feel that labeling it ""weird"" is a harsh judgement. But I would say that using the word ""oceanic"" to describe software is ""quirky"". If folks prefer ""ocean-flavored"" (also quirky, just more characters), let's switch to that. Being ""flexible"" is probably one of our core philosophies as well so I agree with adding that. Sorry, didn't mean to sound harsh. I just really didn't know what other word to use. Also, @glwagner I don't think we have access to change that description. It probably needs to be someone from Clima.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2017#issuecomment-945841241
https://github.com/CliMA/Oceananigans.jl/issues/2017#issuecomment-945841241:446,Security,access,access,446,"> I feel that labeling it ""weird"" is a harsh judgement. But I would say that using the word ""oceanic"" to describe software is ""quirky"". If folks prefer ""ocean-flavored"" (also quirky, just more characters), let's switch to that. Being ""flexible"" is probably one of our core philosophies as well so I agree with adding that. Sorry, didn't mean to sound harsh. I just really didn't know what other word to use. Also, @glwagner I don't think we have access to change that description. It probably needs to be someone from Clima.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2017#issuecomment-945841241
https://github.com/CliMA/Oceananigans.jl/issues/2017#issuecomment-955788563:123,Modifiability,flexible,flexible,123,"@glwagner or @ali-ramadhan probably can change that. I actually like the description as is. :); I'd probably just add the ""flexible"" to the current description: ""A flexible oceanic...""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2017#issuecomment-955788563
https://github.com/CliMA/Oceananigans.jl/issues/2017#issuecomment-955788563:164,Modifiability,flexible,flexible,164,"@glwagner or @ali-ramadhan probably can change that. I actually like the description as is. :); I'd probably just add the ""flexible"" to the current description: ""A flexible oceanic...""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2017#issuecomment-955788563
https://github.com/CliMA/Oceananigans.jl/issues/2017#issuecomment-960167339:98,Modifiability,flexible,flexible,98,"I put some work into the description, removing ""oceanic"" in favor of ""ocean-flavored"" and adding ""flexible"". Please reopen if there's still an issue!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2017#issuecomment-960167339
https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945144113:364,Usability,intuit,intuitive,364,This apparently has to do with the fact that . ```julia; julia> grid1.z === grid2.z; false. julia> grid1.z === grid2.z; false. ```. I don't think this is a due to the grid design as this appears to be standard Julia behavior for arrays:. ```julia; julia> zeros(3) == zeros(3); true. julia> zeros(3) === zeros(3); false. ```. which seems pretty counter-intuitive to me and apparently there's some discussion about this behavior in julia already: https://github.com/JuliaLang/julia/issues/4648,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945144113
https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945824870:417,Usability,intuit,intuitive,417,"> This apparently has to do with the fact that; > ; > ```julia; > julia> grid1.z === grid2.z; > false; > ; > julia> grid1.z === grid2.z; > false; > ```; > ; > I don't think this is a due to the grid design as this appears to be standard Julia behavior for arrays:; > ; > ```julia; > julia> zeros(3) == zeros(3); > true; > ; > julia> zeros(3) === zeros(3); > false; > ```; > ; > which seems pretty counter-intuitive to me and apparently there's some discussion about this behavior in julia already: [JuliaLang/julia#4648](https://github.com/JuliaLang/julia/issues/4648). `===` means that ""no program can distinguish"" between the objects. For arrays this basically means they point to the same space in memory; changes to one imply changes in another. `==` is a weaker statement, usually about numerical equality. What's counter intuitive?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945824870
https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945824870:839,Usability,intuit,intuitive,839,"> This apparently has to do with the fact that; > ; > ```julia; > julia> grid1.z === grid2.z; > false; > ; > julia> grid1.z === grid2.z; > false; > ```; > ; > I don't think this is a due to the grid design as this appears to be standard Julia behavior for arrays:; > ; > ```julia; > julia> zeros(3) == zeros(3); > true; > ; > julia> zeros(3) === zeros(3); > false; > ```; > ; > which seems pretty counter-intuitive to me and apparently there's some discussion about this behavior in julia already: [JuliaLang/julia#4648](https://github.com/JuliaLang/julia/issues/4648). `===` means that ""no program can distinguish"" between the objects. For arrays this basically means they point to the same space in memory; changes to one imply changes in another. `==` is a weaker statement, usually about numerical equality. What's counter intuitive?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945824870
https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945826936:195,Availability,checkpoint,checkpointing,195,"I think there are probably a few other things to fix here, because we can't ""restore"" a grid with a GPU architecture. Fixing this fully really requires finishing #1998 first, and overhauling the checkpointing infrastructure to match so that the checkpointer is ""architecture aware"". We should also add tests for checkpointing with other grid types.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945826936
https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945826936:245,Availability,checkpoint,checkpointer,245,"I think there are probably a few other things to fix here, because we can't ""restore"" a grid with a GPU architecture. Fixing this fully really requires finishing #1998 first, and overhauling the checkpointing infrastructure to match so that the checkpointer is ""architecture aware"". We should also add tests for checkpointing with other grid types.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945826936
https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945826936:312,Availability,checkpoint,checkpointing,312,"I think there are probably a few other things to fix here, because we can't ""restore"" a grid with a GPU architecture. Fixing this fully really requires finishing #1998 first, and overhauling the checkpointing infrastructure to match so that the checkpointer is ""architecture aware"". We should also add tests for checkpointing with other grid types.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945826936
https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945826936:302,Testability,test,tests,302,"I think there are probably a few other things to fix here, because we can't ""restore"" a grid with a GPU architecture. Fixing this fully really requires finishing #1998 first, and overhauling the checkpointing infrastructure to match so that the checkpointer is ""architecture aware"". We should also add tests for checkpointing with other grid types.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945826936
https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945862255:416,Performance,perform,performing,416,"> === means that ""no program can distinguish"" between the objects. For arrays this basically means they point to the same space in memory; changes to one imply changes in another. == is a weaker statement, usually about numerical equality. What's counter intuitive?. Oh yeah I know about `===`. What I mean is that you test two grids with `==`, but Julia then tests each property with `===`. So the user is actually performing a much stricter operation than what it seems at first sight. That's the un-intuitive part to me. Although I may be missing something.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945862255
https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945862255:319,Testability,test,test,319,"> === means that ""no program can distinguish"" between the objects. For arrays this basically means they point to the same space in memory; changes to one imply changes in another. == is a weaker statement, usually about numerical equality. What's counter intuitive?. Oh yeah I know about `===`. What I mean is that you test two grids with `==`, but Julia then tests each property with `===`. So the user is actually performing a much stricter operation than what it seems at first sight. That's the un-intuitive part to me. Although I may be missing something.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945862255
https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945862255:360,Testability,test,tests,360,"> === means that ""no program can distinguish"" between the objects. For arrays this basically means they point to the same space in memory; changes to one imply changes in another. == is a weaker statement, usually about numerical equality. What's counter intuitive?. Oh yeah I know about `===`. What I mean is that you test two grids with `==`, but Julia then tests each property with `===`. So the user is actually performing a much stricter operation than what it seems at first sight. That's the un-intuitive part to me. Although I may be missing something.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945862255
https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945862255:255,Usability,intuit,intuitive,255,"> === means that ""no program can distinguish"" between the objects. For arrays this basically means they point to the same space in memory; changes to one imply changes in another. == is a weaker statement, usually about numerical equality. What's counter intuitive?. Oh yeah I know about `===`. What I mean is that you test two grids with `==`, but Julia then tests each property with `===`. So the user is actually performing a much stricter operation than what it seems at first sight. That's the un-intuitive part to me. Although I may be missing something.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945862255
https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945862255:502,Usability,intuit,intuitive,502,"> === means that ""no program can distinguish"" between the objects. For arrays this basically means they point to the same space in memory; changes to one imply changes in another. == is a weaker statement, usually about numerical equality. What's counter intuitive?. Oh yeah I know about `===`. What I mean is that you test two grids with `==`, but Julia then tests each property with `===`. So the user is actually performing a much stricter operation than what it seems at first sight. That's the un-intuitive part to me. Although I may be missing something.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945862255
https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945891999:87,Usability,intuit,intuitive,87,"> That's because `==` falls back to `===`, right?. No idea! Like I said, it's not very intuitive behavior to me. You probably understand this way better.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945891999
https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945212788:109,Availability,error,error,109,"> @tomchor did you try the MWE in #2018 with this fix and it's all good?. It fixes it for CPUs, but I get an error for GPU architecture. It's likely that we need to allow scalar operations due to `==`. I'm planning on trying that tomorrow and I won't merge before it also works for GPUs. (I was wondering if we should add this as a test...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945212788
https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945212788:332,Testability,test,test,332,"> @tomchor did you try the MWE in #2018 with this fix and it's all good?. It fixes it for CPUs, but I get an error for GPU architecture. It's likely that we need to allow scalar operations due to `==`. I'm planning on trying that tomorrow and I won't merge before it also works for GPUs. (I was wondering if we should add this as a test...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945212788
https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945215869:37,Availability,error,error,37,"> It fixes it for CPUs, but I get an error for GPU architecture. It's likely that we need to allow scalar operations due to `==`. I'm planning on trying that tomorrow and I won't merge before it also works for GPUs. (I was wondering if we should add this as a test...). Hm... Whatever we do should work for both CPUs and GPUs. @glwagner and I were thinking about equality between grids at some point. Probably (I'm not sure -- you can double check that), the fix in this PR fails for GPUs, because when in that case when the checkpointer tries to compare the two grids, the one saved on disk has `Arrays` while the other one has `CuArrays`. If that's the case, we need a solution that remedy this and call two grids ""equal"" despite the device they live on. Some of these issue are related or discussed within #1825 and #1998.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945215869
https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945215869:525,Availability,checkpoint,checkpointer,525,"> It fixes it for CPUs, but I get an error for GPU architecture. It's likely that we need to allow scalar operations due to `==`. I'm planning on trying that tomorrow and I won't merge before it also works for GPUs. (I was wondering if we should add this as a test...). Hm... Whatever we do should work for both CPUs and GPUs. @glwagner and I were thinking about equality between grids at some point. Probably (I'm not sure -- you can double check that), the fix in this PR fails for GPUs, because when in that case when the checkpointer tries to compare the two grids, the one saved on disk has `Arrays` while the other one has `CuArrays`. If that's the case, we need a solution that remedy this and call two grids ""equal"" despite the device they live on. Some of these issue are related or discussed within #1825 and #1998.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945215869
https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945215869:260,Testability,test,test,260,"> It fixes it for CPUs, but I get an error for GPU architecture. It's likely that we need to allow scalar operations due to `==`. I'm planning on trying that tomorrow and I won't merge before it also works for GPUs. (I was wondering if we should add this as a test...). Hm... Whatever we do should work for both CPUs and GPUs. @glwagner and I were thinking about equality between grids at some point. Probably (I'm not sure -- you can double check that), the fix in this PR fails for GPUs, because when in that case when the checkpointer tries to compare the two grids, the one saved on disk has `Arrays` while the other one has `CuArrays`. If that's the case, we need a solution that remedy this and call two grids ""equal"" despite the device they live on. Some of these issue are related or discussed within #1825 and #1998.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945215869
https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945219284:223,Availability,checkpoint,checkpoint,223,"> A test would be nice to come along with this PR. I can help out with that if you want. Thanks! I'll take you up on that if you don't mind. Given that you said that other grids also have arrays, it might be best to expand checkpoint testing for all grids?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945219284
https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945219284:4,Testability,test,test,4,"> A test would be nice to come along with this PR. I can help out with that if you want. Thanks! I'll take you up on that if you don't mind. Given that you said that other grids also have arrays, it might be best to expand checkpoint testing for all grids?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945219284
https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945219284:234,Testability,test,testing,234,"> A test would be nice to come along with this PR. I can help out with that if you want. Thanks! I'll take you up on that if you don't mind. Given that you said that other grids also have arrays, it might be best to expand checkpoint testing for all grids?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945219284
https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945219663:232,Availability,checkpoint,checkpoint,232,"> > A test would be nice to come along with this PR. I can help out with that if you want.; > ; > Thanks! I'll take you up on that if you don't mind. Given that you said that other grids also have arrays, it might be best to expand checkpoint testing for all grids?. Yeap. But first we need to sort the GPU/CPU issue. For example, two grids that are identical but the arrays of one live on CPU but the other on GPU should they be considered equal? I believe in that case we should add methods so that:; ```julia; julia> grid1 == grid2; true. julia> grid1 === grid2; false; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945219663
https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945219663:6,Testability,test,test,6,"> > A test would be nice to come along with this PR. I can help out with that if you want.; > ; > Thanks! I'll take you up on that if you don't mind. Given that you said that other grids also have arrays, it might be best to expand checkpoint testing for all grids?. Yeap. But first we need to sort the GPU/CPU issue. For example, two grids that are identical but the arrays of one live on CPU but the other on GPU should they be considered equal? I believe in that case we should add methods so that:; ```julia; julia> grid1 == grid2; true. julia> grid1 === grid2; false; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945219663
https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945219663:243,Testability,test,testing,243,"> > A test would be nice to come along with this PR. I can help out with that if you want.; > ; > Thanks! I'll take you up on that if you don't mind. Given that you said that other grids also have arrays, it might be best to expand checkpoint testing for all grids?. Yeap. But first we need to sort the GPU/CPU issue. For example, two grids that are identical but the arrays of one live on CPU but the other on GPU should they be considered equal? I believe in that case we should add methods so that:; ```julia; julia> grid1 == grid2; true. julia> grid1 === grid2; false; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945219663
https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945886370:310,Availability,checkpoint,checkpointing,310,"Regarding the comment [here](https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945826936). > I think there are probably a few other things to fix here, because we can't ""restore"" a grid with a GPU architecture.; >; > Fixing this fully really requires finishing #1998 first, and overhauling the checkpointing infrastructure to match so that the checkpointer is ""architecture aware"". We should also add tests for checkpointing with other grid types. I'm not sure what you mean by ""restoring"" a grid with GPU architecture. This last commit was enough for me to pickup my GPU-architecture simulation with a VerticallyStretchedGrid. For example, the following mwe works in this PR:. ```julia; using Oceananigans; using CUDA. grid1 = VerticallyStretchedRectilinearGrid(size=(2, 2, 2),; architecture=GPU(),; x=(0, 1), y=(0, 1), z_faces=k -> k,; halo=(3,3,3),; ). grid2 = VerticallyStretchedRectilinearGrid(size=(2, 2, 2),; architecture=GPU(),; x=(0, 1), y=(0, 1), z_faces=k -> k,; halo=(3,3,3),; ). if CUDA.@allowscalar grid1!=grid2; throw(error); end. model = NonhydrostaticModel(grid=grid1,; architecture=GPU(),; ). progress(sim) = @info ""Iteration: $(sim.model.clock.iteration), time: $(round(Int, sim.model.clock.time))""; simulation = Simulation(model, t=1, stop_time=10, progress=progress); simulation.output_writers[:chk_writer] = Checkpointer(model;; dir=""."",; prefix = ""mwe"",; schedule = TimeInterval(2),; force = false,; cleanup = true,; ). run!(simulation). simulation.stop_time = 20. run!(simulation, pickup=true); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945886370
https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945886370:360,Availability,checkpoint,checkpointer,360,"Regarding the comment [here](https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945826936). > I think there are probably a few other things to fix here, because we can't ""restore"" a grid with a GPU architecture.; >; > Fixing this fully really requires finishing #1998 first, and overhauling the checkpointing infrastructure to match so that the checkpointer is ""architecture aware"". We should also add tests for checkpointing with other grid types. I'm not sure what you mean by ""restoring"" a grid with GPU architecture. This last commit was enough for me to pickup my GPU-architecture simulation with a VerticallyStretchedGrid. For example, the following mwe works in this PR:. ```julia; using Oceananigans; using CUDA. grid1 = VerticallyStretchedRectilinearGrid(size=(2, 2, 2),; architecture=GPU(),; x=(0, 1), y=(0, 1), z_faces=k -> k,; halo=(3,3,3),; ). grid2 = VerticallyStretchedRectilinearGrid(size=(2, 2, 2),; architecture=GPU(),; x=(0, 1), y=(0, 1), z_faces=k -> k,; halo=(3,3,3),; ). if CUDA.@allowscalar grid1!=grid2; throw(error); end. model = NonhydrostaticModel(grid=grid1,; architecture=GPU(),; ). progress(sim) = @info ""Iteration: $(sim.model.clock.iteration), time: $(round(Int, sim.model.clock.time))""; simulation = Simulation(model, t=1, stop_time=10, progress=progress); simulation.output_writers[:chk_writer] = Checkpointer(model;; dir=""."",; prefix = ""mwe"",; schedule = TimeInterval(2),; force = false,; cleanup = true,; ). run!(simulation). simulation.stop_time = 20. run!(simulation, pickup=true); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945886370
https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945886370:427,Availability,checkpoint,checkpointing,427,"Regarding the comment [here](https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945826936). > I think there are probably a few other things to fix here, because we can't ""restore"" a grid with a GPU architecture.; >; > Fixing this fully really requires finishing #1998 first, and overhauling the checkpointing infrastructure to match so that the checkpointer is ""architecture aware"". We should also add tests for checkpointing with other grid types. I'm not sure what you mean by ""restoring"" a grid with GPU architecture. This last commit was enough for me to pickup my GPU-architecture simulation with a VerticallyStretchedGrid. For example, the following mwe works in this PR:. ```julia; using Oceananigans; using CUDA. grid1 = VerticallyStretchedRectilinearGrid(size=(2, 2, 2),; architecture=GPU(),; x=(0, 1), y=(0, 1), z_faces=k -> k,; halo=(3,3,3),; ). grid2 = VerticallyStretchedRectilinearGrid(size=(2, 2, 2),; architecture=GPU(),; x=(0, 1), y=(0, 1), z_faces=k -> k,; halo=(3,3,3),; ). if CUDA.@allowscalar grid1!=grid2; throw(error); end. model = NonhydrostaticModel(grid=grid1,; architecture=GPU(),; ). progress(sim) = @info ""Iteration: $(sim.model.clock.iteration), time: $(round(Int, sim.model.clock.time))""; simulation = Simulation(model, t=1, stop_time=10, progress=progress); simulation.output_writers[:chk_writer] = Checkpointer(model;; dir=""."",; prefix = ""mwe"",; schedule = TimeInterval(2),; force = false,; cleanup = true,; ). run!(simulation). simulation.stop_time = 20. run!(simulation, pickup=true); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945886370
https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945886370:1049,Availability,error,error,1049,"Regarding the comment [here](https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945826936). > I think there are probably a few other things to fix here, because we can't ""restore"" a grid with a GPU architecture.; >; > Fixing this fully really requires finishing #1998 first, and overhauling the checkpointing infrastructure to match so that the checkpointer is ""architecture aware"". We should also add tests for checkpointing with other grid types. I'm not sure what you mean by ""restoring"" a grid with GPU architecture. This last commit was enough for me to pickup my GPU-architecture simulation with a VerticallyStretchedGrid. For example, the following mwe works in this PR:. ```julia; using Oceananigans; using CUDA. grid1 = VerticallyStretchedRectilinearGrid(size=(2, 2, 2),; architecture=GPU(),; x=(0, 1), y=(0, 1), z_faces=k -> k,; halo=(3,3,3),; ). grid2 = VerticallyStretchedRectilinearGrid(size=(2, 2, 2),; architecture=GPU(),; x=(0, 1), y=(0, 1), z_faces=k -> k,; halo=(3,3,3),; ). if CUDA.@allowscalar grid1!=grid2; throw(error); end. model = NonhydrostaticModel(grid=grid1,; architecture=GPU(),; ). progress(sim) = @info ""Iteration: $(sim.model.clock.iteration), time: $(round(Int, sim.model.clock.time))""; simulation = Simulation(model, t=1, stop_time=10, progress=progress); simulation.output_writers[:chk_writer] = Checkpointer(model;; dir=""."",; prefix = ""mwe"",; schedule = TimeInterval(2),; force = false,; cleanup = true,; ). run!(simulation). simulation.stop_time = 20. run!(simulation, pickup=true); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945886370
https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945886370:1347,Availability,Checkpoint,Checkpointer,1347,"Regarding the comment [here](https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945826936). > I think there are probably a few other things to fix here, because we can't ""restore"" a grid with a GPU architecture.; >; > Fixing this fully really requires finishing #1998 first, and overhauling the checkpointing infrastructure to match so that the checkpointer is ""architecture aware"". We should also add tests for checkpointing with other grid types. I'm not sure what you mean by ""restoring"" a grid with GPU architecture. This last commit was enough for me to pickup my GPU-architecture simulation with a VerticallyStretchedGrid. For example, the following mwe works in this PR:. ```julia; using Oceananigans; using CUDA. grid1 = VerticallyStretchedRectilinearGrid(size=(2, 2, 2),; architecture=GPU(),; x=(0, 1), y=(0, 1), z_faces=k -> k,; halo=(3,3,3),; ). grid2 = VerticallyStretchedRectilinearGrid(size=(2, 2, 2),; architecture=GPU(),; x=(0, 1), y=(0, 1), z_faces=k -> k,; halo=(3,3,3),; ). if CUDA.@allowscalar grid1!=grid2; throw(error); end. model = NonhydrostaticModel(grid=grid1,; architecture=GPU(),; ). progress(sim) = @info ""Iteration: $(sim.model.clock.iteration), time: $(round(Int, sim.model.clock.time))""; simulation = Simulation(model, t=1, stop_time=10, progress=progress); simulation.output_writers[:chk_writer] = Checkpointer(model;; dir=""."",; prefix = ""mwe"",; schedule = TimeInterval(2),; force = false,; cleanup = true,; ). run!(simulation). simulation.stop_time = 20. run!(simulation, pickup=true); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945886370
https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945886370:1395,Energy Efficiency,schedul,schedule,1395,"Regarding the comment [here](https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945826936). > I think there are probably a few other things to fix here, because we can't ""restore"" a grid with a GPU architecture.; >; > Fixing this fully really requires finishing #1998 first, and overhauling the checkpointing infrastructure to match so that the checkpointer is ""architecture aware"". We should also add tests for checkpointing with other grid types. I'm not sure what you mean by ""restoring"" a grid with GPU architecture. This last commit was enough for me to pickup my GPU-architecture simulation with a VerticallyStretchedGrid. For example, the following mwe works in this PR:. ```julia; using Oceananigans; using CUDA. grid1 = VerticallyStretchedRectilinearGrid(size=(2, 2, 2),; architecture=GPU(),; x=(0, 1), y=(0, 1), z_faces=k -> k,; halo=(3,3,3),; ). grid2 = VerticallyStretchedRectilinearGrid(size=(2, 2, 2),; architecture=GPU(),; x=(0, 1), y=(0, 1), z_faces=k -> k,; halo=(3,3,3),; ). if CUDA.@allowscalar grid1!=grid2; throw(error); end. model = NonhydrostaticModel(grid=grid1,; architecture=GPU(),; ). progress(sim) = @info ""Iteration: $(sim.model.clock.iteration), time: $(round(Int, sim.model.clock.time))""; simulation = Simulation(model, t=1, stop_time=10, progress=progress); simulation.output_writers[:chk_writer] = Checkpointer(model;; dir=""."",; prefix = ""mwe"",; schedule = TimeInterval(2),; force = false,; cleanup = true,; ). run!(simulation). simulation.stop_time = 20. run!(simulation, pickup=true); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945886370
https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945886370:417,Testability,test,tests,417,"Regarding the comment [here](https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945826936). > I think there are probably a few other things to fix here, because we can't ""restore"" a grid with a GPU architecture.; >; > Fixing this fully really requires finishing #1998 first, and overhauling the checkpointing infrastructure to match so that the checkpointer is ""architecture aware"". We should also add tests for checkpointing with other grid types. I'm not sure what you mean by ""restoring"" a grid with GPU architecture. This last commit was enough for me to pickup my GPU-architecture simulation with a VerticallyStretchedGrid. For example, the following mwe works in this PR:. ```julia; using Oceananigans; using CUDA. grid1 = VerticallyStretchedRectilinearGrid(size=(2, 2, 2),; architecture=GPU(),; x=(0, 1), y=(0, 1), z_faces=k -> k,; halo=(3,3,3),; ). grid2 = VerticallyStretchedRectilinearGrid(size=(2, 2, 2),; architecture=GPU(),; x=(0, 1), y=(0, 1), z_faces=k -> k,; halo=(3,3,3),; ). if CUDA.@allowscalar grid1!=grid2; throw(error); end. model = NonhydrostaticModel(grid=grid1,; architecture=GPU(),; ). progress(sim) = @info ""Iteration: $(sim.model.clock.iteration), time: $(round(Int, sim.model.clock.time))""; simulation = Simulation(model, t=1, stop_time=10, progress=progress); simulation.output_writers[:chk_writer] = Checkpointer(model;; dir=""."",; prefix = ""mwe"",; schedule = TimeInterval(2),; force = false,; cleanup = true,; ). run!(simulation). simulation.stop_time = 20. run!(simulation, pickup=true); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945886370
https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945890117:25,Testability,test,tested,25,"So, everything that I've tested so far leads me to believe this is working with vertically stretched grids for now. I've tested a few examples with both CPU and GPU architecture and they've picked up successfully. (Although it's possible I'm missing something...) However, since @navidcy and @glwagner have reservations about this fix (regarding #1998) I won't expand it to all abstract grids for now. I think more discussions need to be done. I'll leave this PR open though since I need this fix to complete my research, if that's okay.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945890117
https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945890117:121,Testability,test,tested,121,"So, everything that I've tested so far leads me to believe this is working with vertically stretched grids for now. I've tested a few examples with both CPU and GPU architecture and they've picked up successfully. (Although it's possible I'm missing something...) However, since @navidcy and @glwagner have reservations about this fix (regarding #1998) I won't expand it to all abstract grids for now. I think more discussions need to be done. I'll leave this PR open though since I need this fix to complete my research, if that's okay.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945890117
https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945919406:603,Availability,checkpoint,checkpointing,603,"Can we just compare 1) the topology and 2) all of the nodes? I think that would be sufficient to determine equality. I'm worried if we don't explicitly check the topology that we might run into some edge cases where the nodes / spacings are the same but the topologies are different (these would possibly be pathological with 0 halo in a periodic / flat direction, but still good to explicitly check I think...). When comparing numeric equality for nodes, we should add `@allowscalar` as needed there. I think we should add a test that equality works as expected, as well. We should also add a test for checkpointing on stretched grids. I think its ok if we don't support a numeric equality for other grids --- we can build them up one at a time. They are specific to each grid. The main downside here is that we need to refactor our grid implementation to have a single `RectilinearGrid` (there's no reason to have different rectilinear grid types, since we can dispatch on the case that certain directions have constant spacing easily). So this code will go away when we make that change. But I think it's a useful incremental improvement for now while we still have two rectilinear grids, so I'm fine to have it go in once it's cleaned up. Because of this:. ```julia; julia> using CUDA. julia> a = rand(2); 2-element Vector{Float64}:; 0.8207604162394306; 0.3815099688071648. julia> b = CuArray(a); 2-element CuArray{Float64, 1}:; 0.8207604162394306; 0.3815099688071648. julia> CUDA.@allowscalar a == b; true; ```. I think that this will work if the checkpointed grid is deserialized onto the CPU, even though `model.grid` is on the GPU. I think this is what we want, so that's fortunate the above works.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945919406
https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945919406:788,Availability,down,downside,788,"Can we just compare 1) the topology and 2) all of the nodes? I think that would be sufficient to determine equality. I'm worried if we don't explicitly check the topology that we might run into some edge cases where the nodes / spacings are the same but the topologies are different (these would possibly be pathological with 0 halo in a periodic / flat direction, but still good to explicitly check I think...). When comparing numeric equality for nodes, we should add `@allowscalar` as needed there. I think we should add a test that equality works as expected, as well. We should also add a test for checkpointing on stretched grids. I think its ok if we don't support a numeric equality for other grids --- we can build them up one at a time. They are specific to each grid. The main downside here is that we need to refactor our grid implementation to have a single `RectilinearGrid` (there's no reason to have different rectilinear grid types, since we can dispatch on the case that certain directions have constant spacing easily). So this code will go away when we make that change. But I think it's a useful incremental improvement for now while we still have two rectilinear grids, so I'm fine to have it go in once it's cleaned up. Because of this:. ```julia; julia> using CUDA. julia> a = rand(2); 2-element Vector{Float64}:; 0.8207604162394306; 0.3815099688071648. julia> b = CuArray(a); 2-element CuArray{Float64, 1}:; 0.8207604162394306; 0.3815099688071648. julia> CUDA.@allowscalar a == b; true; ```. I think that this will work if the checkpointed grid is deserialized onto the CPU, even though `model.grid` is on the GPU. I think this is what we want, so that's fortunate the above works.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945919406
https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945919406:1552,Availability,checkpoint,checkpointed,1552,"Can we just compare 1) the topology and 2) all of the nodes? I think that would be sufficient to determine equality. I'm worried if we don't explicitly check the topology that we might run into some edge cases where the nodes / spacings are the same but the topologies are different (these would possibly be pathological with 0 halo in a periodic / flat direction, but still good to explicitly check I think...). When comparing numeric equality for nodes, we should add `@allowscalar` as needed there. I think we should add a test that equality works as expected, as well. We should also add a test for checkpointing on stretched grids. I think its ok if we don't support a numeric equality for other grids --- we can build them up one at a time. They are specific to each grid. The main downside here is that we need to refactor our grid implementation to have a single `RectilinearGrid` (there's no reason to have different rectilinear grid types, since we can dispatch on the case that certain directions have constant spacing easily). So this code will go away when we make that change. But I think it's a useful incremental improvement for now while we still have two rectilinear grids, so I'm fine to have it go in once it's cleaned up. Because of this:. ```julia; julia> using CUDA. julia> a = rand(2); 2-element Vector{Float64}:; 0.8207604162394306; 0.3815099688071648. julia> b = CuArray(a); 2-element CuArray{Float64, 1}:; 0.8207604162394306; 0.3815099688071648. julia> CUDA.@allowscalar a == b; true; ```. I think that this will work if the checkpointed grid is deserialized onto the CPU, even though `model.grid` is on the GPU. I think this is what we want, so that's fortunate the above works.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945919406
https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945919406:821,Modifiability,refactor,refactor,821,"Can we just compare 1) the topology and 2) all of the nodes? I think that would be sufficient to determine equality. I'm worried if we don't explicitly check the topology that we might run into some edge cases where the nodes / spacings are the same but the topologies are different (these would possibly be pathological with 0 halo in a periodic / flat direction, but still good to explicitly check I think...). When comparing numeric equality for nodes, we should add `@allowscalar` as needed there. I think we should add a test that equality works as expected, as well. We should also add a test for checkpointing on stretched grids. I think its ok if we don't support a numeric equality for other grids --- we can build them up one at a time. They are specific to each grid. The main downside here is that we need to refactor our grid implementation to have a single `RectilinearGrid` (there's no reason to have different rectilinear grid types, since we can dispatch on the case that certain directions have constant spacing easily). So this code will go away when we make that change. But I think it's a useful incremental improvement for now while we still have two rectilinear grids, so I'm fine to have it go in once it's cleaned up. Because of this:. ```julia; julia> using CUDA. julia> a = rand(2); 2-element Vector{Float64}:; 0.8207604162394306; 0.3815099688071648. julia> b = CuArray(a); 2-element CuArray{Float64, 1}:; 0.8207604162394306; 0.3815099688071648. julia> CUDA.@allowscalar a == b; true; ```. I think that this will work if the checkpointed grid is deserialized onto the CPU, even though `model.grid` is on the GPU. I think this is what we want, so that's fortunate the above works.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945919406
https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945919406:526,Testability,test,test,526,"Can we just compare 1) the topology and 2) all of the nodes? I think that would be sufficient to determine equality. I'm worried if we don't explicitly check the topology that we might run into some edge cases where the nodes / spacings are the same but the topologies are different (these would possibly be pathological with 0 halo in a periodic / flat direction, but still good to explicitly check I think...). When comparing numeric equality for nodes, we should add `@allowscalar` as needed there. I think we should add a test that equality works as expected, as well. We should also add a test for checkpointing on stretched grids. I think its ok if we don't support a numeric equality for other grids --- we can build them up one at a time. They are specific to each grid. The main downside here is that we need to refactor our grid implementation to have a single `RectilinearGrid` (there's no reason to have different rectilinear grid types, since we can dispatch on the case that certain directions have constant spacing easily). So this code will go away when we make that change. But I think it's a useful incremental improvement for now while we still have two rectilinear grids, so I'm fine to have it go in once it's cleaned up. Because of this:. ```julia; julia> using CUDA. julia> a = rand(2); 2-element Vector{Float64}:; 0.8207604162394306; 0.3815099688071648. julia> b = CuArray(a); 2-element CuArray{Float64, 1}:; 0.8207604162394306; 0.3815099688071648. julia> CUDA.@allowscalar a == b; true; ```. I think that this will work if the checkpointed grid is deserialized onto the CPU, even though `model.grid` is on the GPU. I think this is what we want, so that's fortunate the above works.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945919406
https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945919406:594,Testability,test,test,594,"Can we just compare 1) the topology and 2) all of the nodes? I think that would be sufficient to determine equality. I'm worried if we don't explicitly check the topology that we might run into some edge cases where the nodes / spacings are the same but the topologies are different (these would possibly be pathological with 0 halo in a periodic / flat direction, but still good to explicitly check I think...). When comparing numeric equality for nodes, we should add `@allowscalar` as needed there. I think we should add a test that equality works as expected, as well. We should also add a test for checkpointing on stretched grids. I think its ok if we don't support a numeric equality for other grids --- we can build them up one at a time. They are specific to each grid. The main downside here is that we need to refactor our grid implementation to have a single `RectilinearGrid` (there's no reason to have different rectilinear grid types, since we can dispatch on the case that certain directions have constant spacing easily). So this code will go away when we make that change. But I think it's a useful incremental improvement for now while we still have two rectilinear grids, so I'm fine to have it go in once it's cleaned up. Because of this:. ```julia; julia> using CUDA. julia> a = rand(2); 2-element Vector{Float64}:; 0.8207604162394306; 0.3815099688071648. julia> b = CuArray(a); 2-element CuArray{Float64, 1}:; 0.8207604162394306; 0.3815099688071648. julia> CUDA.@allowscalar a == b; true; ```. I think that this will work if the checkpointed grid is deserialized onto the CPU, even though `model.grid` is on the GPU. I think this is what we want, so that's fortunate the above works.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945919406
https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-946332878:404,Usability,simpl,simplest,404,"> I intend to merge this though. It's just that apparently #1998 needs to be finished first, according to @navidcy at least, so I thought I'd wait for that. Are you suggesting we move on this one before other PRs and just for vertically stretched grids?. Nah... Well, I may have initially thought that #1998 was important to finish first, but I take it back :); Let's make this work for all grids in the simplest manner possible and merge it?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-946332878
https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-949813544:63,Safety,avoid,avoid,63,"I agree that it'd be good to have a different name for them to avoid confusion. I think `thermodynamics` is not very intuitive, but I do agree with the name `active_tracers`. We would need to change the name `SeawaterBuoyancy` though, like you mentioned.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-949813544
https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-949813544:117,Usability,intuit,intuitive,117,"I agree that it'd be good to have a different name for them to avoid confusion. I think `thermodynamics` is not very intuitive, but I do agree with the name `active_tracers`. We would need to change the name `SeawaterBuoyancy` though, like you mentioned.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-949813544
https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-950020648:24,Usability,clear,clear,24,"Ah, sorry for not being clear. In summary: I agree with you. I can't think of anything better than `active_tracers` though. My suggestion is:. - Rename `buoyancy.model` to `buoyancy.active_tracers`; - Rename `SeawaterBuoyancy` to `TemperatureSalinityTracers`. Which I think is pretty clear.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-950020648
https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-950020648:284,Usability,clear,clear,284,"Ah, sorry for not being clear. In summary: I agree with you. I can't think of anything better than `active_tracers` though. My suggestion is:. - Rename `buoyancy.model` to `buoyancy.active_tracers`; - Rename `SeawaterBuoyancy` to `TemperatureSalinityTracers`. Which I think is pretty clear.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-950020648
https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-951090677:756,Availability,down,downside,756,"I think that's a decent idea and also might help de-complexify some of the code associated with buoyancy models. We would have to refactor our equations of state a bit but that's not hard. The main question is what to do about `gravitational_acceleration`. Right now, `gravitational_acceleration` is a parameter of `SeawaterBuoyancy`:. https://github.com/CliMA/Oceananigans.jl/blob/da9c53ddd9e28d123b40726cfac2fad835284879/src/BuoyancyModels/seawater_buoyancy.jl#L10-L15. because if you're using `BuoyancyTracer()`, there's no gravitational acceleration parameter (since its absorbed into the definition of buoyancy). However, we could move `gravitational_acceleration` into `Buoyancy`, and then set it to `nothing` when we are using `BuoyancyTracer`. The downside of this approach is that people can then change this parameter when using `BuoyancyTracer`, even though such changes would have no dynamical effect on the model (we've tried to limit such possibility for confusion otherwise...). It could be reasonable to move `constant_temperature` and `constant_salinity` into `equation_of_state`. `SeawaterBuoyancy` is then a type union of buoyancies with either `LinearEquationOfState` or something else from `SeawaterPolynomials.jl`. PS the default values for coefficients here:. https://github.com/CliMA/Oceananigans.jl/blob/da9c53ddd9e28d123b40726cfac2fad835284879/src/BuoyancyModels/linear_equation_of_state.jl#L25. should probably be 0?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-951090677
https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-951090677:130,Modifiability,refactor,refactor,130,"I think that's a decent idea and also might help de-complexify some of the code associated with buoyancy models. We would have to refactor our equations of state a bit but that's not hard. The main question is what to do about `gravitational_acceleration`. Right now, `gravitational_acceleration` is a parameter of `SeawaterBuoyancy`:. https://github.com/CliMA/Oceananigans.jl/blob/da9c53ddd9e28d123b40726cfac2fad835284879/src/BuoyancyModels/seawater_buoyancy.jl#L10-L15. because if you're using `BuoyancyTracer()`, there's no gravitational acceleration parameter (since its absorbed into the definition of buoyancy). However, we could move `gravitational_acceleration` into `Buoyancy`, and then set it to `nothing` when we are using `BuoyancyTracer`. The downside of this approach is that people can then change this parameter when using `BuoyancyTracer`, even though such changes would have no dynamical effect on the model (we've tried to limit such possibility for confusion otherwise...). It could be reasonable to move `constant_temperature` and `constant_salinity` into `equation_of_state`. `SeawaterBuoyancy` is then a type union of buoyancies with either `LinearEquationOfState` or something else from `SeawaterPolynomials.jl`. PS the default values for coefficients here:. https://github.com/CliMA/Oceananigans.jl/blob/da9c53ddd9e28d123b40726cfac2fad835284879/src/BuoyancyModels/linear_equation_of_state.jl#L25. should probably be 0?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-951090677
https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-1016840612:767,Availability,error,error,767,"Latest thinking incorporating some of the suggestions above:. Rename `Buoyancy` to `BuoyancyTerm` (as in, the buoyancy term in the Navier-Stokes equations) with. ```julia; struct BuoyancyTerm; equation_of_state; gravitational_acceleration; vertical_unit_vector; end; ```. Then we move `constant_temperature` and `constant_salinity` to the equations of state; and as @jm-c suggested, the equation of state determines the active tracers. Additionally, we'll define a convenience function. ```julia; BuoyancyTracer(vertical_unit_vector=ZDirection()) = BuoyancyTerm(BuoyancyTracer(), nothing, vertical_unit_vector); ```. so we then have `equation_of_state=BuoyancyTracer()` when buoyancy itself is one of the tracers. If we want to be very friendly, we can also throw an error when `!isnothing(gravitational_acceleration)` but `equation_of_state isa BuoyancyTracer` to help users avoid confusion. I think this is a good change because it allows us to define a function `buoyancy(model)` that returns an `AbstractField` (potentially `ZeroField`, `AbstractOperation`, or `Field`) representing buoyancy for use in diagnostics. It reduces the number of types we need (since we won't have `SeawaterBuoyancy` anymore), and it's a bit more parsimonious with semantics (since it avoids using the word ""model"").",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-1016840612
https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-1016840612:1123,Energy Efficiency,reduce,reduces,1123,"Latest thinking incorporating some of the suggestions above:. Rename `Buoyancy` to `BuoyancyTerm` (as in, the buoyancy term in the Navier-Stokes equations) with. ```julia; struct BuoyancyTerm; equation_of_state; gravitational_acceleration; vertical_unit_vector; end; ```. Then we move `constant_temperature` and `constant_salinity` to the equations of state; and as @jm-c suggested, the equation of state determines the active tracers. Additionally, we'll define a convenience function. ```julia; BuoyancyTracer(vertical_unit_vector=ZDirection()) = BuoyancyTerm(BuoyancyTracer(), nothing, vertical_unit_vector); ```. so we then have `equation_of_state=BuoyancyTracer()` when buoyancy itself is one of the tracers. If we want to be very friendly, we can also throw an error when `!isnothing(gravitational_acceleration)` but `equation_of_state isa BuoyancyTracer` to help users avoid confusion. I think this is a good change because it allows us to define a function `buoyancy(model)` that returns an `AbstractField` (potentially `ZeroField`, `AbstractOperation`, or `Field`) representing buoyancy for use in diagnostics. It reduces the number of types we need (since we won't have `SeawaterBuoyancy` anymore), and it's a bit more parsimonious with semantics (since it avoids using the word ""model"").",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-1016840612
https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-1016840612:876,Safety,avoid,avoid,876,"Latest thinking incorporating some of the suggestions above:. Rename `Buoyancy` to `BuoyancyTerm` (as in, the buoyancy term in the Navier-Stokes equations) with. ```julia; struct BuoyancyTerm; equation_of_state; gravitational_acceleration; vertical_unit_vector; end; ```. Then we move `constant_temperature` and `constant_salinity` to the equations of state; and as @jm-c suggested, the equation of state determines the active tracers. Additionally, we'll define a convenience function. ```julia; BuoyancyTracer(vertical_unit_vector=ZDirection()) = BuoyancyTerm(BuoyancyTracer(), nothing, vertical_unit_vector); ```. so we then have `equation_of_state=BuoyancyTracer()` when buoyancy itself is one of the tracers. If we want to be very friendly, we can also throw an error when `!isnothing(gravitational_acceleration)` but `equation_of_state isa BuoyancyTracer` to help users avoid confusion. I think this is a good change because it allows us to define a function `buoyancy(model)` that returns an `AbstractField` (potentially `ZeroField`, `AbstractOperation`, or `Field`) representing buoyancy for use in diagnostics. It reduces the number of types we need (since we won't have `SeawaterBuoyancy` anymore), and it's a bit more parsimonious with semantics (since it avoids using the word ""model"").",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-1016840612
https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-1016840612:1267,Safety,avoid,avoids,1267,"Latest thinking incorporating some of the suggestions above:. Rename `Buoyancy` to `BuoyancyTerm` (as in, the buoyancy term in the Navier-Stokes equations) with. ```julia; struct BuoyancyTerm; equation_of_state; gravitational_acceleration; vertical_unit_vector; end; ```. Then we move `constant_temperature` and `constant_salinity` to the equations of state; and as @jm-c suggested, the equation of state determines the active tracers. Additionally, we'll define a convenience function. ```julia; BuoyancyTracer(vertical_unit_vector=ZDirection()) = BuoyancyTerm(BuoyancyTracer(), nothing, vertical_unit_vector); ```. so we then have `equation_of_state=BuoyancyTracer()` when buoyancy itself is one of the tracers. If we want to be very friendly, we can also throw an error when `!isnothing(gravitational_acceleration)` but `equation_of_state isa BuoyancyTracer` to help users avoid confusion. I think this is a good change because it allows us to define a function `buoyancy(model)` that returns an `AbstractField` (potentially `ZeroField`, `AbstractOperation`, or `Field`) representing buoyancy for use in diagnostics. It reduces the number of types we need (since we won't have `SeawaterBuoyancy` anymore), and it's a bit more parsimonious with semantics (since it avoids using the word ""model"").",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-1016840612
https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-1480593982:52,Integrability,wrap,wrapper,52,"Ok I have a new proposal:. Eliminate the `Buoyancy` wrapper, and instead implement a new ""optional"" wrapper called ""RotatedBuoyancy"" or something like that, which is _only_ used when buoyancy is rotated. I think this is nice because for the majority of users who don't want to rotate buoyancy, they don't have to deal with the extra layer of indirection that `Buoyancy` currently introduces. For those users who want to rotate gravity, well, they know what they are doing. This is a better API because users get out what they put in (ie the keyword `buoyancy = ...` corresponds to `model.buoyancy`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-1480593982
https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-1480593982:100,Integrability,wrap,wrapper,100,"Ok I have a new proposal:. Eliminate the `Buoyancy` wrapper, and instead implement a new ""optional"" wrapper called ""RotatedBuoyancy"" or something like that, which is _only_ used when buoyancy is rotated. I think this is nice because for the majority of users who don't want to rotate buoyancy, they don't have to deal with the extra layer of indirection that `Buoyancy` currently introduces. For those users who want to rotate gravity, well, they know what they are doing. This is a better API because users get out what they put in (ie the keyword `buoyancy = ...` corresponds to `model.buoyancy`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-1480593982
https://github.com/CliMA/Oceananigans.jl/pull/2023#issuecomment-983973173:29,Testability,test,tests,29,@christophernhill looks like tests are headed towards passing to perhaps we just need an approval to merge?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2023#issuecomment-983973173
https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-950029886:0,Testability,Test,Tested,0,"Tested this behavior on GPUs and it persists. I can't notice a pattern on the slowdown rate, but sometimes things go from taking 1 ms to compute to taking 1 s. A 1000x slowdown!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-950029886
https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-951078455:53,Testability,benchmark,benchmarks,53,Might be good to come up with a minimal example that benchmarks a computation without setting up a simulation. In that benchmarking script I think we should also benchmark. ```julia; averaged_computed_s = AveragedField(ComputedField(s)); compute!(averaged_computed_s); ```. May want to profile too. Hopefully this is any easy fix.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-951078455
https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-951078455:119,Testability,benchmark,benchmarking,119,Might be good to come up with a minimal example that benchmarks a computation without setting up a simulation. In that benchmarking script I think we should also benchmark. ```julia; averaged_computed_s = AveragedField(ComputedField(s)); compute!(averaged_computed_s); ```. May want to profile too. Hopefully this is any easy fix.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-951078455
https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-951078455:162,Testability,benchmark,benchmark,162,Might be good to come up with a minimal example that benchmarks a computation without setting up a simulation. In that benchmarking script I think we should also benchmark. ```julia; averaged_computed_s = AveragedField(ComputedField(s)); compute!(averaged_computed_s); ```. May want to profile too. Hopefully this is any easy fix.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-951078455
https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-951571646:1376,Deployability,continuous,continuous,1376,"This is a bit more minimal:. ```julia; using Oceananigans; grid = RegularRectilinearGrid(size=(64, 64), extent=(1, 1), topology=(Periodic, Periodic, Flat)); c = CenterField(CPU(), grid); averaged_c = AveragedField(c, dims=1); ```. Then I find. ```julia; julia> @time compute!(averaged_c); 2.300619 seconds (1.85 M allocations: 121.873 MiB, 1.29% gc time, 98.45% compilation time). julia> @time compute!(averaged_c); 1.073074 seconds (1.02 M allocations: 73.454 MiB, 55.26% compilation time); ```. But mysteriously:. ```julia; julia> @time mean!(interior(averaged_c), averaged_c.operand); 0.138882 seconds (253.80 k allocations: 14.811 MiB, 99.09% compilation time). julia> @time mean!(interior(averaged_c), averaged_c.operand); 0.001370 seconds (29.41 k allocations: 988.000 KiB); ```. This doesn't really make sense, since `compute!` is just:. https://github.com/CliMA/Oceananigans.jl/blob/da9c53ddd9e28d123b40726cfac2fad835284879/src/Fields/averaged_field.jl#L105-L109. Using views is also a lot more expensive than if we extract the `parent` arrays:. ```julia; julia> @time mean!(parent(averaged_c), parent(averaged_c.operand)); 0.013767 seconds (2.19 k allocations: 157.465 KiB, 99.52% compilation time). julia> @time mean!(parent(averaged_c), parent(averaged_c.operand)); 0.000020 seconds (2 allocations: 1.469 KiB); ```. EDIT: ok, this is explanable since views are non-continuous. The above could justify special-casing `operand isa AbstractDataField` (when we know that `parent(operand)` will succeed). More notes: `mean!` ultimately calls `sum!` which is defined for Oceananigans fields here:. https://github.com/CliMA/Oceananigans.jl/blob/da9c53ddd9e28d123b40726cfac2fad835284879/src/Fields/mapreduce_abstract_fields.jl#L15. where `interior` returns a `view`:. https://github.com/CliMA/Oceananigans.jl/blob/da9c53ddd9e28d123b40726cfac2fad835284879/src/Fields/abstract_field.jl#L172-L175",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-951571646
https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-958603853:2060,Performance,cache,caches,2060," example:. ```julia; julia> a, b, c = (CenterField(GPU(), grid) for i = 1:3); Base.Generator{UnitRange{Int64}, var""#5#6""}(var""#5#6""(), 1:3). julia> @time a .= b + c; 0.929868 seconds (180.70 k allocations: 11.424 MiB, 99.79% compilation time). julia> @time a .= b + c; 0.924904 seconds (159.14 k allocations: 10.031 MiB, 99.79% compilation time); ```. Note that if we avoid constructing an `AbstractOperation` we get. ```julia; julia> @time a .= b .+ c; 1.339598 seconds (2.24 M allocations: 127.662 MiB, 2.91% gc time, 47.98% compilation time). julia> @time a .= b .+ c; 0.000280 seconds (180 allocations: 41.109 KiB); ```. Then I noticed this:. ```julia; julia> a_plus_1 = a + 1; BinaryOperation at (Center, Center, Center);  grid: RegularLatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded}; domain: longitude   [-10.0, 10.0], latitude  [0.0, 45.0], z  [-1000.0, 0.0]; topology: (Bounded, Bounded, Bounded); size (Nx, Ny, Nz): (512, 512, 32); halo (Hx, Hy, Hz): (1, 1, 1); grid spacing (, , z): (0.0390625, 0.087890625, 31.25);   domain: longitude   [-10.0, 10.0], latitude  [0.0, 45.0], z  [-1000.0, 0.0];  tree: ; + at (Center, Center, Center);   Field located at (Center, Center, Center);   1. julia> a .= a_plus_1. julia> @time a .= a_plus_1; 1.674752 seconds (2.22 M allocations: 127.371 MiB, 2.18% gc time, 56.65% compilation time). julia> @time a .= a_plus_1; 0.280226 seconds (17.11 k allocations: 1.104 MiB, 99.87% compilation time). julia> @time a .= a_plus_1; 1.525796 seconds (2.22 M allocations: 127.356 MiB, 2.15% gc time, 51.88% compilation time). julia> @time a .= a_plus_1; 0.294972 seconds (17.11 k allocations: 1.104 MiB, 99.88% compilation time). julia> @time a .= a_plus_1; 0.000274 seconds (170 allocations: 35.438 KiB). julia> @time a .= a_plus_1; 0.000274 seconds (170 allocations: 35.438 KiB); ```. Basically the compiler is ""stubborn"" and only caches our method after many tries... might be worth an issue on `KernelAbstractions.jl`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-958603853
https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-958603853:517,Safety,avoid,avoid,517,"I think this problem is more general than just `AveragedField`. It appears to apply to all reductions and broadcasting with `AbstractOperations`. For example:. ```julia; julia> a, b, c = (CenterField(GPU(), grid) for i = 1:3); Base.Generator{UnitRange{Int64}, var""#5#6""}(var""#5#6""(), 1:3). julia> @time a .= b + c; 0.929868 seconds (180.70 k allocations: 11.424 MiB, 99.79% compilation time). julia> @time a .= b + c; 0.924904 seconds (159.14 k allocations: 10.031 MiB, 99.79% compilation time); ```. Note that if we avoid constructing an `AbstractOperation` we get. ```julia; julia> @time a .= b .+ c; 1.339598 seconds (2.24 M allocations: 127.662 MiB, 2.91% gc time, 47.98% compilation time). julia> @time a .= b .+ c; 0.000280 seconds (180 allocations: 41.109 KiB); ```. Then I noticed this:. ```julia; julia> a_plus_1 = a + 1; BinaryOperation at (Center, Center, Center);  grid: RegularLatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded}; domain: longitude   [-10.0, 10.0], latitude  [0.0, 45.0], z  [-1000.0, 0.0]; topology: (Bounded, Bounded, Bounded); size (Nx, Ny, Nz): (512, 512, 32); halo (Hx, Hy, Hz): (1, 1, 1); grid spacing (, , z): (0.0390625, 0.087890625, 31.25);   domain: longitude   [-10.0, 10.0], latitude  [0.0, 45.0], z  [-1000.0, 0.0];  tree: ; + at (Center, Center, Center);   Field located at (Center, Center, Center);   1. julia> a .= a_plus_1. julia> @time a .= a_plus_1; 1.674752 seconds (2.22 M allocations: 127.371 MiB, 2.18% gc time, 56.65% compilation time). julia> @time a .= a_plus_1; 0.280226 seconds (17.11 k allocations: 1.104 MiB, 99.87% compilation time). julia> @time a .= a_plus_1; 1.525796 seconds (2.22 M allocations: 127.356 MiB, 2.15% gc time, 51.88% compilation time). julia> @time a .= a_plus_1; 0.294972 seconds (17.11 k allocations: 1.104 MiB, 99.88% compilation time). julia> @time a .= a_plus_1; 0.000274 seconds (170 allocations: 35.438 KiB). julia> @time a .= a_plus_1; 0.000274 seconds (170 allocations: 35.43",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-958603853
https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-958603853:2041,Testability,stub,stubborn,2041," example:. ```julia; julia> a, b, c = (CenterField(GPU(), grid) for i = 1:3); Base.Generator{UnitRange{Int64}, var""#5#6""}(var""#5#6""(), 1:3). julia> @time a .= b + c; 0.929868 seconds (180.70 k allocations: 11.424 MiB, 99.79% compilation time). julia> @time a .= b + c; 0.924904 seconds (159.14 k allocations: 10.031 MiB, 99.79% compilation time); ```. Note that if we avoid constructing an `AbstractOperation` we get. ```julia; julia> @time a .= b .+ c; 1.339598 seconds (2.24 M allocations: 127.662 MiB, 2.91% gc time, 47.98% compilation time). julia> @time a .= b .+ c; 0.000280 seconds (180 allocations: 41.109 KiB); ```. Then I noticed this:. ```julia; julia> a_plus_1 = a + 1; BinaryOperation at (Center, Center, Center);  grid: RegularLatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded}; domain: longitude   [-10.0, 10.0], latitude  [0.0, 45.0], z  [-1000.0, 0.0]; topology: (Bounded, Bounded, Bounded); size (Nx, Ny, Nz): (512, 512, 32); halo (Hx, Hy, Hz): (1, 1, 1); grid spacing (, , z): (0.0390625, 0.087890625, 31.25);   domain: longitude   [-10.0, 10.0], latitude  [0.0, 45.0], z  [-1000.0, 0.0];  tree: ; + at (Center, Center, Center);   Field located at (Center, Center, Center);   1. julia> a .= a_plus_1. julia> @time a .= a_plus_1; 1.674752 seconds (2.22 M allocations: 127.371 MiB, 2.18% gc time, 56.65% compilation time). julia> @time a .= a_plus_1; 0.280226 seconds (17.11 k allocations: 1.104 MiB, 99.87% compilation time). julia> @time a .= a_plus_1; 1.525796 seconds (2.22 M allocations: 127.356 MiB, 2.15% gc time, 51.88% compilation time). julia> @time a .= a_plus_1; 0.294972 seconds (17.11 k allocations: 1.104 MiB, 99.88% compilation time). julia> @time a .= a_plus_1; 0.000274 seconds (170 allocations: 35.438 KiB). julia> @time a .= a_plus_1; 0.000274 seconds (170 allocations: 35.438 KiB); ```. Basically the compiler is ""stubborn"" and only caches our method after many tries... might be worth an issue on `KernelAbstractions.jl`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-958603853
https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-958631268:340,Performance,cache,cached,340,"I don't know exactly what to do, so we'll need help. I've started with a post to the julia slack: https://julialang.slack.com/archives/C67910KEH/p1635909337281400. On the other hand, it may not be a huge issue if it only affects diagnostics that are evaluated fewer than 5 times. For long running simulations, our methods do eventually get cached? Do you have an example of a method that doesn't get cached after 5 evaluations?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-958631268
https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-958631268:400,Performance,cache,cached,400,"I don't know exactly what to do, so we'll need help. I've started with a post to the julia slack: https://julialang.slack.com/archives/C67910KEH/p1635909337281400. On the other hand, it may not be a huge issue if it only affects diagnostics that are evaluated fewer than 5 times. For long running simulations, our methods do eventually get cached? Do you have an example of a method that doesn't get cached after 5 evaluations?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-958631268
https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-958632710:348,Performance,cache,cached,348,"> I don't know exactly what to do, so we'll need help. I've started with a post to the julia slack: https://julialang.slack.com/archives/C67910KEH/p1635909337281400; > ; > On the other hand, it may not be a huge issue if it only affects diagnostics that are evaluated fewer than 5 times. For long running simulations, our methods do eventually get cached? Do you have an example of a method that doesn't get cached after 5 evaluations?. ~When I was running an actual simulation this issue seemed to persist after many evaluations (i.e. writings to disk), and not just the first few times. So it may be that doing it 5 times consecutively on the REPL is different from the simulation behavior. That said, I didn't pay a ton a attention to that, so I may have been wrong.~. ~I'll try to investigate this further tomorrow on my end if I have time.~",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-958632710
https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-958632710:408,Performance,cache,cached,408,"> I don't know exactly what to do, so we'll need help. I've started with a post to the julia slack: https://julialang.slack.com/archives/C67910KEH/p1635909337281400; > ; > On the other hand, it may not be a huge issue if it only affects diagnostics that are evaluated fewer than 5 times. For long running simulations, our methods do eventually get cached? Do you have an example of a method that doesn't get cached after 5 evaluations?. ~When I was running an actual simulation this issue seemed to persist after many evaluations (i.e. writings to disk), and not just the first few times. So it may be that doing it 5 times consecutively on the REPL is different from the simulation behavior. That said, I didn't pay a ton a attention to that, so I may have been wrong.~. ~I'll try to investigate this further tomorrow on my end if I have time.~",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-958632710
https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-960312040:293,Testability,test,tested,293,"Apparently the result when running simulations is indeed that compilation does not happen after the 5th time. So I agree that this may not be a huge issue. Although I should mention, it seems that calculation of `AveragedField` is still slower than that of `WindowedSpatialAverage`. I haven't tested this for huge grids yet but for a 128^2 grid the calculation (as per my first example in this issue) goes from around 400 s to around 60 ms. For a 512^2 grid it goes from around 2.5 ms to 950 ms. Not sure if this is expected.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-960312040
https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-960354233:114,Integrability,depend,depend,114,"I'm not 100% sure but I think doing reductions over non-contiguous data might be subject to variable timings that depend on how the data is organized in memory. In an ideal world, we would benchmark these things regularly...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-960354233
https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-960354233:92,Modifiability,variab,variable,92,"I'm not 100% sure but I think doing reductions over non-contiguous data might be subject to variable timings that depend on how the data is organized in memory. In an ideal world, we would benchmark these things regularly...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-960354233
https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-960354233:189,Testability,benchmark,benchmark,189,"I'm not 100% sure but I think doing reductions over non-contiguous data might be subject to variable timings that depend on how the data is organized in memory. In an ideal world, we would benchmark these things regularly...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-960354233
https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-1059771534:419,Deployability,release,release,419,"This issue appears to have magically disappeared on 0.71.6 and with Julia 1.6.5:. ```julia; gregorywagner:examples/ (glw/indices) $ julia --project [7:02:02]; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.6.5 (2021-12-19); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans; [ Info: Oceananigans will use 8 threads. julia> grid = RectilinearGrid(size=(64, 64), extent=(1, 1), topology=(Periodic, Periodic, Flat));. julia> c = CenterField(grid); averaged_c = Field(Average(c, dims=1)); 1641 Field{Nothing, Center, Center} reduced over dims = (1,) on RectilinearGrid on CPU;  data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 64, 1);  grid: 64641 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 110 halo;  operand: mean! over dims (1,) of 64641 Field{Center, Center, Center} on RectilinearGrid on CPU;  status: time=0.0. julia> @time compute!(c); 0.000297 seconds (1.08 k allocations: 103.719 KiB, 78.90% compilation time). julia> @time compute!(c); 0.000005 seconds; ```. I'm also not sure why the timings previously were so slow. It's more appropriate now:. ```julia; julia> using Statistics. julia> a = rand(64, 64);. julia> @time mean(a, dims=1); 0.297254 seconds (781.27 k allocations: 44.972 MiB, 5.28% gc time, 99.97% compilation time); 164 Matrix{Float64}:; 0.516131 0.572081 0.497259 0.422505 0.505043 0.453625  0.511134 0.52023 0.443803 0.503798 0.497578 0.501285. julia> @time mean(a, dims=1); 0.000014 seconds (7 allocations: 1.203 KiB); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-1059771534
https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-1059771534:711,Energy Efficiency,reduce,reduced,711,"This issue appears to have magically disappeared on 0.71.6 and with Julia 1.6.5:. ```julia; gregorywagner:examples/ (glw/indices) $ julia --project [7:02:02]; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.6.5 (2021-12-19); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans; [ Info: Oceananigans will use 8 threads. julia> grid = RectilinearGrid(size=(64, 64), extent=(1, 1), topology=(Periodic, Periodic, Flat));. julia> c = CenterField(grid); averaged_c = Field(Average(c, dims=1)); 1641 Field{Nothing, Center, Center} reduced over dims = (1,) on RectilinearGrid on CPU;  data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 64, 1);  grid: 64641 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 110 halo;  operand: mean! over dims (1,) of 64641 Field{Center, Center, Center} on RectilinearGrid on CPU;  status: time=0.0. julia> @time compute!(c); 0.000297 seconds (1.08 k allocations: 103.719 KiB, 78.90% compilation time). julia> @time compute!(c); 0.000005 seconds; ```. I'm also not sure why the timings previously were so slow. It's more appropriate now:. ```julia; julia> using Statistics. julia> a = rand(64, 64);. julia> @time mean(a, dims=1); 0.297254 seconds (781.27 k allocations: 44.972 MiB, 5.28% gc time, 99.97% compilation time); 164 Matrix{Float64}:; 0.516131 0.572081 0.497259 0.422505 0.505043 0.453625  0.511134 0.52023 0.443803 0.503798 0.497578 0.501285. julia> @time mean(a, dims=1); 0.000014 seconds (7 allocations: 1.203 KiB); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-1059771534
https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-1059781739:58,Deployability,upgrade,upgrades,58,"Hmmm yes we may need to re-open when we do imminent major upgrades to 1.8 and KernelAbstractions 0.8! But probably best to close for now since its not _currently_ an issue, apparently.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-1059781739
https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-2168478726:1649,Availability,reliab,reliable,1649,"This seems to have returned (0.91.1 on Julia 1.10.4). Computing `Average()` over a field requires one big (and very memory intensive) compilation, four or five smaller compilations.; ```jl; using Oceananigans; grid = RectilinearGrid(size=(256, 256), extent=(1, 1), topology=(Periodic, Periodic, Flat));; c = CenterField(grid);; averaged_c = Field(Average(c, dims=1)); @time compute!(averaged_c); @time compute!(averaged_c); @time compute!(averaged_c); @time compute!(averaged_c); @time compute!(averaged_c); @time compute!(averaged_c); ```; ```; [ Info: Oceananigans will use 4 threads; 1.799615 seconds (2.15 M allocations: 145.537 MiB, 2.36% gc time, 99.84% compilation time); 0.403576 seconds (130.11 k allocations: 8.875 MiB, 99.84% compilation time); 0.407113 seconds (130.11 k allocations: 8.875 MiB, 99.85% compilation time); 0.404251 seconds (130.11 k allocations: 8.878 MiB, 99.85% compilation time); 0.412207 seconds (130.11 k allocations: 8.876 MiB, 99.85% compilation time); 0.000443 seconds (201 allocations: 40.250 KiB); ```; `Integral()` works the first time, however it still seems to use a lot of memory (exactly the same as above but with `Integral` rather than `Average`); ```; [ Info: Oceananigans will use 4 threads; 4.467559 seconds (13.71 M allocations: 952.563 MiB, 19.29% gc time, 99.97% compilation time); 0.000239 seconds (60 allocations: 4.938 KiB); 0.000119 seconds (60 allocations: 4.938 KiB); 0.000107 seconds (60 allocations: 4.938 KiB); 0.000131 seconds (60 allocations: 4.938 KiB); ```; Trying to prepare by using a smaller grid to compile `compute!` sometimes works sometimes doesn't. I'm trying to come up with a reliable work-around for post-processing that doesn't involve just computing the averages of underlying arrays and putting them back into fields, which would be kind of sad.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-2168478726
https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-2168694876:153,Usability,simpl,simpler,153,"Oh interesting there is a difference between `Integral` and `Average`. Another thing to try is something like `Reduction(sum!, c, dims=1)` which is even simpler...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-2168694876
https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-2168709643:452,Energy Efficiency,reduce,reduced,452,"I tried. ```julia; using Oceananigans; grid = RectilinearGrid(size=(256, 256), extent=(1, 1), topology=(Periodic, Periodic, Flat));; c = CenterField(grid);; summed_c = Field(Reduction(sum!, c, dims=1)); @time compute!(summed_c); @time compute!(summed_c); ```. which produces. ```julia; julia> @time compute!(summed_c); 0.103867 seconds (153.65 k allocations: 10.584 MiB, 13.85% gc time, 99.78% compilation time); 12561 Field{Nothing, Center, Center} reduced over dims = (1,) on RectilinearGrid on CPU;  data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 256, 1);  grid: 2562561 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 330 halo;  operand: Reducing sum! over dims 1 of 2562561 Field{Center, Center, Center} on RectilinearGrid on CPU;  status: time=0.0;  data: 12621 OffsetArray(::Array{Float64, 3}, 1:1, -2:259, 1:1) with eltype Float64 with indices 1:1-2:2591:1;  max=0.0, min=0.0, mean=0.0. julia> @time compute!(summed_c); 0.000114 seconds (60 allocations: 3.000 KiB); 12561 Field{Nothing, Center, Center} reduced over dims = (1,) on RectilinearGrid on CPU;  data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 256, 1);  grid: 2562561 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 330 halo;  operand: Reducing sum! over dims 1 of 2562561 Field{Center, Center, Center} on RectilinearGrid on CPU;  status: time=0.0;  data: 12621 OffsetArray(::Array{Float64, 3}, 1:1, -2:259, 1:1) with eltype Float64 with indices 1:1-2:2591:1;  max=0.0, min=0.0, mean=0.0; ```. `Integral` is actually similar for me:. ```julia; using Oceananigans; grid = RectilinearGrid(size=(256, 256), extent=(1, 1), topology=(Periodic, Periodic, Flat));; c = CenterField(grid);; int_c = Field(Integral(c, dims=1)); @time compute!(int_c); @time compute!(int_c); ```. producing. ```julia; julia> @time compute!(int_c); 0.092271 seconds (182.96 k allocations: 12.615 MiB, 99.79% compilation t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-2168709643
https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-2168709643:1084,Energy Efficiency,reduce,reduced,1084,"ology=(Periodic, Periodic, Flat));; c = CenterField(grid);; summed_c = Field(Reduction(sum!, c, dims=1)); @time compute!(summed_c); @time compute!(summed_c); ```. which produces. ```julia; julia> @time compute!(summed_c); 0.103867 seconds (153.65 k allocations: 10.584 MiB, 13.85% gc time, 99.78% compilation time); 12561 Field{Nothing, Center, Center} reduced over dims = (1,) on RectilinearGrid on CPU;  data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 256, 1);  grid: 2562561 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 330 halo;  operand: Reducing sum! over dims 1 of 2562561 Field{Center, Center, Center} on RectilinearGrid on CPU;  status: time=0.0;  data: 12621 OffsetArray(::Array{Float64, 3}, 1:1, -2:259, 1:1) with eltype Float64 with indices 1:1-2:2591:1;  max=0.0, min=0.0, mean=0.0. julia> @time compute!(summed_c); 0.000114 seconds (60 allocations: 3.000 KiB); 12561 Field{Nothing, Center, Center} reduced over dims = (1,) on RectilinearGrid on CPU;  data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 256, 1);  grid: 2562561 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 330 halo;  operand: Reducing sum! over dims 1 of 2562561 Field{Center, Center, Center} on RectilinearGrid on CPU;  status: time=0.0;  data: 12621 OffsetArray(::Array{Float64, 3}, 1:1, -2:259, 1:1) with eltype Float64 with indices 1:1-2:2591:1;  max=0.0, min=0.0, mean=0.0; ```. `Integral` is actually similar for me:. ```julia; using Oceananigans; grid = RectilinearGrid(size=(256, 256), extent=(1, 1), topology=(Periodic, Periodic, Flat));; c = CenterField(grid);; int_c = Field(Integral(c, dims=1)); @time compute!(int_c); @time compute!(int_c); ```. producing. ```julia; julia> @time compute!(int_c); 0.092271 seconds (182.96 k allocations: 12.615 MiB, 99.79% compilation time); 12561 Field{Nothing, Center, Center} reduced over dims = (1,) on RectilinearGrid on CPU;",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-2168709643
https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-2168709643:2046,Energy Efficiency,reduce,reduced,2046," Field{Nothing, Center, Center} reduced over dims = (1,) on RectilinearGrid on CPU;  data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 256, 1);  grid: 2562561 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 330 halo;  operand: Reducing sum! over dims 1 of 2562561 Field{Center, Center, Center} on RectilinearGrid on CPU;  status: time=0.0;  data: 12621 OffsetArray(::Array{Float64, 3}, 1:1, -2:259, 1:1) with eltype Float64 with indices 1:1-2:2591:1;  max=0.0, min=0.0, mean=0.0; ```. `Integral` is actually similar for me:. ```julia; using Oceananigans; grid = RectilinearGrid(size=(256, 256), extent=(1, 1), topology=(Periodic, Periodic, Flat));; c = CenterField(grid);; int_c = Field(Integral(c, dims=1)); @time compute!(int_c); @time compute!(int_c); ```. producing. ```julia; julia> @time compute!(int_c); 0.092271 seconds (182.96 k allocations: 12.615 MiB, 99.79% compilation time); 12561 Field{Nothing, Center, Center} reduced over dims = (1,) on RectilinearGrid on CPU;  data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 256, 1);  grid: 2562561 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 330 halo;  operand: Integral of BinaryOperation at (Center, Center, Center) over dims (1,);  status: time=0.0;  data: 12621 OffsetArray(::Array{Float64, 3}, 1:1, -2:259, 1:1) with eltype Float64 with indices 1:1-2:2591:1;  max=0.0, min=0.0, mean=0.0. julia> @time compute!(int_c); 0.000061 seconds (60 allocations: 4.938 KiB); 12561 Field{Nothing, Center, Center} reduced over dims = (1,) on RectilinearGrid on CPU;  data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 256, 1);  grid: 2562561 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 330 halo;  operand: Integral of BinaryOperation at (Center, Center, Center) over dims (1,);  status: time=0.0;  data: 12621 OffsetArray(::Array{Float64, 3}, 1:1, -2:259",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-2168709643
https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-2168709643:2651,Energy Efficiency,reduce,reduced,2651,"riodic, Flat} on CPU with 330 halo;  operand: Reducing sum! over dims 1 of 2562561 Field{Center, Center, Center} on RectilinearGrid on CPU;  status: time=0.0;  data: 12621 OffsetArray(::Array{Float64, 3}, 1:1, -2:259, 1:1) with eltype Float64 with indices 1:1-2:2591:1;  max=0.0, min=0.0, mean=0.0; ```. `Integral` is actually similar for me:. ```julia; using Oceananigans; grid = RectilinearGrid(size=(256, 256), extent=(1, 1), topology=(Periodic, Periodic, Flat));; c = CenterField(grid);; int_c = Field(Integral(c, dims=1)); @time compute!(int_c); @time compute!(int_c); ```. producing. ```julia; julia> @time compute!(int_c); 0.092271 seconds (182.96 k allocations: 12.615 MiB, 99.79% compilation time); 12561 Field{Nothing, Center, Center} reduced over dims = (1,) on RectilinearGrid on CPU;  data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 256, 1);  grid: 2562561 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 330 halo;  operand: Integral of BinaryOperation at (Center, Center, Center) over dims (1,);  status: time=0.0;  data: 12621 OffsetArray(::Array{Float64, 3}, 1:1, -2:259, 1:1) with eltype Float64 with indices 1:1-2:2591:1;  max=0.0, min=0.0, mean=0.0. julia> @time compute!(int_c); 0.000061 seconds (60 allocations: 4.938 KiB); 12561 Field{Nothing, Center, Center} reduced over dims = (1,) on RectilinearGrid on CPU;  data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 256, 1);  grid: 2562561 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 330 halo;  operand: Integral of BinaryOperation at (Center, Center, Center) over dims (1,);  status: time=0.0;  data: 12621 OffsetArray(::Array{Float64, 3}, 1:1, -2:259, 1:1) with eltype Float64 with indices 1:1-2:2591:1;  max=0.0, min=0.0, mean=0.0; ```. But I get similar numbers for `Average`. I think the compilation path may depend on the machine you're using (which could make sense)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-2168709643
https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-2168709643:3220,Integrability,depend,depend,3220,"riodic, Flat} on CPU with 330 halo;  operand: Reducing sum! over dims 1 of 2562561 Field{Center, Center, Center} on RectilinearGrid on CPU;  status: time=0.0;  data: 12621 OffsetArray(::Array{Float64, 3}, 1:1, -2:259, 1:1) with eltype Float64 with indices 1:1-2:2591:1;  max=0.0, min=0.0, mean=0.0; ```. `Integral` is actually similar for me:. ```julia; using Oceananigans; grid = RectilinearGrid(size=(256, 256), extent=(1, 1), topology=(Periodic, Periodic, Flat));; c = CenterField(grid);; int_c = Field(Integral(c, dims=1)); @time compute!(int_c); @time compute!(int_c); ```. producing. ```julia; julia> @time compute!(int_c); 0.092271 seconds (182.96 k allocations: 12.615 MiB, 99.79% compilation time); 12561 Field{Nothing, Center, Center} reduced over dims = (1,) on RectilinearGrid on CPU;  data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 256, 1);  grid: 2562561 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 330 halo;  operand: Integral of BinaryOperation at (Center, Center, Center) over dims (1,);  status: time=0.0;  data: 12621 OffsetArray(::Array{Float64, 3}, 1:1, -2:259, 1:1) with eltype Float64 with indices 1:1-2:2591:1;  max=0.0, min=0.0, mean=0.0. julia> @time compute!(int_c); 0.000061 seconds (60 allocations: 4.938 KiB); 12561 Field{Nothing, Center, Center} reduced over dims = (1,) on RectilinearGrid on CPU;  data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 256, 1);  grid: 2562561 RectilinearGrid{Float64, Periodic, Periodic, Flat} on CPU with 330 halo;  operand: Integral of BinaryOperation at (Center, Center, Center) over dims (1,);  status: time=0.0;  data: 12621 OffsetArray(::Array{Float64, 3}, 1:1, -2:259, 1:1) with eltype Float64 with indices 1:1-2:2591:1;  max=0.0, min=0.0, mean=0.0; ```. But I get similar numbers for `Average`. I think the compilation path may depend on the machine you're using (which could make sense)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-2168709643
https://github.com/CliMA/Oceananigans.jl/pull/2025#issuecomment-950208016:51,Testability,test,test,51,Maybe it would be better to implement a regression test on the RegularLatitudeLongitudeGrid before merging,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2025#issuecomment-950208016
https://github.com/CliMA/Oceananigans.jl/pull/2025#issuecomment-951037471:394,Integrability,depend,depend,394,"> * There is a lot happening here. :) I can have a crack reviewing this but I may ask lots of clarifications?; > * Perhaps we need to expand a bit the [finite volume](https://clima.github.io/OceananigansDocumentation/stable/numerical_implementation/finite_volume/) section in the docs to clarify what, e.g., `Az` is? How come `Ax` or `Ay` are not needed btw?. `Ax` and `Ay` both depend on vertical location, so the constructs you're mentioning would only be valid on a horizontally-curvilinear but _vertically-regular_ grid. I think we should just encode the general form of operators, so we should have things like `Ax` and `Ax` only.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2025#issuecomment-951037471
https://github.com/CliMA/Oceananigans.jl/pull/2025#issuecomment-951256768:293,Energy Efficiency,efficient,efficiently,293,> * a general Rectilinear Grid with an architecture field and possibility of stretching in all directions (rectilinear_grid.jl); > This grid will eventually substitute all instances of RegularRectilinearGrid and VerticallyStretchedRectilinearGrid. Do we have the necessary pressure solvers to efficiently do stretched regular grids in directions that aren't vertical?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2025#issuecomment-951256768
https://github.com/CliMA/Oceananigans.jl/pull/2025#issuecomment-951555624:303,Energy Efficiency,efficient,efficiently,303,"> > * a general Rectilinear Grid with an architecture field and possibility of stretching in all directions (rectilinear_grid.jl); > > This grid will eventually substitute all instances of RegularRectilinearGrid and VerticallyStretchedRectilinearGrid; > ; > Do we have the necessary pressure solvers to efficiently do stretched regular grids in directions that aren't vertical?. We can do hydrostatic simulations or shallow water simulations on arbitrarily stretched rectilinear and curvilinear grids. We cannot do nonhydrostatic simulations without new pressure solvers, however.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2025#issuecomment-951555624
https://github.com/CliMA/Oceananigans.jl/pull/2025#issuecomment-961968320:21,Testability,test,tests,21,"Thanks! I'll get the tests to pass completely then merge! I forgot the previous comments, thanks for reminding me, I will address them now. . For replacing the Regular and Vertically stretched grid it shouldn't be a huge problem but there might be some conflicts. Major ones might be fields like `x` being substituted by `x` and `x` or making sure that architecture is always consistent between grid, models and fields",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2025#issuecomment-961968320
https://github.com/CliMA/Oceananigans.jl/pull/2025#issuecomment-963570267:0,Testability,Test,Tests,0,Tests are passing! :tada: . I don't see any changes in Project.toml though. Don't forget to bump the version before merging.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2025#issuecomment-963570267
https://github.com/CliMA/Oceananigans.jl/pull/2025#issuecomment-963873885:8,Testability,benchmark,benchmarks,8,# A few benchmarks... ## `benchmark_nonhydrostatic_model.jl`. ### `main`. ```; Nonhydrostatic model benchmarks; ;  Architectures  Float_types  Ns  min  median  mean  max  memory  allocs  samples ; ;  CPU  Float32  32  7.436 ms  8.831 ms  8.815 ms  11.402 ms  2.42 MiB  7196  10 ;  CPU  Float32  64  15.440 ms  15.923 ms  16.687 ms  20.447 ms  3.12 MiB  12808  10 ;  CPU  Float32  128  43.847 ms  44.717 ms  44.792 ms  46.774 ms  3.40 MiB  15383  10 ;  CPU  Float32  256  280.225 ms  289.133 ms  289.791 ms  307.004 ms  3.73 MiB  35573  10 ;  CPU  Float64  32  8.626 ms  8.873 ms  8.903 ms  9.340 ms  3.15 MiB  7192  10 ;  CPU  Float64  64  12.859 ms  13.495 ms  13.865 ms  16.695 ms  3.95 MiB  12925  10 ;  CPU  Float64  128  52.882 ms  54.573 ms  56.634 ms  74.680 ms  4.31 MiB  16561  10 ;  CPU  Float64  256  406.856 ms  414.115 ms  417.420 ms  441.158 ms  4.92 MiB  49543  10 ;  GPU  Float32  32  1.932 ms  2.038 ms  2.177 ms  3.359 ms  1.42 MiB  4801  10 ;  GPU  Float32  64  1.992 ms  2.064 ms  2.167 ms  3.109 ms  1.42 MiB  4832  10 ;  GPU  Float32  128  2.746 ms  2.790 ms  3.045 ms  5.152 ms  1.42 MiB  5136  10 ;  GPU  Float32  256  15.301 ms  19.004 ms  18.634 ms  19.064 ms  1.59 MiB  15777  10 ;  GPU  Float64  32  2.167 ms  2.272 ms  2.411 ms  3.706 ms  1.84 MiB  4775  10 ;  GPU  Float64  64  2.260 ms  2.380 ms  2.543 ms  3.984 ms  1.84 MiB  4827  10 ;  GPU  Float64  128  4.640 ms  4.794 ms  4.875 ms  5.688 ms  1.86 MiB  6133  10 ;  GPU  Float64  256  24.612 ms  36.082 ms  34.946 ms  36.210 ms  2.19 MiB  27483  10 ; ,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2025#issuecomment-963873885
https://github.com/CliMA/Oceananigans.jl/pull/2025#issuecomment-963873885:100,Testability,benchmark,benchmarks,100,# A few benchmarks... ## `benchmark_nonhydrostatic_model.jl`. ### `main`. ```; Nonhydrostatic model benchmarks; ;  Architectures  Float_types  Ns  min  median  mean  max  memory  allocs  samples ; ;  CPU  Float32  32  7.436 ms  8.831 ms  8.815 ms  11.402 ms  2.42 MiB  7196  10 ;  CPU  Float32  64  15.440 ms  15.923 ms  16.687 ms  20.447 ms  3.12 MiB  12808  10 ;  CPU  Float32  128  43.847 ms  44.717 ms  44.792 ms  46.774 ms  3.40 MiB  15383  10 ;  CPU  Float32  256  280.225 ms  289.133 ms  289.791 ms  307.004 ms  3.73 MiB  35573  10 ;  CPU  Float64  32  8.626 ms  8.873 ms  8.903 ms  9.340 ms  3.15 MiB  7192  10 ;  CPU  Float64  64  12.859 ms  13.495 ms  13.865 ms  16.695 ms  3.95 MiB  12925  10 ;  CPU  Float64  128  52.882 ms  54.573 ms  56.634 ms  74.680 ms  4.31 MiB  16561  10 ;  CPU  Float64  256  406.856 ms  414.115 ms  417.420 ms  441.158 ms  4.92 MiB  49543  10 ;  GPU  Float32  32  1.932 ms  2.038 ms  2.177 ms  3.359 ms  1.42 MiB  4801  10 ;  GPU  Float32  64  1.992 ms  2.064 ms  2.167 ms  3.109 ms  1.42 MiB  4832  10 ;  GPU  Float32  128  2.746 ms  2.790 ms  3.045 ms  5.152 ms  1.42 MiB  5136  10 ;  GPU  Float32  256  15.301 ms  19.004 ms  18.634 ms  19.064 ms  1.59 MiB  15777  10 ;  GPU  Float64  32  2.167 ms  2.272 ms  2.411 ms  3.706 ms  1.84 MiB  4775  10 ;  GPU  Float64  64  2.260 ms  2.380 ms  2.543 ms  3.984 ms  1.84 MiB  4827  10 ;  GPU  Float64  128  4.640 ms  4.794 ms  4.875 ms  5.688 ms  1.86 MiB  6133  10 ;  GPU  Float64  256  24.612 ms  36.082 ms  34.946 ms  36.210 ms  2.19 MiB  27483  10 ; ,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2025#issuecomment-963873885
https://github.com/CliMA/Oceananigans.jl/pull/2025#issuecomment-964152321:208,Testability,Benchmark,BenchmarkTools,208,"It is the effect of `wait(device(arch), events)` vs the `wait(events)` in `fill_halo_regions.jl` line 64. (On main just substituting that line). ```; julia> benchmark_nonhydrostatic_model(GPU, Float64, 128); BenchmarkTools.Trial: 10 samples with 1 evaluation.; Range (min  max): 4.784 ms  22.835 ms  GC (min  max): 0.00%  0.00%; Time (median): 4.836 ms  GC (median): 0.00%; Time (mean  ): 6.634 ms  5.692 ms  GC (mean  ): 0.00%  0.00%.  ;  ; 4.78 ms Histogram: frequency by time 22.8 ms <. Memory estimate: 1.86 MiB, allocs estimate: 6061.; ```. vs . ```; julia> benchmark_nonhydrostatic_model(GPU, Float64, 128); BenchmarkTools.Trial: 10 samples with 1 evaluation.; Range (min  max): 6.907 ms  25.036 ms  GC (min  max): 0.00%  0.00%; Time (median): 7.512 ms  GC (median): 0.00%; Time (mean  ): 9.426 ms  5.532 ms  GC (mean  ): 0.00%  0.00%.  ;  ; 6.91 ms Histogram: frequency by time 25 ms <. Memory estimate: 1.86 MiB, allocs estimate: 5563.; ```. I ll investigate more this wait function today.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2025#issuecomment-964152321
https://github.com/CliMA/Oceananigans.jl/pull/2025#issuecomment-964152321:687,Testability,Benchmark,BenchmarkTools,687,"It is the effect of `wait(device(arch), events)` vs the `wait(events)` in `fill_halo_regions.jl` line 64. (On main just substituting that line). ```; julia> benchmark_nonhydrostatic_model(GPU, Float64, 128); BenchmarkTools.Trial: 10 samples with 1 evaluation.; Range (min  max): 4.784 ms  22.835 ms  GC (min  max): 0.00%  0.00%; Time (median): 4.836 ms  GC (median): 0.00%; Time (mean  ): 6.634 ms  5.692 ms  GC (mean  ): 0.00%  0.00%.  ;  ; 4.78 ms Histogram: frequency by time 22.8 ms <. Memory estimate: 1.86 MiB, allocs estimate: 6061.; ```. vs . ```; julia> benchmark_nonhydrostatic_model(GPU, Float64, 128); BenchmarkTools.Trial: 10 samples with 1 evaluation.; Range (min  max): 6.907 ms  25.036 ms  GC (min  max): 0.00%  0.00%; Time (median): 7.512 ms  GC (median): 0.00%; Time (mean  ): 9.426 ms  5.532 ms  GC (mean  ): 0.00%  0.00%.  ;  ; 6.91 ms Histogram: frequency by time 25 ms <. Memory estimate: 1.86 MiB, allocs estimate: 5563.; ```. I ll investigate more this wait function today.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2025#issuecomment-964152321
https://github.com/CliMA/Oceananigans.jl/pull/2025#issuecomment-964152322:208,Testability,Benchmark,BenchmarkTools,208,"It is the effect of `wait(device(arch), events)` vs the `wait(events)` in `fill_halo_regions.jl` line 64. (On main just substituting that line). ```; julia> benchmark_nonhydrostatic_model(GPU, Float64, 128); BenchmarkTools.Trial: 10 samples with 1 evaluation.; Range (min  max): 4.784 ms  22.835 ms  GC (min  max): 0.00%  0.00%; Time (median): 4.836 ms  GC (median): 0.00%; Time (mean  ): 6.634 ms  5.692 ms  GC (mean  ): 0.00%  0.00%.  ;  ; 4.78 ms Histogram: frequency by time 22.8 ms <. Memory estimate: 1.86 MiB, allocs estimate: 6061.; ```. vs . ```; julia> benchmark_nonhydrostatic_model(GPU, Float64, 128); BenchmarkTools.Trial: 10 samples with 1 evaluation.; Range (min  max): 6.907 ms  25.036 ms  GC (min  max): 0.00%  0.00%; Time (median): 7.512 ms  GC (median): 0.00%; Time (mean  ): 9.426 ms  5.532 ms  GC (mean  ): 0.00%  0.00%.  ;  ; 6.91 ms Histogram: frequency by time 25 ms <. Memory estimate: 1.86 MiB, allocs estimate: 5563.; ```. I ll investigate more this wait function today.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2025#issuecomment-964152322
https://github.com/CliMA/Oceananigans.jl/pull/2025#issuecomment-964152322:687,Testability,Benchmark,BenchmarkTools,687,"It is the effect of `wait(device(arch), events)` vs the `wait(events)` in `fill_halo_regions.jl` line 64. (On main just substituting that line). ```; julia> benchmark_nonhydrostatic_model(GPU, Float64, 128); BenchmarkTools.Trial: 10 samples with 1 evaluation.; Range (min  max): 4.784 ms  22.835 ms  GC (min  max): 0.00%  0.00%; Time (median): 4.836 ms  GC (median): 0.00%; Time (mean  ): 6.634 ms  5.692 ms  GC (mean  ): 0.00%  0.00%.  ;  ; 4.78 ms Histogram: frequency by time 22.8 ms <. Memory estimate: 1.86 MiB, allocs estimate: 6061.; ```. vs . ```; julia> benchmark_nonhydrostatic_model(GPU, Float64, 128); BenchmarkTools.Trial: 10 samples with 1 evaluation.; Range (min  max): 6.907 ms  25.036 ms  GC (min  max): 0.00%  0.00%; Time (median): 7.512 ms  GC (median): 0.00%; Time (mean  ): 9.426 ms  5.532 ms  GC (mean  ): 0.00%  0.00%.  ;  ; 6.91 ms Histogram: frequency by time 25 ms <. Memory estimate: 1.86 MiB, allocs estimate: 5563.; ```. I ll investigate more this wait function today.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2025#issuecomment-964152322
https://github.com/CliMA/Oceananigans.jl/pull/2025#issuecomment-964234819:77,Availability,mask,masks,77,"Is it possible that the problem lies elsewhere, so that changing `wait` just masks the real issue rather than solving it?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2025#issuecomment-964234819
https://github.com/CliMA/Oceananigans.jl/pull/2025#issuecomment-964247231:103,Integrability,synchroniz,synchronization,103,"For sure, that is always an option. After a lot of searching it seemed that the problem was indeed the synchronization of the boundary conditions that still was not fixed. . this PR should be ready to merge, I ll do the last check of the comments I maybe missed and then merge",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2025#issuecomment-964247231
https://github.com/CliMA/Oceananigans.jl/issues/2027#issuecomment-951393626:59,Modifiability,refactor,refactor,59,Yeah... Let's put this in the pot for a potential buoyancy refactor (see #2022).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2027#issuecomment-951393626
https://github.com/CliMA/Oceananigans.jl/pull/2028#issuecomment-950481812:85,Testability,test,tests,85,If this seem to be doing the job @tomchor and if others are happy I can write up few tests.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2028#issuecomment-950481812
https://github.com/CliMA/Oceananigans.jl/pull/2028#issuecomment-950483789:444,Testability,test,test,444,"> @tomchor what do you think about this?; > ; > (I didn't wanna make changes to your branch in case you are using it for work, so I branched of there...). Thanks, that very thoughtful. I am indeed using that branch for research :). The PR also looks very good! This is exactly what I had in mind :+1:. Sorry I haven't done this yet in my original PR. I was actually planning on doing it this weekend but I got busy. . Should we add an equality test for grids? I think we can get away with something as simple as `@test grid == deepcopy(grid)` no? (This used to return false for vertically stretched grids.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2028#issuecomment-950483789
https://github.com/CliMA/Oceananigans.jl/pull/2028#issuecomment-950483789:514,Testability,test,test,514,"> @tomchor what do you think about this?; > ; > (I didn't wanna make changes to your branch in case you are using it for work, so I branched of there...). Thanks, that very thoughtful. I am indeed using that branch for research :). The PR also looks very good! This is exactly what I had in mind :+1:. Sorry I haven't done this yet in my original PR. I was actually planning on doing it this weekend but I got busy. . Should we add an equality test for grids? I think we can get away with something as simple as `@test grid == deepcopy(grid)` no? (This used to return false for vertically stretched grids.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2028#issuecomment-950483789
https://github.com/CliMA/Oceananigans.jl/pull/2028#issuecomment-950483789:502,Usability,simpl,simple,502,"> @tomchor what do you think about this?; > ; > (I didn't wanna make changes to your branch in case you are using it for work, so I branched of there...). Thanks, that very thoughtful. I am indeed using that branch for research :). The PR also looks very good! This is exactly what I had in mind :+1:. Sorry I haven't done this yet in my original PR. I was actually planning on doing it this weekend but I got busy. . Should we add an equality test for grids? I think we can get away with something as simple as `@test grid == deepcopy(grid)` no? (This used to return false for vertically stretched grids.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2028#issuecomment-950483789
https://github.com/CliMA/Oceananigans.jl/pull/2028#issuecomment-950493532:28,Testability,test,test,28,> Should we add an equality test for grids? I think we can get away with something as simple as `@test grid == deepcopy(grid)` no? (This used to return false for vertically stretched grids.). We should! But I'll try to test a few cases... different type of grids and on different architectures.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2028#issuecomment-950493532
https://github.com/CliMA/Oceananigans.jl/pull/2028#issuecomment-950493532:98,Testability,test,test,98,> Should we add an equality test for grids? I think we can get away with something as simple as `@test grid == deepcopy(grid)` no? (This used to return false for vertically stretched grids.). We should! But I'll try to test a few cases... different type of grids and on different architectures.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2028#issuecomment-950493532
https://github.com/CliMA/Oceananigans.jl/pull/2028#issuecomment-950493532:219,Testability,test,test,219,> Should we add an equality test for grids? I think we can get away with something as simple as `@test grid == deepcopy(grid)` no? (This used to return false for vertically stretched grids.). We should! But I'll try to test a few cases... different type of grids and on different architectures.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2028#issuecomment-950493532
https://github.com/CliMA/Oceananigans.jl/pull/2028#issuecomment-950493532:86,Usability,simpl,simple,86,> Should we add an equality test for grids? I think we can get away with something as simple as `@test grid == deepcopy(grid)` no? (This used to return false for vertically stretched grids.). We should! But I'll try to test a few cases... different type of grids and on different architectures.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2028#issuecomment-950493532
https://github.com/CliMA/Oceananigans.jl/pull/2028#issuecomment-951386368:227,Integrability,wrap,wrapper,227,"> This is good after changes.; > ; > My only question is whether another implementation might be something like; > ; > ```julia; > function Base.:(==)(grid1::AbstractGrid, grid2::AbstractGrid); > !isa(grid2, typeof(grid1).name.wrapper) && return false; > topology(grid1) == topology(grid2) && return false; > ; > x1, y1, z1 = nodes((Face, Face, Face), grid1); > x2, y2, z2 = nodes((Face, Face, Face), grid2); > ; > return x1 == x2 && y1 == y2 && z1 == z2; > end; > ```; > ; > This has different behavior than what's implemented here. In particular, two grids will be identified as equal even if one has ""number spacing"" (eg a constant) whereas the other has array-spacing with all the values equal to that number. In other words, while; > ; > ```julia; > julia> 1.0 == ones(2); > false; > ```; > ; > we may want to identify this case with numeric equality for a grid.; > ; > The key here is that two grids are ""equal"" if they have the same nodes. The other properties (like spacings) are really implied by the placement of the nodes. OK, perhaps then your suggestion is better.; What about when two grids are otherwise the same but one lives on GPU and one on CPU. Will the above render them equal? I guess no since, e.g., `z1 == z2` will return false if one is an Array and other a CuArray.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2028#issuecomment-951386368
https://github.com/CliMA/Oceananigans.jl/pull/2028#issuecomment-951556601:229,Integrability,wrap,wrapper,229,"> > This is good after changes.; > > My only question is whether another implementation might be something like; > > ```julia; > > function Base.:(==)(grid1::AbstractGrid, grid2::AbstractGrid); > > !isa(grid2, typeof(grid1).name.wrapper) && return false; > > topology(grid1) == topology(grid2) && return false; > > ; > > x1, y1, z1 = nodes((Face, Face, Face), grid1); > > x2, y2, z2 = nodes((Face, Face, Face), grid2); > > ; > > return x1 == x2 && y1 == y2 && z1 == z2; > > end; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > This has different behavior than what's implemented here. In particular, two grids will be identified as equal even if one has ""number spacing"" (eg a constant) whereas the other has array-spacing with all the values equal to that number. In other words, while; > > ```julia; > > julia> 1.0 == ones(2); > > false; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > we may want to identify this case with numeric equality for a grid.; > > The key here is that two grids are ""equal"" if they have the same nodes. The other properties (like spacings) are really implied by the placement of the nodes.; > ; > OK, perhaps then your suggestion is better. What about when two grids are otherwise the same but one lives on GPU and one on CPU. Will the above render them equal? I guess no since, e.g., `z1 == z2` will return false if one is an Array and other a CuArray. Actually, the julia gods have decided that CPU and GPU arrays can be numerically equal:. ```julia; julia> using CUDA. julia> a = rand(3); 3-element Vector{Float64}:; 0.3492331921297629; 0.4354818891776633; 0.684771954777823. julia> a == CuArray(a); true; ```. Since we use `==` on the nodes (which are always arrays), we retain the behavior that a CPU grid and a GPU grid can be _numerically_ identical via `==`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2028#issuecomment-951556601
https://github.com/CliMA/Oceananigans.jl/pull/2028#issuecomment-952089949:139,Testability,Test,Tested,139,"> @tomchor, can you confirm that the PR at its current stage actually solves the problem you were facing in #2018?. Seems to do the trick! Tested for CPUs and GPUs. :rocket:",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2028#issuecomment-952089949
https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951424095:586,Safety,avoid,avoided,586,"Calculating trigonometric functions is ""slow"" (compared to simple arithmetic operations) on _all_ hardware because they require various series expansions and iterative calculations. Division is also ""slow""; a single division operation requires something like 20 operations. An issue with any psuedo-anecdotal advice like this is that it may not be valid on all hardware. Just how ""slow"" is `sin` on various hardware? Is it slow on all Nvidia GPUs, or just some? Is it slow on AMD GPUs? What does ""slow"" mean, exactly?. Philosophically, I disagree that trigonometric functions should be avoided. Speed is not always a primary concern for computations. Other concerns that may be equally or more important are reproducibility, programmer productivity, accuracy, etc. I think that users will probably better served by a nice comprehensive reference to floating point calculations on various hardware on CPUs and GPUs...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951424095
https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951424095:59,Usability,simpl,simple,59,"Calculating trigonometric functions is ""slow"" (compared to simple arithmetic operations) on _all_ hardware because they require various series expansions and iterative calculations. Division is also ""slow""; a single division operation requires something like 20 operations. An issue with any psuedo-anecdotal advice like this is that it may not be valid on all hardware. Just how ""slow"" is `sin` on various hardware? Is it slow on all Nvidia GPUs, or just some? Is it slow on AMD GPUs? What does ""slow"" mean, exactly?. Philosophically, I disagree that trigonometric functions should be avoided. Speed is not always a primary concern for computations. Other concerns that may be equally or more important are reproducibility, programmer productivity, accuracy, etc. I think that users will probably better served by a nice comprehensive reference to floating point calculations on various hardware on CPUs and GPUs...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951424095
https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951425085:417,Performance,perform,performed,417,"> It seems very strange to me that evaluating trig functions is slow on GPUs. Is this we problem known to CUDA.jl?; > ; > The information you have here seems good to me. ""slow"" is ill-defined. We recently found that precomputing grid metrics for the latitude-longitude grid leads to a 2x speed up for simple 2D cases (less for more complex cases, probably). But it's all relative to other calculations that are being performed. For many ocean codes the limiting step is evaluating the nonlinear equation of state (a 55 term polynomial) at various locations on the grid. For these cases, the cost of trigonometric functions may not be noticeable.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951425085
https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951425085:301,Usability,simpl,simple,301,"> It seems very strange to me that evaluating trig functions is slow on GPUs. Is this we problem known to CUDA.jl?; > ; > The information you have here seems good to me. ""slow"" is ill-defined. We recently found that precomputing grid metrics for the latitude-longitude grid leads to a 2x speed up for simple 2D cases (less for more complex cases, probably). But it's all relative to other calculations that are being performed. For many ocean codes the limiting step is evaluating the nonlinear equation of state (a 55 term polynomial) at various locations on the grid. For these cases, the cost of trigonometric functions may not be noticeable.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951425085
https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951425101:112,Safety,avoid,avoided,112,"I see @glwagner's point. I'm a bit skeptical in that part of the PR (which claims that trig functions should be avoided). Perhaps we can elaborate a bit more on that or point the reader to some other source? I'm a bit on the fence. On the other hand, if I was trying to code up something and was ending up having my code 100 slower because I was doing `cos(pi/4)` instead of `sqrt(2)/2`, then I'd be very grateful if somebody pointed it out in a ""Tips"" section!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951425101
https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951425555:114,Safety,avoid,avoided,114,"> I see @glwagner's point. I'm a bit skeptical in that part of the PR (which claims that trig functions should be avoided). Perhaps we can elaborate a bit more on that or point the reader to some other source? I'm a bit on the fence. On the other hand, if I was trying to code up something and was ending up having my code 100 slower because I was doing `cos(pi/4)` instead of `sqrt(2)/2`, then I'd be very grateful if somebody pointed it out in a ""Tips"" section!. 100x slower is definitely a scripting bug. We are missing `@inline` in the examples?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951425555
https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951478103:174,Performance,perform,performed,174,"Instead of saying that trig functions should be avoided on gpus, which seems very strong, I suggest pointing out that there have been some examples where trig functions have performed much slower, and include this example. . This clearly problem needs further exploration but I don't want people to be scared to use sin and cos because sometimes they just make a lot of sense. My two cents worth.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951478103
https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951478103:48,Safety,avoid,avoided,48,"Instead of saying that trig functions should be avoided on gpus, which seems very strong, I suggest pointing out that there have been some examples where trig functions have performed much slower, and include this example. . This clearly problem needs further exploration but I don't want people to be scared to use sin and cos because sometimes they just make a lot of sense. My two cents worth.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951478103
https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951478103:230,Usability,clear,clearly,230,"Instead of saying that trig functions should be avoided on gpus, which seems very strong, I suggest pointing out that there have been some examples where trig functions have performed much slower, and include this example. . This clearly problem needs further exploration but I don't want people to be scared to use sin and cos because sometimes they just make a lot of sense. My two cents worth.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951478103
https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951555050:176,Performance,perform,performed,176,"> Instead of saying that trig functions should be avoided on gpus, which seems very strong, I suggest pointing out that there have been some examples where trig functions have performed much slower, and include this example.; > ; > This clearly problem needs further exploration but I don't want people to be scared to use sin and cos because sometimes they just make a lot of sense. My two cents worth. I think there may be a bug in the setup that produces 100x slowdown. (@tomchor if you supply the whole script, we can investigate.) We've run many successful problems with trig functions. Some recent work by @simone-silvestri suggests we can get 2x speed up for _some_ problems by precomputing grid metrics for the `RegularLatitudeLongitudeGrid` rather than computing them on the fly:. https://github.com/CliMA/Oceananigans.jl/blob/da9c53ddd9e28d123b40726cfac2fad835284879/src/Operators/spacings_and_areas_and_volumes.jl#L178-L179. But I don't think we've definitely shown that we _always_ will get 2x speed up. Thus we are going to retain the option to compute metrics on the fly in #2025 so we can continue to investigate it. 2x is a long way from 100x though. If used in a boundary conditions, its basically irrelevant whether one uses a trig function or not. Even a forcing function is only evaluated once per grid point compared to 15x (or more?) for a `BackgroundField` velocity component with high-order advection. Some of these thoughts might be distilled into useful advice in this section of the docs. But we should definitely focus on _approaches_ to performance optimization rather than advice for specific scenarios.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951555050
https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951555050:1566,Performance,perform,performance,1566,"> Instead of saying that trig functions should be avoided on gpus, which seems very strong, I suggest pointing out that there have been some examples where trig functions have performed much slower, and include this example.; > ; > This clearly problem needs further exploration but I don't want people to be scared to use sin and cos because sometimes they just make a lot of sense. My two cents worth. I think there may be a bug in the setup that produces 100x slowdown. (@tomchor if you supply the whole script, we can investigate.) We've run many successful problems with trig functions. Some recent work by @simone-silvestri suggests we can get 2x speed up for _some_ problems by precomputing grid metrics for the `RegularLatitudeLongitudeGrid` rather than computing them on the fly:. https://github.com/CliMA/Oceananigans.jl/blob/da9c53ddd9e28d123b40726cfac2fad835284879/src/Operators/spacings_and_areas_and_volumes.jl#L178-L179. But I don't think we've definitely shown that we _always_ will get 2x speed up. Thus we are going to retain the option to compute metrics on the fly in #2025 so we can continue to investigate it. 2x is a long way from 100x though. If used in a boundary conditions, its basically irrelevant whether one uses a trig function or not. Even a forcing function is only evaluated once per grid point compared to 15x (or more?) for a `BackgroundField` velocity component with high-order advection. Some of these thoughts might be distilled into useful advice in this section of the docs. But we should definitely focus on _approaches_ to performance optimization rather than advice for specific scenarios.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951555050
https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951555050:1578,Performance,optimiz,optimization,1578,"> Instead of saying that trig functions should be avoided on gpus, which seems very strong, I suggest pointing out that there have been some examples where trig functions have performed much slower, and include this example.; > ; > This clearly problem needs further exploration but I don't want people to be scared to use sin and cos because sometimes they just make a lot of sense. My two cents worth. I think there may be a bug in the setup that produces 100x slowdown. (@tomchor if you supply the whole script, we can investigate.) We've run many successful problems with trig functions. Some recent work by @simone-silvestri suggests we can get 2x speed up for _some_ problems by precomputing grid metrics for the `RegularLatitudeLongitudeGrid` rather than computing them on the fly:. https://github.com/CliMA/Oceananigans.jl/blob/da9c53ddd9e28d123b40726cfac2fad835284879/src/Operators/spacings_and_areas_and_volumes.jl#L178-L179. But I don't think we've definitely shown that we _always_ will get 2x speed up. Thus we are going to retain the option to compute metrics on the fly in #2025 so we can continue to investigate it. 2x is a long way from 100x though. If used in a boundary conditions, its basically irrelevant whether one uses a trig function or not. Even a forcing function is only evaluated once per grid point compared to 15x (or more?) for a `BackgroundField` velocity component with high-order advection. Some of these thoughts might be distilled into useful advice in this section of the docs. But we should definitely focus on _approaches_ to performance optimization rather than advice for specific scenarios.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951555050
https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951555050:50,Safety,avoid,avoided,50,"> Instead of saying that trig functions should be avoided on gpus, which seems very strong, I suggest pointing out that there have been some examples where trig functions have performed much slower, and include this example.; > ; > This clearly problem needs further exploration but I don't want people to be scared to use sin and cos because sometimes they just make a lot of sense. My two cents worth. I think there may be a bug in the setup that produces 100x slowdown. (@tomchor if you supply the whole script, we can investigate.) We've run many successful problems with trig functions. Some recent work by @simone-silvestri suggests we can get 2x speed up for _some_ problems by precomputing grid metrics for the `RegularLatitudeLongitudeGrid` rather than computing them on the fly:. https://github.com/CliMA/Oceananigans.jl/blob/da9c53ddd9e28d123b40726cfac2fad835284879/src/Operators/spacings_and_areas_and_volumes.jl#L178-L179. But I don't think we've definitely shown that we _always_ will get 2x speed up. Thus we are going to retain the option to compute metrics on the fly in #2025 so we can continue to investigate it. 2x is a long way from 100x though. If used in a boundary conditions, its basically irrelevant whether one uses a trig function or not. Even a forcing function is only evaluated once per grid point compared to 15x (or more?) for a `BackgroundField` velocity component with high-order advection. Some of these thoughts might be distilled into useful advice in this section of the docs. But we should definitely focus on _approaches_ to performance optimization rather than advice for specific scenarios.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951555050
https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951555050:237,Usability,clear,clearly,237,"> Instead of saying that trig functions should be avoided on gpus, which seems very strong, I suggest pointing out that there have been some examples where trig functions have performed much slower, and include this example.; > ; > This clearly problem needs further exploration but I don't want people to be scared to use sin and cos because sometimes they just make a lot of sense. My two cents worth. I think there may be a bug in the setup that produces 100x slowdown. (@tomchor if you supply the whole script, we can investigate.) We've run many successful problems with trig functions. Some recent work by @simone-silvestri suggests we can get 2x speed up for _some_ problems by precomputing grid metrics for the `RegularLatitudeLongitudeGrid` rather than computing them on the fly:. https://github.com/CliMA/Oceananigans.jl/blob/da9c53ddd9e28d123b40726cfac2fad835284879/src/Operators/spacings_and_areas_and_volumes.jl#L178-L179. But I don't think we've definitely shown that we _always_ will get 2x speed up. Thus we are going to retain the option to compute metrics on the fly in #2025 so we can continue to investigate it. 2x is a long way from 100x though. If used in a boundary conditions, its basically irrelevant whether one uses a trig function or not. Even a forcing function is only evaluated once per grid point compared to 15x (or more?) for a `BackgroundField` velocity component with high-order advection. Some of these thoughts might be distilled into useful advice in this section of the docs. But we should definitely focus on _approaches_ to performance optimization rather than advice for specific scenarios.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951555050
https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151:1042,Energy Efficiency,efficient,efficient,1042,"t dropped it). I also slightly reworded it to have less absolute statements, but further rewording is necessary after we finish this discussion I think.; > ; > Some notes:; > ; > * The same code on CPUs isn't even close to have the same slowdown. So there's definitely something going on here for GPUs; > * I have struggled with this for quite some time until I found the culprit, so if we can't immediately find and fix the cause I'd suggest leaving a caution statement on the simulation tips page. But I agree it has to be less strongly worded...; > ; > I'll try to provide a MWE that reproduces the behavior, but I'm currently having trouble getting my hands on some GPU, so I'm not sure how fast I can do that. Ok, no rush!. Trig functions aren't generically slower on GPUs than CPUs. On CPUs I think our code is fairly non-optimal right now, so various sources of overhead (eg non-optimal threading) can ""hide"" slow operations on the CPU. On the GPU we are more efficient, so overall speed might depend more sensitively on user code when it's injected. (I'd also argue that the beginning of this section is a bit misleading in how it claims we ""try to optimize"" internal source code. In fact, we have performed almost no performance optimization, and this is an important topic for future work.). I found this reference for the cost of various floating point operations on the CPU:. https://latkin.org/blog/2014/11/09/a-simple-benchmark-of-various-math-operations/. We could reproduce this chart on a GPU with CUDA.jl if we want to provide some useful information to users. I think if we're talking about a _constant_ (the current case), then precomputation hardly harms code complexity (both examples are equally readable to me). Precomputing an _array_ is another story (for example, a forcing function or boundary condition that depends on `sin(x)`). This lesson is definitely not restricted to trigonometric functions or the GPU. The basic principle here is that _there is a trade-off_ betwe",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151
https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151:1076,Integrability,depend,depend,1076,"t dropped it). I also slightly reworded it to have less absolute statements, but further rewording is necessary after we finish this discussion I think.; > ; > Some notes:; > ; > * The same code on CPUs isn't even close to have the same slowdown. So there's definitely something going on here for GPUs; > * I have struggled with this for quite some time until I found the culprit, so if we can't immediately find and fix the cause I'd suggest leaving a caution statement on the simulation tips page. But I agree it has to be less strongly worded...; > ; > I'll try to provide a MWE that reproduces the behavior, but I'm currently having trouble getting my hands on some GPU, so I'm not sure how fast I can do that. Ok, no rush!. Trig functions aren't generically slower on GPUs than CPUs. On CPUs I think our code is fairly non-optimal right now, so various sources of overhead (eg non-optimal threading) can ""hide"" slow operations on the CPU. On the GPU we are more efficient, so overall speed might depend more sensitively on user code when it's injected. (I'd also argue that the beginning of this section is a bit misleading in how it claims we ""try to optimize"" internal source code. In fact, we have performed almost no performance optimization, and this is an important topic for future work.). I found this reference for the cost of various floating point operations on the CPU:. https://latkin.org/blog/2014/11/09/a-simple-benchmark-of-various-math-operations/. We could reproduce this chart on a GPU with CUDA.jl if we want to provide some useful information to users. I think if we're talking about a _constant_ (the current case), then precomputation hardly harms code complexity (both examples are equally readable to me). Precomputing an _array_ is another story (for example, a forcing function or boundary condition that depends on `sin(x)`). This lesson is definitely not restricted to trigonometric functions or the GPU. The basic principle here is that _there is a trade-off_ betwe",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151
https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151:1123,Integrability,inject,injected,1123,"t dropped it). I also slightly reworded it to have less absolute statements, but further rewording is necessary after we finish this discussion I think.; > ; > Some notes:; > ; > * The same code on CPUs isn't even close to have the same slowdown. So there's definitely something going on here for GPUs; > * I have struggled with this for quite some time until I found the culprit, so if we can't immediately find and fix the cause I'd suggest leaving a caution statement on the simulation tips page. But I agree it has to be less strongly worded...; > ; > I'll try to provide a MWE that reproduces the behavior, but I'm currently having trouble getting my hands on some GPU, so I'm not sure how fast I can do that. Ok, no rush!. Trig functions aren't generically slower on GPUs than CPUs. On CPUs I think our code is fairly non-optimal right now, so various sources of overhead (eg non-optimal threading) can ""hide"" slow operations on the CPU. On the GPU we are more efficient, so overall speed might depend more sensitively on user code when it's injected. (I'd also argue that the beginning of this section is a bit misleading in how it claims we ""try to optimize"" internal source code. In fact, we have performed almost no performance optimization, and this is an important topic for future work.). I found this reference for the cost of various floating point operations on the CPU:. https://latkin.org/blog/2014/11/09/a-simple-benchmark-of-various-math-operations/. We could reproduce this chart on a GPU with CUDA.jl if we want to provide some useful information to users. I think if we're talking about a _constant_ (the current case), then precomputation hardly harms code complexity (both examples are equally readable to me). Precomputing an _array_ is another story (for example, a forcing function or boundary condition that depends on `sin(x)`). This lesson is definitely not restricted to trigonometric functions or the GPU. The basic principle here is that _there is a trade-off_ betwe",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151
https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151:1912,Integrability,depend,depends,1912,"ggest leaving a caution statement on the simulation tips page. But I agree it has to be less strongly worded...; > ; > I'll try to provide a MWE that reproduces the behavior, but I'm currently having trouble getting my hands on some GPU, so I'm not sure how fast I can do that. Ok, no rush!. Trig functions aren't generically slower on GPUs than CPUs. On CPUs I think our code is fairly non-optimal right now, so various sources of overhead (eg non-optimal threading) can ""hide"" slow operations on the CPU. On the GPU we are more efficient, so overall speed might depend more sensitively on user code when it's injected. (I'd also argue that the beginning of this section is a bit misleading in how it claims we ""try to optimize"" internal source code. In fact, we have performed almost no performance optimization, and this is an important topic for future work.). I found this reference for the cost of various floating point operations on the CPU:. https://latkin.org/blog/2014/11/09/a-simple-benchmark-of-various-math-operations/. We could reproduce this chart on a GPU with CUDA.jl if we want to provide some useful information to users. I think if we're talking about a _constant_ (the current case), then precomputation hardly harms code complexity (both examples are equally readable to me). Precomputing an _array_ is another story (for example, a forcing function or boundary condition that depends on `sin(x)`). This lesson is definitely not restricted to trigonometric functions or the GPU. The basic principle here is that _there is a trade-off_ between precomputing a potentially expensive operation, and performing it on-the-fly. For constants, precomputation is harmless. For arrays, on-the-fly computation has significant benefits, both for code readability and also possibly for performance (in memory-bound computations). Enlightening users on 1) the existence of this trade-off and 2) how to use benchmarking to find the optimal solution for their problem would probably be useful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151
https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151:1232,Performance,optimiz,optimize,1232,"inish this discussion I think.; > ; > Some notes:; > ; > * The same code on CPUs isn't even close to have the same slowdown. So there's definitely something going on here for GPUs; > * I have struggled with this for quite some time until I found the culprit, so if we can't immediately find and fix the cause I'd suggest leaving a caution statement on the simulation tips page. But I agree it has to be less strongly worded...; > ; > I'll try to provide a MWE that reproduces the behavior, but I'm currently having trouble getting my hands on some GPU, so I'm not sure how fast I can do that. Ok, no rush!. Trig functions aren't generically slower on GPUs than CPUs. On CPUs I think our code is fairly non-optimal right now, so various sources of overhead (eg non-optimal threading) can ""hide"" slow operations on the CPU. On the GPU we are more efficient, so overall speed might depend more sensitively on user code when it's injected. (I'd also argue that the beginning of this section is a bit misleading in how it claims we ""try to optimize"" internal source code. In fact, we have performed almost no performance optimization, and this is an important topic for future work.). I found this reference for the cost of various floating point operations on the CPU:. https://latkin.org/blog/2014/11/09/a-simple-benchmark-of-various-math-operations/. We could reproduce this chart on a GPU with CUDA.jl if we want to provide some useful information to users. I think if we're talking about a _constant_ (the current case), then precomputation hardly harms code complexity (both examples are equally readable to me). Precomputing an _array_ is another story (for example, a forcing function or boundary condition that depends on `sin(x)`). This lesson is definitely not restricted to trigonometric functions or the GPU. The basic principle here is that _there is a trade-off_ between precomputing a potentially expensive operation, and performing it on-the-fly. For constants, precomputation is harmless.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151
https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151:1281,Performance,perform,performed,1281,"wn. So there's definitely something going on here for GPUs; > * I have struggled with this for quite some time until I found the culprit, so if we can't immediately find and fix the cause I'd suggest leaving a caution statement on the simulation tips page. But I agree it has to be less strongly worded...; > ; > I'll try to provide a MWE that reproduces the behavior, but I'm currently having trouble getting my hands on some GPU, so I'm not sure how fast I can do that. Ok, no rush!. Trig functions aren't generically slower on GPUs than CPUs. On CPUs I think our code is fairly non-optimal right now, so various sources of overhead (eg non-optimal threading) can ""hide"" slow operations on the CPU. On the GPU we are more efficient, so overall speed might depend more sensitively on user code when it's injected. (I'd also argue that the beginning of this section is a bit misleading in how it claims we ""try to optimize"" internal source code. In fact, we have performed almost no performance optimization, and this is an important topic for future work.). I found this reference for the cost of various floating point operations on the CPU:. https://latkin.org/blog/2014/11/09/a-simple-benchmark-of-various-math-operations/. We could reproduce this chart on a GPU with CUDA.jl if we want to provide some useful information to users. I think if we're talking about a _constant_ (the current case), then precomputation hardly harms code complexity (both examples are equally readable to me). Precomputing an _array_ is another story (for example, a forcing function or boundary condition that depends on `sin(x)`). This lesson is definitely not restricted to trigonometric functions or the GPU. The basic principle here is that _there is a trade-off_ between precomputing a potentially expensive operation, and performing it on-the-fly. For constants, precomputation is harmless. For arrays, on-the-fly computation has significant benefits, both for code readability and also possibly for performance",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151
https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151:1301,Performance,perform,performance,1301,"wn. So there's definitely something going on here for GPUs; > * I have struggled with this for quite some time until I found the culprit, so if we can't immediately find and fix the cause I'd suggest leaving a caution statement on the simulation tips page. But I agree it has to be less strongly worded...; > ; > I'll try to provide a MWE that reproduces the behavior, but I'm currently having trouble getting my hands on some GPU, so I'm not sure how fast I can do that. Ok, no rush!. Trig functions aren't generically slower on GPUs than CPUs. On CPUs I think our code is fairly non-optimal right now, so various sources of overhead (eg non-optimal threading) can ""hide"" slow operations on the CPU. On the GPU we are more efficient, so overall speed might depend more sensitively on user code when it's injected. (I'd also argue that the beginning of this section is a bit misleading in how it claims we ""try to optimize"" internal source code. In fact, we have performed almost no performance optimization, and this is an important topic for future work.). I found this reference for the cost of various floating point operations on the CPU:. https://latkin.org/blog/2014/11/09/a-simple-benchmark-of-various-math-operations/. We could reproduce this chart on a GPU with CUDA.jl if we want to provide some useful information to users. I think if we're talking about a _constant_ (the current case), then precomputation hardly harms code complexity (both examples are equally readable to me). Precomputing an _array_ is another story (for example, a forcing function or boundary condition that depends on `sin(x)`). This lesson is definitely not restricted to trigonometric functions or the GPU. The basic principle here is that _there is a trade-off_ between precomputing a potentially expensive operation, and performing it on-the-fly. For constants, precomputation is harmless. For arrays, on-the-fly computation has significant benefits, both for code readability and also possibly for performance",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151
https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151:1313,Performance,optimiz,optimization,1313,"wn. So there's definitely something going on here for GPUs; > * I have struggled with this for quite some time until I found the culprit, so if we can't immediately find and fix the cause I'd suggest leaving a caution statement on the simulation tips page. But I agree it has to be less strongly worded...; > ; > I'll try to provide a MWE that reproduces the behavior, but I'm currently having trouble getting my hands on some GPU, so I'm not sure how fast I can do that. Ok, no rush!. Trig functions aren't generically slower on GPUs than CPUs. On CPUs I think our code is fairly non-optimal right now, so various sources of overhead (eg non-optimal threading) can ""hide"" slow operations on the CPU. On the GPU we are more efficient, so overall speed might depend more sensitively on user code when it's injected. (I'd also argue that the beginning of this section is a bit misleading in how it claims we ""try to optimize"" internal source code. In fact, we have performed almost no performance optimization, and this is an important topic for future work.). I found this reference for the cost of various floating point operations on the CPU:. https://latkin.org/blog/2014/11/09/a-simple-benchmark-of-various-math-operations/. We could reproduce this chart on a GPU with CUDA.jl if we want to provide some useful information to users. I think if we're talking about a _constant_ (the current case), then precomputation hardly harms code complexity (both examples are equally readable to me). Precomputing an _array_ is another story (for example, a forcing function or boundary condition that depends on `sin(x)`). This lesson is definitely not restricted to trigonometric functions or the GPU. The basic principle here is that _there is a trade-off_ between precomputing a potentially expensive operation, and performing it on-the-fly. For constants, precomputation is harmless. For arrays, on-the-fly computation has significant benefits, both for code readability and also possibly for performance",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151
https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151:2130,Performance,perform,performing,2130,"ggest leaving a caution statement on the simulation tips page. But I agree it has to be less strongly worded...; > ; > I'll try to provide a MWE that reproduces the behavior, but I'm currently having trouble getting my hands on some GPU, so I'm not sure how fast I can do that. Ok, no rush!. Trig functions aren't generically slower on GPUs than CPUs. On CPUs I think our code is fairly non-optimal right now, so various sources of overhead (eg non-optimal threading) can ""hide"" slow operations on the CPU. On the GPU we are more efficient, so overall speed might depend more sensitively on user code when it's injected. (I'd also argue that the beginning of this section is a bit misleading in how it claims we ""try to optimize"" internal source code. In fact, we have performed almost no performance optimization, and this is an important topic for future work.). I found this reference for the cost of various floating point operations on the CPU:. https://latkin.org/blog/2014/11/09/a-simple-benchmark-of-various-math-operations/. We could reproduce this chart on a GPU with CUDA.jl if we want to provide some useful information to users. I think if we're talking about a _constant_ (the current case), then precomputation hardly harms code complexity (both examples are equally readable to me). Precomputing an _array_ is another story (for example, a forcing function or boundary condition that depends on `sin(x)`). This lesson is definitely not restricted to trigonometric functions or the GPU. The basic principle here is that _there is a trade-off_ between precomputing a potentially expensive operation, and performing it on-the-fly. For constants, precomputation is harmless. For arrays, on-the-fly computation has significant benefits, both for code readability and also possibly for performance (in memory-bound computations). Enlightening users on 1) the existence of this trade-off and 2) how to use benchmarking to find the optimal solution for their problem would probably be useful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151
https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151:2308,Performance,perform,performance,2308,"ggest leaving a caution statement on the simulation tips page. But I agree it has to be less strongly worded...; > ; > I'll try to provide a MWE that reproduces the behavior, but I'm currently having trouble getting my hands on some GPU, so I'm not sure how fast I can do that. Ok, no rush!. Trig functions aren't generically slower on GPUs than CPUs. On CPUs I think our code is fairly non-optimal right now, so various sources of overhead (eg non-optimal threading) can ""hide"" slow operations on the CPU. On the GPU we are more efficient, so overall speed might depend more sensitively on user code when it's injected. (I'd also argue that the beginning of this section is a bit misleading in how it claims we ""try to optimize"" internal source code. In fact, we have performed almost no performance optimization, and this is an important topic for future work.). I found this reference for the cost of various floating point operations on the CPU:. https://latkin.org/blog/2014/11/09/a-simple-benchmark-of-various-math-operations/. We could reproduce this chart on a GPU with CUDA.jl if we want to provide some useful information to users. I think if we're talking about a _constant_ (the current case), then precomputation hardly harms code complexity (both examples are equally readable to me). Precomputing an _array_ is another story (for example, a forcing function or boundary condition that depends on `sin(x)`). This lesson is definitely not restricted to trigonometric functions or the GPU. The basic principle here is that _there is a trade-off_ between precomputing a potentially expensive operation, and performing it on-the-fly. For constants, precomputation is harmless. For arrays, on-the-fly computation has significant benefits, both for code readability and also possibly for performance (in memory-bound computations). Enlightening users on 1) the existence of this trade-off and 2) how to use benchmarking to find the optimal solution for their problem would probably be useful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151
https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151:1123,Security,inject,injected,1123,"t dropped it). I also slightly reworded it to have less absolute statements, but further rewording is necessary after we finish this discussion I think.; > ; > Some notes:; > ; > * The same code on CPUs isn't even close to have the same slowdown. So there's definitely something going on here for GPUs; > * I have struggled with this for quite some time until I found the culprit, so if we can't immediately find and fix the cause I'd suggest leaving a caution statement on the simulation tips page. But I agree it has to be less strongly worded...; > ; > I'll try to provide a MWE that reproduces the behavior, but I'm currently having trouble getting my hands on some GPU, so I'm not sure how fast I can do that. Ok, no rush!. Trig functions aren't generically slower on GPUs than CPUs. On CPUs I think our code is fairly non-optimal right now, so various sources of overhead (eg non-optimal threading) can ""hide"" slow operations on the CPU. On the GPU we are more efficient, so overall speed might depend more sensitively on user code when it's injected. (I'd also argue that the beginning of this section is a bit misleading in how it claims we ""try to optimize"" internal source code. In fact, we have performed almost no performance optimization, and this is an important topic for future work.). I found this reference for the cost of various floating point operations on the CPU:. https://latkin.org/blog/2014/11/09/a-simple-benchmark-of-various-math-operations/. We could reproduce this chart on a GPU with CUDA.jl if we want to provide some useful information to users. I think if we're talking about a _constant_ (the current case), then precomputation hardly harms code complexity (both examples are equally readable to me). Precomputing an _array_ is another story (for example, a forcing function or boundary condition that depends on `sin(x)`). This lesson is definitely not restricted to trigonometric functions or the GPU. The basic principle here is that _there is a trade-off_ betwe",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151
https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151:1507,Testability,benchmark,benchmark-of-various-math-operations,1507,"uggest leaving a caution statement on the simulation tips page. But I agree it has to be less strongly worded...; > ; > I'll try to provide a MWE that reproduces the behavior, but I'm currently having trouble getting my hands on some GPU, so I'm not sure how fast I can do that. Ok, no rush!. Trig functions aren't generically slower on GPUs than CPUs. On CPUs I think our code is fairly non-optimal right now, so various sources of overhead (eg non-optimal threading) can ""hide"" slow operations on the CPU. On the GPU we are more efficient, so overall speed might depend more sensitively on user code when it's injected. (I'd also argue that the beginning of this section is a bit misleading in how it claims we ""try to optimize"" internal source code. In fact, we have performed almost no performance optimization, and this is an important topic for future work.). I found this reference for the cost of various floating point operations on the CPU:. https://latkin.org/blog/2014/11/09/a-simple-benchmark-of-various-math-operations/. We could reproduce this chart on a GPU with CUDA.jl if we want to provide some useful information to users. I think if we're talking about a _constant_ (the current case), then precomputation hardly harms code complexity (both examples are equally readable to me). Precomputing an _array_ is another story (for example, a forcing function or boundary condition that depends on `sin(x)`). This lesson is definitely not restricted to trigonometric functions or the GPU. The basic principle here is that _there is a trade-off_ between precomputing a potentially expensive operation, and performing it on-the-fly. For constants, precomputation is harmless. For arrays, on-the-fly computation has significant benefits, both for code readability and also possibly for performance (in memory-bound computations). Enlightening users on 1) the existence of this trade-off and 2) how to use benchmarking to find the optimal solution for their problem would probably be useful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151
https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151:2427,Testability,benchmark,benchmarking,2427,"ggest leaving a caution statement on the simulation tips page. But I agree it has to be less strongly worded...; > ; > I'll try to provide a MWE that reproduces the behavior, but I'm currently having trouble getting my hands on some GPU, so I'm not sure how fast I can do that. Ok, no rush!. Trig functions aren't generically slower on GPUs than CPUs. On CPUs I think our code is fairly non-optimal right now, so various sources of overhead (eg non-optimal threading) can ""hide"" slow operations on the CPU. On the GPU we are more efficient, so overall speed might depend more sensitively on user code when it's injected. (I'd also argue that the beginning of this section is a bit misleading in how it claims we ""try to optimize"" internal source code. In fact, we have performed almost no performance optimization, and this is an important topic for future work.). I found this reference for the cost of various floating point operations on the CPU:. https://latkin.org/blog/2014/11/09/a-simple-benchmark-of-various-math-operations/. We could reproduce this chart on a GPU with CUDA.jl if we want to provide some useful information to users. I think if we're talking about a _constant_ (the current case), then precomputation hardly harms code complexity (both examples are equally readable to me). Precomputing an _array_ is another story (for example, a forcing function or boundary condition that depends on `sin(x)`). This lesson is definitely not restricted to trigonometric functions or the GPU. The basic principle here is that _there is a trade-off_ between precomputing a potentially expensive operation, and performing it on-the-fly. For constants, precomputation is harmless. For arrays, on-the-fly computation has significant benefits, both for code readability and also possibly for performance (in memory-bound computations). Enlightening users on 1) the existence of this trade-off and 2) how to use benchmarking to find the optimal solution for their problem would probably be useful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151
https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151:1500,Usability,simpl,simple-benchmark-of-various-math-operations,1500,"uggest leaving a caution statement on the simulation tips page. But I agree it has to be less strongly worded...; > ; > I'll try to provide a MWE that reproduces the behavior, but I'm currently having trouble getting my hands on some GPU, so I'm not sure how fast I can do that. Ok, no rush!. Trig functions aren't generically slower on GPUs than CPUs. On CPUs I think our code is fairly non-optimal right now, so various sources of overhead (eg non-optimal threading) can ""hide"" slow operations on the CPU. On the GPU we are more efficient, so overall speed might depend more sensitively on user code when it's injected. (I'd also argue that the beginning of this section is a bit misleading in how it claims we ""try to optimize"" internal source code. In fact, we have performed almost no performance optimization, and this is an important topic for future work.). I found this reference for the cost of various floating point operations on the CPU:. https://latkin.org/blog/2014/11/09/a-simple-benchmark-of-various-math-operations/. We could reproduce this chart on a GPU with CUDA.jl if we want to provide some useful information to users. I think if we're talking about a _constant_ (the current case), then precomputation hardly harms code complexity (both examples are equally readable to me). Precomputing an _array_ is another story (for example, a forcing function or boundary condition that depends on `sin(x)`). This lesson is definitely not restricted to trigonometric functions or the GPU. The basic principle here is that _there is a trade-off_ between precomputing a potentially expensive operation, and performing it on-the-fly. For constants, precomputation is harmless. For arrays, on-the-fly computation has significant benefits, both for code readability and also possibly for performance (in memory-bound computations). Enlightening users on 1) the existence of this trade-off and 2) how to use benchmarking to find the optimal solution for their problem would probably be useful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952107151
https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-956540913:195,Safety,avoid,avoiding,195,"Based on [this finding](https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-952119253) it's not just the trig functions that are causing problems, so I agree that the statement about avoiding them shouldn't be there. I removed that and hopefully we can still merge this PR since it's a small improvement. I do think we should look into what's causing the slowdown with the trig function for me specifically though, so I created an issue for that: https://github.com/CliMA/Oceananigans.jl/issues/2034",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-956540913
https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-956542509:105,Testability,test,tests,105,"> I removed that and hopefully we can still merge this PR since it's a small improvement. Yeah, merge if tests pass!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-956542509
https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953473616:281,Deployability,patch,patch,281,"@tomchor:. - I don't understand what ""really"" means in ""it didn't really work"". Did it work or it didn't work?. - In case there was an issue, can you elaborate what that was and why `Adapt` is the solution?. - Last, if there is still an issue and this PR fixes it then it worths a patch release. There is no quota of patch releases. We can release as many as we need to.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953473616
https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953473616:287,Deployability,release,release,287,"@tomchor:. - I don't understand what ""really"" means in ""it didn't really work"". Did it work or it didn't work?. - In case there was an issue, can you elaborate what that was and why `Adapt` is the solution?. - Last, if there is still an issue and this PR fixes it then it worths a patch release. There is no quota of patch releases. We can release as many as we need to.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953473616
https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953473616:317,Deployability,patch,patch,317,"@tomchor:. - I don't understand what ""really"" means in ""it didn't really work"". Did it work or it didn't work?. - In case there was an issue, can you elaborate what that was and why `Adapt` is the solution?. - Last, if there is still an issue and this PR fixes it then it worths a patch release. There is no quota of patch releases. We can release as many as we need to.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953473616
https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953473616:323,Deployability,release,releases,323,"@tomchor:. - I don't understand what ""really"" means in ""it didn't really work"". Did it work or it didn't work?. - In case there was an issue, can you elaborate what that was and why `Adapt` is the solution?. - Last, if there is still an issue and this PR fixes it then it worths a patch release. There is no quota of patch releases. We can release as many as we need to.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953473616
https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953473616:340,Deployability,release,release,340,"@tomchor:. - I don't understand what ""really"" means in ""it didn't really work"". Did it work or it didn't work?. - In case there was an issue, can you elaborate what that was and why `Adapt` is the solution?. - Last, if there is still an issue and this PR fixes it then it worths a patch release. There is no quota of patch releases. We can release as many as we need to.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953473616
https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953473616:183,Energy Efficiency,Adapt,Adapt,183,"@tomchor:. - I don't understand what ""really"" means in ""it didn't really work"". Did it work or it didn't work?. - In case there was an issue, can you elaborate what that was and why `Adapt` is the solution?. - Last, if there is still an issue and this PR fixes it then it worths a patch release. There is no quota of patch releases. We can release as many as we need to.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953473616
https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953473616:183,Modifiability,Adapt,Adapt,183,"@tomchor:. - I don't understand what ""really"" means in ""it didn't really work"". Did it work or it didn't work?. - In case there was an issue, can you elaborate what that was and why `Adapt` is the solution?. - Last, if there is still an issue and this PR fixes it then it worths a patch release. There is no quota of patch releases. We can release as many as we need to.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953473616
https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212:293,Deployability,patch,patch,293,"> @tomchor:; > ; > * I don't understand what ""really"" means in ""it didn't really work"". Did it work or it didn't work?; > * In case there was an issue, can you elaborate what that was and why `Adapt` is the solution?; > * Last, if there is still an issue and this PR fixes it then it worths a patch release. There is no quota of patch releases. We can release as many as we need to. Sorry, let me be more clear:. - It _worked_ when I tried with a MWE that I had. I didn't try it with my main research code at the time because I only had limited GPU time and that code takes a while (I've been having trouble getting my hands on GPUs). However, I assume I must have done something wrong with my MWE because when I finally was able to test this with my main research code I wasn't able to start the simulation; - The issue that popped up was a scalar indexing one. I think basically the `z1==z2` equality uses scalar indexing, which doesn't work for GPUs. Wrapping the `nodes()` expression with `Adapt.adapt()` seemed to solve the issue on every instance that I was able to test so far. I guess `CUDA.@allowscalar` would also be a possibility.; - I will bump a patch release then. I just wasn't sure if we wanted to release a another version with just one PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212
https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212:299,Deployability,release,release,299,"> @tomchor:; > ; > * I don't understand what ""really"" means in ""it didn't really work"". Did it work or it didn't work?; > * In case there was an issue, can you elaborate what that was and why `Adapt` is the solution?; > * Last, if there is still an issue and this PR fixes it then it worths a patch release. There is no quota of patch releases. We can release as many as we need to. Sorry, let me be more clear:. - It _worked_ when I tried with a MWE that I had. I didn't try it with my main research code at the time because I only had limited GPU time and that code takes a while (I've been having trouble getting my hands on GPUs). However, I assume I must have done something wrong with my MWE because when I finally was able to test this with my main research code I wasn't able to start the simulation; - The issue that popped up was a scalar indexing one. I think basically the `z1==z2` equality uses scalar indexing, which doesn't work for GPUs. Wrapping the `nodes()` expression with `Adapt.adapt()` seemed to solve the issue on every instance that I was able to test so far. I guess `CUDA.@allowscalar` would also be a possibility.; - I will bump a patch release then. I just wasn't sure if we wanted to release a another version with just one PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212
https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212:329,Deployability,patch,patch,329,"> @tomchor:; > ; > * I don't understand what ""really"" means in ""it didn't really work"". Did it work or it didn't work?; > * In case there was an issue, can you elaborate what that was and why `Adapt` is the solution?; > * Last, if there is still an issue and this PR fixes it then it worths a patch release. There is no quota of patch releases. We can release as many as we need to. Sorry, let me be more clear:. - It _worked_ when I tried with a MWE that I had. I didn't try it with my main research code at the time because I only had limited GPU time and that code takes a while (I've been having trouble getting my hands on GPUs). However, I assume I must have done something wrong with my MWE because when I finally was able to test this with my main research code I wasn't able to start the simulation; - The issue that popped up was a scalar indexing one. I think basically the `z1==z2` equality uses scalar indexing, which doesn't work for GPUs. Wrapping the `nodes()` expression with `Adapt.adapt()` seemed to solve the issue on every instance that I was able to test so far. I guess `CUDA.@allowscalar` would also be a possibility.; - I will bump a patch release then. I just wasn't sure if we wanted to release a another version with just one PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212
https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212:335,Deployability,release,releases,335,"> @tomchor:; > ; > * I don't understand what ""really"" means in ""it didn't really work"". Did it work or it didn't work?; > * In case there was an issue, can you elaborate what that was and why `Adapt` is the solution?; > * Last, if there is still an issue and this PR fixes it then it worths a patch release. There is no quota of patch releases. We can release as many as we need to. Sorry, let me be more clear:. - It _worked_ when I tried with a MWE that I had. I didn't try it with my main research code at the time because I only had limited GPU time and that code takes a while (I've been having trouble getting my hands on GPUs). However, I assume I must have done something wrong with my MWE because when I finally was able to test this with my main research code I wasn't able to start the simulation; - The issue that popped up was a scalar indexing one. I think basically the `z1==z2` equality uses scalar indexing, which doesn't work for GPUs. Wrapping the `nodes()` expression with `Adapt.adapt()` seemed to solve the issue on every instance that I was able to test so far. I guess `CUDA.@allowscalar` would also be a possibility.; - I will bump a patch release then. I just wasn't sure if we wanted to release a another version with just one PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212
https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212:352,Deployability,release,release,352,"> @tomchor:; > ; > * I don't understand what ""really"" means in ""it didn't really work"". Did it work or it didn't work?; > * In case there was an issue, can you elaborate what that was and why `Adapt` is the solution?; > * Last, if there is still an issue and this PR fixes it then it worths a patch release. There is no quota of patch releases. We can release as many as we need to. Sorry, let me be more clear:. - It _worked_ when I tried with a MWE that I had. I didn't try it with my main research code at the time because I only had limited GPU time and that code takes a while (I've been having trouble getting my hands on GPUs). However, I assume I must have done something wrong with my MWE because when I finally was able to test this with my main research code I wasn't able to start the simulation; - The issue that popped up was a scalar indexing one. I think basically the `z1==z2` equality uses scalar indexing, which doesn't work for GPUs. Wrapping the `nodes()` expression with `Adapt.adapt()` seemed to solve the issue on every instance that I was able to test so far. I guess `CUDA.@allowscalar` would also be a possibility.; - I will bump a patch release then. I just wasn't sure if we wanted to release a another version with just one PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212
https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212:1159,Deployability,patch,patch,1159,"> @tomchor:; > ; > * I don't understand what ""really"" means in ""it didn't really work"". Did it work or it didn't work?; > * In case there was an issue, can you elaborate what that was and why `Adapt` is the solution?; > * Last, if there is still an issue and this PR fixes it then it worths a patch release. There is no quota of patch releases. We can release as many as we need to. Sorry, let me be more clear:. - It _worked_ when I tried with a MWE that I had. I didn't try it with my main research code at the time because I only had limited GPU time and that code takes a while (I've been having trouble getting my hands on GPUs). However, I assume I must have done something wrong with my MWE because when I finally was able to test this with my main research code I wasn't able to start the simulation; - The issue that popped up was a scalar indexing one. I think basically the `z1==z2` equality uses scalar indexing, which doesn't work for GPUs. Wrapping the `nodes()` expression with `Adapt.adapt()` seemed to solve the issue on every instance that I was able to test so far. I guess `CUDA.@allowscalar` would also be a possibility.; - I will bump a patch release then. I just wasn't sure if we wanted to release a another version with just one PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212
https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212:1165,Deployability,release,release,1165,"> @tomchor:; > ; > * I don't understand what ""really"" means in ""it didn't really work"". Did it work or it didn't work?; > * In case there was an issue, can you elaborate what that was and why `Adapt` is the solution?; > * Last, if there is still an issue and this PR fixes it then it worths a patch release. There is no quota of patch releases. We can release as many as we need to. Sorry, let me be more clear:. - It _worked_ when I tried with a MWE that I had. I didn't try it with my main research code at the time because I only had limited GPU time and that code takes a while (I've been having trouble getting my hands on GPUs). However, I assume I must have done something wrong with my MWE because when I finally was able to test this with my main research code I wasn't able to start the simulation; - The issue that popped up was a scalar indexing one. I think basically the `z1==z2` equality uses scalar indexing, which doesn't work for GPUs. Wrapping the `nodes()` expression with `Adapt.adapt()` seemed to solve the issue on every instance that I was able to test so far. I guess `CUDA.@allowscalar` would also be a possibility.; - I will bump a patch release then. I just wasn't sure if we wanted to release a another version with just one PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212
https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212:1214,Deployability,release,release,1214,"> @tomchor:; > ; > * I don't understand what ""really"" means in ""it didn't really work"". Did it work or it didn't work?; > * In case there was an issue, can you elaborate what that was and why `Adapt` is the solution?; > * Last, if there is still an issue and this PR fixes it then it worths a patch release. There is no quota of patch releases. We can release as many as we need to. Sorry, let me be more clear:. - It _worked_ when I tried with a MWE that I had. I didn't try it with my main research code at the time because I only had limited GPU time and that code takes a while (I've been having trouble getting my hands on GPUs). However, I assume I must have done something wrong with my MWE because when I finally was able to test this with my main research code I wasn't able to start the simulation; - The issue that popped up was a scalar indexing one. I think basically the `z1==z2` equality uses scalar indexing, which doesn't work for GPUs. Wrapping the `nodes()` expression with `Adapt.adapt()` seemed to solve the issue on every instance that I was able to test so far. I guess `CUDA.@allowscalar` would also be a possibility.; - I will bump a patch release then. I just wasn't sure if we wanted to release a another version with just one PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212
https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212:193,Energy Efficiency,Adapt,Adapt,193,"> @tomchor:; > ; > * I don't understand what ""really"" means in ""it didn't really work"". Did it work or it didn't work?; > * In case there was an issue, can you elaborate what that was and why `Adapt` is the solution?; > * Last, if there is still an issue and this PR fixes it then it worths a patch release. There is no quota of patch releases. We can release as many as we need to. Sorry, let me be more clear:. - It _worked_ when I tried with a MWE that I had. I didn't try it with my main research code at the time because I only had limited GPU time and that code takes a while (I've been having trouble getting my hands on GPUs). However, I assume I must have done something wrong with my MWE because when I finally was able to test this with my main research code I wasn't able to start the simulation; - The issue that popped up was a scalar indexing one. I think basically the `z1==z2` equality uses scalar indexing, which doesn't work for GPUs. Wrapping the `nodes()` expression with `Adapt.adapt()` seemed to solve the issue on every instance that I was able to test so far. I guess `CUDA.@allowscalar` would also be a possibility.; - I will bump a patch release then. I just wasn't sure if we wanted to release a another version with just one PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212
https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212:994,Energy Efficiency,Adapt,Adapt,994,"> @tomchor:; > ; > * I don't understand what ""really"" means in ""it didn't really work"". Did it work or it didn't work?; > * In case there was an issue, can you elaborate what that was and why `Adapt` is the solution?; > * Last, if there is still an issue and this PR fixes it then it worths a patch release. There is no quota of patch releases. We can release as many as we need to. Sorry, let me be more clear:. - It _worked_ when I tried with a MWE that I had. I didn't try it with my main research code at the time because I only had limited GPU time and that code takes a while (I've been having trouble getting my hands on GPUs). However, I assume I must have done something wrong with my MWE because when I finally was able to test this with my main research code I wasn't able to start the simulation; - The issue that popped up was a scalar indexing one. I think basically the `z1==z2` equality uses scalar indexing, which doesn't work for GPUs. Wrapping the `nodes()` expression with `Adapt.adapt()` seemed to solve the issue on every instance that I was able to test so far. I guess `CUDA.@allowscalar` would also be a possibility.; - I will bump a patch release then. I just wasn't sure if we wanted to release a another version with just one PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212
https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212:1000,Energy Efficiency,adapt,adapt,1000,"> @tomchor:; > ; > * I don't understand what ""really"" means in ""it didn't really work"". Did it work or it didn't work?; > * In case there was an issue, can you elaborate what that was and why `Adapt` is the solution?; > * Last, if there is still an issue and this PR fixes it then it worths a patch release. There is no quota of patch releases. We can release as many as we need to. Sorry, let me be more clear:. - It _worked_ when I tried with a MWE that I had. I didn't try it with my main research code at the time because I only had limited GPU time and that code takes a while (I've been having trouble getting my hands on GPUs). However, I assume I must have done something wrong with my MWE because when I finally was able to test this with my main research code I wasn't able to start the simulation; - The issue that popped up was a scalar indexing one. I think basically the `z1==z2` equality uses scalar indexing, which doesn't work for GPUs. Wrapping the `nodes()` expression with `Adapt.adapt()` seemed to solve the issue on every instance that I was able to test so far. I guess `CUDA.@allowscalar` would also be a possibility.; - I will bump a patch release then. I just wasn't sure if we wanted to release a another version with just one PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212
https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212:954,Integrability,Wrap,Wrapping,954,"> @tomchor:; > ; > * I don't understand what ""really"" means in ""it didn't really work"". Did it work or it didn't work?; > * In case there was an issue, can you elaborate what that was and why `Adapt` is the solution?; > * Last, if there is still an issue and this PR fixes it then it worths a patch release. There is no quota of patch releases. We can release as many as we need to. Sorry, let me be more clear:. - It _worked_ when I tried with a MWE that I had. I didn't try it with my main research code at the time because I only had limited GPU time and that code takes a while (I've been having trouble getting my hands on GPUs). However, I assume I must have done something wrong with my MWE because when I finally was able to test this with my main research code I wasn't able to start the simulation; - The issue that popped up was a scalar indexing one. I think basically the `z1==z2` equality uses scalar indexing, which doesn't work for GPUs. Wrapping the `nodes()` expression with `Adapt.adapt()` seemed to solve the issue on every instance that I was able to test so far. I guess `CUDA.@allowscalar` would also be a possibility.; - I will bump a patch release then. I just wasn't sure if we wanted to release a another version with just one PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212
https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212:193,Modifiability,Adapt,Adapt,193,"> @tomchor:; > ; > * I don't understand what ""really"" means in ""it didn't really work"". Did it work or it didn't work?; > * In case there was an issue, can you elaborate what that was and why `Adapt` is the solution?; > * Last, if there is still an issue and this PR fixes it then it worths a patch release. There is no quota of patch releases. We can release as many as we need to. Sorry, let me be more clear:. - It _worked_ when I tried with a MWE that I had. I didn't try it with my main research code at the time because I only had limited GPU time and that code takes a while (I've been having trouble getting my hands on GPUs). However, I assume I must have done something wrong with my MWE because when I finally was able to test this with my main research code I wasn't able to start the simulation; - The issue that popped up was a scalar indexing one. I think basically the `z1==z2` equality uses scalar indexing, which doesn't work for GPUs. Wrapping the `nodes()` expression with `Adapt.adapt()` seemed to solve the issue on every instance that I was able to test so far. I guess `CUDA.@allowscalar` would also be a possibility.; - I will bump a patch release then. I just wasn't sure if we wanted to release a another version with just one PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212
https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212:994,Modifiability,Adapt,Adapt,994,"> @tomchor:; > ; > * I don't understand what ""really"" means in ""it didn't really work"". Did it work or it didn't work?; > * In case there was an issue, can you elaborate what that was and why `Adapt` is the solution?; > * Last, if there is still an issue and this PR fixes it then it worths a patch release. There is no quota of patch releases. We can release as many as we need to. Sorry, let me be more clear:. - It _worked_ when I tried with a MWE that I had. I didn't try it with my main research code at the time because I only had limited GPU time and that code takes a while (I've been having trouble getting my hands on GPUs). However, I assume I must have done something wrong with my MWE because when I finally was able to test this with my main research code I wasn't able to start the simulation; - The issue that popped up was a scalar indexing one. I think basically the `z1==z2` equality uses scalar indexing, which doesn't work for GPUs. Wrapping the `nodes()` expression with `Adapt.adapt()` seemed to solve the issue on every instance that I was able to test so far. I guess `CUDA.@allowscalar` would also be a possibility.; - I will bump a patch release then. I just wasn't sure if we wanted to release a another version with just one PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212
https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212:1000,Modifiability,adapt,adapt,1000,"> @tomchor:; > ; > * I don't understand what ""really"" means in ""it didn't really work"". Did it work or it didn't work?; > * In case there was an issue, can you elaborate what that was and why `Adapt` is the solution?; > * Last, if there is still an issue and this PR fixes it then it worths a patch release. There is no quota of patch releases. We can release as many as we need to. Sorry, let me be more clear:. - It _worked_ when I tried with a MWE that I had. I didn't try it with my main research code at the time because I only had limited GPU time and that code takes a while (I've been having trouble getting my hands on GPUs). However, I assume I must have done something wrong with my MWE because when I finally was able to test this with my main research code I wasn't able to start the simulation; - The issue that popped up was a scalar indexing one. I think basically the `z1==z2` equality uses scalar indexing, which doesn't work for GPUs. Wrapping the `nodes()` expression with `Adapt.adapt()` seemed to solve the issue on every instance that I was able to test so far. I guess `CUDA.@allowscalar` would also be a possibility.; - I will bump a patch release then. I just wasn't sure if we wanted to release a another version with just one PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212
https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212:733,Testability,test,test,733,"> @tomchor:; > ; > * I don't understand what ""really"" means in ""it didn't really work"". Did it work or it didn't work?; > * In case there was an issue, can you elaborate what that was and why `Adapt` is the solution?; > * Last, if there is still an issue and this PR fixes it then it worths a patch release. There is no quota of patch releases. We can release as many as we need to. Sorry, let me be more clear:. - It _worked_ when I tried with a MWE that I had. I didn't try it with my main research code at the time because I only had limited GPU time and that code takes a while (I've been having trouble getting my hands on GPUs). However, I assume I must have done something wrong with my MWE because when I finally was able to test this with my main research code I wasn't able to start the simulation; - The issue that popped up was a scalar indexing one. I think basically the `z1==z2` equality uses scalar indexing, which doesn't work for GPUs. Wrapping the `nodes()` expression with `Adapt.adapt()` seemed to solve the issue on every instance that I was able to test so far. I guess `CUDA.@allowscalar` would also be a possibility.; - I will bump a patch release then. I just wasn't sure if we wanted to release a another version with just one PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212
https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212:1072,Testability,test,test,1072,"> @tomchor:; > ; > * I don't understand what ""really"" means in ""it didn't really work"". Did it work or it didn't work?; > * In case there was an issue, can you elaborate what that was and why `Adapt` is the solution?; > * Last, if there is still an issue and this PR fixes it then it worths a patch release. There is no quota of patch releases. We can release as many as we need to. Sorry, let me be more clear:. - It _worked_ when I tried with a MWE that I had. I didn't try it with my main research code at the time because I only had limited GPU time and that code takes a while (I've been having trouble getting my hands on GPUs). However, I assume I must have done something wrong with my MWE because when I finally was able to test this with my main research code I wasn't able to start the simulation; - The issue that popped up was a scalar indexing one. I think basically the `z1==z2` equality uses scalar indexing, which doesn't work for GPUs. Wrapping the `nodes()` expression with `Adapt.adapt()` seemed to solve the issue on every instance that I was able to test so far. I guess `CUDA.@allowscalar` would also be a possibility.; - I will bump a patch release then. I just wasn't sure if we wanted to release a another version with just one PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212
https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212:405,Usability,clear,clear,405,"> @tomchor:; > ; > * I don't understand what ""really"" means in ""it didn't really work"". Did it work or it didn't work?; > * In case there was an issue, can you elaborate what that was and why `Adapt` is the solution?; > * Last, if there is still an issue and this PR fixes it then it worths a patch release. There is no quota of patch releases. We can release as many as we need to. Sorry, let me be more clear:. - It _worked_ when I tried with a MWE that I had. I didn't try it with my main research code at the time because I only had limited GPU time and that code takes a while (I've been having trouble getting my hands on GPUs). However, I assume I must have done something wrong with my MWE because when I finally was able to test this with my main research code I wasn't able to start the simulation; - The issue that popped up was a scalar indexing one. I think basically the `z1==z2` equality uses scalar indexing, which doesn't work for GPUs. Wrapping the `nodes()` expression with `Adapt.adapt()` seemed to solve the issue on every instance that I was able to test so far. I guess `CUDA.@allowscalar` would also be a possibility.; - I will bump a patch release then. I just wasn't sure if we wanted to release a another version with just one PR.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953477212
https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-954396122:113,Availability,error,error,113,"@glwagner for some reason your suggestion using tuples didn't work. I was getting a ""scalar indexing disallowed"" error on that same line, which was weird. So I changed it to an `@allowscalar` statement. It's also weird that the test I added (which supposedly tests both CPUs and GPUs) didn't catch that.... not sure why",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-954396122
https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-954396122:228,Testability,test,test,228,"@glwagner for some reason your suggestion using tuples didn't work. I was getting a ""scalar indexing disallowed"" error on that same line, which was weird. So I changed it to an `@allowscalar` statement. It's also weird that the test I added (which supposedly tests both CPUs and GPUs) didn't catch that.... not sure why",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-954396122
https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-954396122:259,Testability,test,tests,259,"@glwagner for some reason your suggestion using tuples didn't work. I was getting a ""scalar indexing disallowed"" error on that same line, which was weird. So I changed it to an `@allowscalar` statement. It's also weird that the test I added (which supposedly tests both CPUs and GPUs) didn't catch that.... not sure why",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-954396122
https://github.com/CliMA/Oceananigans.jl/pull/2031#issuecomment-955473060:149,Integrability,synchroniz,synchronization,149,The reason why this test does not pass on the GPU for periodic boundary conditions in the longitudinal direction might have something to do with the synchronization of the halo filling (PR #1985 which we might want to merge soon),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2031#issuecomment-955473060
https://github.com/CliMA/Oceananigans.jl/pull/2031#issuecomment-955473060:20,Testability,test,test,20,The reason why this test does not pass on the GPU for periodic boundary conditions in the longitudinal direction might have something to do with the synchronization of the halo filling (PR #1985 which we might want to merge soon),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2031#issuecomment-955473060
https://github.com/CliMA/Oceananigans.jl/pull/2031#issuecomment-956239478:28,Testability,test,test,28,Added implicit free surface test,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2031#issuecomment-956239478
https://github.com/CliMA/Oceananigans.jl/pull/2031#issuecomment-956275604:141,Integrability,message,messages,141,"> @simone-silvestri, will you expand this regression to `ImplicitFreeSurface` as well? If not, then perhaps add a note in one of the `@info` messages clarifying e.g. ""... with explicit free surface formulation""?. Good idea, if the test is still cheap!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2031#issuecomment-956275604
https://github.com/CliMA/Oceananigans.jl/pull/2031#issuecomment-956275604:231,Testability,test,test,231,"> @simone-silvestri, will you expand this regression to `ImplicitFreeSurface` as well? If not, then perhaps add a note in one of the `@info` messages clarifying e.g. ""... with explicit free surface formulation""?. Good idea, if the test is still cheap!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2031#issuecomment-956275604
https://github.com/CliMA/Oceananigans.jl/issues/2034#issuecomment-1017688862:82,Availability,down,down,82,"I guess I more meant do we have reason to believe that trig functions slow things down 100x?. We use trig functions in the lat-lon grid without this issue for example, so it seems unlikely. If we're observing expected slow downs (perhaps up to 2-3x for an expensive trig function that's called often), then I don't think we need to keep this issue open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2034#issuecomment-1017688862
https://github.com/CliMA/Oceananigans.jl/issues/2034#issuecomment-1017688862:223,Availability,down,downs,223,"I guess I more meant do we have reason to believe that trig functions slow things down 100x?. We use trig functions in the lat-lon grid without this issue for example, so it seems unlikely. If we're observing expected slow downs (perhaps up to 2-3x for an expensive trig function that's called often), then I don't think we need to keep this issue open.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2034#issuecomment-1017688862
https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-958102800:1785,Availability,failure,failure,1785,"Very nice @simone-silvestri . I think we have to regenerate the ocean LES regression test data. Unfortunately this regression test doesn't use `DataDeps` yet so regenerating it will increase the size of the repo by a little bit. Another option is to refactor the regression tests to use DataDeps but this might be best saved for a future PR. I think this fix may actually resolve some ancient issues that we didn't understand until now, for example:. https://github.com/CliMA/Oceananigans.jl/issues/1179. To summarize:. When running a model that has both `Periodic` and `Bounded` directions, _and_ when using a stencil that touches corner points (such as with `coriolis isa FPlane`, the order in which halos are filled matters. In particular, we must fill periodic directions _last_, because the corners then depend on a halo point which is just outside the boundary in the `Bounded` direction(s). The ocean large eddy simulation regression test is one such case (horizontally-periodic, bounded in z). There is a no-flux surface velocity boundary condition that creates a dependency between the bounded and periodic halo fills. The previous algorithm assumed that all halos could be filled simultaneously with no dependencies on one another. However, because the CPU is serial the halos were nevertheless filled in the ordering prescribed by `fill_halo_regions!`:. https://github.com/CliMA/Oceananigans.jl/blob/2d6ccfe94ce2c68857f70b2f8839020049932e00/src/BoundaryConditions/fill_halo_regions.jl#L32-L42. In other words, the vertical halos (the bounded direction) are filled last on the CPU. On the GPU the ordering may change because on the GPU KernelAbstractions is no longer serial. Thus on occasion the periodic halos might have been filled _after_ the bounded halos, leading to a failure of the regression test. This PR fixes that issue so that periodic directions are always filled last. So I think we should expect that regression tests fail on both the CPU and GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-958102800
https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-958102800:809,Integrability,depend,depend,809,"Very nice @simone-silvestri . I think we have to regenerate the ocean LES regression test data. Unfortunately this regression test doesn't use `DataDeps` yet so regenerating it will increase the size of the repo by a little bit. Another option is to refactor the regression tests to use DataDeps but this might be best saved for a future PR. I think this fix may actually resolve some ancient issues that we didn't understand until now, for example:. https://github.com/CliMA/Oceananigans.jl/issues/1179. To summarize:. When running a model that has both `Periodic` and `Bounded` directions, _and_ when using a stencil that touches corner points (such as with `coriolis isa FPlane`, the order in which halos are filled matters. In particular, we must fill periodic directions _last_, because the corners then depend on a halo point which is just outside the boundary in the `Bounded` direction(s). The ocean large eddy simulation regression test is one such case (horizontally-periodic, bounded in z). There is a no-flux surface velocity boundary condition that creates a dependency between the bounded and periodic halo fills. The previous algorithm assumed that all halos could be filled simultaneously with no dependencies on one another. However, because the CPU is serial the halos were nevertheless filled in the ordering prescribed by `fill_halo_regions!`:. https://github.com/CliMA/Oceananigans.jl/blob/2d6ccfe94ce2c68857f70b2f8839020049932e00/src/BoundaryConditions/fill_halo_regions.jl#L32-L42. In other words, the vertical halos (the bounded direction) are filled last on the CPU. On the GPU the ordering may change because on the GPU KernelAbstractions is no longer serial. Thus on occasion the periodic halos might have been filled _after_ the bounded halos, leading to a failure of the regression test. This PR fixes that issue so that periodic directions are always filled last. So I think we should expect that regression tests fail on both the CPU and GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-958102800
https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-958102800:1072,Integrability,depend,dependency,1072,"Very nice @simone-silvestri . I think we have to regenerate the ocean LES regression test data. Unfortunately this regression test doesn't use `DataDeps` yet so regenerating it will increase the size of the repo by a little bit. Another option is to refactor the regression tests to use DataDeps but this might be best saved for a future PR. I think this fix may actually resolve some ancient issues that we didn't understand until now, for example:. https://github.com/CliMA/Oceananigans.jl/issues/1179. To summarize:. When running a model that has both `Periodic` and `Bounded` directions, _and_ when using a stencil that touches corner points (such as with `coriolis isa FPlane`, the order in which halos are filled matters. In particular, we must fill periodic directions _last_, because the corners then depend on a halo point which is just outside the boundary in the `Bounded` direction(s). The ocean large eddy simulation regression test is one such case (horizontally-periodic, bounded in z). There is a no-flux surface velocity boundary condition that creates a dependency between the bounded and periodic halo fills. The previous algorithm assumed that all halos could be filled simultaneously with no dependencies on one another. However, because the CPU is serial the halos were nevertheless filled in the ordering prescribed by `fill_halo_regions!`:. https://github.com/CliMA/Oceananigans.jl/blob/2d6ccfe94ce2c68857f70b2f8839020049932e00/src/BoundaryConditions/fill_halo_regions.jl#L32-L42. In other words, the vertical halos (the bounded direction) are filled last on the CPU. On the GPU the ordering may change because on the GPU KernelAbstractions is no longer serial. Thus on occasion the periodic halos might have been filled _after_ the bounded halos, leading to a failure of the regression test. This PR fixes that issue so that periodic directions are always filled last. So I think we should expect that regression tests fail on both the CPU and GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-958102800
https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-958102800:1213,Integrability,depend,dependencies,1213,"Very nice @simone-silvestri . I think we have to regenerate the ocean LES regression test data. Unfortunately this regression test doesn't use `DataDeps` yet so regenerating it will increase the size of the repo by a little bit. Another option is to refactor the regression tests to use DataDeps but this might be best saved for a future PR. I think this fix may actually resolve some ancient issues that we didn't understand until now, for example:. https://github.com/CliMA/Oceananigans.jl/issues/1179. To summarize:. When running a model that has both `Periodic` and `Bounded` directions, _and_ when using a stencil that touches corner points (such as with `coriolis isa FPlane`, the order in which halos are filled matters. In particular, we must fill periodic directions _last_, because the corners then depend on a halo point which is just outside the boundary in the `Bounded` direction(s). The ocean large eddy simulation regression test is one such case (horizontally-periodic, bounded in z). There is a no-flux surface velocity boundary condition that creates a dependency between the bounded and periodic halo fills. The previous algorithm assumed that all halos could be filled simultaneously with no dependencies on one another. However, because the CPU is serial the halos were nevertheless filled in the ordering prescribed by `fill_halo_regions!`:. https://github.com/CliMA/Oceananigans.jl/blob/2d6ccfe94ce2c68857f70b2f8839020049932e00/src/BoundaryConditions/fill_halo_regions.jl#L32-L42. In other words, the vertical halos (the bounded direction) are filled last on the CPU. On the GPU the ordering may change because on the GPU KernelAbstractions is no longer serial. Thus on occasion the periodic halos might have been filled _after_ the bounded halos, leading to a failure of the regression test. This PR fixes that issue so that periodic directions are always filled last. So I think we should expect that regression tests fail on both the CPU and GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-958102800
https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-958102800:250,Modifiability,refactor,refactor,250,"Very nice @simone-silvestri . I think we have to regenerate the ocean LES regression test data. Unfortunately this regression test doesn't use `DataDeps` yet so regenerating it will increase the size of the repo by a little bit. Another option is to refactor the regression tests to use DataDeps but this might be best saved for a future PR. I think this fix may actually resolve some ancient issues that we didn't understand until now, for example:. https://github.com/CliMA/Oceananigans.jl/issues/1179. To summarize:. When running a model that has both `Periodic` and `Bounded` directions, _and_ when using a stencil that touches corner points (such as with `coriolis isa FPlane`, the order in which halos are filled matters. In particular, we must fill periodic directions _last_, because the corners then depend on a halo point which is just outside the boundary in the `Bounded` direction(s). The ocean large eddy simulation regression test is one such case (horizontally-periodic, bounded in z). There is a no-flux surface velocity boundary condition that creates a dependency between the bounded and periodic halo fills. The previous algorithm assumed that all halos could be filled simultaneously with no dependencies on one another. However, because the CPU is serial the halos were nevertheless filled in the ordering prescribed by `fill_halo_regions!`:. https://github.com/CliMA/Oceananigans.jl/blob/2d6ccfe94ce2c68857f70b2f8839020049932e00/src/BoundaryConditions/fill_halo_regions.jl#L32-L42. In other words, the vertical halos (the bounded direction) are filled last on the CPU. On the GPU the ordering may change because on the GPU KernelAbstractions is no longer serial. Thus on occasion the periodic halos might have been filled _after_ the bounded halos, leading to a failure of the regression test. This PR fixes that issue so that periodic directions are always filled last. So I think we should expect that regression tests fail on both the CPU and GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-958102800
https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-958102800:85,Testability,test,test,85,"Very nice @simone-silvestri . I think we have to regenerate the ocean LES regression test data. Unfortunately this regression test doesn't use `DataDeps` yet so regenerating it will increase the size of the repo by a little bit. Another option is to refactor the regression tests to use DataDeps but this might be best saved for a future PR. I think this fix may actually resolve some ancient issues that we didn't understand until now, for example:. https://github.com/CliMA/Oceananigans.jl/issues/1179. To summarize:. When running a model that has both `Periodic` and `Bounded` directions, _and_ when using a stencil that touches corner points (such as with `coriolis isa FPlane`, the order in which halos are filled matters. In particular, we must fill periodic directions _last_, because the corners then depend on a halo point which is just outside the boundary in the `Bounded` direction(s). The ocean large eddy simulation regression test is one such case (horizontally-periodic, bounded in z). There is a no-flux surface velocity boundary condition that creates a dependency between the bounded and periodic halo fills. The previous algorithm assumed that all halos could be filled simultaneously with no dependencies on one another. However, because the CPU is serial the halos were nevertheless filled in the ordering prescribed by `fill_halo_regions!`:. https://github.com/CliMA/Oceananigans.jl/blob/2d6ccfe94ce2c68857f70b2f8839020049932e00/src/BoundaryConditions/fill_halo_regions.jl#L32-L42. In other words, the vertical halos (the bounded direction) are filled last on the CPU. On the GPU the ordering may change because on the GPU KernelAbstractions is no longer serial. Thus on occasion the periodic halos might have been filled _after_ the bounded halos, leading to a failure of the regression test. This PR fixes that issue so that periodic directions are always filled last. So I think we should expect that regression tests fail on both the CPU and GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-958102800
https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-958102800:126,Testability,test,test,126,"Very nice @simone-silvestri . I think we have to regenerate the ocean LES regression test data. Unfortunately this regression test doesn't use `DataDeps` yet so regenerating it will increase the size of the repo by a little bit. Another option is to refactor the regression tests to use DataDeps but this might be best saved for a future PR. I think this fix may actually resolve some ancient issues that we didn't understand until now, for example:. https://github.com/CliMA/Oceananigans.jl/issues/1179. To summarize:. When running a model that has both `Periodic` and `Bounded` directions, _and_ when using a stencil that touches corner points (such as with `coriolis isa FPlane`, the order in which halos are filled matters. In particular, we must fill periodic directions _last_, because the corners then depend on a halo point which is just outside the boundary in the `Bounded` direction(s). The ocean large eddy simulation regression test is one such case (horizontally-periodic, bounded in z). There is a no-flux surface velocity boundary condition that creates a dependency between the bounded and periodic halo fills. The previous algorithm assumed that all halos could be filled simultaneously with no dependencies on one another. However, because the CPU is serial the halos were nevertheless filled in the ordering prescribed by `fill_halo_regions!`:. https://github.com/CliMA/Oceananigans.jl/blob/2d6ccfe94ce2c68857f70b2f8839020049932e00/src/BoundaryConditions/fill_halo_regions.jl#L32-L42. In other words, the vertical halos (the bounded direction) are filled last on the CPU. On the GPU the ordering may change because on the GPU KernelAbstractions is no longer serial. Thus on occasion the periodic halos might have been filled _after_ the bounded halos, leading to a failure of the regression test. This PR fixes that issue so that periodic directions are always filled last. So I think we should expect that regression tests fail on both the CPU and GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-958102800
https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-958102800:274,Testability,test,tests,274,"Very nice @simone-silvestri . I think we have to regenerate the ocean LES regression test data. Unfortunately this regression test doesn't use `DataDeps` yet so regenerating it will increase the size of the repo by a little bit. Another option is to refactor the regression tests to use DataDeps but this might be best saved for a future PR. I think this fix may actually resolve some ancient issues that we didn't understand until now, for example:. https://github.com/CliMA/Oceananigans.jl/issues/1179. To summarize:. When running a model that has both `Periodic` and `Bounded` directions, _and_ when using a stencil that touches corner points (such as with `coriolis isa FPlane`, the order in which halos are filled matters. In particular, we must fill periodic directions _last_, because the corners then depend on a halo point which is just outside the boundary in the `Bounded` direction(s). The ocean large eddy simulation regression test is one such case (horizontally-periodic, bounded in z). There is a no-flux surface velocity boundary condition that creates a dependency between the bounded and periodic halo fills. The previous algorithm assumed that all halos could be filled simultaneously with no dependencies on one another. However, because the CPU is serial the halos were nevertheless filled in the ordering prescribed by `fill_halo_regions!`:. https://github.com/CliMA/Oceananigans.jl/blob/2d6ccfe94ce2c68857f70b2f8839020049932e00/src/BoundaryConditions/fill_halo_regions.jl#L32-L42. In other words, the vertical halos (the bounded direction) are filled last on the CPU. On the GPU the ordering may change because on the GPU KernelAbstractions is no longer serial. Thus on occasion the periodic halos might have been filled _after_ the bounded halos, leading to a failure of the regression test. This PR fixes that issue so that periodic directions are always filled last. So I think we should expect that regression tests fail on both the CPU and GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-958102800
https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-958102800:941,Testability,test,test,941,"Very nice @simone-silvestri . I think we have to regenerate the ocean LES regression test data. Unfortunately this regression test doesn't use `DataDeps` yet so regenerating it will increase the size of the repo by a little bit. Another option is to refactor the regression tests to use DataDeps but this might be best saved for a future PR. I think this fix may actually resolve some ancient issues that we didn't understand until now, for example:. https://github.com/CliMA/Oceananigans.jl/issues/1179. To summarize:. When running a model that has both `Periodic` and `Bounded` directions, _and_ when using a stencil that touches corner points (such as with `coriolis isa FPlane`, the order in which halos are filled matters. In particular, we must fill periodic directions _last_, because the corners then depend on a halo point which is just outside the boundary in the `Bounded` direction(s). The ocean large eddy simulation regression test is one such case (horizontally-periodic, bounded in z). There is a no-flux surface velocity boundary condition that creates a dependency between the bounded and periodic halo fills. The previous algorithm assumed that all halos could be filled simultaneously with no dependencies on one another. However, because the CPU is serial the halos were nevertheless filled in the ordering prescribed by `fill_halo_regions!`:. https://github.com/CliMA/Oceananigans.jl/blob/2d6ccfe94ce2c68857f70b2f8839020049932e00/src/BoundaryConditions/fill_halo_regions.jl#L32-L42. In other words, the vertical halos (the bounded direction) are filled last on the CPU. On the GPU the ordering may change because on the GPU KernelAbstractions is no longer serial. Thus on occasion the periodic halos might have been filled _after_ the bounded halos, leading to a failure of the regression test. This PR fixes that issue so that periodic directions are always filled last. So I think we should expect that regression tests fail on both the CPU and GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-958102800
https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-958102800:1811,Testability,test,test,1811,"Very nice @simone-silvestri . I think we have to regenerate the ocean LES regression test data. Unfortunately this regression test doesn't use `DataDeps` yet so regenerating it will increase the size of the repo by a little bit. Another option is to refactor the regression tests to use DataDeps but this might be best saved for a future PR. I think this fix may actually resolve some ancient issues that we didn't understand until now, for example:. https://github.com/CliMA/Oceananigans.jl/issues/1179. To summarize:. When running a model that has both `Periodic` and `Bounded` directions, _and_ when using a stencil that touches corner points (such as with `coriolis isa FPlane`, the order in which halos are filled matters. In particular, we must fill periodic directions _last_, because the corners then depend on a halo point which is just outside the boundary in the `Bounded` direction(s). The ocean large eddy simulation regression test is one such case (horizontally-periodic, bounded in z). There is a no-flux surface velocity boundary condition that creates a dependency between the bounded and periodic halo fills. The previous algorithm assumed that all halos could be filled simultaneously with no dependencies on one another. However, because the CPU is serial the halos were nevertheless filled in the ordering prescribed by `fill_halo_regions!`:. https://github.com/CliMA/Oceananigans.jl/blob/2d6ccfe94ce2c68857f70b2f8839020049932e00/src/BoundaryConditions/fill_halo_regions.jl#L32-L42. In other words, the vertical halos (the bounded direction) are filled last on the CPU. On the GPU the ordering may change because on the GPU KernelAbstractions is no longer serial. Thus on occasion the periodic halos might have been filled _after_ the bounded halos, leading to a failure of the regression test. This PR fixes that issue so that periodic directions are always filled last. So I think we should expect that regression tests fail on both the CPU and GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-958102800
https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-958102800:1938,Testability,test,tests,1938,"Very nice @simone-silvestri . I think we have to regenerate the ocean LES regression test data. Unfortunately this regression test doesn't use `DataDeps` yet so regenerating it will increase the size of the repo by a little bit. Another option is to refactor the regression tests to use DataDeps but this might be best saved for a future PR. I think this fix may actually resolve some ancient issues that we didn't understand until now, for example:. https://github.com/CliMA/Oceananigans.jl/issues/1179. To summarize:. When running a model that has both `Periodic` and `Bounded` directions, _and_ when using a stencil that touches corner points (such as with `coriolis isa FPlane`, the order in which halos are filled matters. In particular, we must fill periodic directions _last_, because the corners then depend on a halo point which is just outside the boundary in the `Bounded` direction(s). The ocean large eddy simulation regression test is one such case (horizontally-periodic, bounded in z). There is a no-flux surface velocity boundary condition that creates a dependency between the bounded and periodic halo fills. The previous algorithm assumed that all halos could be filled simultaneously with no dependencies on one another. However, because the CPU is serial the halos were nevertheless filled in the ordering prescribed by `fill_halo_regions!`:. https://github.com/CliMA/Oceananigans.jl/blob/2d6ccfe94ce2c68857f70b2f8839020049932e00/src/BoundaryConditions/fill_halo_regions.jl#L32-L42. In other words, the vertical halos (the bounded direction) are filled last on the CPU. On the GPU the ordering may change because on the GPU KernelAbstractions is no longer serial. Thus on occasion the periodic halos might have been filled _after_ the bounded halos, leading to a failure of the regression test. This PR fixes that issue so that periodic directions are always filled last. So I think we should expect that regression tests fail on both the CPU and GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-958102800
https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-959993354:27,Testability,benchmark,benchmarks,27,We should run some similar benchmarks as were run on #1923 to see if this change yields a speed up (or not).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-959993354
https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-961064605:5,Testability,benchmark,benchmarks,5,"Some benchmarks... ## On `main`. ```julia; julia> include(""benchmark_two_dimensional_models.jl""); [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; [ Info: Oceananigans will use 24 threads; [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 176.874 ms (66322 allocations: 23.79 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=1, Nz=256)...; 500.601 ms (111291 allocations: 276.81 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 320.139 ms (48245 allocations: 269.93 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 14.721 ms (36840 allocations: 12.11 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=1, Nz=256)...; 23.795 ms (40688 allocations: 12.18 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 17.219 ms (38055 allocations: 12.14 MiB); ```. ## This PR. ```julia; julia> include(""benchmark_two_dimensional_models.jl""); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 104.521 ms (77858 allocations: 25.03 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=1, Nz=256)...; 235.623 ms (120254 allocations: 26.49 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 137.914 ms (72488 allocations: 19.41 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 14.675 ms (37239 allocations: 11.65 MiB); [ Info: Benchmarking GPU(",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-961064605
https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-961064605:222,Testability,Benchmark,Benchmarking,222,"Some benchmarks... ## On `main`. ```julia; julia> include(""benchmark_two_dimensional_models.jl""); [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; [ Info: Oceananigans will use 24 threads; [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 176.874 ms (66322 allocations: 23.79 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=1, Nz=256)...; 500.601 ms (111291 allocations: 276.81 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 320.139 ms (48245 allocations: 269.93 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 14.721 ms (36840 allocations: 12.11 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=1, Nz=256)...; 23.795 ms (40688 allocations: 12.18 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 17.219 ms (38055 allocations: 12.14 MiB); ```. ## This PR. ```julia; julia> include(""benchmark_two_dimensional_models.jl""); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 104.521 ms (77858 allocations: 25.03 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=1, Nz=256)...; 235.623 ms (120254 allocations: 26.49 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 137.914 ms (72488 allocations: 19.41 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 14.675 ms (37239 allocations: 11.65 MiB); [ Info: Benchmarking GPU(",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-961064605
https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-961064605:390,Testability,Benchmark,Benchmarking,390,"Some benchmarks... ## On `main`. ```julia; julia> include(""benchmark_two_dimensional_models.jl""); [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; [ Info: Oceananigans will use 24 threads; [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 176.874 ms (66322 allocations: 23.79 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=1, Nz=256)...; 500.601 ms (111291 allocations: 276.81 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 320.139 ms (48245 allocations: 269.93 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 14.721 ms (36840 allocations: 12.11 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=1, Nz=256)...; 23.795 ms (40688 allocations: 12.18 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 17.219 ms (38055 allocations: 12.14 MiB); ```. ## This PR. ```julia; julia> include(""benchmark_two_dimensional_models.jl""); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 104.521 ms (77858 allocations: 25.03 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=1, Nz=256)...; 235.623 ms (120254 allocations: 26.49 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 137.914 ms (72488 allocations: 19.41 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 14.675 ms (37239 allocations: 11.65 MiB); [ Info: Benchmarking GPU(",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-961064605
https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-961064605:560,Testability,Benchmark,Benchmarking,560,"Some benchmarks... ## On `main`. ```julia; julia> include(""benchmark_two_dimensional_models.jl""); [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; [ Info: Oceananigans will use 24 threads; [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 176.874 ms (66322 allocations: 23.79 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=1, Nz=256)...; 500.601 ms (111291 allocations: 276.81 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 320.139 ms (48245 allocations: 269.93 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 14.721 ms (36840 allocations: 12.11 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=1, Nz=256)...; 23.795 ms (40688 allocations: 12.18 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 17.219 ms (38055 allocations: 12.14 MiB); ```. ## This PR. ```julia; julia> include(""benchmark_two_dimensional_models.jl""); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 104.521 ms (77858 allocations: 25.03 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=1, Nz=256)...; 235.623 ms (120254 allocations: 26.49 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 137.914 ms (72488 allocations: 19.41 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 14.675 ms (37239 allocations: 11.65 MiB); [ Info: Benchmarking GPU(",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-961064605
https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-961064605:729,Testability,Benchmark,Benchmarking,729,"Some benchmarks... ## On `main`. ```julia; julia> include(""benchmark_two_dimensional_models.jl""); [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; [ Info: Oceananigans will use 24 threads; [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 176.874 ms (66322 allocations: 23.79 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=1, Nz=256)...; 500.601 ms (111291 allocations: 276.81 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 320.139 ms (48245 allocations: 269.93 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 14.721 ms (36840 allocations: 12.11 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=1, Nz=256)...; 23.795 ms (40688 allocations: 12.18 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 17.219 ms (38055 allocations: 12.14 MiB); ```. ## This PR. ```julia; julia> include(""benchmark_two_dimensional_models.jl""); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 104.521 ms (77858 allocations: 25.03 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=1, Nz=256)...; 235.623 ms (120254 allocations: 26.49 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 137.914 ms (72488 allocations: 19.41 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 14.675 ms (37239 allocations: 11.65 MiB); [ Info: Benchmarking GPU(",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-961064605
https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-961064605:896,Testability,Benchmark,Benchmarking,896,"Some benchmarks... ## On `main`. ```julia; julia> include(""benchmark_two_dimensional_models.jl""); [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; [ Info: Oceananigans will use 24 threads; [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 176.874 ms (66322 allocations: 23.79 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=1, Nz=256)...; 500.601 ms (111291 allocations: 276.81 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 320.139 ms (48245 allocations: 269.93 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 14.721 ms (36840 allocations: 12.11 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=1, Nz=256)...; 23.795 ms (40688 allocations: 12.18 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 17.219 ms (38055 allocations: 12.14 MiB); ```. ## This PR. ```julia; julia> include(""benchmark_two_dimensional_models.jl""); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 104.521 ms (77858 allocations: 25.03 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=1, Nz=256)...; 235.623 ms (120254 allocations: 26.49 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 137.914 ms (72488 allocations: 19.41 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 14.675 ms (37239 allocations: 11.65 MiB); [ Info: Benchmarking GPU(",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-961064605
https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-961064605:1063,Testability,Benchmark,Benchmarking,1063,"mpiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; [ Info: Oceananigans will use 24 threads; [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 176.874 ms (66322 allocations: 23.79 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=1, Nz=256)...; 500.601 ms (111291 allocations: 276.81 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 320.139 ms (48245 allocations: 269.93 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 14.721 ms (36840 allocations: 12.11 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=1, Nz=256)...; 23.795 ms (40688 allocations: 12.18 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 17.219 ms (38055 allocations: 12.14 MiB); ```. ## This PR. ```julia; julia> include(""benchmark_two_dimensional_models.jl""); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 104.521 ms (77858 allocations: 25.03 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=1, Nz=256)...; 235.623 ms (120254 allocations: 26.49 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 137.914 ms (72488 allocations: 19.41 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 14.675 ms (37239 allocations: 11.65 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=1, Nz=256)...; 22.468 ms ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-961064605
https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-961064605:1312,Testability,Benchmark,Benchmarking,1312,"cations: 23.79 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=1, Nz=256)...; 500.601 ms (111291 allocations: 276.81 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 320.139 ms (48245 allocations: 269.93 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 14.721 ms (36840 allocations: 12.11 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=1, Nz=256)...; 23.795 ms (40688 allocations: 12.18 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 17.219 ms (38055 allocations: 12.14 MiB); ```. ## This PR. ```julia; julia> include(""benchmark_two_dimensional_models.jl""); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 104.521 ms (77858 allocations: 25.03 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=1, Nz=256)...; 235.623 ms (120254 allocations: 26.49 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 137.914 ms (72488 allocations: 19.41 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 14.675 ms (37239 allocations: 11.65 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=1, Nz=256)...; 22.468 ms (41731 allocations: 11.71 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 14.661 ms (37308 allocations: 11.65 MiB); ```. This PR makes substantial improvements on the C",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-961064605
https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-961064605:1480,Testability,Benchmark,Benchmarking,1480,"locations: 276.81 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 320.139 ms (48245 allocations: 269.93 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 14.721 ms (36840 allocations: 12.11 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=1, Nz=256)...; 23.795 ms (40688 allocations: 12.18 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 17.219 ms (38055 allocations: 12.14 MiB); ```. ## This PR. ```julia; julia> include(""benchmark_two_dimensional_models.jl""); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 104.521 ms (77858 allocations: 25.03 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=1, Nz=256)...; 235.623 ms (120254 allocations: 26.49 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 137.914 ms (72488 allocations: 19.41 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 14.675 ms (37239 allocations: 11.65 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=1, Nz=256)...; 22.468 ms (41731 allocations: 11.71 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 14.661 ms (37308 allocations: 11.65 MiB); ```. This PR makes substantial improvements on the CPU at 256^2 (all models are faster, and 2D models in xz or yz are more than 2x faster). For GPU I think the benchmark might need to be bigger (or smaller?!) to see di",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-961064605
https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-961064605:1649,Testability,Benchmark,Benchmarking,1649," 276.81 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 320.139 ms (48245 allocations: 269.93 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 14.721 ms (36840 allocations: 12.11 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=1, Nz=256)...; 23.795 ms (40688 allocations: 12.18 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 17.219 ms (38055 allocations: 12.14 MiB); ```. ## This PR. ```julia; julia> include(""benchmark_two_dimensional_models.jl""); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 104.521 ms (77858 allocations: 25.03 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=1, Nz=256)...; 235.623 ms (120254 allocations: 26.49 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 137.914 ms (72488 allocations: 19.41 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 14.675 ms (37239 allocations: 11.65 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=1, Nz=256)...; 22.468 ms (41731 allocations: 11.71 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 14.661 ms (37308 allocations: 11.65 MiB); ```. This PR makes substantial improvements on the CPU at 256^2 (all models are faster, and 2D models in xz or yz are more than 2x faster). For GPU I think the benchmark might need to be bigger (or smaller?!) to see differences.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-961064605
https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-961064605:1817,Testability,Benchmark,Benchmarking,1817," 276.81 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 320.139 ms (48245 allocations: 269.93 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 14.721 ms (36840 allocations: 12.11 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=1, Nz=256)...; 23.795 ms (40688 allocations: 12.18 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 17.219 ms (38055 allocations: 12.14 MiB); ```. ## This PR. ```julia; julia> include(""benchmark_two_dimensional_models.jl""); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 104.521 ms (77858 allocations: 25.03 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=1, Nz=256)...; 235.623 ms (120254 allocations: 26.49 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 137.914 ms (72488 allocations: 19.41 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 14.675 ms (37239 allocations: 11.65 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=1, Nz=256)...; 22.468 ms (41731 allocations: 11.71 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 14.661 ms (37308 allocations: 11.65 MiB); ```. This PR makes substantial improvements on the CPU at 256^2 (all models are faster, and 2D models in xz or yz are more than 2x faster). For GPU I think the benchmark might need to be bigger (or smaller?!) to see differences.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-961064605
https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-961064605:1984,Testability,Benchmark,Benchmarking,1984," 276.81 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 320.139 ms (48245 allocations: 269.93 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 14.721 ms (36840 allocations: 12.11 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=1, Nz=256)...; 23.795 ms (40688 allocations: 12.18 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 17.219 ms (38055 allocations: 12.14 MiB); ```. ## This PR. ```julia; julia> include(""benchmark_two_dimensional_models.jl""); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 104.521 ms (77858 allocations: 25.03 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=1, Nz=256)...; 235.623 ms (120254 allocations: 26.49 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 137.914 ms (72488 allocations: 19.41 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 14.675 ms (37239 allocations: 11.65 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=1, Nz=256)...; 22.468 ms (41731 allocations: 11.71 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 14.661 ms (37308 allocations: 11.65 MiB); ```. This PR makes substantial improvements on the CPU at 256^2 (all models are faster, and 2D models in xz or yz are more than 2x faster). For GPU I think the benchmark might need to be bigger (or smaller?!) to see differences.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-961064605
https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-961064605:2151,Testability,Benchmark,Benchmarking,2151," 276.81 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 320.139 ms (48245 allocations: 269.93 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 14.721 ms (36840 allocations: 12.11 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=1, Nz=256)...; 23.795 ms (40688 allocations: 12.18 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 17.219 ms (38055 allocations: 12.14 MiB); ```. ## This PR. ```julia; julia> include(""benchmark_two_dimensional_models.jl""); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 104.521 ms (77858 allocations: 25.03 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=1, Nz=256)...; 235.623 ms (120254 allocations: 26.49 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 137.914 ms (72488 allocations: 19.41 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 14.675 ms (37239 allocations: 11.65 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=1, Nz=256)...; 22.468 ms (41731 allocations: 11.71 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 14.661 ms (37308 allocations: 11.65 MiB); ```. This PR makes substantial improvements on the CPU at 256^2 (all models are faster, and 2D models in xz or yz are more than 2x faster). For GPU I think the benchmark might need to be bigger (or smaller?!) to see differences.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-961064605
https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-961064605:2470,Testability,benchmark,benchmark,2470," 276.81 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 320.139 ms (48245 allocations: 269.93 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 14.721 ms (36840 allocations: 12.11 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=1, Nz=256)...; 23.795 ms (40688 allocations: 12.18 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 17.219 ms (38055 allocations: 12.14 MiB); ```. ## This PR. ```julia; julia> include(""benchmark_two_dimensional_models.jl""); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 104.521 ms (77858 allocations: 25.03 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=1, Nz=256)...; 235.623 ms (120254 allocations: 26.49 MiB); [ Info: Benchmarking CPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 137.914 ms (72488 allocations: 19.41 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=256, Nz=1)...; 14.675 ms (37239 allocations: 11.65 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=256, Ny=1, Nz=256)...; 22.468 ms (41731 allocations: 11.71 MiB); [ Info: Benchmarking GPU() model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=256, Nz=256)...; 14.661 ms (37308 allocations: 11.65 MiB); ```. This PR makes substantial improvements on the CPU at 256^2 (all models are faster, and 2D models in xz or yz are more than 2x faster). For GPU I think the benchmark might need to be bigger (or smaller?!) to see differences.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-961064605
https://github.com/CliMA/Oceananigans.jl/issues/2037#issuecomment-958579038:193,Usability,simpl,simpler,193,"I never understood why a `CFL` object had to be pre-constructed, but I always assumed there was a good (probably GPU-related) reason for that. If there isn't, then I completely agree it's much simpler (without, I think, loss of functionality) to have it be two simple functions (advective and diffusive cfl). > is a hack that's not accurate (overly restrictive) on stretched grids. I think we can replace this with; > ```julia; > using Oceananigans.AbstractOperations: x, y, z; > ; > function cell_advection_timescale(grid, u, v, w); > arch = architecture(u); > ; > max_u_x = maximum(abs, u / x); > max_v_y = maximum(abs, v / y); > max_w_z = maximum(abs, w / z); > ; > return 1 / max(max_u_x, max_v_y, max_w_z); > end; > ```. I thought the reason we hadn't implemented the above is because it's slow to compute, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2037#issuecomment-958579038
https://github.com/CliMA/Oceananigans.jl/issues/2037#issuecomment-958579038:261,Usability,simpl,simple,261,"I never understood why a `CFL` object had to be pre-constructed, but I always assumed there was a good (probably GPU-related) reason for that. If there isn't, then I completely agree it's much simpler (without, I think, loss of functionality) to have it be two simple functions (advective and diffusive cfl). > is a hack that's not accurate (overly restrictive) on stretched grids. I think we can replace this with; > ```julia; > using Oceananigans.AbstractOperations: x, y, z; > ; > function cell_advection_timescale(grid, u, v, w); > arch = architecture(u); > ; > max_u_x = maximum(abs, u / x); > max_v_y = maximum(abs, v / y); > max_w_z = maximum(abs, w / z); > ; > return 1 / max(max_u_x, max_v_y, max_w_z); > end; > ```. I thought the reason we hadn't implemented the above is because it's slow to compute, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2037#issuecomment-958579038
https://github.com/CliMA/Oceananigans.jl/issues/2037#issuecomment-958584552:228,Performance,perform,performance,228,"> I never understood why a `CFL` object had to be pre-constructed, but I always assumed there was a good (probably GPU-related) reason for that. I guess it's helpful if we have competing functions for computing time-scales (for performance reasons). But if we have just one fast function then it doesn't seem like there's a good reason.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2037#issuecomment-958584552
https://github.com/CliMA/Oceananigans.jl/issues/2037#issuecomment-958585293:231,Integrability,interface,interface,231,"> If it's slow, that's because of some implementation issue rather than an intrinsic reason. We _should_ be able to do fast reductions of abstract operations. Then I see no reason not to pursue the proposed changes :). On the user interface side: I believe ""diffusive CFL"" isn't quite correct, since the Courant-Friedrichs-Lewy condition is the advective one. (Although I agree that ""diffusive CFL"" is pretty easy to understand and intuitive.) Should we try to come up with a different name?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2037#issuecomment-958585293
https://github.com/CliMA/Oceananigans.jl/issues/2037#issuecomment-958585293:432,Usability,intuit,intuitive,432,"> If it's slow, that's because of some implementation issue rather than an intrinsic reason. We _should_ be able to do fast reductions of abstract operations. Then I see no reason not to pursue the proposed changes :). On the user interface side: I believe ""diffusive CFL"" isn't quite correct, since the Courant-Friedrichs-Lewy condition is the advective one. (Although I agree that ""diffusive CFL"" is pretty easy to understand and intuitive.) Should we try to come up with a different name?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2037#issuecomment-958585293
https://github.com/CliMA/Oceananigans.jl/issues/2037#issuecomment-958994106:1484,Performance,cache,cache,1484,"Some of the lessons over on https://github.com/CliMA/Oceananigans.jl/issues/2024 could warrant using an object after all. The reason is a bit technical... but because of how the compiler works, we have. ```julia; julia> using Oceananigans.AbstractOperations: x. julia> using Oceananigans. julia> grid = RegularRectilinearGrid(size=(2, 2, 2), extent=(1, 1, 1));. julia> u = XFaceField(grid);. julia> udx1 = u / x; BinaryOperation at (Face, Center, Center);  grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=2, Ny=2, Nz=2);   domain: x  [0.0, 1.0], y  [0.0, 1.0], z  [-1.0, 0.0];  tree: ; / at (Face, Center, Center);   Field located at (Face, Center, Center);   x at (Face, Center, Center). julia> udx2 = u / x; BinaryOperation at (Face, Center, Center);  grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=2, Ny=2, Nz=2);   domain: x  [0.0, 1.0], y  [0.0, 1.0], z  [-1.0, 0.0];  tree: ; / at (Face, Center, Center);   Field located at (Face, Center, Center);   x at (Face, Center, Center). julia> udx1 === udx2; false; ```. The reason we get different types is because of the different ""identity"" functions introduced in. https://github.com/CliMA/Oceananigans.jl/blob/6dcf6ffd1fdb2febaf0d20dfab85ef1d3f83d758/src/Operators/interpolation_utils.jl#L29-L66. which we do to avoid the compiler from detecting recursion during compilation. A few things to digest here but basically we want to cache the operations `u / x`, etc because reforming them for every calculation may incur high compilation costs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2037#issuecomment-958994106
https://github.com/CliMA/Oceananigans.jl/issues/2037#issuecomment-958994106:1367,Safety,avoid,avoid,1367,"Some of the lessons over on https://github.com/CliMA/Oceananigans.jl/issues/2024 could warrant using an object after all. The reason is a bit technical... but because of how the compiler works, we have. ```julia; julia> using Oceananigans.AbstractOperations: x. julia> using Oceananigans. julia> grid = RegularRectilinearGrid(size=(2, 2, 2), extent=(1, 1, 1));. julia> u = XFaceField(grid);. julia> udx1 = u / x; BinaryOperation at (Face, Center, Center);  grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=2, Ny=2, Nz=2);   domain: x  [0.0, 1.0], y  [0.0, 1.0], z  [-1.0, 0.0];  tree: ; / at (Face, Center, Center);   Field located at (Face, Center, Center);   x at (Face, Center, Center). julia> udx2 = u / x; BinaryOperation at (Face, Center, Center);  grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=2, Ny=2, Nz=2);   domain: x  [0.0, 1.0], y  [0.0, 1.0], z  [-1.0, 0.0];  tree: ; / at (Face, Center, Center);   Field located at (Face, Center, Center);   x at (Face, Center, Center). julia> udx1 === udx2; false; ```. The reason we get different types is because of the different ""identity"" functions introduced in. https://github.com/CliMA/Oceananigans.jl/blob/6dcf6ffd1fdb2febaf0d20dfab85ef1d3f83d758/src/Operators/interpolation_utils.jl#L29-L66. which we do to avoid the compiler from detecting recursion during compilation. A few things to digest here but basically we want to cache the operations `u / x`, etc because reforming them for every calculation may incur high compilation costs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2037#issuecomment-958994106
https://github.com/CliMA/Oceananigans.jl/issues/2037#issuecomment-958994106:1391,Safety,detect,detecting,1391,"Some of the lessons over on https://github.com/CliMA/Oceananigans.jl/issues/2024 could warrant using an object after all. The reason is a bit technical... but because of how the compiler works, we have. ```julia; julia> using Oceananigans.AbstractOperations: x. julia> using Oceananigans. julia> grid = RegularRectilinearGrid(size=(2, 2, 2), extent=(1, 1, 1));. julia> u = XFaceField(grid);. julia> udx1 = u / x; BinaryOperation at (Face, Center, Center);  grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=2, Ny=2, Nz=2);   domain: x  [0.0, 1.0], y  [0.0, 1.0], z  [-1.0, 0.0];  tree: ; / at (Face, Center, Center);   Field located at (Face, Center, Center);   x at (Face, Center, Center). julia> udx2 = u / x; BinaryOperation at (Face, Center, Center);  grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=2, Ny=2, Nz=2);   domain: x  [0.0, 1.0], y  [0.0, 1.0], z  [-1.0, 0.0];  tree: ; / at (Face, Center, Center);   Field located at (Face, Center, Center);   x at (Face, Center, Center). julia> udx1 === udx2; false; ```. The reason we get different types is because of the different ""identity"" functions introduced in. https://github.com/CliMA/Oceananigans.jl/blob/6dcf6ffd1fdb2febaf0d20dfab85ef1d3f83d758/src/Operators/interpolation_utils.jl#L29-L66. which we do to avoid the compiler from detecting recursion during compilation. A few things to digest here but basically we want to cache the operations `u / x`, etc because reforming them for every calculation may incur high compilation costs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2037#issuecomment-958994106
https://github.com/CliMA/Oceananigans.jl/pull/2045#issuecomment-963566951:110,Performance,load,loading,110,"> The preview isn't showing for me. But we can fix any issues later, so I say merge away. Yeah, It's also not loading for me. It feels like whenever I try to check PR previews it's kinda hit or miss. I wonder if this is an issue with Documenter. But if you're okay with it, I'll merge it and we can fix any problems later.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2045#issuecomment-963566951
https://github.com/CliMA/Oceananigans.jl/pull/2045#issuecomment-963592320:119,Performance,load,loading,119,"> > The preview isn't showing for me. But we can fix any issues later, so I say merge away.; > ; > Yeah, It's also not loading for me. It feels like whenever I try to check PR previews it's kinda hit or miss. I wonder if this is an issue with Documenter.; > ; > But if you're okay with it, I'll merge it and we can fix any problems later. It looks like it works for PRs that I submit, but not others. It may have to do with repo privileges.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2045#issuecomment-963592320
https://github.com/CliMA/Oceananigans.jl/pull/2045#issuecomment-963656757:131,Performance,load,loading,131,"> > > The preview isn't showing for me. But we can fix any issues later, so I say merge away.; > > ; > > ; > > Yeah, It's also not loading for me. It feels like whenever I try to check PR previews it's kinda hit or miss. I wonder if this is an issue with Documenter.; > > But if you're okay with it, I'll merge it and we can fix any problems later.; > ; > It looks like it works for PRs that I submit, but not others. It may have to do with repo privileges. I think, for some reason whatsoever, the preview is not pushed just from the first commit. I think it's because there is a test whether that was a commit on a PR. And unless you first open the PR and then made the first commit that test returns false...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2045#issuecomment-963656757
https://github.com/CliMA/Oceananigans.jl/pull/2045#issuecomment-963656757:581,Testability,test,test,581,"> > > The preview isn't showing for me. But we can fix any issues later, so I say merge away.; > > ; > > ; > > Yeah, It's also not loading for me. It feels like whenever I try to check PR previews it's kinda hit or miss. I wonder if this is an issue with Documenter.; > > But if you're okay with it, I'll merge it and we can fix any problems later.; > ; > It looks like it works for PRs that I submit, but not others. It may have to do with repo privileges. I think, for some reason whatsoever, the preview is not pushed just from the first commit. I think it's because there is a test whether that was a commit on a PR. And unless you first open the PR and then made the first commit that test returns false...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2045#issuecomment-963656757
https://github.com/CliMA/Oceananigans.jl/pull/2045#issuecomment-963656757:690,Testability,test,test,690,"> > > The preview isn't showing for me. But we can fix any issues later, so I say merge away.; > > ; > > ; > > Yeah, It's also not loading for me. It feels like whenever I try to check PR previews it's kinda hit or miss. I wonder if this is an issue with Documenter.; > > But if you're okay with it, I'll merge it and we can fix any problems later.; > ; > It looks like it works for PRs that I submit, but not others. It may have to do with repo privileges. I think, for some reason whatsoever, the preview is not pushed just from the first commit. I think it's because there is a test whether that was a commit on a PR. And unless you first open the PR and then made the first commit that test returns false...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2045#issuecomment-963656757
https://github.com/CliMA/Oceananigans.jl/issues/2046#issuecomment-964616924:287,Energy Efficiency,allocate,allocated,287,"Yes! The `HydrostaticFreeSurfaceModel` constructor permits the kwarg `velocities = PrescribedVelocities()`. This can be used to prescribe velocity fields rather than solving for them directly. when `velocities isa PrescribedVelocities`, then neither prognostic fields nor tendencies are allocated the velocity fields or free surface. With the addition kwarg `tracer_advection=nothing`, then advection can be omitted, permitting the solution of a diffusion equation. This feature is not documented; it can only be found in a few `validation` cases such as. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/curvilinear_diffusion/spot_tracer_diffusion.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2046#issuecomment-964616924
https://github.com/CliMA/Oceananigans.jl/issues/2046#issuecomment-964616924:529,Security,validat,validation,529,"Yes! The `HydrostaticFreeSurfaceModel` constructor permits the kwarg `velocities = PrescribedVelocities()`. This can be used to prescribe velocity fields rather than solving for them directly. when `velocities isa PrescribedVelocities`, then neither prognostic fields nor tendencies are allocated the velocity fields or free surface. With the addition kwarg `tracer_advection=nothing`, then advection can be omitted, permitting the solution of a diffusion equation. This feature is not documented; it can only be found in a few `validation` cases such as. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/curvilinear_diffusion/spot_tracer_diffusion.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2046#issuecomment-964616924
https://github.com/CliMA/Oceananigans.jl/issues/2046#issuecomment-964616924:607,Security,validat,validation,607,"Yes! The `HydrostaticFreeSurfaceModel` constructor permits the kwarg `velocities = PrescribedVelocities()`. This can be used to prescribe velocity fields rather than solving for them directly. when `velocities isa PrescribedVelocities`, then neither prognostic fields nor tendencies are allocated the velocity fields or free surface. With the addition kwarg `tracer_advection=nothing`, then advection can be omitted, permitting the solution of a diffusion equation. This feature is not documented; it can only be found in a few `validation` cases such as. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/curvilinear_diffusion/spot_tracer_diffusion.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2046#issuecomment-964616924
https://github.com/CliMA/Oceananigans.jl/issues/2046#issuecomment-964617381:102,Security,validat,validation,102,The syntax is. https://github.com/CliMA/Oceananigans.jl/blob/057e25cea75a0da5e2e0f2328d39205ebaf2b0dc/validation/curvilinear_diffusion/spot_tracer_diffusion.jl#L24-L29. The infrastructure that supports this is in . https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/HydrostaticFreeSurfaceModels/prescribed_hydrostatic_velocity_fields.jl,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2046#issuecomment-964617381
https://github.com/CliMA/Oceananigans.jl/issues/2046#issuecomment-964617826:104,Security,validat,validation,104,"For a more complicated case on the cubed sphere, see https://github.com/CliMA/Oceananigans.jl/blob/main/validation/cubed_sphere_tracer_advection/cubed_sphere_tracer_advection.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2046#issuecomment-964617826
https://github.com/CliMA/Oceananigans.jl/issues/2047#issuecomment-1479901754:18,Testability,test,test,18,Pretty sure we do test closure tuples,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2047#issuecomment-1479901754
https://github.com/CliMA/Oceananigans.jl/pull/2048#issuecomment-968916615:5,Energy Efficiency,adapt,adaptations,5,Nice adaptations. I agree with modifying the NaNchecker as a stop criteria (which outputs also the NaN location). No need to have simulations timestepping with NaNs,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2048#issuecomment-968916615
https://github.com/CliMA/Oceananigans.jl/pull/2048#issuecomment-968916615:5,Modifiability,adapt,adaptations,5,Nice adaptations. I agree with modifying the NaNchecker as a stop criteria (which outputs also the NaN location). No need to have simulations timestepping with NaNs,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2048#issuecomment-968916615
https://github.com/CliMA/Oceananigans.jl/issues/2049#issuecomment-966423864:404,Integrability,depend,depend,404,"> In dealing with a stretched grid, don't we need these to depenend on the horizontal grid?. Not in general; without bathymetry we would only need this for three-dimensional curvilinearity. If we have only horizontal curvilinearity (as arises in a thin approximation to the spherical shell), then vertical spacing are independent of horizontal location. But as noted in this issue, vertical spacing *do* depend on horizontal location with an immersed boundary.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2049#issuecomment-966423864
https://github.com/CliMA/Oceananigans.jl/issues/2049#issuecomment-966735406:3825,Testability,test,test,3825,"e; -export zF, zC, z, z; +export zF, zC, z, z, z, z; export x, x, x, x; export y, y, y, y; export Ax, Ax, Ax, Ax, Ax, Ax, Ax, Ax; diff --git a/src/Operators/spacings_and_areas_and_volumes.jl b/src/Operators/spacings_and_areas_and_volumes.jl; index 8b7aaeb7..9988b320 100644; --- a/src/Operators/spacings_and_areas_and_volumes.jl; +++ b/src/Operators/spacings_and_areas_and_volumes.jl; @@ -46,6 +46,9 @@ The operators in this file fall into three categories:; @inline z(i, j, k, grid::RegularRectilinearGrid) = grid.z; @inline z(i, j, k, grid::VerticallyStretchedRectilinearGrid) = @inbounds grid.z[k]; ; +@inline z(i, j, k, grid::RegularRectilinearGrid) = grid.z; +@inline z(i, j, k, grid::VerticallyStretchedRectilinearGrid) = @inbounds grid.z[k]; +; #####; ##### ""Spacings"" in Flat directions for rectilinear grids.; ##### Here we dispatch all spacings to `one`. This abuse of notation; diff --git a/test/runtests.jl b/test/runtests.jl; index 246192f6..d9d520f0 100644; --- a/test/runtests.jl; +++ b/test/runtests.jl; @@ -131,6 +131,7 @@ group = get(ENV, ""TEST_GROUP"", :all) |> Symbol; include(""test_vertical_vorticity_field.jl""); include(""test_implicit_free_surface_solver.jl""); include(""test_hydrostatic_free_surface_immersed_boundaries_apply_surf_bc.jl""); + include(""test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl""); end; end; ; diff --git a/test/test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl b/test/test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl; new file mode 100644; index 00000000..5241929b; --- /dev/null; +++ b/test/test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl; @@ -0,0 +1,56 @@; +using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom; +using Oceananigans.TurbulenceClosures: VerticallyImplicitTimeDiscretization; +; +@testset ""Immersed boundaries with",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2049#issuecomment-966735406
https://github.com/CliMA/Oceananigans.jl/issues/2049#issuecomment-966735406:3844,Testability,test,test,3844,"+export zF, zC, z, z, z, z; export x, x, x, x; export y, y, y, y; export Ax, Ax, Ax, Ax, Ax, Ax, Ax, Ax; diff --git a/src/Operators/spacings_and_areas_and_volumes.jl b/src/Operators/spacings_and_areas_and_volumes.jl; index 8b7aaeb7..9988b320 100644; --- a/src/Operators/spacings_and_areas_and_volumes.jl; +++ b/src/Operators/spacings_and_areas_and_volumes.jl; @@ -46,6 +46,9 @@ The operators in this file fall into three categories:; @inline z(i, j, k, grid::RegularRectilinearGrid) = grid.z; @inline z(i, j, k, grid::VerticallyStretchedRectilinearGrid) = @inbounds grid.z[k]; ; +@inline z(i, j, k, grid::RegularRectilinearGrid) = grid.z; +@inline z(i, j, k, grid::VerticallyStretchedRectilinearGrid) = @inbounds grid.z[k]; +; #####; ##### ""Spacings"" in Flat directions for rectilinear grids.; ##### Here we dispatch all spacings to `one`. This abuse of notation; diff --git a/test/runtests.jl b/test/runtests.jl; index 246192f6..d9d520f0 100644; --- a/test/runtests.jl; +++ b/test/runtests.jl; @@ -131,6 +131,7 @@ group = get(ENV, ""TEST_GROUP"", :all) |> Symbol; include(""test_vertical_vorticity_field.jl""); include(""test_implicit_free_surface_solver.jl""); include(""test_hydrostatic_free_surface_immersed_boundaries_apply_surf_bc.jl""); + include(""test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl""); end; end; ; diff --git a/test/test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl b/test/test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl; new file mode 100644; index 00000000..5241929b; --- /dev/null; +++ b/test/test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl; @@ -0,0 +1,56 @@; +using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom; +using Oceananigans.TurbulenceClosures: VerticallyImplicitTimeDiscretization; +; +@testset ""Immersed boundaries with hydrostatic free surface models"" be",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2049#issuecomment-966735406
https://github.com/CliMA/Oceananigans.jl/issues/2049#issuecomment-966735406:3901,Testability,test,test,3901,"port x, x, x, x; export y, y, y, y; export Ax, Ax, Ax, Ax, Ax, Ax, Ax, Ax; diff --git a/src/Operators/spacings_and_areas_and_volumes.jl b/src/Operators/spacings_and_areas_and_volumes.jl; index 8b7aaeb7..9988b320 100644; --- a/src/Operators/spacings_and_areas_and_volumes.jl; +++ b/src/Operators/spacings_and_areas_and_volumes.jl; @@ -46,6 +46,9 @@ The operators in this file fall into three categories:; @inline z(i, j, k, grid::RegularRectilinearGrid) = grid.z; @inline z(i, j, k, grid::VerticallyStretchedRectilinearGrid) = @inbounds grid.z[k]; ; +@inline z(i, j, k, grid::RegularRectilinearGrid) = grid.z; +@inline z(i, j, k, grid::VerticallyStretchedRectilinearGrid) = @inbounds grid.z[k]; +; #####; ##### ""Spacings"" in Flat directions for rectilinear grids.; ##### Here we dispatch all spacings to `one`. This abuse of notation; diff --git a/test/runtests.jl b/test/runtests.jl; index 246192f6..d9d520f0 100644; --- a/test/runtests.jl; +++ b/test/runtests.jl; @@ -131,6 +131,7 @@ group = get(ENV, ""TEST_GROUP"", :all) |> Symbol; include(""test_vertical_vorticity_field.jl""); include(""test_implicit_free_surface_solver.jl""); include(""test_hydrostatic_free_surface_immersed_boundaries_apply_surf_bc.jl""); + include(""test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl""); end; end; ; diff --git a/test/test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl b/test/test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl; new file mode 100644; index 00000000..5241929b; --- /dev/null; +++ b/test/test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl; @@ -0,0 +1,56 @@; +using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom; +using Oceananigans.TurbulenceClosures: VerticallyImplicitTimeDiscretization; +; +@testset ""Immersed boundaries with hydrostatic free surface models"" begin; + @info ""Testing immersed boundaries vertic",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2049#issuecomment-966735406
https://github.com/CliMA/Oceananigans.jl/issues/2049#issuecomment-966735406:3925,Testability,test,test,3925,"; export y, y, y, y; export Ax, Ax, Ax, Ax, Ax, Ax, Ax, Ax; diff --git a/src/Operators/spacings_and_areas_and_volumes.jl b/src/Operators/spacings_and_areas_and_volumes.jl; index 8b7aaeb7..9988b320 100644; --- a/src/Operators/spacings_and_areas_and_volumes.jl; +++ b/src/Operators/spacings_and_areas_and_volumes.jl; @@ -46,6 +46,9 @@ The operators in this file fall into three categories:; @inline z(i, j, k, grid::RegularRectilinearGrid) = grid.z; @inline z(i, j, k, grid::VerticallyStretchedRectilinearGrid) = @inbounds grid.z[k]; ; +@inline z(i, j, k, grid::RegularRectilinearGrid) = grid.z; +@inline z(i, j, k, grid::VerticallyStretchedRectilinearGrid) = @inbounds grid.z[k]; +; #####; ##### ""Spacings"" in Flat directions for rectilinear grids.; ##### Here we dispatch all spacings to `one`. This abuse of notation; diff --git a/test/runtests.jl b/test/runtests.jl; index 246192f6..d9d520f0 100644; --- a/test/runtests.jl; +++ b/test/runtests.jl; @@ -131,6 +131,7 @@ group = get(ENV, ""TEST_GROUP"", :all) |> Symbol; include(""test_vertical_vorticity_field.jl""); include(""test_implicit_free_surface_solver.jl""); include(""test_hydrostatic_free_surface_immersed_boundaries_apply_surf_bc.jl""); + include(""test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl""); end; end; ; diff --git a/test/test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl b/test/test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl; new file mode 100644; index 00000000..5241929b; --- /dev/null; +++ b/test/test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl; @@ -0,0 +1,56 @@; +using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom; +using Oceananigans.TurbulenceClosures: VerticallyImplicitTimeDiscretization; +; +@testset ""Immersed boundaries with hydrostatic free surface models"" begin; + @info ""Testing immersed boundaries vertical integrals""; +; + for arch i",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2049#issuecomment-966735406
https://github.com/CliMA/Oceananigans.jl/issues/2049#issuecomment-966735406:4295,Testability,test,test,4295," this file fall into three categories:; @inline z(i, j, k, grid::RegularRectilinearGrid) = grid.z; @inline z(i, j, k, grid::VerticallyStretchedRectilinearGrid) = @inbounds grid.z[k]; ; +@inline z(i, j, k, grid::RegularRectilinearGrid) = grid.z; +@inline z(i, j, k, grid::VerticallyStretchedRectilinearGrid) = @inbounds grid.z[k]; +; #####; ##### ""Spacings"" in Flat directions for rectilinear grids.; ##### Here we dispatch all spacings to `one`. This abuse of notation; diff --git a/test/runtests.jl b/test/runtests.jl; index 246192f6..d9d520f0 100644; --- a/test/runtests.jl; +++ b/test/runtests.jl; @@ -131,6 +131,7 @@ group = get(ENV, ""TEST_GROUP"", :all) |> Symbol; include(""test_vertical_vorticity_field.jl""); include(""test_implicit_free_surface_solver.jl""); include(""test_hydrostatic_free_surface_immersed_boundaries_apply_surf_bc.jl""); + include(""test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl""); end; end; ; diff --git a/test/test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl b/test/test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl; new file mode 100644; index 00000000..5241929b; --- /dev/null; +++ b/test/test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl; @@ -0,0 +1,56 @@; +using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom; +using Oceananigans.TurbulenceClosures: VerticallyImplicitTimeDiscretization; +; +@testset ""Immersed boundaries with hydrostatic free surface models"" begin; + @info ""Testing immersed boundaries vertical integrals""; +; + for arch in archs; + Nx = 5; + Ny = 5; +; + # A spherical domain; + underlying_grid =; + RegularRectilinearGrid(size=(Nx, Ny, 3), extent=(Nx, Ny, 3), topology=(Periodic,Periodic,Bounded)); +; + B = [-3. for i=1:Nx, j=1:Ny ]; + B[2:Nx-1,2:Ny-1] .= [-2. for i=2:Nx-1, j=2:Ny-1 ]; + B[3:Nx-2,3:Ny-2] .= [-1. for i=3:Nx-2, j=3:Ny-2 ]; + grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(B)); ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2049#issuecomment-966735406
https://github.com/CliMA/Oceananigans.jl/issues/2049#issuecomment-966735406:4374,Testability,test,test,4374," = grid.z; @inline z(i, j, k, grid::VerticallyStretchedRectilinearGrid) = @inbounds grid.z[k]; ; +@inline z(i, j, k, grid::RegularRectilinearGrid) = grid.z; +@inline z(i, j, k, grid::VerticallyStretchedRectilinearGrid) = @inbounds grid.z[k]; +; #####; ##### ""Spacings"" in Flat directions for rectilinear grids.; ##### Here we dispatch all spacings to `one`. This abuse of notation; diff --git a/test/runtests.jl b/test/runtests.jl; index 246192f6..d9d520f0 100644; --- a/test/runtests.jl; +++ b/test/runtests.jl; @@ -131,6 +131,7 @@ group = get(ENV, ""TEST_GROUP"", :all) |> Symbol; include(""test_vertical_vorticity_field.jl""); include(""test_implicit_free_surface_solver.jl""); include(""test_hydrostatic_free_surface_immersed_boundaries_apply_surf_bc.jl""); + include(""test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl""); end; end; ; diff --git a/test/test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl b/test/test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl; new file mode 100644; index 00000000..5241929b; --- /dev/null; +++ b/test/test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl; @@ -0,0 +1,56 @@; +using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom; +using Oceananigans.TurbulenceClosures: VerticallyImplicitTimeDiscretization; +; +@testset ""Immersed boundaries with hydrostatic free surface models"" begin; + @info ""Testing immersed boundaries vertical integrals""; +; + for arch in archs; + Nx = 5; + Ny = 5; +; + # A spherical domain; + underlying_grid =; + RegularRectilinearGrid(size=(Nx, Ny, 3), extent=(Nx, Ny, 3), topology=(Periodic,Periodic,Bounded)); +; + B = [-3. for i=1:Nx, j=1:Ny ]; + B[2:Nx-1,2:Ny-1] .= [-2. for i=2:Nx-1, j=2:Ny-1 ]; + B[3:Nx-2,3:Ny-2] .= [-1. for i=3:Nx-2, j=3:Ny-2 ]; + grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(B)); +; + free_surface = ImplicitFreeSurface(gravitational_acceleration=0.1); +; + model = Hydros",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2049#issuecomment-966735406
https://github.com/CliMA/Oceananigans.jl/issues/2049#issuecomment-966735406:4521,Testability,test,test,4521,"::RegularRectilinearGrid) = grid.z; +@inline z(i, j, k, grid::VerticallyStretchedRectilinearGrid) = @inbounds grid.z[k]; +; #####; ##### ""Spacings"" in Flat directions for rectilinear grids.; ##### Here we dispatch all spacings to `one`. This abuse of notation; diff --git a/test/runtests.jl b/test/runtests.jl; index 246192f6..d9d520f0 100644; --- a/test/runtests.jl; +++ b/test/runtests.jl; @@ -131,6 +131,7 @@ group = get(ENV, ""TEST_GROUP"", :all) |> Symbol; include(""test_vertical_vorticity_field.jl""); include(""test_implicit_free_surface_solver.jl""); include(""test_hydrostatic_free_surface_immersed_boundaries_apply_surf_bc.jl""); + include(""test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl""); end; end; ; diff --git a/test/test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl b/test/test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl; new file mode 100644; index 00000000..5241929b; --- /dev/null; +++ b/test/test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl; @@ -0,0 +1,56 @@; +using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom; +using Oceananigans.TurbulenceClosures: VerticallyImplicitTimeDiscretization; +; +@testset ""Immersed boundaries with hydrostatic free surface models"" begin; + @info ""Testing immersed boundaries vertical integrals""; +; + for arch in archs; + Nx = 5; + Ny = 5; +; + # A spherical domain; + underlying_grid =; + RegularRectilinearGrid(size=(Nx, Ny, 3), extent=(Nx, Ny, 3), topology=(Periodic,Periodic,Bounded)); +; + B = [-3. for i=1:Nx, j=1:Ny ]; + B[2:Nx-1,2:Ny-1] .= [-2. for i=2:Nx-1, j=2:Ny-1 ]; + B[3:Nx-2,3:Ny-2] .= [-1. for i=3:Nx-2, j=3:Ny-2 ]; + grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(B)); +; + free_surface = ImplicitFreeSurface(gravitational_acceleration=0.1); +; + model = HydrostaticFreeSurfaceModel(grid = grid,; + architecture = arch,; + #free_surface = ExplicitFreeSurface(),; + #free_surface = ImplicitFreeSu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2049#issuecomment-966735406
https://github.com/CliMA/Oceananigans.jl/issues/2049#issuecomment-966735406:4780,Testability,test,testset,4780," +++ b/test/runtests.jl; @@ -131,6 +131,7 @@ group = get(ENV, ""TEST_GROUP"", :all) |> Symbol; include(""test_vertical_vorticity_field.jl""); include(""test_implicit_free_surface_solver.jl""); include(""test_hydrostatic_free_surface_immersed_boundaries_apply_surf_bc.jl""); + include(""test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl""); end; end; ; diff --git a/test/test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl b/test/test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl; new file mode 100644; index 00000000..5241929b; --- /dev/null; +++ b/test/test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl; @@ -0,0 +1,56 @@; +using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom; +using Oceananigans.TurbulenceClosures: VerticallyImplicitTimeDiscretization; +; +@testset ""Immersed boundaries with hydrostatic free surface models"" begin; + @info ""Testing immersed boundaries vertical integrals""; +; + for arch in archs; + Nx = 5; + Ny = 5; +; + # A spherical domain; + underlying_grid =; + RegularRectilinearGrid(size=(Nx, Ny, 3), extent=(Nx, Ny, 3), topology=(Periodic,Periodic,Bounded)); +; + B = [-3. for i=1:Nx, j=1:Ny ]; + B[2:Nx-1,2:Ny-1] .= [-2. for i=2:Nx-1, j=2:Ny-1 ]; + B[3:Nx-2,3:Ny-2] .= [-1. for i=3:Nx-2, j=3:Ny-2 ]; + grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(B)); +; + free_surface = ImplicitFreeSurface(gravitational_acceleration=0.1); +; + model = HydrostaticFreeSurfaceModel(grid = grid,; + architecture = arch,; + #free_surface = ExplicitFreeSurface(),; + #free_surface = ImplicitFreeSurface(maximum_iterations=10),; + free_surface = ImplicitFreeSurface(),; + momentum_advection = nothing,; + tracer_advection = WENO5(),; + coriolis = nothing,; + buoyancy = nothing,; + tracers = nothing,; + closure = nothing); +; + x_ref = [0.0 0.0 0.0 0.0 0.0 0.0 0.0; + 0.0 3.0 3.0 3.0 3.0 3.0 0.0; + 0.0 3.0 2.0 2.0 2.0 2.0 0.0; + 0.0 3.0 2.0 1.0 1.0 2.0 0.0; + 0.0 3.0 2.0",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2049#issuecomment-966735406
https://github.com/CliMA/Oceananigans.jl/issues/2049#issuecomment-966735406:4863,Testability,Test,Testing,4863," +++ b/test/runtests.jl; @@ -131,6 +131,7 @@ group = get(ENV, ""TEST_GROUP"", :all) |> Symbol; include(""test_vertical_vorticity_field.jl""); include(""test_implicit_free_surface_solver.jl""); include(""test_hydrostatic_free_surface_immersed_boundaries_apply_surf_bc.jl""); + include(""test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl""); end; end; ; diff --git a/test/test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl b/test/test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl; new file mode 100644; index 00000000..5241929b; --- /dev/null; +++ b/test/test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl; @@ -0,0 +1,56 @@; +using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom; +using Oceananigans.TurbulenceClosures: VerticallyImplicitTimeDiscretization; +; +@testset ""Immersed boundaries with hydrostatic free surface models"" begin; + @info ""Testing immersed boundaries vertical integrals""; +; + for arch in archs; + Nx = 5; + Ny = 5; +; + # A spherical domain; + underlying_grid =; + RegularRectilinearGrid(size=(Nx, Ny, 3), extent=(Nx, Ny, 3), topology=(Periodic,Periodic,Bounded)); +; + B = [-3. for i=1:Nx, j=1:Ny ]; + B[2:Nx-1,2:Ny-1] .= [-2. for i=2:Nx-1, j=2:Ny-1 ]; + B[3:Nx-2,3:Ny-2] .= [-1. for i=3:Nx-2, j=3:Ny-2 ]; + grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(B)); +; + free_surface = ImplicitFreeSurface(gravitational_acceleration=0.1); +; + model = HydrostaticFreeSurfaceModel(grid = grid,; + architecture = arch,; + #free_surface = ExplicitFreeSurface(),; + #free_surface = ImplicitFreeSurface(maximum_iterations=10),; + free_surface = ImplicitFreeSurface(),; + momentum_advection = nothing,; + tracer_advection = WENO5(),; + coriolis = nothing,; + buoyancy = nothing,; + tracers = nothing,; + closure = nothing); +; + x_ref = [0.0 0.0 0.0 0.0 0.0 0.0 0.0; + 0.0 3.0 3.0 3.0 3.0 3.0 0.0; + 0.0 3.0 2.0 2.0 2.0 2.0 0.0; + 0.0 3.0 2.0 1.0 1.0 2.0 0.0; + 0.0 3.0 2.0",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2049#issuecomment-966735406
https://github.com/CliMA/Oceananigans.jl/issues/2049#issuecomment-966735406:6486,Testability,test,test,6486,"st/test_hydrostatic_free_surface_immersed_boundaries_vertical_integrals.jl; @@ -0,0 +1,56 @@; +using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom; +using Oceananigans.TurbulenceClosures: VerticallyImplicitTimeDiscretization; +; +@testset ""Immersed boundaries with hydrostatic free surface models"" begin; + @info ""Testing immersed boundaries vertical integrals""; +; + for arch in archs; + Nx = 5; + Ny = 5; +; + # A spherical domain; + underlying_grid =; + RegularRectilinearGrid(size=(Nx, Ny, 3), extent=(Nx, Ny, 3), topology=(Periodic,Periodic,Bounded)); +; + B = [-3. for i=1:Nx, j=1:Ny ]; + B[2:Nx-1,2:Ny-1] .= [-2. for i=2:Nx-1, j=2:Ny-1 ]; + B[3:Nx-2,3:Ny-2] .= [-1. for i=3:Nx-2, j=3:Ny-2 ]; + grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(B)); +; + free_surface = ImplicitFreeSurface(gravitational_acceleration=0.1); +; + model = HydrostaticFreeSurfaceModel(grid = grid,; + architecture = arch,; + #free_surface = ExplicitFreeSurface(),; + #free_surface = ImplicitFreeSurface(maximum_iterations=10),; + free_surface = ImplicitFreeSurface(),; + momentum_advection = nothing,; + tracer_advection = WENO5(),; + coriolis = nothing,; + buoyancy = nothing,; + tracers = nothing,; + closure = nothing); +; + x_ref = [0.0 0.0 0.0 0.0 0.0 0.0 0.0; + 0.0 3.0 3.0 3.0 3.0 3.0 0.0; + 0.0 3.0 2.0 2.0 2.0 2.0 0.0; + 0.0 3.0 2.0 1.0 1.0 2.0 0.0; + 0.0 3.0 2.0 2.0 2.0 2.0 0.0; + 0.0 3.0 3.0 3.0 3.0 3.0 0.0; + 0.0 0.0 0.0 0.0 0.0 0.0 0.0]'; +; + y_ref = [0.0 0.0 0.0 0.0 0.0 0.0 0.0; + 0.0 3.0 3.0 3.0 3.0 3.0 0.0; + 0.0 3.0 2.0 2.0 2.0 3.0 0.0; + 0.0 3.0 2.0 1.0 2.0 3.0 0.0; + 0.0 3.0 2.0 1.0 2.0 3.0 0.0; + 0.0 3.0 2.0 2.0 2.0 3.0 0.0; + 0.0 0.0 0.0 0.0 0.0 0.0 0.0]'; +; + fs=model.free_surface; + xok=parent(fs.implicit_step_solver.vertically_integrated_lateral_areas.x.data[:,:,1])-x_ref == zeros(7,7); + yok=parent(fs.implicit_step_solver.vertically_integrated_lateral_areas.y.data[:,:,1])-y_ref == zeros(7,7); + @test (xok & yok); + end; +end; +; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2049#issuecomment-966735406
https://github.com/CliMA/Oceananigans.jl/issues/2049#issuecomment-966737027:203,Deployability,update,update,203,~~Do we want to define these metrics next to the other ones in the Operators module? We should use the existing function solid_node I think.~~. Edited to say that I think this is a good start and we can update all the operators in a future PR. It's probably best done after #2050.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2049#issuecomment-966737027
https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-966085231:10,Testability,test,tests,10,These two tests should be failing... https://github.com/CliMA/Oceananigans.jl/blob/77693f7d5dad1e5f8a90c13a2dcd13b8db2e1f71/test/test_rectilinear_grid.jl#L146-L147. Wait. Is `test_rectilinear_grid.jl` ever being called in tests? I'm bit confused...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-966085231
https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-966085231:124,Testability,test,test,124,These two tests should be failing... https://github.com/CliMA/Oceananigans.jl/blob/77693f7d5dad1e5f8a90c13a2dcd13b8db2e1f71/test/test_rectilinear_grid.jl#L146-L147. Wait. Is `test_rectilinear_grid.jl` ever being called in tests? I'm bit confused...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-966085231
https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-966085231:222,Testability,test,tests,222,These two tests should be failing... https://github.com/CliMA/Oceananigans.jl/blob/77693f7d5dad1e5f8a90c13a2dcd13b8db2e1f71/test/test_rectilinear_grid.jl#L146-L147. Wait. Is `test_rectilinear_grid.jl` ever being called in tests? I'm bit confused...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-966085231
https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-966165920:243,Availability,ERROR,ERROR,243,"ShallowWater example fails in docs. . ```julia; julia> simulation.output_writers[:fields] = NetCDFOutputWriter(model, (; , ),; filepath = joinpath(@__DIR__, ""shallow_water_Bickley_jet_fields.nc""),; schedule = TimeInterval(1),; mode = ""c""); ERROR: type StepRangeLen has no field parent; Stacktrace:; [1] getproperty(x::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, f::Symbol); @ Base ./Base.jl:33; [2] default_dimensions(output::Dict{String, ComputedField{Face, Face, Center, Oceananigans.Fields.FieldStatus{Float64}, O, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, RectilinearGrid{Float64, Periodic, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, CPU}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}} where O}, grid::RectilinearGrid{Float64, Periodic, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, CPU}, field_slicer::FieldSlicer{Colon, Colon, Colon}); @ Oceananigans.OutputWriters ~/Research/OC2/src/OutputWriters/netcdf_output_writer.jl:39; [3] NetCDFOutputWriter(model::ShallowWaterModel{RectilinearGrid{Float64, Periodic, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.Of",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-966165920
https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-966165920:201,Energy Efficiency,schedul,schedule,201,"ShallowWater example fails in docs. . ```julia; julia> simulation.output_writers[:fields] = NetCDFOutputWriter(model, (; , ),; filepath = joinpath(@__DIR__, ""shallow_water_Bickley_jet_fields.nc""),; schedule = TimeInterval(1),; mode = ""c""); ERROR: type StepRangeLen has no field parent; Stacktrace:; [1] getproperty(x::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, f::Symbol); @ Base ./Base.jl:33; [2] default_dimensions(output::Dict{String, ComputedField{Face, Face, Center, Oceananigans.Fields.FieldStatus{Float64}, O, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, RectilinearGrid{Float64, Periodic, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, CPU}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}} where O}, grid::RectilinearGrid{Float64, Periodic, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, CPU}, field_slicer::FieldSlicer{Colon, Colon, Colon}); @ Oceananigans.OutputWriters ~/Research/OC2/src/OutputWriters/netcdf_output_writer.jl:39; [3] NetCDFOutputWriter(model::ShallowWaterModel{RectilinearGrid{Float64, Periodic, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.Of",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-966165920
https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-966165920:24640,Energy Efficiency,schedul,schedule,24640,"erators.identity4), CPU, RectilinearGrid{Float64, Periodic, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, CPU}, Float64}, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, RectilinearGrid{Float64, Periodic, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}, CPU}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}}}; filepath::String, schedule::TimeInterval, array_type::Type{Array{Float32, N} where N}, field_slicer::FieldSlicer{Colon, Colon, Colon}, global_attributes::Dict{Any, Any}, output_attributes::Dict{Any, Any}, dimensions::Dict{Any, Any}, mode::String, compression::Int64, verbose::Bool); @ Oceananigans.OutputWriters ~/Research/OC2/src/OutputWriters/netcdf_output_writer.jl:319; [4] top-level scope; @ REPL[34]:1; ```. seems like this has something to do with. https://github.com/CliMA/Oceananigans.jl/blob/6df3e36f0bc8b0cbf7c075b235da678b8d035055/src/OutputWriters/netcdf_output_writer.jl#L39-L45. That's because of the z dimension. It follows that . https://github.com/CliMA/Oceananigans.jl/blob/6df3e36f0bc8b0cbf7c075b235da678b8d035055/src/Grids/grid_utils.jl#L162. returns a range and then `.parent()` is problematic.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-966165920
https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-966636899:197,Usability,clear,clear,197,"@simone-silvestri, I'm trying to understand how I build a stretched grid using the `RectilinearGrid` constructor. I can pass an array or function to, e.g., keyword argument `z = ...`. But it's not clear what would the constructor do. Will it take that array or function and construct the faces of `z` or the centers?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-966636899
https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-967118839:88,Testability,test,test,88,@navidcy you're right. That file is a left over from the previous PR. I was using it to test `RectilinearGrid` while `RegularRectilinearGrid` and `VerticallyStretchedRectilinearGrid` were still around. Now it is basically the same as `test_grids.jl`. I will delete it. Thanks for the cleanup by the way! The tests are passing now,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-967118839
https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-967118839:308,Testability,test,tests,308,@navidcy you're right. That file is a left over from the previous PR. I was using it to test `RectilinearGrid` while `RegularRectilinearGrid` and `VerticallyStretchedRectilinearGrid` were still around. Now it is basically the same as `test_grids.jl`. I will delete it. Thanks for the cleanup by the way! The tests are passing now,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-967118839
https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-967266791:38,Integrability,interface,interface,38,Note to self: we should figure out an interface to help users access grid metrics. We shouldn't write things like `grid.x` in the examples.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-967266791
https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-967266791:62,Security,access,access,62,Note to self: we should figure out an interface to help users access grid metrics. We shouldn't write things like `grid.x` in the examples.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-967266791
https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-967726417:40,Integrability,interface,interface,40,> Note to self: we should figure out an interface to help users access grid metrics. We shouldn't write things like `grid.x` in the examples. Yes yes yes!. Can we have alias?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-967726417
https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-967726417:64,Security,access,access,64,> Note to self: we should figure out an interface to help users access grid metrics. We shouldn't write things like `grid.x` in the examples. Yes yes yes!. Can we have alias?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-967726417
https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-967748805:42,Integrability,interface,interface,42,"> > Note to self: we should figure out an interface to help users access grid metrics. We shouldn't write things like `grid.x` in the examples.; > ; > Yes yes yes!; > ; > Can we have alias?. We need a function like `dx = grid_spacing(grid, 1)` or something which returns a number (if constant) or a field (if not).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-967748805
https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-967748805:66,Security,access,access,66,"> > Note to self: we should figure out an interface to help users access grid metrics. We shouldn't write things like `grid.x` in the examples.; > ; > Yes yes yes!; > ; > Can we have alias?. We need a function like `dx = grid_spacing(grid, 1)` or something which returns a number (if constant) or a field (if not).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-967748805
https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-969441050:47,Testability,test,tests,47,"@simone-silvestri it looks like the GPU solver tests and GPU regression tests now take about 4 hours. Is this right? Is there any way to speed it up? We could split the regression tests into multiple parts, perhaps. I think this might've been the last time our CI ran on the GPU...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-969441050
https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-969441050:72,Testability,test,tests,72,"@simone-silvestri it looks like the GPU solver tests and GPU regression tests now take about 4 hours. Is this right? Is there any way to speed it up? We could split the regression tests into multiple parts, perhaps. I think this might've been the last time our CI ran on the GPU...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-969441050
https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-969441050:180,Testability,test,tests,180,"@simone-silvestri it looks like the GPU solver tests and GPU regression tests now take about 4 hours. Is this right? Is there any way to speed it up? We could split the regression tests into multiple parts, perhaps. I think this might've been the last time our CI ran on the GPU...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-969441050
https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-970254433:195,Availability,down,down,195,"That cannot be true... The regression test should take around two hours, which yes is quite a lot and we should maybe split it into two... I don't know what is reason for the solver test to slow down, might it be because of the forced shutdown of saturday?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-970254433
https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-970254433:38,Testability,test,test,38,"That cannot be true... The regression test should take around two hours, which yes is quite a lot and we should maybe split it into two... I don't know what is reason for the solver test to slow down, might it be because of the forced shutdown of saturday?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-970254433
https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-970254433:182,Testability,test,test,182,"That cannot be true... The regression test should take around two hours, which yes is quite a lot and we should maybe split it into two... I don't know what is reason for the solver test to slow down, might it be because of the forced shutdown of saturday?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-970254433
https://github.com/CliMA/Oceananigans.jl/issues/2052#issuecomment-969400613:118,Deployability,Integrat,IntegrateField,118,"I would rather the first option (`avg_c = Field(Average(c, dims=1))`) because it avoids to have to code functions as `IntegrateField ....` and I think option option 1 is clearer than option 2 (you see that the average operation is applied to the fields c)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2052#issuecomment-969400613
https://github.com/CliMA/Oceananigans.jl/issues/2052#issuecomment-969400613:118,Integrability,Integrat,IntegrateField,118,"I would rather the first option (`avg_c = Field(Average(c, dims=1))`) because it avoids to have to code functions as `IntegrateField ....` and I think option option 1 is clearer than option 2 (you see that the average operation is applied to the fields c)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2052#issuecomment-969400613
https://github.com/CliMA/Oceananigans.jl/issues/2052#issuecomment-969400613:81,Safety,avoid,avoids,81,"I would rather the first option (`avg_c = Field(Average(c, dims=1))`) because it avoids to have to code functions as `IntegrateField ....` and I think option option 1 is clearer than option 2 (you see that the average operation is applied to the fields c)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2052#issuecomment-969400613
https://github.com/CliMA/Oceananigans.jl/issues/2052#issuecomment-969400613:170,Usability,clear,clearer,170,"I would rather the first option (`avg_c = Field(Average(c, dims=1))`) because it avoids to have to code functions as `IntegrateField ....` and I think option option 1 is clearer than option 2 (you see that the average operation is applied to the fields c)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2052#issuecomment-969400613
https://github.com/CliMA/Oceananigans.jl/pull/2055#issuecomment-966741761:324,Deployability,update,updates,324,"> I think we want to introduce this major change to operators in a separate PR right? We also have to change derivatives, abstract operations, and grid metric operations?. @glwagner separate PR is fine too. I haven't been keeping up with where definitive immersed_boundary bits are. It seemed like there were some important updates in global-lat-lon. I am not clear if it can be a PR against main, since main may be missing some immersed bc bits this uses. There are still some bits to work on after the bits in this PR, to get everything fully consistent. I am surprised things run as well as they do at the moment!! I think somehow we must end up with the bathymetry shifted a bit weird. It would be nice to fix, both implicit solve and split explicit are going to struggle I think without this patched up somehow.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2055#issuecomment-966741761
https://github.com/CliMA/Oceananigans.jl/pull/2055#issuecomment-966741761:797,Deployability,patch,patched,797,"> I think we want to introduce this major change to operators in a separate PR right? We also have to change derivatives, abstract operations, and grid metric operations?. @glwagner separate PR is fine too. I haven't been keeping up with where definitive immersed_boundary bits are. It seemed like there were some important updates in global-lat-lon. I am not clear if it can be a PR against main, since main may be missing some immersed bc bits this uses. There are still some bits to work on after the bits in this PR, to get everything fully consistent. I am surprised things run as well as they do at the moment!! I think somehow we must end up with the bathymetry shifted a bit weird. It would be nice to fix, both implicit solve and split explicit are going to struggle I think without this patched up somehow.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2055#issuecomment-966741761
https://github.com/CliMA/Oceananigans.jl/pull/2055#issuecomment-966741761:360,Usability,clear,clear,360,"> I think we want to introduce this major change to operators in a separate PR right? We also have to change derivatives, abstract operations, and grid metric operations?. @glwagner separate PR is fine too. I haven't been keeping up with where definitive immersed_boundary bits are. It seemed like there were some important updates in global-lat-lon. I am not clear if it can be a PR against main, since main may be missing some immersed bc bits this uses. There are still some bits to work on after the bits in this PR, to get everything fully consistent. I am surprised things run as well as they do at the moment!! I think somehow we must end up with the bathymetry shifted a bit weird. It would be nice to fix, both implicit solve and split explicit are going to struggle I think without this patched up somehow.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2055#issuecomment-966741761
https://github.com/CliMA/Oceananigans.jl/pull/2055#issuecomment-966743889:23,Deployability,patch,patch,23,"One can use your quick patch to see if it fixes the implicit solve, no problem. The bulk of the work needed to solve this issue is independent of immersed boundaries (eliminating usage of dz^aac etc in favor of new metrics everywhere in the code). This requires widespread changes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2055#issuecomment-966743889
https://github.com/CliMA/Oceananigans.jl/pull/2056#issuecomment-967178951:54,Usability,guid,guidelines,54,"I'm ok to advertise this. It seems maybe we need some guidelines about when to decide to document something. For practical purposes, we need to merge experimental features... My main uncertainty is that I don't know if this convective adjustment implementation is similar to the implementation in other ocean codes., but that definitely shouldn't prevent us from describe it in the docs. I'm not 100% happy with the implementation --- I want us to be able to prescribe a different diffusivity for each tracer (and I think we can get away with one fewer 3D array). That improvement would change the closure slightly, but it'd be easy to change the docs when we can do that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2056#issuecomment-967178951
https://github.com/CliMA/Oceananigans.jl/pull/2056#issuecomment-967752595:48,Energy Efficiency,efficient,efficient,48,"I vote we include it. Even if it's not the most efficient implementation, it's probably gonna be useful for some users. Also might prompt users to contribute if they see that the closure exists, but also see it has limitations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2056#issuecomment-967752595
https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-967762357:396,Integrability,depend,depending,396,"> We need a function like `dx = grid_spacing(grid, 1)` or something which returns a number (if constant) or a field (if not).; > ; > _Originally posted by @glwagner in [#2050 (comment)](https://github.com/CliMA/Oceananigans.jl/pull/2050#issuecomment-967748805)_. Wouldn't it be better to have something like `x = grid_spacing(model.velocities.v, 1)`? Because I'm assuming the `x` has to change depending if they want to use it on a quantity that lies on a `Face` or `Center` node in that direction. Maybe just `x = grid_spacing(Face, grid, 1)`, or something akin to the already-existing `nodes` function, that returns all 3 at the same time?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-967762357
https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-971713695:401,Modifiability,extend,extended,401,"It's mirroring Base julia, eg. ```julia; julia> a = rand(2, 3, 4); 234 Array{Float64, 3}:; [:, :, 1] =; 0.264469 0.977549 0.937297; 0.491955 0.710279 0.315507. [:, :, 2] =; 0.243796 0.783644 0.820073; 0.682626 0.351825 0.503396. [:, :, 3] =; 0.726912 0.287171 0.671998; 0.234873 0.993365 0.913062. [:, :, 4] =; 0.507489 0.568977 0.327032; 0.59475 0.547478 0.459589. julia> size(a, 3); 4; ```. We've extended `size` for fields, and `1, 2, 3` do currently correspond to the first, second, and third dimensions in that syntax. So I don't agree that it ""means nothing"", but perhaps we want something else for our API... I do agree that having named dimensions is a cool idea. I wonder if it'd be better to do this properly in the sense of #1700 or https://rafaqz.github.io/DimensionalData.jl/stable/course/#Dimensions-and-DimArrays rather than just providing functions like `size(c::AbstractField, :x)`...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-971713695
https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-1001101205:31,Deployability,update,update,31,"Just here to say that I had to update some code from using `grid.xC` to using `grid.x` which is more difficult to write, so I support a redesign or some more user-friendly way.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-1001101205
https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-1001101205:162,Usability,user-friendly,user-friendly,162,"Just here to say that I had to update some code from using `grid.xC` to using `grid.x` which is more difficult to write, so I support a redesign or some more user-friendly way.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-1001101205
https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-1328167384:232,Safety,avoid,avoid,232,"I propose. ```julia; xspacing(X, Y, Z, grid); yspacing(X, Y, Z, grid); zspacing(X, Y, Z, grid); ```. where `X, Y, Z` are all _instantiated_ locations eg. ```julia; x = xspacing(Center(), Center(), Center(), grid); ```. I propose we avoid ""one location"" versions that only work for rectilinear / lat-lon grids.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-1328167384
https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-1328277603:270,Safety,avoid,avoid,270,"> I propose; > ; > ```julia; > xspacing(X, Y, Z, grid); > yspacing(X, Y, Z, grid); > zspacing(X, Y, Z, grid); > ```; > ; > where `X, Y, Z` are all _instantiated_ locations eg; > ; > ```julia; > x = xspacing(Center(), Center(), Center(), grid); > ```; > ; > I propose we avoid ""one location"" versions that only work for rectilinear / lat-lon grids. I like this API. Although, since this is a user-facing function, I'd vote for us to have one-location methods defined only for grids that support it. Although I don't feel strongly about it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-1328277603
https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-1328371814:246,Integrability,depend,depends,246,"I'm wondering if we should abandon the one-location methods. They are convenient, but don't generalize well. They may not even generalize to all immersed boundary methods; for example even with simple `GridFittedBottom` the vertical grid spacing depends on horizontal locations. My thought is that the overall system is simpler and we avoid ""dialects"" if we are disciplined and always require all three locations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-1328371814
https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-1328371814:335,Safety,avoid,avoid,335,"I'm wondering if we should abandon the one-location methods. They are convenient, but don't generalize well. They may not even generalize to all immersed boundary methods; for example even with simple `GridFittedBottom` the vertical grid spacing depends on horizontal locations. My thought is that the overall system is simpler and we avoid ""dialects"" if we are disciplined and always require all three locations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-1328371814
https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-1328371814:194,Usability,simpl,simple,194,"I'm wondering if we should abandon the one-location methods. They are convenient, but don't generalize well. They may not even generalize to all immersed boundary methods; for example even with simple `GridFittedBottom` the vertical grid spacing depends on horizontal locations. My thought is that the overall system is simpler and we avoid ""dialects"" if we are disciplined and always require all three locations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-1328371814
https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-1328371814:320,Usability,simpl,simpler,320,"I'm wondering if we should abandon the one-location methods. They are convenient, but don't generalize well. They may not even generalize to all immersed boundary methods; for example even with simple `GridFittedBottom` the vertical grid spacing depends on horizontal locations. My thought is that the overall system is simpler and we avoid ""dialects"" if we are disciplined and always require all three locations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-1328371814
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-968980153:148,Security,validat,validation,148,"This is a great PR, thanks @simone-silvestri for putting it together!. There is a script [here ](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/advection/plot_rates_convergence_advection.jl)that computes the convergence rates fro the different advection schemes. Given your results I'm sure that replacing `WENO5` by your new new version, would give the same results. . But this script uses a uniform grid. Would it be of interest trying this with a streteched grid to see what order of convergence we get with the different schemes?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-968980153
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-968990386:760,Availability,error,error,760,"@tomchor this is the report from Shu deriving ENO coefficients for a finite volume scheme https://www3.nd.edu/~zxu2/acms60790S13/Shu-WENO-notes.pdf (In particular equation 2.20 which becomes equation 2.21 for uniform grids and reduces to the coefficient we used before) I can add some documentation on the WENO. . By the way, it would be quite easy to modify the type to include the order of the WENO scheme which we could change at will. What do you think? Would it be usefull to do that?. @francispoulin Cool! I'll check the convergence then. What I mean in the comments is that I use a Nonhydrostatic model which computes pressure and there is no infrastructure in Nonhydrostratic.jl for a pressure solver on a non-uniform horizontal grid (it will throw an error ""no method Pressuresolver(grid::RectilinearGrid)"". I maybe should change that test to an hydrostatic model...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-968990386
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-968990386:227,Energy Efficiency,reduce,reduces,227,"@tomchor this is the report from Shu deriving ENO coefficients for a finite volume scheme https://www3.nd.edu/~zxu2/acms60790S13/Shu-WENO-notes.pdf (In particular equation 2.20 which becomes equation 2.21 for uniform grids and reduces to the coefficient we used before) I can add some documentation on the WENO. . By the way, it would be quite easy to modify the type to include the order of the WENO scheme which we could change at will. What do you think? Would it be usefull to do that?. @francispoulin Cool! I'll check the convergence then. What I mean in the comments is that I use a Nonhydrostatic model which computes pressure and there is no infrastructure in Nonhydrostratic.jl for a pressure solver on a non-uniform horizontal grid (it will throw an error ""no method Pressuresolver(grid::RectilinearGrid)"". I maybe should change that test to an hydrostatic model...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-968990386
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-968990386:844,Testability,test,test,844,"@tomchor this is the report from Shu deriving ENO coefficients for a finite volume scheme https://www3.nd.edu/~zxu2/acms60790S13/Shu-WENO-notes.pdf (In particular equation 2.20 which becomes equation 2.21 for uniform grids and reduces to the coefficient we used before) I can add some documentation on the WENO. . By the way, it would be quite easy to modify the type to include the order of the WENO scheme which we could change at will. What do you think? Would it be usefull to do that?. @francispoulin Cool! I'll check the convergence then. What I mean in the comments is that I use a Nonhydrostatic model which computes pressure and there is no infrastructure in Nonhydrostratic.jl for a pressure solver on a non-uniform horizontal grid (it will throw an error ""no method Pressuresolver(grid::RectilinearGrid)"". I maybe should change that test to an hydrostatic model...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-968990386
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-969007656:553,Availability,error,error,553,"First, I think it would be great to have multi-order `WENO` advection, if it's not too difficult. Second, you can see an older version of the plot [here](https://github.com/CliMA/Oceananigans.jl/pull/1648). Since then we've added first order upwinding. I haven't tried running this for a while and hope it works but I guess I should try it and find out. I should point out that this script uses `ShallowWaterModel`. It is easy enough to change it for another of the two models, but I did see some odd behaviour. For `ShallowWaterModel` we have that the error goes down to 1e-14, basically machine precision and the slopes are what we should expect. When I tried this for `NonhydrostaticModel`, I found that the error didn't get any better than 1e-11 or so. I looked into this but never figured out why. The major difference between the two models is that `ShallowWater` does no thave a pressure solve, so I suspect that might be part of the problem. In the end I decided that the latter was probably the best way to test pure advection. But in retrospect, if we used `PrescribedVelocity`, then the pressure solve would not be a factor, and things should work out nicely.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-969007656
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-969007656:564,Availability,down,down,564,"First, I think it would be great to have multi-order `WENO` advection, if it's not too difficult. Second, you can see an older version of the plot [here](https://github.com/CliMA/Oceananigans.jl/pull/1648). Since then we've added first order upwinding. I haven't tried running this for a while and hope it works but I guess I should try it and find out. I should point out that this script uses `ShallowWaterModel`. It is easy enough to change it for another of the two models, but I did see some odd behaviour. For `ShallowWaterModel` we have that the error goes down to 1e-14, basically machine precision and the slopes are what we should expect. When I tried this for `NonhydrostaticModel`, I found that the error didn't get any better than 1e-11 or so. I looked into this but never figured out why. The major difference between the two models is that `ShallowWater` does no thave a pressure solve, so I suspect that might be part of the problem. In the end I decided that the latter was probably the best way to test pure advection. But in retrospect, if we used `PrescribedVelocity`, then the pressure solve would not be a factor, and things should work out nicely.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-969007656
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-969007656:711,Availability,error,error,711,"First, I think it would be great to have multi-order `WENO` advection, if it's not too difficult. Second, you can see an older version of the plot [here](https://github.com/CliMA/Oceananigans.jl/pull/1648). Since then we've added first order upwinding. I haven't tried running this for a while and hope it works but I guess I should try it and find out. I should point out that this script uses `ShallowWaterModel`. It is easy enough to change it for another of the two models, but I did see some odd behaviour. For `ShallowWaterModel` we have that the error goes down to 1e-14, basically machine precision and the slopes are what we should expect. When I tried this for `NonhydrostaticModel`, I found that the error didn't get any better than 1e-11 or so. I looked into this but never figured out why. The major difference between the two models is that `ShallowWater` does no thave a pressure solve, so I suspect that might be part of the problem. In the end I decided that the latter was probably the best way to test pure advection. But in retrospect, if we used `PrescribedVelocity`, then the pressure solve would not be a factor, and things should work out nicely.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-969007656
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-969007656:1016,Testability,test,test,1016,"First, I think it would be great to have multi-order `WENO` advection, if it's not too difficult. Second, you can see an older version of the plot [here](https://github.com/CliMA/Oceananigans.jl/pull/1648). Since then we've added first order upwinding. I haven't tried running this for a while and hope it works but I guess I should try it and find out. I should point out that this script uses `ShallowWaterModel`. It is easy enough to change it for another of the two models, but I did see some odd behaviour. For `ShallowWaterModel` we have that the error goes down to 1e-14, basically machine precision and the slopes are what we should expect. When I tried this for `NonhydrostaticModel`, I found that the error didn't get any better than 1e-11 or so. I looked into this but never figured out why. The major difference between the two models is that `ShallowWater` does no thave a pressure solve, so I suspect that might be part of the problem. In the end I decided that the latter was probably the best way to test pure advection. But in retrospect, if we used `PrescribedVelocity`, then the pressure solve would not be a factor, and things should work out nicely.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-969007656
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-969063314:40,Performance,perform,performance,40,"> Yeah sure, we can do it. ~~Is there a performance difference?~~. ~~The best solution might use dispatch to enable ""non-stretched WENO"" automatically when the grid has constant spacing.~~. After actually looking at the code, it seems this is what this PR does do, indeed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-969063314
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-969290093:468,Performance,perform,performance,468,"> By the way, i didn't use the scheme described in #1704 because it didn't give great results when implemented. I have implemented the ENO coefficients as derived before the assumption of uniform grid to the stencil interpolation (tomorrow I'll go back and check the report which describes them) . The smoothness functions are kept the same. That's interesting. Does that mean you were not able to reproduce the results reported in ""[A simple algorithm to improve the performance of the WENO scheme on non-uniform grids](https://link.springer.com/article/10.1007/s10409-017-0715-2)""?. > > By the way, it would be quite easy to modify the type to include the order of the WENO scheme which we could change at will. What do you think? Would it be usefull to do that?; > ; > If it's easy, then I definitely vote that we do that! A lower order, faster WENO scheme may be a good compromise between computational cost and accuracy. If that's true, we could use it as the default scheme for models. I think a higher order WENO scheme is more important than lower-order scheme. However, a low-order WENO method is proposed [here](https://link.springer.com/article/10.1007/s10915-020-01164-6). I think the 3rd order scheme may be quite diffusive and runs the risk of limiting to 1st order (?!). #995 attempts to implement nth order WENO but I think failed to achieve good CPU performance / compilation on the GPU. But @simone-silvestri perhaps you're able to achieve this?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-969290093
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-969290093:1367,Performance,perform,performance,1367,"> By the way, i didn't use the scheme described in #1704 because it didn't give great results when implemented. I have implemented the ENO coefficients as derived before the assumption of uniform grid to the stencil interpolation (tomorrow I'll go back and check the report which describes them) . The smoothness functions are kept the same. That's interesting. Does that mean you were not able to reproduce the results reported in ""[A simple algorithm to improve the performance of the WENO scheme on non-uniform grids](https://link.springer.com/article/10.1007/s10409-017-0715-2)""?. > > By the way, it would be quite easy to modify the type to include the order of the WENO scheme which we could change at will. What do you think? Would it be usefull to do that?; > ; > If it's easy, then I definitely vote that we do that! A lower order, faster WENO scheme may be a good compromise between computational cost and accuracy. If that's true, we could use it as the default scheme for models. I think a higher order WENO scheme is more important than lower-order scheme. However, a low-order WENO method is proposed [here](https://link.springer.com/article/10.1007/s10915-020-01164-6). I think the 3rd order scheme may be quite diffusive and runs the risk of limiting to 1st order (?!). #995 attempts to implement nth order WENO but I think failed to achieve good CPU performance / compilation on the GPU. But @simone-silvestri perhaps you're able to achieve this?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-969290093
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-969290093:1250,Safety,risk,risk,1250,"> By the way, i didn't use the scheme described in #1704 because it didn't give great results when implemented. I have implemented the ENO coefficients as derived before the assumption of uniform grid to the stencil interpolation (tomorrow I'll go back and check the report which describes them) . The smoothness functions are kept the same. That's interesting. Does that mean you were not able to reproduce the results reported in ""[A simple algorithm to improve the performance of the WENO scheme on non-uniform grids](https://link.springer.com/article/10.1007/s10409-017-0715-2)""?. > > By the way, it would be quite easy to modify the type to include the order of the WENO scheme which we could change at will. What do you think? Would it be usefull to do that?; > ; > If it's easy, then I definitely vote that we do that! A lower order, faster WENO scheme may be a good compromise between computational cost and accuracy. If that's true, we could use it as the default scheme for models. I think a higher order WENO scheme is more important than lower-order scheme. However, a low-order WENO method is proposed [here](https://link.springer.com/article/10.1007/s10915-020-01164-6). I think the 3rd order scheme may be quite diffusive and runs the risk of limiting to 1st order (?!). #995 attempts to implement nth order WENO but I think failed to achieve good CPU performance / compilation on the GPU. But @simone-silvestri perhaps you're able to achieve this?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-969290093
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-969290093:436,Usability,simpl,simple,436,"> By the way, i didn't use the scheme described in #1704 because it didn't give great results when implemented. I have implemented the ENO coefficients as derived before the assumption of uniform grid to the stencil interpolation (tomorrow I'll go back and check the report which describes them) . The smoothness functions are kept the same. That's interesting. Does that mean you were not able to reproduce the results reported in ""[A simple algorithm to improve the performance of the WENO scheme on non-uniform grids](https://link.springer.com/article/10.1007/s10409-017-0715-2)""?. > > By the way, it would be quite easy to modify the type to include the order of the WENO scheme which we could change at will. What do you think? Would it be usefull to do that?; > ; > If it's easy, then I definitely vote that we do that! A lower order, faster WENO scheme may be a good compromise between computational cost and accuracy. If that's true, we could use it as the default scheme for models. I think a higher order WENO scheme is more important than lower-order scheme. However, a low-order WENO method is proposed [here](https://link.springer.com/article/10.1007/s10915-020-01164-6). I think the 3rd order scheme may be quite diffusive and runs the risk of limiting to 1st order (?!). #995 attempts to implement nth order WENO but I think failed to achieve good CPU performance / compilation on the GPU. But @simone-silvestri perhaps you're able to achieve this?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-969290093
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-973179963:60,Deployability,update,update,60,I could have a look on this PR. @simone-silvestri could you update the first comment or is it reflecting what's in here?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-973179963
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-973228896:70,Deployability,update,update,70,"@navidcy I have changed a couple of settings. It's almost ready, I'll update in an hour or so",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-973228896
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974750814:205,Availability,down,down,205,"@simone-silvestri could you point me to a test/validation that confirms 1) that the changes of the PR didn't have an effect on regular grids. Also, a benchmark to see how this PR might have speedup/slowed down things? There were some benchmarks in the first comment when the PR was opened but many changes were pursued after. Should we repeat those benchmarks or something along those lines?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974750814
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974750814:47,Security,validat,validation,47,"@simone-silvestri could you point me to a test/validation that confirms 1) that the changes of the PR didn't have an effect on regular grids. Also, a benchmark to see how this PR might have speedup/slowed down things? There were some benchmarks in the first comment when the PR was opened but many changes were pursued after. Should we repeat those benchmarks or something along those lines?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974750814
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974750814:42,Testability,test,test,42,"@simone-silvestri could you point me to a test/validation that confirms 1) that the changes of the PR didn't have an effect on regular grids. Also, a benchmark to see how this PR might have speedup/slowed down things? There were some benchmarks in the first comment when the PR was opened but many changes were pursued after. Should we repeat those benchmarks or something along those lines?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974750814
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974750814:150,Testability,benchmark,benchmark,150,"@simone-silvestri could you point me to a test/validation that confirms 1) that the changes of the PR didn't have an effect on regular grids. Also, a benchmark to see how this PR might have speedup/slowed down things? There were some benchmarks in the first comment when the PR was opened but many changes were pursued after. Should we repeat those benchmarks or something along those lines?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974750814
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974750814:234,Testability,benchmark,benchmarks,234,"@simone-silvestri could you point me to a test/validation that confirms 1) that the changes of the PR didn't have an effect on regular grids. Also, a benchmark to see how this PR might have speedup/slowed down things? There were some benchmarks in the first comment when the PR was opened but many changes were pursued after. Should we repeat those benchmarks or something along those lines?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974750814
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974750814:349,Testability,benchmark,benchmarks,349,"@simone-silvestri could you point me to a test/validation that confirms 1) that the changes of the PR didn't have an effect on regular grids. Also, a benchmark to see how this PR might have speedup/slowed down things? There were some benchmarks in the first comment when the PR was opened but many changes were pursued after. Should we repeat those benchmarks or something along those lines?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974750814
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974843738:130,Energy Efficiency,adapt,adapted,130,"@navidcy Good call! ; You can find here below the output of benchmarks/benchmark_advection_schemes.jl ran on main and this PR and adapted to test the new methods.; For validation, you can run validation/advection/validate_weno_schemes.jl to validate the methods on a 1D and 2D advection problem for different grids; (uniform and stretched). execution of benchmark_advection_schemes.jl on main; ```; ;  Architectures  Schemes  min  median  mean  max  memory  allocs  samples ; ;  CPU  CenteredFourthOrder  1.779 s  1.789 s  1.794 s  1.814 s  1.05 MiB  1685  3 ;  CPU  CenteredSecondOrder  1.018 s  1.066 s  1.061 s  1.090 s  1.05 MiB  1685  5 ;  CPU  UpwindBiasedFifthOrder  2.467 s  2.505 s  2.505 s  2.544 s  1.05 MiB  1685  2 ;  CPU  UpwindBiasedThirdOrder  1.808 s  1.877 s  1.862 s  1.903 s  1.05 MiB  1685  3 ;  CPU  WENO5  6.775 s  6.775 s  6.775 s  6.775 s  1.05 MiB  1685  1 ;  GPU  CenteredFourthOrder  20.879 ms  20.970 ms  21.078 ms  21.874 ms  2.17 MiB  20610  10 ;  GPU  CenteredSecondOrder  11.402 ms  15.533 ms  15.138 ms  15.680 ms  2.05 MiB  13147  10 ;  GPU  UpwindBiasedFifthOrder  23.356 ms  23.498 ms  24.055 ms  29.246 ms  2.21 MiB  23281  10 ;  GPU  UpwindBiasedThirdOrder  18.863 ms  19.027 ms  19.298 ms  21.745 ms  2.12 MiB  17945  10 ;  GPU  WENO5  23.234 ms  28.467 ms  27.982 ms  28.684 ms  2.30 MiB  29259  10 ; ; ```; This PR same file, (WENO5 on uniform grids); ```; ;  Architec",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974843738
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974843738:5463,Energy Efficiency,efficient,efficient,5463,"llect(0:192), architecture = Arch()). if Scheme == :Uniform; scheme = WENO5(); elseif Scheme == :Stretched; scheme = WENO5(grid = grid); elseif Scheme == :StretchedSmoothness; scheme = WENO5(grid = grid, stretched_smoothness = true); elseif Scheme == :ZFormulation; scheme = WENO5(zweno = true); end; model = NonhydrostaticModel(architecture=Arch(), grid=grid, advection=scheme). time_step!(model, 1) # warmup. trial = @benchmark begin; @sync_gpu time_step!($model, 1); end samples=10. return trial; end. Schemes = (:Uniform, :Stretched, :StretchedSmoothness, :ZFormulation); ```; This PR, with a ""stretched"" vertical direction ; ```; ;  Architectures  Schemes  min  median  mean  max  memory  allocs  samples ; ;  CPU  Stretched  7.122 s  7.122 s  7.122 s  7.122 s  949.91 KiB  1716  1 ;  CPU  StretchedSmoothness  11.042 s  11.042 s  11.042 s  11.042 s  956.47 KiB  1716  1 ;  CPU  Uniform  6.373 s  6.373 s  6.373 s  6.373 s  945.38 KiB  1706  1 ;  CPU  ZFormulation  7.725 s  7.725 s  7.725 s  7.725 s  945.38 KiB  1706  1 ;  GPU  Stretched  25.646 ms  25.920 ms  26.501 ms  32.101 ms  2.15 MiB  30442  10 ;  GPU  StretchedSmoothness  109.080 ms  109.493 ms  109.676 ms  111.118 ms  3.78 MiB  134069  10 ;  GPU  Uniform  25.133 ms  25.394 ms  25.468 ms  26.710 ms  2.06 MiB  27799  10 ;  GPU  ZFormulation  30.554 ms  32.780 ms  32.569 ms  32.922 ms  2.20 MiB  37382  10 ; ; ```; Apparently on a much larger grid than what I tested, StretchedSmoothness is much less efficient, another reason to try to avoid it if not strictly necessary!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974843738
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974843738:130,Modifiability,adapt,adapted,130,"@navidcy Good call! ; You can find here below the output of benchmarks/benchmark_advection_schemes.jl ran on main and this PR and adapted to test the new methods.; For validation, you can run validation/advection/validate_weno_schemes.jl to validate the methods on a 1D and 2D advection problem for different grids; (uniform and stretched). execution of benchmark_advection_schemes.jl on main; ```; ;  Architectures  Schemes  min  median  mean  max  memory  allocs  samples ; ;  CPU  CenteredFourthOrder  1.779 s  1.789 s  1.794 s  1.814 s  1.05 MiB  1685  3 ;  CPU  CenteredSecondOrder  1.018 s  1.066 s  1.061 s  1.090 s  1.05 MiB  1685  5 ;  CPU  UpwindBiasedFifthOrder  2.467 s  2.505 s  2.505 s  2.544 s  1.05 MiB  1685  2 ;  CPU  UpwindBiasedThirdOrder  1.808 s  1.877 s  1.862 s  1.903 s  1.05 MiB  1685  3 ;  CPU  WENO5  6.775 s  6.775 s  6.775 s  6.775 s  1.05 MiB  1685  1 ;  GPU  CenteredFourthOrder  20.879 ms  20.970 ms  21.078 ms  21.874 ms  2.17 MiB  20610  10 ;  GPU  CenteredSecondOrder  11.402 ms  15.533 ms  15.138 ms  15.680 ms  2.05 MiB  13147  10 ;  GPU  UpwindBiasedFifthOrder  23.356 ms  23.498 ms  24.055 ms  29.246 ms  2.21 MiB  23281  10 ;  GPU  UpwindBiasedThirdOrder  18.863 ms  19.027 ms  19.298 ms  21.745 ms  2.12 MiB  17945  10 ;  GPU  WENO5  23.234 ms  28.467 ms  27.982 ms  28.684 ms  2.30 MiB  29259  10 ; ; ```; This PR same file, (WENO5 on uniform grids); ```; ;  Architec",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974843738
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974843738:5499,Safety,avoid,avoid,5499,"llect(0:192), architecture = Arch()). if Scheme == :Uniform; scheme = WENO5(); elseif Scheme == :Stretched; scheme = WENO5(grid = grid); elseif Scheme == :StretchedSmoothness; scheme = WENO5(grid = grid, stretched_smoothness = true); elseif Scheme == :ZFormulation; scheme = WENO5(zweno = true); end; model = NonhydrostaticModel(architecture=Arch(), grid=grid, advection=scheme). time_step!(model, 1) # warmup. trial = @benchmark begin; @sync_gpu time_step!($model, 1); end samples=10. return trial; end. Schemes = (:Uniform, :Stretched, :StretchedSmoothness, :ZFormulation); ```; This PR, with a ""stretched"" vertical direction ; ```; ;  Architectures  Schemes  min  median  mean  max  memory  allocs  samples ; ;  CPU  Stretched  7.122 s  7.122 s  7.122 s  7.122 s  949.91 KiB  1716  1 ;  CPU  StretchedSmoothness  11.042 s  11.042 s  11.042 s  11.042 s  956.47 KiB  1716  1 ;  CPU  Uniform  6.373 s  6.373 s  6.373 s  6.373 s  945.38 KiB  1706  1 ;  CPU  ZFormulation  7.725 s  7.725 s  7.725 s  7.725 s  945.38 KiB  1706  1 ;  GPU  Stretched  25.646 ms  25.920 ms  26.501 ms  32.101 ms  2.15 MiB  30442  10 ;  GPU  StretchedSmoothness  109.080 ms  109.493 ms  109.676 ms  111.118 ms  3.78 MiB  134069  10 ;  GPU  Uniform  25.133 ms  25.394 ms  25.468 ms  26.710 ms  2.06 MiB  27799  10 ;  GPU  ZFormulation  30.554 ms  32.780 ms  32.569 ms  32.922 ms  2.20 MiB  37382  10 ; ; ```; Apparently on a much larger grid than what I tested, StretchedSmoothness is much less efficient, another reason to try to avoid it if not strictly necessary!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974843738
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974843738:168,Security,validat,validation,168,"@navidcy Good call! ; You can find here below the output of benchmarks/benchmark_advection_schemes.jl ran on main and this PR and adapted to test the new methods.; For validation, you can run validation/advection/validate_weno_schemes.jl to validate the methods on a 1D and 2D advection problem for different grids; (uniform and stretched). execution of benchmark_advection_schemes.jl on main; ```; ;  Architectures  Schemes  min  median  mean  max  memory  allocs  samples ; ;  CPU  CenteredFourthOrder  1.779 s  1.789 s  1.794 s  1.814 s  1.05 MiB  1685  3 ;  CPU  CenteredSecondOrder  1.018 s  1.066 s  1.061 s  1.090 s  1.05 MiB  1685  5 ;  CPU  UpwindBiasedFifthOrder  2.467 s  2.505 s  2.505 s  2.544 s  1.05 MiB  1685  2 ;  CPU  UpwindBiasedThirdOrder  1.808 s  1.877 s  1.862 s  1.903 s  1.05 MiB  1685  3 ;  CPU  WENO5  6.775 s  6.775 s  6.775 s  6.775 s  1.05 MiB  1685  1 ;  GPU  CenteredFourthOrder  20.879 ms  20.970 ms  21.078 ms  21.874 ms  2.17 MiB  20610  10 ;  GPU  CenteredSecondOrder  11.402 ms  15.533 ms  15.138 ms  15.680 ms  2.05 MiB  13147  10 ;  GPU  UpwindBiasedFifthOrder  23.356 ms  23.498 ms  24.055 ms  29.246 ms  2.21 MiB  23281  10 ;  GPU  UpwindBiasedThirdOrder  18.863 ms  19.027 ms  19.298 ms  21.745 ms  2.12 MiB  17945  10 ;  GPU  WENO5  23.234 ms  28.467 ms  27.982 ms  28.684 ms  2.30 MiB  29259  10 ; ; ```; This PR same file, (WENO5 on uniform grids); ```; ;  Architec",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974843738
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974843738:192,Security,validat,validation,192,"@navidcy Good call! ; You can find here below the output of benchmarks/benchmark_advection_schemes.jl ran on main and this PR and adapted to test the new methods.; For validation, you can run validation/advection/validate_weno_schemes.jl to validate the methods on a 1D and 2D advection problem for different grids; (uniform and stretched). execution of benchmark_advection_schemes.jl on main; ```; ;  Architectures  Schemes  min  median  mean  max  memory  allocs  samples ; ;  CPU  CenteredFourthOrder  1.779 s  1.789 s  1.794 s  1.814 s  1.05 MiB  1685  3 ;  CPU  CenteredSecondOrder  1.018 s  1.066 s  1.061 s  1.090 s  1.05 MiB  1685  5 ;  CPU  UpwindBiasedFifthOrder  2.467 s  2.505 s  2.505 s  2.544 s  1.05 MiB  1685  2 ;  CPU  UpwindBiasedThirdOrder  1.808 s  1.877 s  1.862 s  1.903 s  1.05 MiB  1685  3 ;  CPU  WENO5  6.775 s  6.775 s  6.775 s  6.775 s  1.05 MiB  1685  1 ;  GPU  CenteredFourthOrder  20.879 ms  20.970 ms  21.078 ms  21.874 ms  2.17 MiB  20610  10 ;  GPU  CenteredSecondOrder  11.402 ms  15.533 ms  15.138 ms  15.680 ms  2.05 MiB  13147  10 ;  GPU  UpwindBiasedFifthOrder  23.356 ms  23.498 ms  24.055 ms  29.246 ms  2.21 MiB  23281  10 ;  GPU  UpwindBiasedThirdOrder  18.863 ms  19.027 ms  19.298 ms  21.745 ms  2.12 MiB  17945  10 ;  GPU  WENO5  23.234 ms  28.467 ms  27.982 ms  28.684 ms  2.30 MiB  29259  10 ; ; ```; This PR same file, (WENO5 on uniform grids); ```; ;  Architec",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974843738
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974843738:241,Security,validat,validate,241,"@navidcy Good call! ; You can find here below the output of benchmarks/benchmark_advection_schemes.jl ran on main and this PR and adapted to test the new methods.; For validation, you can run validation/advection/validate_weno_schemes.jl to validate the methods on a 1D and 2D advection problem for different grids; (uniform and stretched). execution of benchmark_advection_schemes.jl on main; ```; ;  Architectures  Schemes  min  median  mean  max  memory  allocs  samples ; ;  CPU  CenteredFourthOrder  1.779 s  1.789 s  1.794 s  1.814 s  1.05 MiB  1685  3 ;  CPU  CenteredSecondOrder  1.018 s  1.066 s  1.061 s  1.090 s  1.05 MiB  1685  5 ;  CPU  UpwindBiasedFifthOrder  2.467 s  2.505 s  2.505 s  2.544 s  1.05 MiB  1685  2 ;  CPU  UpwindBiasedThirdOrder  1.808 s  1.877 s  1.862 s  1.903 s  1.05 MiB  1685  3 ;  CPU  WENO5  6.775 s  6.775 s  6.775 s  6.775 s  1.05 MiB  1685  1 ;  GPU  CenteredFourthOrder  20.879 ms  20.970 ms  21.078 ms  21.874 ms  2.17 MiB  20610  10 ;  GPU  CenteredSecondOrder  11.402 ms  15.533 ms  15.138 ms  15.680 ms  2.05 MiB  13147  10 ;  GPU  UpwindBiasedFifthOrder  23.356 ms  23.498 ms  24.055 ms  29.246 ms  2.21 MiB  23281  10 ;  GPU  UpwindBiasedThirdOrder  18.863 ms  19.027 ms  19.298 ms  21.745 ms  2.12 MiB  17945  10 ;  GPU  WENO5  23.234 ms  28.467 ms  27.982 ms  28.684 ms  2.30 MiB  29259  10 ; ; ```; This PR same file, (WENO5 on uniform grids); ```; ;  Architec",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974843738
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974843738:60,Testability,benchmark,benchmarks,60,"@navidcy Good call! ; You can find here below the output of benchmarks/benchmark_advection_schemes.jl ran on main and this PR and adapted to test the new methods.; For validation, you can run validation/advection/validate_weno_schemes.jl to validate the methods on a 1D and 2D advection problem for different grids; (uniform and stretched). execution of benchmark_advection_schemes.jl on main; ```; ;  Architectures  Schemes  min  median  mean  max  memory  allocs  samples ; ;  CPU  CenteredFourthOrder  1.779 s  1.789 s  1.794 s  1.814 s  1.05 MiB  1685  3 ;  CPU  CenteredSecondOrder  1.018 s  1.066 s  1.061 s  1.090 s  1.05 MiB  1685  5 ;  CPU  UpwindBiasedFifthOrder  2.467 s  2.505 s  2.505 s  2.544 s  1.05 MiB  1685  2 ;  CPU  UpwindBiasedThirdOrder  1.808 s  1.877 s  1.862 s  1.903 s  1.05 MiB  1685  3 ;  CPU  WENO5  6.775 s  6.775 s  6.775 s  6.775 s  1.05 MiB  1685  1 ;  GPU  CenteredFourthOrder  20.879 ms  20.970 ms  21.078 ms  21.874 ms  2.17 MiB  20610  10 ;  GPU  CenteredSecondOrder  11.402 ms  15.533 ms  15.138 ms  15.680 ms  2.05 MiB  13147  10 ;  GPU  UpwindBiasedFifthOrder  23.356 ms  23.498 ms  24.055 ms  29.246 ms  2.21 MiB  23281  10 ;  GPU  UpwindBiasedThirdOrder  18.863 ms  19.027 ms  19.298 ms  21.745 ms  2.12 MiB  17945  10 ;  GPU  WENO5  23.234 ms  28.467 ms  27.982 ms  28.684 ms  2.30 MiB  29259  10 ; ; ```; This PR same file, (WENO5 on uniform grids); ```; ;  Architec",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974843738
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974843738:141,Testability,test,test,141,"@navidcy Good call! ; You can find here below the output of benchmarks/benchmark_advection_schemes.jl ran on main and this PR and adapted to test the new methods.; For validation, you can run validation/advection/validate_weno_schemes.jl to validate the methods on a 1D and 2D advection problem for different grids; (uniform and stretched). execution of benchmark_advection_schemes.jl on main; ```; ;  Architectures  Schemes  min  median  mean  max  memory  allocs  samples ; ;  CPU  CenteredFourthOrder  1.779 s  1.789 s  1.794 s  1.814 s  1.05 MiB  1685  3 ;  CPU  CenteredSecondOrder  1.018 s  1.066 s  1.061 s  1.090 s  1.05 MiB  1685  5 ;  CPU  UpwindBiasedFifthOrder  2.467 s  2.505 s  2.505 s  2.544 s  1.05 MiB  1685  2 ;  CPU  UpwindBiasedThirdOrder  1.808 s  1.877 s  1.862 s  1.903 s  1.05 MiB  1685  3 ;  CPU  WENO5  6.775 s  6.775 s  6.775 s  6.775 s  1.05 MiB  1685  1 ;  GPU  CenteredFourthOrder  20.879 ms  20.970 ms  21.078 ms  21.874 ms  2.17 MiB  20610  10 ;  GPU  CenteredSecondOrder  11.402 ms  15.533 ms  15.138 ms  15.680 ms  2.05 MiB  13147  10 ;  GPU  UpwindBiasedFifthOrder  23.356 ms  23.498 ms  24.055 ms  29.246 ms  2.21 MiB  23281  10 ;  GPU  UpwindBiasedThirdOrder  18.863 ms  19.027 ms  19.298 ms  21.745 ms  2.12 MiB  17945  10 ;  GPU  WENO5  23.234 ms  28.467 ms  27.982 ms  28.684 ms  2.30 MiB  29259  10 ; ; ```; This PR same file, (WENO5 on uniform grids); ```; ;  Architec",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974843738
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974843738:3292,Testability,test,test,3292,"6 s  1.05 MiB  1685  3 ;  CPU  CenteredSecondOrder  1.018 s  1.027 s  1.034 s  1.053 s  1.05 MiB  1685  5 ;  CPU  UpwindBiasedFifthOrder  2.335 s  2.339 s  2.343 s  2.353 s  1.05 MiB  1685  3 ;  CPU  UpwindBiasedThirdOrder  1.787 s  1.892 s  1.867 s  1.922 s  1.05 MiB  1685  3 ;  CPU  WENO5  6.935 s  6.935 s  6.935 s  6.935 s  1.05 MiB  1685  1 ;  GPU  CenteredFourthOrder  20.856 ms  21.016 ms  21.146 ms  22.351 ms  2.14 MiB  18750  10 ;  GPU  CenteredSecondOrder  11.201 ms  15.574 ms  15.175 ms  15.932 ms  2.05 MiB  13243  10 ;  GPU  UpwindBiasedFifthOrder  23.296 ms  23.514 ms  25.463 ms  43.065 ms  2.18 MiB  21868  10 ;  GPU  UpwindBiasedThirdOrder  18.859 ms  19.041 ms  19.338 ms  22.157 ms  2.10 MiB  16584  10 ;  GPU  WENO5  22.645 ms  28.377 ms  27.818 ms  28.571 ms  2.26 MiB  27075  10 ; ; ```; to test the new WENO methods on a stretched grid modify the code in benchmark_advection_schemes.jl as seen below. ```; function benchmark_advection_scheme(Arch, Scheme); grid = RectilinearGrid(size=(192, 192, 192), x = (0, 1), y = (0, 1), z = collect(0:192), architecture = Arch()). if Scheme == :Uniform; scheme = WENO5(); elseif Scheme == :Stretched; scheme = WENO5(grid = grid); elseif Scheme == :StretchedSmoothness; scheme = WENO5(grid = grid, stretched_smoothness = true); elseif Scheme == :ZFormulation; scheme = WENO5(zweno = true); end; model = NonhydrostaticModel(architecture=Arch(), grid=grid, advection=scheme). time_step!(model, 1) # warmup. trial = @benchmark begin; @sync_gpu time_step!($model, 1); end samples=10. return trial; end. Schemes = (:Uniform, :Stretched, :StretchedSmoothness, :ZFormulation); ```; This PR, with a ""stretched"" vertical direction ; ```; ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974843738
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974843738:3954,Testability,benchmark,benchmark,3954,"BiasedThirdOrder  18.859 ms  19.041 ms  19.338 ms  22.157 ms  2.10 MiB  16584  10 ;  GPU  WENO5  22.645 ms  28.377 ms  27.818 ms  28.571 ms  2.26 MiB  27075  10 ; ; ```; to test the new WENO methods on a stretched grid modify the code in benchmark_advection_schemes.jl as seen below. ```; function benchmark_advection_scheme(Arch, Scheme); grid = RectilinearGrid(size=(192, 192, 192), x = (0, 1), y = (0, 1), z = collect(0:192), architecture = Arch()). if Scheme == :Uniform; scheme = WENO5(); elseif Scheme == :Stretched; scheme = WENO5(grid = grid); elseif Scheme == :StretchedSmoothness; scheme = WENO5(grid = grid, stretched_smoothness = true); elseif Scheme == :ZFormulation; scheme = WENO5(zweno = true); end; model = NonhydrostaticModel(architecture=Arch(), grid=grid, advection=scheme). time_step!(model, 1) # warmup. trial = @benchmark begin; @sync_gpu time_step!($model, 1); end samples=10. return trial; end. Schemes = (:Uniform, :Stretched, :StretchedSmoothness, :ZFormulation); ```; This PR, with a ""stretched"" vertical direction ; ```; ;  Architectures  Schemes  min  median  mean  max  memory  allocs  samples ; ;  CPU  Stretched  7.122 s  7.122 s  7.122 s  7.122 s  949.91 KiB  1716  1 ;  CPU  StretchedSmoothness  11.042 s  11.042 s  11.042 s  11.042 s  956.47 KiB  1716  1 ;  CPU  Uniform  6.373 s  6.373 s  6.373 s  6.373 s  945.38 KiB  1706  1 ;  CPU  ZFormulation  7.725 s  7.725 s  7.725 s  7.725 s  945.38 KiB  1706  1 ;  GPU  Stretched  25.646 ms  25.920 ms  26.501 ms  32.101 ms  2.15 MiB  30442  10 ;  GPU  StretchedSmoothness  ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974843738
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974843738:5422,Testability,test,tested,5422,"llect(0:192), architecture = Arch()). if Scheme == :Uniform; scheme = WENO5(); elseif Scheme == :Stretched; scheme = WENO5(grid = grid); elseif Scheme == :StretchedSmoothness; scheme = WENO5(grid = grid, stretched_smoothness = true); elseif Scheme == :ZFormulation; scheme = WENO5(zweno = true); end; model = NonhydrostaticModel(architecture=Arch(), grid=grid, advection=scheme). time_step!(model, 1) # warmup. trial = @benchmark begin; @sync_gpu time_step!($model, 1); end samples=10. return trial; end. Schemes = (:Uniform, :Stretched, :StretchedSmoothness, :ZFormulation); ```; This PR, with a ""stretched"" vertical direction ; ```; ;  Architectures  Schemes  min  median  mean  max  memory  allocs  samples ; ;  CPU  Stretched  7.122 s  7.122 s  7.122 s  7.122 s  949.91 KiB  1716  1 ;  CPU  StretchedSmoothness  11.042 s  11.042 s  11.042 s  11.042 s  956.47 KiB  1716  1 ;  CPU  Uniform  6.373 s  6.373 s  6.373 s  6.373 s  945.38 KiB  1706  1 ;  CPU  ZFormulation  7.725 s  7.725 s  7.725 s  7.725 s  945.38 KiB  1706  1 ;  GPU  Stretched  25.646 ms  25.920 ms  26.501 ms  32.101 ms  2.15 MiB  30442  10 ;  GPU  StretchedSmoothness  109.080 ms  109.493 ms  109.676 ms  111.118 ms  3.78 MiB  134069  10 ;  GPU  Uniform  25.133 ms  25.394 ms  25.468 ms  26.710 ms  2.06 MiB  27799  10 ;  GPU  ZFormulation  30.554 ms  32.780 ms  32.569 ms  32.922 ms  2.20 MiB  37382  10 ; ; ```; Apparently on a much larger grid than what I tested, StretchedSmoothness is much less efficient, another reason to try to avoid it if not strictly necessary!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974843738
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975180531:126,Energy Efficiency,efficient,efficient,126,"OK. All these is great!. So all this info you just shared is it anywhere else written? E.g. ""StretchedSmoothness is much less efficient... another reason to avoid it"". Btw, what exactly is ""StretchedSmoothness""?. We should have a docs section on advection schemes (#1318) and perhaps this PR is not the right place to deal with that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975180531
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975180531:157,Safety,avoid,avoid,157,"OK. All these is great!. So all this info you just shared is it anywhere else written? E.g. ""StretchedSmoothness is much less efficient... another reason to avoid it"". Btw, what exactly is ""StretchedSmoothness""?. We should have a docs section on advection schemes (#1318) and perhaps this PR is not the right place to deal with that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975180531
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975190722:33,Security,validat,validation,33,I pushed some minor edits to the validation script.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975190722
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975195410:139,Security,validat,validation,139,"I also couldn't play the movies in the first comment. I suspect because they were created with `gif(anim, ""movie.mp4"", ...)`. I re-run the validation script and replaced them.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975195410
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975649397:1237,Integrability,depend,dependent,1237,"he face performed on different ""biased stencils"". <img src=""https://render.githubusercontent.com/render/math?math=v_{i %2B 1/2 ,r} = p_r(x_{i %2B 1/2}) = \sum_{j=0}^k c_{rj} \overline{v}_{i - r %2B j}"">. where <img src=""https://render.githubusercontent.com/render/math?math=p""> is the reconstruction polynomial constructed from the biased stencil <img src=""https://render.githubusercontent.com/render/math?math=r""> and <img src=""https://render.githubusercontent.com/render/math?math=k""> is the order of the polynomial. As we want a 5th order scheme, there will be three polynomials (<img src=""https://render.githubusercontent.com/render/math?math=r = 0, 1, 2"">) with (<img src=""https://render.githubusercontent.com/render/math?math=k = 2"">). Now the coefficients of these polynomials (<img src=""https://render.githubusercontent.com/render/math?math=c_{rj}"">) are based on the Lagrange interpolation of the integral of <img src=""https://render.githubusercontent.com/render/math?math=\overline{v}_{i}""> and, as such, are coordinate-dependent. The first thing to do, when wanting to implement the WENO scheme on a stretched grid, is then to make sure that the reconstruction is correctly done, and, as such, `WENO5(grid = grid)` takes care that (<img src=""https://render.githubusercontent.com/render/math?math=c_{rj}"">) are correctly calculated based on the underlying grid. Now, WENO schemes differ from ENO schemes since they do not just choose the ""smoothest stencil"" among the (in this case) three stencils, but weight them as such. <img src=""https://render.githubusercontent.com/render/math?math=v_{i %2B 1/2} = \sum_{r=0}^k w_{r} v_{i %2B 1/2,r} "">. Those weights have to satisfy <img src=""https://render.githubusercontent.com/render/math?math=\sum_{r=0}^k w_{r} = 1""> and are mostly a matter of choice (if the reconstruction is performed correctly for all stencils!). The general way to do this is to make them functions of a ""local smoothness indicator"" <img src=""https://render.githubusercontent",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975649397
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975649397:3053,Integrability,depend,depends,3053," mostly a matter of choice (if the reconstruction is performed correctly for all stencils!). The general way to do this is to make them functions of a ""local smoothness indicator"" <img src=""https://render.githubusercontent.com/render/math?math=\beta_r""> which is calculated as such; <img src=""https://render.githubusercontent.com/render/math?math=\beta_{r} = \sum_{l=1}^k \int_{x_{i-1/2}}^{x_{i %2B 1/2}} \Delta x^{2l -1} \left( \frac{\partial^l p_r(x)}{\partial x^l} \right)^2 dx""> . These <img src=""https://render.githubusercontent.com/render/math?math=\beta_r""> simplify quite nicely for uniform grids. the `streched_smoothness=true` option calculates the coefficients of these smoothness indicators for a stretched grid, by assuming that (<img src=""https://render.githubusercontent.com/render/math?math=k = 2"">). Then the weights are calculated as such; <img src=""https://render.githubusercontent.com/render/math?math=w_{r} = \frac{\alpha_r}{\alpha_0 %2B \alpha_1 %2B \alpha_2}""> . where <img src=""https://render.githubusercontent.com/render/math?math=\alpha_r""> depends on the scheme used and differs between JS-WENO and Z-WENO. In the former; <img src=""https://render.githubusercontent.com/render/math?math=\alpha_r = \frac{d_r}{(\beta_r %2B \varepsilon)^2}"">; In the latter ; <img src=""https://render.githubusercontent.com/render/math?math=\alpha_r = d_r \left[ 1 %2B \left( \frac{ \left |\beta_2 - \beta_0 \right|}{\beta_r %2B \varepsilon} \right)^2 \right] "">; <img src=""https://render.githubusercontent.com/render/math?math=d_r""> are optimized constants equal in both the schemes. the `zweno = true` flag just switches between these two formulations. Now, I believe that `stretched_smoothness` does not have a such big impact because if you assure that the reconstruction is correct, then all stencil correctly interpolate to the face and weights will still be between 0 and 1. This might be more impactful for grids that are much more non-uniform (or ""irregular"") than what we usually use.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975649397
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975649397:215,Performance,perform,performed,215,"@navidcy thanks for the review! ; Indeed maybe we should document it. . Just to give a quick explanation of the different flavours. WENO involves the reconstruction of the value of the advected quantity on the face performed on different ""biased stencils"". <img src=""https://render.githubusercontent.com/render/math?math=v_{i %2B 1/2 ,r} = p_r(x_{i %2B 1/2}) = \sum_{j=0}^k c_{rj} \overline{v}_{i - r %2B j}"">. where <img src=""https://render.githubusercontent.com/render/math?math=p""> is the reconstruction polynomial constructed from the biased stencil <img src=""https://render.githubusercontent.com/render/math?math=r""> and <img src=""https://render.githubusercontent.com/render/math?math=k""> is the order of the polynomial. As we want a 5th order scheme, there will be three polynomials (<img src=""https://render.githubusercontent.com/render/math?math=r = 0, 1, 2"">) with (<img src=""https://render.githubusercontent.com/render/math?math=k = 2"">). Now the coefficients of these polynomials (<img src=""https://render.githubusercontent.com/render/math?math=c_{rj}"">) are based on the Lagrange interpolation of the integral of <img src=""https://render.githubusercontent.com/render/math?math=\overline{v}_{i}""> and, as such, are coordinate-dependent. The first thing to do, when wanting to implement the WENO scheme on a stretched grid, is then to make sure that the reconstruction is correctly done, and, as such, `WENO5(grid = grid)` takes care that (<img src=""https://render.githubusercontent.com/render/math?math=c_{rj}"">) are correctly calculated based on the underlying grid. Now, WENO schemes differ from ENO schemes since they do not just choose the ""smoothest stencil"" among the (in this case) three stencils, but weight them as such. <img src=""https://render.githubusercontent.com/render/math?math=v_{i %2B 1/2} = \sum_{r=0}^k w_{r} v_{i %2B 1/2,r} "">. Those weights have to satisfy <img src=""https://render.githubusercontent.com/render/math?math=\sum_{r=0}^k w_{r} = 1""> and are mostly a matte",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975649397
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975649397:2039,Performance,perform,performed,2039,"ps://render.githubusercontent.com/render/math?math=c_{rj}"">) are based on the Lagrange interpolation of the integral of <img src=""https://render.githubusercontent.com/render/math?math=\overline{v}_{i}""> and, as such, are coordinate-dependent. The first thing to do, when wanting to implement the WENO scheme on a stretched grid, is then to make sure that the reconstruction is correctly done, and, as such, `WENO5(grid = grid)` takes care that (<img src=""https://render.githubusercontent.com/render/math?math=c_{rj}"">) are correctly calculated based on the underlying grid. Now, WENO schemes differ from ENO schemes since they do not just choose the ""smoothest stencil"" among the (in this case) three stencils, but weight them as such. <img src=""https://render.githubusercontent.com/render/math?math=v_{i %2B 1/2} = \sum_{r=0}^k w_{r} v_{i %2B 1/2,r} "">. Those weights have to satisfy <img src=""https://render.githubusercontent.com/render/math?math=\sum_{r=0}^k w_{r} = 1""> and are mostly a matter of choice (if the reconstruction is performed correctly for all stencils!). The general way to do this is to make them functions of a ""local smoothness indicator"" <img src=""https://render.githubusercontent.com/render/math?math=\beta_r""> which is calculated as such; <img src=""https://render.githubusercontent.com/render/math?math=\beta_{r} = \sum_{l=1}^k \int_{x_{i-1/2}}^{x_{i %2B 1/2}} \Delta x^{2l -1} \left( \frac{\partial^l p_r(x)}{\partial x^l} \right)^2 dx""> . These <img src=""https://render.githubusercontent.com/render/math?math=\beta_r""> simplify quite nicely for uniform grids. the `streched_smoothness=true` option calculates the coefficients of these smoothness indicators for a stretched grid, by assuming that (<img src=""https://render.githubusercontent.com/render/math?math=k = 2"">). Then the weights are calculated as such; <img src=""https://render.githubusercontent.com/render/math?math=w_{r} = \frac{\alpha_r}{\alpha_0 %2B \alpha_1 %2B \alpha_2}""> . where <img src=""https://render.git",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975649397
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975649397:3530,Performance,optimiz,optimized,3530," mostly a matter of choice (if the reconstruction is performed correctly for all stencils!). The general way to do this is to make them functions of a ""local smoothness indicator"" <img src=""https://render.githubusercontent.com/render/math?math=\beta_r""> which is calculated as such; <img src=""https://render.githubusercontent.com/render/math?math=\beta_{r} = \sum_{l=1}^k \int_{x_{i-1/2}}^{x_{i %2B 1/2}} \Delta x^{2l -1} \left( \frac{\partial^l p_r(x)}{\partial x^l} \right)^2 dx""> . These <img src=""https://render.githubusercontent.com/render/math?math=\beta_r""> simplify quite nicely for uniform grids. the `streched_smoothness=true` option calculates the coefficients of these smoothness indicators for a stretched grid, by assuming that (<img src=""https://render.githubusercontent.com/render/math?math=k = 2"">). Then the weights are calculated as such; <img src=""https://render.githubusercontent.com/render/math?math=w_{r} = \frac{\alpha_r}{\alpha_0 %2B \alpha_1 %2B \alpha_2}""> . where <img src=""https://render.githubusercontent.com/render/math?math=\alpha_r""> depends on the scheme used and differs between JS-WENO and Z-WENO. In the former; <img src=""https://render.githubusercontent.com/render/math?math=\alpha_r = \frac{d_r}{(\beta_r %2B \varepsilon)^2}"">; In the latter ; <img src=""https://render.githubusercontent.com/render/math?math=\alpha_r = d_r \left[ 1 %2B \left( \frac{ \left |\beta_2 - \beta_0 \right|}{\beta_r %2B \varepsilon} \right)^2 \right] "">; <img src=""https://render.githubusercontent.com/render/math?math=d_r""> are optimized constants equal in both the schemes. the `zweno = true` flag just switches between these two formulations. Now, I believe that `stretched_smoothness` does not have a such big impact because if you assure that the reconstruction is correct, then all stencil correctly interpolate to the face and weights will still be between 0 and 1. This might be more impactful for grids that are much more non-uniform (or ""irregular"") than what we usually use.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975649397
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975649397:2551,Usability,simpl,simplify,2551,"on the underlying grid. Now, WENO schemes differ from ENO schemes since they do not just choose the ""smoothest stencil"" among the (in this case) three stencils, but weight them as such. <img src=""https://render.githubusercontent.com/render/math?math=v_{i %2B 1/2} = \sum_{r=0}^k w_{r} v_{i %2B 1/2,r} "">. Those weights have to satisfy <img src=""https://render.githubusercontent.com/render/math?math=\sum_{r=0}^k w_{r} = 1""> and are mostly a matter of choice (if the reconstruction is performed correctly for all stencils!). The general way to do this is to make them functions of a ""local smoothness indicator"" <img src=""https://render.githubusercontent.com/render/math?math=\beta_r""> which is calculated as such; <img src=""https://render.githubusercontent.com/render/math?math=\beta_{r} = \sum_{l=1}^k \int_{x_{i-1/2}}^{x_{i %2B 1/2}} \Delta x^{2l -1} \left( \frac{\partial^l p_r(x)}{\partial x^l} \right)^2 dx""> . These <img src=""https://render.githubusercontent.com/render/math?math=\beta_r""> simplify quite nicely for uniform grids. the `streched_smoothness=true` option calculates the coefficients of these smoothness indicators for a stretched grid, by assuming that (<img src=""https://render.githubusercontent.com/render/math?math=k = 2"">). Then the weights are calculated as such; <img src=""https://render.githubusercontent.com/render/math?math=w_{r} = \frac{\alpha_r}{\alpha_0 %2B \alpha_1 %2B \alpha_2}""> . where <img src=""https://render.githubusercontent.com/render/math?math=\alpha_r""> depends on the scheme used and differs between JS-WENO and Z-WENO. In the former; <img src=""https://render.githubusercontent.com/render/math?math=\alpha_r = \frac{d_r}{(\beta_r %2B \varepsilon)^2}"">; In the latter ; <img src=""https://render.githubusercontent.com/render/math?math=\alpha_r = d_r \left[ 1 %2B \left( \frac{ \left |\beta_2 - \beta_0 \right|}{\beta_r %2B \varepsilon} \right)^2 \right] "">; <img src=""https://render.githubusercontent.com/render/math?math=d_r""> are optimized constants equal ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975649397
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975684663:246,Modifiability,variab,variable,246,"@tomchor . In terms of ""smoothness indicators"" yes, not in terms of polynomial reconstruction. The WENO we had before is `WENO5()`. This will be formally wrong on a stretched grid because the reconstruction at the face is not done accounting for variable spacing. . `WENO5(grid = grid, stretched_smoothness=false) ` accounts for variable spacing in the reconstruction polynomial (i.e., the <img src=""https://render.githubusercontent.com/render/math?math=c_{rj}""> coefficients are calculated based on grid spacing). This makes the scheme formally correct as, independently on how you weight the polynomials, the different stencils will have mathematically correct reconstructions at the face. This should _always_ be done in case of a stretched grid (and it does not decrease execution speed). Now, the `stretched_smoothness=true` calculates the <img src=""https://render.githubusercontent.com/render/math?math=\beta_{r}""> accounting for a stretched mesh. This means that the three reconstruction polynomials (<img src=""https://render.githubusercontent.com/render/math?math=p_{0}, p_{1}, p_{2}"">) are weighted accounting for their actual smoothness and not a ""uniform smoothness"" that `WENO5(grid = grid, stretched_smoothness=false) ` calculates. In my tests this did not give a noticeable benefit in terms of accuracy (apparently <img src=""https://render.githubusercontent.com/render/math?math=\beta_{r}""> for a stretched mesh are very similar to <img src=""https://render.githubusercontent.com/render/math?math=\beta_{r}""> for a uniform mesh). In addition, it gives a non-negligible decrease in execution speed (especially on the GPU). For this reason, I think it is nice to have as an option, but to be used with parsimony :) and only when necessary.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975684663
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975684663:329,Modifiability,variab,variable,329,"@tomchor . In terms of ""smoothness indicators"" yes, not in terms of polynomial reconstruction. The WENO we had before is `WENO5()`. This will be formally wrong on a stretched grid because the reconstruction at the face is not done accounting for variable spacing. . `WENO5(grid = grid, stretched_smoothness=false) ` accounts for variable spacing in the reconstruction polynomial (i.e., the <img src=""https://render.githubusercontent.com/render/math?math=c_{rj}""> coefficients are calculated based on grid spacing). This makes the scheme formally correct as, independently on how you weight the polynomials, the different stencils will have mathematically correct reconstructions at the face. This should _always_ be done in case of a stretched grid (and it does not decrease execution speed). Now, the `stretched_smoothness=true` calculates the <img src=""https://render.githubusercontent.com/render/math?math=\beta_{r}""> accounting for a stretched mesh. This means that the three reconstruction polynomials (<img src=""https://render.githubusercontent.com/render/math?math=p_{0}, p_{1}, p_{2}"">) are weighted accounting for their actual smoothness and not a ""uniform smoothness"" that `WENO5(grid = grid, stretched_smoothness=false) ` calculates. In my tests this did not give a noticeable benefit in terms of accuracy (apparently <img src=""https://render.githubusercontent.com/render/math?math=\beta_{r}""> for a stretched mesh are very similar to <img src=""https://render.githubusercontent.com/render/math?math=\beta_{r}""> for a uniform mesh). In addition, it gives a non-negligible decrease in execution speed (especially on the GPU). For this reason, I think it is nice to have as an option, but to be used with parsimony :) and only when necessary.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975684663
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975684663:1251,Testability,test,tests,1251,"@tomchor . In terms of ""smoothness indicators"" yes, not in terms of polynomial reconstruction. The WENO we had before is `WENO5()`. This will be formally wrong on a stretched grid because the reconstruction at the face is not done accounting for variable spacing. . `WENO5(grid = grid, stretched_smoothness=false) ` accounts for variable spacing in the reconstruction polynomial (i.e., the <img src=""https://render.githubusercontent.com/render/math?math=c_{rj}""> coefficients are calculated based on grid spacing). This makes the scheme formally correct as, independently on how you weight the polynomials, the different stencils will have mathematically correct reconstructions at the face. This should _always_ be done in case of a stretched grid (and it does not decrease execution speed). Now, the `stretched_smoothness=true` calculates the <img src=""https://render.githubusercontent.com/render/math?math=\beta_{r}""> accounting for a stretched mesh. This means that the three reconstruction polynomials (<img src=""https://render.githubusercontent.com/render/math?math=p_{0}, p_{1}, p_{2}"">) are weighted accounting for their actual smoothness and not a ""uniform smoothness"" that `WENO5(grid = grid, stretched_smoothness=false) ` calculates. In my tests this did not give a noticeable benefit in terms of accuracy (apparently <img src=""https://render.githubusercontent.com/render/math?math=\beta_{r}""> for a stretched mesh are very similar to <img src=""https://render.githubusercontent.com/render/math?math=\beta_{r}""> for a uniform mesh). In addition, it gives a non-negligible decrease in execution speed (especially on the GPU). For this reason, I think it is nice to have as an option, but to be used with parsimony :) and only when necessary.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975684663
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975853695:253,Modifiability,variab,variable,253,"> @tomchor; > ; > In terms of ""smoothness indicators"" yes, not in terms of polynomial reconstruction. The WENO we had before is `WENO5()`. This will be formally wrong on a stretched grid because the reconstruction at the face is not done accounting for variable spacing.; > ; > `WENO5(grid = grid, stretched_smoothness=false) ` accounts for variable spacing in the reconstruction polynomial (i.e., the ![](https://render.githubusercontent.com/render/math?math=c_{rj}) coefficients are calculated based on grid spacing). This makes the scheme formally correct as, independently on how you weight the polynomials, the different stencils will have mathematically correct reconstructions at the face. This should _always_ be done in case of a stretched grid (and it does not decrease execution speed).; > ; > Now, the `stretched_smoothness=true` calculates the ![](https://render.githubusercontent.com/render/math?math=\beta_{r}) accounting for a stretched mesh. This means that the three reconstruction polynomials (![](https://render.githubusercontent.com/render/math?math=p_{0}, p_{1}, p_{2})) are weighted accounting for their actual smoothness and not a ""uniform smoothness"" that `WENO5(grid = grid, stretched_smoothness=false) ` calculates. In my tests this did not give a noticeable benefit in terms of accuracy (apparently ![](https://render.githubusercontent.com/render/math?math=\beta_{r}) for a stretched mesh are very similar to ![](https://render.githubusercontent.com/render/math?math=\beta_{r}) for a uniform mesh). In addition, it gives a non-negligible decrease in execution speed (especially on the GPU). For this reason, I think it is nice to have as an option, but to be used with parsimony :) and only when necessary. OK. This is great. Do you mind if I add something along those lines in a docstring somewhere? It's a pity to be left just in a comment in this PR, lost in the aether of closed PRs...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975853695
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975853695:341,Modifiability,variab,variable,341,"> @tomchor; > ; > In terms of ""smoothness indicators"" yes, not in terms of polynomial reconstruction. The WENO we had before is `WENO5()`. This will be formally wrong on a stretched grid because the reconstruction at the face is not done accounting for variable spacing.; > ; > `WENO5(grid = grid, stretched_smoothness=false) ` accounts for variable spacing in the reconstruction polynomial (i.e., the ![](https://render.githubusercontent.com/render/math?math=c_{rj}) coefficients are calculated based on grid spacing). This makes the scheme formally correct as, independently on how you weight the polynomials, the different stencils will have mathematically correct reconstructions at the face. This should _always_ be done in case of a stretched grid (and it does not decrease execution speed).; > ; > Now, the `stretched_smoothness=true` calculates the ![](https://render.githubusercontent.com/render/math?math=\beta_{r}) accounting for a stretched mesh. This means that the three reconstruction polynomials (![](https://render.githubusercontent.com/render/math?math=p_{0}, p_{1}, p_{2})) are weighted accounting for their actual smoothness and not a ""uniform smoothness"" that `WENO5(grid = grid, stretched_smoothness=false) ` calculates. In my tests this did not give a noticeable benefit in terms of accuracy (apparently ![](https://render.githubusercontent.com/render/math?math=\beta_{r}) for a stretched mesh are very similar to ![](https://render.githubusercontent.com/render/math?math=\beta_{r}) for a uniform mesh). In addition, it gives a non-negligible decrease in execution speed (especially on the GPU). For this reason, I think it is nice to have as an option, but to be used with parsimony :) and only when necessary. OK. This is great. Do you mind if I add something along those lines in a docstring somewhere? It's a pity to be left just in a comment in this PR, lost in the aether of closed PRs...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975853695
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975853695:1249,Testability,test,tests,1249,"> @tomchor; > ; > In terms of ""smoothness indicators"" yes, not in terms of polynomial reconstruction. The WENO we had before is `WENO5()`. This will be formally wrong on a stretched grid because the reconstruction at the face is not done accounting for variable spacing.; > ; > `WENO5(grid = grid, stretched_smoothness=false) ` accounts for variable spacing in the reconstruction polynomial (i.e., the ![](https://render.githubusercontent.com/render/math?math=c_{rj}) coefficients are calculated based on grid spacing). This makes the scheme formally correct as, independently on how you weight the polynomials, the different stencils will have mathematically correct reconstructions at the face. This should _always_ be done in case of a stretched grid (and it does not decrease execution speed).; > ; > Now, the `stretched_smoothness=true` calculates the ![](https://render.githubusercontent.com/render/math?math=\beta_{r}) accounting for a stretched mesh. This means that the three reconstruction polynomials (![](https://render.githubusercontent.com/render/math?math=p_{0}, p_{1}, p_{2})) are weighted accounting for their actual smoothness and not a ""uniform smoothness"" that `WENO5(grid = grid, stretched_smoothness=false) ` calculates. In my tests this did not give a noticeable benefit in terms of accuracy (apparently ![](https://render.githubusercontent.com/render/math?math=\beta_{r}) for a stretched mesh are very similar to ![](https://render.githubusercontent.com/render/math?math=\beta_{r}) for a uniform mesh). In addition, it gives a non-negligible decrease in execution speed (especially on the GPU). For this reason, I think it is nice to have as an option, but to be used with parsimony :) and only when necessary. OK. This is great. Do you mind if I add something along those lines in a docstring somewhere? It's a pity to be left just in a comment in this PR, lost in the aether of closed PRs...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975853695
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-976013319:134,Performance,perform,performance,134,"I noticed ""On the other hand, a Z-WENO formulation is *always* beneficial (also in case of a uniform mesh) with no major; decrease in performance."". Why don't we then change `zweno = true`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-976013319
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-976145373:153,Testability,test,tested,153,"@navidcy I have made a couple of small changes. Anyways, I am a little hesitant to make Z-WENO the default as it does, yes, have slight benefits, but we tested only on small simplified problems. I would have a bit more testing before making it the default.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-976145373
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-976145373:219,Testability,test,testing,219,"@navidcy I have made a couple of small changes. Anyways, I am a little hesitant to make Z-WENO the default as it does, yes, have slight benefits, but we tested only on small simplified problems. I would have a bit more testing before making it the default.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-976145373
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-976145373:174,Usability,simpl,simplified,174,"@navidcy I have made a couple of small changes. Anyways, I am a little hesitant to make Z-WENO the default as it does, yes, have slight benefits, but we tested only on small simplified problems. I would have a bit more testing before making it the default.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-976145373
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-976148612:155,Testability,test,tested,155,"> @navidcy I have made a couple of small changes. Anyways, I am a little hesitant to make Z-WENO the default as it does, yes, have slight benefits, but we tested only on small simplified problems. I would have a bit more testing before making it the default. Sounds good! I was just wondering. I made a formatting suggestion. I think you should merge as soon as tests pass!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-976148612
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-976148612:221,Testability,test,testing,221,"> @navidcy I have made a couple of small changes. Anyways, I am a little hesitant to make Z-WENO the default as it does, yes, have slight benefits, but we tested only on small simplified problems. I would have a bit more testing before making it the default. Sounds good! I was just wondering. I made a formatting suggestion. I think you should merge as soon as tests pass!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-976148612
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-976148612:362,Testability,test,tests,362,"> @navidcy I have made a couple of small changes. Anyways, I am a little hesitant to make Z-WENO the default as it does, yes, have slight benefits, but we tested only on small simplified problems. I would have a bit more testing before making it the default. Sounds good! I was just wondering. I made a formatting suggestion. I think you should merge as soon as tests pass!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-976148612
https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-976148612:176,Usability,simpl,simplified,176,"> @navidcy I have made a couple of small changes. Anyways, I am a little hesitant to make Z-WENO the default as it does, yes, have slight benefits, but we tested only on small simplified problems. I would have a bit more testing before making it the default. Sounds good! I was just wondering. I made a formatting suggestion. I think you should merge as soon as tests pass!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-976148612
https://github.com/CliMA/Oceananigans.jl/pull/2063#issuecomment-971712282:80,Performance,perform,performance,80,> Nice one. Should we benchmark anything just to make sure this hasn't affected performance?. That's a good idea!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2063#issuecomment-971712282
https://github.com/CliMA/Oceananigans.jl/pull/2063#issuecomment-971712282:22,Testability,benchmark,benchmark,22,> Nice one. Should we benchmark anything just to make sure this hasn't affected performance?. That's a good idea!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2063#issuecomment-971712282
https://github.com/CliMA/Oceananigans.jl/pull/2063#issuecomment-972916256:71,Usability,intuit,intuitive,71,"I agree very much with this decision, it would be very convenient (and intuitive) to be able to change boundary conditions like that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2063#issuecomment-972916256
https://github.com/CliMA/Oceananigans.jl/pull/2063#issuecomment-983874974:950,Availability,avail,available,950,"# Benchmarks. ```; Julia Version 1.6.2; Commit 1b93d53fc4 (2021-07-14 15:36 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; JULIA_NUM_THREADS = 24; JULIA_EDITOR = vim; GPU: NVIDIA TITAN V. CUDA toolkit 11.4, artifact installation; NVIDIA driver 470.86.0, for CUDA 11.4; CUDA driver 11.4. Libraries:; - CUBLAS: 11.5.4; - CURAND: 10.2.5; - CUFFT: 10.5.1; - CUSOLVER: 11.2.0; - CUSPARSE: 11.6.0; - CUPTI: 14.0.0; - NVML: 11.0.0+470.86; - CUDNN: 8.20.2 (for CUDA 11.4.0); - CUTENSOR: 1.3.0 (for CUDA 11.2.0). Toolchain:; - Julia: 1.6.2; - LLVM: 11.0.1; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4, 6.5, 7.0; - Device capability support: sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75, sm_80. 1 device:; 0: NVIDIA TITAN V (sm_70, 11.484 GiB / 11.784 GiB available); nothing; ```. ## `main`. ```; Nonhydrostatic model benchmarks; ;  Architectures  Float_types  Ns  min  median  mean  max  memory  allocs  samples ; ;  CPU  Float32  32  7.865 ms  8.157 ms  8.384 ms  9.923 ms  2.50 MiB  7004  10 ;  CPU  Float32  64  13.237 ms  13.739 ms  14.162 ms  16.642 ms  3.20 MiB  12619  10 ;  CPU  Float32  128  49.644 ms  53.133 ms  52.873 ms  56.953 ms  3.51 MiB  16344  10 ;  CPU  Float32  256  338.545 ms  353.497 ms  353.048 ms  370.172 ms  3.81 MiB  35156  10 ;  CPU  Float64  32  9.683 ms  10.028 ms  10.324 ms  12.479 ms  3.25 MiB  7003  10 ;  CPU  Float64  64  14.979 ms  16.581 ms  17.035 ms  22.013 ms  4.07 MiB  12652  10 ;  CPU  Float64  128  67.659 ms  68.736 ms  70.121 ms  84.62",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2063#issuecomment-983874974
https://github.com/CliMA/Oceananigans.jl/pull/2063#issuecomment-983874974:365,Deployability,install,installation,365,"# Benchmarks. ```; Julia Version 1.6.2; Commit 1b93d53fc4 (2021-07-14 15:36 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; JULIA_NUM_THREADS = 24; JULIA_EDITOR = vim; GPU: NVIDIA TITAN V. CUDA toolkit 11.4, artifact installation; NVIDIA driver 470.86.0, for CUDA 11.4; CUDA driver 11.4. Libraries:; - CUBLAS: 11.5.4; - CURAND: 10.2.5; - CUFFT: 10.5.1; - CUSOLVER: 11.2.0; - CUSPARSE: 11.6.0; - CUPTI: 14.0.0; - NVML: 11.0.0+470.86; - CUDNN: 8.20.2 (for CUDA 11.4.0); - CUTENSOR: 1.3.0 (for CUDA 11.2.0). Toolchain:; - Julia: 1.6.2; - LLVM: 11.0.1; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4, 6.5, 7.0; - Device capability support: sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75, sm_80. 1 device:; 0: NVIDIA TITAN V (sm_70, 11.484 GiB / 11.784 GiB available); nothing; ```. ## `main`. ```; Nonhydrostatic model benchmarks; ;  Architectures  Float_types  Ns  min  median  mean  max  memory  allocs  samples ; ;  CPU  Float32  32  7.865 ms  8.157 ms  8.384 ms  9.923 ms  2.50 MiB  7004  10 ;  CPU  Float32  64  13.237 ms  13.739 ms  14.162 ms  16.642 ms  3.20 MiB  12619  10 ;  CPU  Float32  128  49.644 ms  53.133 ms  52.873 ms  56.953 ms  3.51 MiB  16344  10 ;  CPU  Float32  256  338.545 ms  353.497 ms  353.048 ms  370.172 ms  3.81 MiB  35156  10 ;  CPU  Float64  32  9.683 ms  10.028 ms  10.324 ms  12.479 ms  3.25 MiB  7003  10 ;  CPU  Float64  64  14.979 ms  16.581 ms  17.035 ms  22.013 ms  4.07 MiB  12652  10 ;  CPU  Float64  128  67.659 ms  68.736 ms  70.121 ms  84.62",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2063#issuecomment-983874974
https://github.com/CliMA/Oceananigans.jl/pull/2063#issuecomment-983874974:2,Testability,Benchmark,Benchmarks,2,"# Benchmarks. ```; Julia Version 1.6.2; Commit 1b93d53fc4 (2021-07-14 15:36 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; JULIA_NUM_THREADS = 24; JULIA_EDITOR = vim; GPU: NVIDIA TITAN V. CUDA toolkit 11.4, artifact installation; NVIDIA driver 470.86.0, for CUDA 11.4; CUDA driver 11.4. Libraries:; - CUBLAS: 11.5.4; - CURAND: 10.2.5; - CUFFT: 10.5.1; - CUSOLVER: 11.2.0; - CUSPARSE: 11.6.0; - CUPTI: 14.0.0; - NVML: 11.0.0+470.86; - CUDNN: 8.20.2 (for CUDA 11.4.0); - CUTENSOR: 1.3.0 (for CUDA 11.2.0). Toolchain:; - Julia: 1.6.2; - LLVM: 11.0.1; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4, 6.5, 7.0; - Device capability support: sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75, sm_80. 1 device:; 0: NVIDIA TITAN V (sm_70, 11.484 GiB / 11.784 GiB available); nothing; ```. ## `main`. ```; Nonhydrostatic model benchmarks; ;  Architectures  Float_types  Ns  min  median  mean  max  memory  allocs  samples ; ;  CPU  Float32  32  7.865 ms  8.157 ms  8.384 ms  9.923 ms  2.50 MiB  7004  10 ;  CPU  Float32  64  13.237 ms  13.739 ms  14.162 ms  16.642 ms  3.20 MiB  12619  10 ;  CPU  Float32  128  49.644 ms  53.133 ms  52.873 ms  56.953 ms  3.51 MiB  16344  10 ;  CPU  Float32  256  338.545 ms  353.497 ms  353.048 ms  370.172 ms  3.81 MiB  35156  10 ;  CPU  Float64  32  9.683 ms  10.028 ms  10.324 ms  12.479 ms  3.25 MiB  7003  10 ;  CPU  Float64  64  14.979 ms  16.581 ms  17.035 ms  22.013 ms  4.07 MiB  12652  10 ;  CPU  Float64  128  67.659 ms  68.736 ms  70.121 ms  84.62",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2063#issuecomment-983874974
https://github.com/CliMA/Oceananigans.jl/pull/2063#issuecomment-983874974:1013,Testability,benchmark,benchmarks,1013,"IZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; JULIA_NUM_THREADS = 24; JULIA_EDITOR = vim; GPU: NVIDIA TITAN V. CUDA toolkit 11.4, artifact installation; NVIDIA driver 470.86.0, for CUDA 11.4; CUDA driver 11.4. Libraries:; - CUBLAS: 11.5.4; - CURAND: 10.2.5; - CUFFT: 10.5.1; - CUSOLVER: 11.2.0; - CUSPARSE: 11.6.0; - CUPTI: 14.0.0; - NVML: 11.0.0+470.86; - CUDNN: 8.20.2 (for CUDA 11.4.0); - CUTENSOR: 1.3.0 (for CUDA 11.2.0). Toolchain:; - Julia: 1.6.2; - LLVM: 11.0.1; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4, 6.5, 7.0; - Device capability support: sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75, sm_80. 1 device:; 0: NVIDIA TITAN V (sm_70, 11.484 GiB / 11.784 GiB available); nothing; ```. ## `main`. ```; Nonhydrostatic model benchmarks; ;  Architectures  Float_types  Ns  min  median  mean  max  memory  allocs  samples ; ;  CPU  Float32  32  7.865 ms  8.157 ms  8.384 ms  9.923 ms  2.50 MiB  7004  10 ;  CPU  Float32  64  13.237 ms  13.739 ms  14.162 ms  16.642 ms  3.20 MiB  12619  10 ;  CPU  Float32  128  49.644 ms  53.133 ms  52.873 ms  56.953 ms  3.51 MiB  16344  10 ;  CPU  Float32  256  338.545 ms  353.497 ms  353.048 ms  370.172 ms  3.81 MiB  35156  10 ;  CPU  Float64  32  9.683 ms  10.028 ms  10.324 ms  12.479 ms  3.25 MiB  7003  10 ;  CPU  Float64  64  14.979 ms  16.581 ms  17.035 ms  22.013 ms  4.07 MiB  12652  10 ;  CPU  Float64  128  67.659 ms  68.736 ms  70.121 ms  84.622 ms  4.50 MiB  20205  10 ;  CPU  Float64  256  513.071 ms  520.511 ms  520.758 ms  531.669 ms  5.70 MiB  85616  10 ;  GPU  Float32  32  2.276 ms  2.324 ms  2.420 m",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2063#issuecomment-983874974
https://github.com/CliMA/Oceananigans.jl/pull/2063#issuecomment-983876168:0,Testability,Benchmark,Benchmarks,0,"Benchmarks are more or less unchanged, so I'm merging.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2063#issuecomment-983876168
https://github.com/CliMA/Oceananigans.jl/issues/2064#issuecomment-971140218:26,Usability,clear,clear,26,"- `extrema(z)` is not as clear... let's just write `min(z) = ..., max(z) = ...`; - I'd suggest something like; ```Julia; z  [0.0, 1.0], min(z) = ..., max(z) = ...; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2064#issuecomment-971140218
https://github.com/CliMA/Oceananigans.jl/issues/2064#issuecomment-971810297:306,Availability,down,downside,306,"I actually appreciate the verbose-ness of the grid show functions (actually most of Oceananigans show functions in general). So I can only assume that more beginner users appreciate that as well, since it makes extremely clear what the grid characteristics are. I also don't think there's a very important downside to being verbose here, so I'd vote to keep the same style. Although I agree that we could get rid of some redundant information. My suggestion would be something like:. ```julia; julia> grid = RectilinearGrid(size=3, z=[0.0, 0.2, 0.5, 1.0], topology=(Flat, Flat, Bounded)); RectilinearGrid{Float64, Flat, Flat, Bounded} on the CPU(); domain: x  [1.0, 1.0], y  [1.0, 1.0], z  [0.0, 1.0]; topology: (Flat, Flat, Bounded); size (Nx, Ny, Nz): (1, 1, 3); halo (Hx, Hy, Hz): (0, 0, 1); z spacing: Stretched, with min=0.2, max=0.5; ```. In other words, I'd remove the flat dimensions (since that's unnecessary), and clean and align the `z` spacing statement. I'd also keep the ` topology: (Flat, Flat, Bounded)` because the line `RectilinearGrid{Float64, Flat, Flat, Bounded}` might not be very intuitive to everyone. If a shorter show is necessary in some places maybe we could create something like `short_show`? (Or maybe define `show` differently based on the display?: https://schurkus.com/2018/01/05/julia-print-show-display-dump-what-to-override-what-to-use/)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2064#issuecomment-971810297
https://github.com/CliMA/Oceananigans.jl/issues/2064#issuecomment-971810297:421,Availability,redundant,redundant,421,"I actually appreciate the verbose-ness of the grid show functions (actually most of Oceananigans show functions in general). So I can only assume that more beginner users appreciate that as well, since it makes extremely clear what the grid characteristics are. I also don't think there's a very important downside to being verbose here, so I'd vote to keep the same style. Although I agree that we could get rid of some redundant information. My suggestion would be something like:. ```julia; julia> grid = RectilinearGrid(size=3, z=[0.0, 0.2, 0.5, 1.0], topology=(Flat, Flat, Bounded)); RectilinearGrid{Float64, Flat, Flat, Bounded} on the CPU(); domain: x  [1.0, 1.0], y  [1.0, 1.0], z  [0.0, 1.0]; topology: (Flat, Flat, Bounded); size (Nx, Ny, Nz): (1, 1, 3); halo (Hx, Hy, Hz): (0, 0, 1); z spacing: Stretched, with min=0.2, max=0.5; ```. In other words, I'd remove the flat dimensions (since that's unnecessary), and clean and align the `z` spacing statement. I'd also keep the ` topology: (Flat, Flat, Bounded)` because the line `RectilinearGrid{Float64, Flat, Flat, Bounded}` might not be very intuitive to everyone. If a shorter show is necessary in some places maybe we could create something like `short_show`? (Or maybe define `show` differently based on the display?: https://schurkus.com/2018/01/05/julia-print-show-display-dump-what-to-override-what-to-use/)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2064#issuecomment-971810297
https://github.com/CliMA/Oceananigans.jl/issues/2064#issuecomment-971810297:421,Safety,redund,redundant,421,"I actually appreciate the verbose-ness of the grid show functions (actually most of Oceananigans show functions in general). So I can only assume that more beginner users appreciate that as well, since it makes extremely clear what the grid characteristics are. I also don't think there's a very important downside to being verbose here, so I'd vote to keep the same style. Although I agree that we could get rid of some redundant information. My suggestion would be something like:. ```julia; julia> grid = RectilinearGrid(size=3, z=[0.0, 0.2, 0.5, 1.0], topology=(Flat, Flat, Bounded)); RectilinearGrid{Float64, Flat, Flat, Bounded} on the CPU(); domain: x  [1.0, 1.0], y  [1.0, 1.0], z  [0.0, 1.0]; topology: (Flat, Flat, Bounded); size (Nx, Ny, Nz): (1, 1, 3); halo (Hx, Hy, Hz): (0, 0, 1); z spacing: Stretched, with min=0.2, max=0.5; ```. In other words, I'd remove the flat dimensions (since that's unnecessary), and clean and align the `z` spacing statement. I'd also keep the ` topology: (Flat, Flat, Bounded)` because the line `RectilinearGrid{Float64, Flat, Flat, Bounded}` might not be very intuitive to everyone. If a shorter show is necessary in some places maybe we could create something like `short_show`? (Or maybe define `show` differently based on the display?: https://schurkus.com/2018/01/05/julia-print-show-display-dump-what-to-override-what-to-use/)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2064#issuecomment-971810297
https://github.com/CliMA/Oceananigans.jl/issues/2064#issuecomment-971810297:221,Usability,clear,clear,221,"I actually appreciate the verbose-ness of the grid show functions (actually most of Oceananigans show functions in general). So I can only assume that more beginner users appreciate that as well, since it makes extremely clear what the grid characteristics are. I also don't think there's a very important downside to being verbose here, so I'd vote to keep the same style. Although I agree that we could get rid of some redundant information. My suggestion would be something like:. ```julia; julia> grid = RectilinearGrid(size=3, z=[0.0, 0.2, 0.5, 1.0], topology=(Flat, Flat, Bounded)); RectilinearGrid{Float64, Flat, Flat, Bounded} on the CPU(); domain: x  [1.0, 1.0], y  [1.0, 1.0], z  [0.0, 1.0]; topology: (Flat, Flat, Bounded); size (Nx, Ny, Nz): (1, 1, 3); halo (Hx, Hy, Hz): (0, 0, 1); z spacing: Stretched, with min=0.2, max=0.5; ```. In other words, I'd remove the flat dimensions (since that's unnecessary), and clean and align the `z` spacing statement. I'd also keep the ` topology: (Flat, Flat, Bounded)` because the line `RectilinearGrid{Float64, Flat, Flat, Bounded}` might not be very intuitive to everyone. If a shorter show is necessary in some places maybe we could create something like `short_show`? (Or maybe define `show` differently based on the display?: https://schurkus.com/2018/01/05/julia-print-show-display-dump-what-to-override-what-to-use/)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2064#issuecomment-971810297
https://github.com/CliMA/Oceananigans.jl/issues/2064#issuecomment-971810297:1106,Usability,intuit,intuitive,1106,"I actually appreciate the verbose-ness of the grid show functions (actually most of Oceananigans show functions in general). So I can only assume that more beginner users appreciate that as well, since it makes extremely clear what the grid characteristics are. I also don't think there's a very important downside to being verbose here, so I'd vote to keep the same style. Although I agree that we could get rid of some redundant information. My suggestion would be something like:. ```julia; julia> grid = RectilinearGrid(size=3, z=[0.0, 0.2, 0.5, 1.0], topology=(Flat, Flat, Bounded)); RectilinearGrid{Float64, Flat, Flat, Bounded} on the CPU(); domain: x  [1.0, 1.0], y  [1.0, 1.0], z  [0.0, 1.0]; topology: (Flat, Flat, Bounded); size (Nx, Ny, Nz): (1, 1, 3); halo (Hx, Hy, Hz): (0, 0, 1); z spacing: Stretched, with min=0.2, max=0.5; ```. In other words, I'd remove the flat dimensions (since that's unnecessary), and clean and align the `z` spacing statement. I'd also keep the ` topology: (Flat, Flat, Bounded)` because the line `RectilinearGrid{Float64, Flat, Flat, Bounded}` might not be very intuitive to everyone. If a shorter show is necessary in some places maybe we could create something like `short_show`? (Or maybe define `show` differently based on the display?: https://schurkus.com/2018/01/05/julia-print-show-display-dump-what-to-override-what-to-use/)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2064#issuecomment-971810297
https://github.com/CliMA/Oceananigans.jl/issues/2064#issuecomment-971870818:1881,Integrability,depend,depending,1881," we could also omit `Flat` dimensions from the size display, eg. ```julia; ""3-element RectilinearGrid{Float64} on CPU with topology (Flat, Flat, Bounded) and 1-element halo""; ```. ```julia; ""128128 RectilinearGrid{Float64} on CPU with topology (Periodic, Periodic, Flat) and 11 halo""; ```. If we also change `interior` to drop `Flat` dimensions then I think this makes sense (otherwise it might not). In addition to type information, `show` also gives information about _values_. Here this is the extent of the domain and the grid spacings. For example:. ```julia; julia> rand(3, 3); 33 Matrix{Float64}:; 0.460633 0.134952 0.0366328; 0.6353 0.0632607 0.0657011; 0.339457 0.720342 0.0417144; ```. for this we can use a tabular display like `domain: x  [1.0, 1.0], y  [1.0, 1.0], z  [0.0, 1.0]`. However, I think a better possibility is to explicitly show the locations of the faces using a strategy similar to how `julia` shows row vectors:. ```julia; julia> collect(reshape(0:0.1:10, 1, 101)); 1101 Matrix{Float64}:; 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.1 1.2  8.9 9.0 9.1 9.2 9.3 9.4 9.5 9.6 9.7 9.8 9.9 10.0; ```. so we might have, depending on the width of the display:. ```julia; 11101 RectilinearGrid{Float64} on CPU with topology (Flat, Flat, Bounded) and 001 halo; z faces: [0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9  9.2 9.3 9.4 9.5 9.6 9.7 9.8 9.9 10.0]; ```. etc. Or, putting a ""domain summary"" out front, something like. ```julia; 11101 RectilinearGrid{Float64} on CPU with topology (Flat, Flat, Bounded) and 001 halo; z  [0.0, 10.0] with faces [0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7  9.4 9.5 9.6 9.7 9.8 9.9 10.0]; ```. We can do something similar for spacings, though as others have noted I think it is useful to show _statistics_ rather than list all the values for that case. We probably want to indicate whether we are talking about spacings at Center or Face, so. ```julia; z spacings: stretched with minimum(z) = 0.2, maximum(z) = 0.5; ```. is an option.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2064#issuecomment-971870818
https://github.com/CliMA/Oceananigans.jl/issues/2064#issuecomment-1012213458:2,Deployability,update,updated,2,"I updated the title to broaden the issue to include show for `Field`. @simone-silvestri suggests on #2121 that we also include some information about field _values_, like for example maximum and minimum, or mean (or even just print the whole array for small / reduced fields).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2064#issuecomment-1012213458
https://github.com/CliMA/Oceananigans.jl/issues/2064#issuecomment-1012213458:260,Energy Efficiency,reduce,reduced,260,"I updated the title to broaden the issue to include show for `Field`. @simone-silvestri suggests on #2121 that we also include some information about field _values_, like for example maximum and minimum, or mean (or even just print the whole array for small / reduced fields).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2064#issuecomment-1012213458
https://github.com/CliMA/Oceananigans.jl/issues/2065#issuecomment-973700892:419,Energy Efficiency,adapt,adapt,419,@jm-c there are two `ivd_diagonal` functions --- which one do you mean? Here are the two:. https://github.com/CliMA/Oceananigans.jl/blob/02f4d9dc17293a399ca3adf68b6de71ee7d59f16/src/TurbulenceClosures/vertically_implicit_diffusion_solver.jl#L52-L59. https://github.com/CliMA/Oceananigans.jl/blob/02f4d9dc17293a399ca3adf68b6de71ee7d59f16/src/TurbulenceClosures/vertically_implicit_diffusion_solver.jl#L75-L82. We should adapt this dynamics test:. https://github.com/CliMA/Oceananigans.jl/blob/02f4d9dc17293a399ca3adf68b6de71ee7d59f16/test/test_dynamics.jl#L447. to use a vertically-stretched grid. Hopefully that would isolate this issue.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2065#issuecomment-973700892
https://github.com/CliMA/Oceananigans.jl/issues/2065#issuecomment-973700892:419,Modifiability,adapt,adapt,419,@jm-c there are two `ivd_diagonal` functions --- which one do you mean? Here are the two:. https://github.com/CliMA/Oceananigans.jl/blob/02f4d9dc17293a399ca3adf68b6de71ee7d59f16/src/TurbulenceClosures/vertically_implicit_diffusion_solver.jl#L52-L59. https://github.com/CliMA/Oceananigans.jl/blob/02f4d9dc17293a399ca3adf68b6de71ee7d59f16/src/TurbulenceClosures/vertically_implicit_diffusion_solver.jl#L75-L82. We should adapt this dynamics test:. https://github.com/CliMA/Oceananigans.jl/blob/02f4d9dc17293a399ca3adf68b6de71ee7d59f16/test/test_dynamics.jl#L447. to use a vertically-stretched grid. Hopefully that would isolate this issue.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2065#issuecomment-973700892
https://github.com/CliMA/Oceananigans.jl/issues/2065#issuecomment-973700892:439,Testability,test,test,439,@jm-c there are two `ivd_diagonal` functions --- which one do you mean? Here are the two:. https://github.com/CliMA/Oceananigans.jl/blob/02f4d9dc17293a399ca3adf68b6de71ee7d59f16/src/TurbulenceClosures/vertically_implicit_diffusion_solver.jl#L52-L59. https://github.com/CliMA/Oceananigans.jl/blob/02f4d9dc17293a399ca3adf68b6de71ee7d59f16/src/TurbulenceClosures/vertically_implicit_diffusion_solver.jl#L75-L82. We should adapt this dynamics test:. https://github.com/CliMA/Oceananigans.jl/blob/02f4d9dc17293a399ca3adf68b6de71ee7d59f16/test/test_dynamics.jl#L447. to use a vertically-stretched grid. Hopefully that would isolate this issue.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2065#issuecomment-973700892
https://github.com/CliMA/Oceananigans.jl/issues/2065#issuecomment-973700892:533,Testability,test,test,533,@jm-c there are two `ivd_diagonal` functions --- which one do you mean? Here are the two:. https://github.com/CliMA/Oceananigans.jl/blob/02f4d9dc17293a399ca3adf68b6de71ee7d59f16/src/TurbulenceClosures/vertically_implicit_diffusion_solver.jl#L52-L59. https://github.com/CliMA/Oceananigans.jl/blob/02f4d9dc17293a399ca3adf68b6de71ee7d59f16/src/TurbulenceClosures/vertically_implicit_diffusion_solver.jl#L75-L82. We should adapt this dynamics test:. https://github.com/CliMA/Oceananigans.jl/blob/02f4d9dc17293a399ca3adf68b6de71ee7d59f16/test/test_dynamics.jl#L447. to use a vertically-stretched grid. Hopefully that would isolate this issue.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2065#issuecomment-973700892
https://github.com/CliMA/Oceananigans.jl/issues/2065#issuecomment-973702664:153,Usability,simpl,simpler,153,"> I don't really know what this comment: ""# Shift to adjust for Tridiagonal indexing convenction"" means: Does this means that we don't pick one of the 2 simpler conventions for indexing the tri-diagonal coeff, i.e, either by line/row or by columns ?. I believe this refers to the fact that julia's `Tridiagonal` (whose conventions are followed in the `BatchedTridiagonalSolver`) has three vectors: `d` (diagonal), `du` (upper diagonal) and `dl` (lower diagonal). `d` has length `N`, but `du` and `dl` both have length `N-1`. So for example the matrix component ""1, 2"" is index `1` in the lower diagonal vector (rather than index 2) --- I think?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2065#issuecomment-973702664
https://github.com/CliMA/Oceananigans.jl/issues/2065#issuecomment-974374336:19,Testability,test,test,19,"I'll work on a new test that catches this bug, then we can try to fix it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2065#issuecomment-974374336
https://github.com/CliMA/Oceananigans.jl/issues/2067#issuecomment-973673941:200,Performance,optimiz,optimization,200,"I was wondering if we can regrid in 3D simply by regridding in each dimension in serial. Eg first regrid in x, then, y, then z. It'll be a bit more computation, but we still have the option of future optimization...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2067#issuecomment-973673941
https://github.com/CliMA/Oceananigans.jl/issues/2067#issuecomment-973673941:39,Usability,simpl,simply,39,"I was wondering if we can regrid in 3D simply by regridding in each dimension in serial. Eg first regrid in x, then, y, then z. It'll be a bit more computation, but we still have the option of future optimization...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2067#issuecomment-973673941
https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974594023:29,Integrability,depend,depend,29,"I think having `Distributed` depend on `Models` was intentional. Basically, the design is that the main code is written for single process modules; and `Distributed` simply provides some replacements for functions that are needed for distributed computations without interferring in the core algorithm. This represents a break from other code designs that weave particularities to distributed model deep into the code. What do you think about this?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974594023
https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974594023:166,Usability,simpl,simply,166,"I think having `Distributed` depend on `Models` was intentional. Basically, the design is that the main code is written for single process modules; and `Distributed` simply provides some replacements for functions that are needed for distributed computations without interferring in the core algorithm. This represents a break from other code designs that weave particularities to distributed model deep into the code. What do you think about this?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974594023
https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974594129:68,Integrability,depend,depend,68,"Maybe just to help you could explain the reason why `Models` should depend on `Distributed`?. In reality I think models shouldn't know anything about `architecture`. I think ideally we write architecture-agnostic code, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974594129
https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974594690:905,Integrability,depend,depend,905,"I looked briefly at the code but don't understand it fully. However, I didn't see a construction that I was expecting. I think we need grid constructors that take `architecture` as a positional argument:. ```julia; RectilinearGrid(arch=CPU(); keyword_arguments...) = ...; ```. Then, the `Distributed` module needs to define special grid constructors that dispatch on `architecture::MultiArchitecture`. These constructors will return only the _local_ grid for each process. This pattern will allow us to avoid having to define things like `DistributedNonhydrostaticModel`, etc. Perhaps this will allow us to achieve the pattern that you're referring to @simone-silvestri where `Distributed` has precedence over `Models`. I guess if we were to fracture the Oceananigans repo into ""finite volume specific code"" and ""physics specific code"", it certainly would be the case that the physics specific code would depend on the finite volume utilities.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974594690
https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974594690:503,Safety,avoid,avoid,503,"I looked briefly at the code but don't understand it fully. However, I didn't see a construction that I was expecting. I think we need grid constructors that take `architecture` as a positional argument:. ```julia; RectilinearGrid(arch=CPU(); keyword_arguments...) = ...; ```. Then, the `Distributed` module needs to define special grid constructors that dispatch on `architecture::MultiArchitecture`. These constructors will return only the _local_ grid for each process. This pattern will allow us to avoid having to define things like `DistributedNonhydrostaticModel`, etc. Perhaps this will allow us to achieve the pattern that you're referring to @simone-silvestri where `Distributed` has precedence over `Models`. I guess if we were to fracture the Oceananigans repo into ""finite volume specific code"" and ""physics specific code"", it certainly would be the case that the physics specific code would depend on the finite volume utilities.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974594690
https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974595489:38,Integrability,depend,depend,38,"Why does `BoundaryConditions` need to depend on `Distributed`? I think `Distributed` needs to _extend_ `fill_halo_regions!`. For this, `Distributed` must come _after_ `BoundaryConditions`. I also think that `Distributed` needs to come after `Field`; and `Field` depends on `BoundaryConditions`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974595489
https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974595489:262,Integrability,depend,depends,262,"Why does `BoundaryConditions` need to depend on `Distributed`? I think `Distributed` needs to _extend_ `fill_halo_regions!`. For this, `Distributed` must come _after_ `BoundaryConditions`. I also think that `Distributed` needs to come after `Field`; and `Field` depends on `BoundaryConditions`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974595489
https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724:870,Deployability,integrat,integrating,870,"@glwagner the idea is that the flow of the script for a user would be something like this:. (1) define a grid; (2) choose an architecture; .; .; code does not change from here on; .; . for this reason I was thinking you cannot have a `DistributedNonhydrostaticModel` vs a `NonhydrostaticModel` as much as you don't have a `CPUNonhydrostaticModel` vs a `GPUNonhydrostaticModel`. About the future direction: I was thinking that `Distributed` could be as much of an architecture as `CPU` and `GPU` are. As an example, there is no GPU.jl module which individually extends all the other modules for gpu execution like the extending the Fields.jl module with a `gpu_fields.jl` in GPU.jl. But I see what you mean when you say boundary conditions and fields have to take the precedence over distributed because it is maybe more linear to extend them in a separate module. Maybe integrating fields and boundary conditions in the respective modules (how is done for CPU and GPU which are not separated) for Distributed might make the code a little too complex and keeping it separate is the way to go. I am all up for that. . Now, discussing the `architecture` vs `grid` problem, step (1) and (2) are interlocked, and choosing which goes first (i.e. grid depend on architecture or other way around?) will make a big difference. At the moment they are kind of independent one another (i.e. some `grids` have an `architecture` field, distributed architecture depends on a grid). . In the future I believe we don't want to have the users fiddling with local_ and parent_ grids. I believe you want them to specify the parent grid, an architecture, and the code takes care of the rest. To achieve that, either a copy of the local or parent grid has to be stored in the architecture type when running `MultiArch`. For the constructor you where talking about `RectilinearGrid(arch=MultiArch; kwargs...)` which returns the local grid, we can do that, but the problem is that the connectivity of the architecture depends",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724
https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724:3084,Energy Efficiency,allocate,allocate,3084,"t the architecture you would incur in a user code which looks something like ; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...); local_grid = RectilinearGrid(arch; kwargs...); ; NonhydrostaticModel(arch, parent_grid (for pressure solver), local_grid); ```; (which could be avoided by eliminating the `Periodic` topology which I am all in favour of but maybe is a too much of a deep change) in the end you still have to pass two grids to the `NonhydrostaticModel`. I was thinking, to avoid this pattern for the user, we have two options; (1) store the local grid in the architecture, and take it within the model if `arch == MultiArch` then you can do this; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...) # interchangeable with CPU() or GPU(). NonhydrostaticModel(arch, parent_grid); ```; The problem now is the fields. Ideally you want to have the fields know that they are on a `MultiArch` so that they don't allocate the whole memory field on all the processes, so you would want them to allocate on `arch.local_grid` if the the arch is Distributed... (2) the other way around where `arch` stores the parent grid then you would have; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...); grid = local_grids(arch, parent_grid) # where local_grids(::CPU(), grid) = grid and local_grids(::GPU(), grid) = grid. # from here on out you can ""forget"" about the parent_grid. NonhydrostaticModel(arch, grid); ```. Which, maybe, despite the additional local_grids call, is a better option as you wouldn't have to change the Fields module. Also, the NonhydrostaticModel will become ""agnostic"" to the architecture in this way. Actually maybe this direction is much better (I will change the PR to reflect this option)... In the end, what do you think? How should we solve this `grid` vs `architecture` conundrum avoiding the definition of a `DistributedModel`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724
https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724:3164,Energy Efficiency,allocate,allocate,3164,"t the architecture you would incur in a user code which looks something like ; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...); local_grid = RectilinearGrid(arch; kwargs...); ; NonhydrostaticModel(arch, parent_grid (for pressure solver), local_grid); ```; (which could be avoided by eliminating the `Periodic` topology which I am all in favour of but maybe is a too much of a deep change) in the end you still have to pass two grids to the `NonhydrostaticModel`. I was thinking, to avoid this pattern for the user, we have two options; (1) store the local grid in the architecture, and take it within the model if `arch == MultiArch` then you can do this; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...) # interchangeable with CPU() or GPU(). NonhydrostaticModel(arch, parent_grid); ```; The problem now is the fields. Ideally you want to have the fields know that they are on a `MultiArch` so that they don't allocate the whole memory field on all the processes, so you would want them to allocate on `arch.local_grid` if the the arch is Distributed... (2) the other way around where `arch` stores the parent grid then you would have; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...); grid = local_grids(arch, parent_grid) # where local_grids(::CPU(), grid) = grid and local_grids(::GPU(), grid) = grid. # from here on out you can ""forget"" about the parent_grid. NonhydrostaticModel(arch, grid); ```. Which, maybe, despite the additional local_grids call, is a better option as you wouldn't have to change the Fields module. Also, the NonhydrostaticModel will become ""agnostic"" to the architecture in this way. Actually maybe this direction is much better (I will change the PR to reflect this option)... In the end, what do you think? How should we solve this `grid` vs `architecture` conundrum avoiding the definition of a `DistributedModel`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724
https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724:870,Integrability,integrat,integrating,870,"@glwagner the idea is that the flow of the script for a user would be something like this:. (1) define a grid; (2) choose an architecture; .; .; code does not change from here on; .; . for this reason I was thinking you cannot have a `DistributedNonhydrostaticModel` vs a `NonhydrostaticModel` as much as you don't have a `CPUNonhydrostaticModel` vs a `GPUNonhydrostaticModel`. About the future direction: I was thinking that `Distributed` could be as much of an architecture as `CPU` and `GPU` are. As an example, there is no GPU.jl module which individually extends all the other modules for gpu execution like the extending the Fields.jl module with a `gpu_fields.jl` in GPU.jl. But I see what you mean when you say boundary conditions and fields have to take the precedence over distributed because it is maybe more linear to extend them in a separate module. Maybe integrating fields and boundary conditions in the respective modules (how is done for CPU and GPU which are not separated) for Distributed might make the code a little too complex and keeping it separate is the way to go. I am all up for that. . Now, discussing the `architecture` vs `grid` problem, step (1) and (2) are interlocked, and choosing which goes first (i.e. grid depend on architecture or other way around?) will make a big difference. At the moment they are kind of independent one another (i.e. some `grids` have an `architecture` field, distributed architecture depends on a grid). . In the future I believe we don't want to have the users fiddling with local_ and parent_ grids. I believe you want them to specify the parent grid, an architecture, and the code takes care of the rest. To achieve that, either a copy of the local or parent grid has to be stored in the architecture type when running `MultiArch`. For the constructor you where talking about `RectilinearGrid(arch=MultiArch; kwargs...)` which returns the local grid, we can do that, but the problem is that the connectivity of the architecture depends",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724
https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724:1245,Integrability,depend,depend,1245,"drostaticModel` as much as you don't have a `CPUNonhydrostaticModel` vs a `GPUNonhydrostaticModel`. About the future direction: I was thinking that `Distributed` could be as much of an architecture as `CPU` and `GPU` are. As an example, there is no GPU.jl module which individually extends all the other modules for gpu execution like the extending the Fields.jl module with a `gpu_fields.jl` in GPU.jl. But I see what you mean when you say boundary conditions and fields have to take the precedence over distributed because it is maybe more linear to extend them in a separate module. Maybe integrating fields and boundary conditions in the respective modules (how is done for CPU and GPU which are not separated) for Distributed might make the code a little too complex and keeping it separate is the way to go. I am all up for that. . Now, discussing the `architecture` vs `grid` problem, step (1) and (2) are interlocked, and choosing which goes first (i.e. grid depend on architecture or other way around?) will make a big difference. At the moment they are kind of independent one another (i.e. some `grids` have an `architecture` field, distributed architecture depends on a grid). . In the future I believe we don't want to have the users fiddling with local_ and parent_ grids. I believe you want them to specify the parent grid, an architecture, and the code takes care of the rest. To achieve that, either a copy of the local or parent grid has to be stored in the architecture type when running `MultiArch`. For the constructor you where talking about `RectilinearGrid(arch=MultiArch; kwargs...)` which returns the local grid, we can do that, but the problem is that the connectivity of the architecture depends on the topology of the grid. If then the models should not know about the architecture you would incur in a user code which looks something like ; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...); local_grid = RectilinearGrid",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724
https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724:1447,Integrability,depend,depends,1447,"hat `Distributed` could be as much of an architecture as `CPU` and `GPU` are. As an example, there is no GPU.jl module which individually extends all the other modules for gpu execution like the extending the Fields.jl module with a `gpu_fields.jl` in GPU.jl. But I see what you mean when you say boundary conditions and fields have to take the precedence over distributed because it is maybe more linear to extend them in a separate module. Maybe integrating fields and boundary conditions in the respective modules (how is done for CPU and GPU which are not separated) for Distributed might make the code a little too complex and keeping it separate is the way to go. I am all up for that. . Now, discussing the `architecture` vs `grid` problem, step (1) and (2) are interlocked, and choosing which goes first (i.e. grid depend on architecture or other way around?) will make a big difference. At the moment they are kind of independent one another (i.e. some `grids` have an `architecture` field, distributed architecture depends on a grid). . In the future I believe we don't want to have the users fiddling with local_ and parent_ grids. I believe you want them to specify the parent grid, an architecture, and the code takes care of the rest. To achieve that, either a copy of the local or parent grid has to be stored in the architecture type when running `MultiArch`. For the constructor you where talking about `RectilinearGrid(arch=MultiArch; kwargs...)` which returns the local grid, we can do that, but the problem is that the connectivity of the architecture depends on the topology of the grid. If then the models should not know about the architecture you would incur in a user code which looks something like ; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...); local_grid = RectilinearGrid(arch; kwargs...); ; NonhydrostaticModel(arch, parent_grid (for pressure solver), local_grid); ```; (which could be avoided by eliminating the `",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724
https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724:1994,Integrability,depend,depends,1994,"PU and GPU which are not separated) for Distributed might make the code a little too complex and keeping it separate is the way to go. I am all up for that. . Now, discussing the `architecture` vs `grid` problem, step (1) and (2) are interlocked, and choosing which goes first (i.e. grid depend on architecture or other way around?) will make a big difference. At the moment they are kind of independent one another (i.e. some `grids` have an `architecture` field, distributed architecture depends on a grid). . In the future I believe we don't want to have the users fiddling with local_ and parent_ grids. I believe you want them to specify the parent grid, an architecture, and the code takes care of the rest. To achieve that, either a copy of the local or parent grid has to be stored in the architecture type when running `MultiArch`. For the constructor you where talking about `RectilinearGrid(arch=MultiArch; kwargs...)` which returns the local grid, we can do that, but the problem is that the connectivity of the architecture depends on the topology of the grid. If then the models should not know about the architecture you would incur in a user code which looks something like ; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...); local_grid = RectilinearGrid(arch; kwargs...); ; NonhydrostaticModel(arch, parent_grid (for pressure solver), local_grid); ```; (which could be avoided by eliminating the `Periodic` topology which I am all in favour of but maybe is a too much of a deep change) in the end you still have to pass two grids to the `NonhydrostaticModel`. I was thinking, to avoid this pattern for the user, we have two options; (1) store the local grid in the architecture, and take it within the model if `arch == MultiArch` then you can do this; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...) # interchangeable with CPU() or GPU(). NonhydrostaticModel(arch, parent_grid); ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724
https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724:560,Modifiability,extend,extends,560,"@glwagner the idea is that the flow of the script for a user would be something like this:. (1) define a grid; (2) choose an architecture; .; .; code does not change from here on; .; . for this reason I was thinking you cannot have a `DistributedNonhydrostaticModel` vs a `NonhydrostaticModel` as much as you don't have a `CPUNonhydrostaticModel` vs a `GPUNonhydrostaticModel`. About the future direction: I was thinking that `Distributed` could be as much of an architecture as `CPU` and `GPU` are. As an example, there is no GPU.jl module which individually extends all the other modules for gpu execution like the extending the Fields.jl module with a `gpu_fields.jl` in GPU.jl. But I see what you mean when you say boundary conditions and fields have to take the precedence over distributed because it is maybe more linear to extend them in a separate module. Maybe integrating fields and boundary conditions in the respective modules (how is done for CPU and GPU which are not separated) for Distributed might make the code a little too complex and keeping it separate is the way to go. I am all up for that. . Now, discussing the `architecture` vs `grid` problem, step (1) and (2) are interlocked, and choosing which goes first (i.e. grid depend on architecture or other way around?) will make a big difference. At the moment they are kind of independent one another (i.e. some `grids` have an `architecture` field, distributed architecture depends on a grid). . In the future I believe we don't want to have the users fiddling with local_ and parent_ grids. I believe you want them to specify the parent grid, an architecture, and the code takes care of the rest. To achieve that, either a copy of the local or parent grid has to be stored in the architecture type when running `MultiArch`. For the constructor you where talking about `RectilinearGrid(arch=MultiArch; kwargs...)` which returns the local grid, we can do that, but the problem is that the connectivity of the architecture depends",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724
https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724:617,Modifiability,extend,extending,617,"@glwagner the idea is that the flow of the script for a user would be something like this:. (1) define a grid; (2) choose an architecture; .; .; code does not change from here on; .; . for this reason I was thinking you cannot have a `DistributedNonhydrostaticModel` vs a `NonhydrostaticModel` as much as you don't have a `CPUNonhydrostaticModel` vs a `GPUNonhydrostaticModel`. About the future direction: I was thinking that `Distributed` could be as much of an architecture as `CPU` and `GPU` are. As an example, there is no GPU.jl module which individually extends all the other modules for gpu execution like the extending the Fields.jl module with a `gpu_fields.jl` in GPU.jl. But I see what you mean when you say boundary conditions and fields have to take the precedence over distributed because it is maybe more linear to extend them in a separate module. Maybe integrating fields and boundary conditions in the respective modules (how is done for CPU and GPU which are not separated) for Distributed might make the code a little too complex and keeping it separate is the way to go. I am all up for that. . Now, discussing the `architecture` vs `grid` problem, step (1) and (2) are interlocked, and choosing which goes first (i.e. grid depend on architecture or other way around?) will make a big difference. At the moment they are kind of independent one another (i.e. some `grids` have an `architecture` field, distributed architecture depends on a grid). . In the future I believe we don't want to have the users fiddling with local_ and parent_ grids. I believe you want them to specify the parent grid, an architecture, and the code takes care of the rest. To achieve that, either a copy of the local or parent grid has to be stored in the architecture type when running `MultiArch`. For the constructor you where talking about `RectilinearGrid(arch=MultiArch; kwargs...)` which returns the local grid, we can do that, but the problem is that the connectivity of the architecture depends",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724
https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724:830,Modifiability,extend,extend,830,"@glwagner the idea is that the flow of the script for a user would be something like this:. (1) define a grid; (2) choose an architecture; .; .; code does not change from here on; .; . for this reason I was thinking you cannot have a `DistributedNonhydrostaticModel` vs a `NonhydrostaticModel` as much as you don't have a `CPUNonhydrostaticModel` vs a `GPUNonhydrostaticModel`. About the future direction: I was thinking that `Distributed` could be as much of an architecture as `CPU` and `GPU` are. As an example, there is no GPU.jl module which individually extends all the other modules for gpu execution like the extending the Fields.jl module with a `gpu_fields.jl` in GPU.jl. But I see what you mean when you say boundary conditions and fields have to take the precedence over distributed because it is maybe more linear to extend them in a separate module. Maybe integrating fields and boundary conditions in the respective modules (how is done for CPU and GPU which are not separated) for Distributed might make the code a little too complex and keeping it separate is the way to go. I am all up for that. . Now, discussing the `architecture` vs `grid` problem, step (1) and (2) are interlocked, and choosing which goes first (i.e. grid depend on architecture or other way around?) will make a big difference. At the moment they are kind of independent one another (i.e. some `grids` have an `architecture` field, distributed architecture depends on a grid). . In the future I believe we don't want to have the users fiddling with local_ and parent_ grids. I believe you want them to specify the parent grid, an architecture, and the code takes care of the rest. To achieve that, either a copy of the local or parent grid has to be stored in the architecture type when running `MultiArch`. For the constructor you where talking about `RectilinearGrid(arch=MultiArch; kwargs...)` which returns the local grid, we can do that, but the problem is that the connectivity of the architecture depends",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724
https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724:1191,Safety,interlock,interlocked,1191,"on; .; . for this reason I was thinking you cannot have a `DistributedNonhydrostaticModel` vs a `NonhydrostaticModel` as much as you don't have a `CPUNonhydrostaticModel` vs a `GPUNonhydrostaticModel`. About the future direction: I was thinking that `Distributed` could be as much of an architecture as `CPU` and `GPU` are. As an example, there is no GPU.jl module which individually extends all the other modules for gpu execution like the extending the Fields.jl module with a `gpu_fields.jl` in GPU.jl. But I see what you mean when you say boundary conditions and fields have to take the precedence over distributed because it is maybe more linear to extend them in a separate module. Maybe integrating fields and boundary conditions in the respective modules (how is done for CPU and GPU which are not separated) for Distributed might make the code a little too complex and keeping it separate is the way to go. I am all up for that. . Now, discussing the `architecture` vs `grid` problem, step (1) and (2) are interlocked, and choosing which goes first (i.e. grid depend on architecture or other way around?) will make a big difference. At the moment they are kind of independent one another (i.e. some `grids` have an `architecture` field, distributed architecture depends on a grid). . In the future I believe we don't want to have the users fiddling with local_ and parent_ grids. I believe you want them to specify the parent grid, an architecture, and the code takes care of the rest. To achieve that, either a copy of the local or parent grid has to be stored in the architecture type when running `MultiArch`. For the constructor you where talking about `RectilinearGrid(arch=MultiArch; kwargs...)` which returns the local grid, we can do that, but the problem is that the connectivity of the architecture depends on the topology of the grid. If then the models should not know about the architecture you would incur in a user code which looks something like ; ```; parent_grid = Rectilin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724
https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724:2394,Safety,avoid,avoided,2394,"tecture depends on a grid). . In the future I believe we don't want to have the users fiddling with local_ and parent_ grids. I believe you want them to specify the parent grid, an architecture, and the code takes care of the rest. To achieve that, either a copy of the local or parent grid has to be stored in the architecture type when running `MultiArch`. For the constructor you where talking about `RectilinearGrid(arch=MultiArch; kwargs...)` which returns the local grid, we can do that, but the problem is that the connectivity of the architecture depends on the topology of the grid. If then the models should not know about the architecture you would incur in a user code which looks something like ; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...); local_grid = RectilinearGrid(arch; kwargs...); ; NonhydrostaticModel(arch, parent_grid (for pressure solver), local_grid); ```; (which could be avoided by eliminating the `Periodic` topology which I am all in favour of but maybe is a too much of a deep change) in the end you still have to pass two grids to the `NonhydrostaticModel`. I was thinking, to avoid this pattern for the user, we have two options; (1) store the local grid in the architecture, and take it within the model if `arch == MultiArch` then you can do this; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...) # interchangeable with CPU() or GPU(). NonhydrostaticModel(arch, parent_grid); ```; The problem now is the fields. Ideally you want to have the fields know that they are on a `MultiArch` so that they don't allocate the whole memory field on all the processes, so you would want them to allocate on `arch.local_grid` if the the arch is Distributed... (2) the other way around where `arch` stores the parent grid then you would have; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...); grid = local_grids(arch, par",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724
https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724:2604,Safety,avoid,avoid,2604,"the local or parent grid has to be stored in the architecture type when running `MultiArch`. For the constructor you where talking about `RectilinearGrid(arch=MultiArch; kwargs...)` which returns the local grid, we can do that, but the problem is that the connectivity of the architecture depends on the topology of the grid. If then the models should not know about the architecture you would incur in a user code which looks something like ; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...); local_grid = RectilinearGrid(arch; kwargs...); ; NonhydrostaticModel(arch, parent_grid (for pressure solver), local_grid); ```; (which could be avoided by eliminating the `Periodic` topology which I am all in favour of but maybe is a too much of a deep change) in the end you still have to pass two grids to the `NonhydrostaticModel`. I was thinking, to avoid this pattern for the user, we have two options; (1) store the local grid in the architecture, and take it within the model if `arch == MultiArch` then you can do this; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...) # interchangeable with CPU() or GPU(). NonhydrostaticModel(arch, parent_grid); ```; The problem now is the fields. Ideally you want to have the fields know that they are on a `MultiArch` so that they don't allocate the whole memory field on all the processes, so you would want them to allocate on `arch.local_grid` if the the arch is Distributed... (2) the other way around where `arch` stores the parent grid then you would have; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...); grid = local_grids(arch, parent_grid) # where local_grids(::CPU(), grid) = grid and local_grids(::GPU(), grid) = grid. # from here on out you can ""forget"" about the parent_grid. NonhydrostaticModel(arch, grid); ```. Which, maybe, despite the additional local_grids call, is a better option as yo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724
https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724:4022,Safety,avoid,avoiding,4022,"t the architecture you would incur in a user code which looks something like ; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...); local_grid = RectilinearGrid(arch; kwargs...); ; NonhydrostaticModel(arch, parent_grid (for pressure solver), local_grid); ```; (which could be avoided by eliminating the `Periodic` topology which I am all in favour of but maybe is a too much of a deep change) in the end you still have to pass two grids to the `NonhydrostaticModel`. I was thinking, to avoid this pattern for the user, we have two options; (1) store the local grid in the architecture, and take it within the model if `arch == MultiArch` then you can do this; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...) # interchangeable with CPU() or GPU(). NonhydrostaticModel(arch, parent_grid); ```; The problem now is the fields. Ideally you want to have the fields know that they are on a `MultiArch` so that they don't allocate the whole memory field on all the processes, so you would want them to allocate on `arch.local_grid` if the the arch is Distributed... (2) the other way around where `arch` stores the parent grid then you would have; ```; parent_grid = RectilinearGrid(CPU(); kwargs...); arch = MultiArch(grid=parent_grid, kwargs...); grid = local_grids(arch, parent_grid) # where local_grids(::CPU(), grid) = grid and local_grids(::GPU(), grid) = grid. # from here on out you can ""forget"" about the parent_grid. NonhydrostaticModel(arch, grid); ```. Which, maybe, despite the additional local_grids call, is a better option as you wouldn't have to change the Fields module. Also, the NonhydrostaticModel will become ""agnostic"" to the architecture in this way. Actually maybe this direction is much better (I will change the PR to reflect this option)... In the end, what do you think? How should we solve this `grid` vs `architecture` conundrum avoiding the definition of a `DistributedModel`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724
https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724:1191,Security,interlock,interlocked,1191,"on; .; . for this reason I was thinking you cannot have a `DistributedNonhydrostaticModel` vs a `NonhydrostaticModel` as much as you don't have a `CPUNonhydrostaticModel` vs a `GPUNonhydrostaticModel`. About the future direction: I was thinking that `Distributed` could be as much of an architecture as `CPU` and `GPU` are. As an example, there is no GPU.jl module which individually extends all the other modules for gpu execution like the extending the Fields.jl module with a `gpu_fields.jl` in GPU.jl. But I see what you mean when you say boundary conditions and fields have to take the precedence over distributed because it is maybe more linear to extend them in a separate module. Maybe integrating fields and boundary conditions in the respective modules (how is done for CPU and GPU which are not separated) for Distributed might make the code a little too complex and keeping it separate is the way to go. I am all up for that. . Now, discussing the `architecture` vs `grid` problem, step (1) and (2) are interlocked, and choosing which goes first (i.e. grid depend on architecture or other way around?) will make a big difference. At the moment they are kind of independent one another (i.e. some `grids` have an `architecture` field, distributed architecture depends on a grid). . In the future I believe we don't want to have the users fiddling with local_ and parent_ grids. I believe you want them to specify the parent grid, an architecture, and the code takes care of the rest. To achieve that, either a copy of the local or parent grid has to be stored in the architecture type when running `MultiArch`. For the constructor you where talking about `RectilinearGrid(arch=MultiArch; kwargs...)` which returns the local grid, we can do that, but the problem is that the connectivity of the architecture depends on the topology of the grid. If then the models should not know about the architecture you would incur in a user code which looks something like ; ```; parent_grid = Rectilin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724
https://github.com/CliMA/Oceananigans.jl/issues/2077#issuecomment-975486083:19,Deployability,update,updated,19,For example if you updated Oceananigans.jl from a version `0.X.any` to a version `0.X+1.any` then there will be breaking changes.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2077#issuecomment-975486083
https://github.com/CliMA/Oceananigans.jl/pull/2079#issuecomment-978075603:79,Testability,test,test,79,Finally found the correct settings after discussing with @ali-ramadhan ; Added test for `Nx != Ny` I'll merge when tests pass,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2079#issuecomment-978075603
https://github.com/CliMA/Oceananigans.jl/pull/2079#issuecomment-978075603:115,Testability,test,tests,115,Finally found the correct settings after discussing with @ali-ramadhan ; Added test for `Nx != Ny` I'll merge when tests pass,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2079#issuecomment-978075603
https://github.com/CliMA/Oceananigans.jl/issues/2080#issuecomment-979912506:64,Security,access,access,64,"Thanks for opening this!. I don't have a lot of server/internet access right now so I can't properly test this, but using `.* Warning.*\n` and `.* @ Oceananigans.*\n` seems to work. You can test things out here: https://regexr.com/. Also, it seems like there's an extra quote in your regex line?. `DocTestFilters = [Regex(""Warning: defaulting""), Regex(""Oceananigans.Advection"")""]` . maybe should be. `DocTestFilters = [Regex(""Warning: defaulting""), Regex(""Oceananigans.Advection"")]`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2080#issuecomment-979912506
https://github.com/CliMA/Oceananigans.jl/issues/2080#issuecomment-979912506:101,Testability,test,test,101,"Thanks for opening this!. I don't have a lot of server/internet access right now so I can't properly test this, but using `.* Warning.*\n` and `.* @ Oceananigans.*\n` seems to work. You can test things out here: https://regexr.com/. Also, it seems like there's an extra quote in your regex line?. `DocTestFilters = [Regex(""Warning: defaulting""), Regex(""Oceananigans.Advection"")""]` . maybe should be. `DocTestFilters = [Regex(""Warning: defaulting""), Regex(""Oceananigans.Advection"")]`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2080#issuecomment-979912506
https://github.com/CliMA/Oceananigans.jl/issues/2080#issuecomment-979912506:192,Testability,test,test,192,"Thanks for opening this!. I don't have a lot of server/internet access right now so I can't properly test this, but using `.* Warning.*\n` and `.* @ Oceananigans.*\n` seems to work. You can test things out here: https://regexr.com/. Also, it seems like there's an extra quote in your regex line?. `DocTestFilters = [Regex(""Warning: defaulting""), Regex(""Oceananigans.Advection"")""]` . maybe should be. `DocTestFilters = [Regex(""Warning: defaulting""), Regex(""Oceananigans.Advection"")]`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2080#issuecomment-979912506
https://github.com/CliMA/Oceananigans.jl/pull/2083#issuecomment-981525228:149,Safety,predict,prediction,149,"Just so I understand this filtering thing. It doesn't remove the regex-filtered lines from the output; it just doesn't test those lines against the ""prediction"", right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2083#issuecomment-981525228
https://github.com/CliMA/Oceananigans.jl/pull/2083#issuecomment-981525228:119,Testability,test,test,119,"Just so I understand this filtering thing. It doesn't remove the regex-filtered lines from the output; it just doesn't test those lines against the ""prediction"", right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2083#issuecomment-981525228
https://github.com/CliMA/Oceananigans.jl/pull/2083#issuecomment-982048875:151,Safety,predict,prediction,151,"> Just so I understand this filtering thing. It doesn't remove the regex-filtered lines from the output; it just doesn't test those lines against the ""prediction"", right?. Yeap!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2083#issuecomment-982048875
https://github.com/CliMA/Oceananigans.jl/pull/2083#issuecomment-982048875:121,Testability,test,test,121,"> Just so I understand this filtering thing. It doesn't remove the regex-filtered lines from the output; it just doesn't test those lines against the ""prediction"", right?. Yeap!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2083#issuecomment-982048875
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982852359:46,Availability,checkpoint,checkpointer,46,Perhaps the feature being asked for here is a checkpointer that avoids writing NaNs --- is that correct?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982852359
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982852359:64,Safety,avoid,avoids,64,Perhaps the feature being asked for here is a checkpointer that avoids writing NaNs --- is that correct?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982852359
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982864949:32,Availability,error,error,32,"We could certainly add a field `error` to `NaNChecker` and throw an error if `error=true`, too. Another possibility though is to design a new `schedule` that doesn't actuate if NaNs are detected. This could be used generically for output writing and checkpointing. Maybe a wrapper like. ```julia; schedule = Skip(hasnan, TimeInterval(100)); ```. Then when the scheduled is queried, if `hasnan(model)` is true, the actuator returns false; otherwise the ""child schedule"" (`TimeInterval(100)` in this case) is queried. Other ""skip conditions"" could be provided to `Skip` as well. I think the nice thing about this solution is that it's more robust than hoping the NaNChecker wil throw an error. Relying on an error from `NaNChecker` only works if the iteration interval for the checkpointer is a multiple of the iteration interval used for the NaNChecker. Otherwise users can still get NaNs in their checkpoint even when using NaNChecker.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982864949
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982864949:68,Availability,error,error,68,"We could certainly add a field `error` to `NaNChecker` and throw an error if `error=true`, too. Another possibility though is to design a new `schedule` that doesn't actuate if NaNs are detected. This could be used generically for output writing and checkpointing. Maybe a wrapper like. ```julia; schedule = Skip(hasnan, TimeInterval(100)); ```. Then when the scheduled is queried, if `hasnan(model)` is true, the actuator returns false; otherwise the ""child schedule"" (`TimeInterval(100)` in this case) is queried. Other ""skip conditions"" could be provided to `Skip` as well. I think the nice thing about this solution is that it's more robust than hoping the NaNChecker wil throw an error. Relying on an error from `NaNChecker` only works if the iteration interval for the checkpointer is a multiple of the iteration interval used for the NaNChecker. Otherwise users can still get NaNs in their checkpoint even when using NaNChecker.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982864949
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982864949:78,Availability,error,error,78,"We could certainly add a field `error` to `NaNChecker` and throw an error if `error=true`, too. Another possibility though is to design a new `schedule` that doesn't actuate if NaNs are detected. This could be used generically for output writing and checkpointing. Maybe a wrapper like. ```julia; schedule = Skip(hasnan, TimeInterval(100)); ```. Then when the scheduled is queried, if `hasnan(model)` is true, the actuator returns false; otherwise the ""child schedule"" (`TimeInterval(100)` in this case) is queried. Other ""skip conditions"" could be provided to `Skip` as well. I think the nice thing about this solution is that it's more robust than hoping the NaNChecker wil throw an error. Relying on an error from `NaNChecker` only works if the iteration interval for the checkpointer is a multiple of the iteration interval used for the NaNChecker. Otherwise users can still get NaNs in their checkpoint even when using NaNChecker.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982864949
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982864949:250,Availability,checkpoint,checkpointing,250,"We could certainly add a field `error` to `NaNChecker` and throw an error if `error=true`, too. Another possibility though is to design a new `schedule` that doesn't actuate if NaNs are detected. This could be used generically for output writing and checkpointing. Maybe a wrapper like. ```julia; schedule = Skip(hasnan, TimeInterval(100)); ```. Then when the scheduled is queried, if `hasnan(model)` is true, the actuator returns false; otherwise the ""child schedule"" (`TimeInterval(100)` in this case) is queried. Other ""skip conditions"" could be provided to `Skip` as well. I think the nice thing about this solution is that it's more robust than hoping the NaNChecker wil throw an error. Relying on an error from `NaNChecker` only works if the iteration interval for the checkpointer is a multiple of the iteration interval used for the NaNChecker. Otherwise users can still get NaNs in their checkpoint even when using NaNChecker.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982864949
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982864949:638,Availability,robust,robust,638,"We could certainly add a field `error` to `NaNChecker` and throw an error if `error=true`, too. Another possibility though is to design a new `schedule` that doesn't actuate if NaNs are detected. This could be used generically for output writing and checkpointing. Maybe a wrapper like. ```julia; schedule = Skip(hasnan, TimeInterval(100)); ```. Then when the scheduled is queried, if `hasnan(model)` is true, the actuator returns false; otherwise the ""child schedule"" (`TimeInterval(100)` in this case) is queried. Other ""skip conditions"" could be provided to `Skip` as well. I think the nice thing about this solution is that it's more robust than hoping the NaNChecker wil throw an error. Relying on an error from `NaNChecker` only works if the iteration interval for the checkpointer is a multiple of the iteration interval used for the NaNChecker. Otherwise users can still get NaNs in their checkpoint even when using NaNChecker.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982864949
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982864949:685,Availability,error,error,685,"We could certainly add a field `error` to `NaNChecker` and throw an error if `error=true`, too. Another possibility though is to design a new `schedule` that doesn't actuate if NaNs are detected. This could be used generically for output writing and checkpointing. Maybe a wrapper like. ```julia; schedule = Skip(hasnan, TimeInterval(100)); ```. Then when the scheduled is queried, if `hasnan(model)` is true, the actuator returns false; otherwise the ""child schedule"" (`TimeInterval(100)` in this case) is queried. Other ""skip conditions"" could be provided to `Skip` as well. I think the nice thing about this solution is that it's more robust than hoping the NaNChecker wil throw an error. Relying on an error from `NaNChecker` only works if the iteration interval for the checkpointer is a multiple of the iteration interval used for the NaNChecker. Otherwise users can still get NaNs in their checkpoint even when using NaNChecker.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982864949
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982864949:706,Availability,error,error,706,"We could certainly add a field `error` to `NaNChecker` and throw an error if `error=true`, too. Another possibility though is to design a new `schedule` that doesn't actuate if NaNs are detected. This could be used generically for output writing and checkpointing. Maybe a wrapper like. ```julia; schedule = Skip(hasnan, TimeInterval(100)); ```. Then when the scheduled is queried, if `hasnan(model)` is true, the actuator returns false; otherwise the ""child schedule"" (`TimeInterval(100)` in this case) is queried. Other ""skip conditions"" could be provided to `Skip` as well. I think the nice thing about this solution is that it's more robust than hoping the NaNChecker wil throw an error. Relying on an error from `NaNChecker` only works if the iteration interval for the checkpointer is a multiple of the iteration interval used for the NaNChecker. Otherwise users can still get NaNs in their checkpoint even when using NaNChecker.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982864949
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982864949:775,Availability,checkpoint,checkpointer,775,"We could certainly add a field `error` to `NaNChecker` and throw an error if `error=true`, too. Another possibility though is to design a new `schedule` that doesn't actuate if NaNs are detected. This could be used generically for output writing and checkpointing. Maybe a wrapper like. ```julia; schedule = Skip(hasnan, TimeInterval(100)); ```. Then when the scheduled is queried, if `hasnan(model)` is true, the actuator returns false; otherwise the ""child schedule"" (`TimeInterval(100)` in this case) is queried. Other ""skip conditions"" could be provided to `Skip` as well. I think the nice thing about this solution is that it's more robust than hoping the NaNChecker wil throw an error. Relying on an error from `NaNChecker` only works if the iteration interval for the checkpointer is a multiple of the iteration interval used for the NaNChecker. Otherwise users can still get NaNs in their checkpoint even when using NaNChecker.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982864949
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982864949:897,Availability,checkpoint,checkpoint,897,"We could certainly add a field `error` to `NaNChecker` and throw an error if `error=true`, too. Another possibility though is to design a new `schedule` that doesn't actuate if NaNs are detected. This could be used generically for output writing and checkpointing. Maybe a wrapper like. ```julia; schedule = Skip(hasnan, TimeInterval(100)); ```. Then when the scheduled is queried, if `hasnan(model)` is true, the actuator returns false; otherwise the ""child schedule"" (`TimeInterval(100)` in this case) is queried. Other ""skip conditions"" could be provided to `Skip` as well. I think the nice thing about this solution is that it's more robust than hoping the NaNChecker wil throw an error. Relying on an error from `NaNChecker` only works if the iteration interval for the checkpointer is a multiple of the iteration interval used for the NaNChecker. Otherwise users can still get NaNs in their checkpoint even when using NaNChecker.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982864949
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982864949:143,Energy Efficiency,schedul,schedule,143,"We could certainly add a field `error` to `NaNChecker` and throw an error if `error=true`, too. Another possibility though is to design a new `schedule` that doesn't actuate if NaNs are detected. This could be used generically for output writing and checkpointing. Maybe a wrapper like. ```julia; schedule = Skip(hasnan, TimeInterval(100)); ```. Then when the scheduled is queried, if `hasnan(model)` is true, the actuator returns false; otherwise the ""child schedule"" (`TimeInterval(100)` in this case) is queried. Other ""skip conditions"" could be provided to `Skip` as well. I think the nice thing about this solution is that it's more robust than hoping the NaNChecker wil throw an error. Relying on an error from `NaNChecker` only works if the iteration interval for the checkpointer is a multiple of the iteration interval used for the NaNChecker. Otherwise users can still get NaNs in their checkpoint even when using NaNChecker.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982864949
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982864949:297,Energy Efficiency,schedul,schedule,297,"We could certainly add a field `error` to `NaNChecker` and throw an error if `error=true`, too. Another possibility though is to design a new `schedule` that doesn't actuate if NaNs are detected. This could be used generically for output writing and checkpointing. Maybe a wrapper like. ```julia; schedule = Skip(hasnan, TimeInterval(100)); ```. Then when the scheduled is queried, if `hasnan(model)` is true, the actuator returns false; otherwise the ""child schedule"" (`TimeInterval(100)` in this case) is queried. Other ""skip conditions"" could be provided to `Skip` as well. I think the nice thing about this solution is that it's more robust than hoping the NaNChecker wil throw an error. Relying on an error from `NaNChecker` only works if the iteration interval for the checkpointer is a multiple of the iteration interval used for the NaNChecker. Otherwise users can still get NaNs in their checkpoint even when using NaNChecker.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982864949
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982864949:360,Energy Efficiency,schedul,scheduled,360,"We could certainly add a field `error` to `NaNChecker` and throw an error if `error=true`, too. Another possibility though is to design a new `schedule` that doesn't actuate if NaNs are detected. This could be used generically for output writing and checkpointing. Maybe a wrapper like. ```julia; schedule = Skip(hasnan, TimeInterval(100)); ```. Then when the scheduled is queried, if `hasnan(model)` is true, the actuator returns false; otherwise the ""child schedule"" (`TimeInterval(100)` in this case) is queried. Other ""skip conditions"" could be provided to `Skip` as well. I think the nice thing about this solution is that it's more robust than hoping the NaNChecker wil throw an error. Relying on an error from `NaNChecker` only works if the iteration interval for the checkpointer is a multiple of the iteration interval used for the NaNChecker. Otherwise users can still get NaNs in their checkpoint even when using NaNChecker.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982864949
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982864949:459,Energy Efficiency,schedul,schedule,459,"We could certainly add a field `error` to `NaNChecker` and throw an error if `error=true`, too. Another possibility though is to design a new `schedule` that doesn't actuate if NaNs are detected. This could be used generically for output writing and checkpointing. Maybe a wrapper like. ```julia; schedule = Skip(hasnan, TimeInterval(100)); ```. Then when the scheduled is queried, if `hasnan(model)` is true, the actuator returns false; otherwise the ""child schedule"" (`TimeInterval(100)` in this case) is queried. Other ""skip conditions"" could be provided to `Skip` as well. I think the nice thing about this solution is that it's more robust than hoping the NaNChecker wil throw an error. Relying on an error from `NaNChecker` only works if the iteration interval for the checkpointer is a multiple of the iteration interval used for the NaNChecker. Otherwise users can still get NaNs in their checkpoint even when using NaNChecker.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982864949
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982864949:273,Integrability,wrap,wrapper,273,"We could certainly add a field `error` to `NaNChecker` and throw an error if `error=true`, too. Another possibility though is to design a new `schedule` that doesn't actuate if NaNs are detected. This could be used generically for output writing and checkpointing. Maybe a wrapper like. ```julia; schedule = Skip(hasnan, TimeInterval(100)); ```. Then when the scheduled is queried, if `hasnan(model)` is true, the actuator returns false; otherwise the ""child schedule"" (`TimeInterval(100)` in this case) is queried. Other ""skip conditions"" could be provided to `Skip` as well. I think the nice thing about this solution is that it's more robust than hoping the NaNChecker wil throw an error. Relying on an error from `NaNChecker` only works if the iteration interval for the checkpointer is a multiple of the iteration interval used for the NaNChecker. Otherwise users can still get NaNs in their checkpoint even when using NaNChecker.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982864949
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982864949:186,Safety,detect,detected,186,"We could certainly add a field `error` to `NaNChecker` and throw an error if `error=true`, too. Another possibility though is to design a new `schedule` that doesn't actuate if NaNs are detected. This could be used generically for output writing and checkpointing. Maybe a wrapper like. ```julia; schedule = Skip(hasnan, TimeInterval(100)); ```. Then when the scheduled is queried, if `hasnan(model)` is true, the actuator returns false; otherwise the ""child schedule"" (`TimeInterval(100)` in this case) is queried. Other ""skip conditions"" could be provided to `Skip` as well. I think the nice thing about this solution is that it's more robust than hoping the NaNChecker wil throw an error. Relying on an error from `NaNChecker` only works if the iteration interval for the checkpointer is a multiple of the iteration interval used for the NaNChecker. Otherwise users can still get NaNs in their checkpoint even when using NaNChecker.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982864949
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982873709:377,Energy Efficiency,schedul,schedule,377,"On the skip condition `hasnan`: we currently have. https://github.com/CliMA/Oceananigans.jl/blob/be424494c720e2f5152c485178a963c96b110a0f/src/Simulations/nan_checker.jl#L14. but for the above pattern we'd need something like. ```julia; hasnan(model::AbstractModel) = hasnan(first(fields(model))); ```. With generic ""skip conditions"" users can also write things like. ```julia; schedule = Skip(model -> hasnan(model.pressures.pNHS), TimeInterval(100)); ```. (or something)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982873709
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982878516:62,Energy Efficiency,schedul,schedulers,62,"Another possibility is to create an abstraction for combining schedulers. I've thought this would be a neat pattern for a while. Then we could have something like. ```julia; schedule = Both(model -> !hasnan(model.velocities.u), TimeInterval(100)); ```. or just. ```julia; schedule = Both(!hasnan, TimeInterval(100)); ```. if `hasnan(model)` is defined. For a `Both` schedule, the schedule is actuated if both conditions are met. This is also nice for transition to turbulence studies, where we may want something like. ```julia; schedule = Both(model -> maximum(abs, model.velocities.w) > 1e-2, TimeInterval(100)); ```. This schedule doesn't acutate until the maximum vertical velcoity is greater than 1e-2. After that, it actuates on an interval of 100 seconds.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982878516
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982878516:174,Energy Efficiency,schedul,schedule,174,"Another possibility is to create an abstraction for combining schedulers. I've thought this would be a neat pattern for a while. Then we could have something like. ```julia; schedule = Both(model -> !hasnan(model.velocities.u), TimeInterval(100)); ```. or just. ```julia; schedule = Both(!hasnan, TimeInterval(100)); ```. if `hasnan(model)` is defined. For a `Both` schedule, the schedule is actuated if both conditions are met. This is also nice for transition to turbulence studies, where we may want something like. ```julia; schedule = Both(model -> maximum(abs, model.velocities.w) > 1e-2, TimeInterval(100)); ```. This schedule doesn't acutate until the maximum vertical velcoity is greater than 1e-2. After that, it actuates on an interval of 100 seconds.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982878516
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982878516:272,Energy Efficiency,schedul,schedule,272,"Another possibility is to create an abstraction for combining schedulers. I've thought this would be a neat pattern for a while. Then we could have something like. ```julia; schedule = Both(model -> !hasnan(model.velocities.u), TimeInterval(100)); ```. or just. ```julia; schedule = Both(!hasnan, TimeInterval(100)); ```. if `hasnan(model)` is defined. For a `Both` schedule, the schedule is actuated if both conditions are met. This is also nice for transition to turbulence studies, where we may want something like. ```julia; schedule = Both(model -> maximum(abs, model.velocities.w) > 1e-2, TimeInterval(100)); ```. This schedule doesn't acutate until the maximum vertical velcoity is greater than 1e-2. After that, it actuates on an interval of 100 seconds.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982878516
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982878516:366,Energy Efficiency,schedul,schedule,366,"Another possibility is to create an abstraction for combining schedulers. I've thought this would be a neat pattern for a while. Then we could have something like. ```julia; schedule = Both(model -> !hasnan(model.velocities.u), TimeInterval(100)); ```. or just. ```julia; schedule = Both(!hasnan, TimeInterval(100)); ```. if `hasnan(model)` is defined. For a `Both` schedule, the schedule is actuated if both conditions are met. This is also nice for transition to turbulence studies, where we may want something like. ```julia; schedule = Both(model -> maximum(abs, model.velocities.w) > 1e-2, TimeInterval(100)); ```. This schedule doesn't acutate until the maximum vertical velcoity is greater than 1e-2. After that, it actuates on an interval of 100 seconds.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982878516
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982878516:380,Energy Efficiency,schedul,schedule,380,"Another possibility is to create an abstraction for combining schedulers. I've thought this would be a neat pattern for a while. Then we could have something like. ```julia; schedule = Both(model -> !hasnan(model.velocities.u), TimeInterval(100)); ```. or just. ```julia; schedule = Both(!hasnan, TimeInterval(100)); ```. if `hasnan(model)` is defined. For a `Both` schedule, the schedule is actuated if both conditions are met. This is also nice for transition to turbulence studies, where we may want something like. ```julia; schedule = Both(model -> maximum(abs, model.velocities.w) > 1e-2, TimeInterval(100)); ```. This schedule doesn't acutate until the maximum vertical velcoity is greater than 1e-2. After that, it actuates on an interval of 100 seconds.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982878516
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982878516:529,Energy Efficiency,schedul,schedule,529,"Another possibility is to create an abstraction for combining schedulers. I've thought this would be a neat pattern for a while. Then we could have something like. ```julia; schedule = Both(model -> !hasnan(model.velocities.u), TimeInterval(100)); ```. or just. ```julia; schedule = Both(!hasnan, TimeInterval(100)); ```. if `hasnan(model)` is defined. For a `Both` schedule, the schedule is actuated if both conditions are met. This is also nice for transition to turbulence studies, where we may want something like. ```julia; schedule = Both(model -> maximum(abs, model.velocities.w) > 1e-2, TimeInterval(100)); ```. This schedule doesn't acutate until the maximum vertical velcoity is greater than 1e-2. After that, it actuates on an interval of 100 seconds.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982878516
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982878516:625,Energy Efficiency,schedul,schedule,625,"Another possibility is to create an abstraction for combining schedulers. I've thought this would be a neat pattern for a while. Then we could have something like. ```julia; schedule = Both(model -> !hasnan(model.velocities.u), TimeInterval(100)); ```. or just. ```julia; schedule = Both(!hasnan, TimeInterval(100)); ```. if `hasnan(model)` is defined. For a `Both` schedule, the schedule is actuated if both conditions are met. This is also nice for transition to turbulence studies, where we may want something like. ```julia; schedule = Both(model -> maximum(abs, model.velocities.w) > 1e-2, TimeInterval(100)); ```. This schedule doesn't acutate until the maximum vertical velcoity is greater than 1e-2. After that, it actuates on an interval of 100 seconds.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982878516
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982910455:48,Availability,checkpoint,checkpointer,48,"> Perhaps the feature being asked for here is a checkpointer that avoids writing NaNs --- is that correct?. I actually think having an `error=true` option to `NaNChecker` would be useful for other purposes than avoiding a nan-filled checkpoint, so I personally still think that's the best solution here, since it's also pretty simple. If the script has plots or other analyses after `run!()`, a user might not want to waste resources running all that stuff if a `NaN` is detected. (Or they might! And hence the option :) ). Unless there's a reason why that's a bad idea that I'm missing...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982910455
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982910455:136,Availability,error,error,136,"> Perhaps the feature being asked for here is a checkpointer that avoids writing NaNs --- is that correct?. I actually think having an `error=true` option to `NaNChecker` would be useful for other purposes than avoiding a nan-filled checkpoint, so I personally still think that's the best solution here, since it's also pretty simple. If the script has plots or other analyses after `run!()`, a user might not want to waste resources running all that stuff if a `NaN` is detected. (Or they might! And hence the option :) ). Unless there's a reason why that's a bad idea that I'm missing...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982910455
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982910455:233,Availability,checkpoint,checkpoint,233,"> Perhaps the feature being asked for here is a checkpointer that avoids writing NaNs --- is that correct?. I actually think having an `error=true` option to `NaNChecker` would be useful for other purposes than avoiding a nan-filled checkpoint, so I personally still think that's the best solution here, since it's also pretty simple. If the script has plots or other analyses after `run!()`, a user might not want to waste resources running all that stuff if a `NaN` is detected. (Or they might! And hence the option :) ). Unless there's a reason why that's a bad idea that I'm missing...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982910455
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982910455:66,Safety,avoid,avoids,66,"> Perhaps the feature being asked for here is a checkpointer that avoids writing NaNs --- is that correct?. I actually think having an `error=true` option to `NaNChecker` would be useful for other purposes than avoiding a nan-filled checkpoint, so I personally still think that's the best solution here, since it's also pretty simple. If the script has plots or other analyses after `run!()`, a user might not want to waste resources running all that stuff if a `NaN` is detected. (Or they might! And hence the option :) ). Unless there's a reason why that's a bad idea that I'm missing...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982910455
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982910455:211,Safety,avoid,avoiding,211,"> Perhaps the feature being asked for here is a checkpointer that avoids writing NaNs --- is that correct?. I actually think having an `error=true` option to `NaNChecker` would be useful for other purposes than avoiding a nan-filled checkpoint, so I personally still think that's the best solution here, since it's also pretty simple. If the script has plots or other analyses after `run!()`, a user might not want to waste resources running all that stuff if a `NaN` is detected. (Or they might! And hence the option :) ). Unless there's a reason why that's a bad idea that I'm missing...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982910455
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982910455:471,Safety,detect,detected,471,"> Perhaps the feature being asked for here is a checkpointer that avoids writing NaNs --- is that correct?. I actually think having an `error=true` option to `NaNChecker` would be useful for other purposes than avoiding a nan-filled checkpoint, so I personally still think that's the best solution here, since it's also pretty simple. If the script has plots or other analyses after `run!()`, a user might not want to waste resources running all that stuff if a `NaN` is detected. (Or they might! And hence the option :) ). Unless there's a reason why that's a bad idea that I'm missing...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982910455
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982910455:327,Usability,simpl,simple,327,"> Perhaps the feature being asked for here is a checkpointer that avoids writing NaNs --- is that correct?. I actually think having an `error=true` option to `NaNChecker` would be useful for other purposes than avoiding a nan-filled checkpoint, so I personally still think that's the best solution here, since it's also pretty simple. If the script has plots or other analyses after `run!()`, a user might not want to waste resources running all that stuff if a `NaN` is detected. (Or they might! And hence the option :) ). Unless there's a reason why that's a bad idea that I'm missing...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982910455
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982934538:29,Availability,error,error,29,"> I actually think having an error=true option to NaNChecker would be useful for other purposes than avoiding a nan-filled checkpoint. Okay. > I personally still think that's the best solution here. I disagree, because it only solves the problem for a narrow range of checkpointer schedules. If you checkpoint based on `TimeInterval` and check for NaNs based on `IterationInterval`, there is no guarantee that you won't write NaNs to a checkpoint file whether or not the NaNChecker throws an error. I think a better solution is to explicitly avoid writing a checkpoint file (or any other task) when NaNs are detected. > it's also pretty simple. There's hardly a difference in the simplicity of either implementation. > Unless there's a reason why that's a bad idea that I'm missing... I don't think there is an intrinsic problem with throwing an error, I just think that it's often a brittle hack that can damage productivity (errors thrown by the NaNChecker generate a long stacktrace of irrelevant information --- because the emergence of a NaN is not an error in the usual sense). So I think it's useful to think of more user-friendly solutions to various issues / tasks we face when setting up simulations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982934538
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982934538:123,Availability,checkpoint,checkpoint,123,"> I actually think having an error=true option to NaNChecker would be useful for other purposes than avoiding a nan-filled checkpoint. Okay. > I personally still think that's the best solution here. I disagree, because it only solves the problem for a narrow range of checkpointer schedules. If you checkpoint based on `TimeInterval` and check for NaNs based on `IterationInterval`, there is no guarantee that you won't write NaNs to a checkpoint file whether or not the NaNChecker throws an error. I think a better solution is to explicitly avoid writing a checkpoint file (or any other task) when NaNs are detected. > it's also pretty simple. There's hardly a difference in the simplicity of either implementation. > Unless there's a reason why that's a bad idea that I'm missing... I don't think there is an intrinsic problem with throwing an error, I just think that it's often a brittle hack that can damage productivity (errors thrown by the NaNChecker generate a long stacktrace of irrelevant information --- because the emergence of a NaN is not an error in the usual sense). So I think it's useful to think of more user-friendly solutions to various issues / tasks we face when setting up simulations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982934538
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982934538:268,Availability,checkpoint,checkpointer,268,"> I actually think having an error=true option to NaNChecker would be useful for other purposes than avoiding a nan-filled checkpoint. Okay. > I personally still think that's the best solution here. I disagree, because it only solves the problem for a narrow range of checkpointer schedules. If you checkpoint based on `TimeInterval` and check for NaNs based on `IterationInterval`, there is no guarantee that you won't write NaNs to a checkpoint file whether or not the NaNChecker throws an error. I think a better solution is to explicitly avoid writing a checkpoint file (or any other task) when NaNs are detected. > it's also pretty simple. There's hardly a difference in the simplicity of either implementation. > Unless there's a reason why that's a bad idea that I'm missing... I don't think there is an intrinsic problem with throwing an error, I just think that it's often a brittle hack that can damage productivity (errors thrown by the NaNChecker generate a long stacktrace of irrelevant information --- because the emergence of a NaN is not an error in the usual sense). So I think it's useful to think of more user-friendly solutions to various issues / tasks we face when setting up simulations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982934538
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982934538:299,Availability,checkpoint,checkpoint,299,"> I actually think having an error=true option to NaNChecker would be useful for other purposes than avoiding a nan-filled checkpoint. Okay. > I personally still think that's the best solution here. I disagree, because it only solves the problem for a narrow range of checkpointer schedules. If you checkpoint based on `TimeInterval` and check for NaNs based on `IterationInterval`, there is no guarantee that you won't write NaNs to a checkpoint file whether or not the NaNChecker throws an error. I think a better solution is to explicitly avoid writing a checkpoint file (or any other task) when NaNs are detected. > it's also pretty simple. There's hardly a difference in the simplicity of either implementation. > Unless there's a reason why that's a bad idea that I'm missing... I don't think there is an intrinsic problem with throwing an error, I just think that it's often a brittle hack that can damage productivity (errors thrown by the NaNChecker generate a long stacktrace of irrelevant information --- because the emergence of a NaN is not an error in the usual sense). So I think it's useful to think of more user-friendly solutions to various issues / tasks we face when setting up simulations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982934538
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982934538:436,Availability,checkpoint,checkpoint,436,"> I actually think having an error=true option to NaNChecker would be useful for other purposes than avoiding a nan-filled checkpoint. Okay. > I personally still think that's the best solution here. I disagree, because it only solves the problem for a narrow range of checkpointer schedules. If you checkpoint based on `TimeInterval` and check for NaNs based on `IterationInterval`, there is no guarantee that you won't write NaNs to a checkpoint file whether or not the NaNChecker throws an error. I think a better solution is to explicitly avoid writing a checkpoint file (or any other task) when NaNs are detected. > it's also pretty simple. There's hardly a difference in the simplicity of either implementation. > Unless there's a reason why that's a bad idea that I'm missing... I don't think there is an intrinsic problem with throwing an error, I just think that it's often a brittle hack that can damage productivity (errors thrown by the NaNChecker generate a long stacktrace of irrelevant information --- because the emergence of a NaN is not an error in the usual sense). So I think it's useful to think of more user-friendly solutions to various issues / tasks we face when setting up simulations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982934538
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982934538:492,Availability,error,error,492,"> I actually think having an error=true option to NaNChecker would be useful for other purposes than avoiding a nan-filled checkpoint. Okay. > I personally still think that's the best solution here. I disagree, because it only solves the problem for a narrow range of checkpointer schedules. If you checkpoint based on `TimeInterval` and check for NaNs based on `IterationInterval`, there is no guarantee that you won't write NaNs to a checkpoint file whether or not the NaNChecker throws an error. I think a better solution is to explicitly avoid writing a checkpoint file (or any other task) when NaNs are detected. > it's also pretty simple. There's hardly a difference in the simplicity of either implementation. > Unless there's a reason why that's a bad idea that I'm missing... I don't think there is an intrinsic problem with throwing an error, I just think that it's often a brittle hack that can damage productivity (errors thrown by the NaNChecker generate a long stacktrace of irrelevant information --- because the emergence of a NaN is not an error in the usual sense). So I think it's useful to think of more user-friendly solutions to various issues / tasks we face when setting up simulations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982934538
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982934538:558,Availability,checkpoint,checkpoint,558,"> I actually think having an error=true option to NaNChecker would be useful for other purposes than avoiding a nan-filled checkpoint. Okay. > I personally still think that's the best solution here. I disagree, because it only solves the problem for a narrow range of checkpointer schedules. If you checkpoint based on `TimeInterval` and check for NaNs based on `IterationInterval`, there is no guarantee that you won't write NaNs to a checkpoint file whether or not the NaNChecker throws an error. I think a better solution is to explicitly avoid writing a checkpoint file (or any other task) when NaNs are detected. > it's also pretty simple. There's hardly a difference in the simplicity of either implementation. > Unless there's a reason why that's a bad idea that I'm missing... I don't think there is an intrinsic problem with throwing an error, I just think that it's often a brittle hack that can damage productivity (errors thrown by the NaNChecker generate a long stacktrace of irrelevant information --- because the emergence of a NaN is not an error in the usual sense). So I think it's useful to think of more user-friendly solutions to various issues / tasks we face when setting up simulations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982934538
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982934538:846,Availability,error,error,846,"> I actually think having an error=true option to NaNChecker would be useful for other purposes than avoiding a nan-filled checkpoint. Okay. > I personally still think that's the best solution here. I disagree, because it only solves the problem for a narrow range of checkpointer schedules. If you checkpoint based on `TimeInterval` and check for NaNs based on `IterationInterval`, there is no guarantee that you won't write NaNs to a checkpoint file whether or not the NaNChecker throws an error. I think a better solution is to explicitly avoid writing a checkpoint file (or any other task) when NaNs are detected. > it's also pretty simple. There's hardly a difference in the simplicity of either implementation. > Unless there's a reason why that's a bad idea that I'm missing... I don't think there is an intrinsic problem with throwing an error, I just think that it's often a brittle hack that can damage productivity (errors thrown by the NaNChecker generate a long stacktrace of irrelevant information --- because the emergence of a NaN is not an error in the usual sense). So I think it's useful to think of more user-friendly solutions to various issues / tasks we face when setting up simulations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982934538
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982934538:927,Availability,error,errors,927,"> I actually think having an error=true option to NaNChecker would be useful for other purposes than avoiding a nan-filled checkpoint. Okay. > I personally still think that's the best solution here. I disagree, because it only solves the problem for a narrow range of checkpointer schedules. If you checkpoint based on `TimeInterval` and check for NaNs based on `IterationInterval`, there is no guarantee that you won't write NaNs to a checkpoint file whether or not the NaNChecker throws an error. I think a better solution is to explicitly avoid writing a checkpoint file (or any other task) when NaNs are detected. > it's also pretty simple. There's hardly a difference in the simplicity of either implementation. > Unless there's a reason why that's a bad idea that I'm missing... I don't think there is an intrinsic problem with throwing an error, I just think that it's often a brittle hack that can damage productivity (errors thrown by the NaNChecker generate a long stacktrace of irrelevant information --- because the emergence of a NaN is not an error in the usual sense). So I think it's useful to think of more user-friendly solutions to various issues / tasks we face when setting up simulations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982934538
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982934538:1057,Availability,error,error,1057,"> I actually think having an error=true option to NaNChecker would be useful for other purposes than avoiding a nan-filled checkpoint. Okay. > I personally still think that's the best solution here. I disagree, because it only solves the problem for a narrow range of checkpointer schedules. If you checkpoint based on `TimeInterval` and check for NaNs based on `IterationInterval`, there is no guarantee that you won't write NaNs to a checkpoint file whether or not the NaNChecker throws an error. I think a better solution is to explicitly avoid writing a checkpoint file (or any other task) when NaNs are detected. > it's also pretty simple. There's hardly a difference in the simplicity of either implementation. > Unless there's a reason why that's a bad idea that I'm missing... I don't think there is an intrinsic problem with throwing an error, I just think that it's often a brittle hack that can damage productivity (errors thrown by the NaNChecker generate a long stacktrace of irrelevant information --- because the emergence of a NaN is not an error in the usual sense). So I think it's useful to think of more user-friendly solutions to various issues / tasks we face when setting up simulations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982934538
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982934538:281,Energy Efficiency,schedul,schedules,281,"> I actually think having an error=true option to NaNChecker would be useful for other purposes than avoiding a nan-filled checkpoint. Okay. > I personally still think that's the best solution here. I disagree, because it only solves the problem for a narrow range of checkpointer schedules. If you checkpoint based on `TimeInterval` and check for NaNs based on `IterationInterval`, there is no guarantee that you won't write NaNs to a checkpoint file whether or not the NaNChecker throws an error. I think a better solution is to explicitly avoid writing a checkpoint file (or any other task) when NaNs are detected. > it's also pretty simple. There's hardly a difference in the simplicity of either implementation. > Unless there's a reason why that's a bad idea that I'm missing... I don't think there is an intrinsic problem with throwing an error, I just think that it's often a brittle hack that can damage productivity (errors thrown by the NaNChecker generate a long stacktrace of irrelevant information --- because the emergence of a NaN is not an error in the usual sense). So I think it's useful to think of more user-friendly solutions to various issues / tasks we face when setting up simulations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982934538
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982934538:101,Safety,avoid,avoiding,101,"> I actually think having an error=true option to NaNChecker would be useful for other purposes than avoiding a nan-filled checkpoint. Okay. > I personally still think that's the best solution here. I disagree, because it only solves the problem for a narrow range of checkpointer schedules. If you checkpoint based on `TimeInterval` and check for NaNs based on `IterationInterval`, there is no guarantee that you won't write NaNs to a checkpoint file whether or not the NaNChecker throws an error. I think a better solution is to explicitly avoid writing a checkpoint file (or any other task) when NaNs are detected. > it's also pretty simple. There's hardly a difference in the simplicity of either implementation. > Unless there's a reason why that's a bad idea that I'm missing... I don't think there is an intrinsic problem with throwing an error, I just think that it's often a brittle hack that can damage productivity (errors thrown by the NaNChecker generate a long stacktrace of irrelevant information --- because the emergence of a NaN is not an error in the usual sense). So I think it's useful to think of more user-friendly solutions to various issues / tasks we face when setting up simulations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982934538
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982934538:542,Safety,avoid,avoid,542,"> I actually think having an error=true option to NaNChecker would be useful for other purposes than avoiding a nan-filled checkpoint. Okay. > I personally still think that's the best solution here. I disagree, because it only solves the problem for a narrow range of checkpointer schedules. If you checkpoint based on `TimeInterval` and check for NaNs based on `IterationInterval`, there is no guarantee that you won't write NaNs to a checkpoint file whether or not the NaNChecker throws an error. I think a better solution is to explicitly avoid writing a checkpoint file (or any other task) when NaNs are detected. > it's also pretty simple. There's hardly a difference in the simplicity of either implementation. > Unless there's a reason why that's a bad idea that I'm missing... I don't think there is an intrinsic problem with throwing an error, I just think that it's often a brittle hack that can damage productivity (errors thrown by the NaNChecker generate a long stacktrace of irrelevant information --- because the emergence of a NaN is not an error in the usual sense). So I think it's useful to think of more user-friendly solutions to various issues / tasks we face when setting up simulations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982934538
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982934538:608,Safety,detect,detected,608,"> I actually think having an error=true option to NaNChecker would be useful for other purposes than avoiding a nan-filled checkpoint. Okay. > I personally still think that's the best solution here. I disagree, because it only solves the problem for a narrow range of checkpointer schedules. If you checkpoint based on `TimeInterval` and check for NaNs based on `IterationInterval`, there is no guarantee that you won't write NaNs to a checkpoint file whether or not the NaNChecker throws an error. I think a better solution is to explicitly avoid writing a checkpoint file (or any other task) when NaNs are detected. > it's also pretty simple. There's hardly a difference in the simplicity of either implementation. > Unless there's a reason why that's a bad idea that I'm missing... I don't think there is an intrinsic problem with throwing an error, I just think that it's often a brittle hack that can damage productivity (errors thrown by the NaNChecker generate a long stacktrace of irrelevant information --- because the emergence of a NaN is not an error in the usual sense). So I think it's useful to think of more user-friendly solutions to various issues / tasks we face when setting up simulations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982934538
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982934538:637,Usability,simpl,simple,637,"> I actually think having an error=true option to NaNChecker would be useful for other purposes than avoiding a nan-filled checkpoint. Okay. > I personally still think that's the best solution here. I disagree, because it only solves the problem for a narrow range of checkpointer schedules. If you checkpoint based on `TimeInterval` and check for NaNs based on `IterationInterval`, there is no guarantee that you won't write NaNs to a checkpoint file whether or not the NaNChecker throws an error. I think a better solution is to explicitly avoid writing a checkpoint file (or any other task) when NaNs are detected. > it's also pretty simple. There's hardly a difference in the simplicity of either implementation. > Unless there's a reason why that's a bad idea that I'm missing... I don't think there is an intrinsic problem with throwing an error, I just think that it's often a brittle hack that can damage productivity (errors thrown by the NaNChecker generate a long stacktrace of irrelevant information --- because the emergence of a NaN is not an error in the usual sense). So I think it's useful to think of more user-friendly solutions to various issues / tasks we face when setting up simulations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982934538
https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982934538:680,Usability,simpl,simplicity,680,"> I actually think having an error=true option to NaNChecker would be useful for other purposes than avoiding a nan-filled checkpoint. Okay. > I personally still think that's the best solution here. I disagree, because it only solves the problem for a narrow range of checkpointer schedules. If you checkpoint based on `TimeInterval` and check for NaNs based on `IterationInterval`, there is no guarantee that you won't write NaNs to a checkpoint file whether or not the NaNChecker throws an error. I think a better solution is to explicitly avoid writing a checkpoint file (or any other task) when NaNs are detected. > it's also pretty simple. There's hardly a difference in the simplicity of either implementation. > Unless there's a reason why that's a bad idea that I'm missing... I don't think there is an intrinsic problem with throwing an error, I just think that it's often a brittle hack that can damage productivity (errors thrown by the NaNChecker generate a long stacktrace of irrelevant information --- because the emergence of a NaN is not an error in the usual sense). So I think it's useful to think of more user-friendly solutions to various issues / tasks we face when setting up simulations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086#issuecomment-982934538
