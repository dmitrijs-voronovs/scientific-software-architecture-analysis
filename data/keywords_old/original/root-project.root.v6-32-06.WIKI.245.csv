id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/root/html534/RooTFnBinding.html:3618,Usability,clear,clearShapeDirty,3618,"rtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = Ro",MatchSource.WIKI,root/html534/RooTFnBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnBinding.html
https://root.cern/root/html534/RooTFnBinding.html:3658,Usability,clear,clearValueAndShapeDirty,3658,"DataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = Roo",MatchSource.WIKI,root/html534/RooTFnBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnBinding.html
https://root.cern/root/html534/RooTFnBinding.html:3706,Usability,clear,clearValueDirty,3706,"mdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooC",MatchSource.WIKI,root/html534/RooTFnBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:9983,Availability,error,error,9983,,MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:10067,Availability,error,error,10067,,MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:39779,Availability,error,errors,39779,"ribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TF1*_func; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooListProxy_list; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:40053,Deployability,integrat,integration,40053,"ribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TF1*_func; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooListProxy_list; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:42113,Deployability,configurat,configuration,42113," by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:42210,Deployability,integrat,integrator,42210," by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:42221,Deployability,configurat,configuration,42221," by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:7027,Integrability,depend,dependentVars,7027,"), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; RooAbsReal*RooAbsReal::createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); virtual RooAbsReal*RooAbsPdf::createNLL(RooAbsData& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsPdf::createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:8517,Integrability,depend,dependentOverlaps,8517,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:8609,Integrability,depend,dependentOverlaps,8609,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:8703,Integrability,depend,dependsOn,8703,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:8832,Integrability,depend,dependsOn,8832,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:8950,Integrability,depend,dependsOnValue,8950,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:9057,Integrability,depend,dependsOnValue,9057,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:20992,Integrability,message,message,20992,"TObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::n",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:21143,Integrability,message,message,21143,"ameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAb",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:40053,Integrability,integrat,integration,40053,"ribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TF1*_func; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooListProxy_list; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:42210,Integrability,integrat,integrator,42210," by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:10383,Modifiability,extend,extendedTerm,10383,"nt_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidRooAbsReal::enableOffsetting(Bool_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; static Bool_tRooAbsPdf::evalError(); static RooAbsReal::EvalErrorIterRooAbsReal::evalErrorIter(); static RooAbsReal::ErrorLoggingModeRooAbsReal::evalErrorLoggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet* nset) const; virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_tRooAbsPdf::extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeRooAbsPdf::extendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; v",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:10495,Modifiability,extend,extendMode,10495,"U ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidRooAbsReal::enableOffsetting(Bool_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; static Bool_tRooAbsPdf::evalError(); static RooAbsReal::EvalErrorIterRooAbsReal::evalErrorIter(); static RooAbsReal::ErrorLoggingModeRooAbsReal::evalErrorLoggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet* nset) const; virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_tRooAbsPdf::extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeRooAbsPdf::extendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Doubl",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:14005,Modifiability,extend,extended,14005,"ec&) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Double_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """", Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; virtual RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; virtual RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); virtual RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); virtual voidRooAbsPdf::generateEvent(Int_t code); virtual RooDataSet*RooAbsPdf::generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); virtual RooArgSet*RooAbsPdf::getAllConstraints(const RooArgSet& o",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:14159,Modifiability,extend,extended,14159,"ProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Double_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """", Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; virtual RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; virtual RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); virtual RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); virtual voidRooAbsPdf::generateEvent(Int_t code); virtual RooDataSet*RooAbsPdf::generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); virtual RooArgSet*RooAbsPdf::getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; virtual Int_tRooAbsReal::getAnalyticalIntegral(RooArgSet& allVars, RooA",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:28900,Modifiability,config,config,28900,"imitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCounter(Int_t value, Bool_t allNodes = kFAL",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:29058,Modifiability,config,config,29058,":serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(con",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:33682,Modifiability,extend,extended,33682,"List); TStringRooAbsArg::cleanBranchName() const; virtual voidRooAbsReal::copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); RooAbsReal*RooAbsReal::createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tevaluate() const; virtual voidRooAbsReal::fillTreeBranch(TTree& t); voidRooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; virtual RooAbsGenContext*RooAbsPdf::genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; RooDataSet*RooAbsPdf::generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Double_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bo",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:42113,Modifiability,config,configuration,42113," by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:42221,Modifiability,config,configuration,42221," by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:2037,Performance,cache,cacheUniqueSuffix,2037,"Suffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virt",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:11104,Performance,cache,cacheList,11104,"ent(Int_t event, Int_t px, Int_t py); virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet* nset) const; virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_tRooAbsPdf::extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeRooAbsPdf::extendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:11192,Performance,cache,cacheList,11192,"oArgSet* nset) const; virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_tRooAbsPdf::extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeRooAbsPdf::extendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:23058,Performance,optimiz,optimizeCacheMode,23058,"order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:23130,Performance,optimiz,optimizeCacheMode,23130,"order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:27498,Performance,cache,cache,27498,"eam(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsPdf::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidRooAbsPdf::resetErrorCounters(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooA",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:28798,Performance,cache,cache,28798,"ject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::Se",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:31431,Performance,cache,cache,31431,"nit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector&); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tRooAbsPdf::traceEvalHook(Double_t value) const; Bool_tRooAbsPdf::traceEvalPdf(Double_t value) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intRooAbsPdf::verboseEval(); static voidRooAbsPdf::verboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:35327,Performance,optimiz,optimizeDirtyHook,35327,"ototype, Double_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:38857,Performance,cache,cache,38857,,MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:38941,Performance,cache,cache,38941,,MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:39140,Performance,cache,caches,39140,,MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:39675,Performance,cache,cache,39675,"AbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TF1*_func; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooListProxy_list; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static ",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:39954,Performance,cache,cache,39954,"ribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TF1*_func; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooListProxy_list; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:40379,Performance,cache,cache,40379,"ribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TF1*_func; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooListProxy_list; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:41009,Performance,cache,cache,41009,,MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:41680,Performance,cache,cache,41680,,MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:42479,Performance,cache,cache,42479," by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:12524,Security,hash,hash,12524,"Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; RooDataSet*RooAbsPdf::generate(RooAbsPdf::GenSpec&) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:12675,Security,hash,hash,12675,"rg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; RooDataSet*RooAbsPdf::generate(RooAbsPdf::GenSpec&) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), ",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:39036,Security,validat,validate,39036,,MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:39875,Security,access,access,39875,"ribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TF1*_func; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooListProxy_list; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:8576,Testability,test,testArg,8576,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:8670,Testability,test,testArg,8670,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:20967,Testability,log,logEvalError,20967,") const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notif",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:21066,Testability,log,logEvalError,21066,"irtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRo",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:22177,Testability,test,testArg,22177," = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, Roo",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:22272,Testability,test,testArg,22272,"Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& te",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:23274,Testability,test,testArg,23274,"order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:2621,Usability,clear,clearEvalError,2621,"ual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 ",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:2662,Usability,clear,clearEvalErrorLog,2662,"s(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:2698,Usability,clear,clearShapeDirty,2698,"le_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdA",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:2738,Usability,clear,clearValueAndShapeDirty,2738,"(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdAr",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFnPdfBinding.html:2786,Usability,clear,clearValueDirty,2786,"t = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg",MatchSource.WIKI,root/html534/RooTFnPdfBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html
https://root.cern/root/html534/RooTFoamBinding.html:1547,Availability,error,error,1547,"Binding(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); RooRealBinding&binding(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDensity(Int_t ndim, Double_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html534/RooTFoamBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFoamBinding.html
https://root.cern/root/html534/RooTFoamBinding.html:1631,Availability,error,error,1631,"t::AppendPad(Option_t* option = """"); RooRealBinding&binding(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDensity(Int_t ndim, Double_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html534/RooTFoamBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFoamBinding.html
https://root.cern/root/html534/RooTFoamBinding.html:343,Energy Efficiency,adapt,adaptor,343,". RooTFoamBinding. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  ROOFIT;  ROOFITCORE;  RooTFoamBinding. class RooTFoamBinding: public TFoamIntegrand. Lightweight interface adaptor that binds a RooAbsPdf to TFOAM; . Function Members (Methods); public:. RooTFoamBinding(const RooTFoamBinding&); RooTFoamBinding(const RooAbsReal& pdf, const RooArgSet& observables); virtual~RooTFoamBinding(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); RooRealBinding&binding(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDensity(Int_t ndim, Double_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtua",MatchSource.WIKI,root/html534/RooTFoamBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFoamBinding.html
https://root.cern/root/html534/RooTFoamBinding.html:333,Integrability,interface,interface,333,". RooTFoamBinding. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  ROOFIT;  ROOFITCORE;  RooTFoamBinding. class RooTFoamBinding: public TFoamIntegrand. Lightweight interface adaptor that binds a RooAbsPdf to TFOAM; . Function Members (Methods); public:. RooTFoamBinding(const RooTFoamBinding&); RooTFoamBinding(const RooAbsReal& pdf, const RooArgSet& observables); virtual~RooTFoamBinding(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); RooRealBinding&binding(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDensity(Int_t ndim, Double_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtua",MatchSource.WIKI,root/html534/RooTFoamBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFoamBinding.html
https://root.cern/root/html534/RooTFoamBinding.html:343,Modifiability,adapt,adaptor,343,". RooTFoamBinding. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  ROOFIT;  ROOFITCORE;  RooTFoamBinding. class RooTFoamBinding: public TFoamIntegrand. Lightweight interface adaptor that binds a RooAbsPdf to TFOAM; . Function Members (Methods); public:. RooTFoamBinding(const RooTFoamBinding&); RooTFoamBinding(const RooAbsReal& pdf, const RooArgSet& observables); virtual~RooTFoamBinding(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); RooRealBinding&binding(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDensity(Int_t ndim, Double_t*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtua",MatchSource.WIKI,root/html534/RooTFoamBinding.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTFoamBinding.html
https://root.cern/root/html534/RooThreshEntry.html:1468,Availability,error,error,1468,"other); RooThreshEntry(Double_t thresh, const RooCatType& cat); virtual~RooThreshEntry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); const RooCatType&cat() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*Clone(const char*) const; virtual Int_tCompare(const TObject*) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html534/RooThreshEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooThreshEntry.html
https://root.cern/root/html534/RooThreshEntry.html:1552,Availability,error,error,1552,"ry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); const RooCatType&cat() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*Clone(const char*) const; virtual Int_tCompare(const TObject*) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root/html534/RooThreshEntry.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooThreshEntry.html
https://root.cern/root/html534/RooThresholdCategory.html:4376,Availability,error,error,4376,", const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; static UInt_tRooAbsArg::fnv1a32(const char* data); static U",MatchSource.WIKI,root/html534/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooThresholdCategory.html
https://root.cern/root/html534/RooThresholdCategory.html:4460,Availability,error,error,4460,"t* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); s",MatchSource.WIKI,root/html534/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooThresholdCategory.html
https://root.cern/root/html534/RooThresholdCategory.html:3339,Integrability,depend,dependentOverlaps,3339,"r() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method,",MatchSource.WIKI,root/html534/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooThresholdCategory.html
https://root.cern/root/html534/RooThresholdCategory.html:3431,Integrability,depend,dependentOverlaps,3431,"e(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjAr",MatchSource.WIKI,root/html534/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooThresholdCategory.html
https://root.cern/root/html534/RooThresholdCategory.html:3525,Integrability,depend,dependsOn,3525,"me = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, I",MatchSource.WIKI,root/html534/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooThresholdCategory.html
https://root.cern/root/html534/RooThresholdCategory.html:3654,Integrability,depend,dependsOn,3654,"AbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const c",MatchSource.WIKI,root/html534/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooThresholdCategory.html
https://root.cern/root/html534/RooThresholdCategory.html:3772,Integrability,depend,dependsOnValue,3772,"nt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& ob",MatchSource.WIKI,root/html534/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooThresholdCategory.html
https://root.cern/root/html534/RooThresholdCategory.html:3879,Integrability,depend,dependsOnValue,3879,"crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSe",MatchSource.WIKI,root/html534/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooThresholdCategory.html
https://root.cern/root/html534/RooThresholdCategory.html:1756,Performance,cache,cacheUniqueSuffix,1756,"ractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); Bool_taddThreshold(Double_t upperLimit, const char* catName, Int_t catIdx = -99999); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) co",MatchSource.WIKI,root/html534/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooThresholdCategory.html
https://root.cern/root/html534/RooThresholdCategory.html:4802,Performance,cache,cacheList,4802,"on& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponen",MatchSource.WIKI,root/html534/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooThresholdCategory.html
https://root.cern/root/html534/RooThresholdCategory.html:4890,Performance,cache,cacheList,4890,"onst RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*Ro",MatchSource.WIKI,root/html534/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooThresholdCategory.html
https://root.cern/root/html534/RooThresholdCategory.html:11541,Performance,optimiz,optimizeCacheMode,11541," depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", con",MatchSource.WIKI,root/html534/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooThresholdCategory.html
https://root.cern/root/html534/RooThresholdCategory.html:11613,Performance,optimiz,optimizeCacheMode,11613,"har* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); voidRooAbsArg::printDirty(Boo",MatchSource.WIKI,root/html534/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooThresholdCategory.html
https://root.cern/root/html534/RooThresholdCategory.html:14056,Performance,cache,cache,14056,"idRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsCategory::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsCategory::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidR",MatchSource.WIKI,root/html534/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooThresholdCategory.html
https://root.cern/root/html534/RooThresholdCategory.html:15046,Performance,cache,cache,15046,"Cache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<std::str",MatchSource.WIKI,root/html534/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooThresholdCategory.html
https://root.cern/root/html534/RooThresholdCategory.html:16616,Performance,cache,cache,16616,"virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; TIterator*RooAbsCategory::typeIterator() const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root/html534/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooThresholdCategory.html
https://root.cern/root/html534/RooThresholdCategory.html:18656,Performance,optimiz,optimizeDirtyHook,18656,"tegory::copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValueDirty = kTRUE); const RooCatType*RooAbsCategory::defineType(const char* label); const RooCatType*RooAbsCategory::defineType(const char* label, Int_t index); const RooCatType*RooAbsCategory::defineTypeUnchecked(const char* label, Int_t index); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual RooCatTypeevaluate() const; virtual voidRooAbsCategory::fillTreeBranch(TTree& t); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; const RooCatType*RooAbsCategory::getOrdinal(UInt_t n, const char* rangeName = 0) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; virtual Bool_tRooAbsCategory::isValid() const; virtual Bool_tRooAbsCategory::isValid(const RooCatType& value) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::syncCache(const RooArgSet* set = 0); RooCatTypeRooAbsCategory::traceEval() const; virtual Bool_tRooAbsCategory::traceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy).",MatchSource.WIKI,root/html534/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooThresholdCategory.html
https://root.cern/root/html534/RooThresholdCategory.html:20659,Performance,cache,cache,20659," kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsCategory::_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooCatType*_defCat; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooRealProxy_inputVar; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; R",MatchSource.WIKI,root/html534/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooThresholdCategory.html
https://root.cern/root/html534/RooThresholdCategory.html:20749,Performance,cache,caches,20749," kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsCategory::_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooCatType*_defCat; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooRealProxy_inputVar; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; R",MatchSource.WIKI,root/html534/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooThresholdCategory.html
https://root.cern/root/html534/RooThresholdCategory.html:21304,Performance,cache,cache,21304," kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsCategory::_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooCatType*_defCat; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooRealProxy_inputVar; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; R",MatchSource.WIKI,root/html534/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooThresholdCategory.html
https://root.cern/root/html534/RooThresholdCategory.html:5440,Security,hash,hash,5440,"y* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents(const RooArgSet* depList) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tRooAbsCategory::getIndex() const; virtual const char*RooAbsCategory::getLabel() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); RooArgSet*RooAbsArg::getObservables(const RooA",MatchSource.WIKI,root/html534/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooThresholdCategory.html
https://root.cern/root/html534/RooThresholdCategory.html:5591,Security,hash,hash,5591,"he() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); Bool_tRooAbsArg::getAttribute(const Text_t* name) const; RooAbsCache*RooAbsArg::getCache(Int_t index) const; RooLinkedListRooAbsArg::getCloningAncestors() const; RooArgSet*RooAbsArg::getComponents() const; RooArgSet*RooAbsArg::getDependents(const RooArgSet& set) const; RooArgSet*RooAbsArg::getDependents(const RooAbsData* set) const; RooArgSet*RooAbsArg::getDependents(const RooArgSet* depList) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tRooAbsCategory::getIndex() const; virtual const char*RooAbsCategory::getLabel() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); RooArgSet*RooAbsArg::getObservables(const RooAbsData* data) const; RooArgSet*RooAbsArg::getObservables(const RooAbsData& data) const; RooArgSet*RooAbsArg::getObservables(const RooArgSet& set, Bool_",MatchSource.WIKI,root/html534/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooThresholdCategory.html
https://root.cern/root/html534/RooThresholdCategory.html:21404,Security,access,access,21404," kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsCategory::_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooCatType*_defCat; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooRealProxy_inputVar; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; R",MatchSource.WIKI,root/html534/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooThresholdCategory.html
https://root.cern/root/html534/RooThresholdCategory.html:3398,Testability,test,testArg,3398,"const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTO",MatchSource.WIKI,root/html534/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooThresholdCategory.html
https://root.cern/root/html534/RooThresholdCategory.html:3492,Testability,test,testArg,3492,"bsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::Exe",MatchSource.WIKI,root/html534/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooThresholdCategory.html
https://root.cern/root/html534/RooThresholdCategory.html:10482,Testability,test,testArg,10482,"isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; const RooCatType*RooAbsCategory::lookupType(Int_t index, Bool_t printError = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(const char* label, Bool_t printError = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(const RooCatType& type, Bool_t printError = kFALSE) const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; Int_tRooAbsCategory::numTypes(const char* = 0) const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperM",MatchSource.WIKI,root/html534/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooThresholdCategory.html
https://root.cern/root/html534/RooThresholdCategory.html:10577,Testability,test,testArg,10577,"st; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; const RooCatType*RooAbsCategory::lookupType(Int_t index, Bool_t printError = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(const char* label, Bool_t printError = kFALSE) const; const RooCatType*RooAbsCategory::lookupType(const RooCatType& type, Bool_t printError = kFALSE) const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; Int_tRooAbsCategory::numTypes(const char* = 0) const; Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& obser",MatchSource.WIKI,root/html534/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooThresholdCategory.html
https://root.cern/root/html534/RooThresholdCategory.html:11757,Testability,test,testArg,11757,"operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); voidRooAbsArg::printDirty(Bool_t depth = kTRUE) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsArg::printMetaArgs(ostream&) const; v",MatchSource.WIKI,root/html534/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooThresholdCategory.html
https://root.cern/root/html534/RooThresholdCategory.html:2201,Usability,clear,clearShapeDirty,2201,"(Double_t upperLimit, const char* catName, Int_t catIdx = -99999); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOpti",MatchSource.WIKI,root/html534/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooThresholdCategory.html
https://root.cern/root/html534/RooThresholdCategory.html:2241,Usability,clear,clearValueAndShapeDirty,2241,"nt_t catIdx = -99999); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* ",MatchSource.WIKI,root/html534/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooThresholdCategory.html
https://root.cern/root/html534/RooThresholdCategory.html:2289,Usability,clear,clearValueDirty,2289,":aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Opti",MatchSource.WIKI,root/html534/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooThresholdCategory.html
https://root.cern/root/html534/RooThresholdCategory.html:17440,Usability,clear,clearTypes,17440,,MatchSource.WIKI,root/html534/RooThresholdCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooThresholdCategory.html
https://root.cern/root/html534/RooTObjWrap.html:1474,Availability,error,error,1474,"her); RooTObjWrap(TObject* inObj, Bool_t isArray = kFALSE); virtual~RooTObjWrap(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObj",MatchSource.WIKI,root/html534/RooTObjWrap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTObjWrap.html
https://root.cern/root/html534/RooTObjWrap.html:1558,Availability,error,error,1558,"oidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(",MatchSource.WIKI,root/html534/RooTObjWrap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTObjWrap.html
https://root.cern/root/html534/RooTrace.html:464,Integrability,message,messages,464,". RooTrace. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  ROOFIT;  ROOFITCORE;  RooTrace. class RooTrace. Class RooTrace controls the memory tracing hooks in all RooFit; objects. When tracing is active, a table of live RooFit objects; is kept that can be queried at any time. In verbose mode, messages; are printed in addition at the construction and destruction of; each object.; . Function Members (Methods); public:. RooTrace(); RooTrace(const RooTrace&); virtual~RooTrace(); static voidactive(Bool_t flag); static voidcallgrind_dump(); static voidcallgrind_zero(); static TClass*Class(); static voidcreate(const TObject* obj); static voidcreateSpecial(const char* name, int size); static voiddestroy(const TObject* obj); static voiddestroySpecial(const char* name); static voiddump(); static voiddump(ostream& os, Bool_t sinceMarked = kFALSE); static RooTrace&instance(); virtual TClass*IsA() const; static voidmark(); RooTrace&operator=(const RooTrace&); static voidprintObjectCounts(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); static voidverbose(Bool_t flag). protected:. voidaddPad(const TObject* ref, Bool_t doPad); voidcreate2(const TObject* obj); voidcreate3(const TObject* obj); voidcreateSpecial3(const char* name, int size); voiddestroy2(const TObject* obj); voiddestroy3(const TObject* obj); voiddestroySpecial3(const char* name); voiddump3(ostream&, Bool_t sinceMarked); voidmark3(); voidprintObjectCounts3(); Bool_tremovePad(const TObject* ref). Data Members; protected:. Bool_t_active; static RooTrace*_instance; RooLinkedList_list; RooLinkedList_markList; map<TClass*,int>_objectCount; map<std::string,int>_specialCount; map<std::string,int>_specialSize; Bool_t_verbose. Class Charts. Inheritance; Inherited Members; ",MatchSource.WIKI,root/html534/RooTrace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTrace.html
https://root.cern/root/html534/RooTrace.html:2511,Integrability,message,message,2511,"onst TObject* obj); voiddestroy3(const TObject* obj); voiddestroySpecial3(const char* name); voiddump3(ostream&, Bool_t sinceMarked); voidmark3(); voidprintObjectCounts3(); Bool_tremovePad(const TObject* ref). Data Members; protected:. Bool_t_active; static RooTrace*_instance; RooLinkedList_list; RooLinkedList_markList; map<TClass*,int>_objectCount; map<std::string,int>_specialCount; map<std::string,int>_specialSize; Bool_t_verbose. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooTrace& instance(). RooTrace(). void create(const TObject* obj); Register creation of object 'obj'. void destroy(const TObject* obj); Register deletion of object 'obj'. void createSpecial(const char* name, int size). void destroySpecial(const char* name). void createSpecial3(const char* name, int size). void destroySpecial3(const char* name). void active(Bool_t flag); If flag is true, memory tracing is activated. void verbose(Bool_t flag); If flag is true, a message will be printed at each; object creation or deletion. void create2(const TObject* obj); Back end function of create(), register creation of object 'obj'. void destroy2(const TObject* obj); Back end function of destroy(), register deletion of object 'obj'. void create3(const TObject* obj); Back end function of create(), register creation of object 'obj'. void destroy3(const TObject* obj); Back end function of destroy(), register deletion of object 'obj'. void mark(); Put marker in object list, that allows to dump contents of list; relative to this marker. void mark3(); Put marker in object list, that allows to dump contents of list; relative to this marker. void dump(); Dump contents of object registry to stdout. void dump(ostream& os, Bool_t sinceMarked = kFALSE). void dump3(ostream& , Bool_t sinceMarked); Dump contents of object register to stream 'os'. If sinceMarked is; true, only object created after the last call to mark() are shown. void printObjectCounts(). void printObjectCoun",MatchSource.WIKI,root/html534/RooTrace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTrace.html
https://root.cern/root/html534/RooTrace.html:3691,Integrability,message,message,3691,"be printed at each; object creation or deletion. void create2(const TObject* obj); Back end function of create(), register creation of object 'obj'. void destroy2(const TObject* obj); Back end function of destroy(), register deletion of object 'obj'. void create3(const TObject* obj); Back end function of create(), register creation of object 'obj'. void destroy3(const TObject* obj); Back end function of destroy(), register deletion of object 'obj'. void mark(); Put marker in object list, that allows to dump contents of list; relative to this marker. void mark3(); Put marker in object list, that allows to dump contents of list; relative to this marker. void dump(); Dump contents of object registry to stdout. void dump(ostream& os, Bool_t sinceMarked = kFALSE). void dump3(ostream& , Bool_t sinceMarked); Dump contents of object register to stream 'os'. If sinceMarked is; true, only object created after the last call to mark() are shown. void printObjectCounts(). void printObjectCounts3(). void callgrind_zero(); Utility function to trigger zeroing of callgrind counters. Note that this function does _not_ do anything, other than optionally printing this message; To trigger callgrind zero counter action, run callgrind with; argument '--zero-before=RooTrace::callgrind_zero()' (include single quotes in cmdline). void callgrind_dump(); Utility function to trigger dumping of callgrind counters. Note that this function does _not_ do anything, other than optionally printing this message; To trigger callgrind dumping action, run callgrind with; argument '--dump-before=RooTrace::callgrind_dump()' (include single quotes in cmdline). RooTrace(). virtual ~RooTrace(); {}. void addPad(const TObject* ref, Bool_t doPad). Bool_t removePad(const TObject* ref).  Last changed: Tue Mar 10 17:20:59 2015  Last generated: 2015-03-10 17:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooTrace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTrace.html
https://root.cern/root/html534/RooTrace.html:4016,Integrability,message,message,4016,"be printed at each; object creation or deletion. void create2(const TObject* obj); Back end function of create(), register creation of object 'obj'. void destroy2(const TObject* obj); Back end function of destroy(), register deletion of object 'obj'. void create3(const TObject* obj); Back end function of create(), register creation of object 'obj'. void destroy3(const TObject* obj); Back end function of destroy(), register deletion of object 'obj'. void mark(); Put marker in object list, that allows to dump contents of list; relative to this marker. void mark3(); Put marker in object list, that allows to dump contents of list; relative to this marker. void dump(); Dump contents of object registry to stdout. void dump(ostream& os, Bool_t sinceMarked = kFALSE). void dump3(ostream& , Bool_t sinceMarked); Dump contents of object register to stream 'os'. If sinceMarked is; true, only object created after the last call to mark() are shown. void printObjectCounts(). void printObjectCounts3(). void callgrind_zero(); Utility function to trigger zeroing of callgrind counters. Note that this function does _not_ do anything, other than optionally printing this message; To trigger callgrind zero counter action, run callgrind with; argument '--zero-before=RooTrace::callgrind_zero()' (include single quotes in cmdline). void callgrind_dump(); Utility function to trigger dumping of callgrind counters. Note that this function does _not_ do anything, other than optionally printing this message; To trigger callgrind dumping action, run callgrind with; argument '--dump-before=RooTrace::callgrind_dump()' (include single quotes in cmdline). RooTrace(). virtual ~RooTrace(); {}. void addPad(const TObject* ref, Bool_t doPad). Bool_t removePad(const TObject* ref).  Last changed: Tue Mar 10 17:20:59 2015  Last generated: 2015-03-10 17:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooTrace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTrace.html
https://root.cern/root/html534/RooTreeData.html:549,Availability,avail,available,549,". RooTreeData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT;  ROOFIT;  ROOFITCORE;  RooTreeData. class RooTreeData: public RooAbsData. RooTreeData is the abstract base class for data collection that; use a TTree as internal storage mechanism; . Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. ~RooTreeData(); voidTObject::AbstractMethod(const char* method) const; virtual voidRooAbsData::add(const RooArgSet& row, Double_t weight = 1, Double_t weightError = 0); voidRooAbsData::addOwnedComponent(const char* idxlabel, RooAbsData& data); virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsData::attachBuffers(const RooArgSet& extObs); virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsData::canSplitFast() const; virtual Bool_tRooAbsData::changeObservableName(const char* from, const char* to); voidRooAbsData::checkInit() const; static voidRooAbsData::claimVars(RooAbsData*); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; voidRooAbsData::convertToVectorStore(); virtual voidTNamed::Copy(TObject& named) const; Double_tRooAbsData::correlation(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; TMatrixDSym*RooAbsData::correlationMatrix(const char* cutSpec = 0, const char* cutRange = 0) const; TMatrixDSym*RooAbsData::correlationMatrix(const RooArgList& vars, const char* cutSpec = 0, const char* cutRange = 0) const; Double_tRooAbsData::covariance(RooRealVar& x, RooRealVar& y, const char* cutSpec = 0, const char* cutRange = 0) const; TMatrixDSym*RooAbsData::cov",MatchSource.WIKI,root/html534/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeData.html
https://root.cern/root/html534/RooTreeData.html:3713,Availability,error,error,3713,"one(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; virtual Int_tRooAbsData::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidRooAbsData::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual RooAbsData*RooAbsData::emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0, const char* wgtVarName = 0) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidRooAbsData::fill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TH1*RooAbsData::fillHistogram(TH1* hist, const RooArgList& plotVars, const char* cuts = """", const char* cutRange = 0) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const RooArgSet*RooAbsData::get() const; virtual const RooArgSet*RooAbsData::get(Int_t index) const; static RooAbsData::StorageTypeRooAbsData::getDefaultStorageType(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool",MatchSource.WIKI,root/html534/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeData.html
https://root.cern/root/html534/RooTreeData.html:3797,Availability,error,error,3797,":none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; virtual Int_tRooAbsData::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidRooAbsData::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual RooAbsData*RooAbsData::emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0, const char* wgtVarName = 0) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidRooAbsData::fill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TH1*RooAbsData::fillHistogram(TH1* hist, const RooArgList& plotVars, const char* cuts = """", const char* cutRange = 0) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const RooArgSet*RooAbsData::get() const; virtual const RooArgSet*RooAbsData::get(Int_t index) const; static RooAbsData::StorageTypeRooAbsData::getDefaultStorageType(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Bool_tRooAb",MatchSource.WIKI,root/html534/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeData.html
https://root.cern/root/html534/RooTreeData.html:9250,Deployability,release,releaseVars,9250,"am(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); voidRooAbsData::resetBuffers(); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsData::setDefaultStorageType(RooAbsData::StorageType s); voidRooAbsData::setDirtyProp(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector",MatchSource.WIKI,root/html534/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeData.html
https://root.cern/root/html534/RooTreeData.html:8659,Energy Efficiency,reduce,reduce,8659,"dArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; virtual voidTObject::Pop(); virtual voidRooAbsData::Print(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsData::printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); voidRooAbsData::resetBuffers(); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(U",MatchSource.WIKI,root/html534/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeData.html
https://root.cern/root/html534/RooTreeData.html:8707,Energy Efficiency,reduce,reduce,8707,":none()) const; virtual voidTObject::Pop(); virtual voidRooAbsData::Print(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsData::printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); voidRooAbsData::resetBuffers(); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t s",MatchSource.WIKI,root/html534/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeData.html
https://root.cern/root/html534/RooTreeData.html:8767,Energy Efficiency,reduce,reduce,8767,"bsData::Print(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsData::printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); voidRooAbsData::resetBuffers(); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsData::setDefaultStorageType(RooAbsData",MatchSource.WIKI,root/html534/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeData.html
https://root.cern/root/html534/RooTreeData.html:8847,Energy Efficiency,reduce,reduce,8847,"ss(ostream& os) const; virtual voidRooPrintable::printArgs(ostream& os) const; virtual voidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsData::printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); voidRooAbsData::resetBuffers(); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsData::setDefaultStorageType(RooAbsData::StorageType s); voidRooAbsData::setDirtyProp(Bool_t flag); virtual voidTObject",MatchSource.WIKI,root/html534/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeData.html
https://root.cern/root/html534/RooTreeData.html:8935,Energy Efficiency,reduce,reduce,8935,"oidRooAbsData::printClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidRooAbsData::printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidRooAbsData::printName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsData::printTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidRooPrintable::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); RooAbsData*RooAbsData::reduce(const char* cut); RooAbsData*RooAbsData::reduce(const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const char* cut = 0); RooAbsData*RooAbsData::reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); RooAbsData*RooAbsData::reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); static Bool_tRooAbsData::releaseVars(RooAbsData*); virtual voidRooAbsData::reset(); voidTObject::ResetBit(UInt_t f); voidRooAbsData::resetBuffers(); RooRealVar*RooAbsData::rmsVar(RooRealVar& var, const char* cutSpec = 0, const char* cutRange = 0) const; virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsData::setDefaultStorageType(RooAbsData::StorageType s); voidRooAbsData::setDirtyProp(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj);",MatchSource.WIKI,root/html534/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeData.html
https://root.cern/root/html534/RooTreeData.html:14174,Energy Efficiency,reduce,reduceEng,14174,"Object::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Bool_tRooAbsData::allClientsCached(RooAbsArg*, const RooArgSet&); virtual voidRooAbsData::attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidRooAbsData::cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); virtual RooAbsData*RooAbsData::cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); Double_tRooAbsData::corrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*RooAbsData::corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*RooAbsData::dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); virtual voidRooAbsData::optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*RooAbsData::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; virtual RooAbsData*RooAbsData::reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum RooAbsData::ErrorType { Poisson; SumW2; None; Auto; Expected; };; enum RooAbsData::StorageType { Tree; Vector; };; enum TObject::EStatusBits { kCanDel",MatchSource.WIKI,root/html534/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeData.html
https://root.cern/root/html534/RooTreeData.html:15130,Modifiability,variab,variables,15130,"Set& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum RooAbsData::ErrorType { Poisson; SumW2; None; Auto; Expected; };; enum RooAbsData::StorageType { Tree; Vector; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*RooAbsData::_cacheIter! Iterator over cached variables; RooArgSetRooAbsData::_cachedVars! External variables cached with this data set; RooAbsDataStore*RooAbsData::_dstoreData storage implementation; TIterator*RooAbsData::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>RooAbsData::_ownedComponentsOwned external components; RooArgSetRooAbsData::_varsDimensions of this data set; static RooAbsData::StorageTypeRooAbsData::defaultStorageType; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TString_blindStringBlinding string (optionally read from ASCII files) ; TTree*_treeTTree holding the data points; RooArgSet_truthTruth variables . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const TTree * GetTree() const; { return _tree; }.  Last changed: Tue Mar 10 17:21:00 2015  Last generated: 2015-03-10 17:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeData.html
https://root.cern/root/html534/RooTreeData.html:15184,Modifiability,variab,variables,15184,"Set& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum RooAbsData::ErrorType { Poisson; SumW2; None; Auto; Expected; };; enum RooAbsData::StorageType { Tree; Vector; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*RooAbsData::_cacheIter! Iterator over cached variables; RooArgSetRooAbsData::_cachedVars! External variables cached with this data set; RooAbsDataStore*RooAbsData::_dstoreData storage implementation; TIterator*RooAbsData::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>RooAbsData::_ownedComponentsOwned external components; RooArgSetRooAbsData::_varsDimensions of this data set; static RooAbsData::StorageTypeRooAbsData::defaultStorageType; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TString_blindStringBlinding string (optionally read from ASCII files) ; TTree*_treeTTree holding the data points; RooArgSet_truthTruth variables . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const TTree * GetTree() const; { return _tree; }.  Last changed: Tue Mar 10 17:21:00 2015  Last generated: 2015-03-10 17:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeData.html
https://root.cern/root/html534/RooTreeData.html:15342,Modifiability,variab,variables,15342,"Set& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum RooAbsData::ErrorType { Poisson; SumW2; None; Auto; Expected; };; enum RooAbsData::StorageType { Tree; Vector; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*RooAbsData::_cacheIter! Iterator over cached variables; RooArgSetRooAbsData::_cachedVars! External variables cached with this data set; RooAbsDataStore*RooAbsData::_dstoreData storage implementation; TIterator*RooAbsData::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>RooAbsData::_ownedComponentsOwned external components; RooArgSetRooAbsData::_varsDimensions of this data set; static RooAbsData::StorageTypeRooAbsData::defaultStorageType; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TString_blindStringBlinding string (optionally read from ASCII files) ; TTree*_treeTTree holding the data points; RooArgSet_truthTruth variables . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const TTree * GetTree() const; { return _tree; }.  Last changed: Tue Mar 10 17:21:00 2015  Last generated: 2015-03-10 17:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeData.html
https://root.cern/root/html534/RooTreeData.html:15811,Modifiability,variab,variables,15811,"Set& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum RooAbsData::ErrorType { Poisson; SumW2; None; Auto; Expected; };; enum RooAbsData::StorageType { Tree; Vector; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*RooAbsData::_cacheIter! Iterator over cached variables; RooArgSetRooAbsData::_cachedVars! External variables cached with this data set; RooAbsDataStore*RooAbsData::_dstoreData storage implementation; TIterator*RooAbsData::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>RooAbsData::_ownedComponentsOwned external components; RooArgSetRooAbsData::_varsDimensions of this data set; static RooAbsData::StorageTypeRooAbsData::defaultStorageType; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TString_blindStringBlinding string (optionally read from ASCII files) ; TTree*_treeTTree holding the data points; RooArgSet_truthTruth variables . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const TTree * GetTree() const; { return _tree; }.  Last changed: Tue Mar 10 17:21:00 2015  Last generated: 2015-03-10 17:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeData.html
https://root.cern/root/html534/RooTreeData.html:12955,Performance,cache,cachedVars,12955,"Object::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Bool_tRooAbsData::allClientsCached(RooAbsArg*, const RooArgSet&); virtual voidRooAbsData::attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidRooAbsData::cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); virtual RooAbsData*RooAbsData::cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); Double_tRooAbsData::corrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*RooAbsData::corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*RooAbsData::dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); virtual voidRooAbsData::optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*RooAbsData::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; virtual RooAbsData*RooAbsData::reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum RooAbsData::ErrorType { Poisson; SumW2; None; Auto; Expected; };; enum RooAbsData::StorageType { Tree; Vector; };; enum TObject::EStatusBits { kCanDel",MatchSource.WIKI,root/html534/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeData.html
https://root.cern/root/html534/RooTreeData.html:12992,Performance,cache,cacheArgs,12992,"Object::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Bool_tRooAbsData::allClientsCached(RooAbsArg*, const RooArgSet&); virtual voidRooAbsData::attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidRooAbsData::cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); virtual RooAbsData*RooAbsData::cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); Double_tRooAbsData::corrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*RooAbsData::corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*RooAbsData::dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); virtual voidRooAbsData::optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*RooAbsData::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; virtual RooAbsData*RooAbsData::reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum RooAbsData::ErrorType { Poisson; SumW2; None; Auto; Expected; };; enum RooAbsData::StorageType { Tree; Vector; };; enum TObject::EStatusBits { kCanDel",MatchSource.WIKI,root/html534/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeData.html
https://root.cern/root/html534/RooTreeData.html:13137,Performance,cache,cacheClone,13137,"Object::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Bool_tRooAbsData::allClientsCached(RooAbsArg*, const RooArgSet&); virtual voidRooAbsData::attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidRooAbsData::cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); virtual RooAbsData*RooAbsData::cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); Double_tRooAbsData::corrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*RooAbsData::corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*RooAbsData::dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); virtual voidRooAbsData::optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*RooAbsData::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; virtual RooAbsData*RooAbsData::reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum RooAbsData::ErrorType { Poisson; SumW2; None; Auto; Expected; };; enum RooAbsData::StorageType { Tree; Vector; };; enum TObject::EStatusBits { kCanDel",MatchSource.WIKI,root/html534/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeData.html
https://root.cern/root/html534/RooTreeData.html:13718,Performance,optimiz,optimizeReadingWithCaching,13718,"Object::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Bool_tRooAbsData::allClientsCached(RooAbsArg*, const RooArgSet&); virtual voidRooAbsData::attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidRooAbsData::cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); virtual RooAbsData*RooAbsData::cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); Double_tRooAbsData::corrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*RooAbsData::corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*RooAbsData::dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); virtual voidRooAbsData::optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*RooAbsData::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; virtual RooAbsData*RooAbsData::reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum RooAbsData::ErrorType { Poisson; SumW2; None; Auto; Expected; };; enum RooAbsData::StorageType { Tree; Vector; };; enum TObject::EStatusBits { kCanDel",MatchSource.WIKI,root/html534/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeData.html
https://root.cern/root/html534/RooTreeData.html:13778,Performance,cache,cacheList,13778,"Object::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Bool_tRooAbsData::allClientsCached(RooAbsArg*, const RooArgSet&); virtual voidRooAbsData::attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidRooAbsData::cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); virtual RooAbsData*RooAbsData::cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); Double_tRooAbsData::corrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*RooAbsData::corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*RooAbsData::dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); virtual voidRooAbsData::optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*RooAbsData::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; virtual RooAbsData*RooAbsData::reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum RooAbsData::ErrorType { Poisson; SumW2; None; Auto; Expected; };; enum RooAbsData::StorageType { Tree; Vector; };; enum TObject::EStatusBits { kCanDel",MatchSource.WIKI,root/html534/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeData.html
https://root.cern/root/html534/RooTreeData.html:15123,Performance,cache,cached,15123,"Set& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum RooAbsData::ErrorType { Poisson; SumW2; None; Auto; Expected; };; enum RooAbsData::StorageType { Tree; Vector; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*RooAbsData::_cacheIter! Iterator over cached variables; RooArgSetRooAbsData::_cachedVars! External variables cached with this data set; RooAbsDataStore*RooAbsData::_dstoreData storage implementation; TIterator*RooAbsData::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>RooAbsData::_ownedComponentsOwned external components; RooArgSetRooAbsData::_varsDimensions of this data set; static RooAbsData::StorageTypeRooAbsData::defaultStorageType; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TString_blindStringBlinding string (optionally read from ASCII files) ; TTree*_treeTTree holding the data points; RooArgSet_truthTruth variables . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const TTree * GetTree() const; { return _tree; }.  Last changed: Tue Mar 10 17:21:00 2015  Last generated: 2015-03-10 17:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeData.html
https://root.cern/root/html534/RooTreeData.html:15194,Performance,cache,cached,15194,"Set& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum RooAbsData::ErrorType { Poisson; SumW2; None; Auto; Expected; };; enum RooAbsData::StorageType { Tree; Vector; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*RooAbsData::_cacheIter! Iterator over cached variables; RooArgSetRooAbsData::_cachedVars! External variables cached with this data set; RooAbsDataStore*RooAbsData::_dstoreData storage implementation; TIterator*RooAbsData::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>RooAbsData::_ownedComponentsOwned external components; RooArgSetRooAbsData::_varsDimensions of this data set; static RooAbsData::StorageTypeRooAbsData::defaultStorageType; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TString_blindStringBlinding string (optionally read from ASCII files) ; TTree*_treeTTree holding the data points; RooArgSet_truthTruth variables . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const TTree * GetTree() const; { return _tree; }.  Last changed: Tue Mar 10 17:21:00 2015  Last generated: 2015-03-10 17:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooTreeData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeData.html
https://root.cern/root/html534/RooTreeDataStore.html:3604,Availability,error,error,3604,"one(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooAbsDataStore::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsDataStore::dirtyProp() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidRooAbsDataStore::dump(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tfill(); Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidRooAbsDataStore::forceCacheUpdate(); virtual const RooArgSet*get(Int_t index) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Stat_tGetEntries() const; Int_tGetEntry(Int_t entry = 0, Int_t getall = 0); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTO",MatchSource.WIKI,root/html534/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeDataStore.html
https://root.cern/root/html534/RooTreeDataStore.html:3688,Availability,error,error,3688,"vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooAbsDataStore::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsDataStore::dirtyProp() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidRooAbsDataStore::dump(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tfill(); Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidRooAbsDataStore::forceCacheUpdate(); virtual const RooArgSet*get(Int_t index) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Stat_tGetEntries() const; Int_tGetEntry(Int_t entry = 0, Int_t getall = 0); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtu",MatchSource.WIKI,root/html534/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeDataStore.html
https://root.cern/root/html534/RooTreeDataStore.html:11495,Availability,error,error,11495,"ck; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooArgSet_attachedBuffers! Currently attached buffers (if different from _varsww); TIterator*RooAbsDataStore::_cacheIter! Iterator over cached variables; const RooAbsArg*_cacheOwner! Object owning cache contents; TTree*_cacheTree! TTree holding the cached function values; RooArgSetRooAbsDataStore::_cachedVars; Double_t_curWgtWeight of current event; Double_t_curWgtErrWeight of current event; Double_t_curWgtErrHiWeight of current event; Double_t_curWgtErrLoWeight of current event; Bool_t_defCtor! Was object constructed with default ctor?; static Int_t_defTreeBufSize; Bool_tRooAbsDataStore::_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; Double_t*_extSumW2Array! External sum of weights array; Double_t*_extWgtArray! External weight array; Double_t*_extWgtErrHiArray! External weight array - high error; Double_t*_extWgtErrLoArray! External weight array - low error; TIterator*RooAbsDataStore::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; TTree*_treeTTree holding the data points; RooArgSetRooAbsDataStore::_vars; RooArgSet_varsww; RooRealVar*_wgtVarPointer to weight variable (if set); TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooTreeDataStore(). RooTreeDataStore(TTree* t, const RooArgSet& vars, const char* wgtVarName = 0); Constructor to facilitate reading of legacy RooDataSets. RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const char* wgtVarName = 0). RooTreeDataStore(const c",MatchSource.WIKI,root/html534/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeDataStore.html
https://root.cern/root/html534/RooTreeDataStore.html:11558,Availability,error,error,11558,"ck; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooArgSet_attachedBuffers! Currently attached buffers (if different from _varsww); TIterator*RooAbsDataStore::_cacheIter! Iterator over cached variables; const RooAbsArg*_cacheOwner! Object owning cache contents; TTree*_cacheTree! TTree holding the cached function values; RooArgSetRooAbsDataStore::_cachedVars; Double_t_curWgtWeight of current event; Double_t_curWgtErrWeight of current event; Double_t_curWgtErrHiWeight of current event; Double_t_curWgtErrLoWeight of current event; Bool_t_defCtor! Was object constructed with default ctor?; static Int_t_defTreeBufSize; Bool_tRooAbsDataStore::_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; Double_t*_extSumW2Array! External sum of weights array; Double_t*_extWgtArray! External weight array; Double_t*_extWgtErrHiArray! External weight array - high error; Double_t*_extWgtErrLoArray! External weight array - low error; TIterator*RooAbsDataStore::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; TTree*_treeTTree holding the data points; RooArgSetRooAbsDataStore::_vars; RooArgSet_varsww; RooRealVar*_wgtVarPointer to weight variable (if set); TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooTreeDataStore(). RooTreeDataStore(TTree* t, const RooArgSet& vars, const char* wgtVarName = 0); Constructor to facilitate reading of legacy RooDataSets. RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const char* wgtVarName = 0). RooTreeDataStore(const c",MatchSource.WIKI,root/html534/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeDataStore.html
https://root.cern/root/html534/RooTreeDataStore.html:10797,Modifiability,variab,variables,10797,"ck; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooArgSet_attachedBuffers! Currently attached buffers (if different from _varsww); TIterator*RooAbsDataStore::_cacheIter! Iterator over cached variables; const RooAbsArg*_cacheOwner! Object owning cache contents; TTree*_cacheTree! TTree holding the cached function values; RooArgSetRooAbsDataStore::_cachedVars; Double_t_curWgtWeight of current event; Double_t_curWgtErrWeight of current event; Double_t_curWgtErrHiWeight of current event; Double_t_curWgtErrLoWeight of current event; Bool_t_defCtor! Was object constructed with default ctor?; static Int_t_defTreeBufSize; Bool_tRooAbsDataStore::_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; Double_t*_extSumW2Array! External sum of weights array; Double_t*_extWgtArray! External weight array; Double_t*_extWgtErrHiArray! External weight array - high error; Double_t*_extWgtErrLoArray! External weight array - low error; TIterator*RooAbsDataStore::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; TTree*_treeTTree holding the data points; RooArgSetRooAbsDataStore::_vars; RooArgSet_varsww; RooRealVar*_wgtVarPointer to weight variable (if set); TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooTreeDataStore(). RooTreeDataStore(TTree* t, const RooArgSet& vars, const char* wgtVarName = 0); Constructor to facilitate reading of legacy RooDataSets. RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const char* wgtVarName = 0). RooTreeDataStore(const c",MatchSource.WIKI,root/html534/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeDataStore.html
https://root.cern/root/html534/RooTreeDataStore.html:11627,Modifiability,variab,variables,11627,"ck; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooArgSet_attachedBuffers! Currently attached buffers (if different from _varsww); TIterator*RooAbsDataStore::_cacheIter! Iterator over cached variables; const RooAbsArg*_cacheOwner! Object owning cache contents; TTree*_cacheTree! TTree holding the cached function values; RooArgSetRooAbsDataStore::_cachedVars; Double_t_curWgtWeight of current event; Double_t_curWgtErrWeight of current event; Double_t_curWgtErrHiWeight of current event; Double_t_curWgtErrLoWeight of current event; Bool_t_defCtor! Was object constructed with default ctor?; static Int_t_defTreeBufSize; Bool_tRooAbsDataStore::_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; Double_t*_extSumW2Array! External sum of weights array; Double_t*_extWgtArray! External weight array; Double_t*_extWgtErrHiArray! External weight array - high error; Double_t*_extWgtErrLoArray! External weight array - low error; TIterator*RooAbsDataStore::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; TTree*_treeTTree holding the data points; RooArgSetRooAbsDataStore::_vars; RooArgSet_varsww; RooRealVar*_wgtVarPointer to weight variable (if set); TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooTreeDataStore(). RooTreeDataStore(TTree* t, const RooArgSet& vars, const char* wgtVarName = 0); Constructor to facilitate reading of legacy RooDataSets. RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const char* wgtVarName = 0). RooTreeDataStore(const c",MatchSource.WIKI,root/html534/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeDataStore.html
https://root.cern/root/html534/RooTreeDataStore.html:11806,Modifiability,variab,variable,11806,"ck; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooArgSet_attachedBuffers! Currently attached buffers (if different from _varsww); TIterator*RooAbsDataStore::_cacheIter! Iterator over cached variables; const RooAbsArg*_cacheOwner! Object owning cache contents; TTree*_cacheTree! TTree holding the cached function values; RooArgSetRooAbsDataStore::_cachedVars; Double_t_curWgtWeight of current event; Double_t_curWgtErrWeight of current event; Double_t_curWgtErrHiWeight of current event; Double_t_curWgtErrLoWeight of current event; Bool_t_defCtor! Was object constructed with default ctor?; static Int_t_defTreeBufSize; Bool_tRooAbsDataStore::_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; Double_t*_extSumW2Array! External sum of weights array; Double_t*_extWgtArray! External weight array; Double_t*_extWgtErrHiArray! External weight array - high error; Double_t*_extWgtErrLoArray! External weight array - low error; TIterator*RooAbsDataStore::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; TTree*_treeTTree holding the data points; RooArgSetRooAbsDataStore::_vars; RooArgSet_varsww; RooRealVar*_wgtVarPointer to weight variable (if set); TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooTreeDataStore(). RooTreeDataStore(TTree* t, const RooArgSet& vars, const char* wgtVarName = 0); Constructor to facilitate reading of legacy RooDataSets. RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const char* wgtVarName = 0). RooTreeDataStore(const c",MatchSource.WIKI,root/html534/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeDataStore.html
https://root.cern/root/html534/RooTreeDataStore.html:13232,Modifiability,variab,variable,13232,"r* name, const char* title, const RooArgSet& vars, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, TTree& t, const RooFormulaVar& select, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, TTree& t, const char* selExpr = 0, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const RooAbsDataStore& tds, const RooFormulaVar& select, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const RooAbsDataStore& tds, const char* selExpr = 0, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, RooAbsDataStore& tds, const RooArgSet& vars, const RooFormulaVar* cutVar, const char* cutRange, Int_t nStart, Int_t nStop, Bool_t , const char* wgtVarName = 0). RooArgSet varsNoWeight(const RooArgSet& allVars, const char* wgtName = 0); Utility function for constructors; Return RooArgSet that is copy of allVars minus variable matching wgtName if specified. RooRealVar* weightVar(const RooArgSet& allVars, const char* wgtName = 0); Utility function for constructors; Return pointer to weight variable if it is defined. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Initialize cache of dataset: attach variables of cache ArgSet; to the corresponding TTree branches. RooTreeDataStore(const RooTreeDataStore& other, const char* newname = 0). RooTreeDataStore(const RooTreeDataStore& other, const RooArgSet& vars, const char* newname = 0). ~RooTreeDataStore(); Destructor. void initialize(); One-time initialization common to all constructor forms. Attach; variables of internal ArgSet to the corresponding TTree branches. void createTree(const char* name, const char* title); Create TTree object that lives in memory, independent of current; location of gDirectory. void loadValues(const TTree* t, const RooFormulaVar* select = 0, con",MatchSource.WIKI,root/html534/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeDataStore.html
https://root.cern/root/html534/RooTreeDataStore.html:13406,Modifiability,variab,variable,13406,"mulaVar& select, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, TTree& t, const char* selExpr = 0, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const RooAbsDataStore& tds, const RooFormulaVar& select, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const RooAbsDataStore& tds, const char* selExpr = 0, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, RooAbsDataStore& tds, const RooArgSet& vars, const RooFormulaVar* cutVar, const char* cutRange, Int_t nStart, Int_t nStop, Bool_t , const char* wgtVarName = 0). RooArgSet varsNoWeight(const RooArgSet& allVars, const char* wgtName = 0); Utility function for constructors; Return RooArgSet that is copy of allVars minus variable matching wgtName if specified. RooRealVar* weightVar(const RooArgSet& allVars, const char* wgtName = 0); Utility function for constructors; Return pointer to weight variable if it is defined. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Initialize cache of dataset: attach variables of cache ArgSet; to the corresponding TTree branches. RooTreeDataStore(const RooTreeDataStore& other, const char* newname = 0). RooTreeDataStore(const RooTreeDataStore& other, const RooArgSet& vars, const char* newname = 0). ~RooTreeDataStore(); Destructor. void initialize(); One-time initialization common to all constructor forms. Attach; variables of internal ArgSet to the corresponding TTree branches. void createTree(const char* name, const char* title); Create TTree object that lives in memory, independent of current; location of gDirectory. void loadValues(const TTree* t, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); Load values from tree 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar",MatchSource.WIKI,root/html534/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeDataStore.html
https://root.cern/root/html534/RooTreeDataStore.html:13543,Modifiability,variab,variables,13543,"* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const RooAbsDataStore& tds, const RooFormulaVar& select, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const RooAbsDataStore& tds, const char* selExpr = 0, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, RooAbsDataStore& tds, const RooArgSet& vars, const RooFormulaVar* cutVar, const char* cutRange, Int_t nStart, Int_t nStop, Bool_t , const char* wgtVarName = 0). RooArgSet varsNoWeight(const RooArgSet& allVars, const char* wgtName = 0); Utility function for constructors; Return RooArgSet that is copy of allVars minus variable matching wgtName if specified. RooRealVar* weightVar(const RooArgSet& allVars, const char* wgtName = 0); Utility function for constructors; Return pointer to weight variable if it is defined. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Initialize cache of dataset: attach variables of cache ArgSet; to the corresponding TTree branches. RooTreeDataStore(const RooTreeDataStore& other, const char* newname = 0). RooTreeDataStore(const RooTreeDataStore& other, const RooArgSet& vars, const char* newname = 0). ~RooTreeDataStore(); Destructor. void initialize(); One-time initialization common to all constructor forms. Attach; variables of internal ArgSet to the corresponding TTree branches. void createTree(const char* name, const char* title); Create TTree object that lives in memory, independent of current; location of gDirectory. void loadValues(const TTree* t, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); Load values from tree 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. The source tree 't' is first clone as not disturb its branch; structure when retrieving information from it. void loadValues(const RooAbsDataStore* tds, const RooFor",MatchSource.WIKI,root/html534/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeDataStore.html
https://root.cern/root/html534/RooTreeDataStore.html:13895,Modifiability,variab,variables,13895,"aStore& tds, const RooArgSet& vars, const RooFormulaVar* cutVar, const char* cutRange, Int_t nStart, Int_t nStop, Bool_t , const char* wgtVarName = 0). RooArgSet varsNoWeight(const RooArgSet& allVars, const char* wgtName = 0); Utility function for constructors; Return RooArgSet that is copy of allVars minus variable matching wgtName if specified. RooRealVar* weightVar(const RooArgSet& allVars, const char* wgtName = 0); Utility function for constructors; Return pointer to weight variable if it is defined. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Initialize cache of dataset: attach variables of cache ArgSet; to the corresponding TTree branches. RooTreeDataStore(const RooTreeDataStore& other, const char* newname = 0). RooTreeDataStore(const RooTreeDataStore& other, const RooArgSet& vars, const char* newname = 0). ~RooTreeDataStore(); Destructor. void initialize(); One-time initialization common to all constructor forms. Attach; variables of internal ArgSet to the corresponding TTree branches. void createTree(const char* name, const char* title); Create TTree object that lives in memory, independent of current; location of gDirectory. void loadValues(const TTree* t, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); Load values from tree 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. The source tree 't' is first clone as not disturb its branch; structure when retrieving information from it. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); Load values from dataset 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. Int_t fill(); Interface function to TTree::Fill. cons",MatchSource.WIKI,root/html534/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeDataStore.html
https://root.cern/root/html534/RooTreeDataStore.html:16359,Modifiability,variab,variables,16359,"Error(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Bool_t changeObservableName(const char* from, const char* to); Change name of internal observable named 'from' into 'to'. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add a new column to the data set which holds the pre-calculated values; of 'newVar'. This operation is only meaningful if 'newVar' is a derived; value. The return value points to the added element holding 'newVar's value; in the data collection. The element is always the corresponding fundamental; type of 'newVar' (e.g. a RooRealVar if 'newVar' is a RooFormulaVar). Note: This function is explicitly NOT intended as a speed optimization; opportunity for the user. Components of complex PDFs that can be; precalculated with the dataset are automatically identified as such; and will be precalculated when fitting to a dataset. By forcibly precalculating functions with non-trivial Jacobians,; or functions of multiple variables occurring in the data set,; using addColumn(), you may alter the outcome of the fit. Only in cases where such a modification of fit behaviour is intentional,; this function should be used. RooArgSet* addColumns(const RooArgList& varList); Utility function to add multiple columns in one call; See addColumn() for details. RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void append(RooAbsDataStore& other). Double_t sumEntries() const. Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in thi",MatchSource.WIKI,root/html534/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeDataStore.html
https://root.cern/root/html534/RooTreeDataStore.html:2240,Performance,cache,cachedVars,2240,"onst RooFormulaVar& select, const char* wgtVarName = 0); RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const RooAbsDataStore& tds, const char* selExpr = 0, const char* wgtVarName = 0); RooTreeDataStore(const char* name, const char* title, RooAbsDataStore& tds, const RooArgSet& vars, const RooFormulaVar* cutVar, const char* cutRange, Int_t nStart, Int_t nStop, Bool_t, const char* wgtVarName = 0); virtual~RooTreeDataStore(); voidTObject::AbstractMethod(const char* method) const; virtual RooAbsArg*addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); virtual RooArgSet*addColumns(const RooArgList& varList); virtual voidappend(RooAbsDataStore& other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidattachBuffers(const RooArgSet& extObs); virtual voidTObject::Browse(TBrowser* b); virtual voidcacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); const RooArgSet&RooAbsDataStore::cachedVars() const; virtual const RooAbsArg*cacheOwner(); virtual Bool_tchangeObservableName(const char* from, const char* to); virtual voidcheckInit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual RooAbsDataStore*clone(const char* newname = 0) const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooAbsDataStore::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsDataStore::dirtyProp() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t",MatchSource.WIKI,root/html534/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeDataStore.html
https://root.cern/root/html534/RooTreeDataStore.html:2284,Performance,cache,cacheOwner,2284,"arName = 0); RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const RooAbsDataStore& tds, const char* selExpr = 0, const char* wgtVarName = 0); RooTreeDataStore(const char* name, const char* title, RooAbsDataStore& tds, const RooArgSet& vars, const RooFormulaVar* cutVar, const char* cutRange, Int_t nStart, Int_t nStop, Bool_t, const char* wgtVarName = 0); virtual~RooTreeDataStore(); voidTObject::AbstractMethod(const char* method) const; virtual RooAbsArg*addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); virtual RooArgSet*addColumns(const RooArgList& varList); virtual voidappend(RooAbsDataStore& other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidattachBuffers(const RooArgSet& extObs); virtual voidTObject::Browse(TBrowser* b); virtual voidcacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); const RooArgSet&RooAbsDataStore::cachedVars() const; virtual const RooAbsArg*cacheOwner(); virtual Bool_tchangeObservableName(const char* from, const char* to); virtual voidcheckInit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual RooAbsDataStore*clone(const char* newname = 0) const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooAbsDataStore::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsDataStore::dirtyProp() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawCla",MatchSource.WIKI,root/html534/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeDataStore.html
https://root.cern/root/html534/RooTreeDataStore.html:9723,Performance,cache,cachedVars,9723," msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TTree&tree(); virtual const TTree*tree() const; virtual voidTObject::UseCurrentStyle(); virtual Bool_tvalid() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Double_tweight() const; virtual Double_tweight(Int_t index) const; virtual Double_tweightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const; virtual voidweightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidattachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); voidcreateTree(const char* name, const char* title); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Int_tgetBranchBufferSize() const; voidinitialize(); voidTObject::MakeZombie(); voidsetBranchBufferSize(Int_t size); RooArgSetvarsNoWeight(const RooArgSet& allVars, const char* wgtName = 0); RooRealVar*weightVar(const RooArgSet& allVars, const char* wgtName = 0). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooArgSet_attachedBuffers! Currently attached buffers (if different from _varsww); TIterator*RooAbsDataStore::_cacheIter! Iterator over cached variables; const RooAbsArg*_cacheOwner! Object owning cache contents; TTree*_cacheTree! TTree holding the",MatchSource.WIKI,root/html534/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeDataStore.html
https://root.cern/root/html534/RooTreeDataStore.html:10790,Performance,cache,cached,10790,"ck; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooArgSet_attachedBuffers! Currently attached buffers (if different from _varsww); TIterator*RooAbsDataStore::_cacheIter! Iterator over cached variables; const RooAbsArg*_cacheOwner! Object owning cache contents; TTree*_cacheTree! TTree holding the cached function values; RooArgSetRooAbsDataStore::_cachedVars; Double_t_curWgtWeight of current event; Double_t_curWgtErrWeight of current event; Double_t_curWgtErrHiWeight of current event; Double_t_curWgtErrLoWeight of current event; Bool_t_defCtor! Was object constructed with default ctor?; static Int_t_defTreeBufSize; Bool_tRooAbsDataStore::_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; Double_t*_extSumW2Array! External sum of weights array; Double_t*_extWgtArray! External weight array; Double_t*_extWgtErrHiArray! External weight array - high error; Double_t*_extWgtErrLoArray! External weight array - low error; TIterator*RooAbsDataStore::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; TTree*_treeTTree holding the data points; RooArgSetRooAbsDataStore::_vars; RooArgSet_varsww; RooRealVar*_wgtVarPointer to weight variable (if set); TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooTreeDataStore(). RooTreeDataStore(TTree* t, const RooArgSet& vars, const char* wgtVarName = 0); Constructor to facilitate reading of legacy RooDataSets. RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const char* wgtVarName = 0). RooTreeDataStore(const c",MatchSource.WIKI,root/html534/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeDataStore.html
https://root.cern/root/html534/RooTreeDataStore.html:10851,Performance,cache,cache,10851,"ck; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooArgSet_attachedBuffers! Currently attached buffers (if different from _varsww); TIterator*RooAbsDataStore::_cacheIter! Iterator over cached variables; const RooAbsArg*_cacheOwner! Object owning cache contents; TTree*_cacheTree! TTree holding the cached function values; RooArgSetRooAbsDataStore::_cachedVars; Double_t_curWgtWeight of current event; Double_t_curWgtErrWeight of current event; Double_t_curWgtErrHiWeight of current event; Double_t_curWgtErrLoWeight of current event; Bool_t_defCtor! Was object constructed with default ctor?; static Int_t_defTreeBufSize; Bool_tRooAbsDataStore::_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; Double_t*_extSumW2Array! External sum of weights array; Double_t*_extWgtArray! External weight array; Double_t*_extWgtErrHiArray! External weight array - high error; Double_t*_extWgtErrLoArray! External weight array - low error; TIterator*RooAbsDataStore::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; TTree*_treeTTree holding the data points; RooArgSetRooAbsDataStore::_vars; RooArgSet_varsww; RooRealVar*_wgtVarPointer to weight variable (if set); TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooTreeDataStore(). RooTreeDataStore(TTree* t, const RooArgSet& vars, const char* wgtVarName = 0); Constructor to facilitate reading of legacy RooDataSets. RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const char* wgtVarName = 0). RooTreeDataStore(const c",MatchSource.WIKI,root/html534/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeDataStore.html
https://root.cern/root/html534/RooTreeDataStore.html:10903,Performance,cache,cached,10903,"ck; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooArgSet_attachedBuffers! Currently attached buffers (if different from _varsww); TIterator*RooAbsDataStore::_cacheIter! Iterator over cached variables; const RooAbsArg*_cacheOwner! Object owning cache contents; TTree*_cacheTree! TTree holding the cached function values; RooArgSetRooAbsDataStore::_cachedVars; Double_t_curWgtWeight of current event; Double_t_curWgtErrWeight of current event; Double_t_curWgtErrHiWeight of current event; Double_t_curWgtErrLoWeight of current event; Bool_t_defCtor! Was object constructed with default ctor?; static Int_t_defTreeBufSize; Bool_tRooAbsDataStore::_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; Double_t*_extSumW2Array! External sum of weights array; Double_t*_extWgtArray! External weight array; Double_t*_extWgtErrHiArray! External weight array - high error; Double_t*_extWgtErrLoArray! External weight array - low error; TIterator*RooAbsDataStore::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; TTree*_treeTTree holding the data points; RooArgSetRooAbsDataStore::_vars; RooArgSet_varsww; RooRealVar*_wgtVarPointer to weight variable (if set); TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooTreeDataStore(). RooTreeDataStore(TTree* t, const RooArgSet& vars, const char* wgtVarName = 0); Constructor to facilitate reading of legacy RooDataSets. RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const char* wgtVarName = 0). RooTreeDataStore(const c",MatchSource.WIKI,root/html534/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeDataStore.html
https://root.cern/root/html534/RooTreeDataStore.html:11314,Performance,load,loading,11314,"ck; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. RooArgSet_attachedBuffers! Currently attached buffers (if different from _varsww); TIterator*RooAbsDataStore::_cacheIter! Iterator over cached variables; const RooAbsArg*_cacheOwner! Object owning cache contents; TTree*_cacheTree! TTree holding the cached function values; RooArgSetRooAbsDataStore::_cachedVars; Double_t_curWgtWeight of current event; Double_t_curWgtErrWeight of current event; Double_t_curWgtErrHiWeight of current event; Double_t_curWgtErrLoWeight of current event; Bool_t_defCtor! Was object constructed with default ctor?; static Int_t_defTreeBufSize; Bool_tRooAbsDataStore::_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; Double_t*_extSumW2Array! External sum of weights array; Double_t*_extWgtArray! External weight array; Double_t*_extWgtErrHiArray! External weight array - high error; Double_t*_extWgtErrLoArray! External weight array - low error; TIterator*RooAbsDataStore::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; TTree*_treeTTree holding the data points; RooArgSetRooAbsDataStore::_vars; RooArgSet_varsww; RooRealVar*_wgtVarPointer to weight variable (if set); TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooTreeDataStore(). RooTreeDataStore(TTree* t, const RooArgSet& vars, const char* wgtVarName = 0); Constructor to facilitate reading of legacy RooDataSets. RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const char* wgtVarName = 0). RooTreeDataStore(const c",MatchSource.WIKI,root/html534/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeDataStore.html
https://root.cern/root/html534/RooTreeDataStore.html:13494,Performance,cache,cachedVars,13494,"* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const RooAbsDataStore& tds, const RooFormulaVar& select, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const RooAbsDataStore& tds, const char* selExpr = 0, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, RooAbsDataStore& tds, const RooArgSet& vars, const RooFormulaVar* cutVar, const char* cutRange, Int_t nStart, Int_t nStop, Bool_t , const char* wgtVarName = 0). RooArgSet varsNoWeight(const RooArgSet& allVars, const char* wgtName = 0); Utility function for constructors; Return RooArgSet that is copy of allVars minus variable matching wgtName if specified. RooRealVar* weightVar(const RooArgSet& allVars, const char* wgtName = 0); Utility function for constructors; Return pointer to weight variable if it is defined. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Initialize cache of dataset: attach variables of cache ArgSet; to the corresponding TTree branches. RooTreeDataStore(const RooTreeDataStore& other, const char* newname = 0). RooTreeDataStore(const RooTreeDataStore& other, const RooArgSet& vars, const char* newname = 0). ~RooTreeDataStore(); Destructor. void initialize(); One-time initialization common to all constructor forms. Attach; variables of internal ArgSet to the corresponding TTree branches. void createTree(const char* name, const char* title); Create TTree object that lives in memory, independent of current; location of gDirectory. void loadValues(const TTree* t, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); Load values from tree 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. The source tree 't' is first clone as not disturb its branch; structure when retrieving information from it. void loadValues(const RooAbsDataStore* tds, const RooFor",MatchSource.WIKI,root/html534/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeDataStore.html
https://root.cern/root/html534/RooTreeDataStore.html:13518,Performance,cache,cache,13518,"* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const RooAbsDataStore& tds, const RooFormulaVar& select, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const RooAbsDataStore& tds, const char* selExpr = 0, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, RooAbsDataStore& tds, const RooArgSet& vars, const RooFormulaVar* cutVar, const char* cutRange, Int_t nStart, Int_t nStop, Bool_t , const char* wgtVarName = 0). RooArgSet varsNoWeight(const RooArgSet& allVars, const char* wgtName = 0); Utility function for constructors; Return RooArgSet that is copy of allVars minus variable matching wgtName if specified. RooRealVar* weightVar(const RooArgSet& allVars, const char* wgtName = 0); Utility function for constructors; Return pointer to weight variable if it is defined. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Initialize cache of dataset: attach variables of cache ArgSet; to the corresponding TTree branches. RooTreeDataStore(const RooTreeDataStore& other, const char* newname = 0). RooTreeDataStore(const RooTreeDataStore& other, const RooArgSet& vars, const char* newname = 0). ~RooTreeDataStore(); Destructor. void initialize(); One-time initialization common to all constructor forms. Attach; variables of internal ArgSet to the corresponding TTree branches. void createTree(const char* name, const char* title); Create TTree object that lives in memory, independent of current; location of gDirectory. void loadValues(const TTree* t, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); Load values from tree 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. The source tree 't' is first clone as not disturb its branch; structure when retrieving information from it. void loadValues(const RooAbsDataStore* tds, const RooFor",MatchSource.WIKI,root/html534/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeDataStore.html
https://root.cern/root/html534/RooTreeDataStore.html:13556,Performance,cache,cache,13556,"* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const RooAbsDataStore& tds, const RooFormulaVar& select, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const RooAbsDataStore& tds, const char* selExpr = 0, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, RooAbsDataStore& tds, const RooArgSet& vars, const RooFormulaVar* cutVar, const char* cutRange, Int_t nStart, Int_t nStop, Bool_t , const char* wgtVarName = 0). RooArgSet varsNoWeight(const RooArgSet& allVars, const char* wgtName = 0); Utility function for constructors; Return RooArgSet that is copy of allVars minus variable matching wgtName if specified. RooRealVar* weightVar(const RooArgSet& allVars, const char* wgtName = 0); Utility function for constructors; Return pointer to weight variable if it is defined. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Initialize cache of dataset: attach variables of cache ArgSet; to the corresponding TTree branches. RooTreeDataStore(const RooTreeDataStore& other, const char* newname = 0). RooTreeDataStore(const RooTreeDataStore& other, const RooArgSet& vars, const char* newname = 0). ~RooTreeDataStore(); Destructor. void initialize(); One-time initialization common to all constructor forms. Attach; variables of internal ArgSet to the corresponding TTree branches. void createTree(const char* name, const char* title); Create TTree object that lives in memory, independent of current; location of gDirectory. void loadValues(const TTree* t, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); Load values from tree 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. The source tree 't' is first clone as not disturb its branch; structure when retrieving information from it. void loadValues(const RooAbsDataStore* tds, const RooFor",MatchSource.WIKI,root/html534/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeDataStore.html
https://root.cern/root/html534/RooTreeDataStore.html:14110,Performance,load,loadValues,14110,"nus variable matching wgtName if specified. RooRealVar* weightVar(const RooArgSet& allVars, const char* wgtName = 0); Utility function for constructors; Return pointer to weight variable if it is defined. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Initialize cache of dataset: attach variables of cache ArgSet; to the corresponding TTree branches. RooTreeDataStore(const RooTreeDataStore& other, const char* newname = 0). RooTreeDataStore(const RooTreeDataStore& other, const RooArgSet& vars, const char* newname = 0). ~RooTreeDataStore(); Destructor. void initialize(); One-time initialization common to all constructor forms. Attach; variables of internal ArgSet to the corresponding TTree branches. void createTree(const char* name, const char* title); Create TTree object that lives in memory, independent of current; location of gDirectory. void loadValues(const TTree* t, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); Load values from tree 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. The source tree 't' is first clone as not disturb its branch; structure when retrieving information from it. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); Load values from dataset 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. Int_t fill(); Interface function to TTree::Fill. const RooArgSet* get(Int_t index) const; Load the n-th data point (n='index') in memory; and return a pointer to the internal RooArgSet; holding its coordinates. Double_t weight(Int_t index) const; Return the weight of the n-th data point (n='index') in memory. Double_t weight() const; Return the weight of th",MatchSource.WIKI,root/html534/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeDataStore.html
https://root.cern/root/html534/RooTreeDataStore.html:14468,Performance,load,loadValues,14468,"ee branches. RooTreeDataStore(const RooTreeDataStore& other, const char* newname = 0). RooTreeDataStore(const RooTreeDataStore& other, const RooArgSet& vars, const char* newname = 0). ~RooTreeDataStore(); Destructor. void initialize(); One-time initialization common to all constructor forms. Attach; variables of internal ArgSet to the corresponding TTree branches. void createTree(const char* name, const char* title); Create TTree object that lives in memory, independent of current; location of gDirectory. void loadValues(const TTree* t, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); Load values from tree 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. The source tree 't' is first clone as not disturb its branch; structure when retrieving information from it. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); Load values from dataset 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. Int_t fill(); Interface function to TTree::Fill. const RooArgSet* get(Int_t index) const; Load the n-th data point (n='index') in memory; and return a pointer to the internal RooArgSet; holding its coordinates. Double_t weight(Int_t index) const; Return the weight of the n-th data point (n='index') in memory. Double_t weight() const; Return the weight of the n-th data point (n='index') in memory. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Bool_t changeObservableName(const char* from, const char* to); Change name of internal observable named 'from' into 'to'. RooAbsArg* addColumn",MatchSource.WIKI,root/html534/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeDataStore.html
https://root.cern/root/html534/RooTreeDataStore.html:14774,Performance,load,loaded,14774,"; Destructor. void initialize(); One-time initialization common to all constructor forms. Attach; variables of internal ArgSet to the corresponding TTree branches. void createTree(const char* name, const char* title); Create TTree object that lives in memory, independent of current; location of gDirectory. void loadValues(const TTree* t, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); Load values from tree 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. The source tree 't' is first clone as not disturb its branch; structure when retrieving information from it. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); Load values from dataset 't' into this data collection, optionally; selecting events using 'select' RooFormulaVar. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. Int_t fill(); Interface function to TTree::Fill. const RooArgSet* get(Int_t index) const; Load the n-th data point (n='index') in memory; and return a pointer to the internal RooArgSet; holding its coordinates. Double_t weight(Int_t index) const; Return the weight of the n-th data point (n='index') in memory. Double_t weight() const; Return the weight of the n-th data point (n='index') in memory. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Bool_t changeObservableName(const char* from, const char* to); Change name of internal observable named 'from' into 'to'. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add a new column to the data set which holds the pre-calculated values; of 'newVar'. This operation is only meaningful if 'newVar' is a derived; value. The re",MatchSource.WIKI,root/html534/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeDataStore.html
https://root.cern/root/html534/RooTreeDataStore.html:16066,Performance,optimiz,optimization,16066,"holding its coordinates. Double_t weight(Int_t index) const; Return the weight of the n-th data point (n='index') in memory. Double_t weight() const; Return the weight of the n-th data point (n='index') in memory. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Bool_t changeObservableName(const char* from, const char* to); Change name of internal observable named 'from' into 'to'. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); Add a new column to the data set which holds the pre-calculated values; of 'newVar'. This operation is only meaningful if 'newVar' is a derived; value. The return value points to the added element holding 'newVar's value; in the data collection. The element is always the corresponding fundamental; type of 'newVar' (e.g. a RooRealVar if 'newVar' is a RooFormulaVar). Note: This function is explicitly NOT intended as a speed optimization; opportunity for the user. Components of complex PDFs that can be; precalculated with the dataset are automatically identified as such; and will be precalculated when fitting to a dataset. By forcibly precalculating functions with non-trivial Jacobians,; or functions of multiple variables occurring in the data set,; using addColumn(), you may alter the outcome of the fit. Only in cases where such a modification of fit behaviour is intentional,; this function should be used. RooArgSet* addColumns(const RooArgList& varList); Utility function to add multiple columns in one call; See addColumn() for details. RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void append(RooAbsDataStore& other). Double_t sumEntries() const. Int_t numEntries() con",MatchSource.WIKI,root/html534/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeDataStore.html
https://root.cern/root/html534/RooTreeDataStore.html:17079,Performance,cache,cacheArgs,17079,"e precalculated when fitting to a dataset. By forcibly precalculating functions with non-trivial Jacobians,; or functions of multiple variables occurring in the data set,; using addColumn(), you may alter the outcome of the fit. Only in cases where such a modification of fit behaviour is intentional,; this function should be used. RooArgSet* addColumns(const RooArgList& varList); Utility function to add multiple columns in one call; See addColumn() for details. RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void append(RooAbsDataStore& other). Double_t sumEntries() const. Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void restoreAlternateBuffers(). void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void ",MatchSource.WIKI,root/html534/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeDataStore.html
https://root.cern/root/html534/RooTreeDataStore.html:17292,Performance,cache,cache,17292,"e precalculated when fitting to a dataset. By forcibly precalculating functions with non-trivial Jacobians,; or functions of multiple variables occurring in the data set,; using addColumn(), you may alter the outcome of the fit. Only in cases where such a modification of fit behaviour is intentional,; this function should be used. RooArgSet* addColumns(const RooArgList& varList); Utility function to add multiple columns in one call; See addColumn() for details. RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void append(RooAbsDataStore& other). Double_t sumEntries() const. Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void restoreAlternateBuffers(). void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void ",MatchSource.WIKI,root/html534/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeDataStore.html
https://root.cern/root/html534/RooTreeDataStore.html:17412,Performance,cache,cache,17412," the fit. Only in cases where such a modification of fit behaviour is intentional,; this function should be used. RooArgSet* addColumns(const RooArgList& varList); Utility function to add multiple columns in one call; See addColumn() for details. RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void append(RooAbsDataStore& other). Double_t sumEntries() const. Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void restoreAlternateBuffers(). void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer& ); Stream an object of class RooTreeDataStore. RooAbsDataStore* clone(const char* newname = 0) const; { return new RooTreeDataStore(*this,newname) ; }. RooAbsDataStore* clone(const RooArgSet& vars, con",MatchSource.WIKI,root/html534/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeDataStore.html
https://root.cern/root/html534/RooTreeDataStore.html:17438,Performance,load,loaded,17438," the fit. Only in cases where such a modification of fit behaviour is intentional,; this function should be used. RooArgSet* addColumns(const RooArgList& varList); Utility function to add multiple columns in one call; See addColumn() for details. RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void append(RooAbsDataStore& other). Double_t sumEntries() const. Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void restoreAlternateBuffers(). void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer& ); Stream an object of class RooTreeDataStore. RooAbsDataStore* clone(const char* newname = 0) const; { return new RooTreeDataStore(*this,newname) ; }. RooAbsDataStore* clone(const RooArgSet& vars, con",MatchSource.WIKI,root/html534/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeDataStore.html
https://root.cern/root/html534/RooTreeDataStore.html:17730,Performance,cache,cached,17730,"ars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void append(RooAbsDataStore& other). Double_t sumEntries() const. Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void restoreAlternateBuffers(). void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer& ); Stream an object of class RooTreeDataStore. RooAbsDataStore* clone(const char* newname = 0) const; { return new RooTreeDataStore(*this,newname) ; }. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const; { return new RooTreeDataStore(*this,vars,newname) ; }. Bool_t isWeighted() const; { return (_wgtVar!=0||_extWgtArray!=0) ; }. TTree& tree(); Tree access. { return *_tree ; }. const TTree* tree() const; { return _tree ; }. const RooAbsArg* cacheOwner(); { return",MatchSource.WIKI,root/html534/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeDataStore.html
https://root.cern/root/html534/RooTreeDataStore.html:17768,Performance,cache,cached,17768,"ars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void append(RooAbsDataStore& other). Double_t sumEntries() const. Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void restoreAlternateBuffers(). void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer& ); Stream an object of class RooTreeDataStore. RooAbsDataStore* clone(const char* newname = 0) const; { return new RooTreeDataStore(*this,newname) ; }. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const; { return new RooTreeDataStore(*this,vars,newname) ; }. Bool_t isWeighted() const; { return (_wgtVar!=0||_extWgtArray!=0) ; }. TTree& tree(); Tree access. { return *_tree ; }. const TTree* tree() const; { return _tree ; }. const RooAbsArg* cacheOwner(); { return",MatchSource.WIKI,root/html534/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeDataStore.html
https://root.cern/root/html534/RooTreeDataStore.html:18713,Performance,cache,cacheOwner,18713,"re-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void restoreAlternateBuffers(). void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer& ); Stream an object of class RooTreeDataStore. RooAbsDataStore* clone(const char* newname = 0) const; { return new RooTreeDataStore(*this,newname) ; }. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const; { return new RooTreeDataStore(*this,vars,newname) ; }. Bool_t isWeighted() const; { return (_wgtVar!=0||_extWgtArray!=0) ; }. TTree& tree(); Tree access. { return *_tree ; }. const TTree* tree() const; { return _tree ; }. const RooAbsArg* cacheOwner(); { return _cacheOwner ; }. void setExternalWeightArray(Double_t* arrayWgt, Double_t* arrayWgtErrLo, Double_t* arrayWgtErrHi, Double_t* arraySumW2). const RooArgSet& row(); { return _varsww ; }. void setBranchBufferSize(Int_t size); TTree Branch buffer size control. { _defTreeBufSize = size ; }. Int_t getBranchBufferSize() const; { return _defTreeBufSize ; }.  Last changed: Tue Mar 10 17:21:02 2015  Last generated: 2015-03-10 17:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeDataStore.html
https://root.cern/root/html534/RooTreeDataStore.html:17264,Security,access,access,17264,"e precalculated when fitting to a dataset. By forcibly precalculating functions with non-trivial Jacobians,; or functions of multiple variables occurring in the data set,; using addColumn(), you may alter the outcome of the fit. Only in cases where such a modification of fit behaviour is intentional,; this function should be used. RooArgSet* addColumns(const RooArgList& varList); Utility function to add multiple columns in one call; See addColumn() for details. RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void append(RooAbsDataStore& other). Double_t sumEntries() const. Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void restoreAlternateBuffers(). void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void ",MatchSource.WIKI,root/html534/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeDataStore.html
https://root.cern/root/html534/RooTreeDataStore.html:18620,Security,access,access,18620,"re-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void restoreAlternateBuffers(). void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer& ); Stream an object of class RooTreeDataStore. RooAbsDataStore* clone(const char* newname = 0) const; { return new RooTreeDataStore(*this,newname) ; }. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const; { return new RooTreeDataStore(*this,vars,newname) ; }. Bool_t isWeighted() const; { return (_wgtVar!=0||_extWgtArray!=0) ; }. TTree& tree(); Tree access. { return *_tree ; }. const TTree* tree() const; { return _tree ; }. const RooAbsArg* cacheOwner(); { return _cacheOwner ; }. void setExternalWeightArray(Double_t* arrayWgt, Double_t* arrayWgtErrLo, Double_t* arrayWgtErrHi, Double_t* arraySumW2). const RooArgSet& row(); { return _varsww ; }. void setBranchBufferSize(Int_t size); TTree Branch buffer size control. { _defTreeBufSize = size ; }. Int_t getBranchBufferSize() const; { return _defTreeBufSize ; }.  Last changed: Tue Mar 10 17:21:02 2015  Last generated: 2015-03-10 17:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeDataStore.html
https://root.cern/root/html534/RooTreeDataStore.html:17503,Usability,clear,cleared,17503," the fit. Only in cases where such a modification of fit behaviour is intentional,; this function should be used. RooArgSet* addColumns(const RooArgList& varList); Utility function to add multiple columns in one call; See addColumn() for details. RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void append(RooAbsDataStore& other). Double_t sumEntries() const. Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void restoreAlternateBuffers(). void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer& ); Stream an object of class RooTreeDataStore. RooAbsDataStore* clone(const char* newname = 0) const; { return new RooTreeDataStore(*this,newname) ; }. RooAbsDataStore* clone(const RooArgSet& vars, con",MatchSource.WIKI,root/html534/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeDataStore.html
https://root.cern/root/html534/RooTreeDataStore.html:17754,Usability,clear,clear,17754,"ars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void append(RooAbsDataStore& other). Double_t sumEntries() const. Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void setArgStatus(const RooArgSet& set, Bool_t active); Activate or deactivate the branch status of the TTree branch associated; with the given set of dataset observables. void resetCache(); Remove tree with values of cached observables; and clear list of cached observables. void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void restoreAlternateBuffers(). void checkInit() const. Stat_t GetEntries() const; Interface function to TTree::GetEntries. void Reset(Option_t* option = 0); Interface function to TTree::Reset. Int_t Fill(); Interface function to TTree::Fill. Int_t GetEntry(Int_t entry = 0, Int_t getall = 0); Interface function to TTree::GetEntry. void Draw(Option_t* option = """"). void Streamer(TBuffer& ); Stream an object of class RooTreeDataStore. RooAbsDataStore* clone(const char* newname = 0) const; { return new RooTreeDataStore(*this,newname) ; }. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const; { return new RooTreeDataStore(*this,vars,newname) ; }. Bool_t isWeighted() const; { return (_wgtVar!=0||_extWgtArray!=0) ; }. TTree& tree(); Tree access. { return *_tree ; }. const TTree* tree() const; { return _tree ; }. const RooAbsArg* cacheOwner(); { return",MatchSource.WIKI,root/html534/RooTreeDataStore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTreeDataStore.html
https://root.cern/root/html534/RooTruthModel.html:10665,Availability,error,error,10665,,MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:10749,Availability,error,error,10749,,MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:41562,Availability,error,errors,41562,"n attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_na",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:41836,Deployability,integrat,integration,41836,"ed in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:44021,Deployability,configurat,configuration,44021,"bsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyRooResolutionModel::xDependent/convolution variable.",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:44118,Deployability,integrat,integrator,44118,"bsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyRooResolutionModel::xDependent/convolution variable.",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:44129,Deployability,configurat,configuration,44129,"bsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyRooResolutionModel::xDependent/convolution variable.",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:7709,Integrability,depend,dependentVars,7709,"), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; RooAbsReal*RooAbsReal::createIntRI(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); virtual RooAbsReal*RooAbsPdf::createNLL(RooAbsData& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsPdf::createNLL(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& depVars, const RooArgSet& projVars, RooArgSet*& cloneSet) const; const RooAbsReal*RooAbsReal::createPlotProjection(const RooArgSet& dependentVars, const RooArgSet* projectedVars, RooArgSet*& cloneSet, const char* rangeName = 0, const RooArgSet* condObs = 0) const; virtual RooAbsReal*RooAbsReal::createProfile(const RooArgSet& paramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:9199,Integrability,depend,dependentOverlaps,9199,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:9291,Integrability,depend,dependentOverlaps,9291,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:9385,Integrability,depend,dependsOn,9385,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:9514,Integrability,depend,dependsOn,9514,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:9632,Integrability,depend,dependsOnValue,9632,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:9739,Integrability,depend,dependsOnValue,9739,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:21765,Integrability,message,message,21765,"TObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; virtual RooAbsGenContext*modelGenContext(const RooAbsAnaConvPdf& convPdf, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() co",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:21916,Integrability,message,message,21916,"ameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; virtual RooAbsGenContext*modelGenContext(const RooAbsAnaConvPdf& convPdf, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual voidRooResolutionModel::normLeafServerLis",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:41836,Integrability,integrat,integration,41836,"ed in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:44118,Integrability,integrat,integrator,44118,"bsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyRooResolutionModel::xDependent/convolution variable.",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:11065,Modifiability,extend,extendedTerm,11065,"nt_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidRooAbsReal::enableOffsetting(Bool_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; static Bool_tRooAbsPdf::evalError(); static RooAbsReal::EvalErrorIterRooAbsReal::evalErrorIter(); static RooAbsReal::ErrorLoggingModeRooAbsReal::evalErrorLoggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet* nset) const; virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_tRooAbsPdf::extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeRooAbsPdf::extendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; v",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:11177,Modifiability,extend,extendMode,11177,"U ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidRooAbsReal::enableOffsetting(Bool_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; static Bool_tRooAbsPdf::evalError(); static RooAbsReal::EvalErrorIterRooAbsReal::evalErrorIter(); static RooAbsReal::ErrorLoggingModeRooAbsReal::evalErrorLoggingMode(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet* nset) const; virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_tRooAbsPdf::extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeRooAbsPdf::extendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Doubl",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:14687,Modifiability,extend,extended,14687,"ec&) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Double_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """", Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; virtual RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; virtual RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); virtual RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); virtual voidgenerateEvent(Int_t code); virtual RooDataSet*RooAbsPdf::generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); virtual RooArgSet*RooAbsPdf::getAllConstraints(const RooArgSet& observables,",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:14841,Modifiability,extend,extended,14841,"ProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Double_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """", Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; virtual RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, Double_t nEvents, Bool_t expectedData = kFALSE, Bool_t extended = kFALSE) const; virtual RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, Double_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); virtual RooDataHist*RooAbsPdf::generateBinned(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none()); virtual voidgenerateEvent(Int_t code); virtual RooDataSet*RooAbsPdf::generateSimGlobal(const RooArgSet& whatVars, Int_t nEvents); virtual RooArgSet*RooAbsPdf::getAllConstraints(const RooArgSet& observables, RooArgSet& constrainedParams, Bool_t stripDisconnected = kTRUE) const; virtual Int_tgetAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const ",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:29960,Modifiability,config,config,29960,"imitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCounter(Int_t value, Bool_t allNodes = kFAL",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:30118,Modifiability,config,config,30118,":serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(con",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:34727,Modifiability,extend,extended,34727,"List); TStringRooAbsArg::cleanBranchName() const; virtual voidRooAbsReal::copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); RooAbsReal*RooAbsReal::createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tevaluate() const; virtual voidRooAbsReal::fillTreeBranch(TTree& t); voidRooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; virtual RooAbsGenContext*RooAbsPdf::genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; RooDataSet*RooAbsPdf::generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Double_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bo",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:44021,Modifiability,config,configuration,44021,"bsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyRooResolutionModel::xDependent/convolution variable.",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:44129,Modifiability,config,configuration,44129,"bsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyRooResolutionModel::xDependent/convolution variable.",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:44918,Modifiability,variab,variable,44918,"bsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyRooResolutionModel::xDependent/convolution variable.",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:2523,Performance,cache,cacheUniqueSuffix,2523," code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; const RooFormulaVar&RooResolutionModel::basis() const; virtual Int_tbasisCode(const char* name) const; const RooRealVar&RooResolutionModel::basisConvVar() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::clon",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:11786,Performance,cache,cacheList,11786,"ent(Int_t event, Int_t px, Int_t py); virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet* nset) const; virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_tRooAbsPdf::extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeRooAbsPdf::extendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:11874,Performance,cache,cacheList,11874,"oArgSet* nset) const; virtual Double_tRooAbsPdf::expectedEvents(const RooArgSet& nset) const; RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual Double_tRooAbsPdf::extendedTerm(Double_t observedEvents, const RooArgSet* nset = 0) const; virtual RooAbsPdf::ExtendModeRooAbsPdf::extendMode() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:24099,Performance,optimiz,optimizeCacheMode,24099,"oRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual voidRooResolutionModel::normLeafServerList(RooArgSet& list) const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:24171,Performance,optimiz,optimizeCacheMode,24171,"oRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual voidRooResolutionModel::normLeafServerList(RooArgSet& list) const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:28558,Performance,cache,cache,28558,"eam(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsPdf::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidRooAbsPdf::resetErrorCounters(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooA",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:29858,Performance,cache,cache,29858,"ject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::Se",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:32429,Performance,cache,cache,32429,"SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector&); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tRooAbsPdf::traceEvalPdf(Double_t value) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intRooAbsPdf::verboseEval(); static voidRooAbsPdf::verboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:36372,Performance,optimiz,optimizeDirtyHook,36372,"ototype, Double_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:40640,Performance,cache,cache,40640,,MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:40724,Performance,cache,cache,40724,,MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:40923,Performance,cache,caches,40923,,MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:41458,Performance,cache,cache,41458,"AbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirt",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:41737,Performance,cache,cache,41737,"ed in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:42233,Performance,cache,cache,42233,"ed in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:42844,Performance,cache,cache,42844,,MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:43588,Performance,cache,cache,43588,"inter to global instance of string that matches object named; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if ",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:44387,Performance,cache,cache,44387,"bsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyRooResolutionModel::xDependent/convolution variable.",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:13206,Security,hash,hash,13206,"Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; RooDataSet*RooAbsPdf::generate(RooAbsPdf::GenSpec&) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:13357,Security,hash,hash,13357,"rg::findServer(Int_t index) const; virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsPdf::fitTo(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); static UInt_tRooAbsArg::fnv1a32(const char* data); static UInt_tRooAbsArg::fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); static ULong64_tRooAbsArg::fnv1a64(const char* data); static ULong64_tRooAbsArg::fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; RooDataSet*RooAbsPdf::generate(RooAbsPdf::GenSpec&) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooDataSet& prototype, Int_t nEvents = 0, Bool_t verbose = kFALSE, Bool_t randProtoOrder = kFALSE, Bool_t resampleProto = kFALSE) const; RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none()); RooDataSet*RooAbsPdf::generate(const RooArgSet& whatVars, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), ",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:40819,Security,validat,validate,40819,,MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:41658,Security,access,access,41658,"ed in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:9258,Testability,test,testArg,9258,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:9352,Testability,test,testArg,9352,"aramsOfInterest); virtual RooAbsPdf*RooAbsPdf::createProjection(const RooArgSet& iset); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsReal::createRunningIntegral(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); RooAbsReal*RooAbsPdf::createScanCdf(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); RooAbsReal*RooAbsReal::createScanRI(const RooArgSet& iset, const RooArgSet& nset, Int_t numScanBins, Int_t intOrder); virtual Double_tRooAbsReal::defaultErrorLevel() const; static RooNumGenConfig*RooAbsPdf::defaultGeneratorConfig(); static RooNumIntConfig*RooAbsReal::defaultIntegratorConfig(); virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependsOn(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOn(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0, Bool_t valueOnly = kFALSE) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsCollection& serverList, const RooAbsArg* ignoreArg = 0) const; Bool_tRooAbsArg::dependsOnValue(const RooAbsArg& server, const RooAbsArg* ignoreArg = 0) const; RooDerivative*RooAbsReal::derivative(RooRealVar& obs, Int_t order = 1, Double_t eps = 0.",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:21740,Testability,log,logEvalError,21740,") const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tRooAbsArg::isFundamental() const; virtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; virtual RooAbsGenContext*modelGenContext(const RooAbsAnaConvPdf& convPdf, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPd",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:21839,Testability,log,logEvalError,21839,"irtual Bool_tRooAbsReal::isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE); virtual Bool_tRooAbsArg::isLValue() const; virtual Bool_tRooAbsReal::isOffsetting() const; Bool_tTObject::IsOnHeap() const; Bool_tRooAbsArg::isShapeDirty() const; Bool_tRooAbsArg::isShapeServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isShapeServer(const char* name) const; virtual Bool_tRooAbsArg::IsSortable() const; Bool_tRooAbsArg::isValueDirty() const; Bool_tRooAbsArg::isValueDirtyAndClear() const; Bool_tRooAbsArg::isValueOrShapeDirtyAndClear() const; Bool_tRooAbsArg::isValueServer(const RooAbsArg& arg) const; Bool_tRooAbsArg::isValueServer(const char* name) const; Bool_tTObject::IsZombie() const; voidRooAbsArg::leafNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; Bool_tRooAbsArg::localNoDirtyInhibit() const; voidRooAbsReal::logEvalError(const char* message, const char* serverValueString = 0) const; static voidRooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); virtual voidTNamed::ls(Option_t* option = """") const; virtual Double_tRooAbsReal::maxVal(Int_t code) const; voidTObject::MayNotUse(const char* method) const; RooAbsMoment*RooAbsReal::mean(RooRealVar& obs); RooAbsMoment*RooAbsReal::mean(RooRealVar& obs, const RooArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; virtual RooAbsGenContext*modelGenContext(const RooAbsAnaConvPdf& convPdf, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*Roo",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:23218,Testability,test,testArg,23218,"ArgSet& nset); virtual Int_tRooAbsReal::minTrialSamples(const RooArgSet&) const; virtual RooAbsGenContext*modelGenContext(const RooAbsAnaConvPdf& convPdf, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual voidRooResolutionModel::normLeafServerList(RooArgSet& list) const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, Roo",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:23313,Testability,test,testArg,23313,"GenContext*modelGenContext(const RooAbsAnaConvPdf& convPdf, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, Int_t order, Bool_t central, Bool_t takeRoot); RooAbsMoment*RooAbsReal::moment(RooRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual voidRooResolutionModel::normLeafServerList(RooArgSet& list) const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& te",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:24315,Testability,test,testArg,24315,"oRealVar& obs, const RooArgSet& normObs, Int_t order, Bool_t central, Bool_t takeRoot, Bool_t intNormObs); Bool_tRooAbsPdf::mustBeExtended() const; static voidRooPrintable::nameFieldLength(Int_t newLen); const TNamed*RooAbsArg::namePtr() const; virtual voidRooResolutionModel::normLeafServerList(RooArgSet& list) const; const char*RooAbsPdf::normRange() const; virtual Bool_tTObject::Notify(); Int_tRooAbsArg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooAbsData* data, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:3149,Usability,clear,clearEvalError,3149,"es(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual RooResolutionModel*RooResolutionModel::convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&RooResolutionModel::convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = Roo",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:3190,Usability,clear,clearEvalErrorLog,3190,"onst; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual RooResolutionModel*RooResolutionModel::convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&RooResolutionModel::convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:3226,Usability,clear,clearShapeDirty,3226,"rs(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual RooResolutionModel*RooResolutionModel::convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&RooResolutionModel::convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCm",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:3266,Usability,clear,clearValueAndShapeDirty,3266,"set = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual RooResolutionModel*RooResolutionModel::convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&RooResolutionModel::convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdAr",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/RooTruthModel.html:3314,Usability,clear,clearValueDirty,3314," voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual RooResolutionModel*RooResolutionModel::convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&RooResolutionModel::convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg",MatchSource.WIKI,root/html534/RooTruthModel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/RooTruthModel.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:397,Availability,error,error,397,". ROOT::Fit::BinData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::BinData. class ROOT::Fit::BinData: public ROOT::Fit::FitData. Class describing the binned data sets :; vectors of x coordinates, y values and optionally error on y values and error on coordinates; The dimension of the coordinate is free; There are 4 different options:; - only coordinates and values (for binned likelihood fits) : kNoError; - coordinate, values and error on values (for normal least square fits) : kValueError; - coordinate, values, error on values and coordinates (for effective least square fits) : kCoordError; - corrdinate, values, error on coordinates and asymmettric error on valyes : kAsymError. In addition there is the option to construct Bindata copying the data in (using the DataVector class); or using pointer to external data (DataWrapper) class.; In general is found to be more efficient to copy the data.; In case of really large data sets for limiting memory consumption then the other option can be used; Specialized constructor exists for data up to 3 dimensions. When the data are copying in the number of points can be set later (or re-set) using Initialize and; the data are inserted one by one using the Add method.; It is mandatory to set the size before using the Add method. @ingroup FitData. Function Members (Methods); public:. virtual~BinData(); voidAdd(double x, double y); voidAdd(const double* x, double val); voidAdd(double x, double y, double ey); voidAdd(const double* x, double val, double eval); voidAdd(double x, double y, double ex, double ey); voidAdd(const double* x, double val, const double* ex, double eval); voidAdd(double x, double y, double ex, double eyl, double eyh); voidAdd(const double* x, double val, const double* ex, double elval, double ehval); voidAddBinUpEdge(const double* xup); RO",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:419,Availability,error,error,419,". ROOT::Fit::BinData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::BinData. class ROOT::Fit::BinData: public ROOT::Fit::FitData. Class describing the binned data sets :; vectors of x coordinates, y values and optionally error on y values and error on coordinates; The dimension of the coordinate is free; There are 4 different options:; - only coordinates and values (for binned likelihood fits) : kNoError; - coordinate, values and error on values (for normal least square fits) : kValueError; - coordinate, values, error on values and coordinates (for effective least square fits) : kCoordError; - corrdinate, values, error on coordinates and asymmettric error on valyes : kAsymError. In addition there is the option to construct Bindata copying the data in (using the DataVector class); or using pointer to external data (DataWrapper) class.; In general is found to be more efficient to copy the data.; In case of really large data sets for limiting memory consumption then the other option can be used; Specialized constructor exists for data up to 3 dimensions. When the data are copying in the number of points can be set later (or re-set) using Initialize and; the data are inserted one by one using the Add method.; It is mandatory to set the size before using the Add method. @ingroup FitData. Function Members (Methods); public:. virtual~BinData(); voidAdd(double x, double y); voidAdd(const double* x, double val); voidAdd(double x, double y, double ey); voidAdd(const double* x, double val, double eval); voidAdd(double x, double y, double ex, double ey); voidAdd(const double* x, double val, const double* ex, double eval); voidAdd(double x, double y, double ex, double eyl, double eyh); voidAdd(const double* x, double val, const double* ex, double elval, double ehval); voidAddBinUpEdge(const double* xup); RO",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:610,Availability,error,error,610,". ROOT::Fit::BinData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::BinData. class ROOT::Fit::BinData: public ROOT::Fit::FitData. Class describing the binned data sets :; vectors of x coordinates, y values and optionally error on y values and error on coordinates; The dimension of the coordinate is free; There are 4 different options:; - only coordinates and values (for binned likelihood fits) : kNoError; - coordinate, values and error on values (for normal least square fits) : kValueError; - coordinate, values, error on values and coordinates (for effective least square fits) : kCoordError; - corrdinate, values, error on coordinates and asymmettric error on valyes : kAsymError. In addition there is the option to construct Bindata copying the data in (using the DataVector class); or using pointer to external data (DataWrapper) class.; In general is found to be more efficient to copy the data.; In case of really large data sets for limiting memory consumption then the other option can be used; Specialized constructor exists for data up to 3 dimensions. When the data are copying in the number of points can be set later (or re-set) using Initialize and; the data are inserted one by one using the Add method.; It is mandatory to set the size before using the Add method. @ingroup FitData. Function Members (Methods); public:. virtual~BinData(); voidAdd(double x, double y); voidAdd(const double* x, double val); voidAdd(double x, double y, double ey); voidAdd(const double* x, double val, double eval); voidAdd(double x, double y, double ex, double ey); voidAdd(const double* x, double val, const double* ex, double eval); voidAdd(double x, double y, double ex, double eyl, double eyh); voidAdd(const double* x, double val, const double* ex, double elval, double ehval); voidAddBinUpEdge(const double* xup); RO",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:694,Availability,error,error,694,". ROOT::Fit::BinData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::BinData. class ROOT::Fit::BinData: public ROOT::Fit::FitData. Class describing the binned data sets :; vectors of x coordinates, y values and optionally error on y values and error on coordinates; The dimension of the coordinate is free; There are 4 different options:; - only coordinates and values (for binned likelihood fits) : kNoError; - coordinate, values and error on values (for normal least square fits) : kValueError; - coordinate, values, error on values and coordinates (for effective least square fits) : kCoordError; - corrdinate, values, error on coordinates and asymmettric error on valyes : kAsymError. In addition there is the option to construct Bindata copying the data in (using the DataVector class); or using pointer to external data (DataWrapper) class.; In general is found to be more efficient to copy the data.; In case of really large data sets for limiting memory consumption then the other option can be used; Specialized constructor exists for data up to 3 dimensions. When the data are copying in the number of points can be set later (or re-set) using Initialize and; the data are inserted one by one using the Add method.; It is mandatory to set the size before using the Add method. @ingroup FitData. Function Members (Methods); public:. virtual~BinData(); voidAdd(double x, double y); voidAdd(const double* x, double val); voidAdd(double x, double y, double ey); voidAdd(const double* x, double val, double eval); voidAdd(double x, double y, double ex, double ey); voidAdd(const double* x, double val, const double* ex, double eval); voidAdd(double x, double y, double ex, double eyl, double eyh); voidAdd(const double* x, double val, const double* ex, double elval, double ehval); voidAddBinUpEdge(const double* xup); RO",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:797,Availability,error,error,797,". ROOT::Fit::BinData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::BinData. class ROOT::Fit::BinData: public ROOT::Fit::FitData. Class describing the binned data sets :; vectors of x coordinates, y values and optionally error on y values and error on coordinates; The dimension of the coordinate is free; There are 4 different options:; - only coordinates and values (for binned likelihood fits) : kNoError; - coordinate, values and error on values (for normal least square fits) : kValueError; - coordinate, values, error on values and coordinates (for effective least square fits) : kCoordError; - corrdinate, values, error on coordinates and asymmettric error on valyes : kAsymError. In addition there is the option to construct Bindata copying the data in (using the DataVector class); or using pointer to external data (DataWrapper) class.; In general is found to be more efficient to copy the data.; In case of really large data sets for limiting memory consumption then the other option can be used; Specialized constructor exists for data up to 3 dimensions. When the data are copying in the number of points can be set later (or re-set) using Initialize and; the data are inserted one by one using the Add method.; It is mandatory to set the size before using the Add method. @ingroup FitData. Function Members (Methods); public:. virtual~BinData(); voidAdd(double x, double y); voidAdd(const double* x, double val); voidAdd(double x, double y, double ey); voidAdd(const double* x, double val, double eval); voidAdd(double x, double y, double ex, double ey); voidAdd(const double* x, double val, const double* ex, double eval); voidAdd(double x, double y, double ex, double eyl, double eyh); voidAdd(const double* x, double val, const double* ex, double elval, double ehval); voidAddBinUpEdge(const double* xup); RO",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:834,Availability,error,error,834,". ROOT::Fit::BinData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::BinData. class ROOT::Fit::BinData: public ROOT::Fit::FitData. Class describing the binned data sets :; vectors of x coordinates, y values and optionally error on y values and error on coordinates; The dimension of the coordinate is free; There are 4 different options:; - only coordinates and values (for binned likelihood fits) : kNoError; - coordinate, values and error on values (for normal least square fits) : kValueError; - coordinate, values, error on values and coordinates (for effective least square fits) : kCoordError; - corrdinate, values, error on coordinates and asymmettric error on valyes : kAsymError. In addition there is the option to construct Bindata copying the data in (using the DataVector class); or using pointer to external data (DataWrapper) class.; In general is found to be more efficient to copy the data.; In case of really large data sets for limiting memory consumption then the other option can be used; Specialized constructor exists for data up to 3 dimensions. When the data are copying in the number of points can be set later (or re-set) using Initialize and; the data are inserted one by one using the Add method.; It is mandatory to set the size before using the Add method. @ingroup FitData. Function Members (Methods); public:. virtual~BinData(); voidAdd(double x, double y); voidAdd(const double* x, double val); voidAdd(double x, double y, double ey); voidAdd(const double* x, double val, double eval); voidAdd(double x, double y, double ex, double ey); voidAdd(const double* x, double val, const double* ex, double eval); voidAdd(double x, double y, double ex, double eyl, double eyh); voidAdd(const double* x, double val, const double* ex, double elval, double ehval); voidAddBinUpEdge(const double* xup); RO",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:5534,Availability,error,errors,5534,"const; unsigned intNPoints() const; ROOT::Fit::BinData&operator=(const ROOT::Fit::BinData&); const ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt() const; ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt(); unsigned intPointSize() const; const ROOT::Fit::DataRange&ROOT::Fit::FitData::Range() const; doubleRefVolume() const; voidResize(unsigned int npoints); voidSetRefVolume(double value); unsigned intSize() const; doubleSumOfContent() const; doubleSumOfError2() const; doubleValue(unsigned int ipoint) const. protected:. voidSetNPoints(unsigned int n). Data Members; public:. enum ErrorType { kNoError; kValueError; kCoordError; kAsymError; };. private:. vector<double>fBinEdgevector containing the bin upper edge (coordinate will contain low edge) ; ROOT::Fit::DataVector*fDataVectorpointer to the copied in data vector; ROOT::Fit::DataWrapper*fDataWrapperpointer to the external data wrapper structure; unsigned intfDimcoordinate dimension; unsigned intfNPointsnumber of contained points in the data set (can be different than size of vector); unsigned intfPointSizetotal point size including value and errors (= fDim + 2 for error in only Y ) ; doublefRefVolumereference bin volume - used to normalize the bins in case of variable bins data; doublefSumContenttotal sum of the bin data content ; doublefSumError2total sum square of the errors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; unsigned int GetPointSize(ROOT::Fit::BinData::ErrorType err, unsigned int dim). ErrorType GetErrorType() const. explicit BinData(unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from dimension of point and max number of points (to pre-allocate vector); Give a zero value and then use Initialize later one if the size is not known. explicit BinData(const ROOT::Fit::DataOptions& opt, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from ",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:5557,Availability,error,error,5557,"const; unsigned intNPoints() const; ROOT::Fit::BinData&operator=(const ROOT::Fit::BinData&); const ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt() const; ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt(); unsigned intPointSize() const; const ROOT::Fit::DataRange&ROOT::Fit::FitData::Range() const; doubleRefVolume() const; voidResize(unsigned int npoints); voidSetRefVolume(double value); unsigned intSize() const; doubleSumOfContent() const; doubleSumOfError2() const; doubleValue(unsigned int ipoint) const. protected:. voidSetNPoints(unsigned int n). Data Members; public:. enum ErrorType { kNoError; kValueError; kCoordError; kAsymError; };. private:. vector<double>fBinEdgevector containing the bin upper edge (coordinate will contain low edge) ; ROOT::Fit::DataVector*fDataVectorpointer to the copied in data vector; ROOT::Fit::DataWrapper*fDataWrapperpointer to the external data wrapper structure; unsigned intfDimcoordinate dimension; unsigned intfNPointsnumber of contained points in the data set (can be different than size of vector); unsigned intfPointSizetotal point size including value and errors (= fDim + 2 for error in only Y ) ; doublefRefVolumereference bin volume - used to normalize the bins in case of variable bins data; doublefSumContenttotal sum of the bin data content ; doublefSumError2total sum square of the errors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; unsigned int GetPointSize(ROOT::Fit::BinData::ErrorType err, unsigned int dim). ErrorType GetErrorType() const. explicit BinData(unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from dimension of point and max number of points (to pre-allocate vector); Give a zero value and then use Initialize later one if the size is not known. explicit BinData(const ROOT::Fit::DataOptions& opt, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from ",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:5767,Availability,error,errors,5767,"const; unsigned intNPoints() const; ROOT::Fit::BinData&operator=(const ROOT::Fit::BinData&); const ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt() const; ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt(); unsigned intPointSize() const; const ROOT::Fit::DataRange&ROOT::Fit::FitData::Range() const; doubleRefVolume() const; voidResize(unsigned int npoints); voidSetRefVolume(double value); unsigned intSize() const; doubleSumOfContent() const; doubleSumOfError2() const; doubleValue(unsigned int ipoint) const. protected:. voidSetNPoints(unsigned int n). Data Members; public:. enum ErrorType { kNoError; kValueError; kCoordError; kAsymError; };. private:. vector<double>fBinEdgevector containing the bin upper edge (coordinate will contain low edge) ; ROOT::Fit::DataVector*fDataVectorpointer to the copied in data vector; ROOT::Fit::DataWrapper*fDataWrapperpointer to the external data wrapper structure; unsigned intfDimcoordinate dimension; unsigned intfNPointsnumber of contained points in the data set (can be different than size of vector); unsigned intfPointSizetotal point size including value and errors (= fDim + 2 for error in only Y ) ; doublefRefVolumereference bin volume - used to normalize the bins in case of variable bins data; doublefSumContenttotal sum of the bin data content ; doublefSumError2total sum square of the errors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; unsigned int GetPointSize(ROOT::Fit::BinData::ErrorType err, unsigned int dim). ErrorType GetErrorType() const. explicit BinData(unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from dimension of point and max number of points (to pre-allocate vector); Give a zero value and then use Initialize later one if the size is not known. explicit BinData(const ROOT::Fit::DataOptions& opt, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from ",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:6692,Availability,error,errors,6692,"ns data; doublefSumContenttotal sum of the bin data content ; doublefSumError2total sum square of the errors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; unsigned int GetPointSize(ROOT::Fit::BinData::ErrorType err, unsigned int dim). ErrorType GetErrorType() const. explicit BinData(unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from dimension of point and max number of points (to pre-allocate vector); Give a zero value and then use Initialize later one if the size is not known. explicit BinData(const ROOT::Fit::DataOptions& opt, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from option and default range. BinData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from options and range; efault is 1D and value errors. BinData(unsigned int n, const double* dataX, const double* val, const double* ex, const double* eval); constructurs using external data . constructor from external data for 1D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* val, const double* ex, const double* ey, const double* eval). constructor from external data for 2D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* dataZ, const double* val, const double* ex, const double* ey, const double* ez, const double* eval). constructor from external data for 3D with errors on coordinate and value. BinData(const ROOT::Fit::BinData& ). copy constructors. BinData & operator=(const ROOT::Fit::BinData& ). assignment operator. virtual ~BinData(). destructor. void Initialize(unsigned int maxpoints, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). preallocat",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:6881,Availability,error,errors,6881," int GetPointSize(ROOT::Fit::BinData::ErrorType err, unsigned int dim). ErrorType GetErrorType() const. explicit BinData(unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from dimension of point and max number of points (to pre-allocate vector); Give a zero value and then use Initialize later one if the size is not known. explicit BinData(const ROOT::Fit::DataOptions& opt, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from option and default range. BinData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from options and range; efault is 1D and value errors. BinData(unsigned int n, const double* dataX, const double* val, const double* ex, const double* eval); constructurs using external data . constructor from external data for 1D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* val, const double* ex, const double* ey, const double* eval). constructor from external data for 2D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* dataZ, const double* val, const double* ex, const double* ey, const double* ez, const double* eval). constructor from external data for 3D with errors on coordinate and value. BinData(const ROOT::Fit::BinData& ). copy constructors. BinData & operator=(const ROOT::Fit::BinData& ). assignment operator. virtual ~BinData(). destructor. void Initialize(unsigned int maxpoints, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). preallocate a data set with given size , dimension and error type (to get the full point size); If the data set already exists and it is having the compatible point size space for the new points; is created in the data ",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:7098,Availability,error,errors,7098,"r). constructor from dimension of point and max number of points (to pre-allocate vector); Give a zero value and then use Initialize later one if the size is not known. explicit BinData(const ROOT::Fit::DataOptions& opt, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from option and default range. BinData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from options and range; efault is 1D and value errors. BinData(unsigned int n, const double* dataX, const double* val, const double* ex, const double* eval); constructurs using external data . constructor from external data for 1D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* val, const double* ex, const double* ey, const double* eval). constructor from external data for 2D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* dataZ, const double* val, const double* ex, const double* ey, const double* ez, const double* eval). constructor from external data for 3D with errors on coordinate and value. BinData(const ROOT::Fit::BinData& ). copy constructors. BinData & operator=(const ROOT::Fit::BinData& ). assignment operator. virtual ~BinData(). destructor. void Initialize(unsigned int maxpoints, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). preallocate a data set with given size , dimension and error type (to get the full point size); If the data set already exists and it is having the compatible point size space for the new points; is created in the data sets, while if not compatible the old data are erased and new space of; new size is allocated.; (i.e if exists initialize is equivalent to a resize( NPoints() + maxpoints). unsigned int PointSize() const. return the s",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:7354,Availability,error,errors,7354,"d int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from option and default range. BinData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from options and range; efault is 1D and value errors. BinData(unsigned int n, const double* dataX, const double* val, const double* ex, const double* eval); constructurs using external data . constructor from external data for 1D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* val, const double* ex, const double* ey, const double* eval). constructor from external data for 2D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* dataZ, const double* val, const double* ex, const double* ey, const double* ez, const double* eval). constructor from external data for 3D with errors on coordinate and value. BinData(const ROOT::Fit::BinData& ). copy constructors. BinData & operator=(const ROOT::Fit::BinData& ). assignment operator. virtual ~BinData(). destructor. void Initialize(unsigned int maxpoints, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). preallocate a data set with given size , dimension and error type (to get the full point size); If the data set already exists and it is having the compatible point size space for the new points; is created in the data sets, while if not compatible the old data are erased and new space of; new size is allocated.; (i.e if exists initialize is equivalent to a resize( NPoints() + maxpoints). unsigned int PointSize() const. return the size of a fit point (is the coordinate dimension + 1 for the value and eventually; the number of all errors. unsigned int DataSize() const. return the size of internal data (number of fit points); if data are not copied in but used externally the size is 0.",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:7711,Availability,error,error,7711,"urs using external data . constructor from external data for 1D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* val, const double* ex, const double* ey, const double* eval). constructor from external data for 2D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* dataZ, const double* val, const double* ex, const double* ey, const double* ez, const double* eval). constructor from external data for 3D with errors on coordinate and value. BinData(const ROOT::Fit::BinData& ). copy constructors. BinData & operator=(const ROOT::Fit::BinData& ). assignment operator. virtual ~BinData(). destructor. void Initialize(unsigned int maxpoints, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). preallocate a data set with given size , dimension and error type (to get the full point size); If the data set already exists and it is having the compatible point size space for the new points; is created in the data sets, while if not compatible the old data are erased and new space of; new size is allocated.; (i.e if exists initialize is equivalent to a resize( NPoints() + maxpoints). unsigned int PointSize() const. return the size of a fit point (is the coordinate dimension + 1 for the value and eventually; the number of all errors. unsigned int DataSize() const. return the size of internal data (number of fit points); if data are not copied in but used externally the size is 0. bool HaveCoordErrors() const. flag to control if data provides error on the coordinates. bool HaveAsymErrors() const. flag to control if data provides asymmetric errors on the value. void Add(double x, double y). add one dim data with only coordinate and values. void Add(double x, double y, double ey). add one dim data with no error in the coordinate (x); in this case store the inverse of the error in the value (y). void Add(double x, double y, double ex, dou",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:8192,Availability,error,errors,8192,"nsigned int n, const double* dataX, const double* dataY, const double* dataZ, const double* val, const double* ex, const double* ey, const double* ez, const double* eval). constructor from external data for 3D with errors on coordinate and value. BinData(const ROOT::Fit::BinData& ). copy constructors. BinData & operator=(const ROOT::Fit::BinData& ). assignment operator. virtual ~BinData(). destructor. void Initialize(unsigned int maxpoints, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). preallocate a data set with given size , dimension and error type (to get the full point size); If the data set already exists and it is having the compatible point size space for the new points; is created in the data sets, while if not compatible the old data are erased and new space of; new size is allocated.; (i.e if exists initialize is equivalent to a resize( NPoints() + maxpoints). unsigned int PointSize() const. return the size of a fit point (is the coordinate dimension + 1 for the value and eventually; the number of all errors. unsigned int DataSize() const. return the size of internal data (number of fit points); if data are not copied in but used externally the size is 0. bool HaveCoordErrors() const. flag to control if data provides error on the coordinates. bool HaveAsymErrors() const. flag to control if data provides asymmetric errors on the value. void Add(double x, double y). add one dim data with only coordinate and values. void Add(double x, double y, double ey). add one dim data with no error in the coordinate (x); in this case store the inverse of the error in the value (y). void Add(double x, double y, double ex, double ey). add one dim data with error in the coordinate (x); in this case store the value (y) error and not the inverse. void Add(double x, double y, double ex, double eyl, double eyh). add one dim data with error in the coordinate (x) and asymmetric errors in the value (y); in this case store the y errors and not the inverse.",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:8412,Availability,error,error,8412,"it::BinData& ). copy constructors. BinData & operator=(const ROOT::Fit::BinData& ). assignment operator. virtual ~BinData(). destructor. void Initialize(unsigned int maxpoints, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). preallocate a data set with given size , dimension and error type (to get the full point size); If the data set already exists and it is having the compatible point size space for the new points; is created in the data sets, while if not compatible the old data are erased and new space of; new size is allocated.; (i.e if exists initialize is equivalent to a resize( NPoints() + maxpoints). unsigned int PointSize() const. return the size of a fit point (is the coordinate dimension + 1 for the value and eventually; the number of all errors. unsigned int DataSize() const. return the size of internal data (number of fit points); if data are not copied in but used externally the size is 0. bool HaveCoordErrors() const. flag to control if data provides error on the coordinates. bool HaveAsymErrors() const. flag to control if data provides asymmetric errors on the value. void Add(double x, double y). add one dim data with only coordinate and values. void Add(double x, double y, double ey). add one dim data with no error in the coordinate (x); in this case store the inverse of the error in the value (y). void Add(double x, double y, double ex, double ey). add one dim data with error in the coordinate (x); in this case store the value (y) error and not the inverse. void Add(double x, double y, double ex, double eyl, double eyh). add one dim data with error in the coordinate (x) and asymmetric errors in the value (y); in this case store the y errors and not the inverse. void Add(const double* x, double val). add multi-dim coordinate data with only value (no errors). void Add(const double* x, double val, double eval). add multi-dim coordinate data with only error in value. void Add(const double* x, double val, const double* ex, double",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:8511,Availability,error,errors,8511,"ent operator. virtual ~BinData(). destructor. void Initialize(unsigned int maxpoints, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). preallocate a data set with given size , dimension and error type (to get the full point size); If the data set already exists and it is having the compatible point size space for the new points; is created in the data sets, while if not compatible the old data are erased and new space of; new size is allocated.; (i.e if exists initialize is equivalent to a resize( NPoints() + maxpoints). unsigned int PointSize() const. return the size of a fit point (is the coordinate dimension + 1 for the value and eventually; the number of all errors. unsigned int DataSize() const. return the size of internal data (number of fit points); if data are not copied in but used externally the size is 0. bool HaveCoordErrors() const. flag to control if data provides error on the coordinates. bool HaveAsymErrors() const. flag to control if data provides asymmetric errors on the value. void Add(double x, double y). add one dim data with only coordinate and values. void Add(double x, double y, double ey). add one dim data with no error in the coordinate (x); in this case store the inverse of the error in the value (y). void Add(double x, double y, double ex, double ey). add one dim data with error in the coordinate (x); in this case store the value (y) error and not the inverse. void Add(double x, double y, double ex, double eyl, double eyh). add one dim data with error in the coordinate (x) and asymmetric errors in the value (y); in this case store the y errors and not the inverse. void Add(const double* x, double val). add multi-dim coordinate data with only value (no errors). void Add(const double* x, double val, double eval). add multi-dim coordinate data with only error in value. void Add(const double* x, double val, const double* ex, double eval). add multi-dim coordinate data with both error in coordinates and value. void Add(co",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:8678,Availability,error,error,8678," error type (to get the full point size); If the data set already exists and it is having the compatible point size space for the new points; is created in the data sets, while if not compatible the old data are erased and new space of; new size is allocated.; (i.e if exists initialize is equivalent to a resize( NPoints() + maxpoints). unsigned int PointSize() const. return the size of a fit point (is the coordinate dimension + 1 for the value and eventually; the number of all errors. unsigned int DataSize() const. return the size of internal data (number of fit points); if data are not copied in but used externally the size is 0. bool HaveCoordErrors() const. flag to control if data provides error on the coordinates. bool HaveAsymErrors() const. flag to control if data provides asymmetric errors on the value. void Add(double x, double y). add one dim data with only coordinate and values. void Add(double x, double y, double ey). add one dim data with no error in the coordinate (x); in this case store the inverse of the error in the value (y). void Add(double x, double y, double ex, double ey). add one dim data with error in the coordinate (x); in this case store the value (y) error and not the inverse. void Add(double x, double y, double ex, double eyl, double eyh). add one dim data with error in the coordinate (x) and asymmetric errors in the value (y); in this case store the y errors and not the inverse. void Add(const double* x, double val). add multi-dim coordinate data with only value (no errors). void Add(const double* x, double val, double eval). add multi-dim coordinate data with only error in value. void Add(const double* x, double val, const double* ex, double eval). add multi-dim coordinate data with both error in coordinates and value. void Add(const double* x, double val, const double* ex, double elval, double ehval). add multi-dim coordinate data with both error in coordinates and value. const double * Coords(unsigned int ipoint) const. return a pointe",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:8745,Availability,error,error,8745," error type (to get the full point size); If the data set already exists and it is having the compatible point size space for the new points; is created in the data sets, while if not compatible the old data are erased and new space of; new size is allocated.; (i.e if exists initialize is equivalent to a resize( NPoints() + maxpoints). unsigned int PointSize() const. return the size of a fit point (is the coordinate dimension + 1 for the value and eventually; the number of all errors. unsigned int DataSize() const. return the size of internal data (number of fit points); if data are not copied in but used externally the size is 0. bool HaveCoordErrors() const. flag to control if data provides error on the coordinates. bool HaveAsymErrors() const. flag to control if data provides asymmetric errors on the value. void Add(double x, double y). add one dim data with only coordinate and values. void Add(double x, double y, double ey). add one dim data with no error in the coordinate (x); in this case store the inverse of the error in the value (y). void Add(double x, double y, double ex, double ey). add one dim data with error in the coordinate (x); in this case store the value (y) error and not the inverse. void Add(double x, double y, double ex, double eyl, double eyh). add one dim data with error in the coordinate (x) and asymmetric errors in the value (y); in this case store the y errors and not the inverse. void Add(const double* x, double val). add multi-dim coordinate data with only value (no errors). void Add(const double* x, double val, double eval). add multi-dim coordinate data with only error in value. void Add(const double* x, double val, const double* ex, double eval). add multi-dim coordinate data with both error in coordinates and value. void Add(const double* x, double val, const double* ex, double elval, double ehval). add multi-dim coordinate data with both error in coordinates and value. const double * Coords(unsigned int ipoint) const. return a pointe",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:8843,Availability,error,error,8843,"sets, while if not compatible the old data are erased and new space of; new size is allocated.; (i.e if exists initialize is equivalent to a resize( NPoints() + maxpoints). unsigned int PointSize() const. return the size of a fit point (is the coordinate dimension + 1 for the value and eventually; the number of all errors. unsigned int DataSize() const. return the size of internal data (number of fit points); if data are not copied in but used externally the size is 0. bool HaveCoordErrors() const. flag to control if data provides error on the coordinates. bool HaveAsymErrors() const. flag to control if data provides asymmetric errors on the value. void Add(double x, double y). add one dim data with only coordinate and values. void Add(double x, double y, double ey). add one dim data with no error in the coordinate (x); in this case store the inverse of the error in the value (y). void Add(double x, double y, double ex, double ey). add one dim data with error in the coordinate (x); in this case store the value (y) error and not the inverse. void Add(double x, double y, double ex, double eyl, double eyh). add one dim data with error in the coordinate (x) and asymmetric errors in the value (y); in this case store the y errors and not the inverse. void Add(const double* x, double val). add multi-dim coordinate data with only value (no errors). void Add(const double* x, double val, double eval). add multi-dim coordinate data with only error in value. void Add(const double* x, double val, const double* ex, double eval). add multi-dim coordinate data with both error in coordinates and value. void Add(const double* x, double val, const double* ex, double elval, double ehval). add multi-dim coordinate data with both error in coordinates and value. const double * Coords(unsigned int ipoint) const. return a pointer to the coordinates data for the given fit point. double Value(unsigned int ipoint) const. return the value for the given fit point. double Error(unsigned int ipoint",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:8905,Availability,error,error,8905,"sets, while if not compatible the old data are erased and new space of; new size is allocated.; (i.e if exists initialize is equivalent to a resize( NPoints() + maxpoints). unsigned int PointSize() const. return the size of a fit point (is the coordinate dimension + 1 for the value and eventually; the number of all errors. unsigned int DataSize() const. return the size of internal data (number of fit points); if data are not copied in but used externally the size is 0. bool HaveCoordErrors() const. flag to control if data provides error on the coordinates. bool HaveAsymErrors() const. flag to control if data provides asymmetric errors on the value. void Add(double x, double y). add one dim data with only coordinate and values. void Add(double x, double y, double ey). add one dim data with no error in the coordinate (x); in this case store the inverse of the error in the value (y). void Add(double x, double y, double ex, double ey). add one dim data with error in the coordinate (x); in this case store the value (y) error and not the inverse. void Add(double x, double y, double ex, double eyl, double eyh). add one dim data with error in the coordinate (x) and asymmetric errors in the value (y); in this case store the y errors and not the inverse. void Add(const double* x, double val). add multi-dim coordinate data with only value (no errors). void Add(const double* x, double val, double eval). add multi-dim coordinate data with only error in value. void Add(const double* x, double val, const double* ex, double eval). add multi-dim coordinate data with both error in coordinates and value. void Add(const double* x, double val, const double* ex, double elval, double ehval). add multi-dim coordinate data with both error in coordinates and value. const double * Coords(unsigned int ipoint) const. return a pointer to the coordinates data for the given fit point. double Value(unsigned int ipoint) const. return the value for the given fit point. double Error(unsigned int ipoint",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:9019,Availability,error,error,9019,"ize() const. return the size of a fit point (is the coordinate dimension + 1 for the value and eventually; the number of all errors. unsigned int DataSize() const. return the size of internal data (number of fit points); if data are not copied in but used externally the size is 0. bool HaveCoordErrors() const. flag to control if data provides error on the coordinates. bool HaveAsymErrors() const. flag to control if data provides asymmetric errors on the value. void Add(double x, double y). add one dim data with only coordinate and values. void Add(double x, double y, double ey). add one dim data with no error in the coordinate (x); in this case store the inverse of the error in the value (y). void Add(double x, double y, double ex, double ey). add one dim data with error in the coordinate (x); in this case store the value (y) error and not the inverse. void Add(double x, double y, double ex, double eyl, double eyh). add one dim data with error in the coordinate (x) and asymmetric errors in the value (y); in this case store the y errors and not the inverse. void Add(const double* x, double val). add multi-dim coordinate data with only value (no errors). void Add(const double* x, double val, double eval). add multi-dim coordinate data with only error in value. void Add(const double* x, double val, const double* ex, double eval). add multi-dim coordinate data with both error in coordinates and value. void Add(const double* x, double val, const double* ex, double elval, double ehval). add multi-dim coordinate data with both error in coordinates and value. const double * Coords(unsigned int ipoint) const. return a pointer to the coordinates data for the given fit point. double Value(unsigned int ipoint) const. return the value for the given fit point. double Error(unsigned int ipoint) const. return error on the value for the given fit point; Safe (but slower) method returning correctly the error on the value; in case of asymm errors return the average 0.5(eu + el). double",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:9062,Availability,error,errors,9062,"ize() const. return the size of a fit point (is the coordinate dimension + 1 for the value and eventually; the number of all errors. unsigned int DataSize() const. return the size of internal data (number of fit points); if data are not copied in but used externally the size is 0. bool HaveCoordErrors() const. flag to control if data provides error on the coordinates. bool HaveAsymErrors() const. flag to control if data provides asymmetric errors on the value. void Add(double x, double y). add one dim data with only coordinate and values. void Add(double x, double y, double ey). add one dim data with no error in the coordinate (x); in this case store the inverse of the error in the value (y). void Add(double x, double y, double ex, double ey). add one dim data with error in the coordinate (x); in this case store the value (y) error and not the inverse. void Add(double x, double y, double ex, double eyl, double eyh). add one dim data with error in the coordinate (x) and asymmetric errors in the value (y); in this case store the y errors and not the inverse. void Add(const double* x, double val). add multi-dim coordinate data with only value (no errors). void Add(const double* x, double val, double eval). add multi-dim coordinate data with only error in value. void Add(const double* x, double val, const double* ex, double eval). add multi-dim coordinate data with both error in coordinates and value. void Add(const double* x, double val, const double* ex, double elval, double ehval). add multi-dim coordinate data with both error in coordinates and value. const double * Coords(unsigned int ipoint) const. return a pointer to the coordinates data for the given fit point. double Value(unsigned int ipoint) const. return the value for the given fit point. double Error(unsigned int ipoint) const. return error on the value for the given fit point; Safe (but slower) method returning correctly the error on the value; in case of asymm errors return the average 0.5(eu + el). double",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:9112,Availability,error,errors,9112,"ize() const. return the size of a fit point (is the coordinate dimension + 1 for the value and eventually; the number of all errors. unsigned int DataSize() const. return the size of internal data (number of fit points); if data are not copied in but used externally the size is 0. bool HaveCoordErrors() const. flag to control if data provides error on the coordinates. bool HaveAsymErrors() const. flag to control if data provides asymmetric errors on the value. void Add(double x, double y). add one dim data with only coordinate and values. void Add(double x, double y, double ey). add one dim data with no error in the coordinate (x); in this case store the inverse of the error in the value (y). void Add(double x, double y, double ex, double ey). add one dim data with error in the coordinate (x); in this case store the value (y) error and not the inverse. void Add(double x, double y, double ex, double eyl, double eyh). add one dim data with error in the coordinate (x) and asymmetric errors in the value (y); in this case store the y errors and not the inverse. void Add(const double* x, double val). add multi-dim coordinate data with only value (no errors). void Add(const double* x, double val, double eval). add multi-dim coordinate data with only error in value. void Add(const double* x, double val, const double* ex, double eval). add multi-dim coordinate data with both error in coordinates and value. void Add(const double* x, double val, const double* ex, double elval, double ehval). add multi-dim coordinate data with both error in coordinates and value. const double * Coords(unsigned int ipoint) const. return a pointer to the coordinates data for the given fit point. double Value(unsigned int ipoint) const. return the value for the given fit point. double Error(unsigned int ipoint) const. return error on the value for the given fit point; Safe (but slower) method returning correctly the error on the value; in case of asymm errors return the average 0.5(eu + el). double",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:9229,Availability,error,errors,9229,"d int DataSize() const. return the size of internal data (number of fit points); if data are not copied in but used externally the size is 0. bool HaveCoordErrors() const. flag to control if data provides error on the coordinates. bool HaveAsymErrors() const. flag to control if data provides asymmetric errors on the value. void Add(double x, double y). add one dim data with only coordinate and values. void Add(double x, double y, double ey). add one dim data with no error in the coordinate (x); in this case store the inverse of the error in the value (y). void Add(double x, double y, double ex, double ey). add one dim data with error in the coordinate (x); in this case store the value (y) error and not the inverse. void Add(double x, double y, double ex, double eyl, double eyh). add one dim data with error in the coordinate (x) and asymmetric errors in the value (y); in this case store the y errors and not the inverse. void Add(const double* x, double val). add multi-dim coordinate data with only value (no errors). void Add(const double* x, double val, double eval). add multi-dim coordinate data with only error in value. void Add(const double* x, double val, const double* ex, double eval). add multi-dim coordinate data with both error in coordinates and value. void Add(const double* x, double val, const double* ex, double elval, double ehval). add multi-dim coordinate data with both error in coordinates and value. const double * Coords(unsigned int ipoint) const. return a pointer to the coordinates data for the given fit point. double Value(unsigned int ipoint) const. return the value for the given fit point. double Error(unsigned int ipoint) const. return error on the value for the given fit point; Safe (but slower) method returning correctly the error on the value; in case of asymm errors return the average 0.5(eu + el). double InvError(unsigned int ipoint) const. Return the inverse of error on the value for the given fit point; useful when error in the coordinates",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:9330,Availability,error,error,9330," used externally the size is 0. bool HaveCoordErrors() const. flag to control if data provides error on the coordinates. bool HaveAsymErrors() const. flag to control if data provides asymmetric errors on the value. void Add(double x, double y). add one dim data with only coordinate and values. void Add(double x, double y, double ey). add one dim data with no error in the coordinate (x); in this case store the inverse of the error in the value (y). void Add(double x, double y, double ex, double ey). add one dim data with error in the coordinate (x); in this case store the value (y) error and not the inverse. void Add(double x, double y, double ex, double eyl, double eyh). add one dim data with error in the coordinate (x) and asymmetric errors in the value (y); in this case store the y errors and not the inverse. void Add(const double* x, double val). add multi-dim coordinate data with only value (no errors). void Add(const double* x, double val, double eval). add multi-dim coordinate data with only error in value. void Add(const double* x, double val, const double* ex, double eval). add multi-dim coordinate data with both error in coordinates and value. void Add(const double* x, double val, const double* ex, double elval, double ehval). add multi-dim coordinate data with both error in coordinates and value. const double * Coords(unsigned int ipoint) const. return a pointer to the coordinates data for the given fit point. double Value(unsigned int ipoint) const. return the value for the given fit point. double Error(unsigned int ipoint) const. return error on the value for the given fit point; Safe (but slower) method returning correctly the error on the value; in case of asymm errors return the average 0.5(eu + el). double InvError(unsigned int ipoint) const. Return the inverse of error on the value for the given fit point; useful when error in the coordinates are not stored and then this is used directly this as the weight in; the least square function. const double",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:9456,Availability,error,error,9456,"Errors() const. flag to control if data provides asymmetric errors on the value. void Add(double x, double y). add one dim data with only coordinate and values. void Add(double x, double y, double ey). add one dim data with no error in the coordinate (x); in this case store the inverse of the error in the value (y). void Add(double x, double y, double ex, double ey). add one dim data with error in the coordinate (x); in this case store the value (y) error and not the inverse. void Add(double x, double y, double ex, double eyl, double eyh). add one dim data with error in the coordinate (x) and asymmetric errors in the value (y); in this case store the y errors and not the inverse. void Add(const double* x, double val). add multi-dim coordinate data with only value (no errors). void Add(const double* x, double val, double eval). add multi-dim coordinate data with only error in value. void Add(const double* x, double val, const double* ex, double eval). add multi-dim coordinate data with both error in coordinates and value. void Add(const double* x, double val, const double* ex, double elval, double ehval). add multi-dim coordinate data with both error in coordinates and value. const double * Coords(unsigned int ipoint) const. return a pointer to the coordinates data for the given fit point. double Value(unsigned int ipoint) const. return the value for the given fit point. double Error(unsigned int ipoint) const. return error on the value for the given fit point; Safe (but slower) method returning correctly the error on the value; in case of asymm errors return the average 0.5(eu + el). double InvError(unsigned int ipoint) const. Return the inverse of error on the value for the given fit point; useful when error in the coordinates are not stored and then this is used directly this as the weight in; the least square function. const double * CoordErrors(unsigned int ipoint) const. Return a pointer to the errors in the coordinates for the given fit point. const double * G",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:9613,Availability,error,error,9613,"es. void Add(double x, double y, double ey). add one dim data with no error in the coordinate (x); in this case store the inverse of the error in the value (y). void Add(double x, double y, double ex, double ey). add one dim data with error in the coordinate (x); in this case store the value (y) error and not the inverse. void Add(double x, double y, double ex, double eyl, double eyh). add one dim data with error in the coordinate (x) and asymmetric errors in the value (y); in this case store the y errors and not the inverse. void Add(const double* x, double val). add multi-dim coordinate data with only value (no errors). void Add(const double* x, double val, double eval). add multi-dim coordinate data with only error in value. void Add(const double* x, double val, const double* ex, double eval). add multi-dim coordinate data with both error in coordinates and value. void Add(const double* x, double val, const double* ex, double elval, double ehval). add multi-dim coordinate data with both error in coordinates and value. const double * Coords(unsigned int ipoint) const. return a pointer to the coordinates data for the given fit point. double Value(unsigned int ipoint) const. return the value for the given fit point. double Error(unsigned int ipoint) const. return error on the value for the given fit point; Safe (but slower) method returning correctly the error on the value; in case of asymm errors return the average 0.5(eu + el). double InvError(unsigned int ipoint) const. Return the inverse of error on the value for the given fit point; useful when error in the coordinates are not stored and then this is used directly this as the weight in; the least square function. const double * CoordErrors(unsigned int ipoint) const. Return a pointer to the errors in the coordinates for the given fit point. const double * GetPoint(unsigned int ipoint, double& value) const. retrieve at the same time a pointer to the coordinate data and the fit value; More efficient than calling ",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:9892,Availability,error,error,9892," ex, double eyl, double eyh). add one dim data with error in the coordinate (x) and asymmetric errors in the value (y); in this case store the y errors and not the inverse. void Add(const double* x, double val). add multi-dim coordinate data with only value (no errors). void Add(const double* x, double val, double eval). add multi-dim coordinate data with only error in value. void Add(const double* x, double val, const double* ex, double eval). add multi-dim coordinate data with both error in coordinates and value. void Add(const double* x, double val, const double* ex, double elval, double ehval). add multi-dim coordinate data with both error in coordinates and value. const double * Coords(unsigned int ipoint) const. return a pointer to the coordinates data for the given fit point. double Value(unsigned int ipoint) const. return the value for the given fit point. double Error(unsigned int ipoint) const. return error on the value for the given fit point; Safe (but slower) method returning correctly the error on the value; in case of asymm errors return the average 0.5(eu + el). double InvError(unsigned int ipoint) const. Return the inverse of error on the value for the given fit point; useful when error in the coordinates are not stored and then this is used directly this as the weight in; the least square function. const double * CoordErrors(unsigned int ipoint) const. Return a pointer to the errors in the coordinates for the given fit point. const double * GetPoint(unsigned int ipoint, double& value) const. retrieve at the same time a pointer to the coordinate data and the fit value; More efficient than calling Coords(i) and Value(i). const double * GetPoint(unsigned int ipoint, double& value, double& invError) const. retrieve in a single call a pointer to the coordinate data, value and inverse error for; the given fit point.; To be used only when type is kValueError or kNoError. In the last case the value 1 is returned; for the error. const double * GetPointError",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:9985,Availability,error,error,9985," ex, double eyl, double eyh). add one dim data with error in the coordinate (x) and asymmetric errors in the value (y); in this case store the y errors and not the inverse. void Add(const double* x, double val). add multi-dim coordinate data with only value (no errors). void Add(const double* x, double val, double eval). add multi-dim coordinate data with only error in value. void Add(const double* x, double val, const double* ex, double eval). add multi-dim coordinate data with both error in coordinates and value. void Add(const double* x, double val, const double* ex, double elval, double ehval). add multi-dim coordinate data with both error in coordinates and value. const double * Coords(unsigned int ipoint) const. return a pointer to the coordinates data for the given fit point. double Value(unsigned int ipoint) const. return the value for the given fit point. double Error(unsigned int ipoint) const. return error on the value for the given fit point; Safe (but slower) method returning correctly the error on the value; in case of asymm errors return the average 0.5(eu + el). double InvError(unsigned int ipoint) const. Return the inverse of error on the value for the given fit point; useful when error in the coordinates are not stored and then this is used directly this as the weight in; the least square function. const double * CoordErrors(unsigned int ipoint) const. Return a pointer to the errors in the coordinates for the given fit point. const double * GetPoint(unsigned int ipoint, double& value) const. retrieve at the same time a pointer to the coordinate data and the fit value; More efficient than calling Coords(i) and Value(i). const double * GetPoint(unsigned int ipoint, double& value, double& invError) const. retrieve in a single call a pointer to the coordinate data, value and inverse error for; the given fit point.; To be used only when type is kValueError or kNoError. In the last case the value 1 is returned; for the error. const double * GetPointError",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:10022,Availability,error,errors,10022," ex, double eyl, double eyh). add one dim data with error in the coordinate (x) and asymmetric errors in the value (y); in this case store the y errors and not the inverse. void Add(const double* x, double val). add multi-dim coordinate data with only value (no errors). void Add(const double* x, double val, double eval). add multi-dim coordinate data with only error in value. void Add(const double* x, double val, const double* ex, double eval). add multi-dim coordinate data with both error in coordinates and value. void Add(const double* x, double val, const double* ex, double elval, double ehval). add multi-dim coordinate data with both error in coordinates and value. const double * Coords(unsigned int ipoint) const. return a pointer to the coordinates data for the given fit point. double Value(unsigned int ipoint) const. return the value for the given fit point. double Error(unsigned int ipoint) const. return error on the value for the given fit point; Safe (but slower) method returning correctly the error on the value; in case of asymm errors return the average 0.5(eu + el). double InvError(unsigned int ipoint) const. Return the inverse of error on the value for the given fit point; useful when error in the coordinates are not stored and then this is used directly this as the weight in; the least square function. const double * CoordErrors(unsigned int ipoint) const. Return a pointer to the errors in the coordinates for the given fit point. const double * GetPoint(unsigned int ipoint, double& value) const. retrieve at the same time a pointer to the coordinate data and the fit value; More efficient than calling Coords(i) and Value(i). const double * GetPoint(unsigned int ipoint, double& value, double& invError) const. retrieve in a single call a pointer to the coordinate data, value and inverse error for; the given fit point.; To be used only when type is kValueError or kNoError. In the last case the value 1 is returned; for the error. const double * GetPointError",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:10128,Availability,error,error,10128,"data with only value (no errors). void Add(const double* x, double val, double eval). add multi-dim coordinate data with only error in value. void Add(const double* x, double val, const double* ex, double eval). add multi-dim coordinate data with both error in coordinates and value. void Add(const double* x, double val, const double* ex, double elval, double ehval). add multi-dim coordinate data with both error in coordinates and value. const double * Coords(unsigned int ipoint) const. return a pointer to the coordinates data for the given fit point. double Value(unsigned int ipoint) const. return the value for the given fit point. double Error(unsigned int ipoint) const. return error on the value for the given fit point; Safe (but slower) method returning correctly the error on the value; in case of asymm errors return the average 0.5(eu + el). double InvError(unsigned int ipoint) const. Return the inverse of error on the value for the given fit point; useful when error in the coordinates are not stored and then this is used directly this as the weight in; the least square function. const double * CoordErrors(unsigned int ipoint) const. Return a pointer to the errors in the coordinates for the given fit point. const double * GetPoint(unsigned int ipoint, double& value) const. retrieve at the same time a pointer to the coordinate data and the fit value; More efficient than calling Coords(i) and Value(i). const double * GetPoint(unsigned int ipoint, double& value, double& invError) const. retrieve in a single call a pointer to the coordinate data, value and inverse error for; the given fit point.; To be used only when type is kValueError or kNoError. In the last case the value 1 is returned; for the error. const double * GetPointError(unsigned int ipoint, double& errvalue) const. Retrieve the errors on the point (coordinate and value) for the given fit point; It must be called only when the coordinate errors are stored otherwise it will produce an; assert. const doubl",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:10184,Availability,error,error,10184,"data with only value (no errors). void Add(const double* x, double val, double eval). add multi-dim coordinate data with only error in value. void Add(const double* x, double val, const double* ex, double eval). add multi-dim coordinate data with both error in coordinates and value. void Add(const double* x, double val, const double* ex, double elval, double ehval). add multi-dim coordinate data with both error in coordinates and value. const double * Coords(unsigned int ipoint) const. return a pointer to the coordinates data for the given fit point. double Value(unsigned int ipoint) const. return the value for the given fit point. double Error(unsigned int ipoint) const. return error on the value for the given fit point; Safe (but slower) method returning correctly the error on the value; in case of asymm errors return the average 0.5(eu + el). double InvError(unsigned int ipoint) const. Return the inverse of error on the value for the given fit point; useful when error in the coordinates are not stored and then this is used directly this as the weight in; the least square function. const double * CoordErrors(unsigned int ipoint) const. Return a pointer to the errors in the coordinates for the given fit point. const double * GetPoint(unsigned int ipoint, double& value) const. retrieve at the same time a pointer to the coordinate data and the fit value; More efficient than calling Coords(i) and Value(i). const double * GetPoint(unsigned int ipoint, double& value, double& invError) const. retrieve in a single call a pointer to the coordinate data, value and inverse error for; the given fit point.; To be used only when type is kValueError or kNoError. In the last case the value 1 is returned; for the error. const double * GetPointError(unsigned int ipoint, double& errvalue) const. Retrieve the errors on the point (coordinate and value) for the given fit point; It must be called only when the coordinate errors are stored otherwise it will produce an; assert. const doubl",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:10384,Availability,error,errors,10384,"* ex, double eval). add multi-dim coordinate data with both error in coordinates and value. void Add(const double* x, double val, const double* ex, double elval, double ehval). add multi-dim coordinate data with both error in coordinates and value. const double * Coords(unsigned int ipoint) const. return a pointer to the coordinates data for the given fit point. double Value(unsigned int ipoint) const. return the value for the given fit point. double Error(unsigned int ipoint) const. return error on the value for the given fit point; Safe (but slower) method returning correctly the error on the value; in case of asymm errors return the average 0.5(eu + el). double InvError(unsigned int ipoint) const. Return the inverse of error on the value for the given fit point; useful when error in the coordinates are not stored and then this is used directly this as the weight in; the least square function. const double * CoordErrors(unsigned int ipoint) const. Return a pointer to the errors in the coordinates for the given fit point. const double * GetPoint(unsigned int ipoint, double& value) const. retrieve at the same time a pointer to the coordinate data and the fit value; More efficient than calling Coords(i) and Value(i). const double * GetPoint(unsigned int ipoint, double& value, double& invError) const. retrieve in a single call a pointer to the coordinate data, value and inverse error for; the given fit point.; To be used only when type is kValueError or kNoError. In the last case the value 1 is returned; for the error. const double * GetPointError(unsigned int ipoint, double& errvalue) const. Retrieve the errors on the point (coordinate and value) for the given fit point; It must be called only when the coordinate errors are stored otherwise it will produce an; assert. const double * GetPointError(unsigned int ipoint, double& errlow, double& errhigh) const. Get errors on the point (coordinate errors and asymmetric value errors) for the; given fit point.; It must be cal",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:10795,Availability,error,error,10795,"ue(unsigned int ipoint) const. return the value for the given fit point. double Error(unsigned int ipoint) const. return error on the value for the given fit point; Safe (but slower) method returning correctly the error on the value; in case of asymm errors return the average 0.5(eu + el). double InvError(unsigned int ipoint) const. Return the inverse of error on the value for the given fit point; useful when error in the coordinates are not stored and then this is used directly this as the weight in; the least square function. const double * CoordErrors(unsigned int ipoint) const. Return a pointer to the errors in the coordinates for the given fit point. const double * GetPoint(unsigned int ipoint, double& value) const. retrieve at the same time a pointer to the coordinate data and the fit value; More efficient than calling Coords(i) and Value(i). const double * GetPoint(unsigned int ipoint, double& value, double& invError) const. retrieve in a single call a pointer to the coordinate data, value and inverse error for; the given fit point.; To be used only when type is kValueError or kNoError. In the last case the value 1 is returned; for the error. const double * GetPointError(unsigned int ipoint, double& errvalue) const. Retrieve the errors on the point (coordinate and value) for the given fit point; It must be called only when the coordinate errors are stored otherwise it will produce an; assert. const double * GetPointError(unsigned int ipoint, double& errlow, double& errhigh) const. Get errors on the point (coordinate errors and asymmetric value errors) for the; given fit point.; It must be called only when the coordinate errors and asymmetric errors are stored; otherwise it will produce an assert. void Resize(unsigned int npoints). resize the vector to the new given npoints; if vector does not exists is created using existing point size. unsigned int NPoints() const. return number of fit points. { return fNPoints; }. unsigned int Size() const. return number of",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:10932,Availability,error,error,10932,"e for the given fit point; Safe (but slower) method returning correctly the error on the value; in case of asymm errors return the average 0.5(eu + el). double InvError(unsigned int ipoint) const. Return the inverse of error on the value for the given fit point; useful when error in the coordinates are not stored and then this is used directly this as the weight in; the least square function. const double * CoordErrors(unsigned int ipoint) const. Return a pointer to the errors in the coordinates for the given fit point. const double * GetPoint(unsigned int ipoint, double& value) const. retrieve at the same time a pointer to the coordinate data and the fit value; More efficient than calling Coords(i) and Value(i). const double * GetPoint(unsigned int ipoint, double& value, double& invError) const. retrieve in a single call a pointer to the coordinate data, value and inverse error for; the given fit point.; To be used only when type is kValueError or kNoError. In the last case the value 1 is returned; for the error. const double * GetPointError(unsigned int ipoint, double& errvalue) const. Retrieve the errors on the point (coordinate and value) for the given fit point; It must be called only when the coordinate errors are stored otherwise it will produce an; assert. const double * GetPointError(unsigned int ipoint, double& errlow, double& errhigh) const. Get errors on the point (coordinate errors and asymmetric value errors) for the; given fit point.; It must be called only when the coordinate errors and asymmetric errors are stored; otherwise it will produce an assert. void Resize(unsigned int npoints). resize the vector to the new given npoints; if vector does not exists is created using existing point size. unsigned int NPoints() const. return number of fit points. { return fNPoints; }. unsigned int Size() const. return number of fit points. { return fNPoints; }. unsigned int NDim() const. return coordinate data dimension. { return fDim; }. BinData & LogTransform().",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:11027,Availability,error,errors,11027,"t. Return the inverse of error on the value for the given fit point; useful when error in the coordinates are not stored and then this is used directly this as the weight in; the least square function. const double * CoordErrors(unsigned int ipoint) const. Return a pointer to the errors in the coordinates for the given fit point. const double * GetPoint(unsigned int ipoint, double& value) const. retrieve at the same time a pointer to the coordinate data and the fit value; More efficient than calling Coords(i) and Value(i). const double * GetPoint(unsigned int ipoint, double& value, double& invError) const. retrieve in a single call a pointer to the coordinate data, value and inverse error for; the given fit point.; To be used only when type is kValueError or kNoError. In the last case the value 1 is returned; for the error. const double * GetPointError(unsigned int ipoint, double& errvalue) const. Retrieve the errors on the point (coordinate and value) for the given fit point; It must be called only when the coordinate errors are stored otherwise it will produce an; assert. const double * GetPointError(unsigned int ipoint, double& errlow, double& errhigh) const. Get errors on the point (coordinate errors and asymmetric value errors) for the; given fit point.; It must be called only when the coordinate errors and asymmetric errors are stored; otherwise it will produce an assert. void Resize(unsigned int npoints). resize the vector to the new given npoints; if vector does not exists is created using existing point size. unsigned int NPoints() const. return number of fit points. { return fNPoints; }. unsigned int Size() const. return number of fit points. { return fNPoints; }. unsigned int NDim() const. return coordinate data dimension. { return fDim; }. BinData & LogTransform(). apply a Log transformation of the data values; can be used for example when fitting an exponential or gaussian; Transform the data in place need to copy if want to preserve original data; The ",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:11138,Availability,error,errors,11138,"t. Return the inverse of error on the value for the given fit point; useful when error in the coordinates are not stored and then this is used directly this as the weight in; the least square function. const double * CoordErrors(unsigned int ipoint) const. Return a pointer to the errors in the coordinates for the given fit point. const double * GetPoint(unsigned int ipoint, double& value) const. retrieve at the same time a pointer to the coordinate data and the fit value; More efficient than calling Coords(i) and Value(i). const double * GetPoint(unsigned int ipoint, double& value, double& invError) const. retrieve in a single call a pointer to the coordinate data, value and inverse error for; the given fit point.; To be used only when type is kValueError or kNoError. In the last case the value 1 is returned; for the error. const double * GetPointError(unsigned int ipoint, double& errvalue) const. Retrieve the errors on the point (coordinate and value) for the given fit point; It must be called only when the coordinate errors are stored otherwise it will produce an; assert. const double * GetPointError(unsigned int ipoint, double& errlow, double& errhigh) const. Get errors on the point (coordinate errors and asymmetric value errors) for the; given fit point.; It must be called only when the coordinate errors and asymmetric errors are stored; otherwise it will produce an assert. void Resize(unsigned int npoints). resize the vector to the new given npoints; if vector does not exists is created using existing point size. unsigned int NPoints() const. return number of fit points. { return fNPoints; }. unsigned int Size() const. return number of fit points. { return fNPoints; }. unsigned int NDim() const. return coordinate data dimension. { return fDim; }. BinData & LogTransform(). apply a Log transformation of the data values; can be used for example when fitting an exponential or gaussian; Transform the data in place need to copy if want to preserve original data; The ",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:11288,Availability,error,errors,11288,"unsigned int ipoint) const. Return a pointer to the errors in the coordinates for the given fit point. const double * GetPoint(unsigned int ipoint, double& value) const. retrieve at the same time a pointer to the coordinate data and the fit value; More efficient than calling Coords(i) and Value(i). const double * GetPoint(unsigned int ipoint, double& value, double& invError) const. retrieve in a single call a pointer to the coordinate data, value and inverse error for; the given fit point.; To be used only when type is kValueError or kNoError. In the last case the value 1 is returned; for the error. const double * GetPointError(unsigned int ipoint, double& errvalue) const. Retrieve the errors on the point (coordinate and value) for the given fit point; It must be called only when the coordinate errors are stored otherwise it will produce an; assert. const double * GetPointError(unsigned int ipoint, double& errlow, double& errhigh) const. Get errors on the point (coordinate errors and asymmetric value errors) for the; given fit point.; It must be called only when the coordinate errors and asymmetric errors are stored; otherwise it will produce an assert. void Resize(unsigned int npoints). resize the vector to the new given npoints; if vector does not exists is created using existing point size. unsigned int NPoints() const. return number of fit points. { return fNPoints; }. unsigned int Size() const. return number of fit points. { return fNPoints; }. unsigned int NDim() const. return coordinate data dimension. { return fDim; }. BinData & LogTransform(). apply a Log transformation of the data values; can be used for example when fitting an exponential or gaussian; Transform the data in place need to copy if want to preserve original data; The data sets must not contain negative values. IN case it does,; an empty data set is returned. const double * BinUpEdge(unsigned int icoord) const. return an array containing the upper edge of the bin for coordinate i; In case of e",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:11320,Availability,error,errors,11320,"unsigned int ipoint) const. Return a pointer to the errors in the coordinates for the given fit point. const double * GetPoint(unsigned int ipoint, double& value) const. retrieve at the same time a pointer to the coordinate data and the fit value; More efficient than calling Coords(i) and Value(i). const double * GetPoint(unsigned int ipoint, double& value, double& invError) const. retrieve in a single call a pointer to the coordinate data, value and inverse error for; the given fit point.; To be used only when type is kValueError or kNoError. In the last case the value 1 is returned; for the error. const double * GetPointError(unsigned int ipoint, double& errvalue) const. Retrieve the errors on the point (coordinate and value) for the given fit point; It must be called only when the coordinate errors are stored otherwise it will produce an; assert. const double * GetPointError(unsigned int ipoint, double& errlow, double& errhigh) const. Get errors on the point (coordinate errors and asymmetric value errors) for the; given fit point.; It must be called only when the coordinate errors and asymmetric errors are stored; otherwise it will produce an assert. void Resize(unsigned int npoints). resize the vector to the new given npoints; if vector does not exists is created using existing point size. unsigned int NPoints() const. return number of fit points. { return fNPoints; }. unsigned int Size() const. return number of fit points. { return fNPoints; }. unsigned int NDim() const. return coordinate data dimension. { return fDim; }. BinData & LogTransform(). apply a Log transformation of the data values; can be used for example when fitting an exponential or gaussian; Transform the data in place need to copy if want to preserve original data; The data sets must not contain negative values. IN case it does,; an empty data set is returned. const double * BinUpEdge(unsigned int icoord) const. return an array containing the upper edge of the bin for coordinate i; In case of e",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:11348,Availability,error,errors,11348,"unsigned int ipoint) const. Return a pointer to the errors in the coordinates for the given fit point. const double * GetPoint(unsigned int ipoint, double& value) const. retrieve at the same time a pointer to the coordinate data and the fit value; More efficient than calling Coords(i) and Value(i). const double * GetPoint(unsigned int ipoint, double& value, double& invError) const. retrieve in a single call a pointer to the coordinate data, value and inverse error for; the given fit point.; To be used only when type is kValueError or kNoError. In the last case the value 1 is returned; for the error. const double * GetPointError(unsigned int ipoint, double& errvalue) const. Retrieve the errors on the point (coordinate and value) for the given fit point; It must be called only when the coordinate errors are stored otherwise it will produce an; assert. const double * GetPointError(unsigned int ipoint, double& errlow, double& errhigh) const. Get errors on the point (coordinate errors and asymmetric value errors) for the; given fit point.; It must be called only when the coordinate errors and asymmetric errors are stored; otherwise it will produce an assert. void Resize(unsigned int npoints). resize the vector to the new given npoints; if vector does not exists is created using existing point size. unsigned int NPoints() const. return number of fit points. { return fNPoints; }. unsigned int Size() const. return number of fit points. { return fNPoints; }. unsigned int NDim() const. return coordinate data dimension. { return fDim; }. BinData & LogTransform(). apply a Log transformation of the data values; can be used for example when fitting an exponential or gaussian; Transform the data in place need to copy if want to preserve original data; The data sets must not contain negative values. IN case it does,; an empty data set is returned. const double * BinUpEdge(unsigned int icoord) const. return an array containing the upper edge of the bin for coordinate i; In case of e",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:11426,Availability,error,errors,11426,"ouble * GetPoint(unsigned int ipoint, double& value) const. retrieve at the same time a pointer to the coordinate data and the fit value; More efficient than calling Coords(i) and Value(i). const double * GetPoint(unsigned int ipoint, double& value, double& invError) const. retrieve in a single call a pointer to the coordinate data, value and inverse error for; the given fit point.; To be used only when type is kValueError or kNoError. In the last case the value 1 is returned; for the error. const double * GetPointError(unsigned int ipoint, double& errvalue) const. Retrieve the errors on the point (coordinate and value) for the given fit point; It must be called only when the coordinate errors are stored otherwise it will produce an; assert. const double * GetPointError(unsigned int ipoint, double& errlow, double& errhigh) const. Get errors on the point (coordinate errors and asymmetric value errors) for the; given fit point.; It must be called only when the coordinate errors and asymmetric errors are stored; otherwise it will produce an assert. void Resize(unsigned int npoints). resize the vector to the new given npoints; if vector does not exists is created using existing point size. unsigned int NPoints() const. return number of fit points. { return fNPoints; }. unsigned int Size() const. return number of fit points. { return fNPoints; }. unsigned int NDim() const. return coordinate data dimension. { return fDim; }. BinData & LogTransform(). apply a Log transformation of the data values; can be used for example when fitting an exponential or gaussian; Transform the data in place need to copy if want to preserve original data; The data sets must not contain negative values. IN case it does,; an empty data set is returned. const double * BinUpEdge(unsigned int icoord) const. return an array containing the upper edge of the bin for coordinate i; In case of empty bin they could be merged in a single larger bin; Return a NULL pointer if the bin width is not stored. bo",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:11448,Availability,error,errors,11448,"ouble * GetPoint(unsigned int ipoint, double& value) const. retrieve at the same time a pointer to the coordinate data and the fit value; More efficient than calling Coords(i) and Value(i). const double * GetPoint(unsigned int ipoint, double& value, double& invError) const. retrieve in a single call a pointer to the coordinate data, value and inverse error for; the given fit point.; To be used only when type is kValueError or kNoError. In the last case the value 1 is returned; for the error. const double * GetPointError(unsigned int ipoint, double& errvalue) const. Retrieve the errors on the point (coordinate and value) for the given fit point; It must be called only when the coordinate errors are stored otherwise it will produce an; assert. const double * GetPointError(unsigned int ipoint, double& errlow, double& errhigh) const. Get errors on the point (coordinate errors and asymmetric value errors) for the; given fit point.; It must be called only when the coordinate errors and asymmetric errors are stored; otherwise it will produce an assert. void Resize(unsigned int npoints). resize the vector to the new given npoints; if vector does not exists is created using existing point size. unsigned int NPoints() const. return number of fit points. { return fNPoints; }. unsigned int Size() const. return number of fit points. { return fNPoints; }. unsigned int NDim() const. return coordinate data dimension. { return fDim; }. BinData & LogTransform(). apply a Log transformation of the data values; can be used for example when fitting an exponential or gaussian; Transform the data in place need to copy if want to preserve original data; The data sets must not contain negative values. IN case it does,; an empty data set is returned. const double * BinUpEdge(unsigned int icoord) const. return an array containing the upper edge of the bin for coordinate i; In case of empty bin they could be merged in a single larger bin; Return a NULL pointer if the bin width is not stored. bo",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:13284,Availability,error,error,13284,"return number of fit points. { return fNPoints; }. unsigned int NDim() const. return coordinate data dimension. { return fDim; }. BinData & LogTransform(). apply a Log transformation of the data values; can be used for example when fitting an exponential or gaussian; Transform the data in place need to copy if want to preserve original data; The data sets must not contain negative values. IN case it does,; an empty data set is returned. const double * BinUpEdge(unsigned int icoord) const. return an array containing the upper edge of the bin for coordinate i; In case of empty bin they could be merged in a single larger bin; Return a NULL pointer if the bin width is not stored. bool HasBinEdges() const. query if the data store the bin edges instead of the center. void AddBinUpEdge(const double* xup). add the bin width data, a pointer to an array with the bin upper edge information.; This is needed when fitting with integral options; The information is added for the previously inserted point.; BinData::Add must be called before. double RefVolume() const. retrieve the reference volume used to normalize the data when the option bin volume is set. { return fRefVolume; }. void SetRefVolume(double value). set the reference volume used to normalize the data when the option bin volume is set. { fRefVolume = value; }. double SumOfContent() const. compute the total sum of the data content; (sum of weights in cse of weighted data set). { return fSumContent; }. double SumOfError2() const. compute the total sum of the error square; (sum of weight square in case of a weighted data set). { return fSumError2;}. void SetNPoints(unsigned int n); { fNPoints = n; }.  Author: L. Moneta Wed Aug 30 11:15:23 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:1054,Energy Efficiency,efficient,efficient,1054,"Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::BinData. class ROOT::Fit::BinData: public ROOT::Fit::FitData. Class describing the binned data sets :; vectors of x coordinates, y values and optionally error on y values and error on coordinates; The dimension of the coordinate is free; There are 4 different options:; - only coordinates and values (for binned likelihood fits) : kNoError; - coordinate, values and error on values (for normal least square fits) : kValueError; - coordinate, values, error on values and coordinates (for effective least square fits) : kCoordError; - corrdinate, values, error on coordinates and asymmettric error on valyes : kAsymError. In addition there is the option to construct Bindata copying the data in (using the DataVector class); or using pointer to external data (DataWrapper) class.; In general is found to be more efficient to copy the data.; In case of really large data sets for limiting memory consumption then the other option can be used; Specialized constructor exists for data up to 3 dimensions. When the data are copying in the number of points can be set later (or re-set) using Initialize and; the data are inserted one by one using the Add method.; It is mandatory to set the size before using the Add method. @ingroup FitData. Function Members (Methods); public:. virtual~BinData(); voidAdd(double x, double y); voidAdd(const double* x, double val); voidAdd(double x, double y, double ey); voidAdd(const double* x, double val, double eval); voidAdd(double x, double y, double ex, double ey); voidAdd(const double* x, double val, const double* ex, double eval); voidAdd(double x, double y, double ex, double eyl, double eyh); voidAdd(const double* x, double val, const double* ex, double elval, double ehval); voidAddBinUpEdge(const double* xup); ROOT::Fit::BinDataBinData(const ROOT::Fit::BinData&)",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:1137,Energy Efficiency,consumption,consumption,1137,"ction members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::BinData. class ROOT::Fit::BinData: public ROOT::Fit::FitData. Class describing the binned data sets :; vectors of x coordinates, y values and optionally error on y values and error on coordinates; The dimension of the coordinate is free; There are 4 different options:; - only coordinates and values (for binned likelihood fits) : kNoError; - coordinate, values and error on values (for normal least square fits) : kValueError; - coordinate, values, error on values and coordinates (for effective least square fits) : kCoordError; - corrdinate, values, error on coordinates and asymmettric error on valyes : kAsymError. In addition there is the option to construct Bindata copying the data in (using the DataVector class); or using pointer to external data (DataWrapper) class.; In general is found to be more efficient to copy the data.; In case of really large data sets for limiting memory consumption then the other option can be used; Specialized constructor exists for data up to 3 dimensions. When the data are copying in the number of points can be set later (or re-set) using Initialize and; the data are inserted one by one using the Add method.; It is mandatory to set the size before using the Add method. @ingroup FitData. Function Members (Methods); public:. virtual~BinData(); voidAdd(double x, double y); voidAdd(const double* x, double val); voidAdd(double x, double y, double ey); voidAdd(const double* x, double val, double eval); voidAdd(double x, double y, double ex, double ey); voidAdd(const double* x, double val, const double* ex, double eval); voidAdd(double x, double y, double ex, double eyl, double eyh); voidAdd(const double* x, double val, const double* ex, double elval, double ehval); voidAddBinUpEdge(const double* xup); ROOT::Fit::BinDataBinData(const ROOT::Fit::BinData&); ROOT::Fit::BinDataBinData(unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:6164,Energy Efficiency,allocate,allocate,6164,") ; ROOT::Fit::DataVector*fDataVectorpointer to the copied in data vector; ROOT::Fit::DataWrapper*fDataWrapperpointer to the external data wrapper structure; unsigned intfDimcoordinate dimension; unsigned intfNPointsnumber of contained points in the data set (can be different than size of vector); unsigned intfPointSizetotal point size including value and errors (= fDim + 2 for error in only Y ) ; doublefRefVolumereference bin volume - used to normalize the bins in case of variable bins data; doublefSumContenttotal sum of the bin data content ; doublefSumError2total sum square of the errors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; unsigned int GetPointSize(ROOT::Fit::BinData::ErrorType err, unsigned int dim). ErrorType GetErrorType() const. explicit BinData(unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from dimension of point and max number of points (to pre-allocate vector); Give a zero value and then use Initialize later one if the size is not known. explicit BinData(const ROOT::Fit::DataOptions& opt, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from option and default range. BinData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from options and range; efault is 1D and value errors. BinData(unsigned int n, const double* dataX, const double* val, const double* ex, const double* eval); constructurs using external data . constructor from external data for 1D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* val, const double* ex, const double* ey, const double* eval). constructor from external data for 2D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, co",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:7959,Energy Efficiency,allocate,allocated,7959,"urs using external data . constructor from external data for 1D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* val, const double* ex, const double* ey, const double* eval). constructor from external data for 2D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* dataZ, const double* val, const double* ex, const double* ey, const double* ez, const double* eval). constructor from external data for 3D with errors on coordinate and value. BinData(const ROOT::Fit::BinData& ). copy constructors. BinData & operator=(const ROOT::Fit::BinData& ). assignment operator. virtual ~BinData(). destructor. void Initialize(unsigned int maxpoints, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). preallocate a data set with given size , dimension and error type (to get the full point size); If the data set already exists and it is having the compatible point size space for the new points; is created in the data sets, while if not compatible the old data are erased and new space of; new size is allocated.; (i.e if exists initialize is equivalent to a resize( NPoints() + maxpoints). unsigned int PointSize() const. return the size of a fit point (is the coordinate dimension + 1 for the value and eventually; the number of all errors. unsigned int DataSize() const. return the size of internal data (number of fit points); if data are not copied in but used externally the size is 0. bool HaveCoordErrors() const. flag to control if data provides error on the coordinates. bool HaveAsymErrors() const. flag to control if data provides asymmetric errors on the value. void Add(double x, double y). add one dim data with only coordinate and values. void Add(double x, double y, double ey). add one dim data with no error in the coordinate (x); in this case store the inverse of the error in the value (y). void Add(double x, double y, double ex, dou",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:10585,Energy Efficiency,efficient,efficient,10585,"hval). add multi-dim coordinate data with both error in coordinates and value. const double * Coords(unsigned int ipoint) const. return a pointer to the coordinates data for the given fit point. double Value(unsigned int ipoint) const. return the value for the given fit point. double Error(unsigned int ipoint) const. return error on the value for the given fit point; Safe (but slower) method returning correctly the error on the value; in case of asymm errors return the average 0.5(eu + el). double InvError(unsigned int ipoint) const. Return the inverse of error on the value for the given fit point; useful when error in the coordinates are not stored and then this is used directly this as the weight in; the least square function. const double * CoordErrors(unsigned int ipoint) const. Return a pointer to the errors in the coordinates for the given fit point. const double * GetPoint(unsigned int ipoint, double& value) const. retrieve at the same time a pointer to the coordinate data and the fit value; More efficient than calling Coords(i) and Value(i). const double * GetPoint(unsigned int ipoint, double& value, double& invError) const. retrieve in a single call a pointer to the coordinate data, value and inverse error for; the given fit point.; To be used only when type is kValueError or kNoError. In the last case the value 1 is returned; for the error. const double * GetPointError(unsigned int ipoint, double& errvalue) const. Retrieve the errors on the point (coordinate and value) for the given fit point; It must be called only when the coordinate errors are stored otherwise it will produce an; assert. const double * GetPointError(unsigned int ipoint, double& errlow, double& errhigh) const. Get errors on the point (coordinate errors and asymmetric value errors) for the; given fit point.; It must be called only when the coordinate errors and asymmetric errors are stored; otherwise it will produce an assert. void Resize(unsigned int npoints). resize the vector to the ne",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:5315,Integrability,wrap,wrapper,5315,"const; unsigned intNPoints() const; ROOT::Fit::BinData&operator=(const ROOT::Fit::BinData&); const ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt() const; ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt(); unsigned intPointSize() const; const ROOT::Fit::DataRange&ROOT::Fit::FitData::Range() const; doubleRefVolume() const; voidResize(unsigned int npoints); voidSetRefVolume(double value); unsigned intSize() const; doubleSumOfContent() const; doubleSumOfError2() const; doubleValue(unsigned int ipoint) const. protected:. voidSetNPoints(unsigned int n). Data Members; public:. enum ErrorType { kNoError; kValueError; kCoordError; kAsymError; };. private:. vector<double>fBinEdgevector containing the bin upper edge (coordinate will contain low edge) ; ROOT::Fit::DataVector*fDataVectorpointer to the copied in data vector; ROOT::Fit::DataWrapper*fDataWrapperpointer to the external data wrapper structure; unsigned intfDimcoordinate dimension; unsigned intfNPointsnumber of contained points in the data set (can be different than size of vector); unsigned intfPointSizetotal point size including value and errors (= fDim + 2 for error in only Y ) ; doublefRefVolumereference bin volume - used to normalize the bins in case of variable bins data; doublefSumContenttotal sum of the bin data content ; doublefSumError2total sum square of the errors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; unsigned int GetPointSize(ROOT::Fit::BinData::ErrorType err, unsigned int dim). ErrorType GetErrorType() const. explicit BinData(unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from dimension of point and max number of points (to pre-allocate vector); Give a zero value and then use Initialize later one if the size is not known. explicit BinData(const ROOT::Fit::DataOptions& opt, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from ",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:5654,Modifiability,variab,variable,5654,"const; unsigned intNPoints() const; ROOT::Fit::BinData&operator=(const ROOT::Fit::BinData&); const ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt() const; ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt(); unsigned intPointSize() const; const ROOT::Fit::DataRange&ROOT::Fit::FitData::Range() const; doubleRefVolume() const; voidResize(unsigned int npoints); voidSetRefVolume(double value); unsigned intSize() const; doubleSumOfContent() const; doubleSumOfError2() const; doubleValue(unsigned int ipoint) const. protected:. voidSetNPoints(unsigned int n). Data Members; public:. enum ErrorType { kNoError; kValueError; kCoordError; kAsymError; };. private:. vector<double>fBinEdgevector containing the bin upper edge (coordinate will contain low edge) ; ROOT::Fit::DataVector*fDataVectorpointer to the copied in data vector; ROOT::Fit::DataWrapper*fDataWrapperpointer to the external data wrapper structure; unsigned intfDimcoordinate dimension; unsigned intfNPointsnumber of contained points in the data set (can be different than size of vector); unsigned intfPointSizetotal point size including value and errors (= fDim + 2 for error in only Y ) ; doublefRefVolumereference bin volume - used to normalize the bins in case of variable bins data; doublefSumContenttotal sum of the bin data content ; doublefSumError2total sum square of the errors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; unsigned int GetPointSize(ROOT::Fit::BinData::ErrorType err, unsigned int dim). ErrorType GetErrorType() const. explicit BinData(unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from dimension of point and max number of points (to pre-allocate vector); Give a zero value and then use Initialize later one if the size is not known. explicit BinData(const ROOT::Fit::DataOptions& opt, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from ",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:11186,Testability,assert,assert,11186,"t. Return the inverse of error on the value for the given fit point; useful when error in the coordinates are not stored and then this is used directly this as the weight in; the least square function. const double * CoordErrors(unsigned int ipoint) const. Return a pointer to the errors in the coordinates for the given fit point. const double * GetPoint(unsigned int ipoint, double& value) const. retrieve at the same time a pointer to the coordinate data and the fit value; More efficient than calling Coords(i) and Value(i). const double * GetPoint(unsigned int ipoint, double& value, double& invError) const. retrieve in a single call a pointer to the coordinate data, value and inverse error for; the given fit point.; To be used only when type is kValueError or kNoError. In the last case the value 1 is returned; for the error. const double * GetPointError(unsigned int ipoint, double& errvalue) const. Retrieve the errors on the point (coordinate and value) for the given fit point; It must be called only when the coordinate errors are stored otherwise it will produce an; assert. const double * GetPointError(unsigned int ipoint, double& errlow, double& errhigh) const. Get errors on the point (coordinate errors and asymmetric value errors) for the; given fit point.; It must be called only when the coordinate errors and asymmetric errors are stored; otherwise it will produce an assert. void Resize(unsigned int npoints). resize the vector to the new given npoints; if vector does not exists is created using existing point size. unsigned int NPoints() const. return number of fit points. { return fNPoints; }. unsigned int Size() const. return number of fit points. { return fNPoints; }. unsigned int NDim() const. return coordinate data dimension. { return fDim; }. BinData & LogTransform(). apply a Log transformation of the data values; can be used for example when fitting an exponential or gaussian; Transform the data in place need to copy if want to preserve original data; The ",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__BinData.html:11496,Testability,assert,assert,11496,"ouble * GetPoint(unsigned int ipoint, double& value) const. retrieve at the same time a pointer to the coordinate data and the fit value; More efficient than calling Coords(i) and Value(i). const double * GetPoint(unsigned int ipoint, double& value, double& invError) const. retrieve in a single call a pointer to the coordinate data, value and inverse error for; the given fit point.; To be used only when type is kValueError or kNoError. In the last case the value 1 is returned; for the error. const double * GetPointError(unsigned int ipoint, double& errvalue) const. Retrieve the errors on the point (coordinate and value) for the given fit point; It must be called only when the coordinate errors are stored otherwise it will produce an; assert. const double * GetPointError(unsigned int ipoint, double& errlow, double& errhigh) const. Get errors on the point (coordinate errors and asymmetric value errors) for the; given fit point.; It must be called only when the coordinate errors and asymmetric errors are stored; otherwise it will produce an assert. void Resize(unsigned int npoints). resize the vector to the new given npoints; if vector does not exists is created using existing point size. unsigned int NPoints() const. return number of fit points. { return fNPoints; }. unsigned int Size() const. return number of fit points. { return fNPoints; }. unsigned int NDim() const. return coordinate data dimension. { return fDim; }. BinData & LogTransform(). apply a Log transformation of the data values; can be used for example when fitting an exponential or gaussian; Transform the data in place need to copy if want to preserve original data; The data sets must not contain negative values. IN case it does,; an empty data set is returned. const double * BinUpEdge(unsigned int icoord) const. return an array containing the upper edge of the bin for coordinate i; In case of empty bin they could be merged in a single larger bin; Return a NULL pointer if the bin width is not stored. bo",MatchSource.WIKI,root/html534/ROOT__Fit__BinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__BinData.html
https://root.cern/root/html534/ROOT__Fit__Chi2FCN_-p0Math__IBaseFunctionMultiDim_.html:3685,Integrability,interface,interface,3685,"onst ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>&); virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::ResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::UpdateNCalls() const. protected:. virtual voidSetNFitPoints(unsigned int n) const. private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const. Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::BinData&fData; const ROOT::Fit::Chi2FCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; unsigned intfNEffPointsnumber of effective points used in the fit . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function. unsigned int NFitPoints() const; effective points used in the fit (exclude the rejected one). { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th chi-square residual. void Gradient(const double* x, double* g) const; need to be virtual to be instantiated. void SetNFitPoints(unsigned int n) const; set number of fit points (need to be called in const methods, make it const). { fNEffPoints = n; }. double DoEval(const double* x) const. Evaluation of the function (required by interface). double DoDerivative(const double* x, unsigned int icoord) const; for derivatives.  Author: L. Moneta Tue Sep 5 09:13:32 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Fit__Chi2FCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Chi2FCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html534/ROOT__Fit__Chi2FCN_-p0Math__IGradientFunctionMultiDim_.html:3981,Integrability,interface,interface,3981,"icFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>&); virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::ResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::UpdateNCalls() const. protected:. virtual voidSetNFitPoints(unsigned int n) const. private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const. Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::BinData&fData; const ROOT::Fit::Chi2FCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; unsigned intfNEffPointsnumber of effective points used in the fit . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function. unsigned int NFitPoints() const; effective points used in the fit (exclude the rejected one). { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th chi-square residual. void Gradient(const double* x, double* g) const; need to be virtual to be instantiated. void SetNFitPoints(unsigned int n) const; set number of fit points (need to be called in const methods, make it const). { fNEffPoints = n; }. double DoEval(const double* x) const. Evaluation of the function (required by interface). double DoDerivative(const double* x, unsigned int icoord) const; for derivatives.  Author: L. Moneta Tue Sep 5 09:13:32 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Fit__Chi2FCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Chi2FCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html534/ROOT__Fit__DataOptions.html:662,Availability,error,errors,662,". ROOT::Fit::DataOptions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::DataOptions. class ROOT::Fit::DataOptions. DataOptions : simple structure holding the options on how the data are filled. @ingroup FitData. Function Members (Methods); public:. ~DataOptions(); ROOT::Fit::DataOptionsDataOptions(); ROOT::Fit::DataOptionsDataOptions(const ROOT::Fit::DataOptions&); ROOT::Fit::DataOptions&operator=(const ROOT::Fit::DataOptions&). Data Members; public:. boolfAsymErrorsuse asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true); boolfBinVolumenormalize data by the bin volume (it is used in the Poisson likelihood fits); boolfCoordErrorsuse errors on the x coordinates when available (default is true); boolfErrors1use all errors equal to 1, i.e. fit without errors (default is false) ; boolfExpErrorsuse expected errors from the function and not from the data ; boolfIntegraluse integral of bin content instead of bin center (default is false); boolfUseEmptyuse empty bins (default is false) with a fixed error of 1; boolfUseRangeuse the function range when creating the fit data (default is false). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DataOptions(). Default constructor: use the default options. {}.  Author: L. Moneta Wed Aug 30 11:04:59 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Fit__DataOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__DataOptions.html
https://root.cern/root/html534/ROOT__Fit__DataOptions.html:687,Availability,avail,available,687,". ROOT::Fit::DataOptions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::DataOptions. class ROOT::Fit::DataOptions. DataOptions : simple structure holding the options on how the data are filled. @ingroup FitData. Function Members (Methods); public:. ~DataOptions(); ROOT::Fit::DataOptionsDataOptions(); ROOT::Fit::DataOptionsDataOptions(const ROOT::Fit::DataOptions&); ROOT::Fit::DataOptions&operator=(const ROOT::Fit::DataOptions&). Data Members; public:. boolfAsymErrorsuse asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true); boolfBinVolumenormalize data by the bin volume (it is used in the Poisson likelihood fits); boolfCoordErrorsuse errors on the x coordinates when available (default is true); boolfErrors1use all errors equal to 1, i.e. fit without errors (default is false) ; boolfExpErrorsuse expected errors from the function and not from the data ; boolfIntegraluse integral of bin content instead of bin center (default is false); boolfUseEmptyuse empty bins (default is false) with a fixed error of 1; boolfUseRangeuse the function range when creating the fit data (default is false). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DataOptions(). Default constructor: use the default options. {}.  Author: L. Moneta Wed Aug 30 11:04:59 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Fit__DataOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__DataOptions.html
https://root.cern/root/html534/ROOT__Fit__DataOptions.html:881,Availability,error,errors,881,". ROOT::Fit::DataOptions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::DataOptions. class ROOT::Fit::DataOptions. DataOptions : simple structure holding the options on how the data are filled. @ingroup FitData. Function Members (Methods); public:. ~DataOptions(); ROOT::Fit::DataOptionsDataOptions(); ROOT::Fit::DataOptionsDataOptions(const ROOT::Fit::DataOptions&); ROOT::Fit::DataOptions&operator=(const ROOT::Fit::DataOptions&). Data Members; public:. boolfAsymErrorsuse asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true); boolfBinVolumenormalize data by the bin volume (it is used in the Poisson likelihood fits); boolfCoordErrorsuse errors on the x coordinates when available (default is true); boolfErrors1use all errors equal to 1, i.e. fit without errors (default is false) ; boolfExpErrorsuse expected errors from the function and not from the data ; boolfIntegraluse integral of bin content instead of bin center (default is false); boolfUseEmptyuse empty bins (default is false) with a fixed error of 1; boolfUseRangeuse the function range when creating the fit data (default is false). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DataOptions(). Default constructor: use the default options. {}.  Author: L. Moneta Wed Aug 30 11:04:59 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Fit__DataOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__DataOptions.html
https://root.cern/root/html534/ROOT__Fit__DataOptions.html:914,Availability,avail,available,914,". ROOT::Fit::DataOptions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::DataOptions. class ROOT::Fit::DataOptions. DataOptions : simple structure holding the options on how the data are filled. @ingroup FitData. Function Members (Methods); public:. ~DataOptions(); ROOT::Fit::DataOptionsDataOptions(); ROOT::Fit::DataOptionsDataOptions(const ROOT::Fit::DataOptions&); ROOT::Fit::DataOptions&operator=(const ROOT::Fit::DataOptions&). Data Members; public:. boolfAsymErrorsuse asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true); boolfBinVolumenormalize data by the bin volume (it is used in the Poisson likelihood fits); boolfCoordErrorsuse errors on the x coordinates when available (default is true); boolfErrors1use all errors equal to 1, i.e. fit without errors (default is false) ; boolfExpErrorsuse expected errors from the function and not from the data ; boolfIntegraluse integral of bin content instead of bin center (default is false); boolfUseEmptyuse empty bins (default is false) with a fixed error of 1; boolfUseRangeuse the function range when creating the fit data (default is false). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DataOptions(). Default constructor: use the default options. {}.  Author: L. Moneta Wed Aug 30 11:04:59 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Fit__DataOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__DataOptions.html
https://root.cern/root/html534/ROOT__Fit__DataOptions.html:963,Availability,error,errors,963,". ROOT::Fit::DataOptions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::DataOptions. class ROOT::Fit::DataOptions. DataOptions : simple structure holding the options on how the data are filled. @ingroup FitData. Function Members (Methods); public:. ~DataOptions(); ROOT::Fit::DataOptionsDataOptions(); ROOT::Fit::DataOptionsDataOptions(const ROOT::Fit::DataOptions&); ROOT::Fit::DataOptions&operator=(const ROOT::Fit::DataOptions&). Data Members; public:. boolfAsymErrorsuse asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true); boolfBinVolumenormalize data by the bin volume (it is used in the Poisson likelihood fits); boolfCoordErrorsuse errors on the x coordinates when available (default is true); boolfErrors1use all errors equal to 1, i.e. fit without errors (default is false) ; boolfExpErrorsuse expected errors from the function and not from the data ; boolfIntegraluse integral of bin content instead of bin center (default is false); boolfUseEmptyuse empty bins (default is false) with a fixed error of 1; boolfUseRangeuse the function range when creating the fit data (default is false). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DataOptions(). Default constructor: use the default options. {}.  Author: L. Moneta Wed Aug 30 11:04:59 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Fit__DataOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__DataOptions.html
https://root.cern/root/html534/ROOT__Fit__DataOptions.html:999,Availability,error,errors,999,". ROOT::Fit::DataOptions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::DataOptions. class ROOT::Fit::DataOptions. DataOptions : simple structure holding the options on how the data are filled. @ingroup FitData. Function Members (Methods); public:. ~DataOptions(); ROOT::Fit::DataOptionsDataOptions(); ROOT::Fit::DataOptionsDataOptions(const ROOT::Fit::DataOptions&); ROOT::Fit::DataOptions&operator=(const ROOT::Fit::DataOptions&). Data Members; public:. boolfAsymErrorsuse asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true); boolfBinVolumenormalize data by the bin volume (it is used in the Poisson likelihood fits); boolfCoordErrorsuse errors on the x coordinates when available (default is true); boolfErrors1use all errors equal to 1, i.e. fit without errors (default is false) ; boolfExpErrorsuse expected errors from the function and not from the data ; boolfIntegraluse integral of bin content instead of bin center (default is false); boolfUseEmptyuse empty bins (default is false) with a fixed error of 1; boolfUseRangeuse the function range when creating the fit data (default is false). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DataOptions(). Default constructor: use the default options. {}.  Author: L. Moneta Wed Aug 30 11:04:59 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Fit__DataOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__DataOptions.html
https://root.cern/root/html534/ROOT__Fit__DataOptions.html:1054,Availability,error,errors,1054,". ROOT::Fit::DataOptions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::DataOptions. class ROOT::Fit::DataOptions. DataOptions : simple structure holding the options on how the data are filled. @ingroup FitData. Function Members (Methods); public:. ~DataOptions(); ROOT::Fit::DataOptionsDataOptions(); ROOT::Fit::DataOptionsDataOptions(const ROOT::Fit::DataOptions&); ROOT::Fit::DataOptions&operator=(const ROOT::Fit::DataOptions&). Data Members; public:. boolfAsymErrorsuse asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true); boolfBinVolumenormalize data by the bin volume (it is used in the Poisson likelihood fits); boolfCoordErrorsuse errors on the x coordinates when available (default is true); boolfErrors1use all errors equal to 1, i.e. fit without errors (default is false) ; boolfExpErrorsuse expected errors from the function and not from the data ; boolfIntegraluse integral of bin content instead of bin center (default is false); boolfUseEmptyuse empty bins (default is false) with a fixed error of 1; boolfUseRangeuse the function range when creating the fit data (default is false). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DataOptions(). Default constructor: use the default options. {}.  Author: L. Moneta Wed Aug 30 11:04:59 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Fit__DataOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__DataOptions.html
https://root.cern/root/html534/ROOT__Fit__DataOptions.html:1246,Availability,error,error,1246,". ROOT::Fit::DataOptions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::DataOptions. class ROOT::Fit::DataOptions. DataOptions : simple structure holding the options on how the data are filled. @ingroup FitData. Function Members (Methods); public:. ~DataOptions(); ROOT::Fit::DataOptionsDataOptions(); ROOT::Fit::DataOptionsDataOptions(const ROOT::Fit::DataOptions&); ROOT::Fit::DataOptions&operator=(const ROOT::Fit::DataOptions&). Data Members; public:. boolfAsymErrorsuse asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true); boolfBinVolumenormalize data by the bin volume (it is used in the Poisson likelihood fits); boolfCoordErrorsuse errors on the x coordinates when available (default is true); boolfErrors1use all errors equal to 1, i.e. fit without errors (default is false) ; boolfExpErrorsuse expected errors from the function and not from the data ; boolfIntegraluse integral of bin content instead of bin center (default is false); boolfUseEmptyuse empty bins (default is false) with a fixed error of 1; boolfUseRangeuse the function range when creating the fit data (default is false). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DataOptions(). Default constructor: use the default options. {}.  Author: L. Moneta Wed Aug 30 11:04:59 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Fit__DataOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__DataOptions.html
https://root.cern/root/html534/ROOT__Fit__DataOptions.html:305,Usability,simpl,simple,305,". ROOT::Fit::DataOptions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::DataOptions. class ROOT::Fit::DataOptions. DataOptions : simple structure holding the options on how the data are filled. @ingroup FitData. Function Members (Methods); public:. ~DataOptions(); ROOT::Fit::DataOptionsDataOptions(); ROOT::Fit::DataOptionsDataOptions(const ROOT::Fit::DataOptions&); ROOT::Fit::DataOptions&operator=(const ROOT::Fit::DataOptions&). Data Members; public:. boolfAsymErrorsuse asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true); boolfBinVolumenormalize data by the bin volume (it is used in the Poisson likelihood fits); boolfCoordErrorsuse errors on the x coordinates when available (default is true); boolfErrors1use all errors equal to 1, i.e. fit without errors (default is false) ; boolfExpErrorsuse expected errors from the function and not from the data ; boolfIntegraluse integral of bin content instead of bin center (default is false); boolfUseEmptyuse empty bins (default is false) with a fixed error of 1; boolfUseRangeuse the function range when creating the fit data (default is false). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DataOptions(). Default constructor: use the default options. {}.  Author: L. Moneta Wed Aug 30 11:04:59 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Fit__DataOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__DataOptions.html
https://root.cern/root/html534/ROOT__Fit__DataRange.html:6080,Usability,clear,clear,6080,"min, double xmax, double ymin, double ymax). add a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate. { AddRange(0,xmin,xmax); AddRange(1,ymin,ymax); }. void AddRange(double xmin, double xmax, double ymin, double ymax, double zmin, double zmax). add a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate and; [zmin,zmax] for the third coordinate. void SetRange(unsigned int icoord, double xmin, double xmax). set a range [xmin,xmax] for the new coordinate icoord; If more range exists for other coordinates, delete the existing one and use it the new one; Use Add range if want to keep the union of the existing ranges. void SetRange(double xmin, double xmax). set a range [xmin,xmax] for the first coordinate icoord. { SetRange(0,xmin,xmax); }. void SetRange(double xmin, double xmax, double ymin, double ymax). set a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate. { SetRange(0,xmin,xmax); SetRange(1,ymin,ymax); }. void SetRange(double xmin, double xmax, double ymin, double ymax, double zmin, double zmax). set a range [xmin,xmax] for the first and [ymin,ymax] for the second coordinate and; [zmin,zmax] for the third coordinate. void Clear(unsigned int icoord = 0). clear all ranges in one coordinate (is now -inf, +inf). bool IsInside(double x, unsigned int icoord = 0) const. check if a point is inside the range for the given coordinate. void CleanRangeSet(unsigned int icoord, double xmin, double xmax). internal function to remove all the existing ranges between xmin and xmax; called when a new range is inserted. void GetInfRange(double& x1, double& x2); get the full range (-inf, +inf).  Author: L. Moneta Wed Aug 30 11:05:02 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Fit__DataRange.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__DataRange.html
https://root.cern/root/html534/ROOT__Fit__FitConfig.html:2104,Availability,error,error,2104,"gs&ParSettings(unsigned int i); static voidSetDefaultMinimizer(const char* type, const char* algo = 0); voidSetFromFitResult(const ROOT::Fit::FitResult& rhs); voidSetMinimizer(const char* type, const char* algo = 0); voidSetMinosErrors(bool on = true); voidSetMinosErrors(const vector<unsigned int>& paramInd); voidSetNormErrors(bool on = true); voidSetParabErrors(bool on = true); voidSetParamsSettings(const vector<ROOT::Fit::ParameterSettings>& pars); voidSetParamsSettings(unsigned int npar, const double* params, const double* vstep = 0); voidSetUpdateAfterFit(bool on = true); voidSetWeightCorrection(bool on = true); boolUpdateAfterFit() const; boolUseWeightCorrection() const. Data Members; private:. ROOT::Math::MinimizerOptionsfMinimizerOptsminimizer control parameters including name and algo type; boolfMinosErrorsdo full error analysis using Minos; vector<unsigned int>fMinosParamsvector with the parameter indeces for running Minos; boolfNormErrorsflag for error normalization; boolfParabErrorsget correct parabolic errors estimate (call Hesse after minimizing) ; vector<ROOT::Fit::ParameterSettings>fSettingsvector with the parameter settings; boolfUpdateAfterFitupdate the configuration after a fit using the result; boolfWeightCorrapply correction to errors for weights fits . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitConfig(unsigned int npar = 0). Default constructor. FitConfig(const ROOT::Fit::FitConfig& rhs). Copy constructor. ~FitConfig(). Destructor. FitConfig & operator=(const ROOT::Fit::FitConfig& rhs). Assignment operator. const ParameterSettings & ParSettings(unsigned int i) const. get the parameter settings for the i-th parameter (const method). { return fSettings.at(i); }. ParameterSettings & ParSettings(unsigned int i). get the parameter settings for the i-th parameter (non-const method). { return fSettings.at(i); }. const std::vector<ROOT::Fit::ParameterSettings> & ParamsSettings() const. get the vector of ",MatchSource.WIKI,root/html534/ROOT__Fit__FitConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitConfig.html
https://root.cern/root/html534/ROOT__Fit__FitConfig.html:2241,Availability,error,error,2241,"gs&ParSettings(unsigned int i); static voidSetDefaultMinimizer(const char* type, const char* algo = 0); voidSetFromFitResult(const ROOT::Fit::FitResult& rhs); voidSetMinimizer(const char* type, const char* algo = 0); voidSetMinosErrors(bool on = true); voidSetMinosErrors(const vector<unsigned int>& paramInd); voidSetNormErrors(bool on = true); voidSetParabErrors(bool on = true); voidSetParamsSettings(const vector<ROOT::Fit::ParameterSettings>& pars); voidSetParamsSettings(unsigned int npar, const double* params, const double* vstep = 0); voidSetUpdateAfterFit(bool on = true); voidSetWeightCorrection(bool on = true); boolUpdateAfterFit() const; boolUseWeightCorrection() const. Data Members; private:. ROOT::Math::MinimizerOptionsfMinimizerOptsminimizer control parameters including name and algo type; boolfMinosErrorsdo full error analysis using Minos; vector<unsigned int>fMinosParamsvector with the parameter indeces for running Minos; boolfNormErrorsflag for error normalization; boolfParabErrorsget correct parabolic errors estimate (call Hesse after minimizing) ; vector<ROOT::Fit::ParameterSettings>fSettingsvector with the parameter settings; boolfUpdateAfterFitupdate the configuration after a fit using the result; boolfWeightCorrapply correction to errors for weights fits . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitConfig(unsigned int npar = 0). Default constructor. FitConfig(const ROOT::Fit::FitConfig& rhs). Copy constructor. ~FitConfig(). Destructor. FitConfig & operator=(const ROOT::Fit::FitConfig& rhs). Assignment operator. const ParameterSettings & ParSettings(unsigned int i) const. get the parameter settings for the i-th parameter (const method). { return fSettings.at(i); }. ParameterSettings & ParSettings(unsigned int i). get the parameter settings for the i-th parameter (non-const method). { return fSettings.at(i); }. const std::vector<ROOT::Fit::ParameterSettings> & ParamsSettings() const. get the vector of ",MatchSource.WIKI,root/html534/ROOT__Fit__FitConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitConfig.html
https://root.cern/root/html534/ROOT__Fit__FitConfig.html:2300,Availability,error,errors,2300,"gs&ParSettings(unsigned int i); static voidSetDefaultMinimizer(const char* type, const char* algo = 0); voidSetFromFitResult(const ROOT::Fit::FitResult& rhs); voidSetMinimizer(const char* type, const char* algo = 0); voidSetMinosErrors(bool on = true); voidSetMinosErrors(const vector<unsigned int>& paramInd); voidSetNormErrors(bool on = true); voidSetParabErrors(bool on = true); voidSetParamsSettings(const vector<ROOT::Fit::ParameterSettings>& pars); voidSetParamsSettings(unsigned int npar, const double* params, const double* vstep = 0); voidSetUpdateAfterFit(bool on = true); voidSetWeightCorrection(bool on = true); boolUpdateAfterFit() const; boolUseWeightCorrection() const. Data Members; private:. ROOT::Math::MinimizerOptionsfMinimizerOptsminimizer control parameters including name and algo type; boolfMinosErrorsdo full error analysis using Minos; vector<unsigned int>fMinosParamsvector with the parameter indeces for running Minos; boolfNormErrorsflag for error normalization; boolfParabErrorsget correct parabolic errors estimate (call Hesse after minimizing) ; vector<ROOT::Fit::ParameterSettings>fSettingsvector with the parameter settings; boolfUpdateAfterFitupdate the configuration after a fit using the result; boolfWeightCorrapply correction to errors for weights fits . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitConfig(unsigned int npar = 0). Default constructor. FitConfig(const ROOT::Fit::FitConfig& rhs). Copy constructor. ~FitConfig(). Destructor. FitConfig & operator=(const ROOT::Fit::FitConfig& rhs). Assignment operator. const ParameterSettings & ParSettings(unsigned int i) const. get the parameter settings for the i-th parameter (const method). { return fSettings.at(i); }. ParameterSettings & ParSettings(unsigned int i). get the parameter settings for the i-th parameter (non-const method). { return fSettings.at(i); }. const std::vector<ROOT::Fit::ParameterSettings> & ParamsSettings() const. get the vector of ",MatchSource.WIKI,root/html534/ROOT__Fit__FitConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitConfig.html
https://root.cern/root/html534/ROOT__Fit__FitConfig.html:2538,Availability,error,errors,2538,"gs&ParSettings(unsigned int i); static voidSetDefaultMinimizer(const char* type, const char* algo = 0); voidSetFromFitResult(const ROOT::Fit::FitResult& rhs); voidSetMinimizer(const char* type, const char* algo = 0); voidSetMinosErrors(bool on = true); voidSetMinosErrors(const vector<unsigned int>& paramInd); voidSetNormErrors(bool on = true); voidSetParabErrors(bool on = true); voidSetParamsSettings(const vector<ROOT::Fit::ParameterSettings>& pars); voidSetParamsSettings(unsigned int npar, const double* params, const double* vstep = 0); voidSetUpdateAfterFit(bool on = true); voidSetWeightCorrection(bool on = true); boolUpdateAfterFit() const; boolUseWeightCorrection() const. Data Members; private:. ROOT::Math::MinimizerOptionsfMinimizerOptsminimizer control parameters including name and algo type; boolfMinosErrorsdo full error analysis using Minos; vector<unsigned int>fMinosParamsvector with the parameter indeces for running Minos; boolfNormErrorsflag for error normalization; boolfParabErrorsget correct parabolic errors estimate (call Hesse after minimizing) ; vector<ROOT::Fit::ParameterSettings>fSettingsvector with the parameter settings; boolfUpdateAfterFitupdate the configuration after a fit using the result; boolfWeightCorrapply correction to errors for weights fits . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitConfig(unsigned int npar = 0). Default constructor. FitConfig(const ROOT::Fit::FitConfig& rhs). Copy constructor. ~FitConfig(). Destructor. FitConfig & operator=(const ROOT::Fit::FitConfig& rhs). Assignment operator. const ParameterSettings & ParSettings(unsigned int i) const. get the parameter settings for the i-th parameter (const method). { return fSettings.at(i); }. ParameterSettings & ParSettings(unsigned int i). get the parameter settings for the i-th parameter (non-const method). { return fSettings.at(i); }. const std::vector<ROOT::Fit::ParameterSettings> & ParamsSettings() const. get the vector of ",MatchSource.WIKI,root/html534/ROOT__Fit__FitConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitConfig.html
https://root.cern/root/html534/ROOT__Fit__FitConfig.html:4793,Availability,error,errors,4793,"uble* params, const double* vstep = 0). set the parameter settings from number of parameters and a vector of values and optionally step values. If there are not existing or number of parameters does not match existing one, create a new parameter setting list. void SetParamsSettings(const vector<ROOT::Fit::ParameterSettings>& pars). Set the parameter settings from a vector of parameter settings. void SetFromFitResult(const ROOT::Fit::FitResult& rhs). Set the parameter settings from a fit Result. ROOT::Math::Minimizer * CreateMinimizer(). create a new minimizer according to chosen configuration. void SetMinimizer(const char* type, const char* algo = 0). set minimizer type. const std::string & MinimizerType() const. return type of minimizer package. { return fMinimizerOpts.MinimizerType(); }. const std::string & MinimizerAlgoType() const. return type of minimizer algorithms. { return fMinimizerOpts.MinimizerAlgorithm(); }. bool NormalizeErrors() const. flag to check if resulting errors are be normalized according to chi2/ndf. { return fNormErrors; }. bool ParabErrors() const; do analysis for parabolic errors. { return fParabErrors; }. bool MinosErrors() const; do minos errros analysis on the parameters. { return fMinosErrors; }. bool UpdateAfterFit() const; Update configuration after a fit using the FitResult. { return fUpdateAfterFit; }. bool UseWeightCorrection() const; Apply Weight correction for error matrix computation. { return fWeightCorr; }. const std::vector<unsigned int> & MinosParams() const; return vector of parameter indeces for which the Minos Error will be computed. { return fMinosParams; }. void SetNormErrors(bool on = true). set the option to normalize the error on the result according to chi2/ndf. { fNormErrors= on; }. void SetParabErrors(bool on = true); set parabolic erros. { fParabErrors = on; }. void SetMinosErrors(bool on = true); set Minos erros computation to be performed after fitting. { fMinosErrors = on; }. void SetWeightCorrection(bool on = ",MatchSource.WIKI,root/html534/ROOT__Fit__FitConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitConfig.html
https://root.cern/root/html534/ROOT__Fit__FitConfig.html:4918,Availability,error,errors,4918,"and a vector of values and optionally step values. If there are not existing or number of parameters does not match existing one, create a new parameter setting list. void SetParamsSettings(const vector<ROOT::Fit::ParameterSettings>& pars). Set the parameter settings from a vector of parameter settings. void SetFromFitResult(const ROOT::Fit::FitResult& rhs). Set the parameter settings from a fit Result. ROOT::Math::Minimizer * CreateMinimizer(). create a new minimizer according to chosen configuration. void SetMinimizer(const char* type, const char* algo = 0). set minimizer type. const std::string & MinimizerType() const. return type of minimizer package. { return fMinimizerOpts.MinimizerType(); }. const std::string & MinimizerAlgoType() const. return type of minimizer algorithms. { return fMinimizerOpts.MinimizerAlgorithm(); }. bool NormalizeErrors() const. flag to check if resulting errors are be normalized according to chi2/ndf. { return fNormErrors; }. bool ParabErrors() const; do analysis for parabolic errors. { return fParabErrors; }. bool MinosErrors() const; do minos errros analysis on the parameters. { return fMinosErrors; }. bool UpdateAfterFit() const; Update configuration after a fit using the FitResult. { return fUpdateAfterFit; }. bool UseWeightCorrection() const; Apply Weight correction for error matrix computation. { return fWeightCorr; }. const std::vector<unsigned int> & MinosParams() const; return vector of parameter indeces for which the Minos Error will be computed. { return fMinosParams; }. void SetNormErrors(bool on = true). set the option to normalize the error on the result according to chi2/ndf. { fNormErrors= on; }. void SetParabErrors(bool on = true); set parabolic erros. { fParabErrors = on; }. void SetMinosErrors(bool on = true); set Minos erros computation to be performed after fitting. { fMinosErrors = on; }. void SetWeightCorrection(bool on = true); apply the weight correction for error matric computation. { fWeightCorr = on; }. void",MatchSource.WIKI,root/html534/ROOT__Fit__FitConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitConfig.html
https://root.cern/root/html534/ROOT__Fit__FitConfig.html:5222,Availability,error,error,5222,"d SetFromFitResult(const ROOT::Fit::FitResult& rhs). Set the parameter settings from a fit Result. ROOT::Math::Minimizer * CreateMinimizer(). create a new minimizer according to chosen configuration. void SetMinimizer(const char* type, const char* algo = 0). set minimizer type. const std::string & MinimizerType() const. return type of minimizer package. { return fMinimizerOpts.MinimizerType(); }. const std::string & MinimizerAlgoType() const. return type of minimizer algorithms. { return fMinimizerOpts.MinimizerAlgorithm(); }. bool NormalizeErrors() const. flag to check if resulting errors are be normalized according to chi2/ndf. { return fNormErrors; }. bool ParabErrors() const; do analysis for parabolic errors. { return fParabErrors; }. bool MinosErrors() const; do minos errros analysis on the parameters. { return fMinosErrors; }. bool UpdateAfterFit() const; Update configuration after a fit using the FitResult. { return fUpdateAfterFit; }. bool UseWeightCorrection() const; Apply Weight correction for error matrix computation. { return fWeightCorr; }. const std::vector<unsigned int> & MinosParams() const; return vector of parameter indeces for which the Minos Error will be computed. { return fMinosParams; }. void SetNormErrors(bool on = true). set the option to normalize the error on the result according to chi2/ndf. { fNormErrors= on; }. void SetParabErrors(bool on = true); set parabolic erros. { fParabErrors = on; }. void SetMinosErrors(bool on = true); set Minos erros computation to be performed after fitting. { fMinosErrors = on; }. void SetWeightCorrection(bool on = true); apply the weight correction for error matric computation. { fWeightCorr = on; }. void SetMinosErrors(const vector<unsigned int>& paramInd); set parameter indeces for running Minos; this can be used for running Minos on a subset of parameters - otherwise is run on all of them; if MinosErrors() is set. void SetUpdateAfterFit(bool on = true); Update configuration after a fit using the FitResul",MatchSource.WIKI,root/html534/ROOT__Fit__FitConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitConfig.html
https://root.cern/root/html534/ROOT__Fit__FitConfig.html:5501,Availability,error,error,5501,"imizerType() const. return type of minimizer package. { return fMinimizerOpts.MinimizerType(); }. const std::string & MinimizerAlgoType() const. return type of minimizer algorithms. { return fMinimizerOpts.MinimizerAlgorithm(); }. bool NormalizeErrors() const. flag to check if resulting errors are be normalized according to chi2/ndf. { return fNormErrors; }. bool ParabErrors() const; do analysis for parabolic errors. { return fParabErrors; }. bool MinosErrors() const; do minos errros analysis on the parameters. { return fMinosErrors; }. bool UpdateAfterFit() const; Update configuration after a fit using the FitResult. { return fUpdateAfterFit; }. bool UseWeightCorrection() const; Apply Weight correction for error matrix computation. { return fWeightCorr; }. const std::vector<unsigned int> & MinosParams() const; return vector of parameter indeces for which the Minos Error will be computed. { return fMinosParams; }. void SetNormErrors(bool on = true). set the option to normalize the error on the result according to chi2/ndf. { fNormErrors= on; }. void SetParabErrors(bool on = true); set parabolic erros. { fParabErrors = on; }. void SetMinosErrors(bool on = true); set Minos erros computation to be performed after fitting. { fMinosErrors = on; }. void SetWeightCorrection(bool on = true); apply the weight correction for error matric computation. { fWeightCorr = on; }. void SetMinosErrors(const vector<unsigned int>& paramInd); set parameter indeces for running Minos; this can be used for running Minos on a subset of parameters - otherwise is run on all of them; if MinosErrors() is set. void SetUpdateAfterFit(bool on = true); Update configuration after a fit using the FitResult. { fUpdateAfterFit = on; }. void SetDefaultMinimizer(const char* type, const char* algo = 0). static function to control default minimizer type and algorithm.  Author: L. Moneta Thu Sep 21 16:21:29 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last",MatchSource.WIKI,root/html534/ROOT__Fit__FitConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitConfig.html
https://root.cern/root/html534/ROOT__Fit__FitConfig.html:5842,Availability,error,error,5842,"turn fMinimizerOpts.MinimizerAlgorithm(); }. bool NormalizeErrors() const. flag to check if resulting errors are be normalized according to chi2/ndf. { return fNormErrors; }. bool ParabErrors() const; do analysis for parabolic errors. { return fParabErrors; }. bool MinosErrors() const; do minos errros analysis on the parameters. { return fMinosErrors; }. bool UpdateAfterFit() const; Update configuration after a fit using the FitResult. { return fUpdateAfterFit; }. bool UseWeightCorrection() const; Apply Weight correction for error matrix computation. { return fWeightCorr; }. const std::vector<unsigned int> & MinosParams() const; return vector of parameter indeces for which the Minos Error will be computed. { return fMinosParams; }. void SetNormErrors(bool on = true). set the option to normalize the error on the result according to chi2/ndf. { fNormErrors= on; }. void SetParabErrors(bool on = true); set parabolic erros. { fParabErrors = on; }. void SetMinosErrors(bool on = true); set Minos erros computation to be performed after fitting. { fMinosErrors = on; }. void SetWeightCorrection(bool on = true); apply the weight correction for error matric computation. { fWeightCorr = on; }. void SetMinosErrors(const vector<unsigned int>& paramInd); set parameter indeces for running Minos; this can be used for running Minos on a subset of parameters - otherwise is run on all of them; if MinosErrors() is set. void SetUpdateAfterFit(bool on = true); Update configuration after a fit using the FitResult. { fUpdateAfterFit = on; }. void SetDefaultMinimizer(const char* type, const char* algo = 0). static function to control default minimizer type and algorithm.  Author: L. Moneta Thu Sep 21 16:21:29 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Fit__FitConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitConfig.html
https://root.cern/root/html534/ROOT__Fit__FitConfig.html:306,Deployability,configurat,configuration,306,". ROOT::Fit::FitConfig. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::FitConfig. class ROOT::Fit::FitConfig. Class describing the configuration of the fit, options and parameter settings; using the ROOT::Fit::ParameterSettings class. @ingroup FitMain. Function Members (Methods); public:. ~FitConfig(); ROOT::Math::Minimizer*CreateMinimizer(); voidCreateParamsSettings(const ROOT::Math::IParamMultiFunction& func); ROOT::Fit::FitConfigFitConfig(unsigned int npar = 0); ROOT::Fit::FitConfigFitConfig(const ROOT::Fit::FitConfig& rhs); const string&MinimizerAlgoType() const; ROOT::Math::MinimizerOptions&MinimizerOptions(); const string&MinimizerType() const; boolMinosErrors() const; const vector<unsigned int>&MinosParams() const; boolNormalizeErrors() const; unsigned intNPar() const; ROOT::Fit::FitConfig&operator=(const ROOT::Fit::FitConfig& rhs); boolParabErrors() const; const vector<ROOT::Fit::ParameterSettings>&ParamsSettings() const; vector<ROOT::Fit::ParameterSettings>&ParamsSettings(); const ROOT::Fit::ParameterSettings&ParSettings(unsigned int i) const; ROOT::Fit::ParameterSettings&ParSettings(unsigned int i); static voidSetDefaultMinimizer(const char* type, const char* algo = 0); voidSetFromFitResult(const ROOT::Fit::FitResult& rhs); voidSetMinimizer(const char* type, const char* algo = 0); voidSetMinosErrors(bool on = true); voidSetMinosErrors(const vector<unsigned int>& paramInd); voidSetNormErrors(bool on = true); voidSetParabErrors(bool on = true); voidSetParamsSettings(const vector<ROOT::Fit::ParameterSettings>& pars); voidSetParamsSettings(unsigned int npar, const double* params, const double* vstep = 0); voidSetUpdateAfterFit(bool on = true); voidSetWeightCorrection(bool on = true); boolUpdateAfterFit() const; boolUseWeightCorrection() const. Data Members; private:. ROOT::Math::MinimizerO",MatchSource.WIKI,root/html534/ROOT__Fit__FitConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitConfig.html
https://root.cern/root/html534/ROOT__Fit__FitConfig.html:2459,Deployability,configurat,configuration,2459,"gs&ParSettings(unsigned int i); static voidSetDefaultMinimizer(const char* type, const char* algo = 0); voidSetFromFitResult(const ROOT::Fit::FitResult& rhs); voidSetMinimizer(const char* type, const char* algo = 0); voidSetMinosErrors(bool on = true); voidSetMinosErrors(const vector<unsigned int>& paramInd); voidSetNormErrors(bool on = true); voidSetParabErrors(bool on = true); voidSetParamsSettings(const vector<ROOT::Fit::ParameterSettings>& pars); voidSetParamsSettings(unsigned int npar, const double* params, const double* vstep = 0); voidSetUpdateAfterFit(bool on = true); voidSetWeightCorrection(bool on = true); boolUpdateAfterFit() const; boolUseWeightCorrection() const. Data Members; private:. ROOT::Math::MinimizerOptionsfMinimizerOptsminimizer control parameters including name and algo type; boolfMinosErrorsdo full error analysis using Minos; vector<unsigned int>fMinosParamsvector with the parameter indeces for running Minos; boolfNormErrorsflag for error normalization; boolfParabErrorsget correct parabolic errors estimate (call Hesse after minimizing) ; vector<ROOT::Fit::ParameterSettings>fSettingsvector with the parameter settings; boolfUpdateAfterFitupdate the configuration after a fit using the result; boolfWeightCorrapply correction to errors for weights fits . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitConfig(unsigned int npar = 0). Default constructor. FitConfig(const ROOT::Fit::FitConfig& rhs). Copy constructor. ~FitConfig(). Destructor. FitConfig & operator=(const ROOT::Fit::FitConfig& rhs). Assignment operator. const ParameterSettings & ParSettings(unsigned int i) const. get the parameter settings for the i-th parameter (const method). { return fSettings.at(i); }. ParameterSettings & ParSettings(unsigned int i). get the parameter settings for the i-th parameter (non-const method). { return fSettings.at(i); }. const std::vector<ROOT::Fit::ParameterSettings> & ParamsSettings() const. get the vector of ",MatchSource.WIKI,root/html534/ROOT__Fit__FitConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitConfig.html
https://root.cern/root/html534/ROOT__Fit__FitConfig.html:4388,Deployability,configurat,configuration,4388,"ParamsSettings(). get the vector of parameter settings (non-const method). { return fSettings; }. unsigned int NPar() const. number of parameters settings. { return fSettings.size(); }. void CreateParamsSettings(const ROOT::Math::IParamMultiFunction& func). set the parameter settings from a model function.; Create always new parameter setting list from a given model function. void SetParamsSettings(unsigned int npar, const double* params, const double* vstep = 0). set the parameter settings from number of parameters and a vector of values and optionally step values. If there are not existing or number of parameters does not match existing one, create a new parameter setting list. void SetParamsSettings(const vector<ROOT::Fit::ParameterSettings>& pars). Set the parameter settings from a vector of parameter settings. void SetFromFitResult(const ROOT::Fit::FitResult& rhs). Set the parameter settings from a fit Result. ROOT::Math::Minimizer * CreateMinimizer(). create a new minimizer according to chosen configuration. void SetMinimizer(const char* type, const char* algo = 0). set minimizer type. const std::string & MinimizerType() const. return type of minimizer package. { return fMinimizerOpts.MinimizerType(); }. const std::string & MinimizerAlgoType() const. return type of minimizer algorithms. { return fMinimizerOpts.MinimizerAlgorithm(); }. bool NormalizeErrors() const. flag to check if resulting errors are be normalized according to chi2/ndf. { return fNormErrors; }. bool ParabErrors() const; do analysis for parabolic errors. { return fParabErrors; }. bool MinosErrors() const; do minos errros analysis on the parameters. { return fMinosErrors; }. bool UpdateAfterFit() const; Update configuration after a fit using the FitResult. { return fUpdateAfterFit; }. bool UseWeightCorrection() const; Apply Weight correction for error matrix computation. { return fWeightCorr; }. const std::vector<unsigned int> & MinosParams() const; return vector of parameter indeces for which ",MatchSource.WIKI,root/html534/ROOT__Fit__FitConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitConfig.html
https://root.cern/root/html534/ROOT__Fit__FitConfig.html:5084,Deployability,configurat,configuration,5084,"st vector<ROOT::Fit::ParameterSettings>& pars). Set the parameter settings from a vector of parameter settings. void SetFromFitResult(const ROOT::Fit::FitResult& rhs). Set the parameter settings from a fit Result. ROOT::Math::Minimizer * CreateMinimizer(). create a new minimizer according to chosen configuration. void SetMinimizer(const char* type, const char* algo = 0). set minimizer type. const std::string & MinimizerType() const. return type of minimizer package. { return fMinimizerOpts.MinimizerType(); }. const std::string & MinimizerAlgoType() const. return type of minimizer algorithms. { return fMinimizerOpts.MinimizerAlgorithm(); }. bool NormalizeErrors() const. flag to check if resulting errors are be normalized according to chi2/ndf. { return fNormErrors; }. bool ParabErrors() const; do analysis for parabolic errors. { return fParabErrors; }. bool MinosErrors() const; do minos errros analysis on the parameters. { return fMinosErrors; }. bool UpdateAfterFit() const; Update configuration after a fit using the FitResult. { return fUpdateAfterFit; }. bool UseWeightCorrection() const; Apply Weight correction for error matrix computation. { return fWeightCorr; }. const std::vector<unsigned int> & MinosParams() const; return vector of parameter indeces for which the Minos Error will be computed. { return fMinosParams; }. void SetNormErrors(bool on = true). set the option to normalize the error on the result according to chi2/ndf. { fNormErrors= on; }. void SetParabErrors(bool on = true); set parabolic erros. { fParabErrors = on; }. void SetMinosErrors(bool on = true); set Minos erros computation to be performed after fitting. { fMinosErrors = on; }. void SetWeightCorrection(bool on = true); apply the weight correction for error matric computation. { fWeightCorr = on; }. void SetMinosErrors(const vector<unsigned int>& paramInd); set parameter indeces for running Minos; this can be used for running Minos on a subset of parameters - otherwise is run on all of them; if",MatchSource.WIKI,root/html534/ROOT__Fit__FitConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitConfig.html
https://root.cern/root/html534/ROOT__Fit__FitConfig.html:6159,Deployability,configurat,configuration,6159,"turn fMinimizerOpts.MinimizerAlgorithm(); }. bool NormalizeErrors() const. flag to check if resulting errors are be normalized according to chi2/ndf. { return fNormErrors; }. bool ParabErrors() const; do analysis for parabolic errors. { return fParabErrors; }. bool MinosErrors() const; do minos errros analysis on the parameters. { return fMinosErrors; }. bool UpdateAfterFit() const; Update configuration after a fit using the FitResult. { return fUpdateAfterFit; }. bool UseWeightCorrection() const; Apply Weight correction for error matrix computation. { return fWeightCorr; }. const std::vector<unsigned int> & MinosParams() const; return vector of parameter indeces for which the Minos Error will be computed. { return fMinosParams; }. void SetNormErrors(bool on = true). set the option to normalize the error on the result according to chi2/ndf. { fNormErrors= on; }. void SetParabErrors(bool on = true); set parabolic erros. { fParabErrors = on; }. void SetMinosErrors(bool on = true); set Minos erros computation to be performed after fitting. { fMinosErrors = on; }. void SetWeightCorrection(bool on = true); apply the weight correction for error matric computation. { fWeightCorr = on; }. void SetMinosErrors(const vector<unsigned int>& paramInd); set parameter indeces for running Minos; this can be used for running Minos on a subset of parameters - otherwise is run on all of them; if MinosErrors() is set. void SetUpdateAfterFit(bool on = true); Update configuration after a fit using the FitResult. { fUpdateAfterFit = on; }. void SetDefaultMinimizer(const char* type, const char* algo = 0). static function to control default minimizer type and algorithm.  Author: L. Moneta Thu Sep 21 16:21:29 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Fit__FitConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitConfig.html
https://root.cern/root/html534/ROOT__Fit__FitConfig.html:306,Modifiability,config,configuration,306,". ROOT::Fit::FitConfig. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::FitConfig. class ROOT::Fit::FitConfig. Class describing the configuration of the fit, options and parameter settings; using the ROOT::Fit::ParameterSettings class. @ingroup FitMain. Function Members (Methods); public:. ~FitConfig(); ROOT::Math::Minimizer*CreateMinimizer(); voidCreateParamsSettings(const ROOT::Math::IParamMultiFunction& func); ROOT::Fit::FitConfigFitConfig(unsigned int npar = 0); ROOT::Fit::FitConfigFitConfig(const ROOT::Fit::FitConfig& rhs); const string&MinimizerAlgoType() const; ROOT::Math::MinimizerOptions&MinimizerOptions(); const string&MinimizerType() const; boolMinosErrors() const; const vector<unsigned int>&MinosParams() const; boolNormalizeErrors() const; unsigned intNPar() const; ROOT::Fit::FitConfig&operator=(const ROOT::Fit::FitConfig& rhs); boolParabErrors() const; const vector<ROOT::Fit::ParameterSettings>&ParamsSettings() const; vector<ROOT::Fit::ParameterSettings>&ParamsSettings(); const ROOT::Fit::ParameterSettings&ParSettings(unsigned int i) const; ROOT::Fit::ParameterSettings&ParSettings(unsigned int i); static voidSetDefaultMinimizer(const char* type, const char* algo = 0); voidSetFromFitResult(const ROOT::Fit::FitResult& rhs); voidSetMinimizer(const char* type, const char* algo = 0); voidSetMinosErrors(bool on = true); voidSetMinosErrors(const vector<unsigned int>& paramInd); voidSetNormErrors(bool on = true); voidSetParabErrors(bool on = true); voidSetParamsSettings(const vector<ROOT::Fit::ParameterSettings>& pars); voidSetParamsSettings(unsigned int npar, const double* params, const double* vstep = 0); voidSetUpdateAfterFit(bool on = true); voidSetWeightCorrection(bool on = true); boolUpdateAfterFit() const; boolUseWeightCorrection() const. Data Members; private:. ROOT::Math::MinimizerO",MatchSource.WIKI,root/html534/ROOT__Fit__FitConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitConfig.html
https://root.cern/root/html534/ROOT__Fit__FitConfig.html:2459,Modifiability,config,configuration,2459,"gs&ParSettings(unsigned int i); static voidSetDefaultMinimizer(const char* type, const char* algo = 0); voidSetFromFitResult(const ROOT::Fit::FitResult& rhs); voidSetMinimizer(const char* type, const char* algo = 0); voidSetMinosErrors(bool on = true); voidSetMinosErrors(const vector<unsigned int>& paramInd); voidSetNormErrors(bool on = true); voidSetParabErrors(bool on = true); voidSetParamsSettings(const vector<ROOT::Fit::ParameterSettings>& pars); voidSetParamsSettings(unsigned int npar, const double* params, const double* vstep = 0); voidSetUpdateAfterFit(bool on = true); voidSetWeightCorrection(bool on = true); boolUpdateAfterFit() const; boolUseWeightCorrection() const. Data Members; private:. ROOT::Math::MinimizerOptionsfMinimizerOptsminimizer control parameters including name and algo type; boolfMinosErrorsdo full error analysis using Minos; vector<unsigned int>fMinosParamsvector with the parameter indeces for running Minos; boolfNormErrorsflag for error normalization; boolfParabErrorsget correct parabolic errors estimate (call Hesse after minimizing) ; vector<ROOT::Fit::ParameterSettings>fSettingsvector with the parameter settings; boolfUpdateAfterFitupdate the configuration after a fit using the result; boolfWeightCorrapply correction to errors for weights fits . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitConfig(unsigned int npar = 0). Default constructor. FitConfig(const ROOT::Fit::FitConfig& rhs). Copy constructor. ~FitConfig(). Destructor. FitConfig & operator=(const ROOT::Fit::FitConfig& rhs). Assignment operator. const ParameterSettings & ParSettings(unsigned int i) const. get the parameter settings for the i-th parameter (const method). { return fSettings.at(i); }. ParameterSettings & ParSettings(unsigned int i). get the parameter settings for the i-th parameter (non-const method). { return fSettings.at(i); }. const std::vector<ROOT::Fit::ParameterSettings> & ParamsSettings() const. get the vector of ",MatchSource.WIKI,root/html534/ROOT__Fit__FitConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitConfig.html
https://root.cern/root/html534/ROOT__Fit__FitConfig.html:4388,Modifiability,config,configuration,4388,"ParamsSettings(). get the vector of parameter settings (non-const method). { return fSettings; }. unsigned int NPar() const. number of parameters settings. { return fSettings.size(); }. void CreateParamsSettings(const ROOT::Math::IParamMultiFunction& func). set the parameter settings from a model function.; Create always new parameter setting list from a given model function. void SetParamsSettings(unsigned int npar, const double* params, const double* vstep = 0). set the parameter settings from number of parameters and a vector of values and optionally step values. If there are not existing or number of parameters does not match existing one, create a new parameter setting list. void SetParamsSettings(const vector<ROOT::Fit::ParameterSettings>& pars). Set the parameter settings from a vector of parameter settings. void SetFromFitResult(const ROOT::Fit::FitResult& rhs). Set the parameter settings from a fit Result. ROOT::Math::Minimizer * CreateMinimizer(). create a new minimizer according to chosen configuration. void SetMinimizer(const char* type, const char* algo = 0). set minimizer type. const std::string & MinimizerType() const. return type of minimizer package. { return fMinimizerOpts.MinimizerType(); }. const std::string & MinimizerAlgoType() const. return type of minimizer algorithms. { return fMinimizerOpts.MinimizerAlgorithm(); }. bool NormalizeErrors() const. flag to check if resulting errors are be normalized according to chi2/ndf. { return fNormErrors; }. bool ParabErrors() const; do analysis for parabolic errors. { return fParabErrors; }. bool MinosErrors() const; do minos errros analysis on the parameters. { return fMinosErrors; }. bool UpdateAfterFit() const; Update configuration after a fit using the FitResult. { return fUpdateAfterFit; }. bool UseWeightCorrection() const; Apply Weight correction for error matrix computation. { return fWeightCorr; }. const std::vector<unsigned int> & MinosParams() const; return vector of parameter indeces for which ",MatchSource.WIKI,root/html534/ROOT__Fit__FitConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitConfig.html
https://root.cern/root/html534/ROOT__Fit__FitConfig.html:5084,Modifiability,config,configuration,5084,"st vector<ROOT::Fit::ParameterSettings>& pars). Set the parameter settings from a vector of parameter settings. void SetFromFitResult(const ROOT::Fit::FitResult& rhs). Set the parameter settings from a fit Result. ROOT::Math::Minimizer * CreateMinimizer(). create a new minimizer according to chosen configuration. void SetMinimizer(const char* type, const char* algo = 0). set minimizer type. const std::string & MinimizerType() const. return type of minimizer package. { return fMinimizerOpts.MinimizerType(); }. const std::string & MinimizerAlgoType() const. return type of minimizer algorithms. { return fMinimizerOpts.MinimizerAlgorithm(); }. bool NormalizeErrors() const. flag to check if resulting errors are be normalized according to chi2/ndf. { return fNormErrors; }. bool ParabErrors() const; do analysis for parabolic errors. { return fParabErrors; }. bool MinosErrors() const; do minos errros analysis on the parameters. { return fMinosErrors; }. bool UpdateAfterFit() const; Update configuration after a fit using the FitResult. { return fUpdateAfterFit; }. bool UseWeightCorrection() const; Apply Weight correction for error matrix computation. { return fWeightCorr; }. const std::vector<unsigned int> & MinosParams() const; return vector of parameter indeces for which the Minos Error will be computed. { return fMinosParams; }. void SetNormErrors(bool on = true). set the option to normalize the error on the result according to chi2/ndf. { fNormErrors= on; }. void SetParabErrors(bool on = true); set parabolic erros. { fParabErrors = on; }. void SetMinosErrors(bool on = true); set Minos erros computation to be performed after fitting. { fMinosErrors = on; }. void SetWeightCorrection(bool on = true); apply the weight correction for error matric computation. { fWeightCorr = on; }. void SetMinosErrors(const vector<unsigned int>& paramInd); set parameter indeces for running Minos; this can be used for running Minos on a subset of parameters - otherwise is run on all of them; if",MatchSource.WIKI,root/html534/ROOT__Fit__FitConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitConfig.html
https://root.cern/root/html534/ROOT__Fit__FitConfig.html:6159,Modifiability,config,configuration,6159,"turn fMinimizerOpts.MinimizerAlgorithm(); }. bool NormalizeErrors() const. flag to check if resulting errors are be normalized according to chi2/ndf. { return fNormErrors; }. bool ParabErrors() const; do analysis for parabolic errors. { return fParabErrors; }. bool MinosErrors() const; do minos errros analysis on the parameters. { return fMinosErrors; }. bool UpdateAfterFit() const; Update configuration after a fit using the FitResult. { return fUpdateAfterFit; }. bool UseWeightCorrection() const; Apply Weight correction for error matrix computation. { return fWeightCorr; }. const std::vector<unsigned int> & MinosParams() const; return vector of parameter indeces for which the Minos Error will be computed. { return fMinosParams; }. void SetNormErrors(bool on = true). set the option to normalize the error on the result according to chi2/ndf. { fNormErrors= on; }. void SetParabErrors(bool on = true); set parabolic erros. { fParabErrors = on; }. void SetMinosErrors(bool on = true); set Minos erros computation to be performed after fitting. { fMinosErrors = on; }. void SetWeightCorrection(bool on = true); apply the weight correction for error matric computation. { fWeightCorr = on; }. void SetMinosErrors(const vector<unsigned int>& paramInd); set parameter indeces for running Minos; this can be used for running Minos on a subset of parameters - otherwise is run on all of them; if MinosErrors() is set. void SetUpdateAfterFit(bool on = true); Update configuration after a fit using the FitResult. { fUpdateAfterFit = on; }. void SetDefaultMinimizer(const char* type, const char* algo = 0). static function to control default minimizer type and algorithm.  Author: L. Moneta Thu Sep 21 16:21:29 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Fit__FitConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitConfig.html
https://root.cern/root/html534/ROOT__Fit__FitConfig.html:5719,Performance,perform,performed,5719,"turn fMinimizerOpts.MinimizerAlgorithm(); }. bool NormalizeErrors() const. flag to check if resulting errors are be normalized according to chi2/ndf. { return fNormErrors; }. bool ParabErrors() const; do analysis for parabolic errors. { return fParabErrors; }. bool MinosErrors() const; do minos errros analysis on the parameters. { return fMinosErrors; }. bool UpdateAfterFit() const; Update configuration after a fit using the FitResult. { return fUpdateAfterFit; }. bool UseWeightCorrection() const; Apply Weight correction for error matrix computation. { return fWeightCorr; }. const std::vector<unsigned int> & MinosParams() const; return vector of parameter indeces for which the Minos Error will be computed. { return fMinosParams; }. void SetNormErrors(bool on = true). set the option to normalize the error on the result according to chi2/ndf. { fNormErrors= on; }. void SetParabErrors(bool on = true); set parabolic erros. { fParabErrors = on; }. void SetMinosErrors(bool on = true); set Minos erros computation to be performed after fitting. { fMinosErrors = on; }. void SetWeightCorrection(bool on = true); apply the weight correction for error matric computation. { fWeightCorr = on; }. void SetMinosErrors(const vector<unsigned int>& paramInd); set parameter indeces for running Minos; this can be used for running Minos on a subset of parameters - otherwise is run on all of them; if MinosErrors() is set. void SetUpdateAfterFit(bool on = true); Update configuration after a fit using the FitResult. { fUpdateAfterFit = on; }. void SetDefaultMinimizer(const char* type, const char* algo = 0). static function to control default minimizer type and algorithm.  Author: L. Moneta Thu Sep 21 16:21:29 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Fit__FitConfig.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitConfig.html
https://root.cern/root/html534/ROOT__Fit__FitData.html:1545,Safety,avoid,avoid,1545,". ROOT::Fit::FitData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::FitData. class ROOT::Fit::FitData. Function Members (Methods); public:. virtual~FitData(); ROOT::Fit::FitDataFitData(); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataOptions& opt); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataRange& range); ROOT::Fit::FitDataFitData(const ROOT::Fit::FitData&); ROOT::Fit::FitDataFitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); static unsigned intMaxSize(); ROOT::Fit::FitData&operator=(const ROOT::Fit::FitData&); const ROOT::Fit::DataOptions&Opt() const; ROOT::Fit::DataOptions&Opt(); const ROOT::Fit::DataRange&Range() const. Data Members; private:. ROOT::Fit::DataOptionsfOptions; ROOT::Fit::DataRangefRange. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitData(); construct with default option and data range. {}. virtual ~FitData(); dummy virtual destructor. {}. FitData(const DataOptions & opt); construct passing options and default data range. {}. FitData(const DataRange & range); construct passing range and default options. {}. FitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); construct passing options and data range. {}. unsigned int MaxSize(); range cannot be modified afterwards; since fit method functions use all data. define a max size to avoid allocating too large arrays.  Author: L. Moneta Wed Aug 30 11:15:23 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Fit__FitData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitData.html
https://root.cern/root/html534/ROOT__Fit__FitResult.html:381,Availability,error,error,381,". ROOT::Fit::FitResult. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::FitResult. class ROOT::Fit::FitResult. class containg the result of the fit and all the related information; (fitted parameter values, error, covariance matrix and minimizer result information); Contains a pointer also to the fitted (model) function, modified with the fit parameter values.; When the fit is valid, it is constructed from a Minimizer and a model function pointer. @ingroup FitMain. Function Members (Methods); public:. virtual~FitResult(); doubleChi2() const; doubleCorrelation(unsigned int i, unsigned int j) const; doubleCovMatrix(unsigned int i, unsigned int j) const; intCovMatrixStatus() const; doubleEdm() const; doubleError(unsigned int i) const; const vector<double>&Errors() const; ROOT::Fit::FitResultFitResult(); ROOT::Fit::FitResultFitResult(const ROOT::Fit::FitConfig& fconfig); ROOT::Fit::FitResultFitResult(const ROOT::Fit::FitResult&); ROOT::Fit::FitResultFitResult(ROOT::Math::Minimizer& min, const ROOT::Fit::FitConfig& fconfig, const ROOT::Fit::FitResult::IModelFunction* f, bool isValid, unsigned int sizeOfData = 0, bool binFit = true, const ROOT::Math::IMultiGenFunction* chi2func = 0, unsigned int ncalls = 0); const ROOT::Fit::FitResult::IModelFunction*FittedFunction() const; voidGetConfidenceIntervals(const ROOT::Fit::BinData& data, double* ci, double cl = 0.95, bool norm = true) const; voidGetConfidenceIntervals(unsigned int n, unsigned int stride1, unsigned int stride2, const double* x, double* ci, double cl = 0.95, bool norm = true) const; voidGetCorrelationMatrix(TMatrixTSym<double>& mat) const; voidGetCorrelationMatrix<TMatrixDSym>(TMatrixTSym<double>& mat) const; voidGetCovarianceMatrix(TMatrixTSym<double>& mat) const; voidGetCovarianceMatrix<TMatrixDSym>(TMatrixTSym<double>& mat) const; const dou",MatchSource.WIKI,root/html534/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitResult.html
https://root.cern/root/html534/ROOT__Fit__FitResult.html:4215,Availability,error,errors,4215,"(unsigned int i) const. protected:. ROOT::Fit::FitResult::IModelFunction*ModelFunction(); voidSetModelFunction(ROOT::Fit::FitResult::IModelFunction* func). Data Members; protected:. map<unsigned int,unsigned int>fBoundParamslist of limited parameters; doublefChi2fit chi2 value (different than fval in case of chi2 fits); vector<double>fCovMatrixcovariance matrix (size is npar*(npar+1)/2) where npar is total parameters; intfCovStatuscovariance matrix status code; doublefEdmexpected distance from mimimum; vector<double>fErrorserrors ; ROOT::Fit::FitResult::IModelFunction*fFitFunc! model function resulting from the fit. It is given by Fitter but it is managed by FitResult; map<unsigned int,bool>fFixedParamslist of fixed parameters; vector<double>fGlobalCCglobal Correlation coefficient; stringfMinimTypestring indicating type of minimizer; map<unsigned int,std::pair<double,double> >fMinosErrorsmap contains the two Minos errors; unsigned intfNCallsnumber of function calls; unsigned intfNFreenumber of fit free parameters (total parameters are in size of parameter vector) ; unsigned intfNdfnumber of degree of freedom; boolfNormalizedflag for indicating is errors are normalized; vector<std::string>fParNamesparameter names (only with FCN only fits, when fFitFunc=0); vector<std::pair<double,double> >fParamBoundsparameter bounds; vector<double>fParamsparameter values. Size is total number of parameters; intfStatusminimizer status code; doublefValminimum function value; boolfValidflag for indicating valid fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitResult(). Default constructor for an empty (non valid) fit result. FitResult(const FitConfig & fconfig). Constructor from a fit-config for a dummy fit; (e.g. when only one fcn evaluation is done). FitResult(ROOT::Math::Minimizer& min, const ROOT::Fit::FitConfig& fconfig, const ROOT::Fit::FitResult::IModelFunction* f, bool isValid, unsigned int sizeOfData = 0, bool binFit = true, co",MatchSource.WIKI,root/html534/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitResult.html
https://root.cern/root/html534/ROOT__Fit__FitResult.html:4452,Availability,error,errors,4452,"(unsigned int i) const. protected:. ROOT::Fit::FitResult::IModelFunction*ModelFunction(); voidSetModelFunction(ROOT::Fit::FitResult::IModelFunction* func). Data Members; protected:. map<unsigned int,unsigned int>fBoundParamslist of limited parameters; doublefChi2fit chi2 value (different than fval in case of chi2 fits); vector<double>fCovMatrixcovariance matrix (size is npar*(npar+1)/2) where npar is total parameters; intfCovStatuscovariance matrix status code; doublefEdmexpected distance from mimimum; vector<double>fErrorserrors ; ROOT::Fit::FitResult::IModelFunction*fFitFunc! model function resulting from the fit. It is given by Fitter but it is managed by FitResult; map<unsigned int,bool>fFixedParamslist of fixed parameters; vector<double>fGlobalCCglobal Correlation coefficient; stringfMinimTypestring indicating type of minimizer; map<unsigned int,std::pair<double,double> >fMinosErrorsmap contains the two Minos errors; unsigned intfNCallsnumber of function calls; unsigned intfNFreenumber of fit free parameters (total parameters are in size of parameter vector) ; unsigned intfNdfnumber of degree of freedom; boolfNormalizedflag for indicating is errors are normalized; vector<std::string>fParNamesparameter names (only with FCN only fits, when fFitFunc=0); vector<std::pair<double,double> >fParamBoundsparameter bounds; vector<double>fParamsparameter values. Size is total number of parameters; intfStatusminimizer status code; doublefValminimum function value; boolfValidflag for indicating valid fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitResult(). Default constructor for an empty (non valid) fit result. FitResult(const FitConfig & fconfig). Constructor from a fit-config for a dummy fit; (e.g. when only one fcn evaluation is done). FitResult(ROOT::Math::Minimizer& min, const ROOT::Fit::FitConfig& fconfig, const ROOT::Fit::FitResult::IModelFunction* f, bool isValid, unsigned int sizeOfData = 0, bool binFit = true, co",MatchSource.WIKI,root/html534/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitResult.html
https://root.cern/root/html534/ROOT__Fit__FitResult.html:6161,Availability,error,error,6161,"OOT::Fit::FitConfig& fconfig, const ROOT::Fit::FitResult::IModelFunction* f, bool isValid, unsigned int sizeOfData = 0, bool binFit = true, const ROOT::Math::IMultiGenFunction* chi2func = 0, unsigned int ncalls = 0). Construct from a Minimizer instance after fitting; Run also Minos if requested from the configuration. FitResult(const FitResult &). Copy constructor. virtual ~FitResult(). Destructor. bool Update(const ROOT::Math::Minimizer& min, bool isValid, unsigned int ncalls = 0). Update the fit result with a new minimization status; To be run only if same fit is performed with same configuration; Note that in this case MINOS is not re-run. If one wants to run also MINOS; a new result must be created. const std::string & MinimizerType() const; minimization quantities ; minimizer type. { return fMinimType; }. bool IsValid() const. True if fit successful, otherwise false.; A fit is considered successful if the minimizer succeded in finding the; minimum. It could happen that subsequent operations like error analysis (e.g. Minos); failed. In that case the status can be still true if the original minimization algorithm; succeeded in finding the minimum.; One can query in that case the minimizer return status using Status().; It is responability to the Minimizer class to tag a found minimum as valid or not; and to produce also a status code. { return fValid; }. bool IsEmpty() const; True if a fit result does not exist (even invalid) with parameter values. { return (fParams.size() == 0); }. double MinFcnValue() const; Return value of the objective function (chi2 or likelihood) used in the fit. { return fVal; }. unsigned int NCalls() const; Number of function calls to find minimum. { return fNCalls; }. double Edm() const; Expected distance from minimum. { return fEdm; }. unsigned int NTotalParameters() const; get total number of parameters. { return fParams.size(); }. unsigned int NPar() const; total number of parameters (abbreviation). { return NTotalParameters(); }. unsi",MatchSource.WIKI,root/html534/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitResult.html
https://root.cern/root/html534/ROOT__Fit__FitResult.html:7922,Availability,error,errors,7922," from minimum. { return fEdm; }. unsigned int NTotalParameters() const; get total number of parameters. { return fParams.size(); }. unsigned int NPar() const; total number of parameters (abbreviation). { return NTotalParameters(); }. unsigned int NFreeParameters() const; get total number of free parameters. { return fNFree; }. int Status() const; minimizer status code. { return fStatus; }. int CovMatrixStatus() const; covariance matrix status code; using Minuit convention : =0 not calculated, =1 approximated, =2 made pos def , =3 accurate. { return fCovStatus; }. const IModelFunction * FittedFunction() const; fitting quantities ; Return pointer to model (fit) function with fitted parameter values. { return fFitFunc; }. double Chi2() const; Chi2 fit value; in case of likelihood must be computed ?. { return fChi2; }. unsigned int Ndf() const; Number of degree of freedom. { return fNdf; }. double Prob() const; p value of the fit (chi2 probability). const std::vector<double> & Errors() const; parameter errors (return st::vector). { return fErrors; }. const double * GetErrors() const; parameter errors (return const pointer). { return (fErrors.empty()) ? 0 : &fErrors.front(); }. const std::vector<double> & Parameters() const; parameter values (return std::vector). { return fParams; }. const double * GetParams() const; parameter values (return const pointer). { return &fParams.front(); }. double Value(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Parameter(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Error(unsigned int i) const; parameter error by index; (NOTE: this due to conflict with TObject::Error cannot used in derived class which; inherits from TObject. Use instead ParError (or Errors()[i] ). double ParError(unsigned int i) const; parameter error by index. std::string ParName(unsigned int i) const; name of the parameter. void SetMinosError(unsigned int i, double elow, double eup); set the Minos erro",MatchSource.WIKI,root/html534/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitResult.html
https://root.cern/root/html534/ROOT__Fit__FitResult.html:8015,Availability,error,errors,8015,"ers. { return fParams.size(); }. unsigned int NPar() const; total number of parameters (abbreviation). { return NTotalParameters(); }. unsigned int NFreeParameters() const; get total number of free parameters. { return fNFree; }. int Status() const; minimizer status code. { return fStatus; }. int CovMatrixStatus() const; covariance matrix status code; using Minuit convention : =0 not calculated, =1 approximated, =2 made pos def , =3 accurate. { return fCovStatus; }. const IModelFunction * FittedFunction() const; fitting quantities ; Return pointer to model (fit) function with fitted parameter values. { return fFitFunc; }. double Chi2() const; Chi2 fit value; in case of likelihood must be computed ?. { return fChi2; }. unsigned int Ndf() const; Number of degree of freedom. { return fNdf; }. double Prob() const; p value of the fit (chi2 probability). const std::vector<double> & Errors() const; parameter errors (return st::vector). { return fErrors; }. const double * GetErrors() const; parameter errors (return const pointer). { return (fErrors.empty()) ? 0 : &fErrors.front(); }. const std::vector<double> & Parameters() const; parameter values (return std::vector). { return fParams; }. const double * GetParams() const; parameter values (return const pointer). { return &fParams.front(); }. double Value(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Parameter(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Error(unsigned int i) const; parameter error by index; (NOTE: this due to conflict with TObject::Error cannot used in derived class which; inherits from TObject. Use instead ParError (or Errors()[i] ). double ParError(unsigned int i) const; parameter error by index. std::string ParName(unsigned int i) const; name of the parameter. void SetMinosError(unsigned int i, double elow, double eup); set the Minos errors for parameter i (called by the Fitter class when running Minos). bool HasMinosError(unsigned int ",MatchSource.WIKI,root/html534/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitResult.html
https://root.cern/root/html534/ROOT__Fit__FitResult.html:8535,Availability,error,error,8535,"it) function with fitted parameter values. { return fFitFunc; }. double Chi2() const; Chi2 fit value; in case of likelihood must be computed ?. { return fChi2; }. unsigned int Ndf() const; Number of degree of freedom. { return fNdf; }. double Prob() const; p value of the fit (chi2 probability). const std::vector<double> & Errors() const; parameter errors (return st::vector). { return fErrors; }. const double * GetErrors() const; parameter errors (return const pointer). { return (fErrors.empty()) ? 0 : &fErrors.front(); }. const std::vector<double> & Parameters() const; parameter values (return std::vector). { return fParams; }. const double * GetParams() const; parameter values (return const pointer). { return &fParams.front(); }. double Value(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Parameter(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Error(unsigned int i) const; parameter error by index; (NOTE: this due to conflict with TObject::Error cannot used in derived class which; inherits from TObject. Use instead ParError (or Errors()[i] ). double ParError(unsigned int i) const; parameter error by index. std::string ParName(unsigned int i) const; name of the parameter. void SetMinosError(unsigned int i, double elow, double eup); set the Minos errors for parameter i (called by the Fitter class when running Minos). bool HasMinosError(unsigned int i) const; query if parameter i has the Minos error. double LowerError(unsigned int i) const; lower Minos error. If Minos has not run for parameter i return the parabolic error. double UpperError(unsigned int i) const; upper Minos error. If Minos has not run for parameter i return the parabolic error. double GlobalCC(unsigned int i) const; parameter global correlation coefficient. double CovMatrix(unsigned int i, unsigned int j) const; retrieve covariance matrix element. double Correlation(unsigned int i, unsigned int j) const; retrieve correlation elements. v",MatchSource.WIKI,root/html534/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitResult.html
https://root.cern/root/html534/ROOT__Fit__FitResult.html:8747,Availability,error,error,8747,"2; }. unsigned int Ndf() const; Number of degree of freedom. { return fNdf; }. double Prob() const; p value of the fit (chi2 probability). const std::vector<double> & Errors() const; parameter errors (return st::vector). { return fErrors; }. const double * GetErrors() const; parameter errors (return const pointer). { return (fErrors.empty()) ? 0 : &fErrors.front(); }. const std::vector<double> & Parameters() const; parameter values (return std::vector). { return fParams; }. const double * GetParams() const; parameter values (return const pointer). { return &fParams.front(); }. double Value(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Parameter(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Error(unsigned int i) const; parameter error by index; (NOTE: this due to conflict with TObject::Error cannot used in derived class which; inherits from TObject. Use instead ParError (or Errors()[i] ). double ParError(unsigned int i) const; parameter error by index. std::string ParName(unsigned int i) const; name of the parameter. void SetMinosError(unsigned int i, double elow, double eup); set the Minos errors for parameter i (called by the Fitter class when running Minos). bool HasMinosError(unsigned int i) const; query if parameter i has the Minos error. double LowerError(unsigned int i) const; lower Minos error. If Minos has not run for parameter i return the parabolic error. double UpperError(unsigned int i) const; upper Minos error. If Minos has not run for parameter i return the parabolic error. double GlobalCC(unsigned int i) const; parameter global correlation coefficient. double CovMatrix(unsigned int i, unsigned int j) const; retrieve covariance matrix element. double Correlation(unsigned int i, unsigned int j) const; retrieve correlation elements. void GetCovarianceMatrix(TMatrixTSym<double>& mat) const; fill covariance matrix elements using a generic matrix class implementing operator(i,j); the matrix ",MatchSource.WIKI,root/html534/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitResult.html
https://root.cern/root/html534/ROOT__Fit__FitResult.html:8904,Availability,error,errors,8904,"s() const; parameter errors (return st::vector). { return fErrors; }. const double * GetErrors() const; parameter errors (return const pointer). { return (fErrors.empty()) ? 0 : &fErrors.front(); }. const std::vector<double> & Parameters() const; parameter values (return std::vector). { return fParams; }. const double * GetParams() const; parameter values (return const pointer). { return &fParams.front(); }. double Value(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Parameter(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Error(unsigned int i) const; parameter error by index; (NOTE: this due to conflict with TObject::Error cannot used in derived class which; inherits from TObject. Use instead ParError (or Errors()[i] ). double ParError(unsigned int i) const; parameter error by index. std::string ParName(unsigned int i) const; name of the parameter. void SetMinosError(unsigned int i, double elow, double eup); set the Minos errors for parameter i (called by the Fitter class when running Minos). bool HasMinosError(unsigned int i) const; query if parameter i has the Minos error. double LowerError(unsigned int i) const; lower Minos error. If Minos has not run for parameter i return the parabolic error. double UpperError(unsigned int i) const; upper Minos error. If Minos has not run for parameter i return the parabolic error. double GlobalCC(unsigned int i) const; parameter global correlation coefficient. double CovMatrix(unsigned int i, unsigned int j) const; retrieve covariance matrix element. double Correlation(unsigned int i, unsigned int j) const; retrieve correlation elements. void GetCovarianceMatrix(TMatrixTSym<double>& mat) const; fill covariance matrix elements using a generic matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetCorrelationMatrix(TMatrixTSym<double>& mat) const; fill a correlation matrix elements using a generic sy",MatchSource.WIKI,root/html534/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitResult.html
https://root.cern/root/html534/ROOT__Fit__FitResult.html:9053,Availability,error,error,9053,"rors (return const pointer). { return (fErrors.empty()) ? 0 : &fErrors.front(); }. const std::vector<double> & Parameters() const; parameter values (return std::vector). { return fParams; }. const double * GetParams() const; parameter values (return const pointer). { return &fParams.front(); }. double Value(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Parameter(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Error(unsigned int i) const; parameter error by index; (NOTE: this due to conflict with TObject::Error cannot used in derived class which; inherits from TObject. Use instead ParError (or Errors()[i] ). double ParError(unsigned int i) const; parameter error by index. std::string ParName(unsigned int i) const; name of the parameter. void SetMinosError(unsigned int i, double elow, double eup); set the Minos errors for parameter i (called by the Fitter class when running Minos). bool HasMinosError(unsigned int i) const; query if parameter i has the Minos error. double LowerError(unsigned int i) const; lower Minos error. If Minos has not run for parameter i return the parabolic error. double UpperError(unsigned int i) const; upper Minos error. If Minos has not run for parameter i return the parabolic error. double GlobalCC(unsigned int i) const; parameter global correlation coefficient. double CovMatrix(unsigned int i, unsigned int j) const; retrieve covariance matrix element. double Correlation(unsigned int i, unsigned int j) const; retrieve correlation elements. void GetCovarianceMatrix(TMatrixTSym<double>& mat) const; fill covariance matrix elements using a generic matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetCorrelationMatrix(TMatrixTSym<double>& mat) const; fill a correlation matrix elements using a generic symmetric matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * np",MatchSource.WIKI,root/html534/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitResult.html
https://root.cern/root/html534/ROOT__Fit__FitResult.html:9113,Availability,error,error,9113,"ront(); }. const std::vector<double> & Parameters() const; parameter values (return std::vector). { return fParams; }. const double * GetParams() const; parameter values (return const pointer). { return &fParams.front(); }. double Value(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Parameter(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Error(unsigned int i) const; parameter error by index; (NOTE: this due to conflict with TObject::Error cannot used in derived class which; inherits from TObject. Use instead ParError (or Errors()[i] ). double ParError(unsigned int i) const; parameter error by index. std::string ParName(unsigned int i) const; name of the parameter. void SetMinosError(unsigned int i, double elow, double eup); set the Minos errors for parameter i (called by the Fitter class when running Minos). bool HasMinosError(unsigned int i) const; query if parameter i has the Minos error. double LowerError(unsigned int i) const; lower Minos error. If Minos has not run for parameter i return the parabolic error. double UpperError(unsigned int i) const; upper Minos error. If Minos has not run for parameter i return the parabolic error. double GlobalCC(unsigned int i) const; parameter global correlation coefficient. double CovMatrix(unsigned int i, unsigned int j) const; retrieve covariance matrix element. double Correlation(unsigned int i, unsigned int j) const; retrieve correlation elements. void GetCovarianceMatrix(TMatrixTSym<double>& mat) const; fill covariance matrix elements using a generic matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetCorrelationMatrix(TMatrixTSym<double>& mat) const; fill a correlation matrix elements using a generic symmetric matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetConfidenceIntervals(unsigned int n, unsigned int stride1, u",MatchSource.WIKI,root/html534/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitResult.html
https://root.cern/root/html534/ROOT__Fit__FitResult.html:9178,Availability,error,error,9178,"ameter values (return std::vector). { return fParams; }. const double * GetParams() const; parameter values (return const pointer). { return &fParams.front(); }. double Value(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Parameter(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Error(unsigned int i) const; parameter error by index; (NOTE: this due to conflict with TObject::Error cannot used in derived class which; inherits from TObject. Use instead ParError (or Errors()[i] ). double ParError(unsigned int i) const; parameter error by index. std::string ParName(unsigned int i) const; name of the parameter. void SetMinosError(unsigned int i, double elow, double eup); set the Minos errors for parameter i (called by the Fitter class when running Minos). bool HasMinosError(unsigned int i) const; query if parameter i has the Minos error. double LowerError(unsigned int i) const; lower Minos error. If Minos has not run for parameter i return the parabolic error. double UpperError(unsigned int i) const; upper Minos error. If Minos has not run for parameter i return the parabolic error. double GlobalCC(unsigned int i) const; parameter global correlation coefficient. double CovMatrix(unsigned int i, unsigned int j) const; retrieve covariance matrix element. double Correlation(unsigned int i, unsigned int j) const; retrieve correlation elements. void GetCovarianceMatrix(TMatrixTSym<double>& mat) const; fill covariance matrix elements using a generic matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetCorrelationMatrix(TMatrixTSym<double>& mat) const; fill a correlation matrix elements using a generic symmetric matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetConfidenceIntervals(unsigned int n, unsigned int stride1, unsigned int stride2, const double* x, double* ci, double cl = 0",MatchSource.WIKI,root/html534/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitResult.html
https://root.cern/root/html534/ROOT__Fit__FitResult.html:9238,Availability,error,error,9238,"double * GetParams() const; parameter values (return const pointer). { return &fParams.front(); }. double Value(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Parameter(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Error(unsigned int i) const; parameter error by index; (NOTE: this due to conflict with TObject::Error cannot used in derived class which; inherits from TObject. Use instead ParError (or Errors()[i] ). double ParError(unsigned int i) const; parameter error by index. std::string ParName(unsigned int i) const; name of the parameter. void SetMinosError(unsigned int i, double elow, double eup); set the Minos errors for parameter i (called by the Fitter class when running Minos). bool HasMinosError(unsigned int i) const; query if parameter i has the Minos error. double LowerError(unsigned int i) const; lower Minos error. If Minos has not run for parameter i return the parabolic error. double UpperError(unsigned int i) const; upper Minos error. If Minos has not run for parameter i return the parabolic error. double GlobalCC(unsigned int i) const; parameter global correlation coefficient. double CovMatrix(unsigned int i, unsigned int j) const; retrieve covariance matrix element. double Correlation(unsigned int i, unsigned int j) const; retrieve correlation elements. void GetCovarianceMatrix(TMatrixTSym<double>& mat) const; fill covariance matrix elements using a generic matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetCorrelationMatrix(TMatrixTSym<double>& mat) const; fill a correlation matrix elements using a generic symmetric matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetConfidenceIntervals(unsigned int n, unsigned int stride1, unsigned int stride2, const double* x, double* ci, double cl = 0.95, bool norm = true) const. get confidence intervals for an ",MatchSource.WIKI,root/html534/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitResult.html
https://root.cern/root/html534/ROOT__Fit__FitResult.html:9303,Availability,error,error,9303,"nter). { return &fParams.front(); }. double Value(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Parameter(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Error(unsigned int i) const; parameter error by index; (NOTE: this due to conflict with TObject::Error cannot used in derived class which; inherits from TObject. Use instead ParError (or Errors()[i] ). double ParError(unsigned int i) const; parameter error by index. std::string ParName(unsigned int i) const; name of the parameter. void SetMinosError(unsigned int i, double elow, double eup); set the Minos errors for parameter i (called by the Fitter class when running Minos). bool HasMinosError(unsigned int i) const; query if parameter i has the Minos error. double LowerError(unsigned int i) const; lower Minos error. If Minos has not run for parameter i return the parabolic error. double UpperError(unsigned int i) const; upper Minos error. If Minos has not run for parameter i return the parabolic error. double GlobalCC(unsigned int i) const; parameter global correlation coefficient. double CovMatrix(unsigned int i, unsigned int j) const; retrieve covariance matrix element. double Correlation(unsigned int i, unsigned int j) const; retrieve correlation elements. void GetCovarianceMatrix(TMatrixTSym<double>& mat) const; fill covariance matrix elements using a generic matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetCorrelationMatrix(TMatrixTSym<double>& mat) const; fill a correlation matrix elements using a generic symmetric matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetConfidenceIntervals(unsigned int n, unsigned int stride1, unsigned int stride2, const double* x, double* ci, double cl = 0.95, bool norm = true) const. get confidence intervals for an array of n points x.; stride1 indicates the stride in the coord",MatchSource.WIKI,root/html534/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitResult.html
https://root.cern/root/html534/ROOT__Fit__FitResult.html:11252,Availability,error,errors,11252,"s the stride in the coordinate space while stride2 the stride in dimension space.; For 1-dim points : stride1=1, stride2=1; for multi-dim points arranged as (x0,x1,...,xN,y0,....yN) stride1=1 stride2=n; for multi-dim points arraged as (x0,y0,..,x1,y1,...,xN,yN,..) stride1=ndim, stride2=1. the confidence interval are returned in the array ci; cl is the desired confidedence interval value; norm is a flag to control if the intervals need to be normalized to the chi2/ndf value; By default the intervals are corrected using the chi2/ndf value of the fit if a chi2 fit is performed. void GetConfidenceIntervals(const ROOT::Fit::BinData& data, double* ci, double cl = 0.95, bool norm = true) const. evaluate confidence interval for the point specified in the passed data sets; the confidence interval are returned in the array ci; cl is the desired confidence interval value. int Index(const string& name) const; get index for parameter name (return -1 if not found). void NormalizeErrors(); normalize errors using chi2/ndf for chi2 fits. bool NormalizedErrors() const; flag to chek if errors are normalized. { return fNormalized; }. void Print(ostream& os, bool covmat = false) const; print the result and optionaly covariance matrix and correlations. void PrintCovMatrix(ostream& os) const; print error matrix and correlations. bool IsParameterBound(unsigned int ipar) const; query if a parameter is bound. bool IsParameterFixed(unsigned int ipar) const; query if a parameter is fixed. bool ParameterBounds(unsigned int ipar, double& lower, double& upper) const; retrieve parameter bounds - return false if parameter is not bound. std::string GetParameterName(unsigned int ipar) const; get name of parameter (deprecated). void SetModelFunction(ROOT::Fit::FitResult::IModelFunction* func); { fFitFunc = func; }.  Author: L. Moneta Wed Aug 30 11:05:34 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been",MatchSource.WIKI,root/html534/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitResult.html
https://root.cern/root/html534/ROOT__Fit__FitResult.html:11336,Availability,error,errors,11336,"ion space.; For 1-dim points : stride1=1, stride2=1; for multi-dim points arranged as (x0,x1,...,xN,y0,....yN) stride1=1 stride2=n; for multi-dim points arraged as (x0,y0,..,x1,y1,...,xN,yN,..) stride1=ndim, stride2=1. the confidence interval are returned in the array ci; cl is the desired confidedence interval value; norm is a flag to control if the intervals need to be normalized to the chi2/ndf value; By default the intervals are corrected using the chi2/ndf value of the fit if a chi2 fit is performed. void GetConfidenceIntervals(const ROOT::Fit::BinData& data, double* ci, double cl = 0.95, bool norm = true) const. evaluate confidence interval for the point specified in the passed data sets; the confidence interval are returned in the array ci; cl is the desired confidence interval value. int Index(const string& name) const; get index for parameter name (return -1 if not found). void NormalizeErrors(); normalize errors using chi2/ndf for chi2 fits. bool NormalizedErrors() const; flag to chek if errors are normalized. { return fNormalized; }. void Print(ostream& os, bool covmat = false) const; print the result and optionaly covariance matrix and correlations. void PrintCovMatrix(ostream& os) const; print error matrix and correlations. bool IsParameterBound(unsigned int ipar) const; query if a parameter is bound. bool IsParameterFixed(unsigned int ipar) const; query if a parameter is fixed. bool ParameterBounds(unsigned int ipar, double& lower, double& upper) const; retrieve parameter bounds - return false if parameter is not bound. std::string GetParameterName(unsigned int ipar) const; get name of parameter (deprecated). void SetModelFunction(ROOT::Fit::FitResult::IModelFunction* func); { fFitFunc = func; }.  Author: L. Moneta Wed Aug 30 11:05:34 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the do",MatchSource.WIKI,root/html534/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitResult.html
https://root.cern/root/html534/ROOT__Fit__FitResult.html:11549,Availability,error,error,11549,"points arranged as (x0,x1,...,xN,y0,....yN) stride1=1 stride2=n; for multi-dim points arraged as (x0,y0,..,x1,y1,...,xN,yN,..) stride1=ndim, stride2=1. the confidence interval are returned in the array ci; cl is the desired confidedence interval value; norm is a flag to control if the intervals need to be normalized to the chi2/ndf value; By default the intervals are corrected using the chi2/ndf value of the fit if a chi2 fit is performed. void GetConfidenceIntervals(const ROOT::Fit::BinData& data, double* ci, double cl = 0.95, bool norm = true) const. evaluate confidence interval for the point specified in the passed data sets; the confidence interval are returned in the array ci; cl is the desired confidence interval value. int Index(const string& name) const; get index for parameter name (return -1 if not found). void NormalizeErrors(); normalize errors using chi2/ndf for chi2 fits. bool NormalizedErrors() const; flag to chek if errors are normalized. { return fNormalized; }. void Print(ostream& os, bool covmat = false) const; print the result and optionaly covariance matrix and correlations. void PrintCovMatrix(ostream& os) const; print error matrix and correlations. bool IsParameterBound(unsigned int ipar) const; query if a parameter is bound. bool IsParameterFixed(unsigned int ipar) const; query if a parameter is fixed. bool ParameterBounds(unsigned int ipar, double& lower, double& upper) const; retrieve parameter bounds - return false if parameter is not bound. std::string GetParameterName(unsigned int ipar) const; get name of parameter (deprecated). void SetModelFunction(ROOT::Fit::FitResult::IModelFunction* func); { fFitFunc = func; }.  Author: L. Moneta Wed Aug 30 11:05:34 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitResult.html
https://root.cern/root/html534/ROOT__Fit__FitResult.html:5450,Deployability,configurat,configuration,5450,"; boolfNormalizedflag for indicating is errors are normalized; vector<std::string>fParNamesparameter names (only with FCN only fits, when fFitFunc=0); vector<std::pair<double,double> >fParamBoundsparameter bounds; vector<double>fParamsparameter values. Size is total number of parameters; intfStatusminimizer status code; doublefValminimum function value; boolfValidflag for indicating valid fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitResult(). Default constructor for an empty (non valid) fit result. FitResult(const FitConfig & fconfig). Constructor from a fit-config for a dummy fit; (e.g. when only one fcn evaluation is done). FitResult(ROOT::Math::Minimizer& min, const ROOT::Fit::FitConfig& fconfig, const ROOT::Fit::FitResult::IModelFunction* f, bool isValid, unsigned int sizeOfData = 0, bool binFit = true, const ROOT::Math::IMultiGenFunction* chi2func = 0, unsigned int ncalls = 0). Construct from a Minimizer instance after fitting; Run also Minos if requested from the configuration. FitResult(const FitResult &). Copy constructor. virtual ~FitResult(). Destructor. bool Update(const ROOT::Math::Minimizer& min, bool isValid, unsigned int ncalls = 0). Update the fit result with a new minimization status; To be run only if same fit is performed with same configuration; Note that in this case MINOS is not re-run. If one wants to run also MINOS; a new result must be created. const std::string & MinimizerType() const; minimization quantities ; minimizer type. { return fMinimType; }. bool IsValid() const. True if fit successful, otherwise false.; A fit is considered successful if the minimizer succeded in finding the; minimum. It could happen that subsequent operations like error analysis (e.g. Minos); failed. In that case the status can be still true if the original minimization algorithm; succeeded in finding the minimum.; One can query in that case the minimizer return status using Status().; It is responability to the",MatchSource.WIKI,root/html534/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitResult.html
https://root.cern/root/html534/ROOT__Fit__FitResult.html:5737,Deployability,configurat,configuration,5737,"nimizer status code; doublefValminimum function value; boolfValidflag for indicating valid fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitResult(). Default constructor for an empty (non valid) fit result. FitResult(const FitConfig & fconfig). Constructor from a fit-config for a dummy fit; (e.g. when only one fcn evaluation is done). FitResult(ROOT::Math::Minimizer& min, const ROOT::Fit::FitConfig& fconfig, const ROOT::Fit::FitResult::IModelFunction* f, bool isValid, unsigned int sizeOfData = 0, bool binFit = true, const ROOT::Math::IMultiGenFunction* chi2func = 0, unsigned int ncalls = 0). Construct from a Minimizer instance after fitting; Run also Minos if requested from the configuration. FitResult(const FitResult &). Copy constructor. virtual ~FitResult(). Destructor. bool Update(const ROOT::Math::Minimizer& min, bool isValid, unsigned int ncalls = 0). Update the fit result with a new minimization status; To be run only if same fit is performed with same configuration; Note that in this case MINOS is not re-run. If one wants to run also MINOS; a new result must be created. const std::string & MinimizerType() const; minimization quantities ; minimizer type. { return fMinimType; }. bool IsValid() const. True if fit successful, otherwise false.; A fit is considered successful if the minimizer succeded in finding the; minimum. It could happen that subsequent operations like error analysis (e.g. Minos); failed. In that case the status can be still true if the original minimization algorithm; succeeded in finding the minimum.; One can query in that case the minimizer return status using Status().; It is responability to the Minimizer class to tag a found minimum as valid or not; and to produce also a status code. { return fValid; }. bool IsEmpty() const; True if a fit result does not exist (even invalid) with parameter values. { return (fParams.size() == 0); }. double MinFcnValue() const; Return value of the objective ",MatchSource.WIKI,root/html534/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitResult.html
https://root.cern/root/html534/ROOT__Fit__FitResult.html:9749,Energy Efficiency,allocate,allocates,9749,"or Errors()[i] ). double ParError(unsigned int i) const; parameter error by index. std::string ParName(unsigned int i) const; name of the parameter. void SetMinosError(unsigned int i, double elow, double eup); set the Minos errors for parameter i (called by the Fitter class when running Minos). bool HasMinosError(unsigned int i) const; query if parameter i has the Minos error. double LowerError(unsigned int i) const; lower Minos error. If Minos has not run for parameter i return the parabolic error. double UpperError(unsigned int i) const; upper Minos error. If Minos has not run for parameter i return the parabolic error. double GlobalCC(unsigned int i) const; parameter global correlation coefficient. double CovMatrix(unsigned int i, unsigned int j) const; retrieve covariance matrix element. double Correlation(unsigned int i, unsigned int j) const; retrieve correlation elements. void GetCovarianceMatrix(TMatrixTSym<double>& mat) const; fill covariance matrix elements using a generic matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetCorrelationMatrix(TMatrixTSym<double>& mat) const; fill a correlation matrix elements using a generic symmetric matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetConfidenceIntervals(unsigned int n, unsigned int stride1, unsigned int stride2, const double* x, double* ci, double cl = 0.95, bool norm = true) const. get confidence intervals for an array of n points x.; stride1 indicates the stride in the coordinate space while stride2 the stride in dimension space.; For 1-dim points : stride1=1, stride2=1; for multi-dim points arranged as (x0,x1,...,xN,y0,....yN) stride1=1 stride2=n; for multi-dim points arraged as (x0,y0,..,x1,y1,...,xN,yN,..) stride1=ndim, stride2=1. the confidence interval are returned in the array ci; cl is the desired confidedence interval value; norm is a flag to control if the inte",MatchSource.WIKI,root/html534/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitResult.html
https://root.cern/root/html534/ROOT__Fit__FitResult.html:9981,Energy Efficiency,allocate,allocates,9981,"rrors for parameter i (called by the Fitter class when running Minos). bool HasMinosError(unsigned int i) const; query if parameter i has the Minos error. double LowerError(unsigned int i) const; lower Minos error. If Minos has not run for parameter i return the parabolic error. double UpperError(unsigned int i) const; upper Minos error. If Minos has not run for parameter i return the parabolic error. double GlobalCC(unsigned int i) const; parameter global correlation coefficient. double CovMatrix(unsigned int i, unsigned int j) const; retrieve covariance matrix element. double Correlation(unsigned int i, unsigned int j) const; retrieve correlation elements. void GetCovarianceMatrix(TMatrixTSym<double>& mat) const; fill covariance matrix elements using a generic matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetCorrelationMatrix(TMatrixTSym<double>& mat) const; fill a correlation matrix elements using a generic symmetric matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetConfidenceIntervals(unsigned int n, unsigned int stride1, unsigned int stride2, const double* x, double* ci, double cl = 0.95, bool norm = true) const. get confidence intervals for an array of n points x.; stride1 indicates the stride in the coordinate space while stride2 the stride in dimension space.; For 1-dim points : stride1=1, stride2=1; for multi-dim points arranged as (x0,x1,...,xN,y0,....yN) stride1=1 stride2=n; for multi-dim points arraged as (x0,y0,..,x1,y1,...,xN,yN,..) stride1=ndim, stride2=1. the confidence interval are returned in the array ci; cl is the desired confidedence interval value; norm is a flag to control if the intervals need to be normalized to the chi2/ndf value; By default the intervals are corrected using the chi2/ndf value of the fit if a chi2 fit is performed. void GetConfidenceIntervals(const ROOT::Fit::BinData& data, double* ci,",MatchSource.WIKI,root/html534/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitResult.html
https://root.cern/root/html534/ROOT__Fit__FitResult.html:5031,Modifiability,config,config,5031,"double>fGlobalCCglobal Correlation coefficient; stringfMinimTypestring indicating type of minimizer; map<unsigned int,std::pair<double,double> >fMinosErrorsmap contains the two Minos errors; unsigned intfNCallsnumber of function calls; unsigned intfNFreenumber of fit free parameters (total parameters are in size of parameter vector) ; unsigned intfNdfnumber of degree of freedom; boolfNormalizedflag for indicating is errors are normalized; vector<std::string>fParNamesparameter names (only with FCN only fits, when fFitFunc=0); vector<std::pair<double,double> >fParamBoundsparameter bounds; vector<double>fParamsparameter values. Size is total number of parameters; intfStatusminimizer status code; doublefValminimum function value; boolfValidflag for indicating valid fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitResult(). Default constructor for an empty (non valid) fit result. FitResult(const FitConfig & fconfig). Constructor from a fit-config for a dummy fit; (e.g. when only one fcn evaluation is done). FitResult(ROOT::Math::Minimizer& min, const ROOT::Fit::FitConfig& fconfig, const ROOT::Fit::FitResult::IModelFunction* f, bool isValid, unsigned int sizeOfData = 0, bool binFit = true, const ROOT::Math::IMultiGenFunction* chi2func = 0, unsigned int ncalls = 0). Construct from a Minimizer instance after fitting; Run also Minos if requested from the configuration. FitResult(const FitResult &). Copy constructor. virtual ~FitResult(). Destructor. bool Update(const ROOT::Math::Minimizer& min, bool isValid, unsigned int ncalls = 0). Update the fit result with a new minimization status; To be run only if same fit is performed with same configuration; Note that in this case MINOS is not re-run. If one wants to run also MINOS; a new result must be created. const std::string & MinimizerType() const; minimization quantities ; minimizer type. { return fMinimType; }. bool IsValid() const. True if fit successful, otherwise false.; A ",MatchSource.WIKI,root/html534/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitResult.html
https://root.cern/root/html534/ROOT__Fit__FitResult.html:5450,Modifiability,config,configuration,5450,"; boolfNormalizedflag for indicating is errors are normalized; vector<std::string>fParNamesparameter names (only with FCN only fits, when fFitFunc=0); vector<std::pair<double,double> >fParamBoundsparameter bounds; vector<double>fParamsparameter values. Size is total number of parameters; intfStatusminimizer status code; doublefValminimum function value; boolfValidflag for indicating valid fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitResult(). Default constructor for an empty (non valid) fit result. FitResult(const FitConfig & fconfig). Constructor from a fit-config for a dummy fit; (e.g. when only one fcn evaluation is done). FitResult(ROOT::Math::Minimizer& min, const ROOT::Fit::FitConfig& fconfig, const ROOT::Fit::FitResult::IModelFunction* f, bool isValid, unsigned int sizeOfData = 0, bool binFit = true, const ROOT::Math::IMultiGenFunction* chi2func = 0, unsigned int ncalls = 0). Construct from a Minimizer instance after fitting; Run also Minos if requested from the configuration. FitResult(const FitResult &). Copy constructor. virtual ~FitResult(). Destructor. bool Update(const ROOT::Math::Minimizer& min, bool isValid, unsigned int ncalls = 0). Update the fit result with a new minimization status; To be run only if same fit is performed with same configuration; Note that in this case MINOS is not re-run. If one wants to run also MINOS; a new result must be created. const std::string & MinimizerType() const; minimization quantities ; minimizer type. { return fMinimType; }. bool IsValid() const. True if fit successful, otherwise false.; A fit is considered successful if the minimizer succeded in finding the; minimum. It could happen that subsequent operations like error analysis (e.g. Minos); failed. In that case the status can be still true if the original minimization algorithm; succeeded in finding the minimum.; One can query in that case the minimizer return status using Status().; It is responability to the",MatchSource.WIKI,root/html534/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitResult.html
https://root.cern/root/html534/ROOT__Fit__FitResult.html:5737,Modifiability,config,configuration,5737,"nimizer status code; doublefValminimum function value; boolfValidflag for indicating valid fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitResult(). Default constructor for an empty (non valid) fit result. FitResult(const FitConfig & fconfig). Constructor from a fit-config for a dummy fit; (e.g. when only one fcn evaluation is done). FitResult(ROOT::Math::Minimizer& min, const ROOT::Fit::FitConfig& fconfig, const ROOT::Fit::FitResult::IModelFunction* f, bool isValid, unsigned int sizeOfData = 0, bool binFit = true, const ROOT::Math::IMultiGenFunction* chi2func = 0, unsigned int ncalls = 0). Construct from a Minimizer instance after fitting; Run also Minos if requested from the configuration. FitResult(const FitResult &). Copy constructor. virtual ~FitResult(). Destructor. bool Update(const ROOT::Math::Minimizer& min, bool isValid, unsigned int ncalls = 0). Update the fit result with a new minimization status; To be run only if same fit is performed with same configuration; Note that in this case MINOS is not re-run. If one wants to run also MINOS; a new result must be created. const std::string & MinimizerType() const; minimization quantities ; minimizer type. { return fMinimType; }. bool IsValid() const. True if fit successful, otherwise false.; A fit is considered successful if the minimizer succeded in finding the; minimum. It could happen that subsequent operations like error analysis (e.g. Minos); failed. In that case the status can be still true if the original minimization algorithm; succeeded in finding the minimum.; One can query in that case the minimizer return status using Status().; It is responability to the Minimizer class to tag a found minimum as valid or not; and to produce also a status code. { return fValid; }. bool IsEmpty() const; True if a fit result does not exist (even invalid) with parameter values. { return (fParams.size() == 0); }. double MinFcnValue() const; Return value of the objective ",MatchSource.WIKI,root/html534/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitResult.html
https://root.cern/root/html534/ROOT__Fit__FitResult.html:8635,Modifiability,inherit,inherits,8635,"it) function with fitted parameter values. { return fFitFunc; }. double Chi2() const; Chi2 fit value; in case of likelihood must be computed ?. { return fChi2; }. unsigned int Ndf() const; Number of degree of freedom. { return fNdf; }. double Prob() const; p value of the fit (chi2 probability). const std::vector<double> & Errors() const; parameter errors (return st::vector). { return fErrors; }. const double * GetErrors() const; parameter errors (return const pointer). { return (fErrors.empty()) ? 0 : &fErrors.front(); }. const std::vector<double> & Parameters() const; parameter values (return std::vector). { return fParams; }. const double * GetParams() const; parameter values (return const pointer). { return &fParams.front(); }. double Value(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Parameter(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Error(unsigned int i) const; parameter error by index; (NOTE: this due to conflict with TObject::Error cannot used in derived class which; inherits from TObject. Use instead ParError (or Errors()[i] ). double ParError(unsigned int i) const; parameter error by index. std::string ParName(unsigned int i) const; name of the parameter. void SetMinosError(unsigned int i, double elow, double eup); set the Minos errors for parameter i (called by the Fitter class when running Minos). bool HasMinosError(unsigned int i) const; query if parameter i has the Minos error. double LowerError(unsigned int i) const; lower Minos error. If Minos has not run for parameter i return the parabolic error. double UpperError(unsigned int i) const; upper Minos error. If Minos has not run for parameter i return the parabolic error. double GlobalCC(unsigned int i) const; parameter global correlation coefficient. double CovMatrix(unsigned int i, unsigned int j) const; retrieve covariance matrix element. double Correlation(unsigned int i, unsigned int j) const; retrieve correlation elements. v",MatchSource.WIKI,root/html534/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitResult.html
https://root.cern/root/html534/ROOT__Fit__FitResult.html:5717,Performance,perform,performed,5717,"nimizer status code; doublefValminimum function value; boolfValidflag for indicating valid fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FitResult(). Default constructor for an empty (non valid) fit result. FitResult(const FitConfig & fconfig). Constructor from a fit-config for a dummy fit; (e.g. when only one fcn evaluation is done). FitResult(ROOT::Math::Minimizer& min, const ROOT::Fit::FitConfig& fconfig, const ROOT::Fit::FitResult::IModelFunction* f, bool isValid, unsigned int sizeOfData = 0, bool binFit = true, const ROOT::Math::IMultiGenFunction* chi2func = 0, unsigned int ncalls = 0). Construct from a Minimizer instance after fitting; Run also Minos if requested from the configuration. FitResult(const FitResult &). Copy constructor. virtual ~FitResult(). Destructor. bool Update(const ROOT::Math::Minimizer& min, bool isValid, unsigned int ncalls = 0). Update the fit result with a new minimization status; To be run only if same fit is performed with same configuration; Note that in this case MINOS is not re-run. If one wants to run also MINOS; a new result must be created. const std::string & MinimizerType() const; minimization quantities ; minimizer type. { return fMinimType; }. bool IsValid() const. True if fit successful, otherwise false.; A fit is considered successful if the minimizer succeded in finding the; minimum. It could happen that subsequent operations like error analysis (e.g. Minos); failed. In that case the status can be still true if the original minimization algorithm; succeeded in finding the minimum.; One can query in that case the minimizer return status using Status().; It is responability to the Minimizer class to tag a found minimum as valid or not; and to produce also a status code. { return fValid; }. bool IsEmpty() const; True if a fit result does not exist (even invalid) with parameter values. { return (fParams.size() == 0); }. double MinFcnValue() const; Return value of the objective ",MatchSource.WIKI,root/html534/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitResult.html
https://root.cern/root/html534/ROOT__Fit__FitResult.html:10823,Performance,perform,performed,10823,"ass implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetCorrelationMatrix(TMatrixTSym<double>& mat) const; fill a correlation matrix elements using a generic symmetric matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetConfidenceIntervals(unsigned int n, unsigned int stride1, unsigned int stride2, const double* x, double* ci, double cl = 0.95, bool norm = true) const. get confidence intervals for an array of n points x.; stride1 indicates the stride in the coordinate space while stride2 the stride in dimension space.; For 1-dim points : stride1=1, stride2=1; for multi-dim points arranged as (x0,x1,...,xN,y0,....yN) stride1=1 stride2=n; for multi-dim points arraged as (x0,y0,..,x1,y1,...,xN,yN,..) stride1=ndim, stride2=1. the confidence interval are returned in the array ci; cl is the desired confidedence interval value; norm is a flag to control if the intervals need to be normalized to the chi2/ndf value; By default the intervals are corrected using the chi2/ndf value of the fit if a chi2 fit is performed. void GetConfidenceIntervals(const ROOT::Fit::BinData& data, double* ci, double cl = 0.95, bool norm = true) const. evaluate confidence interval for the point specified in the passed data sets; the confidence interval are returned in the array ci; cl is the desired confidence interval value. int Index(const string& name) const; get index for parameter name (return -1 if not found). void NormalizeErrors(); normalize errors using chi2/ndf for chi2 fits. bool NormalizedErrors() const; flag to chek if errors are normalized. { return fNormalized; }. void Print(ostream& os, bool covmat = false) const; print the result and optionaly covariance matrix and correlations. void PrintCovMatrix(ostream& os) const; print error matrix and correlations. bool IsParameterBound(unsigned int ipar) const; query if a parameter is bound. bool IsParameterFixed(unsign",MatchSource.WIKI,root/html534/ROOT__Fit__FitResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitResult.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:837,Availability,error,errors,837,". ROOT::Fit::Fitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::Fitter. class ROOT::Fit::Fitter. Fitter class, entry point for performing all type of fits.; Fits are performed using the generic ROOT::Fit::Fitter::Fit method.; The inputs are the data points and a model function (using a ROOT::Math::IParamFunction); The result of the fit is returned and kept internally in the ROOT::Fit::FitResult class.; The configuration of the fit (parameters, options, etc...) are specified in the; ROOT::Math::FitConfig class.; After fitting the config of the fit will be modified to have the new values the resulting; parameter of the fit with step sizes equal to the errors. FitConfig can be preserved with; initial parameters by calling FitConfig.SetUpdateAfterFit(false);. @ingroup FitMain. Function Members (Methods); public:. ~Fitter(); boolApplyWeightCorrection(const ROOT::Math::IMultiGenFunction& loglw2, bool minimizeW2L = false); boolCalculateHessErrors(); boolCalculateMinosErrors(); const ROOT::Fit::FitConfig&Config() const; ROOT::Fit::FitConfig&Config(); boolEvalFCN(); boolFit(const ROOT::Fit::BinData& data); boolFit(const ROOT::Fit::UnBinData& data, bool extended = false); boolFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func); boolFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func); boolFitFCN(); boolFitFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params =",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:11711,Availability,error,error,11711,"ented by a multi-dimensional gradient function interface; (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; See also note above for the initial parameters for FitFCN. bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). bool EvalFCN(). Perform a simple FCN evaluation. FitResult will be modified and contain the value of the FCN. bool LinearFit(const ROOT::Fit::BinData& data). do a linear fit on a set of bin-data. { return DoLinearFit(data); }. void SetFunction(const IModelFunction & func, bool useGradient = false). Set the fitted function (model function) from a parametric function interface. void SetFunction(const IModel1DFunction & func, bool useGradient = false). Set the fitted function from a parametric 1D function interface. bool CalculateHessErrors(). perform an error analysis on the result using the Hessian; Errors are obtaied from the inverse of the Hessian matrix; To be called only after fitting and when a minimizer supporting the Hessian calculations is used; otherwise an error (false) is returned.; A new FitResult with the Hessian result will be produced. bool CalculateMinosErrors(). perform an error analysis on the result using MINOS; To be called only after fitting and when a minimizer supporting MINOS is used; otherwise an error (false) is returned.; The result will be appended in the fit result class; Optionally a vector of parameter indeces can be passed for selecting; the parameters to analyse using FitConfig::SetMinosErrors. bool IsBinFit() const. query if fit is binned. In cse of false teh fit can be unbinned; or is not defined (like in case of fitting through a ::FitFCN). { return fBinFit; }. ROOT::Math::Minimizer * GetMinimizer() const. return pointer to last used minimizer; (is NULL in case fit is not yet done); This pointer will be valid as far as the data, the objective function; and the fitter class have not been deleted.; To be used only",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:11929,Availability,error,error,11929,"ented by a multi-dimensional gradient function interface; (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; See also note above for the initial parameters for FitFCN. bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). bool EvalFCN(). Perform a simple FCN evaluation. FitResult will be modified and contain the value of the FCN. bool LinearFit(const ROOT::Fit::BinData& data). do a linear fit on a set of bin-data. { return DoLinearFit(data); }. void SetFunction(const IModelFunction & func, bool useGradient = false). Set the fitted function (model function) from a parametric function interface. void SetFunction(const IModel1DFunction & func, bool useGradient = false). Set the fitted function from a parametric 1D function interface. bool CalculateHessErrors(). perform an error analysis on the result using the Hessian; Errors are obtaied from the inverse of the Hessian matrix; To be called only after fitting and when a minimizer supporting the Hessian calculations is used; otherwise an error (false) is returned.; A new FitResult with the Hessian result will be produced. bool CalculateMinosErrors(). perform an error analysis on the result using MINOS; To be called only after fitting and when a minimizer supporting MINOS is used; otherwise an error (false) is returned.; The result will be appended in the fit result class; Optionally a vector of parameter indeces can be passed for selecting; the parameters to analyse using FitConfig::SetMinosErrors. bool IsBinFit() const. query if fit is binned. In cse of false teh fit can be unbinned; or is not defined (like in case of fitting through a ::FitFCN). { return fBinFit; }. ROOT::Math::Minimizer * GetMinimizer() const. return pointer to last used minimizer; (is NULL in case fit is not yet done); This pointer will be valid as far as the data, the objective function; and the fitter class have not been deleted.; To be used only",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:12055,Availability,error,error,12055," bool chi2fit = false). bool EvalFCN(). Perform a simple FCN evaluation. FitResult will be modified and contain the value of the FCN. bool LinearFit(const ROOT::Fit::BinData& data). do a linear fit on a set of bin-data. { return DoLinearFit(data); }. void SetFunction(const IModelFunction & func, bool useGradient = false). Set the fitted function (model function) from a parametric function interface. void SetFunction(const IModel1DFunction & func, bool useGradient = false). Set the fitted function from a parametric 1D function interface. bool CalculateHessErrors(). perform an error analysis on the result using the Hessian; Errors are obtaied from the inverse of the Hessian matrix; To be called only after fitting and when a minimizer supporting the Hessian calculations is used; otherwise an error (false) is returned.; A new FitResult with the Hessian result will be produced. bool CalculateMinosErrors(). perform an error analysis on the result using MINOS; To be called only after fitting and when a minimizer supporting MINOS is used; otherwise an error (false) is returned.; The result will be appended in the fit result class; Optionally a vector of parameter indeces can be passed for selecting; the parameters to analyse using FitConfig::SetMinosErrors. bool IsBinFit() const. query if fit is binned. In cse of false teh fit can be unbinned; or is not defined (like in case of fitting through a ::FitFCN). { return fBinFit; }. ROOT::Math::Minimizer * GetMinimizer() const. return pointer to last used minimizer; (is NULL in case fit is not yet done); This pointer will be valid as far as the data, the objective function; and the fitter class have not been deleted.; To be used only after fitting.; The pointer should not be stored and will be invalided after performing a new fitting.; In this case a new instance of ROOT::Math::Minimizer will be re-created and can be; obtained calling again GetMinimizer(). { return fMinimizer.get(); }. ROOT::Math::IMultiGenFunction * GetFCN() con",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:12189,Availability,error,error,12189," bool chi2fit = false). bool EvalFCN(). Perform a simple FCN evaluation. FitResult will be modified and contain the value of the FCN. bool LinearFit(const ROOT::Fit::BinData& data). do a linear fit on a set of bin-data. { return DoLinearFit(data); }. void SetFunction(const IModelFunction & func, bool useGradient = false). Set the fitted function (model function) from a parametric function interface. void SetFunction(const IModel1DFunction & func, bool useGradient = false). Set the fitted function from a parametric 1D function interface. bool CalculateHessErrors(). perform an error analysis on the result using the Hessian; Errors are obtaied from the inverse of the Hessian matrix; To be called only after fitting and when a minimizer supporting the Hessian calculations is used; otherwise an error (false) is returned.; A new FitResult with the Hessian result will be produced. bool CalculateMinosErrors(). perform an error analysis on the result using MINOS; To be called only after fitting and when a minimizer supporting MINOS is used; otherwise an error (false) is returned.; The result will be appended in the fit result class; Optionally a vector of parameter indeces can be passed for selecting; the parameters to analyse using FitConfig::SetMinosErrors. bool IsBinFit() const. query if fit is binned. In cse of false teh fit can be unbinned; or is not defined (like in case of fitting through a ::FitFCN). { return fBinFit; }. ROOT::Math::Minimizer * GetMinimizer() const. return pointer to last used minimizer; (is NULL in case fit is not yet done); This pointer will be valid as far as the data, the objective function; and the fitter class have not been deleted.; To be used only after fitting.; The pointer should not be stored and will be invalided after performing a new fitting.; In this case a new instance of ROOT::Math::Minimizer will be re-created and can be; obtained calling again GetMinimizer(). { return fMinimizer.get(); }. ROOT::Math::IMultiGenFunction * GetFCN() con",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:13701,Availability,error,error,13701,"e data, the objective function; and the fitter class have not been deleted.; To be used only after fitting.; The pointer should not be stored and will be invalided after performing a new fitting.; In this case a new instance of ROOT::Math::Minimizer will be re-created and can be; obtained calling again GetMinimizer(). { return fMinimizer.get(); }. ROOT::Math::IMultiGenFunction * GetFCN() const. return pointer to last used objective function; (is NULL in case fit is not yet done); This pointer will be valid as far as the data and the fitter class; have not been deleted. To be used after the fitting.; The pointer should not be stored and will be invalided after performing a new fitting.; In this case a new instance of the function pointer will be re-created and can be; obtained calling again GetFCN(). { return fObjFunction.get(); }. bool ApplyWeightCorrection(const ROOT::Math::IMultiGenFunction& loglw2, bool minimizeW2L = false). apply correction in the error matrix for the weights for likelihood fits; This method can be called only after a fit. The; passed function (loglw2) is a log-likelihood function impelemented using the; sum of weight squared; When using FitConfig.SetWeightCorrection() this correction is applied; automatically when doing a likelihood fit (binned or unbinned). bool DoLinearFit(const ROOT::Fit::BinData& data); linear least square fit. bool DoInitMinimizer(); initialize the minimizer. bool DoMinimization(const ROOT::Fit::Fitter::BaseFunc& f, const ROOT::Math::IMultiGenFunction* chifunc = 0); do minimization. bool DoMinimization(const ROOT::Math::IMultiGenFunction* chifunc = 0); do minimization after having set obj function. void DoUpdateFitConfig(); update config after fit. int GetNCallsFromFCN(); get function calls from the FCN. void DoSetFunction(const IModel1DFunction & func, bool useGrad); set 1D function. void DoSetFunction(const IModelFunction & func, bool useGrad); set generic N-d function.  Author: L. Moneta Wed Aug 30 11:05:19 2006  Copy",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:589,Deployability,configurat,configuration,589,". ROOT::Fit::Fitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::Fitter. class ROOT::Fit::Fitter. Fitter class, entry point for performing all type of fits.; Fits are performed using the generic ROOT::Fit::Fitter::Fit method.; The inputs are the data points and a model function (using a ROOT::Math::IParamFunction); The result of the fit is returned and kept internally in the ROOT::Fit::FitResult class.; The configuration of the fit (parameters, options, etc...) are specified in the; ROOT::Math::FitConfig class.; After fitting the config of the fit will be modified to have the new values the resulting; parameter of the fit with step sizes equal to the errors. FitConfig can be preserved with; initial parameters by calling FitConfig.SetUpdateAfterFit(false);. @ingroup FitMain. Function Members (Methods); public:. ~Fitter(); boolApplyWeightCorrection(const ROOT::Math::IMultiGenFunction& loglw2, bool minimizeW2L = false); boolCalculateHessErrors(); boolCalculateMinosErrors(); const ROOT::Fit::FitConfig&Config() const; ROOT::Fit::FitConfig&Config(); boolEvalFCN(); boolFit(const ROOT::Fit::BinData& data); boolFit(const ROOT::Fit::UnBinData& data, bool extended = false); boolFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func); boolFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func); boolFitFCN(); boolFitFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params =",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:5163,Deployability,configurat,configuration,5163,"kelihoodFit(const ROOT::Fit::UnBinData& data, bool extended = false); boolDoLinearFit(const ROOT::Fit::BinData& data); boolDoMinimization(const ROOT::Math::IMultiGenFunction* chifunc = 0); boolDoMinimization(const ROOT::Fit::Fitter::BaseFunc& f, const ROOT::Math::IMultiGenFunction* chifunc = 0); voidDoSetFunction(const ROOT::Fit::Fitter::IModel1DFunction& func, bool useGrad); voidDoSetFunction(const ROOT::Fit::Fitter::IModelFunction& func, bool useGrad); voidDoUpdateFitConfig(); intGetNCallsFromFCN(). private:. ROOT::Fit::FitterFitter(const ROOT::Fit::Fitter&); ROOT::Fit::Fitter&operator=(const ROOT::Fit::Fitter& rhs). Data Members; private:. boolfBinFitflag to indicate if fit is binned ; ROOT::Fit::FitConfigfConfigfitter configuration (options and parameter settings); intfDataSizesize of data sets (need for Fumili or LM fitters); intfFitTypetype of fit (0 undefined, 1 least square, 2 likelihood); ROOT::Fit::Fitter::IModelFunction*fFunccopy of the fitted function containing on output the fit result (managed by FitResult); auto_ptr<ROOT::Math::Minimizer>fMinimizer! pointer to used minimizer; auto_ptr<ROOT::Math::IMultiGenFunction>fObjFunction! pointer to used objective function; auto_ptr<ROOT::Fit::FitResult>fResult! pointer to the object containing the result of the fit; boolfUseGradientflag to indicate if using gradient or not. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). bool SetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fitter(). Default constructor. ~Fitter(). Destructor. Fitter(const ROOT::Fit::Fitter& ). Copy constructor (disabled, class is not copyable). bool Fit( const Data & data, const Function & func ). fit a data set using any generic model function; If data set is binned a least square f",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:14431,Deployability,update,update,14431," be; obtained calling again GetMinimizer(). { return fMinimizer.get(); }. ROOT::Math::IMultiGenFunction * GetFCN() const. return pointer to last used objective function; (is NULL in case fit is not yet done); This pointer will be valid as far as the data and the fitter class; have not been deleted. To be used after the fitting.; The pointer should not be stored and will be invalided after performing a new fitting.; In this case a new instance of the function pointer will be re-created and can be; obtained calling again GetFCN(). { return fObjFunction.get(); }. bool ApplyWeightCorrection(const ROOT::Math::IMultiGenFunction& loglw2, bool minimizeW2L = false). apply correction in the error matrix for the weights for likelihood fits; This method can be called only after a fit. The; passed function (loglw2) is a log-likelihood function impelemented using the; sum of weight squared; When using FitConfig.SetWeightCorrection() this correction is applied; automatically when doing a likelihood fit (binned or unbinned). bool DoLinearFit(const ROOT::Fit::BinData& data); linear least square fit. bool DoInitMinimizer(); initialize the minimizer. bool DoMinimization(const ROOT::Fit::Fitter::BaseFunc& f, const ROOT::Math::IMultiGenFunction* chifunc = 0); do minimization. bool DoMinimization(const ROOT::Math::IMultiGenFunction* chifunc = 0); do minimization after having set obj function. void DoUpdateFitConfig(); update config after fit. int GetNCallsFromFCN(); get function calls from the FCN. void DoSetFunction(const IModel1DFunction & func, bool useGrad); set 1D function. void DoSetFunction(const IModelFunction & func, bool useGrad); set generic N-d function.  Author: L. Moneta Wed Aug 30 11:05:19 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:6618,Integrability,interface,interface,6618,"ath::Minimizer>fMinimizer! pointer to used minimizer; auto_ptr<ROOT::Math::IMultiGenFunction>fObjFunction! pointer to used objective function; auto_ptr<ROOT::Fit::FitResult>fResult! pointer to the object containing the result of the fit; boolfUseGradientflag to indicate if using gradient or not. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). bool SetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fitter(). Default constructor. ~Fitter(). Destructor. Fitter(const ROOT::Fit::Fitter& ). Copy constructor (disabled, class is not copyable). bool Fit( const Data & data, const Function & func ). fit a data set using any generic model function; If data set is binned a least square fit is performed; If data set is unbinned a maximum likelihood fit (not extended) is done; Pre-requisite on the function:; it must implement the 1D or multidimensional parametric function interface. SetFunction(func). return Fit(const ROOT::Fit::BinData& data). bool Fit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit (default method). return DoLeastSquareFit(const ROOT::Fit::BinData& data). bool LeastSquareFit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit. bool Fit(const ROOT::Fit::UnBinData& data, bool extended = false). fit an unbinned data set using loglikelihood method. return DoLikelihoodFit(data, extended). bool LikelihoodFit(const Data & data ). Likelihood fit (unbinned or unbinned) depending on the type of data; If Binned default is extended; If Unbinned default is NOT extended (for backward compatibility). return DoLikelihoodFit(data). bool LikelihoodFit(const Data & data, bool extended ). Likelihood fit using extended or not extended method. bool LikelihoodFit( cons",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:7195,Integrability,depend,depending,7195,"opy constructor (disabled, class is not copyable). bool Fit( const Data & data, const Function & func ). fit a data set using any generic model function; If data set is binned a least square fit is performed; If data set is unbinned a maximum likelihood fit (not extended) is done; Pre-requisite on the function:; it must implement the 1D or multidimensional parametric function interface. SetFunction(func). return Fit(const ROOT::Fit::BinData& data). bool Fit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit (default method). return DoLeastSquareFit(const ROOT::Fit::BinData& data). bool LeastSquareFit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit. bool Fit(const ROOT::Fit::UnBinData& data, bool extended = false). fit an unbinned data set using loglikelihood method. return DoLikelihoodFit(data, extended). bool LikelihoodFit(const Data & data ). Likelihood fit (unbinned or unbinned) depending on the type of data; If Binned default is extended; If Unbinned default is NOT extended (for backward compatibility). return DoLikelihoodFit(data). bool LikelihoodFit(const Data & data, bool extended ). Likelihood fit using extended or not extended method. bool LikelihoodFit( const Data & data, const Function & func, bool extended). fit a data set using any generic model function; Pre-requisite on the function:. SetFunction(func). bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using the a generic FCN function as a C++ callable object implementing; double () (const double *); Note that the function dimension (i.e. the number of parameter) is needed in this case; For the options see documentation for following methods FitFCN(IMultiGenFunction & fcn,..). bool SetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Set a generic FCN function as a C++ cal",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:8681,Integrability,interface,interface,8681,"Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using the a generic FCN function as a C++ callable object implementing; double () (const double *); Note that the function dimension (i.e. the number of parameter) is needed in this case; For the options see documentation for following methods FitFCN(IMultiGenFunction & fcn,..). bool SetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Set a generic FCN function as a C++ callable object implementing; double () (const double *); Note that the function dimension (i.e. the number of parameter) is needed in this case; For the options see documentation for following methods FitFCN(IMultiGenFunction & fcn,..). bool FitFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using the given FCN function represented by a multi-dimensional function interface; (ROOT::Math::IMultiGenFunction).; Give optionally the initial arameter values, data size to have the fit Ndf correctly; set in the FitResult and flag specifying if it is a chi2 fit.; Note that if the parameters values are not given (params=0) the; current parameter settings are used. The parameter settings can be created before; by using the FitConfig::SetParamsSetting. If they have not been created they are created; automatically when the params pointer is not zero.; Note that passing a params != 0 will set the parameter settings to the new value AND also the; step sizes to some pre-defined value (stepsize = 0.3 * abs(parameter_value) ). bool SetFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using a FitMethodFunction interface. Same as method above, but now extra information; can be taken from the function class. Set the FCN function represented by a multi-dimensional function in",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:9499,Integrability,interface,interface,9499,"nst ROOT::Math::IMultiGenFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using the given FCN function represented by a multi-dimensional function interface; (ROOT::Math::IMultiGenFunction).; Give optionally the initial arameter values, data size to have the fit Ndf correctly; set in the FitResult and flag specifying if it is a chi2 fit.; Note that if the parameters values are not given (params=0) the; current parameter settings are used. The parameter settings can be created before; by using the FitConfig::SetParamsSetting. If they have not been created they are created; automatically when the params pointer is not zero.; Note that passing a params != 0 will set the parameter settings to the new value AND also the; step sizes to some pre-defined value (stepsize = 0.3 * abs(parameter_value) ). bool SetFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using a FitMethodFunction interface. Same as method above, but now extra information; can be taken from the function class. Set the FCN function represented by a multi-dimensional function interface; (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; See also note above for the initial parameters for FitFCN. bool SetFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0). Set the objective function (FCN) using a FitMethodFunction interface.; Same as method above, but now extra information can be taken from the function class. bool FitFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using the given FCN function representing a multi-dimensional gradient function; interface (ROOT::Math::IMultiGradFunction). In this case the minimizer will use the; gradient information provided by the function.; For the options same consideration as in the previous method. bool FitFCN(const ROOT::Math::FitMeth",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:9662,Integrability,interface,interface,9662,"Math::IMultiGenFunction).; Give optionally the initial arameter values, data size to have the fit Ndf correctly; set in the FitResult and flag specifying if it is a chi2 fit.; Note that if the parameters values are not given (params=0) the; current parameter settings are used. The parameter settings can be created before; by using the FitConfig::SetParamsSetting. If they have not been created they are created; automatically when the params pointer is not zero.; Note that passing a params != 0 will set the parameter settings to the new value AND also the; step sizes to some pre-defined value (stepsize = 0.3 * abs(parameter_value) ). bool SetFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using a FitMethodFunction interface. Same as method above, but now extra information; can be taken from the function class. Set the FCN function represented by a multi-dimensional function interface; (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; See also note above for the initial parameters for FitFCN. bool SetFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0). Set the objective function (FCN) using a FitMethodFunction interface.; Same as method above, but now extra information can be taken from the function class. bool FitFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using the given FCN function representing a multi-dimensional gradient function; interface (ROOT::Math::IMultiGradFunction). In this case the minimizer will use the; gradient information provided by the function.; For the options same consideration as in the previous method. bool FitFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0). Fit using a FitMethodGradFunction interface. Same as method above, but now extra information; can be taken from the function class. bool SetFCN(const ROOT::Math::",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:9943,Integrability,interface,interface,9943,"given (params=0) the; current parameter settings are used. The parameter settings can be created before; by using the FitConfig::SetParamsSetting. If they have not been created they are created; automatically when the params pointer is not zero.; Note that passing a params != 0 will set the parameter settings to the new value AND also the; step sizes to some pre-defined value (stepsize = 0.3 * abs(parameter_value) ). bool SetFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using a FitMethodFunction interface. Same as method above, but now extra information; can be taken from the function class. Set the FCN function represented by a multi-dimensional function interface; (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; See also note above for the initial parameters for FitFCN. bool SetFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0). Set the objective function (FCN) using a FitMethodFunction interface.; Same as method above, but now extra information can be taken from the function class. bool FitFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using the given FCN function representing a multi-dimensional gradient function; interface (ROOT::Math::IMultiGradFunction). In this case the minimizer will use the; gradient information provided by the function.; For the options same consideration as in the previous method. bool FitFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0). Fit using a FitMethodGradFunction interface. Same as method above, but now extra information; can be taken from the function class. bool SetFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Set the FCN function represented by a multi-dimensional gradient function interface; (ROOT::Math::IMultiGenFunction) a",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:10257,Integrability,interface,interface,10257," new value AND also the; step sizes to some pre-defined value (stepsize = 0.3 * abs(parameter_value) ). bool SetFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using a FitMethodFunction interface. Same as method above, but now extra information; can be taken from the function class. Set the FCN function represented by a multi-dimensional function interface; (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; See also note above for the initial parameters for FitFCN. bool SetFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0). Set the objective function (FCN) using a FitMethodFunction interface.; Same as method above, but now extra information can be taken from the function class. bool FitFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using the given FCN function representing a multi-dimensional gradient function; interface (ROOT::Math::IMultiGradFunction). In this case the minimizer will use the; gradient information provided by the function.; For the options same consideration as in the previous method. bool FitFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0). Fit using a FitMethodGradFunction interface. Same as method above, but now extra information; can be taken from the function class. bool SetFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Set the FCN function represented by a multi-dimensional gradient function interface; (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; See also note above for the initial parameters for FitFCN. bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). bool EvalFCN(). Perform a simple FCN evaluation. FitResult will be modified and con",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:10571,Integrability,interface,interface,10571," can be taken from the function class. Set the FCN function represented by a multi-dimensional function interface; (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; See also note above for the initial parameters for FitFCN. bool SetFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0). Set the objective function (FCN) using a FitMethodFunction interface.; Same as method above, but now extra information can be taken from the function class. bool FitFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using the given FCN function representing a multi-dimensional gradient function; interface (ROOT::Math::IMultiGradFunction). In this case the minimizer will use the; gradient information provided by the function.; For the options same consideration as in the previous method. bool FitFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0). Fit using a FitMethodGradFunction interface. Same as method above, but now extra information; can be taken from the function class. bool SetFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Set the FCN function represented by a multi-dimensional gradient function interface; (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; See also note above for the initial parameters for FitFCN. bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). bool EvalFCN(). Perform a simple FCN evaluation. FitResult will be modified and contain the value of the FCN. bool LinearFit(const ROOT::Fit::BinData& data). do a linear fit on a set of bin-data. { return DoLinearFit(data); }. void SetFunction(const IModelFunction & func, bool useGradient = false). Set the fitted function (model function) from a parametric function interface. void SetFunction(const IMod",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:10874,Integrability,interface,interface,10874,"tion (FCN) using a FitMethodFunction interface.; Same as method above, but now extra information can be taken from the function class. bool FitFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using the given FCN function representing a multi-dimensional gradient function; interface (ROOT::Math::IMultiGradFunction). In this case the minimizer will use the; gradient information provided by the function.; For the options same consideration as in the previous method. bool FitFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0). Fit using a FitMethodGradFunction interface. Same as method above, but now extra information; can be taken from the function class. bool SetFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Set the FCN function represented by a multi-dimensional gradient function interface; (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; See also note above for the initial parameters for FitFCN. bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). bool EvalFCN(). Perform a simple FCN evaluation. FitResult will be modified and contain the value of the FCN. bool LinearFit(const ROOT::Fit::BinData& data). do a linear fit on a set of bin-data. { return DoLinearFit(data); }. void SetFunction(const IModelFunction & func, bool useGradient = false). Set the fitted function (model function) from a parametric function interface. void SetFunction(const IModel1DFunction & func, bool useGradient = false). Set the fitted function from a parametric 1D function interface. bool CalculateHessErrors(). perform an error analysis on the result using the Hessian; Errors are obtaied from the inverse of the Hessian matrix; To be called only after fitting and when a minimizer supporting the Hessian calculations ",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:11521,Integrability,interface,interface,11521,"GradFunction& fcn, const double* params = 0). Fit using a FitMethodGradFunction interface. Same as method above, but now extra information; can be taken from the function class. bool SetFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Set the FCN function represented by a multi-dimensional gradient function interface; (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; See also note above for the initial parameters for FitFCN. bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). bool EvalFCN(). Perform a simple FCN evaluation. FitResult will be modified and contain the value of the FCN. bool LinearFit(const ROOT::Fit::BinData& data). do a linear fit on a set of bin-data. { return DoLinearFit(data); }. void SetFunction(const IModelFunction & func, bool useGradient = false). Set the fitted function (model function) from a parametric function interface. void SetFunction(const IModel1DFunction & func, bool useGradient = false). Set the fitted function from a parametric 1D function interface. bool CalculateHessErrors(). perform an error analysis on the result using the Hessian; Errors are obtaied from the inverse of the Hessian matrix; To be called only after fitting and when a minimizer supporting the Hessian calculations is used; otherwise an error (false) is returned.; A new FitResult with the Hessian result will be produced. bool CalculateMinosErrors(). perform an error analysis on the result using MINOS; To be called only after fitting and when a minimizer supporting MINOS is used; otherwise an error (false) is returned.; The result will be appended in the fit result class; Optionally a vector of parameter indeces can be passed for selecting; the parameters to analyse using FitConfig::SetMinosErrors. bool IsBinFit() const. query if fit is binned. In cse of false teh fit can be unbinned; or is",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:11661,Integrability,interface,interface,11661,"taken from the function class. bool SetFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Set the FCN function represented by a multi-dimensional gradient function interface; (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; See also note above for the initial parameters for FitFCN. bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). bool EvalFCN(). Perform a simple FCN evaluation. FitResult will be modified and contain the value of the FCN. bool LinearFit(const ROOT::Fit::BinData& data). do a linear fit on a set of bin-data. { return DoLinearFit(data); }. void SetFunction(const IModelFunction & func, bool useGradient = false). Set the fitted function (model function) from a parametric function interface. void SetFunction(const IModel1DFunction & func, bool useGradient = false). Set the fitted function from a parametric 1D function interface. bool CalculateHessErrors(). perform an error analysis on the result using the Hessian; Errors are obtaied from the inverse of the Hessian matrix; To be called only after fitting and when a minimizer supporting the Hessian calculations is used; otherwise an error (false) is returned.; A new FitResult with the Hessian result will be produced. bool CalculateMinosErrors(). perform an error analysis on the result using MINOS; To be called only after fitting and when a minimizer supporting MINOS is used; otherwise an error (false) is returned.; The result will be appended in the fit result class; Optionally a vector of parameter indeces can be passed for selecting; the parameters to analyse using FitConfig::SetMinosErrors. bool IsBinFit() const. query if fit is binned. In cse of false teh fit can be unbinned; or is not defined (like in case of fitting through a ::FitFCN). { return fBinFit; }. ROOT::Math::Minimizer * GetMinimizer() const. return pointer to las",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:589,Modifiability,config,configuration,589,". ROOT::Fit::Fitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::Fitter. class ROOT::Fit::Fitter. Fitter class, entry point for performing all type of fits.; Fits are performed using the generic ROOT::Fit::Fitter::Fit method.; The inputs are the data points and a model function (using a ROOT::Math::IParamFunction); The result of the fit is returned and kept internally in the ROOT::Fit::FitResult class.; The configuration of the fit (parameters, options, etc...) are specified in the; ROOT::Math::FitConfig class.; After fitting the config of the fit will be modified to have the new values the resulting; parameter of the fit with step sizes equal to the errors. FitConfig can be preserved with; initial parameters by calling FitConfig.SetUpdateAfterFit(false);. @ingroup FitMain. Function Members (Methods); public:. ~Fitter(); boolApplyWeightCorrection(const ROOT::Math::IMultiGenFunction& loglw2, bool minimizeW2L = false); boolCalculateHessErrors(); boolCalculateMinosErrors(); const ROOT::Fit::FitConfig&Config() const; ROOT::Fit::FitConfig&Config(); boolEvalFCN(); boolFit(const ROOT::Fit::BinData& data); boolFit(const ROOT::Fit::UnBinData& data, bool extended = false); boolFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func); boolFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func); boolFitFCN(); boolFitFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params =",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:714,Modifiability,config,config,714,". ROOT::Fit::Fitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::Fitter. class ROOT::Fit::Fitter. Fitter class, entry point for performing all type of fits.; Fits are performed using the generic ROOT::Fit::Fitter::Fit method.; The inputs are the data points and a model function (using a ROOT::Math::IParamFunction); The result of the fit is returned and kept internally in the ROOT::Fit::FitResult class.; The configuration of the fit (parameters, options, etc...) are specified in the; ROOT::Math::FitConfig class.; After fitting the config of the fit will be modified to have the new values the resulting; parameter of the fit with step sizes equal to the errors. FitConfig can be preserved with; initial parameters by calling FitConfig.SetUpdateAfterFit(false);. @ingroup FitMain. Function Members (Methods); public:. ~Fitter(); boolApplyWeightCorrection(const ROOT::Math::IMultiGenFunction& loglw2, bool minimizeW2L = false); boolCalculateHessErrors(); boolCalculateMinosErrors(); const ROOT::Fit::FitConfig&Config() const; ROOT::Fit::FitConfig&Config(); boolEvalFCN(); boolFit(const ROOT::Fit::BinData& data); boolFit(const ROOT::Fit::UnBinData& data, bool extended = false); boolFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func); boolFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func); boolFitFCN(); boolFitFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params =",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:1341,Modifiability,extend,extended,1341," ~Fitter(); boolApplyWeightCorrection(const ROOT::Math::IMultiGenFunction& loglw2, bool minimizeW2L = false); boolCalculateHessErrors(); boolCalculateMinosErrors(); const ROOT::Fit::FitConfig&Config() const; ROOT::Fit::FitConfig&Config(); boolEvalFCN(); boolFit(const ROOT::Fit::BinData& data); boolFit(const ROOT::Fit::UnBinData& data, bool extended = false); boolFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func); boolFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func); boolFitFCN(); boolFitFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params =",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:2672,Modifiability,extend,extended,2672,"inData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func); boolFitFCN(); boolFitFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolFitFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolFitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); ROOT::Fit::FitterFitter(); ROOT::Math::IMultiGenFunction*GetFCN() const; ROOT::Math::Minimizer*GetMinimizer() const; boolIsBinFit() const; boolLeastSquareFit(const ROOT::Fit::BinData& data); boolLikelihoodFit(const ROOT::Fit::BinData& data); boolLikelihoodFit(const ROOT::Fit::UnBinData& data); boolLikelihoodFit(const ROOT::Fit::BinData& data, bool extended); boolLikelihoodFit(const ROOT::Fit::UnBinData& data, bool extended); boolLikelihoodFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricFunctionMultiDim& func, bool extended); boolLikelihoodFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricFunctionMultiDim& func, bool extended); boolLikelihoodFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func, bool extended); boolLikelihoodFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func, bool extended); boolLinearFit(const ROOT::Fit::BinData& data); const ROOT::Fit::FitResult&Result() const; boolSetFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0); boolSetFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0); boolSetFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolSetFCN(const ROOT::Math::IMultiGradFunction& fcn, c",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:2740,Modifiability,extend,extended,2740,"c); boolFitFCN(); boolFitFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolFitFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolFitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); ROOT::Fit::FitterFitter(); ROOT::Math::IMultiGenFunction*GetFCN() const; ROOT::Math::Minimizer*GetMinimizer() const; boolIsBinFit() const; boolLeastSquareFit(const ROOT::Fit::BinData& data); boolLikelihoodFit(const ROOT::Fit::BinData& data); boolLikelihoodFit(const ROOT::Fit::UnBinData& data); boolLikelihoodFit(const ROOT::Fit::BinData& data, bool extended); boolLikelihoodFit(const ROOT::Fit::UnBinData& data, bool extended); boolLikelihoodFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricFunctionMultiDim& func, bool extended); boolLikelihoodFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricFunctionMultiDim& func, bool extended); boolLikelihoodFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func, bool extended); boolLikelihoodFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func, bool extended); boolLinearFit(const ROOT::Fit::BinData& data); const ROOT::Fit::FitResult&Result() const; boolSetFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0); boolSetFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0); boolSetFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolSetFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = f",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:2859,Modifiability,extend,extended,2859,"::Math::FitMethodGradFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolFitFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolFitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); ROOT::Fit::FitterFitter(); ROOT::Math::IMultiGenFunction*GetFCN() const; ROOT::Math::Minimizer*GetMinimizer() const; boolIsBinFit() const; boolLeastSquareFit(const ROOT::Fit::BinData& data); boolLikelihoodFit(const ROOT::Fit::BinData& data); boolLikelihoodFit(const ROOT::Fit::UnBinData& data); boolLikelihoodFit(const ROOT::Fit::BinData& data, bool extended); boolLikelihoodFit(const ROOT::Fit::UnBinData& data, bool extended); boolLikelihoodFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricFunctionMultiDim& func, bool extended); boolLikelihoodFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricFunctionMultiDim& func, bool extended); boolLikelihoodFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func, bool extended); boolLikelihoodFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func, bool extended); boolLinearFit(const ROOT::Fit::BinData& data); const ROOT::Fit::FitResult&Result() const; boolSetFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0); boolSetFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0); boolSetFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolSetFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolSetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:2980,Modifiability,extend,extended,2980," double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolFitFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolFitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); ROOT::Fit::FitterFitter(); ROOT::Math::IMultiGenFunction*GetFCN() const; ROOT::Math::Minimizer*GetMinimizer() const; boolIsBinFit() const; boolLeastSquareFit(const ROOT::Fit::BinData& data); boolLikelihoodFit(const ROOT::Fit::BinData& data); boolLikelihoodFit(const ROOT::Fit::UnBinData& data); boolLikelihoodFit(const ROOT::Fit::BinData& data, bool extended); boolLikelihoodFit(const ROOT::Fit::UnBinData& data, bool extended); boolLikelihoodFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricFunctionMultiDim& func, bool extended); boolLikelihoodFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricFunctionMultiDim& func, bool extended); boolLikelihoodFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func, bool extended); boolLikelihoodFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func, bool extended); boolLinearFit(const ROOT::Fit::BinData& data); const ROOT::Fit::FitResult&Result() const; boolSetFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0); boolSetFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0); boolSetFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolSetFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolSetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); voidSetFunction(const ROOT::Fit::Fitter::IModelFunction& func, bool useGradient = false); voidSe",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:3103,Modifiability,extend,extended,3103,", const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolFitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); ROOT::Fit::FitterFitter(); ROOT::Math::IMultiGenFunction*GetFCN() const; ROOT::Math::Minimizer*GetMinimizer() const; boolIsBinFit() const; boolLeastSquareFit(const ROOT::Fit::BinData& data); boolLikelihoodFit(const ROOT::Fit::BinData& data); boolLikelihoodFit(const ROOT::Fit::UnBinData& data); boolLikelihoodFit(const ROOT::Fit::BinData& data, bool extended); boolLikelihoodFit(const ROOT::Fit::UnBinData& data, bool extended); boolLikelihoodFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricFunctionMultiDim& func, bool extended); boolLikelihoodFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricFunctionMultiDim& func, bool extended); boolLikelihoodFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func, bool extended); boolLikelihoodFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func, bool extended); boolLinearFit(const ROOT::Fit::BinData& data); const ROOT::Fit::FitResult&Result() const; boolSetFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0); boolSetFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0); boolSetFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolSetFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolSetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); voidSetFunction(const ROOT::Fit::Fitter::IModelFunction& func, bool useGradient = false); voidSetFunction(const ROOT::Fit::Fitter::IModel1DFunction& func, bool useGradient = false); voidSetFunction(const ROOT::Fit::Fitt",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:3228,Modifiability,extend,extended,3228,"int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); ROOT::Fit::FitterFitter(); ROOT::Math::IMultiGenFunction*GetFCN() const; ROOT::Math::Minimizer*GetMinimizer() const; boolIsBinFit() const; boolLeastSquareFit(const ROOT::Fit::BinData& data); boolLikelihoodFit(const ROOT::Fit::BinData& data); boolLikelihoodFit(const ROOT::Fit::UnBinData& data); boolLikelihoodFit(const ROOT::Fit::BinData& data, bool extended); boolLikelihoodFit(const ROOT::Fit::UnBinData& data, bool extended); boolLikelihoodFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricFunctionMultiDim& func, bool extended); boolLikelihoodFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricFunctionMultiDim& func, bool extended); boolLikelihoodFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func, bool extended); boolLikelihoodFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func, bool extended); boolLinearFit(const ROOT::Fit::BinData& data); const ROOT::Fit::FitResult&Result() const; boolSetFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0); boolSetFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0); boolSetFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolSetFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolSetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); voidSetFunction(const ROOT::Fit::Fitter::IModelFunction& func, bool useGradient = false); voidSetFunction(const ROOT::Fit::Fitter::IModel1DFunction& func, bool useGradient = false); voidSetFunction(const ROOT::Fit::Fitter::IGradModelFunction& func, bool useGradient = true); voidSetFunction(const ROOT::Fit::Fitter::IGradModel1DFunction& func, ",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:4405,Modifiability,extend,extended,4405," chi2fit = false); boolSetFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolSetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); voidSetFunction(const ROOT::Fit::Fitter::IModelFunction& func, bool useGradient = false); voidSetFunction(const ROOT::Fit::Fitter::IModel1DFunction& func, bool useGradient = false); voidSetFunction(const ROOT::Fit::Fitter::IGradModelFunction& func, bool useGradient = true); voidSetFunction(const ROOT::Fit::Fitter::IGradModel1DFunction& func, bool useGradient = true). protected:. boolDoInitMinimizer(); boolDoLeastSquareFit(const ROOT::Fit::BinData& data); boolDoLikelihoodFit(const ROOT::Fit::BinData& data, bool extended = true); boolDoLikelihoodFit(const ROOT::Fit::UnBinData& data, bool extended = false); boolDoLinearFit(const ROOT::Fit::BinData& data); boolDoMinimization(const ROOT::Math::IMultiGenFunction* chifunc = 0); boolDoMinimization(const ROOT::Fit::Fitter::BaseFunc& f, const ROOT::Math::IMultiGenFunction* chifunc = 0); voidDoSetFunction(const ROOT::Fit::Fitter::IModel1DFunction& func, bool useGrad); voidDoSetFunction(const ROOT::Fit::Fitter::IModelFunction& func, bool useGrad); voidDoUpdateFitConfig(); intGetNCallsFromFCN(). private:. ROOT::Fit::FitterFitter(const ROOT::Fit::Fitter&); ROOT::Fit::Fitter&operator=(const ROOT::Fit::Fitter& rhs). Data Members; private:. boolfBinFitflag to indicate if fit is binned ; ROOT::Fit::FitConfigfConfigfitter configuration (options and parameter settings); intfDataSizesize of data sets (need for Fumili or LM fitters); intfFitTypetype of fit (0 undefined, 1 least square, 2 likelihood); ROOT::Fit::Fitter::IModelFunction*fFunccopy of the fitted function containing on output the fit result (managed by FitResult); auto_ptr<ROOT::Math::Minimizer>fMinimizer! pointer to used minimizer; auto_ptr<ROOT::Math::IMultiGenFunction>fObjFunction! pointer to u",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:4482,Modifiability,extend,extended,4482," chi2fit = false); boolSetFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); boolSetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false); voidSetFunction(const ROOT::Fit::Fitter::IModelFunction& func, bool useGradient = false); voidSetFunction(const ROOT::Fit::Fitter::IModel1DFunction& func, bool useGradient = false); voidSetFunction(const ROOT::Fit::Fitter::IGradModelFunction& func, bool useGradient = true); voidSetFunction(const ROOT::Fit::Fitter::IGradModel1DFunction& func, bool useGradient = true). protected:. boolDoInitMinimizer(); boolDoLeastSquareFit(const ROOT::Fit::BinData& data); boolDoLikelihoodFit(const ROOT::Fit::BinData& data, bool extended = true); boolDoLikelihoodFit(const ROOT::Fit::UnBinData& data, bool extended = false); boolDoLinearFit(const ROOT::Fit::BinData& data); boolDoMinimization(const ROOT::Math::IMultiGenFunction* chifunc = 0); boolDoMinimization(const ROOT::Fit::Fitter::BaseFunc& f, const ROOT::Math::IMultiGenFunction* chifunc = 0); voidDoSetFunction(const ROOT::Fit::Fitter::IModel1DFunction& func, bool useGrad); voidDoSetFunction(const ROOT::Fit::Fitter::IModelFunction& func, bool useGrad); voidDoUpdateFitConfig(); intGetNCallsFromFCN(). private:. ROOT::Fit::FitterFitter(const ROOT::Fit::Fitter&); ROOT::Fit::Fitter&operator=(const ROOT::Fit::Fitter& rhs). Data Members; private:. boolfBinFitflag to indicate if fit is binned ; ROOT::Fit::FitConfigfConfigfitter configuration (options and parameter settings); intfDataSizesize of data sets (need for Fumili or LM fitters); intfFitTypetype of fit (0 undefined, 1 least square, 2 likelihood); ROOT::Fit::Fitter::IModelFunction*fFunccopy of the fitted function containing on output the fit result (managed by FitResult); auto_ptr<ROOT::Math::Minimizer>fMinimizer! pointer to used minimizer; auto_ptr<ROOT::Math::IMultiGenFunction>fObjFunction! pointer to u",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:5163,Modifiability,config,configuration,5163,"kelihoodFit(const ROOT::Fit::UnBinData& data, bool extended = false); boolDoLinearFit(const ROOT::Fit::BinData& data); boolDoMinimization(const ROOT::Math::IMultiGenFunction* chifunc = 0); boolDoMinimization(const ROOT::Fit::Fitter::BaseFunc& f, const ROOT::Math::IMultiGenFunction* chifunc = 0); voidDoSetFunction(const ROOT::Fit::Fitter::IModel1DFunction& func, bool useGrad); voidDoSetFunction(const ROOT::Fit::Fitter::IModelFunction& func, bool useGrad); voidDoUpdateFitConfig(); intGetNCallsFromFCN(). private:. ROOT::Fit::FitterFitter(const ROOT::Fit::Fitter&); ROOT::Fit::Fitter&operator=(const ROOT::Fit::Fitter& rhs). Data Members; private:. boolfBinFitflag to indicate if fit is binned ; ROOT::Fit::FitConfigfConfigfitter configuration (options and parameter settings); intfDataSizesize of data sets (need for Fumili or LM fitters); intfFitTypetype of fit (0 undefined, 1 least square, 2 likelihood); ROOT::Fit::Fitter::IModelFunction*fFunccopy of the fitted function containing on output the fit result (managed by FitResult); auto_ptr<ROOT::Math::Minimizer>fMinimizer! pointer to used minimizer; auto_ptr<ROOT::Math::IMultiGenFunction>fObjFunction! pointer to used objective function; auto_ptr<ROOT::Fit::FitResult>fResult! pointer to the object containing the result of the fit; boolfUseGradientflag to indicate if using gradient or not. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). bool SetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fitter(). Default constructor. ~Fitter(). Destructor. Fitter(const ROOT::Fit::Fitter& ). Copy constructor (disabled, class is not copyable). bool Fit( const Data & data, const Function & func ). fit a data set using any generic model function; If data set is binned a least square f",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:6502,Modifiability,extend,extended,6502,"ath::Minimizer>fMinimizer! pointer to used minimizer; auto_ptr<ROOT::Math::IMultiGenFunction>fObjFunction! pointer to used objective function; auto_ptr<ROOT::Fit::FitResult>fResult! pointer to the object containing the result of the fit; boolfUseGradientflag to indicate if using gradient or not. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). bool SetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fitter(). Default constructor. ~Fitter(). Destructor. Fitter(const ROOT::Fit::Fitter& ). Copy constructor (disabled, class is not copyable). bool Fit( const Data & data, const Function & func ). fit a data set using any generic model function; If data set is binned a least square fit is performed; If data set is unbinned a maximum likelihood fit (not extended) is done; Pre-requisite on the function:; it must implement the 1D or multidimensional parametric function interface. SetFunction(func). return Fit(const ROOT::Fit::BinData& data). bool Fit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit (default method). return DoLeastSquareFit(const ROOT::Fit::BinData& data). bool LeastSquareFit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit. bool Fit(const ROOT::Fit::UnBinData& data, bool extended = false). fit an unbinned data set using loglikelihood method. return DoLikelihoodFit(data, extended). bool LikelihoodFit(const Data & data ). Likelihood fit (unbinned or unbinned) depending on the type of data; If Binned default is extended; If Unbinned default is NOT extended (for backward compatibility). return DoLikelihoodFit(data). bool LikelihoodFit(const Data & data, bool extended ). Likelihood fit using extended or not extended method. bool LikelihoodFit( cons",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:7005,Modifiability,extend,extended,7005,"ool chi2fit = false). bool SetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fitter(). Default constructor. ~Fitter(). Destructor. Fitter(const ROOT::Fit::Fitter& ). Copy constructor (disabled, class is not copyable). bool Fit( const Data & data, const Function & func ). fit a data set using any generic model function; If data set is binned a least square fit is performed; If data set is unbinned a maximum likelihood fit (not extended) is done; Pre-requisite on the function:; it must implement the 1D or multidimensional parametric function interface. SetFunction(func). return Fit(const ROOT::Fit::BinData& data). bool Fit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit (default method). return DoLeastSquareFit(const ROOT::Fit::BinData& data). bool LeastSquareFit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit. bool Fit(const ROOT::Fit::UnBinData& data, bool extended = false). fit an unbinned data set using loglikelihood method. return DoLikelihoodFit(data, extended). bool LikelihoodFit(const Data & data ). Likelihood fit (unbinned or unbinned) depending on the type of data; If Binned default is extended; If Unbinned default is NOT extended (for backward compatibility). return DoLikelihoodFit(data). bool LikelihoodFit(const Data & data, bool extended ). Likelihood fit using extended or not extended method. bool LikelihoodFit( const Data & data, const Function & func, bool extended). fit a data set using any generic model function; Pre-requisite on the function:. SetFunction(func). bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using the a generic FCN function as a C++ callable object implementing; double () (const double *); Note that the function dimension (i.e. the number of parameter) is needed in this case; For the options see ",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:7106,Modifiability,extend,extended,7106,"0, unsigned int dataSize = 0, bool chi2fit = false). Fitter(). Default constructor. ~Fitter(). Destructor. Fitter(const ROOT::Fit::Fitter& ). Copy constructor (disabled, class is not copyable). bool Fit( const Data & data, const Function & func ). fit a data set using any generic model function; If data set is binned a least square fit is performed; If data set is unbinned a maximum likelihood fit (not extended) is done; Pre-requisite on the function:; it must implement the 1D or multidimensional parametric function interface. SetFunction(func). return Fit(const ROOT::Fit::BinData& data). bool Fit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit (default method). return DoLeastSquareFit(const ROOT::Fit::BinData& data). bool LeastSquareFit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit. bool Fit(const ROOT::Fit::UnBinData& data, bool extended = false). fit an unbinned data set using loglikelihood method. return DoLikelihoodFit(data, extended). bool LikelihoodFit(const Data & data ). Likelihood fit (unbinned or unbinned) depending on the type of data; If Binned default is extended; If Unbinned default is NOT extended (for backward compatibility). return DoLikelihoodFit(data). bool LikelihoodFit(const Data & data, bool extended ). Likelihood fit using extended or not extended method. bool LikelihoodFit( const Data & data, const Function & func, bool extended). fit a data set using any generic model function; Pre-requisite on the function:. SetFunction(func). bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using the a generic FCN function as a C++ callable object implementing; double () (const double *); Note that the function dimension (i.e. the number of parameter) is needed in this case; For the options see documentation for following methods FitFCN(IMultiGenFunction & fcn,..). bool SetFCN(ROOT::Fit::Fitter::Min",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:7247,Modifiability,extend,extended,7247,"opy constructor (disabled, class is not copyable). bool Fit( const Data & data, const Function & func ). fit a data set using any generic model function; If data set is binned a least square fit is performed; If data set is unbinned a maximum likelihood fit (not extended) is done; Pre-requisite on the function:; it must implement the 1D or multidimensional parametric function interface. SetFunction(func). return Fit(const ROOT::Fit::BinData& data). bool Fit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit (default method). return DoLeastSquareFit(const ROOT::Fit::BinData& data). bool LeastSquareFit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit. bool Fit(const ROOT::Fit::UnBinData& data, bool extended = false). fit an unbinned data set using loglikelihood method. return DoLikelihoodFit(data, extended). bool LikelihoodFit(const Data & data ). Likelihood fit (unbinned or unbinned) depending on the type of data; If Binned default is extended; If Unbinned default is NOT extended (for backward compatibility). return DoLikelihoodFit(data). bool LikelihoodFit(const Data & data, bool extended ). Likelihood fit using extended or not extended method. bool LikelihoodFit( const Data & data, const Function & func, bool extended). fit a data set using any generic model function; Pre-requisite on the function:. SetFunction(func). bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using the a generic FCN function as a C++ callable object implementing; double () (const double *); Note that the function dimension (i.e. the number of parameter) is needed in this case; For the options see documentation for following methods FitFCN(IMultiGenFunction & fcn,..). bool SetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Set a generic FCN function as a C++ cal",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:7284,Modifiability,extend,extended,7284,"opy constructor (disabled, class is not copyable). bool Fit( const Data & data, const Function & func ). fit a data set using any generic model function; If data set is binned a least square fit is performed; If data set is unbinned a maximum likelihood fit (not extended) is done; Pre-requisite on the function:; it must implement the 1D or multidimensional parametric function interface. SetFunction(func). return Fit(const ROOT::Fit::BinData& data). bool Fit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit (default method). return DoLeastSquareFit(const ROOT::Fit::BinData& data). bool LeastSquareFit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit. bool Fit(const ROOT::Fit::UnBinData& data, bool extended = false). fit an unbinned data set using loglikelihood method. return DoLikelihoodFit(data, extended). bool LikelihoodFit(const Data & data ). Likelihood fit (unbinned or unbinned) depending on the type of data; If Binned default is extended; If Unbinned default is NOT extended (for backward compatibility). return DoLikelihoodFit(data). bool LikelihoodFit(const Data & data, bool extended ). Likelihood fit using extended or not extended method. bool LikelihoodFit( const Data & data, const Function & func, bool extended). fit a data set using any generic model function; Pre-requisite on the function:. SetFunction(func). bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using the a generic FCN function as a C++ callable object implementing; double () (const double *); Note that the function dimension (i.e. the number of parameter) is needed in this case; For the options see documentation for following methods FitFCN(IMultiGenFunction & fcn,..). bool SetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Set a generic FCN function as a C++ cal",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:7396,Modifiability,extend,extended,7396,"del function; If data set is binned a least square fit is performed; If data set is unbinned a maximum likelihood fit (not extended) is done; Pre-requisite on the function:; it must implement the 1D or multidimensional parametric function interface. SetFunction(func). return Fit(const ROOT::Fit::BinData& data). bool Fit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit (default method). return DoLeastSquareFit(const ROOT::Fit::BinData& data). bool LeastSquareFit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit. bool Fit(const ROOT::Fit::UnBinData& data, bool extended = false). fit an unbinned data set using loglikelihood method. return DoLikelihoodFit(data, extended). bool LikelihoodFit(const Data & data ). Likelihood fit (unbinned or unbinned) depending on the type of data; If Binned default is extended; If Unbinned default is NOT extended (for backward compatibility). return DoLikelihoodFit(data). bool LikelihoodFit(const Data & data, bool extended ). Likelihood fit using extended or not extended method. bool LikelihoodFit( const Data & data, const Function & func, bool extended). fit a data set using any generic model function; Pre-requisite on the function:. SetFunction(func). bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using the a generic FCN function as a C++ callable object implementing; double () (const double *); Note that the function dimension (i.e. the number of parameter) is needed in this case; For the options see documentation for following methods FitFCN(IMultiGenFunction & fcn,..). bool SetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Set a generic FCN function as a C++ callable object implementing; double () (const double *); Note that the function dimension (i.e. the number of parameter) is needed in this case",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:7429,Modifiability,extend,extended,7429,"is performed; If data set is unbinned a maximum likelihood fit (not extended) is done; Pre-requisite on the function:; it must implement the 1D or multidimensional parametric function interface. SetFunction(func). return Fit(const ROOT::Fit::BinData& data). bool Fit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit (default method). return DoLeastSquareFit(const ROOT::Fit::BinData& data). bool LeastSquareFit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit. bool Fit(const ROOT::Fit::UnBinData& data, bool extended = false). fit an unbinned data set using loglikelihood method. return DoLikelihoodFit(data, extended). bool LikelihoodFit(const Data & data ). Likelihood fit (unbinned or unbinned) depending on the type of data; If Binned default is extended; If Unbinned default is NOT extended (for backward compatibility). return DoLikelihoodFit(data). bool LikelihoodFit(const Data & data, bool extended ). Likelihood fit using extended or not extended method. bool LikelihoodFit( const Data & data, const Function & func, bool extended). fit a data set using any generic model function; Pre-requisite on the function:. SetFunction(func). bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using the a generic FCN function as a C++ callable object implementing; double () (const double *); Note that the function dimension (i.e. the number of parameter) is needed in this case; For the options see documentation for following methods FitFCN(IMultiGenFunction & fcn,..). bool SetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Set a generic FCN function as a C++ callable object implementing; double () (const double *); Note that the function dimension (i.e. the number of parameter) is needed in this case; For the options see documentation for following meth",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:7445,Modifiability,extend,extended,7445,"is performed; If data set is unbinned a maximum likelihood fit (not extended) is done; Pre-requisite on the function:; it must implement the 1D or multidimensional parametric function interface. SetFunction(func). return Fit(const ROOT::Fit::BinData& data). bool Fit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit (default method). return DoLeastSquareFit(const ROOT::Fit::BinData& data). bool LeastSquareFit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit. bool Fit(const ROOT::Fit::UnBinData& data, bool extended = false). fit an unbinned data set using loglikelihood method. return DoLikelihoodFit(data, extended). bool LikelihoodFit(const Data & data ). Likelihood fit (unbinned or unbinned) depending on the type of data; If Binned default is extended; If Unbinned default is NOT extended (for backward compatibility). return DoLikelihoodFit(data). bool LikelihoodFit(const Data & data, bool extended ). Likelihood fit using extended or not extended method. bool LikelihoodFit( const Data & data, const Function & func, bool extended). fit a data set using any generic model function; Pre-requisite on the function:. SetFunction(func). bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using the a generic FCN function as a C++ callable object implementing; double () (const double *); Note that the function dimension (i.e. the number of parameter) is needed in this case; For the options see documentation for following methods FitFCN(IMultiGenFunction & fcn,..). bool SetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Set a generic FCN function as a C++ callable object implementing; double () (const double *); Note that the function dimension (i.e. the number of parameter) is needed in this case; For the options see documentation for following meth",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:7529,Modifiability,extend,extended,7529,"t extended) is done; Pre-requisite on the function:; it must implement the 1D or multidimensional parametric function interface. SetFunction(func). return Fit(const ROOT::Fit::BinData& data). bool Fit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit (default method). return DoLeastSquareFit(const ROOT::Fit::BinData& data). bool LeastSquareFit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit. bool Fit(const ROOT::Fit::UnBinData& data, bool extended = false). fit an unbinned data set using loglikelihood method. return DoLikelihoodFit(data, extended). bool LikelihoodFit(const Data & data ). Likelihood fit (unbinned or unbinned) depending on the type of data; If Binned default is extended; If Unbinned default is NOT extended (for backward compatibility). return DoLikelihoodFit(data). bool LikelihoodFit(const Data & data, bool extended ). Likelihood fit using extended or not extended method. bool LikelihoodFit( const Data & data, const Function & func, bool extended). fit a data set using any generic model function; Pre-requisite on the function:. SetFunction(func). bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using the a generic FCN function as a C++ callable object implementing; double () (const double *); Note that the function dimension (i.e. the number of parameter) is needed in this case; For the options see documentation for following methods FitFCN(IMultiGenFunction & fcn,..). bool SetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Set a generic FCN function as a C++ callable object implementing; double () (const double *); Note that the function dimension (i.e. the number of parameter) is needed in this case; For the options see documentation for following methods FitFCN(IMultiGenFunction & fcn,..). bool FitFCN(const ROOT::Ma",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:14438,Modifiability,config,config,14438," be; obtained calling again GetMinimizer(). { return fMinimizer.get(); }. ROOT::Math::IMultiGenFunction * GetFCN() const. return pointer to last used objective function; (is NULL in case fit is not yet done); This pointer will be valid as far as the data and the fitter class; have not been deleted. To be used after the fitting.; The pointer should not be stored and will be invalided after performing a new fitting.; In this case a new instance of the function pointer will be re-created and can be; obtained calling again GetFCN(). { return fObjFunction.get(); }. bool ApplyWeightCorrection(const ROOT::Math::IMultiGenFunction& loglw2, bool minimizeW2L = false). apply correction in the error matrix for the weights for likelihood fits; This method can be called only after a fit. The; passed function (loglw2) is a log-likelihood function impelemented using the; sum of weight squared; When using FitConfig.SetWeightCorrection() this correction is applied; automatically when doing a likelihood fit (binned or unbinned). bool DoLinearFit(const ROOT::Fit::BinData& data); linear least square fit. bool DoInitMinimizer(); initialize the minimizer. bool DoMinimization(const ROOT::Fit::Fitter::BaseFunc& f, const ROOT::Math::IMultiGenFunction* chifunc = 0); do minimization. bool DoMinimization(const ROOT::Math::IMultiGenFunction* chifunc = 0); do minimization after having set obj function. void DoUpdateFitConfig(); update config after fit. int GetNCallsFromFCN(); get function calls from the FCN. void DoSetFunction(const IModel1DFunction & func, bool useGrad); set 1D function. void DoSetFunction(const IModelFunction & func, bool useGrad); set generic N-d function.  Author: L. Moneta Wed Aug 30 11:05:19 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:306,Performance,perform,performing,306,". ROOT::Fit::Fitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::Fitter. class ROOT::Fit::Fitter. Fitter class, entry point for performing all type of fits.; Fits are performed using the generic ROOT::Fit::Fitter::Fit method.; The inputs are the data points and a model function (using a ROOT::Math::IParamFunction); The result of the fit is returned and kept internally in the ROOT::Fit::FitResult class.; The configuration of the fit (parameters, options, etc...) are specified in the; ROOT::Math::FitConfig class.; After fitting the config of the fit will be modified to have the new values the resulting; parameter of the fit with step sizes equal to the errors. FitConfig can be preserved with; initial parameters by calling FitConfig.SetUpdateAfterFit(false);. @ingroup FitMain. Function Members (Methods); public:. ~Fitter(); boolApplyWeightCorrection(const ROOT::Math::IMultiGenFunction& loglw2, bool minimizeW2L = false); boolCalculateHessErrors(); boolCalculateMinosErrors(); const ROOT::Fit::FitConfig&Config() const; ROOT::Fit::FitConfig&Config(); boolEvalFCN(); boolFit(const ROOT::Fit::BinData& data); boolFit(const ROOT::Fit::UnBinData& data, bool extended = false); boolFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func); boolFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func); boolFitFCN(); boolFitFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params =",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:345,Performance,perform,performed,345,". ROOT::Fit::Fitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::Fitter. class ROOT::Fit::Fitter. Fitter class, entry point for performing all type of fits.; Fits are performed using the generic ROOT::Fit::Fitter::Fit method.; The inputs are the data points and a model function (using a ROOT::Math::IParamFunction); The result of the fit is returned and kept internally in the ROOT::Fit::FitResult class.; The configuration of the fit (parameters, options, etc...) are specified in the; ROOT::Math::FitConfig class.; After fitting the config of the fit will be modified to have the new values the resulting; parameter of the fit with step sizes equal to the errors. FitConfig can be preserved with; initial parameters by calling FitConfig.SetUpdateAfterFit(false);. @ingroup FitMain. Function Members (Methods); public:. ~Fitter(); boolApplyWeightCorrection(const ROOT::Math::IMultiGenFunction& loglw2, bool minimizeW2L = false); boolCalculateHessErrors(); boolCalculateMinosErrors(); const ROOT::Fit::FitConfig&Config() const; ROOT::Fit::FitConfig&Config(); boolEvalFCN(); boolFit(const ROOT::Fit::BinData& data); boolFit(const ROOT::Fit::UnBinData& data, bool extended = false); boolFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricFunctionMultiDim& func); boolFit(const ROOT::Fit::BinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func); boolFit(const ROOT::Fit::UnBinData& data, const ROOT::Math::IParametricGradFunctionMultiDim& func); boolFitFCN(); boolFitFCN(const ROOT::Math::FitMethodFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0); boolFitFCN(const ROOT::Math::IMultiGenFunction& fcn, const double* params =",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:6437,Performance,perform,performed,6437,"ath::Minimizer>fMinimizer! pointer to used minimizer; auto_ptr<ROOT::Math::IMultiGenFunction>fObjFunction! pointer to used objective function; auto_ptr<ROOT::Fit::FitResult>fResult! pointer to the object containing the result of the fit; boolfUseGradientflag to indicate if using gradient or not. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). bool SetFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fitter(). Default constructor. ~Fitter(). Destructor. Fitter(const ROOT::Fit::Fitter& ). Copy constructor (disabled, class is not copyable). bool Fit( const Data & data, const Function & func ). fit a data set using any generic model function; If data set is binned a least square fit is performed; If data set is unbinned a maximum likelihood fit (not extended) is done; Pre-requisite on the function:; it must implement the 1D or multidimensional parametric function interface. SetFunction(func). return Fit(const ROOT::Fit::BinData& data). bool Fit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit (default method). return DoLeastSquareFit(const ROOT::Fit::BinData& data). bool LeastSquareFit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit. bool Fit(const ROOT::Fit::UnBinData& data, bool extended = false). fit an unbinned data set using loglikelihood method. return DoLikelihoodFit(data, extended). bool LikelihoodFit(const Data & data ). Likelihood fit (unbinned or unbinned) depending on the type of data; If Binned default is extended; If Unbinned default is NOT extended (for backward compatibility). return DoLikelihoodFit(data). bool LikelihoodFit(const Data & data, bool extended ). Likelihood fit using extended or not extended method. bool LikelihoodFit( cons",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:11700,Performance,perform,perform,11700,"ented by a multi-dimensional gradient function interface; (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; See also note above for the initial parameters for FitFCN. bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). bool EvalFCN(). Perform a simple FCN evaluation. FitResult will be modified and contain the value of the FCN. bool LinearFit(const ROOT::Fit::BinData& data). do a linear fit on a set of bin-data. { return DoLinearFit(data); }. void SetFunction(const IModelFunction & func, bool useGradient = false). Set the fitted function (model function) from a parametric function interface. void SetFunction(const IModel1DFunction & func, bool useGradient = false). Set the fitted function from a parametric 1D function interface. bool CalculateHessErrors(). perform an error analysis on the result using the Hessian; Errors are obtaied from the inverse of the Hessian matrix; To be called only after fitting and when a minimizer supporting the Hessian calculations is used; otherwise an error (false) is returned.; A new FitResult with the Hessian result will be produced. bool CalculateMinosErrors(). perform an error analysis on the result using MINOS; To be called only after fitting and when a minimizer supporting MINOS is used; otherwise an error (false) is returned.; The result will be appended in the fit result class; Optionally a vector of parameter indeces can be passed for selecting; the parameters to analyse using FitConfig::SetMinosErrors. bool IsBinFit() const. query if fit is binned. In cse of false teh fit can be unbinned; or is not defined (like in case of fitting through a ::FitFCN). { return fBinFit; }. ROOT::Math::Minimizer * GetMinimizer() const. return pointer to last used minimizer; (is NULL in case fit is not yet done); This pointer will be valid as far as the data, the objective function; and the fitter class have not been deleted.; To be used only",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:12044,Performance,perform,perform,12044," bool chi2fit = false). bool EvalFCN(). Perform a simple FCN evaluation. FitResult will be modified and contain the value of the FCN. bool LinearFit(const ROOT::Fit::BinData& data). do a linear fit on a set of bin-data. { return DoLinearFit(data); }. void SetFunction(const IModelFunction & func, bool useGradient = false). Set the fitted function (model function) from a parametric function interface. void SetFunction(const IModel1DFunction & func, bool useGradient = false). Set the fitted function from a parametric 1D function interface. bool CalculateHessErrors(). perform an error analysis on the result using the Hessian; Errors are obtaied from the inverse of the Hessian matrix; To be called only after fitting and when a minimizer supporting the Hessian calculations is used; otherwise an error (false) is returned.; A new FitResult with the Hessian result will be produced. bool CalculateMinosErrors(). perform an error analysis on the result using MINOS; To be called only after fitting and when a minimizer supporting MINOS is used; otherwise an error (false) is returned.; The result will be appended in the fit result class; Optionally a vector of parameter indeces can be passed for selecting; the parameters to analyse using FitConfig::SetMinosErrors. bool IsBinFit() const. query if fit is binned. In cse of false teh fit can be unbinned; or is not defined (like in case of fitting through a ::FitFCN). { return fBinFit; }. ROOT::Math::Minimizer * GetMinimizer() const. return pointer to last used minimizer; (is NULL in case fit is not yet done); This pointer will be valid as far as the data, the objective function; and the fitter class have not been deleted.; To be used only after fitting.; The pointer should not be stored and will be invalided after performing a new fitting.; In this case a new instance of ROOT::Math::Minimizer will be re-created and can be; obtained calling again GetMinimizer(). { return fMinimizer.get(); }. ROOT::Math::IMultiGenFunction * GetFCN() con",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:12905,Performance,perform,performing,12905,"Hessian calculations is used; otherwise an error (false) is returned.; A new FitResult with the Hessian result will be produced. bool CalculateMinosErrors(). perform an error analysis on the result using MINOS; To be called only after fitting and when a minimizer supporting MINOS is used; otherwise an error (false) is returned.; The result will be appended in the fit result class; Optionally a vector of parameter indeces can be passed for selecting; the parameters to analyse using FitConfig::SetMinosErrors. bool IsBinFit() const. query if fit is binned. In cse of false teh fit can be unbinned; or is not defined (like in case of fitting through a ::FitFCN). { return fBinFit; }. ROOT::Math::Minimizer * GetMinimizer() const. return pointer to last used minimizer; (is NULL in case fit is not yet done); This pointer will be valid as far as the data, the objective function; and the fitter class have not been deleted.; To be used only after fitting.; The pointer should not be stored and will be invalided after performing a new fitting.; In this case a new instance of ROOT::Math::Minimizer will be re-created and can be; obtained calling again GetMinimizer(). { return fMinimizer.get(); }. ROOT::Math::IMultiGenFunction * GetFCN() const. return pointer to last used objective function; (is NULL in case fit is not yet done); This pointer will be valid as far as the data and the fitter class; have not been deleted. To be used after the fitting.; The pointer should not be stored and will be invalided after performing a new fitting.; In this case a new instance of the function pointer will be re-created and can be; obtained calling again GetFCN(). { return fObjFunction.get(); }. bool ApplyWeightCorrection(const ROOT::Math::IMultiGenFunction& loglw2, bool minimizeW2L = false). apply correction in the error matrix for the weights for likelihood fits; This method can be called only after a fit. The; passed function (loglw2) is a log-likelihood function impelemented using the; sum of w",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:13403,Performance,perform,performing,13403,"etMinosErrors. bool IsBinFit() const. query if fit is binned. In cse of false teh fit can be unbinned; or is not defined (like in case of fitting through a ::FitFCN). { return fBinFit; }. ROOT::Math::Minimizer * GetMinimizer() const. return pointer to last used minimizer; (is NULL in case fit is not yet done); This pointer will be valid as far as the data, the objective function; and the fitter class have not been deleted.; To be used only after fitting.; The pointer should not be stored and will be invalided after performing a new fitting.; In this case a new instance of ROOT::Math::Minimizer will be re-created and can be; obtained calling again GetMinimizer(). { return fMinimizer.get(); }. ROOT::Math::IMultiGenFunction * GetFCN() const. return pointer to last used objective function; (is NULL in case fit is not yet done); This pointer will be valid as far as the data and the fitter class; have not been deleted. To be used after the fitting.; The pointer should not be stored and will be invalided after performing a new fitting.; In this case a new instance of the function pointer will be re-created and can be; obtained calling again GetFCN(). { return fObjFunction.get(); }. bool ApplyWeightCorrection(const ROOT::Math::IMultiGenFunction& loglw2, bool minimizeW2L = false). apply correction in the error matrix for the weights for likelihood fits; This method can be called only after a fit. The; passed function (loglw2) is a log-likelihood function impelemented using the; sum of weight squared; When using FitConfig.SetWeightCorrection() this correction is applied; automatically when doing a likelihood fit (binned or unbinned). bool DoLinearFit(const ROOT::Fit::BinData& data); linear least square fit. bool DoInitMinimizer(); initialize the minimizer. bool DoMinimization(const ROOT::Fit::Fitter::BaseFunc& f, const ROOT::Math::IMultiGenFunction* chifunc = 0); do minimization. bool DoMinimization(const ROOT::Math::IMultiGenFunction* chifunc = 0); do minimization after havi",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:7055,Testability,log,loglikelihood,7055,"CN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fitter(). Default constructor. ~Fitter(). Destructor. Fitter(const ROOT::Fit::Fitter& ). Copy constructor (disabled, class is not copyable). bool Fit( const Data & data, const Function & func ). fit a data set using any generic model function; If data set is binned a least square fit is performed; If data set is unbinned a maximum likelihood fit (not extended) is done; Pre-requisite on the function:; it must implement the 1D or multidimensional parametric function interface. SetFunction(func). return Fit(const ROOT::Fit::BinData& data). bool Fit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit (default method). return DoLeastSquareFit(const ROOT::Fit::BinData& data). bool LeastSquareFit(const ROOT::Fit::BinData& data). Fit a binned data set using a least square fit. bool Fit(const ROOT::Fit::UnBinData& data, bool extended = false). fit an unbinned data set using loglikelihood method. return DoLikelihoodFit(data, extended). bool LikelihoodFit(const Data & data ). Likelihood fit (unbinned or unbinned) depending on the type of data; If Binned default is extended; If Unbinned default is NOT extended (for backward compatibility). return DoLikelihoodFit(data). bool LikelihoodFit(const Data & data, bool extended ). Likelihood fit using extended or not extended method. bool LikelihoodFit( const Data & data, const Function & func, bool extended). fit a data set using any generic model function; Pre-requisite on the function:. SetFunction(func). bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Fit using the a generic FCN function as a C++ callable object implementing; double () (const double *); Note that the function dimension (i.e. the number of parameter) is needed in this case; For the options see documentation for following methods FitFCN(IMultiGenFunction",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:13830,Testability,log,log-likelihood,13830,"ould not be stored and will be invalided after performing a new fitting.; In this case a new instance of ROOT::Math::Minimizer will be re-created and can be; obtained calling again GetMinimizer(). { return fMinimizer.get(); }. ROOT::Math::IMultiGenFunction * GetFCN() const. return pointer to last used objective function; (is NULL in case fit is not yet done); This pointer will be valid as far as the data and the fitter class; have not been deleted. To be used after the fitting.; The pointer should not be stored and will be invalided after performing a new fitting.; In this case a new instance of the function pointer will be re-created and can be; obtained calling again GetFCN(). { return fObjFunction.get(); }. bool ApplyWeightCorrection(const ROOT::Math::IMultiGenFunction& loglw2, bool minimizeW2L = false). apply correction in the error matrix for the weights for likelihood fits; This method can be called only after a fit. The; passed function (loglw2) is a log-likelihood function impelemented using the; sum of weight squared; When using FitConfig.SetWeightCorrection() this correction is applied; automatically when doing a likelihood fit (binned or unbinned). bool DoLinearFit(const ROOT::Fit::BinData& data); linear least square fit. bool DoInitMinimizer(); initialize the minimizer. bool DoMinimization(const ROOT::Fit::Fitter::BaseFunc& f, const ROOT::Math::IMultiGenFunction* chifunc = 0); do minimization. bool DoMinimization(const ROOT::Math::IMultiGenFunction* chifunc = 0); do minimization after having set obj function. void DoUpdateFitConfig(); update config after fit. int GetNCallsFromFCN(); get function calls from the FCN. void DoSetFunction(const IModel1DFunction & func, bool useGrad); set 1D function. void DoSetFunction(const IModelFunction & func, bool useGrad); set generic N-d function.  Author: L. Moneta Wed Aug 30 11:05:19 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; Th",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__Fitter.html:11179,Usability,simpl,simple,11179,"e given FCN function representing a multi-dimensional gradient function; interface (ROOT::Math::IMultiGradFunction). In this case the minimizer will use the; gradient information provided by the function.; For the options same consideration as in the previous method. bool FitFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0). Fit using a FitMethodGradFunction interface. Same as method above, but now extra information; can be taken from the function class. bool SetFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Set the FCN function represented by a multi-dimensional gradient function interface; (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; See also note above for the initial parameters for FitFCN. bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). bool EvalFCN(). Perform a simple FCN evaluation. FitResult will be modified and contain the value of the FCN. bool LinearFit(const ROOT::Fit::BinData& data). do a linear fit on a set of bin-data. { return DoLinearFit(data); }. void SetFunction(const IModelFunction & func, bool useGradient = false). Set the fitted function (model function) from a parametric function interface. void SetFunction(const IModel1DFunction & func, bool useGradient = false). Set the fitted function from a parametric 1D function interface. bool CalculateHessErrors(). perform an error analysis on the result using the Hessian; Errors are obtaied from the inverse of the Hessian matrix; To be called only after fitting and when a minimizer supporting the Hessian calculations is used; otherwise an error (false) is returned.; A new FitResult with the Hessian result will be produced. bool CalculateMinosErrors(). perform an error analysis on the result using MINOS; To be called only after fitting and when a minimizer supporting MINOS is used; otherwise",MatchSource.WIKI,root/html534/ROOT__Fit__Fitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__Fitter.html
https://root.cern/root/html534/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html:4017,Availability,error,errors,4017,"dFCN<ROOT::Math::IBaseFunctionMultiDim>(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&); ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&operator=(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::UnBinData&fData; const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag for indicating if likelihood is extended; unsigned intfNEffPointsnumber of effective points used in the fit ; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new LogLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); }. unsigned int NFitPoints() const; using BaseObjFunction::operator();; effective points used in the fit. { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th likelihood contribution and its gradient. void Gradient(const double* x, double* g) const; need to be virtual to be instantited. void UseSumOfWeightSquare(bool on = true); Use sum of the weight squared in evaluating the likelihood; (this is needed for calculating the errors). double DoEval(const double* x) const. Evaluation of the function (required by interface). double DoDerivative(const double* x, unsigned int icoord) const; for derivatives.  Author: L. Moneta Fri Aug 17 14:29:24 2007  Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html534/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html:4104,Integrability,interface,interface,4104,"dFCN<ROOT::Math::IBaseFunctionMultiDim>(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&); ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&operator=(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::UnBinData&fData; const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag for indicating if likelihood is extended; unsigned intfNEffPointsnumber of effective points used in the fit ; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new LogLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); }. unsigned int NFitPoints() const; using BaseObjFunction::operator();; effective points used in the fit. { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th likelihood contribution and its gradient. void Gradient(const double* x, double* g) const; need to be virtual to be instantited. void UseSumOfWeightSquare(bool on = true); Use sum of the weight squared in evaluating the likelihood; (this is needed for calculating the errors). double DoEval(const double* x) const. Evaluation of the function (required by interface). double DoDerivative(const double* x, unsigned int icoord) const; for derivatives.  Author: L. Moneta Fri Aug 17 14:29:24 2007  Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html534/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html:1409,Modifiability,extend,extended,1409,"h gradient and non-gradient case. @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Fit::LogLikelihoodFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IMultiGenFunction>. Function Members (Methods); public:. virtual~LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(); virtual ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseFunction*Clone() const; virtual const ROOT::Fit::UnBinData&Data() const; virtual doubleDataElement(const double* x, unsigned int i, double* g) const; virtual voidGradient(const double* x, double* g) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const ROOT::Fit::UnBinData& data, const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction& func, int weight = 0, bool extended = false); virtual const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&ModelFunction() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::ResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::UpdateNCalls() const; voidUseSumOfWeightSquare(bool on = true). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim",MatchSource.WIKI,root/html534/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html534/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html:3125,Modifiability,extend,extended,3125,"MethodFunction<ROOT::Math::IBaseFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::UpdateNCalls() const; voidUseSumOfWeightSquare(bool on = true). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&); ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&operator=(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::UnBinData&fData; const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag for indicating if likelihood is extended; unsigned intfNEffPointsnumber of effective points used in the fit ; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new LogLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); }. unsigned int NFitPoints() const; using BaseObjFunction::operator();; effective points used in the fit. { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th likelihood contribution and its gradient. void Gradient(const double* x, double* g) const; need to be virtual to be instantited. void UseSumOfWeightSquare(bool on = true); Use sum of the weight squared in evaluating the likelihood; (this is needed for calculating the errors). double DoEval(const double* x) const. Evaluation of the function (required by int",MatchSource.WIKI,root/html534/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__LogLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html534/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html:4309,Availability,error,errors,4309,"adientFunctionMultiDim>(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&); ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&operator=(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::UnBinData&fData; const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag for indicating if likelihood is extended; unsigned intfNEffPointsnumber of effective points used in the fit ; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new LogLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); }. unsigned int NFitPoints() const; using BaseObjFunction::operator();; effective points used in the fit. { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th likelihood contribution and its gradient. void Gradient(const double* x, double* g) const; need to be virtual to be instantited. void UseSumOfWeightSquare(bool on = true); Use sum of the weight squared in evaluating the likelihood; (this is needed for calculating the errors). double DoEval(const double* x) const. Evaluation of the function (required by interface). double DoDerivative(const double* x, unsigned int icoord) const; for derivatives.  Author: L. Moneta Fri Aug 17 14:29:24 2007  Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html534/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html:4396,Integrability,interface,interface,4396,"adientFunctionMultiDim>(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&); ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&operator=(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::UnBinData&fData; const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag for indicating if likelihood is extended; unsigned intfNEffPointsnumber of effective points used in the fit ; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new LogLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); }. unsigned int NFitPoints() const; using BaseObjFunction::operator();; effective points used in the fit. { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th likelihood contribution and its gradient. void Gradient(const double* x, double* g) const; need to be virtual to be instantited. void UseSumOfWeightSquare(bool on = true); Use sum of the weight squared in evaluating the likelihood; (this is needed for calculating the errors). double DoEval(const double* x) const. Evaluation of the function (required by interface). double DoDerivative(const double* x, unsigned int icoord) const; for derivatives.  Author: L. Moneta Fri Aug 17 14:29:24 2007  Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html534/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html:1649,Modifiability,extend,extended,1649,"ihoodGradFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IMultiGradFunction>. Function Members (Methods); public:. virtual~LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(); virtual ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseFunction*Clone() const; virtual const ROOT::Fit::UnBinData&Data() const; virtual doubleDataElement(const double* x, unsigned int i, double* g) const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidROOT::Math::IGradientFunctionMultiDim::FdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* g) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(const ROOT::Fit::UnBinData& data, const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction& func, int weight = 0, bool extended = false); virtual const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&ModelFunction() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::ResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::UpdateNCalls() const; voidUseSumOfWeightSquare(bool on = true). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double",MatchSource.WIKI,root/html534/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html534/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html:3417,Modifiability,extend,extended,3417,"adientFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::UpdateNCalls() const; voidUseSumOfWeightSquare(bool on = true). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const; ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&); ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&operator=(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::UnBinData&fData; const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag for indicating if likelihood is extended; unsigned intfNEffPointsnumber of effective points used in the fit ; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new LogLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); }. unsigned int NFitPoints() const; using BaseObjFunction::operator();; effective points used in the fit. { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th likelihood contribution and its gradient. void Gradient(const double* x, double* g) const; need to be virtual to be instantited. void UseSumOfWeightSquare(bool on = true); Use sum of the weight squared in evaluating the likelihood; (this is needed for calculating the errors). double DoEval(const double* x) const. Evaluation of the function (required by i",MatchSource.WIKI,root/html534/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html534/ROOT__Fit__ParameterSettings.html:4113,Deployability,release,release,4113,"uble err, double min, double max); constructor for double limited Parameter. SetLimits(double low, double up). ParameterSettings(const string& name, double val); constructor for fixed Parameter. {}. void Set(const string& name, double value, double step); set value and name (unlimited parameter). SetName(const string& name). SetValue(double val). SetStepSize(double err). void Set(const string& name, double value, double step, double lower, double upper); set a limited parameter. void Set(const string& name, double value); set a fixed parameter. Fix(). ~ParameterSettings(). Destructor (no operations). {}. double Value() const; copy constructor and assignment operators (leave them to the compiler); return parameter value. { return fValue; }. double StepSize() const; return step size. { return fStepSize; }. double LowerLimit() const; return lower limit value. {return fLowerLimit;}. double UpperLimit() const; return upper limit value. {return fUpperLimit;}. bool IsFixed() const; check if is fixed. { return fFix; }. bool HasLowerLimit() const; check if parameter has lower limit. {return fHasLowerLimit; }. bool HasUpperLimit() const; check if parameter has upper limit. {return fHasUpperLimit; }. bool IsBound() const; check if is bound. { return fHasLowerLimit || fHasUpperLimit; }. bool IsDoubleBound() const; check if is double bound (upper AND lower limit). { return fHasLowerLimit && fHasUpperLimit; }. const std::string & Name() const; return name. { return fName; }. void Release(); release the parameter. {fFix = false;}. RemoveLimits(). void SetUpperLimit(double up); set a single upper limit. void SetLowerLimit(double low); set a single lower limit.  Author: L. Moneta Thu Sep 21 16:21:48 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Fit__ParameterSettings.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__ParameterSettings.html
https://root.cern/root/html534/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html:4255,Availability,error,errors,4255,"tionMultiDim>PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::BinData&fData; const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag to indicate if is extended (when false is a Multinomial lieklihood), default is true; unsigned intfNEffPointsnumber of effective points used in the fit; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new PoissonLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); }. unsigned int NFitPoints() const; effective points used in the fit. { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th likelihood element and its gradient. void Gradient(const double* x, double* g) const; evaluate gradient. bool IsWeighted() const; { return (fWeight != 0); }. void UseSumOfWeights(); Use the weights in evaluating the likelihood. void UseSumOfWeightSquare(bool on = true); Use sum of the weight squared in evaluating the likelihood; (this is needed for calculating the errors). double DoEval(const double* x) const. Evaluation of the function (required by interface). double DoDerivative(const double* x, unsigned int icoord) const; for derivatives.  Author: L. Moneta Fri Aug 17 14:29:24 2007  Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html534/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html:4342,Integrability,interface,interface,4342,"tionMultiDim>PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::BinData&fData; const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag to indicate if is extended (when false is a Multinomial lieklihood), default is true; unsigned intfNEffPointsnumber of effective points used in the fit; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new PoissonLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); }. unsigned int NFitPoints() const; effective points used in the fit. { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th likelihood element and its gradient. void Gradient(const double* x, double* g) const; evaluate gradient. bool IsWeighted() const; { return (fWeight != 0); }. void UseSumOfWeights(); Use the weights in evaluating the likelihood. void UseSumOfWeightSquare(bool on = true); Use sum of the weight squared in evaluating the likelihood; (this is needed for calculating the errors). double DoEval(const double* x) const. Evaluation of the function (required by interface). double DoDerivative(const double* x, unsigned int icoord) const; for derivatives.  Author: L. Moneta Fri Aug 17 14:29:24 2007  Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html534/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html:2045,Modifiability,extend,extended,2045," @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IMultiGenFunction>, ROOT::Fit::PoissonLLFunction. Function Members (Methods); public:. virtual~PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(); virtual ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseFunction*Clone() const; virtual const ROOT::Fit::BinData&Data() const; virtual doubleDataElement(const double* x, unsigned int i, double* g) const; virtual voidGradient(const double* x, double* g) const; boolIsWeighted() const; virtual const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&ModelFunction() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const ROOT::Fit::BinData& data, const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction& func, int weight = 0, bool extended = true); virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::ResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::UpdateNCalls() const; voidUseSumOfWeights(); voidUseSumOfWeightSquare(bool on = true). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const; ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&operator=(co",MatchSource.WIKI,root/html534/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html534/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html:3239,Modifiability,extend,extended,3239,"nst; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::UpdateNCalls() const; voidUseSumOfWeights(); voidUseSumOfWeightSquare(bool on = true). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const; ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&operator=(const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&); ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::BinData&fData; const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag to indicate if is extended (when false is a Multinomial lieklihood), default is true; unsigned intfNEffPointsnumber of effective points used in the fit; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new PoissonLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); }. unsigned int NFitPoints() const; effective points used in the fit. { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th likelihood element and its gradient. void Gradient(const double* x, double* g) const; evaluate gradient. bool IsWeighted() const; { return (fWeight != 0); }. void UseSumOfWeights(); Use the weights in evaluating the likelihood. void UseSumOfWeightSquare(bool on = true); Use sum of the weight squared in evaluating the likelihood; (this is needed for calculating the ",MatchSource.WIKI,root/html534/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html534/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html:522,Testability,log,log,522,". ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>. class ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>: public ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>. class evaluating the log likelihood; for binned Poisson likelihood fits; it is template to distinguish gradient and non-gradient case. @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IMultiGenFunction>, ROOT::Fit::PoissonLLFunction. Function Members (Methods); public:. virtual~PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(); virtual ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseFunction*Clone() const; virtual const ROOT::Fit::BinData&Data() const; virtual doubleDataElement(const double* x, unsigned int i, double* g) const; virtual voidGradient(const double* x, double* g) const; boolIsWeighted() const; virtual const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction&ModelFunction() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>(const ROOT::Fit::BinData& data, const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>:",MatchSource.WIKI,root/html534/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IBaseFunctionMultiDim_.html
https://root.cern/root/html534/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html:4547,Availability,error,errors,4547,">PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::BinData&fData; const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag to indicate if is extended (when false is a Multinomial lieklihood), default is true; unsigned intfNEffPointsnumber of effective points used in the fit; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new PoissonLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); }. unsigned int NFitPoints() const; effective points used in the fit. { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th likelihood element and its gradient. void Gradient(const double* x, double* g) const; evaluate gradient. bool IsWeighted() const; { return (fWeight != 0); }. void UseSumOfWeights(); Use the weights in evaluating the likelihood. void UseSumOfWeightSquare(bool on = true); Use sum of the weight squared in evaluating the likelihood; (this is needed for calculating the errors). double DoEval(const double* x) const. Evaluation of the function (required by interface). double DoDerivative(const double* x, unsigned int icoord) const; for derivatives.  Author: L. Moneta Fri Aug 17 14:29:24 2007  Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html534/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html:4634,Integrability,interface,interface,4634,">PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::BinData&fData; const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag to indicate if is extended (when false is a Multinomial lieklihood), default is true; unsigned intfNEffPointsnumber of effective points used in the fit; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new PoissonLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); }. unsigned int NFitPoints() const; effective points used in the fit. { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th likelihood element and its gradient. void Gradient(const double* x, double* g) const; evaluate gradient. bool IsWeighted() const; { return (fWeight != 0); }. void UseSumOfWeights(); Use the weights in evaluating the likelihood. void UseSumOfWeightSquare(bool on = true); Use sum of the weight squared in evaluating the likelihood; (this is needed for calculating the errors). double DoEval(const double* x) const. Evaluation of the function (required by interface). double DoDerivative(const double* x, unsigned int icoord) const; for derivatives.  Author: L. Moneta Fri Aug 17 14:29:24 2007  Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html534/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html:2301,Modifiability,extend,extended,2301,"LikelihoodFCN<ROOT::Math::IMultiGradFunction>. Function Members (Methods); public:. virtual~PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(); virtual ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseFunction*Clone() const; virtual const ROOT::Fit::BinData&Data() const; virtual doubleDataElement(const double* x, unsigned int i, double* g) const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidROOT::Math::IGradientFunctionMultiDim::FdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* g) const; boolIsWeighted() const; virtual const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&ModelFunction() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(const ROOT::Fit::BinData& data, const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction& func, int weight = 0, bool extended = true); virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::ResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::Type_tType() const; virtual voidROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::UpdateNCalls() const; voidUseSumOfWeights(); voidUseSumOfWeightSquare(bool on = true). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; ",MatchSource.WIKI,root/html534/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html534/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html:3531,Modifiability,extend,extended,3531,"h::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::UpdateNCalls() const; voidUseSumOfWeights(); voidUseSumOfWeightSquare(bool on = true). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const; ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&operator=(const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&); ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::BinData&fData; const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag to indicate if is extended (when false is a Multinomial lieklihood), default is true; unsigned intfNEffPointsnumber of effective points used in the fit; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new PoissonLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); }. unsigned int NFitPoints() const; effective points used in the fit. { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th likelihood element and its gradient. void Gradient(const double* x, double* g) const; evaluate gradient. bool IsWeighted() const; { return (fWeight != 0); }. void UseSumOfWeights(); Use the weights in evaluating the likelihood. void UseSumOfWeightSquare(bool on = true); Use sum of the weight squared in evaluating the likelihood; (this is needed for calculating th",MatchSource.WIKI,root/html534/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html534/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html:538,Testability,log,log,538,". ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>. class ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>: public ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>. class evaluating the log likelihood; for binned Poisson likelihood fits; it is template to distinguish gradient and non-gradient case. @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Fit::PoissonLLGradFunction, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IMultiGradFunction>. Function Members (Methods); public:. virtual~PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>(); virtual ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseFunction*Clone() const; virtual const ROOT::Fit::BinData&Data() const; virtual doubleDataElement(const double* x, unsigned int i, double* g) const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidROOT::Math::IGradientFunctionMultiDim::FdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* g) const; boolIsWeighted() const; virtual const ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&ModelFunction() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NCalls() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NDim() const; virtual unsigned intNFitPoints() const; virtual unsigned intROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::NPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const d",MatchSource.WIKI,root/html534/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__PoissonLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html
https://root.cern/root/html534/ROOT__Fit__SparseData.html:459,Availability,error,error,459,". ROOT::Fit::SparseData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::SparseData. class ROOT::Fit::SparseData: public ROOT::Fit::FitData. Function Members (Methods); public:. virtual~SparseData(); voidAdd(vector<double>& min, vector<double>& max, const double content, const double error = 1.0); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::DataOptions& opt); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::DataRange& range); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::FitData&); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); voidGetBinData(ROOT::Fit::BinData&) const; voidGetBinDataIntegral(ROOT::Fit::BinData&) const; voidGetBinDataNoZeros(ROOT::Fit::BinData&) const; voidGetPoint(const unsigned int i, vector<double>& min, vector<double>& max, double& content, double& error); static unsigned intROOT::Fit::FitData::MaxSize(); unsigned intNDim() const; unsigned intNPoints() const; ROOT::Fit::SparseData&operator=(const ROOT::Fit::SparseData&); const ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt() const; ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt(); voidPrintList() const; const ROOT::Fit::DataRange&ROOT::Fit::FitData::Range() const; ROOT::Fit::SparseDataSparseData(const ROOT::Fit::SparseData&); ROOT::Fit::SparseDataSparseData(vector<double>& min, vector<double>& max); ROOT::Fit::SparseDataSparseData(const unsigned int dim, double* min, double* max). Data Members; private:. ROOT::Fit::ProxyListBox*fList. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SparseData(vector<double>& min, vector<double>& max); Constructor with a vector. SparseData(const unsigned int dim, double* min, double* m",MatchSource.WIKI,root/html534/ROOT__Fit__SparseData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__SparseData.html
https://root.cern/root/html534/ROOT__Fit__SparseData.html:1123,Availability,error,error,1123,"Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::SparseData. class ROOT::Fit::SparseData: public ROOT::Fit::FitData. Function Members (Methods); public:. virtual~SparseData(); voidAdd(vector<double>& min, vector<double>& max, const double content, const double error = 1.0); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::DataOptions& opt); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::DataRange& range); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::FitData&); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); voidGetBinData(ROOT::Fit::BinData&) const; voidGetBinDataIntegral(ROOT::Fit::BinData&) const; voidGetBinDataNoZeros(ROOT::Fit::BinData&) const; voidGetPoint(const unsigned int i, vector<double>& min, vector<double>& max, double& content, double& error); static unsigned intROOT::Fit::FitData::MaxSize(); unsigned intNDim() const; unsigned intNPoints() const; ROOT::Fit::SparseData&operator=(const ROOT::Fit::SparseData&); const ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt() const; ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt(); voidPrintList() const; const ROOT::Fit::DataRange&ROOT::Fit::FitData::Range() const; ROOT::Fit::SparseDataSparseData(const ROOT::Fit::SparseData&); ROOT::Fit::SparseDataSparseData(vector<double>& min, vector<double>& max); ROOT::Fit::SparseDataSparseData(const unsigned int dim, double* min, double* max). Data Members; private:. ROOT::Fit::ProxyListBox*fList. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SparseData(vector<double>& min, vector<double>& max); Constructor with a vector. SparseData(const unsigned int dim, double* min, double* max); Constructor with a dimension and two arrays. ~SparseData(); Destructor. unsigned int NP",MatchSource.WIKI,root/html534/ROOT__Fit__SparseData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__SparseData.html
https://root.cern/root/html534/ROOT__Fit__SparseData.html:2302,Availability,error,error,2302,"uble>& min, vector<double>& max, double& content, double& error); static unsigned intROOT::Fit::FitData::MaxSize(); unsigned intNDim() const; unsigned intNPoints() const; ROOT::Fit::SparseData&operator=(const ROOT::Fit::SparseData&); const ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt() const; ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt(); voidPrintList() const; const ROOT::Fit::DataRange&ROOT::Fit::FitData::Range() const; ROOT::Fit::SparseDataSparseData(const ROOT::Fit::SparseData&); ROOT::Fit::SparseDataSparseData(vector<double>& min, vector<double>& max); ROOT::Fit::SparseDataSparseData(const unsigned int dim, double* min, double* max). Data Members; private:. ROOT::Fit::ProxyListBox*fList. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SparseData(vector<double>& min, vector<double>& max); Constructor with a vector. SparseData(const unsigned int dim, double* min, double* max); Constructor with a dimension and two arrays. ~SparseData(); Destructor. unsigned int NPoints() const; Returns the number of points stored. unsigned int NDim() const; Returns the dimension of the object (bins). void Add(vector<double>& min, vector<double>& max, const double content, const double error = 1.0); Adds a new bin specified by the vectors. void PrintList() const; Debug method to print the list of bins stored. void GetBinData(ROOT::Fit::BinData& ) const; Transforms the data into a ROOT::Fit::BinData structure. void GetBinDataIntegral(ROOT::Fit::BinData& ) const; Same as before, but with integral format. void GetBinDataNoZeros(ROOT::Fit::BinData& ) const; Same as before, but including zero content bins.  Author: David Gonzalez Maline Wed Aug 28 15:23:43 2009  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Fit__SparseData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__SparseData.html
https://root.cern/root/html534/ROOT__Fit__UnBinData.html:579,Energy Efficiency,efficient,efficient,579,". ROOT::Fit::UnBinData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::UnBinData. class ROOT::Fit::UnBinData: public ROOT::Fit::FitData. Class describing the unbinned data sets (just x coordinates values) of any dimensions. There is the option to construct UnBindata copying the data in (using the DataVector class); or using pointer to external data (DataWrapper) class.; In general is found to be more efficient to copy the data.; In case of really large data sets for limiting memory consumption then the other option can be used; Specialized constructor exists for using external data up to 3 dimensions. When the data are copying in the number of points can be set later (or re-set) using Initialize and; the data are inserted one by one using the Add method.; It is mandatory to set the size before using the Add method. @ingroup FitData. Function Members (Methods); public:. virtual~UnBinData(); voidAdd(double x); voidAdd(const double* x); voidAdd(double x, double y); voidAdd(const double* x, double w); voidAdd(double x, double y, double z); const double*Coords(unsigned int ipoint) const; unsigned intDataSize() const; ROOT::Fit::FitDataROOT::Fit::FitData::FitData(); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::DataOptions& opt); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::DataRange& range); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::FitData&); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); voidInitialize(unsigned int maxpoints, unsigned int dim = 1, bool isWeighted = false); boolIsWeighted() const; static unsigned intROOT::Fit::FitData::MaxSize(); unsigned intNDim() const; unsigned intNPoints() const; const ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt() const; ROOT::Fit::Dat",MatchSource.WIKI,root/html534/ROOT__Fit__UnBinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__UnBinData.html
https://root.cern/root/html534/ROOT__Fit__UnBinData.html:662,Energy Efficiency,consumption,consumption,662,". ROOT::Fit::UnBinData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Fit::UnBinData. class ROOT::Fit::UnBinData: public ROOT::Fit::FitData. Class describing the unbinned data sets (just x coordinates values) of any dimensions. There is the option to construct UnBindata copying the data in (using the DataVector class); or using pointer to external data (DataWrapper) class.; In general is found to be more efficient to copy the data.; In case of really large data sets for limiting memory consumption then the other option can be used; Specialized constructor exists for using external data up to 3 dimensions. When the data are copying in the number of points can be set later (or re-set) using Initialize and; the data are inserted one by one using the Add method.; It is mandatory to set the size before using the Add method. @ingroup FitData. Function Members (Methods); public:. virtual~UnBinData(); voidAdd(double x); voidAdd(const double* x); voidAdd(double x, double y); voidAdd(const double* x, double w); voidAdd(double x, double y, double z); const double*Coords(unsigned int ipoint) const; unsigned intDataSize() const; ROOT::Fit::FitDataROOT::Fit::FitData::FitData(); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::DataOptions& opt); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::DataRange& range); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::FitData&); ROOT::Fit::FitDataROOT::Fit::FitData::FitData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range); voidInitialize(unsigned int maxpoints, unsigned int dim = 1, bool isWeighted = false); boolIsWeighted() const; static unsigned intROOT::Fit::FitData::MaxSize(); unsigned intNDim() const; unsigned intNPoints() const; const ROOT::Fit::DataOptions&ROOT::Fit::FitData::Opt() const; ROOT::Fit::Dat",MatchSource.WIKI,root/html534/ROOT__Fit__UnBinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__UnBinData.html
https://root.cern/root/html534/ROOT__Fit__UnBinData.html:4222,Energy Efficiency,allocate,allocate,4222,"); ROOT::Fit::UnBinDataUnBinData(unsigned int maxpoints, const double* dataX, const double* dataY, const double* dataZ, const ROOT::Fit::DataRange& range, bool isWeighted = false); doubleWeight(unsigned int ipoint) const. protected:. voidSetNPoints(unsigned int n). private:. ROOT::Fit::UnBinData&operator=(const ROOT::Fit::UnBinData&); ROOT::Fit::UnBinDataUnBinData(const ROOT::Fit::UnBinData&). Data Members; private:. ROOT::Fit::DataVector*fDataVectorpointer to internal data vector (null for external data); ROOT::Fit::DataWrapper*fDataWrapperpointer to structure wrapping external data (null when data are copied in); unsigned intfDimcoordinate data dimension; unsigned intfNPointsnumer of fit points; unsigned intfPointSizepoit size dimension (coordinate + weight). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; explicit UnBinData(unsigned int maxpoints = 0, unsigned int dim = 1, bool isWeighted = false). constructor from dimension of point and max number of points (to pre-allocate vector). explicit UnBinData(const ROOT::Fit::DataRange& range, unsigned int maxpoints = 0, unsigned int dim = 1, bool isWeighted = false). constructor from range and default option. UnBinData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range, unsigned int maxpoints = 0, unsigned int dim = 1, bool isWeighted = false). constructor from options and range. UnBinData(unsigned int n, const double* dataX). constructor for 1D external data (data are not copied inside). UnBinData(unsigned int n, const double* dataX, const double* dataY, bool isWeighted = false). constructor for 2D external data (data are not copied inside); or 1D data with a weight (if isWeighted = true). UnBinData(unsigned int n, const double* dataX, const double* dataY, const double* dataZ, bool isWeighted = false). constructor for 3D external data (data are not copied inside); or 2D data with a weight (if isWeighted = true). UnBinData(unsigned int n, const double* dataX, ",MatchSource.WIKI,root/html534/ROOT__Fit__UnBinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__UnBinData.html
https://root.cern/root/html534/ROOT__Fit__UnBinData.html:3763,Integrability,wrap,wrapping,3763,"opt, const ROOT::Fit::DataRange& range, unsigned int maxpoints = 0, unsigned int dim = 1, bool isWeighted = false); ROOT::Fit::UnBinDataUnBinData(unsigned int n, const double* dataX, const double* dataY, const double* dataZ, bool isWeighted = false); ROOT::Fit::UnBinDataUnBinData(unsigned int maxpoints, const double* dataX, const double* dataY, const ROOT::Fit::DataRange& range, bool isWeighted = false); ROOT::Fit::UnBinDataUnBinData(unsigned int maxpoints, const double* dataX, const double* dataY, const double* dataZ, const ROOT::Fit::DataRange& range, bool isWeighted = false); doubleWeight(unsigned int ipoint) const. protected:. voidSetNPoints(unsigned int n). private:. ROOT::Fit::UnBinData&operator=(const ROOT::Fit::UnBinData&); ROOT::Fit::UnBinDataUnBinData(const ROOT::Fit::UnBinData&). Data Members; private:. ROOT::Fit::DataVector*fDataVectorpointer to internal data vector (null for external data); ROOT::Fit::DataWrapper*fDataWrapperpointer to structure wrapping external data (null when data are copied in); unsigned intfDimcoordinate data dimension; unsigned intfNPointsnumer of fit points; unsigned intfPointSizepoit size dimension (coordinate + weight). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; explicit UnBinData(unsigned int maxpoints = 0, unsigned int dim = 1, bool isWeighted = false). constructor from dimension of point and max number of points (to pre-allocate vector). explicit UnBinData(const ROOT::Fit::DataRange& range, unsigned int maxpoints = 0, unsigned int dim = 1, bool isWeighted = false). constructor from range and default option. UnBinData(const ROOT::Fit::DataOptions& opt, const ROOT::Fit::DataRange& range, unsigned int maxpoints = 0, unsigned int dim = 1, bool isWeighted = false). constructor from options and range. UnBinData(unsigned int n, const double* dataX). constructor for 1D external data (data are not copied inside). UnBinData(unsigned int n, const double* dataX, const double* dataY, bool is",MatchSource.WIKI,root/html534/ROOT__Fit__UnBinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__UnBinData.html
https://root.cern/root/html534/ROOT__Fit__UnBinData.html:6623,Integrability,wrap,wrapper,6623,"nBinData(unsigned int maxpoints, const double* dataX, const ROOT::Fit::DataRange& range). constructor for 1D data and a range (data are copied inside according to the given range). UnBinData(unsigned int maxpoints, const double* dataX, const double* dataY, const ROOT::Fit::DataRange& range, bool isWeighted = false). constructor for 2D data and a range (data are copied inside according to the given range); or 1 1D data set + weight. If is weighted dataY is the pointer to the list of the weights. UnBinData(unsigned int maxpoints, const double* dataX, const double* dataY, const double* dataZ, const ROOT::Fit::DataRange& range, bool isWeighted = false). constructor for 3D data and a range (data are copied inside according to the given range); or a 2D data set + weights. If is weighted dataZ is the pointer to the list of the weights. UnBinData & operator=(const ROOT::Fit::UnBinData& ); assignment operator (private). { return *this; }. virtual ~UnBinData(). destructor, delete pointer to internal data or external data wrapper. void Initialize(unsigned int maxpoints, unsigned int dim = 1, bool isWeighted = false). preallocate a data set given size and dimension of the coordinates; if a vector already exists with correct dimension (point size) extend the existing one; to a total size of maxpoints (equivalent to a Resize). void Add(double x). add one dim coordinate data (unweighted). void Add(double x, double y). add 2-dim coordinate data; can also be used to add 1-dim data with a weight. void Add(double x, double y, double z). add 3-dim coordinate data; can also be used to add 2-dim data with a weight. void Add(const double* x). add multi-dim coordinate data. void Add(const double* x, double w). add multi-dim coordinate data + weight. const double * Coords(unsigned int ipoint) const. return pointer to coordinate data. bool IsWeighted() const. double Weight(unsigned int ipoint) const. void Resize(unsigned int npoints). resize the vector to the given npoints. unsigned int NPoi",MatchSource.WIKI,root/html534/ROOT__Fit__UnBinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__UnBinData.html
https://root.cern/root/html534/ROOT__Fit__UnBinData.html:6851,Modifiability,extend,extend,6851," dataX, const double* dataY, const ROOT::Fit::DataRange& range, bool isWeighted = false). constructor for 2D data and a range (data are copied inside according to the given range); or 1 1D data set + weight. If is weighted dataY is the pointer to the list of the weights. UnBinData(unsigned int maxpoints, const double* dataX, const double* dataY, const double* dataZ, const ROOT::Fit::DataRange& range, bool isWeighted = false). constructor for 3D data and a range (data are copied inside according to the given range); or a 2D data set + weights. If is weighted dataZ is the pointer to the list of the weights. UnBinData & operator=(const ROOT::Fit::UnBinData& ); assignment operator (private). { return *this; }. virtual ~UnBinData(). destructor, delete pointer to internal data or external data wrapper. void Initialize(unsigned int maxpoints, unsigned int dim = 1, bool isWeighted = false). preallocate a data set given size and dimension of the coordinates; if a vector already exists with correct dimension (point size) extend the existing one; to a total size of maxpoints (equivalent to a Resize). void Add(double x). add one dim coordinate data (unweighted). void Add(double x, double y). add 2-dim coordinate data; can also be used to add 1-dim data with a weight. void Add(double x, double y, double z). add 3-dim coordinate data; can also be used to add 2-dim data with a weight. void Add(const double* x). add multi-dim coordinate data. void Add(const double* x, double w). add multi-dim coordinate data + weight. const double * Coords(unsigned int ipoint) const. return pointer to coordinate data. bool IsWeighted() const. double Weight(unsigned int ipoint) const. void Resize(unsigned int npoints). resize the vector to the given npoints. unsigned int NPoints() const. return number of contained points. { return fNPoints; }. unsigned int Size() const. return number of contained points. { return fNPoints; }. unsigned int NDim() const. return coordinate data dimension. { return fDim;",MatchSource.WIKI,root/html534/ROOT__Fit__UnBinData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Fit__UnBinData.html
https://root.cern/root/html534/ROOT__Math.html:32588,Deployability,release,releases,32588,"s; Function documentation; double beta_quantile(double x, double a, double b); @defgroup QuantFunc Quantile Functions; * @ingroup StatFunc; *; * Inverse functions of the cumulative distribution functions; * and the inverse of the complement of the cumulative distribution functions; * for various distributions.; * The functions with the extension <em>_quantile</em> calculate the; * inverse of the <em>_cdf</em> function, the; * lower tail integral of the probability density function; * \f$D^{-1}(z)\f$ where; *; * \f[ D(x) = \int_{-\infty}^{x} p(x') dx' \f]; *; * while those with the <em>_quantile_c</em> extension calculate the; * inverse of the <em>_cdf_c</em> functions, the upper tail integral of the probability; * density function \f$D^{-1}(z) \f$ where; *; * \f[ D(x) = \int_{x}^{+\infty} p(x') dx' \f]; *; * These functions are defined in the header file <em>Math/ProbFunc.h<em> or in the global one; * including all statistical dunctions <em>Math/DistFunc.h<em>; *; *; * <strong>NOTE:</strong> In the old releases (< 5.14) the <em>_quantile</em> functions were called; * <em>_quant_inv</em> and the <em>_quantile_c</em> functions were called; * <em>_prob_inv</em>.; * These names are currently kept for backward compatibility, but; * their usage is deprecated.; *. @name Quantile Functions from MathCore; * The implementation is provided in MathCore and for the majority of the function comes from; * <A HREF=""http://www.netlib.org/cephes"">Cephes</A>. @{. Inverse (\f$D^{-1}(z)\f$) of the cumulative distribution; function of the upper tail of the beta distribution; (#beta_cdf_c).; It is implemented using the function incbi from <A HREF=""http://www.netlib.org/cephes"">Cephes</A>. @ingroup QuantFunc. double beta_quantile_c(double x, double a, double b). Inverse (\f$D^{-1}(z)\f$) of the cumulative distribution; function of the lower tail of the beta distribution; (#beta_cdf).; It is implemented using; the function incbi from <A HREF=""http://www.netlib.org/cephes"">Cephes</A>. @ingrou",MatchSource.WIKI,root/html534/ROOT__Math.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math.html
https://root.cern/root/html534/ROOT__Math.html:40129,Testability,log,lognormal,40129,"the cumulative distribution; function of the upper tail of the normal (Gaussian) distribution; (#gaussian_cdf_c). For detailed description see; <A HREF=""http://mathworld.wolfram.com/NormalDistribution.html"">; Mathworld</A>. It can also be evaluated using #normal_quantile_c which will; call the same implementation. @ingroup QuantFunc. double gaussian_quantile(double z, double sigma). Inverse (\f$D^{-1}(z)\f$) of the cumulative distribution; function of the lower tail of the normal (Gaussian) distribution; (#gaussian_cdf). For detailed description see; <A HREF=""http://mathworld.wolfram.com/NormalDistribution.html"">; Mathworld</A>. It can also be evaluated using #normal_quantile which will; call the same implementation.; It is implemented using the function ROOT::Math::Cephes::ndtri taken from; <A HREF=""http://www.netlib.org/cephes"">Cephes</A>. @ingroup QuantFunc. double lognormal_quantile_c(double x, double m, double s). Inverse (\f$D^{-1}(z)\f$) of the cumulative distribution; function of the upper tail of the lognormal distribution; (#lognormal_cdf_c). For detailed description see; <A HREF=""http://mathworld.wolfram.com/LogNormalDistribution.html"">; Mathworld</A>. The implementation used is that of; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_19.html#SEC302"">GSL</A>. @ingroup QuantFunc. double lognormal_quantile(double x, double m, double s). Inverse (\f$D^{-1}(z)\f$) of the cumulative distribution; function of the lower tail of the lognormal distribution; (#lognormal_cdf). For detailed description see; <A HREF=""http://mathworld.wolfram.com/LogNormalDistribution.html"">; Mathworld</A>. The implementation used is that of; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_19.html#SEC302"">GSL</A>. @ingroup QuantFunc. double normal_quantile_c(double z, double sigma). Inverse (\f$D^{-1}(z)\f$) of the cumulative distribution; function of the upper tail of the normal (Gaussian) distribution; (#normal_cdf_c). For detailed description see; <A HREF=""http://mat",MatchSource.WIKI,root/html534/ROOT__Math.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math.html
https://root.cern/root/html534/ROOT__Math.html:40572,Testability,log,lognormal,40572,"; function of the lower tail of the normal (Gaussian) distribution; (#gaussian_cdf). For detailed description see; <A HREF=""http://mathworld.wolfram.com/NormalDistribution.html"">; Mathworld</A>. It can also be evaluated using #normal_quantile which will; call the same implementation.; It is implemented using the function ROOT::Math::Cephes::ndtri taken from; <A HREF=""http://www.netlib.org/cephes"">Cephes</A>. @ingroup QuantFunc. double lognormal_quantile_c(double x, double m, double s). Inverse (\f$D^{-1}(z)\f$) of the cumulative distribution; function of the upper tail of the lognormal distribution; (#lognormal_cdf_c). For detailed description see; <A HREF=""http://mathworld.wolfram.com/LogNormalDistribution.html"">; Mathworld</A>. The implementation used is that of; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_19.html#SEC302"">GSL</A>. @ingroup QuantFunc. double lognormal_quantile(double x, double m, double s). Inverse (\f$D^{-1}(z)\f$) of the cumulative distribution; function of the lower tail of the lognormal distribution; (#lognormal_cdf). For detailed description see; <A HREF=""http://mathworld.wolfram.com/LogNormalDistribution.html"">; Mathworld</A>. The implementation used is that of; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_19.html#SEC302"">GSL</A>. @ingroup QuantFunc. double normal_quantile_c(double z, double sigma). Inverse (\f$D^{-1}(z)\f$) of the cumulative distribution; function of the upper tail of the normal (Gaussian) distribution; (#normal_cdf_c). For detailed description see; <A HREF=""http://mathworld.wolfram.com/NormalDistribution.html"">; Mathworld</A>. It can also be evaluated using #gaussian_quantile_c which will; call the same implementation.; It is implemented using the function ROOT::Math::Cephes::ndtri taken from; <A HREF=""http://www.netlib.org/cephes"">Cephes</A>. @ingroup QuantFunc. double normal_quantile(double z, double sigma). Inverse (\f$D^{-1}(z)\f$) of the cumulative distribution; function of the lower tail of the ",MatchSource.WIKI,root/html534/ROOT__Math.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:1220,Availability,error,error,1220,"E;  ROOT::Math::AdaptiveIntegratorMultiDim. class ROOT::Math::AdaptiveIntegratorMultiDim: public ROOT::Math::VirtualIntegratorMultiDim. class for adaptive quadrature integration in multi-dimensions using rectangular regions.; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. Control parameters are:. minpts: Minimum number of function evaluations requested. Must not exceed maxpts.; if minpts < 1 minpts is set to 2^n +2*n*(n+1) +1 where n is the function dimension; maxpts: Maximum number of function evaluations to be allowed.; maxpts >= 2^n +2*n*(n+1) +1; if maxpts<minpts, maxpts is set to 10*minpts; epstol, epsrel : Specified relative and absolute accuracy. The integral will stop if the relative error is less than relative tolerance OR the; absolute error is less than the absolute tolerance. The class computes in addition to the integral of the function is the desired interval:. an estimation of the relative accuracy of the result.; number of function evaluations performed.; status code :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2.Numerical integration usually works best for smooth functions.; Some analysis or suitable tr",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:1248,Availability,toler,tolerance,1248,"E;  ROOT::Math::AdaptiveIntegratorMultiDim. class ROOT::Math::AdaptiveIntegratorMultiDim: public ROOT::Math::VirtualIntegratorMultiDim. class for adaptive quadrature integration in multi-dimensions using rectangular regions.; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. Control parameters are:. minpts: Minimum number of function evaluations requested. Must not exceed maxpts.; if minpts < 1 minpts is set to 2^n +2*n*(n+1) +1 where n is the function dimension; maxpts: Maximum number of function evaluations to be allowed.; maxpts >= 2^n +2*n*(n+1) +1; if maxpts<minpts, maxpts is set to 10*minpts; epstol, epsrel : Specified relative and absolute accuracy. The integral will stop if the relative error is less than relative tolerance OR the; absolute error is less than the absolute tolerance. The class computes in addition to the integral of the function is the desired interval:. an estimation of the relative accuracy of the result.; number of function evaluations performed.; status code :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2.Numerical integration usually works best for smooth functions.; Some analysis or suitable tr",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:1275,Availability,error,error,1275,"E;  ROOT::Math::AdaptiveIntegratorMultiDim. class ROOT::Math::AdaptiveIntegratorMultiDim: public ROOT::Math::VirtualIntegratorMultiDim. class for adaptive quadrature integration in multi-dimensions using rectangular regions.; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. Control parameters are:. minpts: Minimum number of function evaluations requested. Must not exceed maxpts.; if minpts < 1 minpts is set to 2^n +2*n*(n+1) +1 where n is the function dimension; maxpts: Maximum number of function evaluations to be allowed.; maxpts >= 2^n +2*n*(n+1) +1; if maxpts<minpts, maxpts is set to 10*minpts; epstol, epsrel : Specified relative and absolute accuracy. The integral will stop if the relative error is less than relative tolerance OR the; absolute error is less than the absolute tolerance. The class computes in addition to the integral of the function is the desired interval:. an estimation of the relative accuracy of the result.; number of function evaluations performed.; status code :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2.Numerical integration usually works best for smooth functions.; Some analysis or suitable tr",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:1307,Availability,toler,tolerance,1307,"E;  ROOT::Math::AdaptiveIntegratorMultiDim. class ROOT::Math::AdaptiveIntegratorMultiDim: public ROOT::Math::VirtualIntegratorMultiDim. class for adaptive quadrature integration in multi-dimensions using rectangular regions.; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. Control parameters are:. minpts: Minimum number of function evaluations requested. Must not exceed maxpts.; if minpts < 1 minpts is set to 2^n +2*n*(n+1) +1 where n is the function dimension; maxpts: Maximum number of function evaluations to be allowed.; maxpts >= 2^n +2*n*(n+1) +1; if maxpts<minpts, maxpts is set to 10*minpts; epstol, epsrel : Specified relative and absolute accuracy. The integral will stop if the relative error is less than relative tolerance OR the; absolute error is less than the absolute tolerance. The class computes in addition to the integral of the function is the desired interval:. an estimation of the relative accuracy of the result.; number of function evaluations performed.; status code :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2.Numerical integration usually works best for smooth functions.; Some analysis or suitable tr",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:4322,Availability,toler,tolerance,4322,"th::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidSetRelTolerance(double relTol); voidSetSize(unsigned int size); virtual intStatus() const; virtual ROOT::Math::IntegrationMultiDim::TypeROOT::Math::VirtualIntegratorMultiDim::Type() const. protected:. doubleDoIntegral(const double* xmin, const double* xmax, bool absVal = false). Data Members; private:. doublefAbsTolabsolute tolerance; unsigned intfDimdimentionality of integrand; doublefErrorintegration error ; const ROOT::Math::IMultiGenFunction*fFunpointer to integrand function ; unsigned intfMaxPtsmaximum number of function evaluation requested ; unsigned intfMinPtsminimum number of function evaluation requested ; intfNEvalnumber of function evaluation; doublefRelErrorRelative error; doublefRelTolrelative tolerance; doublefResultlast integration result ; unsigned intfSizemax size of working array (explode with dimension); intfStatusstatus of algorithm (error if not zero). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; AdaptiveIntegratorMultiDim(double absTol = 1.E-9, double relTol = 1E-9, unsigned int maxpts = 100000, unsigned int size = 0). construct given optionally tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array.; The size of working array represents the number of sub-division used for calculating the integral.; Higher the dimension, larger sizes are required for getting the same accuracy.; The size must be larger than >= (2N + 3) * (1 + MAXPTS/(2**N + 2N(N + 1) + 1))/2). For smaller value passed, the; minimum allowed will be used. AdaptiveIntegratorMultiDi",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:4402,Availability,error,error,4402,"th::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidSetRelTolerance(double relTol); voidSetSize(unsigned int size); virtual intStatus() const; virtual ROOT::Math::IntegrationMultiDim::TypeROOT::Math::VirtualIntegratorMultiDim::Type() const. protected:. doubleDoIntegral(const double* xmin, const double* xmax, bool absVal = false). Data Members; private:. doublefAbsTolabsolute tolerance; unsigned intfDimdimentionality of integrand; doublefErrorintegration error ; const ROOT::Math::IMultiGenFunction*fFunpointer to integrand function ; unsigned intfMaxPtsmaximum number of function evaluation requested ; unsigned intfMinPtsminimum number of function evaluation requested ; intfNEvalnumber of function evaluation; doublefRelErrorRelative error; doublefRelTolrelative tolerance; doublefResultlast integration result ; unsigned intfSizemax size of working array (explode with dimension); intfStatusstatus of algorithm (error if not zero). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; AdaptiveIntegratorMultiDim(double absTol = 1.E-9, double relTol = 1E-9, unsigned int maxpts = 100000, unsigned int size = 0). construct given optionally tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array.; The size of working array represents the number of sub-division used for calculating the integral.; Higher the dimension, larger sizes are required for getting the same accuracy.; The size must be larger than >= (2N + 3) * (1 + MAXPTS/(2**N + 2N(N + 1) + 1))/2). For smaller value passed, the; minimum allowed will be used. AdaptiveIntegratorMultiDi",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:4684,Availability,error,error,4684,"th::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidSetRelTolerance(double relTol); voidSetSize(unsigned int size); virtual intStatus() const; virtual ROOT::Math::IntegrationMultiDim::TypeROOT::Math::VirtualIntegratorMultiDim::Type() const. protected:. doubleDoIntegral(const double* xmin, const double* xmax, bool absVal = false). Data Members; private:. doublefAbsTolabsolute tolerance; unsigned intfDimdimentionality of integrand; doublefErrorintegration error ; const ROOT::Math::IMultiGenFunction*fFunpointer to integrand function ; unsigned intfMaxPtsmaximum number of function evaluation requested ; unsigned intfMinPtsminimum number of function evaluation requested ; intfNEvalnumber of function evaluation; doublefRelErrorRelative error; doublefRelTolrelative tolerance; doublefResultlast integration result ; unsigned intfSizemax size of working array (explode with dimension); intfStatusstatus of algorithm (error if not zero). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; AdaptiveIntegratorMultiDim(double absTol = 1.E-9, double relTol = 1E-9, unsigned int maxpts = 100000, unsigned int size = 0). construct given optionally tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array.; The size of working array represents the number of sub-division used for calculating the integral.; Higher the dimension, larger sizes are required for getting the same accuracy.; The size must be larger than >= (2N + 3) * (1 + MAXPTS/(2**N + 2N(N + 1) + 1))/2). For smaller value passed, the; minimum allowed will be used. AdaptiveIntegratorMultiDi",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:4713,Availability,toler,tolerance,4713,"th::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidSetRelTolerance(double relTol); voidSetSize(unsigned int size); virtual intStatus() const; virtual ROOT::Math::IntegrationMultiDim::TypeROOT::Math::VirtualIntegratorMultiDim::Type() const. protected:. doubleDoIntegral(const double* xmin, const double* xmax, bool absVal = false). Data Members; private:. doublefAbsTolabsolute tolerance; unsigned intfDimdimentionality of integrand; doublefErrorintegration error ; const ROOT::Math::IMultiGenFunction*fFunpointer to integrand function ; unsigned intfMaxPtsmaximum number of function evaluation requested ; unsigned intfMinPtsminimum number of function evaluation requested ; intfNEvalnumber of function evaluation; doublefRelErrorRelative error; doublefRelTolrelative tolerance; doublefResultlast integration result ; unsigned intfSizemax size of working array (explode with dimension); intfStatusstatus of algorithm (error if not zero). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; AdaptiveIntegratorMultiDim(double absTol = 1.E-9, double relTol = 1E-9, unsigned int maxpts = 100000, unsigned int size = 0). construct given optionally tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array.; The size of working array represents the number of sub-division used for calculating the integral.; Higher the dimension, larger sizes are required for getting the same accuracy.; The size must be larger than >= (2N + 3) * (1 + MAXPTS/(2**N + 2N(N + 1) + 1))/2). For smaller value passed, the; minimum allowed will be used. AdaptiveIntegratorMultiDi",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:4863,Availability,error,error,4863,"th::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidSetRelTolerance(double relTol); voidSetSize(unsigned int size); virtual intStatus() const; virtual ROOT::Math::IntegrationMultiDim::TypeROOT::Math::VirtualIntegratorMultiDim::Type() const. protected:. doubleDoIntegral(const double* xmin, const double* xmax, bool absVal = false). Data Members; private:. doublefAbsTolabsolute tolerance; unsigned intfDimdimentionality of integrand; doublefErrorintegration error ; const ROOT::Math::IMultiGenFunction*fFunpointer to integrand function ; unsigned intfMaxPtsmaximum number of function evaluation requested ; unsigned intfMinPtsminimum number of function evaluation requested ; intfNEvalnumber of function evaluation; doublefRelErrorRelative error; doublefRelTolrelative tolerance; doublefResultlast integration result ; unsigned intfSizemax size of working array (explode with dimension); intfStatusstatus of algorithm (error if not zero). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; AdaptiveIntegratorMultiDim(double absTol = 1.E-9, double relTol = 1E-9, unsigned int maxpts = 100000, unsigned int size = 0). construct given optionally tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array.; The size of working array represents the number of sub-division used for calculating the integral.; Higher the dimension, larger sizes are required for getting the same accuracy.; The size must be larger than >= (2N + 3) * (1 + MAXPTS/(2**N + 2N(N + 1) + 1))/2). For smaller value passed, the; minimum allowed will be used. AdaptiveIntegratorMultiDi",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:5127,Availability,toler,tolerance,5127,"::Type() const. protected:. doubleDoIntegral(const double* xmin, const double* xmax, bool absVal = false). Data Members; private:. doublefAbsTolabsolute tolerance; unsigned intfDimdimentionality of integrand; doublefErrorintegration error ; const ROOT::Math::IMultiGenFunction*fFunpointer to integrand function ; unsigned intfMaxPtsmaximum number of function evaluation requested ; unsigned intfMinPtsminimum number of function evaluation requested ; intfNEvalnumber of function evaluation; doublefRelErrorRelative error; doublefRelTolrelative tolerance; doublefResultlast integration result ; unsigned intfSizemax size of working array (explode with dimension); intfStatusstatus of algorithm (error if not zero). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; AdaptiveIntegratorMultiDim(double absTol = 1.E-9, double relTol = 1E-9, unsigned int maxpts = 100000, unsigned int size = 0). construct given optionally tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array.; The size of working array represents the number of sub-division used for calculating the integral.; Higher the dimension, larger sizes are required for getting the same accuracy.; The size must be larger than >= (2N + 3) * (1 + MAXPTS/(2**N + 2N(N + 1) + 1))/2). For smaller value passed, the; minimum allowed will be used. AdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-9, unsigned int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operations). {}. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. return DoIntegral(const double* xmin",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:5808,Availability,toler,tolerance,5808,"ion); intfStatusstatus of algorithm (error if not zero). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; AdaptiveIntegratorMultiDim(double absTol = 1.E-9, double relTol = 1E-9, unsigned int maxpts = 100000, unsigned int size = 0). construct given optionally tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array.; The size of working array represents the number of sub-division used for calculating the integral.; Higher the dimension, larger sizes are required for getting the same accuracy.; The size must be larger than >= (2N + 3) * (1 + MAXPTS/(2**N + 2N(N + 1) + 1))/2). For smaller value passed, the; minimum allowed will be used. AdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-9, unsigned int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operations). {}. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. return DoIntegral(const double* xmin, const double* xmax, bool absVal = false). double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. void SetFunction(const ROOT::Math::IMultiGenFunction& f); set the integration function (must implement multi-dim function interface: IBaseFunctionMultiDim). double Result() const; return result of integration. { return fResult; }. double Error() const; return integration error. { return fError; }. double RelError() const; return relative error. { return fRelError; }. int Status() const; return status of integration. { return fStatus; }. int NEval() const; return num",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:6629,Availability,error,error,6629,"IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-9, unsigned int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operations). {}. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. return DoIntegral(const double* xmin, const double* xmax, bool absVal = false). double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. void SetFunction(const ROOT::Math::IMultiGenFunction& f); set the integration function (must implement multi-dim function interface: IBaseFunctionMultiDim). double Result() const; return result of integration. { return fResult; }. double Error() const; return integration error. { return fError; }. double RelError() const; return relative error. { return fRelError; }. int Status() const; return status of integration. { return fStatus; }. int NEval() const; return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTol); set relative tolerance. void SetAbsTolerance(double absTol); set absolute tolerance. void SetSize(unsigned int size); set workspace size. { fSize = size; }. void SetMinPts(unsigned int n); set min points. { fMinPts = n; }. void SetMaxPts(unsigned int n); set max points. { fMaxPts = n; }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options.  Author: M. Slawinska 08/2007  Copyright (c) 2007 , LCG ROOT MathLib Team *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT s",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:6697,Availability,error,error,6697,"nFunction& f, double absTol = 1.E-9, double relTol = 1E-9, unsigned int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operations). {}. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. return DoIntegral(const double* xmin, const double* xmax, bool absVal = false). double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. void SetFunction(const ROOT::Math::IMultiGenFunction& f); set the integration function (must implement multi-dim function interface: IBaseFunctionMultiDim). double Result() const; return result of integration. { return fResult; }. double Error() const; return integration error. { return fError; }. double RelError() const; return relative error. { return fRelError; }. int Status() const; return status of integration. { return fStatus; }. int NEval() const; return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTol); set relative tolerance. void SetAbsTolerance(double absTol); set absolute tolerance. void SetSize(unsigned int size); set workspace size. { fSize = size; }. void SetMinPts(unsigned int n); set min points. { fMinPts = n; }. void SetMaxPts(unsigned int n); set max points. { fMaxPts = n; }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options.  Author: M. Slawinska 08/2007  Copyright (c) 2007 , LCG ROOT MathLib Team *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:6954,Availability,toler,tolerance,6954,"nFunction& f, double absTol = 1.E-9, double relTol = 1E-9, unsigned int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operations). {}. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. return DoIntegral(const double* xmin, const double* xmax, bool absVal = false). double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. void SetFunction(const ROOT::Math::IMultiGenFunction& f); set the integration function (must implement multi-dim function interface: IBaseFunctionMultiDim). double Result() const; return result of integration. { return fResult; }. double Error() const; return integration error. { return fError; }. double RelError() const; return relative error. { return fRelError; }. int Status() const; return status of integration. { return fStatus; }. int NEval() const; return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTol); set relative tolerance. void SetAbsTolerance(double absTol); set absolute tolerance. void SetSize(unsigned int size); set workspace size. { fSize = size; }. void SetMinPts(unsigned int n); set min points. { fMinPts = n; }. void SetMaxPts(unsigned int n); set max points. { fMaxPts = n; }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options.  Author: M. Slawinska 08/2007  Copyright (c) 2007 , LCG ROOT MathLib Team *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:7015,Availability,toler,tolerance,7015,"nFunction& f, double absTol = 1.E-9, double relTol = 1E-9, unsigned int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operations). {}. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. return DoIntegral(const double* xmin, const double* xmax, bool absVal = false). double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. void SetFunction(const ROOT::Math::IMultiGenFunction& f); set the integration function (must implement multi-dim function interface: IBaseFunctionMultiDim). double Result() const; return result of integration. { return fResult; }. double Error() const; return integration error. { return fError; }. double RelError() const; return relative error. { return fRelError; }. int Status() const; return status of integration. { return fStatus; }. int NEval() const; return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTol); set relative tolerance. void SetAbsTolerance(double absTol); set absolute tolerance. void SetSize(unsigned int size); set workspace size. { fSize = size; }. void SetMinPts(unsigned int n); set min points. { fMinPts = n; }. void SetMaxPts(unsigned int n); set max points. { fMaxPts = n; }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options.  Author: M. Slawinska 08/2007  Copyright (c) 2007 , LCG ROOT MathLib Team *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:415,Deployability,integrat,integration,415,". ROOT::Math::AdaptiveIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::AdaptiveIntegratorMultiDim. class ROOT::Math::AdaptiveIntegratorMultiDim: public ROOT::Math::VirtualIntegratorMultiDim. class for adaptive quadrature integration in multi-dimensions using rectangular regions.; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. Control parameters are:. minpts: Minimum number of function evaluations requested. Must not exceed maxpts.; if minpts < 1 minpts is set to 2^n +2*n*(n+1) +1 where n is the function dimension; maxpts: Maximum number of function evaluations to be allowed.; maxpts >= 2^n +2*n*(n+1) +1; if maxpts<minpts, maxpts is set to 10*minpts; epstol, epsrel : Specified relative and absolute accuracy. The integral will stop if the relative error is less than relative tolerance OR the; absolute error is less than the absolute tolerance. The class computes in addition to the integral of the function is the desired interval:. an estimation of the relative accuracy of the result.; number of function evaluations performed.; status code :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For ea",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:549,Deployability,integrat,integration,549,". ROOT::Math::AdaptiveIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::AdaptiveIntegratorMultiDim. class ROOT::Math::AdaptiveIntegratorMultiDim: public ROOT::Math::VirtualIntegratorMultiDim. class for adaptive quadrature integration in multi-dimensions using rectangular regions.; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. Control parameters are:. minpts: Minimum number of function evaluations requested. Must not exceed maxpts.; if minpts < 1 minpts is set to 2^n +2*n*(n+1) +1 where n is the function dimension; maxpts: Maximum number of function evaluations to be allowed.; maxpts >= 2^n +2*n*(n+1) +1; if maxpts<minpts, maxpts is set to 10*minpts; epstol, epsrel : Specified relative and absolute accuracy. The integral will stop if the relative error is less than relative tolerance OR the; absolute error is less than the absolute tolerance. The class computes in addition to the integral of the function is the desired interval:. an estimation of the relative accuracy of the result.; number of function evaluations performed.; status code :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For ea",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:1782,Deployability,integrat,integration,1782,"Minimum number of function evaluations requested. Must not exceed maxpts.; if minpts < 1 minpts is set to 2^n +2*n*(n+1) +1 where n is the function dimension; maxpts: Maximum number of function evaluations to be allowed.; maxpts >= 2^n +2*n*(n+1) +1; if maxpts<minpts, maxpts is set to 10*minpts; epstol, epsrel : Specified relative and absolute accuracy. The integral will stop if the relative error is less than relative tolerance OR the; absolute error is less than the absolute tolerance. The class computes in addition to the integral of the function is the desired interval:. an estimation of the relative accuracy of the result.; number of function evaluations performed.; status code :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2.Numerical integration usually works best for smooth functions.; Some analysis or suitable transformations of the integral prior to; numerical work may contribute to numerical efficiency. References:. 1.A.C. Genz and A.A. Malik, Remarks on algorithm 006:; An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302.; 2.A. van Doren and L. de Ridder, An adaptive algorithm for numerical; integration over an n-dimensional cube, J.Comput. Appl. Math. 2 (1976) 207-217. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMul",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:1964,Deployability,integrat,integration,1964,"on dimension; maxpts: Maximum number of function evaluations to be allowed.; maxpts >= 2^n +2*n*(n+1) +1; if maxpts<minpts, maxpts is set to 10*minpts; epstol, epsrel : Specified relative and absolute accuracy. The integral will stop if the relative error is less than relative tolerance OR the; absolute error is less than the absolute tolerance. The class computes in addition to the integral of the function is the desired interval:. an estimation of the relative accuracy of the result.; number of function evaluations performed.; status code :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2.Numerical integration usually works best for smooth functions.; Some analysis or suitable transformations of the integral prior to; numerical work may contribute to numerical efficiency. References:. 1.A.C. Genz and A.A. Malik, Remarks on algorithm 006:; An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302.; 2.A. van Doren and L. de Ridder, An adaptive algorithm for numerical; integration over an n-dimensional cube, J.Comput. Appl. Math. 2 (1976) 207-217. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:2167,Deployability,integrat,integration,2167,"egral will stop if the relative error is less than relative tolerance OR the; absolute error is less than the absolute tolerance. The class computes in addition to the integral of the function is the desired interval:. an estimation of the relative accuracy of the result.; number of function evaluations performed.; status code :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2.Numerical integration usually works best for smooth functions.; Some analysis or suitable transformations of the integral prior to; numerical work may contribute to numerical efficiency. References:. 1.A.C. Genz and A.A. Malik, Remarks on algorithm 006:; An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302.; 2.A. van Doren and L. de Ridder, An adaptive algorithm for numerical; integration over an n-dimensional cube, J.Comput. Appl. Math. 2 (1976) 207-217. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-9, double relTol = 1E-9, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol ",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:2448,Deployability,integrat,integration,2448,"racy of the result.; number of function evaluations performed.; status code :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2.Numerical integration usually works best for smooth functions.; Some analysis or suitable transformations of the integral prior to; numerical work may contribute to numerical efficiency. References:. 1.A.C. Genz and A.A. Malik, Remarks on algorithm 006:; An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302.; 2.A. van Doren and L. de Ridder, An adaptive algorithm for numerical; integration over an n-dimensional cube, J.Comput. Appl. Math. 2 (1976) 207-217. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-9, double relTol = 1E-9, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-9, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin,",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:2615,Deployability,integrat,integration,2615,"1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2.Numerical integration usually works best for smooth functions.; Some analysis or suitable transformations of the integral prior to; numerical work may contribute to numerical efficiency. References:. 1.A.C. Genz and A.A. Malik, Remarks on algorithm 006:; An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302.; 2.A. van Doren and L. de Ridder, An adaptive algorithm for numerical; integration over an n-dimensional cube, J.Comput. Appl. Math. 2 (1976) 207-217. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-9, double relTol = 1E-9, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-9, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); virtual intNEval() const; ROOT::Math::VirtualIntegratorMultiDim&ROOT::Math::VirtualIntegratorMultiDim::operator=(const ROOT::Math::VirtualIntegratorM",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:4742,Deployability,integrat,integration,4742,"th::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidSetRelTolerance(double relTol); voidSetSize(unsigned int size); virtual intStatus() const; virtual ROOT::Math::IntegrationMultiDim::TypeROOT::Math::VirtualIntegratorMultiDim::Type() const. protected:. doubleDoIntegral(const double* xmin, const double* xmax, bool absVal = false). Data Members; private:. doublefAbsTolabsolute tolerance; unsigned intfDimdimentionality of integrand; doublefErrorintegration error ; const ROOT::Math::IMultiGenFunction*fFunpointer to integrand function ; unsigned intfMaxPtsmaximum number of function evaluation requested ; unsigned intfMinPtsminimum number of function evaluation requested ; intfNEvalnumber of function evaluation; doublefRelErrorRelative error; doublefRelTolrelative tolerance; doublefResultlast integration result ; unsigned intfSizemax size of working array (explode with dimension); intfStatusstatus of algorithm (error if not zero). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; AdaptiveIntegratorMultiDim(double absTol = 1.E-9, double relTol = 1E-9, unsigned int maxpts = 100000, unsigned int size = 0). construct given optionally tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array.; The size of working array represents the number of sub-division used for calculating the integral.; Higher the dimension, larger sizes are required for getting the same accuracy.; The size must be larger than >= (2N + 3) * (1 + MAXPTS/(2**N + 2N(N + 1) + 1))/2). For smaller value passed, the; minimum allowed will be used. AdaptiveIntegratorMultiDi",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:6423,Deployability,integrat,integration,6423,"t be larger than >= (2N + 3) * (1 + MAXPTS/(2**N + 2N(N + 1) + 1))/2). For smaller value passed, the; minimum allowed will be used. AdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-9, unsigned int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operations). {}. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. return DoIntegral(const double* xmin, const double* xmax, bool absVal = false). double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. void SetFunction(const ROOT::Math::IMultiGenFunction& f); set the integration function (must implement multi-dim function interface: IBaseFunctionMultiDim). double Result() const; return result of integration. { return fResult; }. double Error() const; return integration error. { return fError; }. double RelError() const; return relative error. { return fRelError; }. int Status() const; return status of integration. { return fStatus; }. int NEval() const; return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTol); set relative tolerance. void SetAbsTolerance(double absTol); set absolute tolerance. void SetSize(unsigned int size); set workspace size. { fSize = size; }. void SetMinPts(unsigned int n); set min points. { fMinPts = n; }. void SetMaxPts(unsigned int n); set max points. { fMaxPts = n; }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options.  Author: M. Slawinska 08/2007  Copyright (c) 2007 , LCG ROOT MathLib Team *;  Last changed: root/mathcore:$Id$  Last ",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:6554,Deployability,integrat,integration,6554,"imum allowed will be used. AdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-9, unsigned int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operations). {}. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. return DoIntegral(const double* xmin, const double* xmax, bool absVal = false). double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. void SetFunction(const ROOT::Math::IMultiGenFunction& f); set the integration function (must implement multi-dim function interface: IBaseFunctionMultiDim). double Result() const; return result of integration. { return fResult; }. double Error() const; return integration error. { return fError; }. double RelError() const; return relative error. { return fRelError; }. int Status() const; return status of integration. { return fStatus; }. int NEval() const; return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTol); set relative tolerance. void SetAbsTolerance(double absTol); set absolute tolerance. void SetSize(unsigned int size); set workspace size. { fSize = size; }. void SetMinPts(unsigned int n); set min points. { fMinPts = n; }. void SetMaxPts(unsigned int n); set max points. { fMaxPts = n; }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options.  Author: M. Slawinska 08/2007  Copyright (c) 2007 , LCG ROOT MathLib Team *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions rega",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:6617,Deployability,integrat,integration,6617,"IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-9, unsigned int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operations). {}. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. return DoIntegral(const double* xmin, const double* xmax, bool absVal = false). double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. void SetFunction(const ROOT::Math::IMultiGenFunction& f); set the integration function (must implement multi-dim function interface: IBaseFunctionMultiDim). double Result() const; return result of integration. { return fResult; }. double Error() const; return integration error. { return fError; }. double RelError() const; return relative error. { return fRelError; }. int Status() const; return status of integration. { return fStatus; }. int NEval() const; return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTol); set relative tolerance. void SetAbsTolerance(double absTol); set absolute tolerance. void SetSize(unsigned int size); set workspace size. { fSize = size; }. void SetMinPts(unsigned int n); set min points. { fMinPts = n; }. void SetMaxPts(unsigned int n); set max points. { fMaxPts = n; }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options.  Author: M. Slawinska 08/2007  Copyright (c) 2007 , LCG ROOT MathLib Team *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT s",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:6764,Deployability,integrat,integration,6764,"nFunction& f, double absTol = 1.E-9, double relTol = 1E-9, unsigned int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operations). {}. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. return DoIntegral(const double* xmin, const double* xmax, bool absVal = false). double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. void SetFunction(const ROOT::Math::IMultiGenFunction& f); set the integration function (must implement multi-dim function interface: IBaseFunctionMultiDim). double Result() const; return result of integration. { return fResult; }. double Error() const; return integration error. { return fError; }. double RelError() const; return relative error. { return fRelError; }. int Status() const; return status of integration. { return fStatus; }. int NEval() const; return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTol); set relative tolerance. void SetAbsTolerance(double absTol); set absolute tolerance. void SetSize(unsigned int size); set workspace size. { fSize = size; }. void SetMinPts(unsigned int n); set min points. { fMinPts = n; }. void SetMaxPts(unsigned int n); set max points. { fMaxPts = n; }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options.  Author: M. Slawinska 08/2007  Copyright (c) 2007 , LCG ROOT MathLib Team *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:395,Energy Efficiency,adapt,adaptive,395,". ROOT::Math::AdaptiveIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::AdaptiveIntegratorMultiDim. class ROOT::Math::AdaptiveIntegratorMultiDim: public ROOT::Math::VirtualIntegratorMultiDim. class for adaptive quadrature integration in multi-dimensions using rectangular regions.; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. Control parameters are:. minpts: Minimum number of function evaluations requested. Must not exceed maxpts.; if minpts < 1 minpts is set to 2^n +2*n*(n+1) +1 where n is the function dimension; maxpts: Maximum number of function evaluations to be allowed.; maxpts >= 2^n +2*n*(n+1) +1; if maxpts<minpts, maxpts is set to 10*minpts; epstol, epsrel : Specified relative and absolute accuracy. The integral will stop if the relative error is less than relative tolerance OR the; absolute error is less than the absolute tolerance. The class computes in addition to the integral of the function is the desired interval:. an estimation of the relative accuracy of the result.; number of function evaluations performed.; status code :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For ea",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:516,Energy Efficiency,adapt,adaptive,516,". ROOT::Math::AdaptiveIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::AdaptiveIntegratorMultiDim. class ROOT::Math::AdaptiveIntegratorMultiDim: public ROOT::Math::VirtualIntegratorMultiDim. class for adaptive quadrature integration in multi-dimensions using rectangular regions.; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. Control parameters are:. minpts: Minimum number of function evaluations requested. Must not exceed maxpts.; if minpts < 1 minpts is set to 2^n +2*n*(n+1) +1 where n is the function dimension; maxpts: Maximum number of function evaluations to be allowed.; maxpts >= 2^n +2*n*(n+1) +1; if maxpts<minpts, maxpts is set to 10*minpts; epstol, epsrel : Specified relative and absolute accuracy. The integral will stop if the relative error is less than relative tolerance OR the; absolute error is less than the absolute tolerance. The class computes in addition to the integral of the function is the desired interval:. an estimation of the relative accuracy of the result.; number of function evaluations performed.; status code :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For ea",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:655,Energy Efficiency,adapt,adapted,655,". ROOT::Math::AdaptiveIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::AdaptiveIntegratorMultiDim. class ROOT::Math::AdaptiveIntegratorMultiDim: public ROOT::Math::VirtualIntegratorMultiDim. class for adaptive quadrature integration in multi-dimensions using rectangular regions.; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. Control parameters are:. minpts: Minimum number of function evaluations requested. Must not exceed maxpts.; if minpts < 1 minpts is set to 2^n +2*n*(n+1) +1 where n is the function dimension; maxpts: Maximum number of function evaluations to be allowed.; maxpts >= 2^n +2*n*(n+1) +1; if maxpts<minpts, maxpts is set to 10*minpts; epstol, epsrel : Specified relative and absolute accuracy. The integral will stop if the relative error is less than relative tolerance OR the; absolute error is less than the absolute tolerance. The class computes in addition to the integral of the function is the desired interval:. an estimation of the relative accuracy of the result.; number of function evaluations performed.; status code :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For ea",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:2415,Energy Efficiency,adapt,adaptive,2415,"racy of the result.; number of function evaluations performed.; status code :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2.Numerical integration usually works best for smooth functions.; Some analysis or suitable transformations of the integral prior to; numerical work may contribute to numerical efficiency. References:. 1.A.C. Genz and A.A. Malik, Remarks on algorithm 006:; An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302.; 2.A. van Doren and L. de Ridder, An adaptive algorithm for numerical; integration over an n-dimensional cube, J.Comput. Appl. Math. 2 (1976) 207-217. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-9, double relTol = 1E-9, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-9, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin,",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:2581,Energy Efficiency,adapt,adaptive,2581,"1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2.Numerical integration usually works best for smooth functions.; Some analysis or suitable transformations of the integral prior to; numerical work may contribute to numerical efficiency. References:. 1.A.C. Genz and A.A. Malik, Remarks on algorithm 006:; An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302.; 2.A. van Doren and L. de Ridder, An adaptive algorithm for numerical; integration over an n-dimensional cube, J.Comput. Appl. Math. 2 (1976) 207-217. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-9, double relTol = 1E-9, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-9, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); virtual intNEval() const; ROOT::Math::VirtualIntegratorMultiDim&ROOT::Math::VirtualIntegratorMultiDim::operator=(const ROOT::Math::VirtualIntegratorM",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:415,Integrability,integrat,integration,415,". ROOT::Math::AdaptiveIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::AdaptiveIntegratorMultiDim. class ROOT::Math::AdaptiveIntegratorMultiDim: public ROOT::Math::VirtualIntegratorMultiDim. class for adaptive quadrature integration in multi-dimensions using rectangular regions.; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. Control parameters are:. minpts: Minimum number of function evaluations requested. Must not exceed maxpts.; if minpts < 1 minpts is set to 2^n +2*n*(n+1) +1 where n is the function dimension; maxpts: Maximum number of function evaluations to be allowed.; maxpts >= 2^n +2*n*(n+1) +1; if maxpts<minpts, maxpts is set to 10*minpts; epstol, epsrel : Specified relative and absolute accuracy. The integral will stop if the relative error is less than relative tolerance OR the; absolute error is less than the absolute tolerance. The class computes in addition to the integral of the function is the desired interval:. an estimation of the relative accuracy of the result.; number of function evaluations performed.; status code :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For ea",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:549,Integrability,integrat,integration,549,". ROOT::Math::AdaptiveIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::AdaptiveIntegratorMultiDim. class ROOT::Math::AdaptiveIntegratorMultiDim: public ROOT::Math::VirtualIntegratorMultiDim. class for adaptive quadrature integration in multi-dimensions using rectangular regions.; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. Control parameters are:. minpts: Minimum number of function evaluations requested. Must not exceed maxpts.; if minpts < 1 minpts is set to 2^n +2*n*(n+1) +1 where n is the function dimension; maxpts: Maximum number of function evaluations to be allowed.; maxpts >= 2^n +2*n*(n+1) +1; if maxpts<minpts, maxpts is set to 10*minpts; epstol, epsrel : Specified relative and absolute accuracy. The integral will stop if the relative error is less than relative tolerance OR the; absolute error is less than the absolute tolerance. The class computes in addition to the integral of the function is the desired interval:. an estimation of the relative accuracy of the result.; number of function evaluations performed.; status code :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For ea",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:701,Integrability,rout,routine,701,". ROOT::Math::AdaptiveIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::AdaptiveIntegratorMultiDim. class ROOT::Math::AdaptiveIntegratorMultiDim: public ROOT::Math::VirtualIntegratorMultiDim. class for adaptive quadrature integration in multi-dimensions using rectangular regions.; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. Control parameters are:. minpts: Minimum number of function evaluations requested. Must not exceed maxpts.; if minpts < 1 minpts is set to 2^n +2*n*(n+1) +1 where n is the function dimension; maxpts: Maximum number of function evaluations to be allowed.; maxpts >= 2^n +2*n*(n+1) +1; if maxpts<minpts, maxpts is set to 10*minpts; epstol, epsrel : Specified relative and absolute accuracy. The integral will stop if the relative error is less than relative tolerance OR the; absolute error is less than the absolute tolerance. The class computes in addition to the integral of the function is the desired interval:. an estimation of the relative accuracy of the result.; number of function evaluations performed.; status code :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For ea",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:1782,Integrability,integrat,integration,1782,"Minimum number of function evaluations requested. Must not exceed maxpts.; if minpts < 1 minpts is set to 2^n +2*n*(n+1) +1 where n is the function dimension; maxpts: Maximum number of function evaluations to be allowed.; maxpts >= 2^n +2*n*(n+1) +1; if maxpts<minpts, maxpts is set to 10*minpts; epstol, epsrel : Specified relative and absolute accuracy. The integral will stop if the relative error is less than relative tolerance OR the; absolute error is less than the absolute tolerance. The class computes in addition to the integral of the function is the desired interval:. an estimation of the relative accuracy of the result.; number of function evaluations performed.; status code :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2.Numerical integration usually works best for smooth functions.; Some analysis or suitable transformations of the integral prior to; numerical work may contribute to numerical efficiency. References:. 1.A.C. Genz and A.A. Malik, Remarks on algorithm 006:; An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302.; 2.A. van Doren and L. de Ridder, An adaptive algorithm for numerical; integration over an n-dimensional cube, J.Comput. Appl. Math. 2 (1976) 207-217. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMul",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:1964,Integrability,integrat,integration,1964,"on dimension; maxpts: Maximum number of function evaluations to be allowed.; maxpts >= 2^n +2*n*(n+1) +1; if maxpts<minpts, maxpts is set to 10*minpts; epstol, epsrel : Specified relative and absolute accuracy. The integral will stop if the relative error is less than relative tolerance OR the; absolute error is less than the absolute tolerance. The class computes in addition to the integral of the function is the desired interval:. an estimation of the relative accuracy of the result.; number of function evaluations performed.; status code :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2.Numerical integration usually works best for smooth functions.; Some analysis or suitable transformations of the integral prior to; numerical work may contribute to numerical efficiency. References:. 1.A.C. Genz and A.A. Malik, Remarks on algorithm 006:; An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302.; 2.A. van Doren and L. de Ridder, An adaptive algorithm for numerical; integration over an n-dimensional cube, J.Comput. Appl. Math. 2 (1976) 207-217. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:2032,Integrability,rout,routine,2032,"o be allowed.; maxpts >= 2^n +2*n*(n+1) +1; if maxpts<minpts, maxpts is set to 10*minpts; epstol, epsrel : Specified relative and absolute accuracy. The integral will stop if the relative error is less than relative tolerance OR the; absolute error is less than the absolute tolerance. The class computes in addition to the integral of the function is the desired interval:. an estimation of the relative accuracy of the result.; number of function evaluations performed.; status code :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2.Numerical integration usually works best for smooth functions.; Some analysis or suitable transformations of the integral prior to; numerical work may contribute to numerical efficiency. References:. 1.A.C. Genz and A.A. Malik, Remarks on algorithm 006:; An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302.; 2.A. van Doren and L. de Ridder, An adaptive algorithm for numerical; integration over an n-dimensional cube, J.Comput. Appl. Math. 2 (1976) 207-217. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-9, double relTol = 1E-9, unsigned int maxp",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:2167,Integrability,integrat,integration,2167,"egral will stop if the relative error is less than relative tolerance OR the; absolute error is less than the absolute tolerance. The class computes in addition to the integral of the function is the desired interval:. an estimation of the relative accuracy of the result.; number of function evaluations performed.; status code :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2.Numerical integration usually works best for smooth functions.; Some analysis or suitable transformations of the integral prior to; numerical work may contribute to numerical efficiency. References:. 1.A.C. Genz and A.A. Malik, Remarks on algorithm 006:; An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302.; 2.A. van Doren and L. de Ridder, An adaptive algorithm for numerical; integration over an n-dimensional cube, J.Comput. Appl. Math. 2 (1976) 207-217. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-9, double relTol = 1E-9, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol ",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:2448,Integrability,integrat,integration,2448,"racy of the result.; number of function evaluations performed.; status code :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2.Numerical integration usually works best for smooth functions.; Some analysis or suitable transformations of the integral prior to; numerical work may contribute to numerical efficiency. References:. 1.A.C. Genz and A.A. Malik, Remarks on algorithm 006:; An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302.; 2.A. van Doren and L. de Ridder, An adaptive algorithm for numerical; integration over an n-dimensional cube, J.Comput. Appl. Math. 2 (1976) 207-217. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-9, double relTol = 1E-9, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-9, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin,",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:2615,Integrability,integrat,integration,2615,"1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2.Numerical integration usually works best for smooth functions.; Some analysis or suitable transformations of the integral prior to; numerical work may contribute to numerical efficiency. References:. 1.A.C. Genz and A.A. Malik, Remarks on algorithm 006:; An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302.; 2.A. van Doren and L. de Ridder, An adaptive algorithm for numerical; integration over an n-dimensional cube, J.Comput. Appl. Math. 2 (1976) 207-217. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-9, double relTol = 1E-9, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-9, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); virtual intNEval() const; ROOT::Math::VirtualIntegratorMultiDim&ROOT::Math::VirtualIntegratorMultiDim::operator=(const ROOT::Math::VirtualIntegratorM",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:4742,Integrability,integrat,integration,4742,"th::VirtualIntegratorMultiDim&); virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleRelError() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTol); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetMaxPts(unsigned int n); voidSetMinPts(unsigned int n); virtual voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); virtual voidSetRelTolerance(double relTol); voidSetSize(unsigned int size); virtual intStatus() const; virtual ROOT::Math::IntegrationMultiDim::TypeROOT::Math::VirtualIntegratorMultiDim::Type() const. protected:. doubleDoIntegral(const double* xmin, const double* xmax, bool absVal = false). Data Members; private:. doublefAbsTolabsolute tolerance; unsigned intfDimdimentionality of integrand; doublefErrorintegration error ; const ROOT::Math::IMultiGenFunction*fFunpointer to integrand function ; unsigned intfMaxPtsmaximum number of function evaluation requested ; unsigned intfMinPtsminimum number of function evaluation requested ; intfNEvalnumber of function evaluation; doublefRelErrorRelative error; doublefRelTolrelative tolerance; doublefResultlast integration result ; unsigned intfSizemax size of working array (explode with dimension); intfStatusstatus of algorithm (error if not zero). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; AdaptiveIntegratorMultiDim(double absTol = 1.E-9, double relTol = 1E-9, unsigned int maxpts = 100000, unsigned int size = 0). construct given optionally tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array.; The size of working array represents the number of sub-division used for calculating the integral.; Higher the dimension, larger sizes are required for getting the same accuracy.; The size must be larger than >= (2N + 3) * (1 + MAXPTS/(2**N + 2N(N + 1) + 1))/2). For smaller value passed, the; minimum allowed will be used. AdaptiveIntegratorMultiDi",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:6423,Integrability,integrat,integration,6423,"t be larger than >= (2N + 3) * (1 + MAXPTS/(2**N + 2N(N + 1) + 1))/2). For smaller value passed, the; minimum allowed will be used. AdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-9, unsigned int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operations). {}. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. return DoIntegral(const double* xmin, const double* xmax, bool absVal = false). double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. void SetFunction(const ROOT::Math::IMultiGenFunction& f); set the integration function (must implement multi-dim function interface: IBaseFunctionMultiDim). double Result() const; return result of integration. { return fResult; }. double Error() const; return integration error. { return fError; }. double RelError() const; return relative error. { return fRelError; }. int Status() const; return status of integration. { return fStatus; }. int NEval() const; return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTol); set relative tolerance. void SetAbsTolerance(double absTol); set absolute tolerance. void SetSize(unsigned int size); set workspace size. { fSize = size; }. void SetMinPts(unsigned int n); set min points. { fMinPts = n; }. void SetMaxPts(unsigned int n); set max points. { fMaxPts = n; }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options.  Author: M. Slawinska 08/2007  Copyright (c) 2007 , LCG ROOT MathLib Team *;  Last changed: root/mathcore:$Id$  Last ",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:6479,Integrability,interface,interface,6479,"t be larger than >= (2N + 3) * (1 + MAXPTS/(2**N + 2N(N + 1) + 1))/2). For smaller value passed, the; minimum allowed will be used. AdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-9, unsigned int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operations). {}. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. return DoIntegral(const double* xmin, const double* xmax, bool absVal = false). double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. void SetFunction(const ROOT::Math::IMultiGenFunction& f); set the integration function (must implement multi-dim function interface: IBaseFunctionMultiDim). double Result() const; return result of integration. { return fResult; }. double Error() const; return integration error. { return fError; }. double RelError() const; return relative error. { return fRelError; }. int Status() const; return status of integration. { return fStatus; }. int NEval() const; return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTol); set relative tolerance. void SetAbsTolerance(double absTol); set absolute tolerance. void SetSize(unsigned int size); set workspace size. { fSize = size; }. void SetMinPts(unsigned int n); set min points. { fMinPts = n; }. void SetMaxPts(unsigned int n); set max points. { fMaxPts = n; }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options.  Author: M. Slawinska 08/2007  Copyright (c) 2007 , LCG ROOT MathLib Team *;  Last changed: root/mathcore:$Id$  Last ",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:6554,Integrability,integrat,integration,6554,"imum allowed will be used. AdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-9, unsigned int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operations). {}. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. return DoIntegral(const double* xmin, const double* xmax, bool absVal = false). double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. void SetFunction(const ROOT::Math::IMultiGenFunction& f); set the integration function (must implement multi-dim function interface: IBaseFunctionMultiDim). double Result() const; return result of integration. { return fResult; }. double Error() const; return integration error. { return fError; }. double RelError() const; return relative error. { return fRelError; }. int Status() const; return status of integration. { return fStatus; }. int NEval() const; return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTol); set relative tolerance. void SetAbsTolerance(double absTol); set absolute tolerance. void SetSize(unsigned int size); set workspace size. { fSize = size; }. void SetMinPts(unsigned int n); set min points. { fMinPts = n; }. void SetMaxPts(unsigned int n); set max points. { fMaxPts = n; }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options.  Author: M. Slawinska 08/2007  Copyright (c) 2007 , LCG ROOT MathLib Team *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions rega",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:6617,Integrability,integrat,integration,6617,"IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-9, unsigned int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operations). {}. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. return DoIntegral(const double* xmin, const double* xmax, bool absVal = false). double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. void SetFunction(const ROOT::Math::IMultiGenFunction& f); set the integration function (must implement multi-dim function interface: IBaseFunctionMultiDim). double Result() const; return result of integration. { return fResult; }. double Error() const; return integration error. { return fError; }. double RelError() const; return relative error. { return fRelError; }. int Status() const; return status of integration. { return fStatus; }. int NEval() const; return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTol); set relative tolerance. void SetAbsTolerance(double absTol); set absolute tolerance. void SetSize(unsigned int size); set workspace size. { fSize = size; }. void SetMinPts(unsigned int n); set min points. { fMinPts = n; }. void SetMaxPts(unsigned int n); set max points. { fMaxPts = n; }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options.  Author: M. Slawinska 08/2007  Copyright (c) 2007 , LCG ROOT MathLib Team *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT s",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:6764,Integrability,integrat,integration,6764,"nFunction& f, double absTol = 1.E-9, double relTol = 1E-9, unsigned int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operations). {}. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. return DoIntegral(const double* xmin, const double* xmax, bool absVal = false). double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. void SetFunction(const ROOT::Math::IMultiGenFunction& f); set the integration function (must implement multi-dim function interface: IBaseFunctionMultiDim). double Result() const; return result of integration. { return fResult; }. double Error() const; return integration error. { return fError; }. double RelError() const; return relative error. { return fRelError; }. int Status() const; return status of integration. { return fStatus; }. int NEval() const; return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTol); set relative tolerance. void SetAbsTolerance(double absTol); set absolute tolerance. void SetSize(unsigned int size); set workspace size. { fSize = size; }. void SetMinPts(unsigned int n); set min points. { fMinPts = n; }. void SetMaxPts(unsigned int n); set max points. { fMaxPts = n; }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options.  Author: M. Slawinska 08/2007  Copyright (c) 2007 , LCG ROOT MathLib Team *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:395,Modifiability,adapt,adaptive,395,". ROOT::Math::AdaptiveIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::AdaptiveIntegratorMultiDim. class ROOT::Math::AdaptiveIntegratorMultiDim: public ROOT::Math::VirtualIntegratorMultiDim. class for adaptive quadrature integration in multi-dimensions using rectangular regions.; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. Control parameters are:. minpts: Minimum number of function evaluations requested. Must not exceed maxpts.; if minpts < 1 minpts is set to 2^n +2*n*(n+1) +1 where n is the function dimension; maxpts: Maximum number of function evaluations to be allowed.; maxpts >= 2^n +2*n*(n+1) +1; if maxpts<minpts, maxpts is set to 10*minpts; epstol, epsrel : Specified relative and absolute accuracy. The integral will stop if the relative error is less than relative tolerance OR the; absolute error is less than the absolute tolerance. The class computes in addition to the integral of the function is the desired interval:. an estimation of the relative accuracy of the result.; number of function evaluations performed.; status code :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For ea",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:516,Modifiability,adapt,adaptive,516,". ROOT::Math::AdaptiveIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::AdaptiveIntegratorMultiDim. class ROOT::Math::AdaptiveIntegratorMultiDim: public ROOT::Math::VirtualIntegratorMultiDim. class for adaptive quadrature integration in multi-dimensions using rectangular regions.; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. Control parameters are:. minpts: Minimum number of function evaluations requested. Must not exceed maxpts.; if minpts < 1 minpts is set to 2^n +2*n*(n+1) +1 where n is the function dimension; maxpts: Maximum number of function evaluations to be allowed.; maxpts >= 2^n +2*n*(n+1) +1; if maxpts<minpts, maxpts is set to 10*minpts; epstol, epsrel : Specified relative and absolute accuracy. The integral will stop if the relative error is less than relative tolerance OR the; absolute error is less than the absolute tolerance. The class computes in addition to the integral of the function is the desired interval:. an estimation of the relative accuracy of the result.; number of function evaluations performed.; status code :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For ea",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:655,Modifiability,adapt,adapted,655,". ROOT::Math::AdaptiveIntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::AdaptiveIntegratorMultiDim. class ROOT::Math::AdaptiveIntegratorMultiDim: public ROOT::Math::VirtualIntegratorMultiDim. class for adaptive quadrature integration in multi-dimensions using rectangular regions.; Algorithm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. Control parameters are:. minpts: Minimum number of function evaluations requested. Must not exceed maxpts.; if minpts < 1 minpts is set to 2^n +2*n*(n+1) +1 where n is the function dimension; maxpts: Maximum number of function evaluations to be allowed.; maxpts >= 2^n +2*n*(n+1) +1; if maxpts<minpts, maxpts is set to 10*minpts; epstol, epsrel : Specified relative and absolute accuracy. The integral will stop if the relative error is less than relative tolerance OR the; absolute error is less than the absolute tolerance. The class computes in addition to the integral of the function is the desired interval:. an estimation of the relative accuracy of the result.; number of function evaluations performed.; status code :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For ea",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:2415,Modifiability,adapt,adaptive,2415,"racy of the result.; number of function evaluations performed.; status code :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2.Numerical integration usually works best for smooth functions.; Some analysis or suitable transformations of the integral prior to; numerical work may contribute to numerical efficiency. References:. 1.A.C. Genz and A.A. Malik, Remarks on algorithm 006:; An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302.; 2.A. van Doren and L. de Ridder, An adaptive algorithm for numerical; integration over an n-dimensional cube, J.Comput. Appl. Math. 2 (1976) 207-217. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-9, double relTol = 1E-9, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-9, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin,",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:2581,Modifiability,adapt,adaptive,2581,"1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2.Numerical integration usually works best for smooth functions.; Some analysis or suitable transformations of the integral prior to; numerical work may contribute to numerical efficiency. References:. 1.A.C. Genz and A.A. Malik, Remarks on algorithm 006:; An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302.; 2.A. van Doren and L. de Ridder, An adaptive algorithm for numerical; integration over an n-dimensional cube, J.Comput. Appl. Math. 2 (1976) 207-217. @ingroup Integration. Function Members (Methods); public:. virtual~AdaptiveIntegratorMultiDim(); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::AdaptiveIntegratorMultiDim&); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(double absTol = 1.E-9, double relTol = 1E-9, unsigned int maxpts = 100000, unsigned int size = 0); ROOT::Math::AdaptiveIntegratorMultiDimAdaptiveIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, double absTol = 1.E-9, double relTol = 1E-9, unsigned int maxcall = 100000, unsigned int size = 0); virtual doubleError() const; virtual doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); virtual intNEval() const; ROOT::Math::VirtualIntegratorMultiDim&ROOT::Math::VirtualIntegratorMultiDim::operator=(const ROOT::Math::VirtualIntegratorM",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:1493,Performance,perform,performed,1493,"thm from A.C. Genz, A.A. Malik, An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. Control parameters are:. minpts: Minimum number of function evaluations requested. Must not exceed maxpts.; if minpts < 1 minpts is set to 2^n +2*n*(n+1) +1 where n is the function dimension; maxpts: Maximum number of function evaluations to be allowed.; maxpts >= 2^n +2*n*(n+1) +1; if maxpts<minpts, maxpts is set to 10*minpts; epstol, epsrel : Specified relative and absolute accuracy. The integral will stop if the relative error is less than relative tolerance OR the; absolute error is less than the absolute tolerance. The class computes in addition to the integral of the function is the desired interval:. an estimation of the relative accuracy of the result.; number of function evaluations performed.; status code :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2.Numerical integration usually works best for smooth functions.; Some analysis or suitable transformations of the integral prior to; numerical work may contribute to numerical efficiency. References:. 1.A.C. Genz and A.A. Malik, Remarks on algorithm 006:; An adaptive algorithm for numerical integration over; an N-dimensional",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html:1599,Performance,perform,performed,1599,"dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. Converted/adapted by R.Brun to C++ from Fortran CERNLIB routine RADMUL (D120); The new code features many changes compared to the Fortran version. Control parameters are:. minpts: Minimum number of function evaluations requested. Must not exceed maxpts.; if minpts < 1 minpts is set to 2^n +2*n*(n+1) +1 where n is the function dimension; maxpts: Maximum number of function evaluations to be allowed.; maxpts >= 2^n +2*n*(n+1) +1; if maxpts<minpts, maxpts is set to 10*minpts; epstol, epsrel : Specified relative and absolute accuracy. The integral will stop if the relative error is less than relative tolerance OR the; absolute error is less than the absolute tolerance. The class computes in addition to the integral of the function is the desired interval:. an estimation of the relative accuracy of the result.; number of function evaluations performed.; status code :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. An integration rule of degree seven is used together with a certain; strategy of subdivision.; For a more detailed description of the method see References. Notes:. 1.Multi-dimensional integration is time-consuming. For each rectangular; subregion, the routine requires function evaluations.; Careful programming of the integrand might result in substantial saving; of time.; 2.Numerical integration usually works best for smooth functions.; Some analysis or suitable transformations of the integral prior to; numerical work may contribute to numerical efficiency. References:. 1.A.C. Genz and A.A. Malik, Remarks on algorithm 006:; An adaptive algorithm for numerical integration over; an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302.; 2.A. van Doren and L. de Rid",MatchSource.WIKI,root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AdaptiveIntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__AxisAngle.html:5223,Security,access,access,5223,"e canonical range (-pi,pi]. explicit AxisAngle(const ROOT::Math::AxisAngle& ); ======== Construction From other Rotation Forms ==================. Construct from another supported rotation type (see gv_detail::convert ). {gv_detail::convert(r,*this);}. AxisAngle & operator=( OtherRotation const & r ). Assign from another supported rotation type (see gv_detail::convert ). void SetComponents(double* begin, double* end); ======== Components ==============. Set the axis and then the angle given a pair of pointers or iterators; defining the beginning and end of an array of four Scalars.; Precondition: The first three components are assumed to represent; the rotation axis vector and the 4-th the rotation angle.; The angle is assumed to be in the range (-pi,pi].; The axis vector is automatically normalized to be a unit vector. void GetComponents(IT begin, IT end). Get the axis and then the angle into data specified by an iterator begin; and another to the end of the desired data (4 past start). Scalar Angle() const. access to rotation angle. { return fAngle; }. XYZVector operator()(const ROOT::Math::AxisAngle::XYZVector& v) const. AVector operator*(const AVector & v). Overload operator * for rotation on a vector. void Invert(). Invert an AxisAngle rotation in place. { fAngle = -fAngle; }. AxisAngle Inverse() const. Return inverse of an AxisAngle rotation. { AxisAngle result(*this); result.Invert(); return result; }. return ! operator==(rhs). void RectifyAngle(). double Pi(); { return 3.14159265358979323; }. AxisAngle operator*(RotationX const & r1, AxisAngle const & r2). Multiplication of an axial rotation by an AxisAngle. AxisAngle operator*(RotationY const & r1, AxisAngle const & r2). AxisAngle operator*(RotationZ const & r1, AxisAngle const & r2).  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__AxisAngle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__AxisAngle.html
https://root.cern/root/html534/ROOT__Math__BaseIntegratorOptions.html:638,Availability,avail,available,638,". ROOT::Math::BaseIntegratorOptions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::BaseIntegratorOptions. class ROOT::Math::BaseIntegratorOptions. Base class for Numerical integration options; common in 1D and multi-dimension; This is an internal class and is not supposed to be instantiated by the user. @ingroup Integration. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~BaseIntegratorOptions(); doubleAbsTolerance() const; ROOT::Math::IOptions*ExtraOptions() const; virtual stringIntegrator() const; ROOT::Math::BaseIntegratorOptions&operator=(const ROOT::Math::BaseIntegratorOptions& opt); doubleRelTolerance() const; voidSetAbsTolerance(double tol); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetRelTolerance(double tol); voidSetWKSize(unsigned int size); unsigned intWKSize() const. protected:. voidClearExtra(). Data Members; protected:. doublefAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*fExtraOptionsextra options ; intfIntegTypeIntegrator type (value converted from enum); unsigned intfNCalls(max) funxtion calls; doublefRelTolerancerelative tolerance ; unsigned intfWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::BaseIntegratorOptions& opt); assignment operators. virtual ~BaseIntegratorOptions(); protected constructor to avoid user creating this class. { ClearExtra(); }. std::string Integrator() const; name of 1D integrator. double AbsTolerance() const; non-static methods for retrivieng options ; absolute tolerance. { return fAbsTolerance; }. double RelTolerance() const; absolute tolerance. { return fRelTolerance; }. unsigned int WK",MatchSource.WIKI,root/html534/ROOT__Math__BaseIntegratorOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BaseIntegratorOptions.html
https://root.cern/root/html534/ROOT__Math__BaseIntegratorOptions.html:1195,Availability,toler,tolerance,1195,"h::BaseIntegratorOptions. Base class for Numerical integration options; common in 1D and multi-dimension; This is an internal class and is not supposed to be instantiated by the user. @ingroup Integration. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~BaseIntegratorOptions(); doubleAbsTolerance() const; ROOT::Math::IOptions*ExtraOptions() const; virtual stringIntegrator() const; ROOT::Math::BaseIntegratorOptions&operator=(const ROOT::Math::BaseIntegratorOptions& opt); doubleRelTolerance() const; voidSetAbsTolerance(double tol); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetRelTolerance(double tol); voidSetWKSize(unsigned int size); unsigned intWKSize() const. protected:. voidClearExtra(). Data Members; protected:. doublefAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*fExtraOptionsextra options ; intfIntegTypeIntegrator type (value converted from enum); unsigned intfNCalls(max) funxtion calls; doublefRelTolerancerelative tolerance ; unsigned intfWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::BaseIntegratorOptions& opt); assignment operators. virtual ~BaseIntegratorOptions(); protected constructor to avoid user creating this class. { ClearExtra(); }. std::string Integrator() const; name of 1D integrator. double AbsTolerance() const; non-static methods for retrivieng options ; absolute tolerance. { return fAbsTolerance; }. double RelTolerance() const; absolute tolerance. { return fRelTolerance; }. unsigned int WKSize() const; size of the workspace. { return fWKSize; }. IOptions * ExtraOptions() const; return extra options. { return fExtraOptions; }. void SetAbsTolerance(double tol); non-static methods for setting options ; set the abs tolerance. { fAbsTolerance = tol; }. void SetRelTolerance(double tol);",MatchSource.WIKI,root/html534/ROOT__Math__BaseIntegratorOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BaseIntegratorOptions.html
https://root.cern/root/html534/ROOT__Math__BaseIntegratorOptions.html:1384,Availability,toler,tolerance,1384,"h::BaseIntegratorOptions. Base class for Numerical integration options; common in 1D and multi-dimension; This is an internal class and is not supposed to be instantiated by the user. @ingroup Integration. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~BaseIntegratorOptions(); doubleAbsTolerance() const; ROOT::Math::IOptions*ExtraOptions() const; virtual stringIntegrator() const; ROOT::Math::BaseIntegratorOptions&operator=(const ROOT::Math::BaseIntegratorOptions& opt); doubleRelTolerance() const; voidSetAbsTolerance(double tol); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetRelTolerance(double tol); voidSetWKSize(unsigned int size); unsigned intWKSize() const. protected:. voidClearExtra(). Data Members; protected:. doublefAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*fExtraOptionsextra options ; intfIntegTypeIntegrator type (value converted from enum); unsigned intfNCalls(max) funxtion calls; doublefRelTolerancerelative tolerance ; unsigned intfWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::BaseIntegratorOptions& opt); assignment operators. virtual ~BaseIntegratorOptions(); protected constructor to avoid user creating this class. { ClearExtra(); }. std::string Integrator() const; name of 1D integrator. double AbsTolerance() const; non-static methods for retrivieng options ; absolute tolerance. { return fAbsTolerance; }. double RelTolerance() const; absolute tolerance. { return fRelTolerance; }. unsigned int WKSize() const; size of the workspace. { return fWKSize; }. IOptions * ExtraOptions() const; return extra options. { return fExtraOptions; }. void SetAbsTolerance(double tol); non-static methods for setting options ; set the abs tolerance. { fAbsTolerance = tol; }. void SetRelTolerance(double tol);",MatchSource.WIKI,root/html534/ROOT__Math__BaseIntegratorOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BaseIntegratorOptions.html
https://root.cern/root/html534/ROOT__Math__BaseIntegratorOptions.html:1872,Availability,toler,tolerance,1872,"rOptions&operator=(const ROOT::Math::BaseIntegratorOptions& opt); doubleRelTolerance() const; voidSetAbsTolerance(double tol); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetRelTolerance(double tol); voidSetWKSize(unsigned int size); unsigned intWKSize() const. protected:. voidClearExtra(). Data Members; protected:. doublefAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*fExtraOptionsextra options ; intfIntegTypeIntegrator type (value converted from enum); unsigned intfNCalls(max) funxtion calls; doublefRelTolerancerelative tolerance ; unsigned intfWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::BaseIntegratorOptions& opt); assignment operators. virtual ~BaseIntegratorOptions(); protected constructor to avoid user creating this class. { ClearExtra(); }. std::string Integrator() const; name of 1D integrator. double AbsTolerance() const; non-static methods for retrivieng options ; absolute tolerance. { return fAbsTolerance; }. double RelTolerance() const; absolute tolerance. { return fRelTolerance; }. unsigned int WKSize() const; size of the workspace. { return fWKSize; }. IOptions * ExtraOptions() const; return extra options. { return fExtraOptions; }. void SetAbsTolerance(double tol); non-static methods for setting options ; set the abs tolerance. { fAbsTolerance = tol; }. void SetRelTolerance(double tol); set the relative tolerance. { fRelTolerance = tol; }. void SetWKSize(unsigned int size); set workspace size. { fWKSize = size; }. void SetExtraOptions(const ROOT::Math::IOptions& opt); set extra options (in this case pointer is cloned). void ClearExtra().  Author: L. Moneta Fri Aug 15 2008  Copyright (c) 2008 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general",MatchSource.WIKI,root/html534/ROOT__Math__BaseIntegratorOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BaseIntegratorOptions.html
https://root.cern/root/html534/ROOT__Math__BaseIntegratorOptions.html:1948,Availability,toler,tolerance,1948,"aseIntegratorOptions& opt); doubleRelTolerance() const; voidSetAbsTolerance(double tol); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetRelTolerance(double tol); voidSetWKSize(unsigned int size); unsigned intWKSize() const. protected:. voidClearExtra(). Data Members; protected:. doublefAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*fExtraOptionsextra options ; intfIntegTypeIntegrator type (value converted from enum); unsigned intfNCalls(max) funxtion calls; doublefRelTolerancerelative tolerance ; unsigned intfWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::BaseIntegratorOptions& opt); assignment operators. virtual ~BaseIntegratorOptions(); protected constructor to avoid user creating this class. { ClearExtra(); }. std::string Integrator() const; name of 1D integrator. double AbsTolerance() const; non-static methods for retrivieng options ; absolute tolerance. { return fAbsTolerance; }. double RelTolerance() const; absolute tolerance. { return fRelTolerance; }. unsigned int WKSize() const; size of the workspace. { return fWKSize; }. IOptions * ExtraOptions() const; return extra options. { return fExtraOptions; }. void SetAbsTolerance(double tol); non-static methods for setting options ; set the abs tolerance. { fAbsTolerance = tol; }. void SetRelTolerance(double tol); set the relative tolerance. { fRelTolerance = tol; }. void SetWKSize(unsigned int size); set workspace size. { fWKSize = size; }. void SetExtraOptions(const ROOT::Math::IOptions& opt); set extra options (in this case pointer is cloned). void ClearExtra().  Author: L. Moneta Fri Aug 15 2008  Copyright (c) 2008 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__BaseIntegratorOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BaseIntegratorOptions.html
https://root.cern/root/html534/ROOT__Math__BaseIntegratorOptions.html:2228,Availability,toler,tolerance,2228,"aseIntegratorOptions& opt); doubleRelTolerance() const; voidSetAbsTolerance(double tol); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetRelTolerance(double tol); voidSetWKSize(unsigned int size); unsigned intWKSize() const. protected:. voidClearExtra(). Data Members; protected:. doublefAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*fExtraOptionsextra options ; intfIntegTypeIntegrator type (value converted from enum); unsigned intfNCalls(max) funxtion calls; doublefRelTolerancerelative tolerance ; unsigned intfWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::BaseIntegratorOptions& opt); assignment operators. virtual ~BaseIntegratorOptions(); protected constructor to avoid user creating this class. { ClearExtra(); }. std::string Integrator() const; name of 1D integrator. double AbsTolerance() const; non-static methods for retrivieng options ; absolute tolerance. { return fAbsTolerance; }. double RelTolerance() const; absolute tolerance. { return fRelTolerance; }. unsigned int WKSize() const; size of the workspace. { return fWKSize; }. IOptions * ExtraOptions() const; return extra options. { return fExtraOptions; }. void SetAbsTolerance(double tol); non-static methods for setting options ; set the abs tolerance. { fAbsTolerance = tol; }. void SetRelTolerance(double tol); set the relative tolerance. { fRelTolerance = tol; }. void SetWKSize(unsigned int size); set workspace size. { fWKSize = size; }. void SetExtraOptions(const ROOT::Math::IOptions& opt); set extra options (in this case pointer is cloned). void ClearExtra().  Author: L. Moneta Fri Aug 15 2008  Copyright (c) 2008 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__BaseIntegratorOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BaseIntegratorOptions.html
https://root.cern/root/html534/ROOT__Math__BaseIntegratorOptions.html:2316,Availability,toler,tolerance,2316,"aseIntegratorOptions& opt); doubleRelTolerance() const; voidSetAbsTolerance(double tol); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetRelTolerance(double tol); voidSetWKSize(unsigned int size); unsigned intWKSize() const. protected:. voidClearExtra(). Data Members; protected:. doublefAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*fExtraOptionsextra options ; intfIntegTypeIntegrator type (value converted from enum); unsigned intfNCalls(max) funxtion calls; doublefRelTolerancerelative tolerance ; unsigned intfWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::BaseIntegratorOptions& opt); assignment operators. virtual ~BaseIntegratorOptions(); protected constructor to avoid user creating this class. { ClearExtra(); }. std::string Integrator() const; name of 1D integrator. double AbsTolerance() const; non-static methods for retrivieng options ; absolute tolerance. { return fAbsTolerance; }. double RelTolerance() const; absolute tolerance. { return fRelTolerance; }. unsigned int WKSize() const; size of the workspace. { return fWKSize; }. IOptions * ExtraOptions() const; return extra options. { return fExtraOptions; }. void SetAbsTolerance(double tol); non-static methods for setting options ; set the abs tolerance. { fAbsTolerance = tol; }. void SetRelTolerance(double tol); set the relative tolerance. { fRelTolerance = tol; }. void SetWKSize(unsigned int size); set workspace size. { fWKSize = size; }. void SetExtraOptions(const ROOT::Math::IOptions& opt); set extra options (in this case pointer is cloned). void ClearExtra().  Author: L. Moneta Fri Aug 15 2008  Copyright (c) 2008 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__BaseIntegratorOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BaseIntegratorOptions.html
https://root.cern/root/html534/ROOT__Math__BaseIntegratorOptions.html:349,Deployability,integrat,integration,349,". ROOT::Math::BaseIntegratorOptions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::BaseIntegratorOptions. class ROOT::Math::BaseIntegratorOptions. Base class for Numerical integration options; common in 1D and multi-dimension; This is an internal class and is not supposed to be instantiated by the user. @ingroup Integration. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~BaseIntegratorOptions(); doubleAbsTolerance() const; ROOT::Math::IOptions*ExtraOptions() const; virtual stringIntegrator() const; ROOT::Math::BaseIntegratorOptions&operator=(const ROOT::Math::BaseIntegratorOptions& opt); doubleRelTolerance() const; voidSetAbsTolerance(double tol); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetRelTolerance(double tol); voidSetWKSize(unsigned int size); unsigned intWKSize() const. protected:. voidClearExtra(). Data Members; protected:. doublefAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*fExtraOptionsextra options ; intfIntegTypeIntegrator type (value converted from enum); unsigned intfNCalls(max) funxtion calls; doublefRelTolerancerelative tolerance ; unsigned intfWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::BaseIntegratorOptions& opt); assignment operators. virtual ~BaseIntegratorOptions(); protected constructor to avoid user creating this class. { ClearExtra(); }. std::string Integrator() const; name of 1D integrator. double AbsTolerance() const; non-static methods for retrivieng options ; absolute tolerance. { return fAbsTolerance; }. double RelTolerance() const; absolute tolerance. { return fRelTolerance; }. unsigned int WK",MatchSource.WIKI,root/html534/ROOT__Math__BaseIntegratorOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BaseIntegratorOptions.html
https://root.cern/root/html534/ROOT__Math__BaseIntegratorOptions.html:1778,Deployability,integrat,integrator,1778,"tions() const; virtual stringIntegrator() const; ROOT::Math::BaseIntegratorOptions&operator=(const ROOT::Math::BaseIntegratorOptions& opt); doubleRelTolerance() const; voidSetAbsTolerance(double tol); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetRelTolerance(double tol); voidSetWKSize(unsigned int size); unsigned intWKSize() const. protected:. voidClearExtra(). Data Members; protected:. doublefAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*fExtraOptionsextra options ; intfIntegTypeIntegrator type (value converted from enum); unsigned intfNCalls(max) funxtion calls; doublefRelTolerancerelative tolerance ; unsigned intfWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::BaseIntegratorOptions& opt); assignment operators. virtual ~BaseIntegratorOptions(); protected constructor to avoid user creating this class. { ClearExtra(); }. std::string Integrator() const; name of 1D integrator. double AbsTolerance() const; non-static methods for retrivieng options ; absolute tolerance. { return fAbsTolerance; }. double RelTolerance() const; absolute tolerance. { return fRelTolerance; }. unsigned int WKSize() const; size of the workspace. { return fWKSize; }. IOptions * ExtraOptions() const; return extra options. { return fExtraOptions; }. void SetAbsTolerance(double tol); non-static methods for setting options ; set the abs tolerance. { fAbsTolerance = tol; }. void SetRelTolerance(double tol); set the relative tolerance. { fRelTolerance = tol; }. void SetWKSize(unsigned int size); set workspace size. { fWKSize = size; }. void SetExtraOptions(const ROOT::Math::IOptions& opt); set extra options (in this case pointer is cloned). void ClearExtra().  Author: L. Moneta Fri Aug 15 2008  Copyright (c) 2008 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. ",MatchSource.WIKI,root/html534/ROOT__Math__BaseIntegratorOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BaseIntegratorOptions.html
https://root.cern/root/html534/ROOT__Math__BaseIntegratorOptions.html:349,Integrability,integrat,integration,349,". ROOT::Math::BaseIntegratorOptions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::BaseIntegratorOptions. class ROOT::Math::BaseIntegratorOptions. Base class for Numerical integration options; common in 1D and multi-dimension; This is an internal class and is not supposed to be instantiated by the user. @ingroup Integration. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~BaseIntegratorOptions(); doubleAbsTolerance() const; ROOT::Math::IOptions*ExtraOptions() const; virtual stringIntegrator() const; ROOT::Math::BaseIntegratorOptions&operator=(const ROOT::Math::BaseIntegratorOptions& opt); doubleRelTolerance() const; voidSetAbsTolerance(double tol); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetRelTolerance(double tol); voidSetWKSize(unsigned int size); unsigned intWKSize() const. protected:. voidClearExtra(). Data Members; protected:. doublefAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*fExtraOptionsextra options ; intfIntegTypeIntegrator type (value converted from enum); unsigned intfNCalls(max) funxtion calls; doublefRelTolerancerelative tolerance ; unsigned intfWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::BaseIntegratorOptions& opt); assignment operators. virtual ~BaseIntegratorOptions(); protected constructor to avoid user creating this class. { ClearExtra(); }. std::string Integrator() const; name of 1D integrator. double AbsTolerance() const; non-static methods for retrivieng options ; absolute tolerance. { return fAbsTolerance; }. double RelTolerance() const; absolute tolerance. { return fRelTolerance; }. unsigned int WK",MatchSource.WIKI,root/html534/ROOT__Math__BaseIntegratorOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BaseIntegratorOptions.html
https://root.cern/root/html534/ROOT__Math__BaseIntegratorOptions.html:1778,Integrability,integrat,integrator,1778,"tions() const; virtual stringIntegrator() const; ROOT::Math::BaseIntegratorOptions&operator=(const ROOT::Math::BaseIntegratorOptions& opt); doubleRelTolerance() const; voidSetAbsTolerance(double tol); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetRelTolerance(double tol); voidSetWKSize(unsigned int size); unsigned intWKSize() const. protected:. voidClearExtra(). Data Members; protected:. doublefAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*fExtraOptionsextra options ; intfIntegTypeIntegrator type (value converted from enum); unsigned intfNCalls(max) funxtion calls; doublefRelTolerancerelative tolerance ; unsigned intfWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::BaseIntegratorOptions& opt); assignment operators. virtual ~BaseIntegratorOptions(); protected constructor to avoid user creating this class. { ClearExtra(); }. std::string Integrator() const; name of 1D integrator. double AbsTolerance() const; non-static methods for retrivieng options ; absolute tolerance. { return fAbsTolerance; }. double RelTolerance() const; absolute tolerance. { return fRelTolerance; }. unsigned int WKSize() const; size of the workspace. { return fWKSize; }. IOptions * ExtraOptions() const; return extra options. { return fExtraOptions; }. void SetAbsTolerance(double tol); non-static methods for setting options ; set the abs tolerance. { fAbsTolerance = tol; }. void SetRelTolerance(double tol); set the relative tolerance. { fRelTolerance = tol; }. void SetWKSize(unsigned int size); set workspace size. { fWKSize = size; }. void SetExtraOptions(const ROOT::Math::IOptions& opt); set extra options (in this case pointer is cloned). void ClearExtra().  Author: L. Moneta Fri Aug 15 2008  Copyright (c) 2008 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. ",MatchSource.WIKI,root/html534/ROOT__Math__BaseIntegratorOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BaseIntegratorOptions.html
https://root.cern/root/html534/ROOT__Math__BaseIntegratorOptions.html:1684,Safety,avoid,avoid,1684,":. virtual~BaseIntegratorOptions(); doubleAbsTolerance() const; ROOT::Math::IOptions*ExtraOptions() const; virtual stringIntegrator() const; ROOT::Math::BaseIntegratorOptions&operator=(const ROOT::Math::BaseIntegratorOptions& opt); doubleRelTolerance() const; voidSetAbsTolerance(double tol); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetRelTolerance(double tol); voidSetWKSize(unsigned int size); unsigned intWKSize() const. protected:. voidClearExtra(). Data Members; protected:. doublefAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*fExtraOptionsextra options ; intfIntegTypeIntegrator type (value converted from enum); unsigned intfNCalls(max) funxtion calls; doublefRelTolerancerelative tolerance ; unsigned intfWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::BaseIntegratorOptions& opt); assignment operators. virtual ~BaseIntegratorOptions(); protected constructor to avoid user creating this class. { ClearExtra(); }. std::string Integrator() const; name of 1D integrator. double AbsTolerance() const; non-static methods for retrivieng options ; absolute tolerance. { return fAbsTolerance; }. double RelTolerance() const; absolute tolerance. { return fRelTolerance; }. unsigned int WKSize() const; size of the workspace. { return fWKSize; }. IOptions * ExtraOptions() const; return extra options. { return fExtraOptions; }. void SetAbsTolerance(double tol); non-static methods for setting options ; set the abs tolerance. { fAbsTolerance = tol; }. void SetRelTolerance(double tol); set the relative tolerance. { fRelTolerance = tol; }. void SetWKSize(unsigned int size); set workspace size. { fWKSize = size; }. void SetExtraOptions(const ROOT::Math::IOptions& opt); set extra options (in this case pointer is cloned). void ClearExtra().  Author: L. Moneta Fri Aug 15 2008  Copyright (c) 2008 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/ma",MatchSource.WIKI,root/html534/ROOT__Math__BaseIntegratorOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BaseIntegratorOptions.html
https://root.cern/root/html534/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html:1289,Availability,avail,available,1289,"  ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>. class ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>: public ROOT::Math::IBaseFunctionMultiDim. FitMethodFunction class; Interface for objective functions (like chi2 and likelihood used in the fit); In addition to normal function interface provide interface for calculating each; data contrinution to the function which is required by some algorithm (like Fumili). @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Fit::Chi2FCN<ROOT::Math::IBaseFunctionMultiDim>::BaseObjFunction, ROOT::Math::FitMethodFunction, ROOT::Math::BasicFitMethodFunction<ROOT::Math::IMultiGenFunction>, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseObjFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseObjFunction. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual doubleDataElement(const double* x, unsigned int i, double* g = 0) const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>&operator=(const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>&); virtual voidResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::Type_tType() const; virtual voidUpdateNCalls() const. Data Members; public:. enum Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. unsigned intfNCallsnumber of function calls; unsigned intfNDimfunction dimension ; unsigned intfNPointssize of the data. C",MatchSource.WIKI,root/html534/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html
https://root.cern/root/html534/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html:3098,Deployability,update,update,3098," int i, double* g = 0) const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>&operator=(const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>&); virtual voidResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::Type_tType() const; virtual voidUpdateNCalls() const. Data Members; public:. enum Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. unsigned intfNCallsnumber of function calls; unsigned intfNDimfunction dimension ; unsigned intfNPointssize of the data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; unsigned int NDim() const. Number of dimension (parameters) . From IGenMultiFunction interface. { return fNDim; }. double DataElement(const double* x, unsigned int i, double* g = 0) const. method returning the data i-th contribution to the fit objective function; For example the residual for the least square functions or the pdf element for the; likelihood functions.; Estimating eventually also the gradient of the data element if the passed pointer is not null. unsigned int NPoints() const. return the number of data points used in evaluating the function. { return fNPoints; }. unsigned int NCalls() const. return the total number of function calls (overrided if needed). { return fNCalls; }. void UpdateNCalls() const. update number of calls. { fNCalls++; }. void ResetNCalls(). reset number of function calls. { fNCalls = 0; }.  Author: L. Moneta Thu Aug 16 15:40:28 2007  Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html
https://root.cern/root/html534/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html:608,Integrability,interface,interface,608,". ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>. class ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>: public ROOT::Math::IBaseFunctionMultiDim. FitMethodFunction class; Interface for objective functions (like chi2 and likelihood used in the fit); In addition to normal function interface provide interface for calculating each; data contrinution to the function which is required by some algorithm (like Fumili). @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Fit::Chi2FCN<ROOT::Math::IBaseFunctionMultiDim>::BaseObjFunction, ROOT::Math::FitMethodFunction, ROOT::Math::BasicFitMethodFunction<ROOT::Math::IMultiGenFunction>, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseObjFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseObjFunction. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual doubleDataElement(const double* x, unsigned int i, double* g = 0) const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>&operator=(const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>&); virtual voidResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctio",MatchSource.WIKI,root/html534/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html
https://root.cern/root/html534/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html:626,Integrability,interface,interface,626,". ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>. class ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>: public ROOT::Math::IBaseFunctionMultiDim. FitMethodFunction class; Interface for objective functions (like chi2 and likelihood used in the fit); In addition to normal function interface provide interface for calculating each; data contrinution to the function which is required by some algorithm (like Fumili). @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Fit::Chi2FCN<ROOT::Math::IBaseFunctionMultiDim>::BaseObjFunction, ROOT::Math::FitMethodFunction, ROOT::Math::BasicFitMethodFunction<ROOT::Math::IMultiGenFunction>, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseObjFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseObjFunction. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual doubleDataElement(const double* x, unsigned int i, double* g = 0) const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>&operator=(const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>&); virtual voidResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctio",MatchSource.WIKI,root/html534/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html
https://root.cern/root/html534/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html:2457,Integrability,interface,interface,2457,"eFunctionMultiDim::Clone() const; virtual doubleDataElement(const double* x, unsigned int i, double* g = 0) const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>&operator=(const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>&); virtual voidResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::Type_tType() const; virtual voidUpdateNCalls() const. Data Members; public:. enum Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. unsigned intfNCallsnumber of function calls; unsigned intfNDimfunction dimension ; unsigned intfNPointssize of the data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; unsigned int NDim() const. Number of dimension (parameters) . From IGenMultiFunction interface. { return fNDim; }. double DataElement(const double* x, unsigned int i, double* g = 0) const. method returning the data i-th contribution to the fit objective function; For example the residual for the least square functions or the pdf element for the; likelihood functions.; Estimating eventually also the gradient of the data element if the passed pointer is not null. unsigned int NPoints() const. return the number of data points used in evaluating the function. { return fNPoints; }. unsigned int NCalls() const. return the total number of function calls (overrided if needed). { return fNCalls; }. void UpdateNCalls() const. update number of calls. { fNCalls++; }. void ResetNCalls(). reset number of function calls. { fNCalls = 0; }.  Author: L. Moneta Thu Aug 16 15:40:28 2007  Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestion",MatchSource.WIKI,root/html534/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BasicFitMethodFunction_-p1IBaseFunctionMultiDim_.html
https://root.cern/root/html534/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html:1322,Availability,avail,available,1322,"Function<ROOT::Math::IGradientFunctionMultiDim>. class ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>: public ROOT::Math::IGradientFunctionMultiDim. FitMethodFunction class; Interface for objective functions (like chi2 and likelihood used in the fit); In addition to normal function interface provide interface for calculating each; data contrinution to the function which is required by some algorithm (like Fumili). @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Math::FitMethodGradFunction, ROOT::Math::BasicFitMethodFunction<ROOT::Math::IMultiGradFunction>, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseObjFunction, ROOT::Fit::Chi2FCN<ROOT::Math::IGradientFunctionMultiDim>::BaseObjFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseObjFunction. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual doubleDataElement(const double* x, unsigned int i, double* g = 0) const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidROOT::Math::IGradientFunctionMultiDim::FdF(const double* x, double& f, double* df) const; virtual voidROOT::Math::IGradientFunctionMultiDim::Gradient(const double* x, double* grad) const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>&operator=(const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>&); virtual voidResetNCalls(); virtual ROOT::Math::BasicFitMethodFunct",MatchSource.WIKI,root/html534/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html
https://root.cern/root/html534/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html:3444,Deployability,update,update,3444,"ble* grad) const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>&operator=(const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>&); virtual voidResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::Type_tType() const; virtual voidUpdateNCalls() const. Data Members; public:. enum Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. unsigned intfNCallsnumber of function calls; unsigned intfNDimfunction dimension ; unsigned intfNPointssize of the data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; unsigned int NDim() const. Number of dimension (parameters) . From IGenMultiFunction interface. { return fNDim; }. double DataElement(const double* x, unsigned int i, double* g = 0) const. method returning the data i-th contribution to the fit objective function; For example the residual for the least square functions or the pdf element for the; likelihood functions.; Estimating eventually also the gradient of the data element if the passed pointer is not null. unsigned int NPoints() const. return the number of data points used in evaluating the function. { return fNPoints; }. unsigned int NCalls() const. return the total number of function calls (overrided if needed). { return fNCalls; }. void UpdateNCalls() const. update number of calls. { fNCalls++; }. void ResetNCalls(). reset number of function calls. { fNCalls = 0; }.  Author: L. Moneta Thu Aug 16 15:40:28 2007  Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html
https://root.cern/root/html534/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html:624,Integrability,interface,interface,624,". ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>. class ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>: public ROOT::Math::IGradientFunctionMultiDim. FitMethodFunction class; Interface for objective functions (like chi2 and likelihood used in the fit); In addition to normal function interface provide interface for calculating each; data contrinution to the function which is required by some algorithm (like Fumili). @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Math::FitMethodGradFunction, ROOT::Math::BasicFitMethodFunction<ROOT::Math::IMultiGradFunction>, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseObjFunction, ROOT::Fit::Chi2FCN<ROOT::Math::IGradientFunctionMultiDim>::BaseObjFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseObjFunction. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual doubleDataElement(const double* x, unsigned int i, double* g = 0) const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidROOT::Math::IGradientFunctionMultiDim::FdF(const double* x, double& f, double* df) const; virtual voidROOT::Math::IGradientFunctionMultiDim::Gradient(const double* x, double* grad) const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNPoints() co",MatchSource.WIKI,root/html534/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html
https://root.cern/root/html534/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html:642,Integrability,interface,interface,642,". ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>. class ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>: public ROOT::Math::IGradientFunctionMultiDim. FitMethodFunction class; Interface for objective functions (like chi2 and likelihood used in the fit); In addition to normal function interface provide interface for calculating each; data contrinution to the function which is required by some algorithm (like Fumili). @ingroup FitMethodFunc. This class is also known as (typedefs to this class)ROOT::Math::FitMethodGradFunction, ROOT::Math::BasicFitMethodFunction<ROOT::Math::IMultiGradFunction>, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseObjFunction, ROOT::Fit::Chi2FCN<ROOT::Math::IGradientFunctionMultiDim>::BaseObjFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseObjFunction. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual doubleDataElement(const double* x, unsigned int i, double* g = 0) const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidROOT::Math::IGradientFunctionMultiDim::FdF(const double* x, double& f, double* df) const; virtual voidROOT::Math::IGradientFunctionMultiDim::Gradient(const double* x, double* grad) const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNPoints() co",MatchSource.WIKI,root/html534/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html
https://root.cern/root/html534/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html:2803,Integrability,interface,interface,2803,"nst; virtual voidROOT::Math::IGradientFunctionMultiDim::Gradient(const double* x, double* grad) const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNPoints() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>&operator=(const ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>&); virtual voidResetNCalls(); virtual ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::Type_tType() const; virtual voidUpdateNCalls() const. Data Members; public:. enum Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. unsigned intfNCallsnumber of function calls; unsigned intfNDimfunction dimension ; unsigned intfNPointssize of the data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; unsigned int NDim() const. Number of dimension (parameters) . From IGenMultiFunction interface. { return fNDim; }. double DataElement(const double* x, unsigned int i, double* g = 0) const. method returning the data i-th contribution to the fit objective function; For example the residual for the least square functions or the pdf element for the; likelihood functions.; Estimating eventually also the gradient of the data element if the passed pointer is not null. unsigned int NPoints() const. return the number of data points used in evaluating the function. { return fNPoints; }. unsigned int NCalls() const. return the total number of function calls (overrided if needed). { return fNCalls; }. void UpdateNCalls() const. update number of calls. { fNCalls++; }. void ResetNCalls(). reset number of function calls. { fNCalls = 0; }.  Author: L. Moneta Thu Aug 16 15:40:28 2007  Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestion",MatchSource.WIKI,root/html534/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BasicFitMethodFunction_-p1IGradientFunctionMultiDim_.html
https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html:5818,Availability,error,errors,5818,"tVariableValues(const double* x); intROOT::Math::Minimizer::Status() const; virtual const double*StepSizes() const; intROOT::Math::Minimizer::Strategy() const; doubleROOT::Math::Minimizer::Tolerance() const; const ROOT::Math::MinimTransformFunction*TransformFunction() const; virtual intVariableIndex(const string& name) const; virtual stringVariableName(unsigned int ivar) const; virtual const double*X() const. protected:. boolCheckDimension() const; boolCheckObjFunction() const; ROOT::Math::MinimTransformFunction*CreateTransformation(vector<double>& startValues, const ROOT::Math::IMultiGradFunction* func = 0); voidSetFinalValues(const double* x); voidSetMinValue(double val). private:. ROOT::Math::BasicMinimizerBasicMinimizer(const ROOT::Math::BasicMinimizer&); ROOT::Math::BasicMinimizer&operator=(const ROOT::Math::BasicMinimizer& rhs). Data Members; protected:. ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::fOptionsminimizer options; intROOT::Math::Minimizer::fStatusstatus of minimizer ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. map<unsigned int,std::pair<double,double> >fBoundsmap specifying the bound using as key the parameter index; unsigned intfDim; doublefMinVal; vector<std::string>fNames; const ROOT::Math::IMultiGenFunction*fObjFunc; vector<double>fSteps; vector<double>fValues; vector<ROOT::Math::EMinimVariableType>fVarTypesvector specifyng the type of variables. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BasicMinimizer(). Default constructor. virtual ~BasicMinimizer(). Destructor. BasicMinimizer(const ROOT::Math::BasicMinimizer& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. {}. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set gradient the function to minimize. bool SetVariable(",MatchSource.WIKI,root/html534/ROOT__Math__BasicMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html
https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html:8287,Deployability,release,release,8287," , double ); set upper/lower limited variable (override if minimizer supports them ). bool SetFixedVariable(unsigned int , const string& , double ); set fixed variable (override if minimizer supports them ). bool SetVariableValue(unsigned int ivar, double val); set the value of an existing variable. bool SetVariableValues(const double* x); set the values of all existing variables (array must be dimensioned to the size of existing parameters). bool SetVariableStepSize(unsigned int ivar, double step); set the step size of an already existing variable. bool SetVariableLowerLimit(unsigned int ivar, double lower); set the lower-limit of an already existing variable. bool SetVariableUpperLimit(unsigned int ivar, double upper); set the upper-limit of an already existing variable. bool SetVariableLimits(unsigned int ivar, double lower, double upper); set the limits of an already existing variable. bool FixVariable(unsigned int ivar); fix an existing variable. bool ReleaseVariable(unsigned int ivar); release an existing variable. bool IsFixedVariable(unsigned int ivar) const; query if an existing variable is fixed (i.e. considered constant in the minimization); note that by default all variables are not fixed. bool GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings& varObj) const; get variable settings in a variable object (like ROOT::Fit::ParamsSettings). std::string VariableName(unsigned int ivar) const; get name of variables (override if minimizer support storing of variable names). int VariableIndex(const string& name) const; get index of variable given a variable given a name; return -1 if variable is not found. bool Minimize(); method to perform the minimization. double MinValue() const; return minimum function value. { return fMinVal; }. const double * X() const; return pointer to X values at the minimum. { return &fValues.front(); }. unsigned int NDim() const; number of dimensions. { return fDim; }. unsigned int NFree() const; number of free variables",MatchSource.WIKI,root/html534/ROOT__Math__BasicMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html
https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html:6231,Modifiability,variab,variables,6231,"g& name) const; virtual stringVariableName(unsigned int ivar) const; virtual const double*X() const. protected:. boolCheckDimension() const; boolCheckObjFunction() const; ROOT::Math::MinimTransformFunction*CreateTransformation(vector<double>& startValues, const ROOT::Math::IMultiGradFunction* func = 0); voidSetFinalValues(const double* x); voidSetMinValue(double val). private:. ROOT::Math::BasicMinimizerBasicMinimizer(const ROOT::Math::BasicMinimizer&); ROOT::Math::BasicMinimizer&operator=(const ROOT::Math::BasicMinimizer& rhs). Data Members; protected:. ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::fOptionsminimizer options; intROOT::Math::Minimizer::fStatusstatus of minimizer ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. map<unsigned int,std::pair<double,double> >fBoundsmap specifying the bound using as key the parameter index; unsigned intfDim; doublefMinVal; vector<std::string>fNames; const ROOT::Math::IMultiGenFunction*fObjFunc; vector<double>fSteps; vector<double>fValues; vector<ROOT::Math::EMinimVariableType>fVarTypesvector specifyng the type of variables. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BasicMinimizer(). Default constructor. virtual ~BasicMinimizer(). Destructor. BasicMinimizer(const ROOT::Math::BasicMinimizer& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. {}. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set gradient the function to minimize. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set free variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set lower limit variable (override if minimizer supports them ). bool SetUpperLimitedVariable(unsigned int ivar, const s",MatchSource.WIKI,root/html534/ROOT__Math__BasicMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html
https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html:6830,Modifiability,variab,variable,6830,"fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. map<unsigned int,std::pair<double,double> >fBoundsmap specifying the bound using as key the parameter index; unsigned intfDim; doublefMinVal; vector<std::string>fNames; const ROOT::Math::IMultiGenFunction*fObjFunc; vector<double>fSteps; vector<double>fValues; vector<ROOT::Math::EMinimVariableType>fVarTypesvector specifyng the type of variables. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BasicMinimizer(). Default constructor. virtual ~BasicMinimizer(). Destructor. BasicMinimizer(const ROOT::Math::BasicMinimizer& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. {}. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set gradient the function to minimize. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set free variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set lower limit variable (override if minimizer supports them ). bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set upper limit variable (override if minimizer supports them ). bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set upper/lower limited variable (override if minimizer supports them ). bool SetFixedVariable(unsigned int , const string& , double ); set fixed variable (override if minimizer supports them ). bool SetVariableValue(unsigned int ivar, double val); set the value of an existing variable. bool SetVariableValues(const double* x); set the values of all existing variables (array must be dimensioned to the size of existing parameters). bool SetVariableStepSize(unsigned int ivar, double step); set ",MatchSource.WIKI,root/html534/ROOT__Math__BasicMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html
https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html:6964,Modifiability,variab,variable,6964,"ble,double> >fBoundsmap specifying the bound using as key the parameter index; unsigned intfDim; doublefMinVal; vector<std::string>fNames; const ROOT::Math::IMultiGenFunction*fObjFunc; vector<double>fSteps; vector<double>fValues; vector<ROOT::Math::EMinimVariableType>fVarTypesvector specifyng the type of variables. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BasicMinimizer(). Default constructor. virtual ~BasicMinimizer(). Destructor. BasicMinimizer(const ROOT::Math::BasicMinimizer& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. {}. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set gradient the function to minimize. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set free variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set lower limit variable (override if minimizer supports them ). bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set upper limit variable (override if minimizer supports them ). bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set upper/lower limited variable (override if minimizer supports them ). bool SetFixedVariable(unsigned int , const string& , double ); set fixed variable (override if minimizer supports them ). bool SetVariableValue(unsigned int ivar, double val); set the value of an existing variable. bool SetVariableValues(const double* x); set the values of all existing variables (array must be dimensioned to the size of existing parameters). bool SetVariableStepSize(unsigned int ivar, double step); set the step size of an already existing variable. bool SetVariableLowerLimit(unsigned int ivar, double lower); set the lower-limit of an alr",MatchSource.WIKI,root/html534/ROOT__Math__BasicMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html
https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html:7137,Modifiability,variab,variable,7137,"n*fObjFunc; vector<double>fSteps; vector<double>fValues; vector<ROOT::Math::EMinimVariableType>fVarTypesvector specifyng the type of variables. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BasicMinimizer(). Default constructor. virtual ~BasicMinimizer(). Destructor. BasicMinimizer(const ROOT::Math::BasicMinimizer& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. {}. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set gradient the function to minimize. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set free variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set lower limit variable (override if minimizer supports them ). bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set upper limit variable (override if minimizer supports them ). bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set upper/lower limited variable (override if minimizer supports them ). bool SetFixedVariable(unsigned int , const string& , double ); set fixed variable (override if minimizer supports them ). bool SetVariableValue(unsigned int ivar, double val); set the value of an existing variable. bool SetVariableValues(const double* x); set the values of all existing variables (array must be dimensioned to the size of existing parameters). bool SetVariableStepSize(unsigned int ivar, double step); set the step size of an already existing variable. bool SetVariableLowerLimit(unsigned int ivar, double lower); set the lower-limit of an already existing variable. bool SetVariableUpperLimit(unsigned int ivar, double upper); set the upper-limit of an already existing variable. bool SetVariableLimits(unsigned int",MatchSource.WIKI,root/html534/ROOT__Math__BasicMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html
https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html:7317,Modifiability,variab,variable,7317,"ted Members; Includes; Libraries. Function documentation; BasicMinimizer(). Default constructor. virtual ~BasicMinimizer(). Destructor. BasicMinimizer(const ROOT::Math::BasicMinimizer& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. {}. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set gradient the function to minimize. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set free variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set lower limit variable (override if minimizer supports them ). bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set upper limit variable (override if minimizer supports them ). bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set upper/lower limited variable (override if minimizer supports them ). bool SetFixedVariable(unsigned int , const string& , double ); set fixed variable (override if minimizer supports them ). bool SetVariableValue(unsigned int ivar, double val); set the value of an existing variable. bool SetVariableValues(const double* x); set the values of all existing variables (array must be dimensioned to the size of existing parameters). bool SetVariableStepSize(unsigned int ivar, double step); set the step size of an already existing variable. bool SetVariableLowerLimit(unsigned int ivar, double lower); set the lower-limit of an already existing variable. bool SetVariableUpperLimit(unsigned int ivar, double upper); set the upper-limit of an already existing variable. bool SetVariableLimits(unsigned int ivar, double lower, double upper); set the limits of an already existing variable. bool FixVariable(unsigned int ivar); fix an existing variable. bool ReleaseVariable(unsigned",MatchSource.WIKI,root/html534/ROOT__Math__BasicMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html
https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html:7439,Modifiability,variab,variable,7439,"const ROOT::Math::BasicMinimizer& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. {}. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set gradient the function to minimize. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set free variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set lower limit variable (override if minimizer supports them ). bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set upper limit variable (override if minimizer supports them ). bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set upper/lower limited variable (override if minimizer supports them ). bool SetFixedVariable(unsigned int , const string& , double ); set fixed variable (override if minimizer supports them ). bool SetVariableValue(unsigned int ivar, double val); set the value of an existing variable. bool SetVariableValues(const double* x); set the values of all existing variables (array must be dimensioned to the size of existing parameters). bool SetVariableStepSize(unsigned int ivar, double step); set the step size of an already existing variable. bool SetVariableLowerLimit(unsigned int ivar, double lower); set the lower-limit of an already existing variable. bool SetVariableUpperLimit(unsigned int ivar, double upper); set the upper-limit of an already existing variable. bool SetVariableLimits(unsigned int ivar, double lower, double upper); set the limits of an already existing variable. bool FixVariable(unsigned int ivar); fix an existing variable. bool ReleaseVariable(unsigned int ivar); release an existing variable. bool IsFixedVariable(unsigned int ivar) const; query if an existing variable is fixed (i.e. considered consta",MatchSource.WIKI,root/html534/ROOT__Math__BasicMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html
https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html:7571,Modifiability,variab,variable,7571,"structor. {}. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set gradient the function to minimize. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set free variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set lower limit variable (override if minimizer supports them ). bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set upper limit variable (override if minimizer supports them ). bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set upper/lower limited variable (override if minimizer supports them ). bool SetFixedVariable(unsigned int , const string& , double ); set fixed variable (override if minimizer supports them ). bool SetVariableValue(unsigned int ivar, double val); set the value of an existing variable. bool SetVariableValues(const double* x); set the values of all existing variables (array must be dimensioned to the size of existing parameters). bool SetVariableStepSize(unsigned int ivar, double step); set the step size of an already existing variable. bool SetVariableLowerLimit(unsigned int ivar, double lower); set the lower-limit of an already existing variable. bool SetVariableUpperLimit(unsigned int ivar, double upper); set the upper-limit of an already existing variable. bool SetVariableLimits(unsigned int ivar, double lower, double upper); set the limits of an already existing variable. bool FixVariable(unsigned int ivar); fix an existing variable. bool ReleaseVariable(unsigned int ivar); release an existing variable. bool IsFixedVariable(unsigned int ivar) const; query if an existing variable is fixed (i.e. considered constant in the minimization); note that by default all variables are not fixed. bool GetVariableSettings(unsigned",MatchSource.WIKI,root/html534/ROOT__Math__BasicMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html
https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html:7653,Modifiability,variab,variables,7653,"n(const ROOT::Math::IMultiGradFunction& func); set gradient the function to minimize. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set free variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set lower limit variable (override if minimizer supports them ). bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set upper limit variable (override if minimizer supports them ). bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set upper/lower limited variable (override if minimizer supports them ). bool SetFixedVariable(unsigned int , const string& , double ); set fixed variable (override if minimizer supports them ). bool SetVariableValue(unsigned int ivar, double val); set the value of an existing variable. bool SetVariableValues(const double* x); set the values of all existing variables (array must be dimensioned to the size of existing parameters). bool SetVariableStepSize(unsigned int ivar, double step); set the step size of an already existing variable. bool SetVariableLowerLimit(unsigned int ivar, double lower); set the lower-limit of an already existing variable. bool SetVariableUpperLimit(unsigned int ivar, double upper); set the upper-limit of an already existing variable. bool SetVariableLimits(unsigned int ivar, double lower, double upper); set the limits of an already existing variable. bool FixVariable(unsigned int ivar); fix an existing variable. bool ReleaseVariable(unsigned int ivar); release an existing variable. bool IsFixedVariable(unsigned int ivar) const; query if an existing variable is fixed (i.e. considered constant in the minimization); note that by default all variables are not fixed. bool GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings& varObj) const; get variable settings in a variable object (like ROOT::Fit::Par",MatchSource.WIKI,root/html534/ROOT__Math__BasicMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html
https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html:7826,Modifiability,variab,variable,7826," string& name, double val, double step); set free variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set lower limit variable (override if minimizer supports them ). bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set upper limit variable (override if minimizer supports them ). bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set upper/lower limited variable (override if minimizer supports them ). bool SetFixedVariable(unsigned int , const string& , double ); set fixed variable (override if minimizer supports them ). bool SetVariableValue(unsigned int ivar, double val); set the value of an existing variable. bool SetVariableValues(const double* x); set the values of all existing variables (array must be dimensioned to the size of existing parameters). bool SetVariableStepSize(unsigned int ivar, double step); set the step size of an already existing variable. bool SetVariableLowerLimit(unsigned int ivar, double lower); set the lower-limit of an already existing variable. bool SetVariableUpperLimit(unsigned int ivar, double upper); set the upper-limit of an already existing variable. bool SetVariableLimits(unsigned int ivar, double lower, double upper); set the limits of an already existing variable. bool FixVariable(unsigned int ivar); fix an existing variable. bool ReleaseVariable(unsigned int ivar); release an existing variable. bool IsFixedVariable(unsigned int ivar) const; query if an existing variable is fixed (i.e. considered constant in the minimization); note that by default all variables are not fixed. bool GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings& varObj) const; get variable settings in a variable object (like ROOT::Fit::ParamsSettings). std::string VariableName(unsigned int ivar) const; get name of variables (override if minimizer support storing of",MatchSource.WIKI,root/html534/ROOT__Math__BasicMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html
https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html:7940,Modifiability,variab,variable,7940,"t string& name, double val, double step, double lower); set lower limit variable (override if minimizer supports them ). bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set upper limit variable (override if minimizer supports them ). bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set upper/lower limited variable (override if minimizer supports them ). bool SetFixedVariable(unsigned int , const string& , double ); set fixed variable (override if minimizer supports them ). bool SetVariableValue(unsigned int ivar, double val); set the value of an existing variable. bool SetVariableValues(const double* x); set the values of all existing variables (array must be dimensioned to the size of existing parameters). bool SetVariableStepSize(unsigned int ivar, double step); set the step size of an already existing variable. bool SetVariableLowerLimit(unsigned int ivar, double lower); set the lower-limit of an already existing variable. bool SetVariableUpperLimit(unsigned int ivar, double upper); set the upper-limit of an already existing variable. bool SetVariableLimits(unsigned int ivar, double lower, double upper); set the limits of an already existing variable. bool FixVariable(unsigned int ivar); fix an existing variable. bool ReleaseVariable(unsigned int ivar); release an existing variable. bool IsFixedVariable(unsigned int ivar) const; query if an existing variable is fixed (i.e. considered constant in the minimization); note that by default all variables are not fixed. bool GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings& varObj) const; get variable settings in a variable object (like ROOT::Fit::ParamsSettings). std::string VariableName(unsigned int ivar) const; get name of variables (override if minimizer support storing of variable names). int VariableIndex(const string& name) const; get index of variable given a variable given a n",MatchSource.WIKI,root/html534/ROOT__Math__BasicMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html
https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html:8054,Modifiability,variab,variable,8054,"hem ). bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set upper limit variable (override if minimizer supports them ). bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set upper/lower limited variable (override if minimizer supports them ). bool SetFixedVariable(unsigned int , const string& , double ); set fixed variable (override if minimizer supports them ). bool SetVariableValue(unsigned int ivar, double val); set the value of an existing variable. bool SetVariableValues(const double* x); set the values of all existing variables (array must be dimensioned to the size of existing parameters). bool SetVariableStepSize(unsigned int ivar, double step); set the step size of an already existing variable. bool SetVariableLowerLimit(unsigned int ivar, double lower); set the lower-limit of an already existing variable. bool SetVariableUpperLimit(unsigned int ivar, double upper); set the upper-limit of an already existing variable. bool SetVariableLimits(unsigned int ivar, double lower, double upper); set the limits of an already existing variable. bool FixVariable(unsigned int ivar); fix an existing variable. bool ReleaseVariable(unsigned int ivar); release an existing variable. bool IsFixedVariable(unsigned int ivar) const; query if an existing variable is fixed (i.e. considered constant in the minimization); note that by default all variables are not fixed. bool GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings& varObj) const; get variable settings in a variable object (like ROOT::Fit::ParamsSettings). std::string VariableName(unsigned int ivar) const; get name of variables (override if minimizer support storing of variable names). int VariableIndex(const string& name) const; get index of variable given a variable given a name; return -1 if variable is not found. bool Minimize(); method to perform the minimization. double MinValue() co",MatchSource.WIKI,root/html534/ROOT__Math__BasicMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html
https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html:8173,Modifiability,variab,variable,8173,"et upper limit variable (override if minimizer supports them ). bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set upper/lower limited variable (override if minimizer supports them ). bool SetFixedVariable(unsigned int , const string& , double ); set fixed variable (override if minimizer supports them ). bool SetVariableValue(unsigned int ivar, double val); set the value of an existing variable. bool SetVariableValues(const double* x); set the values of all existing variables (array must be dimensioned to the size of existing parameters). bool SetVariableStepSize(unsigned int ivar, double step); set the step size of an already existing variable. bool SetVariableLowerLimit(unsigned int ivar, double lower); set the lower-limit of an already existing variable. bool SetVariableUpperLimit(unsigned int ivar, double upper); set the upper-limit of an already existing variable. bool SetVariableLimits(unsigned int ivar, double lower, double upper); set the limits of an already existing variable. bool FixVariable(unsigned int ivar); fix an existing variable. bool ReleaseVariable(unsigned int ivar); release an existing variable. bool IsFixedVariable(unsigned int ivar) const; query if an existing variable is fixed (i.e. considered constant in the minimization); note that by default all variables are not fixed. bool GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings& varObj) const; get variable settings in a variable object (like ROOT::Fit::ParamsSettings). std::string VariableName(unsigned int ivar) const; get name of variables (override if minimizer support storing of variable names). int VariableIndex(const string& name) const; get index of variable given a variable given a name; return -1 if variable is not found. bool Minimize(); method to perform the minimization. double MinValue() const; return minimum function value. { return fMinVal; }. const double * X() const; return pointer to X values at the ",MatchSource.WIKI,root/html534/ROOT__Math__BasicMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html
https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html:8236,Modifiability,variab,variable,8236,"igned int ivar, const string& name, double val, double step, double , double ); set upper/lower limited variable (override if minimizer supports them ). bool SetFixedVariable(unsigned int , const string& , double ); set fixed variable (override if minimizer supports them ). bool SetVariableValue(unsigned int ivar, double val); set the value of an existing variable. bool SetVariableValues(const double* x); set the values of all existing variables (array must be dimensioned to the size of existing parameters). bool SetVariableStepSize(unsigned int ivar, double step); set the step size of an already existing variable. bool SetVariableLowerLimit(unsigned int ivar, double lower); set the lower-limit of an already existing variable. bool SetVariableUpperLimit(unsigned int ivar, double upper); set the upper-limit of an already existing variable. bool SetVariableLimits(unsigned int ivar, double lower, double upper); set the limits of an already existing variable. bool FixVariable(unsigned int ivar); fix an existing variable. bool ReleaseVariable(unsigned int ivar); release an existing variable. bool IsFixedVariable(unsigned int ivar) const; query if an existing variable is fixed (i.e. considered constant in the minimization); note that by default all variables are not fixed. bool GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings& varObj) const; get variable settings in a variable object (like ROOT::Fit::ParamsSettings). std::string VariableName(unsigned int ivar) const; get name of variables (override if minimizer support storing of variable names). int VariableIndex(const string& name) const; get index of variable given a variable given a name; return -1 if variable is not found. bool Minimize(); method to perform the minimization. double MinValue() const; return minimum function value. { return fMinVal; }. const double * X() const; return pointer to X values at the minimum. { return &fValues.front(); }. unsigned int NDim() const; number of dimensions. { r",MatchSource.WIKI,root/html534/ROOT__Math__BasicMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html
https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html:8307,Modifiability,variab,variable,8307," , double ); set upper/lower limited variable (override if minimizer supports them ). bool SetFixedVariable(unsigned int , const string& , double ); set fixed variable (override if minimizer supports them ). bool SetVariableValue(unsigned int ivar, double val); set the value of an existing variable. bool SetVariableValues(const double* x); set the values of all existing variables (array must be dimensioned to the size of existing parameters). bool SetVariableStepSize(unsigned int ivar, double step); set the step size of an already existing variable. bool SetVariableLowerLimit(unsigned int ivar, double lower); set the lower-limit of an already existing variable. bool SetVariableUpperLimit(unsigned int ivar, double upper); set the upper-limit of an already existing variable. bool SetVariableLimits(unsigned int ivar, double lower, double upper); set the limits of an already existing variable. bool FixVariable(unsigned int ivar); fix an existing variable. bool ReleaseVariable(unsigned int ivar); release an existing variable. bool IsFixedVariable(unsigned int ivar) const; query if an existing variable is fixed (i.e. considered constant in the minimization); note that by default all variables are not fixed. bool GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings& varObj) const; get variable settings in a variable object (like ROOT::Fit::ParamsSettings). std::string VariableName(unsigned int ivar) const; get name of variables (override if minimizer support storing of variable names). int VariableIndex(const string& name) const; get index of variable given a variable given a name; return -1 if variable is not found. bool Minimize(); method to perform the minimization. double MinValue() const; return minimum function value. { return fMinVal; }. const double * X() const; return pointer to X values at the minimum. { return &fValues.front(); }. unsigned int NDim() const; number of dimensions. { return fDim; }. unsigned int NFree() const; number of free variables",MatchSource.WIKI,root/html534/ROOT__Math__BasicMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html
https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html:8385,Modifiability,variab,variable,8385,"m ). bool SetFixedVariable(unsigned int , const string& , double ); set fixed variable (override if minimizer supports them ). bool SetVariableValue(unsigned int ivar, double val); set the value of an existing variable. bool SetVariableValues(const double* x); set the values of all existing variables (array must be dimensioned to the size of existing parameters). bool SetVariableStepSize(unsigned int ivar, double step); set the step size of an already existing variable. bool SetVariableLowerLimit(unsigned int ivar, double lower); set the lower-limit of an already existing variable. bool SetVariableUpperLimit(unsigned int ivar, double upper); set the upper-limit of an already existing variable. bool SetVariableLimits(unsigned int ivar, double lower, double upper); set the limits of an already existing variable. bool FixVariable(unsigned int ivar); fix an existing variable. bool ReleaseVariable(unsigned int ivar); release an existing variable. bool IsFixedVariable(unsigned int ivar) const; query if an existing variable is fixed (i.e. considered constant in the minimization); note that by default all variables are not fixed. bool GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings& varObj) const; get variable settings in a variable object (like ROOT::Fit::ParamsSettings). std::string VariableName(unsigned int ivar) const; get name of variables (override if minimizer support storing of variable names). int VariableIndex(const string& name) const; get index of variable given a variable given a name; return -1 if variable is not found. bool Minimize(); method to perform the minimization. double MinValue() const; return minimum function value. { return fMinVal; }. const double * X() const; return pointer to X values at the minimum. { return &fValues.front(); }. unsigned int NDim() const; number of dimensions. { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem). unsigned int NPar() const; total number of par",MatchSource.WIKI,root/html534/ROOT__Math__BasicMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html
https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html:8476,Modifiability,variab,variables,8476,"ide if minimizer supports them ). bool SetVariableValue(unsigned int ivar, double val); set the value of an existing variable. bool SetVariableValues(const double* x); set the values of all existing variables (array must be dimensioned to the size of existing parameters). bool SetVariableStepSize(unsigned int ivar, double step); set the step size of an already existing variable. bool SetVariableLowerLimit(unsigned int ivar, double lower); set the lower-limit of an already existing variable. bool SetVariableUpperLimit(unsigned int ivar, double upper); set the upper-limit of an already existing variable. bool SetVariableLimits(unsigned int ivar, double lower, double upper); set the limits of an already existing variable. bool FixVariable(unsigned int ivar); fix an existing variable. bool ReleaseVariable(unsigned int ivar); release an existing variable. bool IsFixedVariable(unsigned int ivar) const; query if an existing variable is fixed (i.e. considered constant in the minimization); note that by default all variables are not fixed. bool GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings& varObj) const; get variable settings in a variable object (like ROOT::Fit::ParamsSettings). std::string VariableName(unsigned int ivar) const; get name of variables (override if minimizer support storing of variable names). int VariableIndex(const string& name) const; get index of variable given a variable given a name; return -1 if variable is not found. bool Minimize(); method to perform the minimization. double MinValue() const; return minimum function value. { return fMinVal; }. const double * X() const; return pointer to X values at the minimum. { return &fValues.front(); }. unsigned int NDim() const; number of dimensions. { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem). unsigned int NPar() const; total number of parameter defined. { return fValues.size(); }. const ROOT::Math::IMultiGenFunction * ObjFunction",MatchSource.WIKI,root/html534/ROOT__Math__BasicMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html
https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html:8594,Modifiability,variab,variable,8594,"ol SetVariableValues(const double* x); set the values of all existing variables (array must be dimensioned to the size of existing parameters). bool SetVariableStepSize(unsigned int ivar, double step); set the step size of an already existing variable. bool SetVariableLowerLimit(unsigned int ivar, double lower); set the lower-limit of an already existing variable. bool SetVariableUpperLimit(unsigned int ivar, double upper); set the upper-limit of an already existing variable. bool SetVariableLimits(unsigned int ivar, double lower, double upper); set the limits of an already existing variable. bool FixVariable(unsigned int ivar); fix an existing variable. bool ReleaseVariable(unsigned int ivar); release an existing variable. bool IsFixedVariable(unsigned int ivar) const; query if an existing variable is fixed (i.e. considered constant in the minimization); note that by default all variables are not fixed. bool GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings& varObj) const; get variable settings in a variable object (like ROOT::Fit::ParamsSettings). std::string VariableName(unsigned int ivar) const; get name of variables (override if minimizer support storing of variable names). int VariableIndex(const string& name) const; get index of variable given a variable given a name; return -1 if variable is not found. bool Minimize(); method to perform the minimization. double MinValue() const; return minimum function value. { return fMinVal; }. const double * X() const; return pointer to X values at the minimum. { return &fValues.front(); }. unsigned int NDim() const; number of dimensions. { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem). unsigned int NPar() const; total number of parameter defined. { return fValues.size(); }. const ROOT::Math::IMultiGenFunction * ObjFunction() const; return pointer to used objective function. { return fObjFunc; }. const ROOT::Math::IMultiGradFunction * GradObjFunction",MatchSource.WIKI,root/html534/ROOT__Math__BasicMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html
https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html:8617,Modifiability,variab,variable,8617,"ol SetVariableValues(const double* x); set the values of all existing variables (array must be dimensioned to the size of existing parameters). bool SetVariableStepSize(unsigned int ivar, double step); set the step size of an already existing variable. bool SetVariableLowerLimit(unsigned int ivar, double lower); set the lower-limit of an already existing variable. bool SetVariableUpperLimit(unsigned int ivar, double upper); set the upper-limit of an already existing variable. bool SetVariableLimits(unsigned int ivar, double lower, double upper); set the limits of an already existing variable. bool FixVariable(unsigned int ivar); fix an existing variable. bool ReleaseVariable(unsigned int ivar); release an existing variable. bool IsFixedVariable(unsigned int ivar) const; query if an existing variable is fixed (i.e. considered constant in the minimization); note that by default all variables are not fixed. bool GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings& varObj) const; get variable settings in a variable object (like ROOT::Fit::ParamsSettings). std::string VariableName(unsigned int ivar) const; get name of variables (override if minimizer support storing of variable names). int VariableIndex(const string& name) const; get index of variable given a variable given a name; return -1 if variable is not found. bool Minimize(); method to perform the minimization. double MinValue() const; return minimum function value. { return fMinVal; }. const double * X() const; return pointer to X values at the minimum. { return &fValues.front(); }. unsigned int NDim() const; number of dimensions. { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem). unsigned int NPar() const; total number of parameter defined. { return fValues.size(); }. const ROOT::Math::IMultiGenFunction * ObjFunction() const; return pointer to used objective function. { return fObjFunc; }. const ROOT::Math::IMultiGradFunction * GradObjFunction",MatchSource.WIKI,root/html534/ROOT__Math__BasicMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html
https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html:8730,Modifiability,variab,variables,8730,"SetVariableStepSize(unsigned int ivar, double step); set the step size of an already existing variable. bool SetVariableLowerLimit(unsigned int ivar, double lower); set the lower-limit of an already existing variable. bool SetVariableUpperLimit(unsigned int ivar, double upper); set the upper-limit of an already existing variable. bool SetVariableLimits(unsigned int ivar, double lower, double upper); set the limits of an already existing variable. bool FixVariable(unsigned int ivar); fix an existing variable. bool ReleaseVariable(unsigned int ivar); release an existing variable. bool IsFixedVariable(unsigned int ivar) const; query if an existing variable is fixed (i.e. considered constant in the minimization); note that by default all variables are not fixed. bool GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings& varObj) const; get variable settings in a variable object (like ROOT::Fit::ParamsSettings). std::string VariableName(unsigned int ivar) const; get name of variables (override if minimizer support storing of variable names). int VariableIndex(const string& name) const; get index of variable given a variable given a name; return -1 if variable is not found. bool Minimize(); method to perform the minimization. double MinValue() const; return minimum function value. { return fMinVal; }. const double * X() const; return pointer to X values at the minimum. { return &fValues.front(); }. unsigned int NDim() const; number of dimensions. { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem). unsigned int NPar() const; total number of parameter defined. { return fValues.size(); }. const ROOT::Math::IMultiGenFunction * ObjFunction() const; return pointer to used objective function. { return fObjFunc; }. const ROOT::Math::IMultiGradFunction * GradObjFunction() const; return pointer to used gradient object function (NULL if gradient is not supported). void PrintResult() const; print result of minimization",MatchSource.WIKI,root/html534/ROOT__Math__BasicMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html
https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html:8782,Modifiability,variab,variable,8782,"SetVariableStepSize(unsigned int ivar, double step); set the step size of an already existing variable. bool SetVariableLowerLimit(unsigned int ivar, double lower); set the lower-limit of an already existing variable. bool SetVariableUpperLimit(unsigned int ivar, double upper); set the upper-limit of an already existing variable. bool SetVariableLimits(unsigned int ivar, double lower, double upper); set the limits of an already existing variable. bool FixVariable(unsigned int ivar); fix an existing variable. bool ReleaseVariable(unsigned int ivar); release an existing variable. bool IsFixedVariable(unsigned int ivar) const; query if an existing variable is fixed (i.e. considered constant in the minimization); note that by default all variables are not fixed. bool GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings& varObj) const; get variable settings in a variable object (like ROOT::Fit::ParamsSettings). std::string VariableName(unsigned int ivar) const; get name of variables (override if minimizer support storing of variable names). int VariableIndex(const string& name) const; get index of variable given a variable given a name; return -1 if variable is not found. bool Minimize(); method to perform the minimization. double MinValue() const; return minimum function value. { return fMinVal; }. const double * X() const; return pointer to X values at the minimum. { return &fValues.front(); }. unsigned int NDim() const; number of dimensions. { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem). unsigned int NPar() const; total number of parameter defined. { return fValues.size(); }. const ROOT::Math::IMultiGenFunction * ObjFunction() const; return pointer to used objective function. { return fObjFunc; }. const ROOT::Math::IMultiGradFunction * GradObjFunction() const; return pointer to used gradient object function (NULL if gradient is not supported). void PrintResult() const; print result of minimization",MatchSource.WIKI,root/html534/ROOT__Math__BasicMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html
https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html:8857,Modifiability,variab,variable,8857,"signed int ivar, double lower); set the lower-limit of an already existing variable. bool SetVariableUpperLimit(unsigned int ivar, double upper); set the upper-limit of an already existing variable. bool SetVariableLimits(unsigned int ivar, double lower, double upper); set the limits of an already existing variable. bool FixVariable(unsigned int ivar); fix an existing variable. bool ReleaseVariable(unsigned int ivar); release an existing variable. bool IsFixedVariable(unsigned int ivar) const; query if an existing variable is fixed (i.e. considered constant in the minimization); note that by default all variables are not fixed. bool GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings& varObj) const; get variable settings in a variable object (like ROOT::Fit::ParamsSettings). std::string VariableName(unsigned int ivar) const; get name of variables (override if minimizer support storing of variable names). int VariableIndex(const string& name) const; get index of variable given a variable given a name; return -1 if variable is not found. bool Minimize(); method to perform the minimization. double MinValue() const; return minimum function value. { return fMinVal; }. const double * X() const; return pointer to X values at the minimum. { return &fValues.front(); }. unsigned int NDim() const; number of dimensions. { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem). unsigned int NPar() const; total number of parameter defined. { return fValues.size(); }. const ROOT::Math::IMultiGenFunction * ObjFunction() const; return pointer to used objective function. { return fObjFunc; }. const ROOT::Math::IMultiGradFunction * GradObjFunction() const; return pointer to used gradient object function (NULL if gradient is not supported). void PrintResult() const; print result of minimization. const double * StepSizes() const; accessor methods. { return &fSteps.front(); }. bool CheckDimension() const. bool CheckObjFunction",MatchSource.WIKI,root/html534/ROOT__Math__BasicMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html
https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html:8874,Modifiability,variab,variable,8874,"signed int ivar, double lower); set the lower-limit of an already existing variable. bool SetVariableUpperLimit(unsigned int ivar, double upper); set the upper-limit of an already existing variable. bool SetVariableLimits(unsigned int ivar, double lower, double upper); set the limits of an already existing variable. bool FixVariable(unsigned int ivar); fix an existing variable. bool ReleaseVariable(unsigned int ivar); release an existing variable. bool IsFixedVariable(unsigned int ivar) const; query if an existing variable is fixed (i.e. considered constant in the minimization); note that by default all variables are not fixed. bool GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings& varObj) const; get variable settings in a variable object (like ROOT::Fit::ParamsSettings). std::string VariableName(unsigned int ivar) const; get name of variables (override if minimizer support storing of variable names). int VariableIndex(const string& name) const; get index of variable given a variable given a name; return -1 if variable is not found. bool Minimize(); method to perform the minimization. double MinValue() const; return minimum function value. { return fMinVal; }. const double * X() const; return pointer to X values at the minimum. { return &fValues.front(); }. unsigned int NDim() const; number of dimensions. { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem). unsigned int NPar() const; total number of parameter defined. { return fValues.size(); }. const ROOT::Math::IMultiGenFunction * ObjFunction() const; return pointer to used objective function. { return fObjFunc; }. const ROOT::Math::IMultiGradFunction * GradObjFunction() const; return pointer to used gradient object function (NULL if gradient is not supported). void PrintResult() const; print result of minimization. const double * StepSizes() const; accessor methods. { return &fSteps.front(); }. bool CheckDimension() const. bool CheckObjFunction",MatchSource.WIKI,root/html534/ROOT__Math__BasicMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html
https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html:8910,Modifiability,variab,variable,8910,"signed int ivar, double lower); set the lower-limit of an already existing variable. bool SetVariableUpperLimit(unsigned int ivar, double upper); set the upper-limit of an already existing variable. bool SetVariableLimits(unsigned int ivar, double lower, double upper); set the limits of an already existing variable. bool FixVariable(unsigned int ivar); fix an existing variable. bool ReleaseVariable(unsigned int ivar); release an existing variable. bool IsFixedVariable(unsigned int ivar) const; query if an existing variable is fixed (i.e. considered constant in the minimization); note that by default all variables are not fixed. bool GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings& varObj) const; get variable settings in a variable object (like ROOT::Fit::ParamsSettings). std::string VariableName(unsigned int ivar) const; get name of variables (override if minimizer support storing of variable names). int VariableIndex(const string& name) const; get index of variable given a variable given a name; return -1 if variable is not found. bool Minimize(); method to perform the minimization. double MinValue() const; return minimum function value. { return fMinVal; }. const double * X() const; return pointer to X values at the minimum. { return &fValues.front(); }. unsigned int NDim() const; number of dimensions. { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem). unsigned int NPar() const; total number of parameter defined. { return fValues.size(); }. const ROOT::Math::IMultiGenFunction * ObjFunction() const; return pointer to used objective function. { return fObjFunc; }. const ROOT::Math::IMultiGradFunction * GradObjFunction() const; return pointer to used gradient object function (NULL if gradient is not supported). void PrintResult() const; print result of minimization. const double * StepSizes() const; accessor methods. { return &fSteps.front(); }. bool CheckDimension() const. bool CheckObjFunction",MatchSource.WIKI,root/html534/ROOT__Math__BasicMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html
https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html:9272,Modifiability,variab,variables,9272,"gned int ivar); release an existing variable. bool IsFixedVariable(unsigned int ivar) const; query if an existing variable is fixed (i.e. considered constant in the minimization); note that by default all variables are not fixed. bool GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings& varObj) const; get variable settings in a variable object (like ROOT::Fit::ParamsSettings). std::string VariableName(unsigned int ivar) const; get name of variables (override if minimizer support storing of variable names). int VariableIndex(const string& name) const; get index of variable given a variable given a name; return -1 if variable is not found. bool Minimize(); method to perform the minimization. double MinValue() const; return minimum function value. { return fMinVal; }. const double * X() const; return pointer to X values at the minimum. { return &fValues.front(); }. unsigned int NDim() const; number of dimensions. { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem). unsigned int NPar() const; total number of parameter defined. { return fValues.size(); }. const ROOT::Math::IMultiGenFunction * ObjFunction() const; return pointer to used objective function. { return fObjFunc; }. const ROOT::Math::IMultiGradFunction * GradObjFunction() const; return pointer to used gradient object function (NULL if gradient is not supported). void PrintResult() const; print result of minimization. const double * StepSizes() const; accessor methods. { return &fSteps.front(); }. bool CheckDimension() const. bool CheckObjFunction() const. MinimTransformFunction * CreateTransformation(vector<double>& startValues, const ROOT::Math::IMultiGradFunction* func = 0). void SetFinalValues(const double* x). void SetMinValue(double val); { fMinVal = val; }.  Author: L. Moneta Oct 2012  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatic",MatchSource.WIKI,root/html534/ROOT__Math__BasicMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html
https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html:8960,Performance,perform,perform,8960,"VariableUpperLimit(unsigned int ivar, double upper); set the upper-limit of an already existing variable. bool SetVariableLimits(unsigned int ivar, double lower, double upper); set the limits of an already existing variable. bool FixVariable(unsigned int ivar); fix an existing variable. bool ReleaseVariable(unsigned int ivar); release an existing variable. bool IsFixedVariable(unsigned int ivar) const; query if an existing variable is fixed (i.e. considered constant in the minimization); note that by default all variables are not fixed. bool GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings& varObj) const; get variable settings in a variable object (like ROOT::Fit::ParamsSettings). std::string VariableName(unsigned int ivar) const; get name of variables (override if minimizer support storing of variable names). int VariableIndex(const string& name) const; get index of variable given a variable given a name; return -1 if variable is not found. bool Minimize(); method to perform the minimization. double MinValue() const; return minimum function value. { return fMinVal; }. const double * X() const; return pointer to X values at the minimum. { return &fValues.front(); }. unsigned int NDim() const; number of dimensions. { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem). unsigned int NPar() const; total number of parameter defined. { return fValues.size(); }. const ROOT::Math::IMultiGenFunction * ObjFunction() const; return pointer to used objective function. { return fObjFunc; }. const ROOT::Math::IMultiGradFunction * GradObjFunction() const; return pointer to used gradient object function (NULL if gradient is not supported). void PrintResult() const; print result of minimization. const double * StepSizes() const; accessor methods. { return &fSteps.front(); }. bool CheckDimension() const. bool CheckObjFunction() const. MinimTransformFunction * CreateTransformation(vector<double>& startValues, const ROO",MatchSource.WIKI,root/html534/ROOT__Math__BasicMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html
https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html:5835,Security,validat,validated,5835,"tVariableValues(const double* x); intROOT::Math::Minimizer::Status() const; virtual const double*StepSizes() const; intROOT::Math::Minimizer::Strategy() const; doubleROOT::Math::Minimizer::Tolerance() const; const ROOT::Math::MinimTransformFunction*TransformFunction() const; virtual intVariableIndex(const string& name) const; virtual stringVariableName(unsigned int ivar) const; virtual const double*X() const. protected:. boolCheckDimension() const; boolCheckObjFunction() const; ROOT::Math::MinimTransformFunction*CreateTransformation(vector<double>& startValues, const ROOT::Math::IMultiGradFunction* func = 0); voidSetFinalValues(const double* x); voidSetMinValue(double val). private:. ROOT::Math::BasicMinimizerBasicMinimizer(const ROOT::Math::BasicMinimizer&); ROOT::Math::BasicMinimizer&operator=(const ROOT::Math::BasicMinimizer& rhs). Data Members; protected:. ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::fOptionsminimizer options; intROOT::Math::Minimizer::fStatusstatus of minimizer ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. map<unsigned int,std::pair<double,double> >fBoundsmap specifying the bound using as key the parameter index; unsigned intfDim; doublefMinVal; vector<std::string>fNames; const ROOT::Math::IMultiGenFunction*fObjFunc; vector<double>fSteps; vector<double>fValues; vector<ROOT::Math::EMinimVariableType>fVarTypesvector specifyng the type of variables. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BasicMinimizer(). Default constructor. virtual ~BasicMinimizer(). Destructor. BasicMinimizer(const ROOT::Math::BasicMinimizer& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. {}. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set gradient the function to minimize. bool SetVariable(",MatchSource.WIKI,root/html534/ROOT__Math__BasicMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html
https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html:9768,Security,access,accessor,9768,"ixed (i.e. considered constant in the minimization); note that by default all variables are not fixed. bool GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings& varObj) const; get variable settings in a variable object (like ROOT::Fit::ParamsSettings). std::string VariableName(unsigned int ivar) const; get name of variables (override if minimizer support storing of variable names). int VariableIndex(const string& name) const; get index of variable given a variable given a name; return -1 if variable is not found. bool Minimize(); method to perform the minimization. double MinValue() const; return minimum function value. { return fMinVal; }. const double * X() const; return pointer to X values at the minimum. { return &fValues.front(); }. unsigned int NDim() const; number of dimensions. { return fDim; }. unsigned int NFree() const; number of free variables (real dimension of the problem). unsigned int NPar() const; total number of parameter defined. { return fValues.size(); }. const ROOT::Math::IMultiGenFunction * ObjFunction() const; return pointer to used objective function. { return fObjFunc; }. const ROOT::Math::IMultiGradFunction * GradObjFunction() const; return pointer to used gradient object function (NULL if gradient is not supported). void PrintResult() const; print result of minimization. const double * StepSizes() const; accessor methods. { return &fSteps.front(); }. bool CheckDimension() const. bool CheckObjFunction() const. MinimTransformFunction * CreateTransformation(vector<double>& startValues, const ROOT::Math::IMultiGradFunction* func = 0). void SetFinalValues(const double* x). void SetMinValue(double val); { fMinVal = val; }.  Author: L. Moneta Oct 2012  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__BasicMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BasicMinimizer.html
https://root.cern/root/html534/ROOT__Math__BrentMinimizer1D.html:1409,Availability,error,error,1409," use the Brent Method for function minimization in a given interval.; First, a grid search is used to bracket the minimum value; with the a step size = (xmax-xmin)/npx. The step size; can be controlled via the SetNpx() function. A default value of npx = 100 is used.; The default value con be changed using the static method SetDefaultNpx.; If the function is unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval.; If the Brent method fails to converge the bracketing is repeted on the latest best estimate of the; interval. The procedure is repeted with a maximum value (default =10) which can be set for all; BrentRootFinder classes with the method SetDefaultNSearch. This class is implemented from TF1::GetMinimum. To use the class, three steps have to be taken:; 1. Create the class.; 2. Set a function within an interval to look for the minimum.; 3. Call the Minimize function with the error parameters. If another minimization is to be performed, repeat the last two steps. @ingroup Min1D. Function Members (Methods); public:. virtual~BrentMinimizer1D(); ROOT::Math::BrentMinimizer1DBrentMinimizer1D(); ROOT::Math::BrentMinimizer1DBrentMinimizer1D(const ROOT::Math::BrentMinimizer1D&); virtual doubleFValLower() const; virtual doubleFValMinimum() const; virtual doubleFValUpper() const; virtual intIterations() const; virtual boolMinimize(int maxIter, double absTol = 1.E-8, double relTol = 1.E-10); virtual const char*Name() const; static voidSetDefaultNpx(int npx); static voidSetDefaultNSearch(int n); voidSetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); voidSetLogScan(bool on); voidSetNpx(int npx); virtual intStatus() const; virtual doubleXLower() const; virtual doubleXMinimum() const; virtual doubleXUpper() const. private:. ROOT::Math::IMinimizer1D&ROOT::Math::IMinimizer1D::operator=(const ROOT::Math::IMinimizer1D&). Data Members; private:.",MatchSource.WIKI,root/html534/ROOT__Math__BrentMinimizer1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BrentMinimizer1D.html
https://root.cern/root/html534/ROOT__Math__BrentMinimizer1D.html:3791,Availability,toler,tolerance,3791,"arch interval.; doublefXMinimumPosition of the stimated minimum. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BrentMinimizer1D(); Default Constructor. . virtual ~BrentMinimizer1D(); Default Destructor. . {}. double XMinimum() const; Return current estimate of the position of the minimum. . { return fXMinimum; }. double XLower() const; Return current lower bound of the minimization interval. . { return fXMin; }. double XUpper() const; Return current upper bound of the minimization interval. . { return fXMax; }. double FValMinimum() const; Return function value at current estimate of the minimum. . double FValLower() const; Return function value at current lower bound of the minimization interval. . double FValUpper() const; Return function value at current upper bound of the minimization interval. . bool Minimize(int maxIter, double absTol = 1.E-8, double relTol = 1.E-10); Find minimum position iterating until convergence specified by the absolute and relative tolerance or; the maximum number of iteration is reached.; Return true if iterations converged successfully; \@param maxIter maximum number of iterations.; \@param absTol desired absolute error in the minimum position (default 1.E-8); \@param absTol desired relative error in the minimum position (default = 1.E-10). int Iterations() const; Return number of iteration used to find minimum . { return fNIter; }. const char * Name() const; Return name of minimization algorithm (""BrentMinimizer1D"") . void SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); Sets function to be minimized. \@param f Function to be minimized.; \@param xlow Lower bound of the search interval.; \@param xup Upper bound of the search interval. void SetNpx(int npx); Set the number of point used to bracket root using a grid . { fNpx = npx; }. void SetLogScan(bool on). Set a log grid scan (default is equidistant bins); will work only if xlow > 0. { fLogScan = on; }. int Status() c",MatchSource.WIKI,root/html534/ROOT__Math__BrentMinimizer1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BrentMinimizer1D.html
https://root.cern/root/html534/ROOT__Math__BrentMinimizer1D.html:3979,Availability,error,error,3979,"ntMinimizer1D(); Default Destructor. . {}. double XMinimum() const; Return current estimate of the position of the minimum. . { return fXMinimum; }. double XLower() const; Return current lower bound of the minimization interval. . { return fXMin; }. double XUpper() const; Return current upper bound of the minimization interval. . { return fXMax; }. double FValMinimum() const; Return function value at current estimate of the minimum. . double FValLower() const; Return function value at current lower bound of the minimization interval. . double FValUpper() const; Return function value at current upper bound of the minimization interval. . bool Minimize(int maxIter, double absTol = 1.E-8, double relTol = 1.E-10); Find minimum position iterating until convergence specified by the absolute and relative tolerance or; the maximum number of iteration is reached.; Return true if iterations converged successfully; \@param maxIter maximum number of iterations.; \@param absTol desired absolute error in the minimum position (default 1.E-8); \@param absTol desired relative error in the minimum position (default = 1.E-10). int Iterations() const; Return number of iteration used to find minimum . { return fNIter; }. const char * Name() const; Return name of minimization algorithm (""BrentMinimizer1D"") . void SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); Sets function to be minimized. \@param f Function to be minimized.; \@param xlow Lower bound of the search interval.; \@param xup Upper bound of the search interval. void SetNpx(int npx); Set the number of point used to bracket root using a grid . { fNpx = npx; }. void SetLogScan(bool on). Set a log grid scan (default is equidistant bins); will work only if xlow > 0. { fLogScan = on; }. int Status() const; Returns status of last estimate. If = 0 is OK . { return fStatus; }. void SetDefaultNpx(int npx); static function used to modify the default parameters; set number of default Npx used at construction time ",MatchSource.WIKI,root/html534/ROOT__Math__BrentMinimizer1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BrentMinimizer1D.html
https://root.cern/root/html534/ROOT__Math__BrentMinimizer1D.html:4058,Availability,error,error,4058,"rent estimate of the position of the minimum. . { return fXMinimum; }. double XLower() const; Return current lower bound of the minimization interval. . { return fXMin; }. double XUpper() const; Return current upper bound of the minimization interval. . { return fXMax; }. double FValMinimum() const; Return function value at current estimate of the minimum. . double FValLower() const; Return function value at current lower bound of the minimization interval. . double FValUpper() const; Return function value at current upper bound of the minimization interval. . bool Minimize(int maxIter, double absTol = 1.E-8, double relTol = 1.E-10); Find minimum position iterating until convergence specified by the absolute and relative tolerance or; the maximum number of iteration is reached.; Return true if iterations converged successfully; \@param maxIter maximum number of iterations.; \@param absTol desired absolute error in the minimum position (default 1.E-8); \@param absTol desired relative error in the minimum position (default = 1.E-10). int Iterations() const; Return number of iteration used to find minimum . { return fNIter; }. const char * Name() const; Return name of minimization algorithm (""BrentMinimizer1D"") . void SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); Sets function to be minimized. \@param f Function to be minimized.; \@param xlow Lower bound of the search interval.; \@param xup Upper bound of the search interval. void SetNpx(int npx); Set the number of point used to bracket root using a grid . { fNpx = npx; }. void SetLogScan(bool on). Set a log grid scan (default is equidistant bins); will work only if xlow > 0. { fLogScan = on; }. int Status() const; Returns status of last estimate. If = 0 is OK . { return fStatus; }. void SetDefaultNpx(int npx); static function used to modify the default parameters; set number of default Npx used at construction time (when SetNpx is not called); Default value is 100. void SetDefaultNSearch(int ",MatchSource.WIKI,root/html534/ROOT__Math__BrentMinimizer1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BrentMinimizer1D.html
https://root.cern/root/html534/ROOT__Math__BrentMinimizer1D.html:358,Performance,perform,performing,358,". ROOT::Math::BrentMinimizer1D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::BrentMinimizer1D. class ROOT::Math::BrentMinimizer1D: private ROOT::Math::IMinimizer1D. User class for performing function minimization. It will use the Brent Method for function minimization in a given interval.; First, a grid search is used to bracket the minimum value; with the a step size = (xmax-xmin)/npx. The step size; can be controlled via the SetNpx() function. A default value of npx = 100 is used.; The default value con be changed using the static method SetDefaultNpx.; If the function is unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval.; If the Brent method fails to converge the bracketing is repeted on the latest best estimate of the; interval. The procedure is repeted with a maximum value (default =10) which can be set for all; BrentRootFinder classes with the method SetDefaultNSearch. This class is implemented from TF1::GetMinimum. To use the class, three steps have to be taken:; 1. Create the class.; 2. Set a function within an interval to look for the minimum.; 3. Call the Minimize function with the error parameters. If another minimization is to be performed, repeat the last two steps. @ingroup Min1D. Function Members (Methods); public:. virtual~BrentMinimizer1D(); ROOT::Math::BrentMinimizer1DBrentMinimizer1D(); ROOT::Math::BrentMinimizer1DBrentMinimizer1D(const ROOT::Math::BrentMinimizer1D&); virtual doubleFValLower() const; virtual doubleFValMinimum() const; virtual doubleFValUpper() const; virtual intIterations() const; virtual boolMinimize(int maxIter, double absTol = 1.E-8, double relTol = 1.E-10); virtual const char*Name() const; static voidSetDefaultNpx(int npx); static vo",MatchSource.WIKI,root/html534/ROOT__Math__BrentMinimizer1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BrentMinimizer1D.html
https://root.cern/root/html534/ROOT__Math__BrentMinimizer1D.html:1460,Performance,perform,performed,1460,"erval.; First, a grid search is used to bracket the minimum value; with the a step size = (xmax-xmin)/npx. The step size; can be controlled via the SetNpx() function. A default value of npx = 100 is used.; The default value con be changed using the static method SetDefaultNpx.; If the function is unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval.; If the Brent method fails to converge the bracketing is repeted on the latest best estimate of the; interval. The procedure is repeted with a maximum value (default =10) which can be set for all; BrentRootFinder classes with the method SetDefaultNSearch. This class is implemented from TF1::GetMinimum. To use the class, three steps have to be taken:; 1. Create the class.; 2. Set a function within an interval to look for the minimum.; 3. Call the Minimize function with the error parameters. If another minimization is to be performed, repeat the last two steps. @ingroup Min1D. Function Members (Methods); public:. virtual~BrentMinimizer1D(); ROOT::Math::BrentMinimizer1DBrentMinimizer1D(); ROOT::Math::BrentMinimizer1DBrentMinimizer1D(const ROOT::Math::BrentMinimizer1D&); virtual doubleFValLower() const; virtual doubleFValMinimum() const; virtual doubleFValUpper() const; virtual intIterations() const; virtual boolMinimize(int maxIter, double absTol = 1.E-8, double relTol = 1.E-10); virtual const char*Name() const; static voidSetDefaultNpx(int npx); static voidSetDefaultNSearch(int n); voidSetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); voidSetLogScan(bool on); voidSetNpx(int npx); virtual intStatus() const; virtual doubleXLower() const; virtual doubleXMinimum() const; virtual doubleXUpper() const. private:. ROOT::Math::IMinimizer1D&ROOT::Math::IMinimizer1D::operator=(const ROOT::Math::IMinimizer1D&). Data Members; private:. const ROOT::Math::IGenFunction*fFunctionPointer to the functio",MatchSource.WIKI,root/html534/ROOT__Math__BrentMinimizer1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BrentMinimizer1D.html
https://root.cern/root/html534/ROOT__Math__BrentMinimizer1D.html:2505,Testability,log,log,2505,"on Members (Methods); public:. virtual~BrentMinimizer1D(); ROOT::Math::BrentMinimizer1DBrentMinimizer1D(); ROOT::Math::BrentMinimizer1DBrentMinimizer1D(const ROOT::Math::BrentMinimizer1D&); virtual doubleFValLower() const; virtual doubleFValMinimum() const; virtual doubleFValUpper() const; virtual intIterations() const; virtual boolMinimize(int maxIter, double absTol = 1.E-8, double relTol = 1.E-10); virtual const char*Name() const; static voidSetDefaultNpx(int npx); static voidSetDefaultNSearch(int n); voidSetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); voidSetLogScan(bool on); voidSetNpx(int npx); virtual intStatus() const; virtual doubleXLower() const; virtual doubleXMinimum() const; virtual doubleXUpper() const. private:. ROOT::Math::IMinimizer1D&ROOT::Math::IMinimizer1D::operator=(const ROOT::Math::IMinimizer1D&). Data Members; private:. const ROOT::Math::IGenFunction*fFunctionPointer to the function.; boolfLogScanflag to control usage of a log scan; intfNIterNumber of iterations needed for the last estimation.; intfNpxNumber of points to bracket minimum with grid (def is 100); intfStatusStatus of code of the last estimate; doublefXMaxUpper bound of the search interval; doublefXMinLower bound of the search interval.; doublefXMinimumPosition of the stimated minimum. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BrentMinimizer1D(); Default Constructor. . virtual ~BrentMinimizer1D(); Default Destructor. . {}. double XMinimum() const; Return current estimate of the position of the minimum. . { return fXMinimum; }. double XLower() const; Return current lower bound of the minimization interval. . { return fXMin; }. double XUpper() const; Return current upper bound of the minimization interval. . { return fXMax; }. double FValMinimum() const; Return function value at current estimate of the minimum. . double FValLower() const; Return function value at current lower bound of the minimization interval",MatchSource.WIKI,root/html534/ROOT__Math__BrentMinimizer1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BrentMinimizer1D.html
https://root.cern/root/html534/ROOT__Math__BrentMinimizer1D.html:4665,Testability,log,log,4665,"d of the minimization interval. . double FValUpper() const; Return function value at current upper bound of the minimization interval. . bool Minimize(int maxIter, double absTol = 1.E-8, double relTol = 1.E-10); Find minimum position iterating until convergence specified by the absolute and relative tolerance or; the maximum number of iteration is reached.; Return true if iterations converged successfully; \@param maxIter maximum number of iterations.; \@param absTol desired absolute error in the minimum position (default 1.E-8); \@param absTol desired relative error in the minimum position (default = 1.E-10). int Iterations() const; Return number of iteration used to find minimum . { return fNIter; }. const char * Name() const; Return name of minimization algorithm (""BrentMinimizer1D"") . void SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); Sets function to be minimized. \@param f Function to be minimized.; \@param xlow Lower bound of the search interval.; \@param xup Upper bound of the search interval. void SetNpx(int npx); Set the number of point used to bracket root using a grid . { fNpx = npx; }. void SetLogScan(bool on). Set a log grid scan (default is equidistant bins); will work only if xlow > 0. { fLogScan = on; }. int Status() const; Returns status of last estimate. If = 0 is OK . { return fStatus; }. void SetDefaultNpx(int npx); static function used to modify the default parameters; set number of default Npx used at construction time (when SetNpx is not called); Default value is 100. void SetDefaultNSearch(int n); set number of times the bracketing search in combination with is done to find a good interval; Default value is 10.  Author: David Gonzalez Maline 2/2008  Copyright (c) 2004 Maline, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__BrentMinimizer1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BrentMinimizer1D.html
https://root.cern/root/html534/ROOT__Math__BrentRootFinder.html:3465,Availability,error,error,3465,"StatusStatus of code of the last estimate; doublefXMaxUpper bound of the search interval; doublefXMinLower bound of the search interval. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BrentRootFinder(); Default Constructor. . virtual ~BrentRootFinder(); Default Destructor. . {}. bool SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup). bool Solve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); Returns the X value corresponding to the function value fy for (xmin<x<xmax).; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx. This way, the step size; can be controlled via the SetNpx() function. If the function is; unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval. \@param maxIter maximum number of iterations.; \@param absTol desired absolute error in the minimum position.; \@param absTol desired relative error in the minimum position. void SetNpx(int npx); Set the number of point used to bracket root using a grid . { fNpx = npx; }. void SetLogScan(bool on). Set a log grid scan (default is equidistant bins); will work only if xlow > 0. { fLogScan = on; }. double Root() const; Returns root value. Need to call first Solve(). . { return fRoot; }. int Status() const; Returns status of last estimate. If = 0 is OK . { return fStatus; }. int Iterations() const; Return number of iteration used to find minimum . { return fNIter; }. const char* Name() const; Return name of root finder algorithm (""BrentRootFinder""). . void SetDefaultNpx(int npx); static function used to modify the default parameters; set number of default Npx used at construction time (when SetNpx is not called); Default value is 100. void SetDefaultNSearch(int n); set number of times the bracketing search in combination with is done to find a good interval; Default",MatchSource.WIKI,root/html534/ROOT__Math__BrentRootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BrentRootFinder.html
https://root.cern/root/html534/ROOT__Math__BrentRootFinder.html:3529,Availability,error,error,3529,"d of the search interval; doublefXMinLower bound of the search interval. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BrentRootFinder(); Default Constructor. . virtual ~BrentRootFinder(); Default Destructor. . {}. bool SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup). bool Solve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); Returns the X value corresponding to the function value fy for (xmin<x<xmax).; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx. This way, the step size; can be controlled via the SetNpx() function. If the function is; unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval. \@param maxIter maximum number of iterations.; \@param absTol desired absolute error in the minimum position.; \@param absTol desired relative error in the minimum position. void SetNpx(int npx); Set the number of point used to bracket root using a grid . { fNpx = npx; }. void SetLogScan(bool on). Set a log grid scan (default is equidistant bins); will work only if xlow > 0. { fLogScan = on; }. double Root() const; Returns root value. Need to call first Solve(). . { return fRoot; }. int Status() const; Returns status of last estimate. If = 0 is OK . { return fStatus; }. int Iterations() const; Return number of iteration used to find minimum . { return fNIter; }. const char* Name() const; Return name of root finder algorithm (""BrentRootFinder""). . void SetDefaultNpx(int npx); static function used to modify the default parameters; set number of default Npx used at construction time (when SetNpx is not called); Default value is 100. void SetDefaultNSearch(int n); set number of times the bracketing search in combination with is done to find a good interval; Default value is 10.  Last changed: root/mathcore:$Id$  Last generate",MatchSource.WIKI,root/html534/ROOT__Math__BrentRootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BrentRootFinder.html
https://root.cern/root/html534/ROOT__Math__BrentRootFinder.html:2261,Testability,log,log,2261,"ethod SetDefaultNSearch. This class is implemented from TF1::GetX() method. @ingroup RootFinders. Function Members (Methods); public:. virtual~BrentRootFinder(); ROOT::Math::BrentRootFinderBrentRootFinder(); ROOT::Math::BrentRootFinderBrentRootFinder(const ROOT::Math::BrentRootFinder&); virtual intROOT::Math::IRootFinderMethod::Iterate(); virtual intIterations() const; virtual const char*Name() const; ROOT::Math::IRootFinderMethod&ROOT::Math::IRootFinderMethod::operator=(const ROOT::Math::IRootFinderMethod&); virtual doubleRoot() const; static voidSetDefaultNpx(int npx); static voidSetDefaultNSearch(int n); virtual boolSetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); voidSetLogScan(bool on); voidSetNpx(int npx); virtual boolSolve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); virtual intStatus() const. Data Members; private:. const ROOT::Math::IGenFunction*fFunctionPointer to the function.; boolfLogScanflag to control usage of a log scan ; intfNIterNumber of iterations needed for the last estimation.; intfNpxNumber of points to bracket root with initial grid (def is 100); doublefRootCurrent stimation of the function root.; intfStatusStatus of code of the last estimate; doublefXMaxUpper bound of the search interval; doublefXMinLower bound of the search interval. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BrentRootFinder(); Default Constructor. . virtual ~BrentRootFinder(); Default Destructor. . {}. bool SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup). bool Solve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); Returns the X value corresponding to the function value fy for (xmin<x<xmax).; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx. This way, the step size; can be controlled via the SetNpx() function. If the function is; unimodal or if its extrema are far apart, setting the fNpx to; a",MatchSource.WIKI,root/html534/ROOT__Math__BrentRootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BrentRootFinder.html
https://root.cern/root/html534/ROOT__Math__BrentRootFinder.html:3691,Testability,log,log,3691,"der(); Default Constructor. . virtual ~BrentRootFinder(); Default Destructor. . {}. bool SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup). bool Solve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); Returns the X value corresponding to the function value fy for (xmin<x<xmax).; Method:; First, the grid search is used to bracket the maximum; with the step size = (xmax-xmin)/fNpx. This way, the step size; can be controlled via the SetNpx() function. If the function is; unimodal or if its extrema are far apart, setting the fNpx to; a small value speeds the algorithm up many times.; Then, Brent's method is applied on the bracketed interval. \@param maxIter maximum number of iterations.; \@param absTol desired absolute error in the minimum position.; \@param absTol desired relative error in the minimum position. void SetNpx(int npx); Set the number of point used to bracket root using a grid . { fNpx = npx; }. void SetLogScan(bool on). Set a log grid scan (default is equidistant bins); will work only if xlow > 0. { fLogScan = on; }. double Root() const; Returns root value. Need to call first Solve(). . { return fRoot; }. int Status() const; Returns status of last estimate. If = 0 is OK . { return fStatus; }. int Iterations() const; Return number of iteration used to find minimum . { return fNIter; }. const char* Name() const; Return name of root finder algorithm (""BrentRootFinder""). . void SetDefaultNpx(int npx); static function used to modify the default parameters; set number of default Npx used at construction time (when SetNpx is not called); Default value is 100. void SetDefaultNSearch(int n); set number of times the bracketing search in combination with is done to find a good interval; Default value is 10.  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__BrentRootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__BrentRootFinder.html
https://root.cern/root/html534/ROOT__Math__ChebyshevApprox.html:2632,Availability,error,error,2632,"LChebSeries*fSeries. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ChebyshevApprox(const ROOT::Math::IGenFunction& f, double a, double b, size_t n). Construct a Chebyshev series approximation to a Function f in range [a,b];; constructor based on functions of type IGenFunction. ChebyshevApprox(ROOT::Math::GSLFuncPointer f, void* p, double a, double b, size_t n). Construct a Chebyshev series approximation to a Function f in range [a,b];; constructor based on free functions with gsl_function type signature. virtual ~ChebyshevApprox(); destructor. ChebyshevApprox(size_t n). construct a Chebyshev series or order n; The series must be initialized from a function. ChebyshevApprox(const ROOT::Math::ChebyshevApprox& ); usually copying is non trivial, so we make this unaccessible. double operator()(double x) const. Evaluate the series at a given point x. std::pair<double, double> EvalErr(double x) const. Evaluate the series at a given point x estimating both the series result and its absolute error.; The error estimate is made from the first neglected term in the series.; A pair containing result and error is returned. double operator()(double x, size_t n) const. Evaluate the series at a given point, to (at most) the given order n. std::pair<double, double> EvalErr(double x, size_t n) const. evaluate the series at a given point x to the given order n,; estimating both the series result and its absolute error.; The error estimate is made from the first neglected term in the series.; A pair containing result and error is returned. ChebyshevApprox * Deriv(). Compute the derivative of the series and return a pointer to a new Chebyshev series with the; derivatives coefficients. The returned pointer must be managed by the user. TO DO: implement copying to return by value. ChebyshevApprox * Integral(). Compute the integral of the series and return a pointer to a new Chebyshev series with the; integral coefficients. The lower limit of the i",MatchSource.WIKI,root/html534/ROOT__Math__ChebyshevApprox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__ChebyshevApprox.html
https://root.cern/root/html534/ROOT__Math__ChebyshevApprox.html:2644,Availability,error,error,2644,"s. Function documentation; ChebyshevApprox(const ROOT::Math::IGenFunction& f, double a, double b, size_t n). Construct a Chebyshev series approximation to a Function f in range [a,b];; constructor based on functions of type IGenFunction. ChebyshevApprox(ROOT::Math::GSLFuncPointer f, void* p, double a, double b, size_t n). Construct a Chebyshev series approximation to a Function f in range [a,b];; constructor based on free functions with gsl_function type signature. virtual ~ChebyshevApprox(); destructor. ChebyshevApprox(size_t n). construct a Chebyshev series or order n; The series must be initialized from a function. ChebyshevApprox(const ROOT::Math::ChebyshevApprox& ); usually copying is non trivial, so we make this unaccessible. double operator()(double x) const. Evaluate the series at a given point x. std::pair<double, double> EvalErr(double x) const. Evaluate the series at a given point x estimating both the series result and its absolute error.; The error estimate is made from the first neglected term in the series.; A pair containing result and error is returned. double operator()(double x, size_t n) const. Evaluate the series at a given point, to (at most) the given order n. std::pair<double, double> EvalErr(double x, size_t n) const. evaluate the series at a given point x to the given order n,; estimating both the series result and its absolute error.; The error estimate is made from the first neglected term in the series.; A pair containing result and error is returned. ChebyshevApprox * Deriv(). Compute the derivative of the series and return a pointer to a new Chebyshev series with the; derivatives coefficients. The returned pointer must be managed by the user. TO DO: implement copying to return by value. ChebyshevApprox * Integral(). Compute the integral of the series and return a pointer to a new Chebyshev series with the; integral coefficients. The lower limit of the integration is the left range value a.; The returned pointer must be managed by the us",MatchSource.WIKI,root/html534/ROOT__Math__ChebyshevApprox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__ChebyshevApprox.html
https://root.cern/root/html534/ROOT__Math__ChebyshevApprox.html:2742,Availability,error,error,2742,"IGenFunction& f, double a, double b, size_t n). Construct a Chebyshev series approximation to a Function f in range [a,b];; constructor based on functions of type IGenFunction. ChebyshevApprox(ROOT::Math::GSLFuncPointer f, void* p, double a, double b, size_t n). Construct a Chebyshev series approximation to a Function f in range [a,b];; constructor based on free functions with gsl_function type signature. virtual ~ChebyshevApprox(); destructor. ChebyshevApprox(size_t n). construct a Chebyshev series or order n; The series must be initialized from a function. ChebyshevApprox(const ROOT::Math::ChebyshevApprox& ); usually copying is non trivial, so we make this unaccessible. double operator()(double x) const. Evaluate the series at a given point x. std::pair<double, double> EvalErr(double x) const. Evaluate the series at a given point x estimating both the series result and its absolute error.; The error estimate is made from the first neglected term in the series.; A pair containing result and error is returned. double operator()(double x, size_t n) const. Evaluate the series at a given point, to (at most) the given order n. std::pair<double, double> EvalErr(double x, size_t n) const. evaluate the series at a given point x to the given order n,; estimating both the series result and its absolute error.; The error estimate is made from the first neglected term in the series.; A pair containing result and error is returned. ChebyshevApprox * Deriv(). Compute the derivative of the series and return a pointer to a new Chebyshev series with the; derivatives coefficients. The returned pointer must be managed by the user. TO DO: implement copying to return by value. ChebyshevApprox * Integral(). Compute the integral of the series and return a pointer to a new Chebyshev series with the; integral coefficients. The lower limit of the integration is the left range value a.; The returned pointer must be managed by the user. TO DO: implement copying to return by value. void Initial",MatchSource.WIKI,root/html534/ROOT__Math__ChebyshevApprox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__ChebyshevApprox.html
https://root.cern/root/html534/ROOT__Math__ChebyshevApprox.html:3050,Availability,error,error,3050,". Construct a Chebyshev series approximation to a Function f in range [a,b];; constructor based on free functions with gsl_function type signature. virtual ~ChebyshevApprox(); destructor. ChebyshevApprox(size_t n). construct a Chebyshev series or order n; The series must be initialized from a function. ChebyshevApprox(const ROOT::Math::ChebyshevApprox& ); usually copying is non trivial, so we make this unaccessible. double operator()(double x) const. Evaluate the series at a given point x. std::pair<double, double> EvalErr(double x) const. Evaluate the series at a given point x estimating both the series result and its absolute error.; The error estimate is made from the first neglected term in the series.; A pair containing result and error is returned. double operator()(double x, size_t n) const. Evaluate the series at a given point, to (at most) the given order n. std::pair<double, double> EvalErr(double x, size_t n) const. evaluate the series at a given point x to the given order n,; estimating both the series result and its absolute error.; The error estimate is made from the first neglected term in the series.; A pair containing result and error is returned. ChebyshevApprox * Deriv(). Compute the derivative of the series and return a pointer to a new Chebyshev series with the; derivatives coefficients. The returned pointer must be managed by the user. TO DO: implement copying to return by value. ChebyshevApprox * Integral(). Compute the integral of the series and return a pointer to a new Chebyshev series with the; integral coefficients. The lower limit of the integration is the left range value a.; The returned pointer must be managed by the user. TO DO: implement copying to return by value. void Initialize(ROOT::Math::GSLFuncPointer f, void* params, double a, double b). Initialize series passing function and range.  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions re",MatchSource.WIKI,root/html534/ROOT__Math__ChebyshevApprox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__ChebyshevApprox.html
https://root.cern/root/html534/ROOT__Math__ChebyshevApprox.html:3062,Availability,error,error,3062,"structor based on free functions with gsl_function type signature. virtual ~ChebyshevApprox(); destructor. ChebyshevApprox(size_t n). construct a Chebyshev series or order n; The series must be initialized from a function. ChebyshevApprox(const ROOT::Math::ChebyshevApprox& ); usually copying is non trivial, so we make this unaccessible. double operator()(double x) const. Evaluate the series at a given point x. std::pair<double, double> EvalErr(double x) const. Evaluate the series at a given point x estimating both the series result and its absolute error.; The error estimate is made from the first neglected term in the series.; A pair containing result and error is returned. double operator()(double x, size_t n) const. Evaluate the series at a given point, to (at most) the given order n. std::pair<double, double> EvalErr(double x, size_t n) const. evaluate the series at a given point x to the given order n,; estimating both the series result and its absolute error.; The error estimate is made from the first neglected term in the series.; A pair containing result and error is returned. ChebyshevApprox * Deriv(). Compute the derivative of the series and return a pointer to a new Chebyshev series with the; derivatives coefficients. The returned pointer must be managed by the user. TO DO: implement copying to return by value. ChebyshevApprox * Integral(). Compute the integral of the series and return a pointer to a new Chebyshev series with the; integral coefficients. The lower limit of the integration is the left range value a.; The returned pointer must be managed by the user. TO DO: implement copying to return by value. void Initialize(ROOT::Math::GSLFuncPointer f, void* params, double a, double b). Initialize series passing function and range.  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__ChebyshevApprox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__ChebyshevApprox.html
https://root.cern/root/html534/ROOT__Math__ChebyshevApprox.html:3160,Availability,error,error,3160,"structor based on free functions with gsl_function type signature. virtual ~ChebyshevApprox(); destructor. ChebyshevApprox(size_t n). construct a Chebyshev series or order n; The series must be initialized from a function. ChebyshevApprox(const ROOT::Math::ChebyshevApprox& ); usually copying is non trivial, so we make this unaccessible. double operator()(double x) const. Evaluate the series at a given point x. std::pair<double, double> EvalErr(double x) const. Evaluate the series at a given point x estimating both the series result and its absolute error.; The error estimate is made from the first neglected term in the series.; A pair containing result and error is returned. double operator()(double x, size_t n) const. Evaluate the series at a given point, to (at most) the given order n. std::pair<double, double> EvalErr(double x, size_t n) const. evaluate the series at a given point x to the given order n,; estimating both the series result and its absolute error.; The error estimate is made from the first neglected term in the series.; A pair containing result and error is returned. ChebyshevApprox * Deriv(). Compute the derivative of the series and return a pointer to a new Chebyshev series with the; derivatives coefficients. The returned pointer must be managed by the user. TO DO: implement copying to return by value. ChebyshevApprox * Integral(). Compute the integral of the series and return a pointer to a new Chebyshev series with the; integral coefficients. The lower limit of the integration is the left range value a.; The returned pointer must be managed by the user. TO DO: implement copying to return by value. void Initialize(ROOT::Math::GSLFuncPointer f, void* params, double a, double b). Initialize series passing function and range.  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__ChebyshevApprox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__ChebyshevApprox.html
https://root.cern/root/html534/ROOT__Math__ChebyshevApprox.html:3589,Deployability,integrat,integration,3589,"structor based on free functions with gsl_function type signature. virtual ~ChebyshevApprox(); destructor. ChebyshevApprox(size_t n). construct a Chebyshev series or order n; The series must be initialized from a function. ChebyshevApprox(const ROOT::Math::ChebyshevApprox& ); usually copying is non trivial, so we make this unaccessible. double operator()(double x) const. Evaluate the series at a given point x. std::pair<double, double> EvalErr(double x) const. Evaluate the series at a given point x estimating both the series result and its absolute error.; The error estimate is made from the first neglected term in the series.; A pair containing result and error is returned. double operator()(double x, size_t n) const. Evaluate the series at a given point, to (at most) the given order n. std::pair<double, double> EvalErr(double x, size_t n) const. evaluate the series at a given point x to the given order n,; estimating both the series result and its absolute error.; The error estimate is made from the first neglected term in the series.; A pair containing result and error is returned. ChebyshevApprox * Deriv(). Compute the derivative of the series and return a pointer to a new Chebyshev series with the; derivatives coefficients. The returned pointer must be managed by the user. TO DO: implement copying to return by value. ChebyshevApprox * Integral(). Compute the integral of the series and return a pointer to a new Chebyshev series with the; integral coefficients. The lower limit of the integration is the left range value a.; The returned pointer must be managed by the user. TO DO: implement copying to return by value. void Initialize(ROOT::Math::GSLFuncPointer f, void* params, double a, double b). Initialize series passing function and range.  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__ChebyshevApprox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__ChebyshevApprox.html
https://root.cern/root/html534/ROOT__Math__ChebyshevApprox.html:3589,Integrability,integrat,integration,3589,"structor based on free functions with gsl_function type signature. virtual ~ChebyshevApprox(); destructor. ChebyshevApprox(size_t n). construct a Chebyshev series or order n; The series must be initialized from a function. ChebyshevApprox(const ROOT::Math::ChebyshevApprox& ); usually copying is non trivial, so we make this unaccessible. double operator()(double x) const. Evaluate the series at a given point x. std::pair<double, double> EvalErr(double x) const. Evaluate the series at a given point x estimating both the series result and its absolute error.; The error estimate is made from the first neglected term in the series.; A pair containing result and error is returned. double operator()(double x, size_t n) const. Evaluate the series at a given point, to (at most) the given order n. std::pair<double, double> EvalErr(double x, size_t n) const. evaluate the series at a given point x to the given order n,; estimating both the series result and its absolute error.; The error estimate is made from the first neglected term in the series.; A pair containing result and error is returned. ChebyshevApprox * Deriv(). Compute the derivative of the series and return a pointer to a new Chebyshev series with the; derivatives coefficients. The returned pointer must be managed by the user. TO DO: implement copying to return by value. ChebyshevApprox * Integral(). Compute the integral of the series and return a pointer to a new Chebyshev series with the; integral coefficients. The lower limit of the integration is the left range value a.; The returned pointer must be managed by the user. TO DO: implement copying to return by value. void Initialize(ROOT::Math::GSLFuncPointer f, void* params, double a, double b). Initialize series passing function and range.  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__ChebyshevApprox.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__ChebyshevApprox.html
https://root.cern/root/html534/ROOT__Math__Cylindrical3D_Double32_t_.html:4653,Security,access,accessors,4653,"ates(const ROOT::Math::Cylindrical3D<Double32_t>::Scalar* src). Set internal data based on an array of 3 Scalar numbers ( rho, z , phi). { fRho=src[0]; fZ=src[1]; fPhi=src[2]; Restrict(); }. void GetCoordinates(ROOT::Math::Cylindrical3D<Double32_t>::Scalar* dest) const. get internal data into an array of 3 Scalar numbers ( rho, z , phi). { dest[0] = fRho; dest[1] = fZ; dest[2] = fPhi; }. void SetCoordinates(ROOT::Math::Cylindrical3D<Double32_t>::Scalar rho, ROOT::Math::Cylindrical3D<Double32_t>::Scalar zz, ROOT::Math::Cylindrical3D<Double32_t>::Scalar phi). Set internal data based on 3 Scalar numbers ( rho, z , phi). { fRho=rho; fZ=zz; fPhi=phi; Restrict(); }. void GetCoordinates(ROOT::Math::Cylindrical3D<Double32_t>::Scalar& rho, ROOT::Math::Cylindrical3D<Double32_t>::Scalar& zz, ROOT::Math::Cylindrical3D<Double32_t>::Scalar& phi) const. get internal data into 3 Scalar numbers ( rho, z , phi). {rho=fRho; zz=fZ; phi=fPhi;}. Scalar pi(); { return M_PI; }. void Restrict(). Scalar Rho() const; accessors. { return fRho; }. Scalar Z() const; { return fZ; }. Scalar Phi() const; { return fPhi; }. Scalar X() const; { return fRho*std::cos(fPhi); }. Scalar Y() const; { return fRho*std::sin(fPhi); }. Scalar Mag2() const; { return fRho*fRho + fZ*fZ; }. Scalar R() const; { return std::sqrt( Mag2()); }. Scalar Perp2() const; { return fRho*fRho; }. Scalar Theta() const; { return (fRho==0 && fZ==0 ) ? 0 : atan2(fRho,fZ); }. Scalar Eta() const; pseudorapidity - use same implementation as in Cartesian3D. void SetRho(Double32_t rho); setters (only for data members). set the rho coordinate value keeping z and phi constant. void SetZ(Double32_t zz). set the z coordinate value keeping rho and phi constant. void SetPhi(Double32_t phi). set the phi coordinate value keeping rho and z constant. void SetXYZ(ROOT::Math::Cylindrical3D<Double32_t>::Scalar xx, ROOT::Math::Cylindrical3D<Double32_t>::Scalar yy, ROOT::Math::Cylindrical3D<Double32_t>::Scalar zz). set all values using cartesian coordin",MatchSource.WIKI,root/html534/ROOT__Math__Cylindrical3D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__Cylindrical3D_Double32_t_.html
https://root.cern/root/html534/ROOT__Math__Cylindrical3D_double_.html:4389,Security,access,accessors,4389,"gnment operator. void SetCoordinates(const ROOT::Math::Cylindrical3D<double>::Scalar* src). Set internal data based on an array of 3 Scalar numbers ( rho, z , phi). { fRho=src[0]; fZ=src[1]; fPhi=src[2]; Restrict(); }. void GetCoordinates(ROOT::Math::Cylindrical3D<double>::Scalar* dest) const. get internal data into an array of 3 Scalar numbers ( rho, z , phi). { dest[0] = fRho; dest[1] = fZ; dest[2] = fPhi; }. void SetCoordinates(ROOT::Math::Cylindrical3D<double>::Scalar rho, ROOT::Math::Cylindrical3D<double>::Scalar zz, ROOT::Math::Cylindrical3D<double>::Scalar phi). Set internal data based on 3 Scalar numbers ( rho, z , phi). { fRho=rho; fZ=zz; fPhi=phi; Restrict(); }. void GetCoordinates(ROOT::Math::Cylindrical3D<double>::Scalar& rho, ROOT::Math::Cylindrical3D<double>::Scalar& zz, ROOT::Math::Cylindrical3D<double>::Scalar& phi) const. get internal data into 3 Scalar numbers ( rho, z , phi). {rho=fRho; zz=fZ; phi=fPhi;}. Scalar pi(); { return M_PI; }. void Restrict(). Scalar Rho() const; accessors. { return fRho; }. Scalar Z() const; { return fZ; }. Scalar Phi() const; { return fPhi; }. Scalar X() const; { return fRho*std::cos(fPhi); }. Scalar Y() const; { return fRho*std::sin(fPhi); }. Scalar Mag2() const; { return fRho*fRho + fZ*fZ; }. Scalar R() const; { return std::sqrt( Mag2()); }. Scalar Perp2() const; { return fRho*fRho; }. Scalar Theta() const; { return (fRho==0 && fZ==0 ) ? 0 : atan2(fRho,fZ); }. Scalar Eta() const; pseudorapidity - use same implementation as in Cartesian3D. void SetRho(double rho); setters (only for data members). set the rho coordinate value keeping z and phi constant. void SetZ(double zz). set the z coordinate value keeping rho and phi constant. void SetPhi(double phi). set the phi coordinate value keeping rho and z constant. void SetXYZ(ROOT::Math::Cylindrical3D<double>::Scalar xx, ROOT::Math::Cylindrical3D<double>::Scalar yy, ROOT::Math::Cylindrical3D<double>::Scalar zz). set all values using cartesian coordinates. void Scale(double ",MatchSource.WIKI,root/html534/ROOT__Math__Cylindrical3D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__Cylindrical3D_double_.html
https://root.cern/root/html534/ROOT__Math__CylindricalEta3D_Double32_t_.html:4923,Security,access,accessors,4923,"ment operator. void SetCoordinates(const ROOT::Math::CylindricalEta3D<Double32_t>::Scalar* src). Set internal data based on an array of 3 Scalar numbers. { fRho=src[0]; fEta=src[1]; fPhi=src[2]; Restrict(); }. void GetCoordinates(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar* dest) const. get internal data into an array of 3 Scalar numbers. { dest[0] = fRho; dest[1] = fEta; dest[2] = fPhi; }. void SetCoordinates(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar rho, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar eta, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar phi). Set internal data based on 3 Scalar numbers. { fRho=rho; fEta=eta; fPhi=phi; Restrict(); }. void GetCoordinates(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar& rho, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar& eta, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar& phi) const. get internal data into 3 Scalar numbers. {rho=fRho; eta=fEta; phi=fPhi;}. Scalar pi(); { return M_PI; }. void Restrict(). T Rho() const; accessors. { return fRho; }. T Eta() const; { return fEta; }. T Phi() const; { return fPhi; }. T X() const; { return fRho*std::cos(fPhi); }. T Y() const; { return fRho*std::sin(fPhi); }. T Z() const. T R() const. T Mag2() const; { return R()*R(); }. T Perp2() const; { return fRho*fRho; }. T Theta() const. void SetRho(Double32_t rho); setters (only for data members). set the rho coordinate value keeping eta and phi constant. void SetEta(Double32_t eta). set the eta coordinate value keeping rho and phi constant. void SetPhi(Double32_t phi). set the phi coordinate value keeping rho and eta constant. void SetXYZ(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar xx, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar yy, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar zz). set all values using cartesian coordinates. void Scale(Double32_t a). scale by a scalar quantity a --; for cylindrical eta coords, as long as a >= 0, only rho changes!. Negate(). bool operator==(const ROOT::Math::Cylindri",MatchSource.WIKI,root/html534/ROOT__Math__CylindricalEta3D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__CylindricalEta3D_Double32_t_.html
https://root.cern/root/html534/ROOT__Math__CylindricalEta3D_Double32_t_.html:6068,Testability,test,test,6068,"onst; { return fRho*std::cos(fPhi); }. T Y() const; { return fRho*std::sin(fPhi); }. T Z() const. T R() const. T Mag2() const; { return R()*R(); }. T Perp2() const; { return fRho*fRho; }. T Theta() const. void SetRho(Double32_t rho); setters (only for data members). set the rho coordinate value keeping eta and phi constant. void SetEta(Double32_t eta). set the eta coordinate value keeping rho and phi constant. void SetPhi(Double32_t phi). set the phi coordinate value keeping rho and eta constant. void SetXYZ(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar xx, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar yy, ROOT::Math::CylindricalEta3D<Double32_t>::Scalar zz). set all values using cartesian coordinates. void Scale(Double32_t a). scale by a scalar quantity a --; for cylindrical eta coords, as long as a >= 0, only rho changes!. Negate(). bool operator==(const ROOT::Math::CylindricalEta3D<Double32_t>& rhs) const. Exact component-by-component equality; Note: Peculiar representaions of the zero vector such as (0,1,0) will; not test as equal to one another. bool operator!=(const ROOT::Math::CylindricalEta3D<Double32_t>& rhs) const; {return !(operator==(rhs));}. T x() const; ============= Compatibility section ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X();}. T y() const; { return Y();}. T z() const; { return Z(); }. void SetX(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar xx); ============= Specializations for improved speed ==================; (none); ====== Set member functions for coordinates in other systems =======. void SetY(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar yy). void SetZ(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar zz). void SetR(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar r). void SetTheta(ROOT::Math::CylindricalEta3D<Double32_t>::Scalar theta).  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; T",MatchSource.WIKI,root/html534/ROOT__Math__CylindricalEta3D_Double32_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__CylindricalEta3D_Double32_t_.html
https://root.cern/root/html534/ROOT__Math__CylindricalEta3D_double_.html:4149,Security,access,accessors,4149,"ndricalEta3D<double>& v). assignment operator. void SetCoordinates(const ROOT::Math::CylindricalEta3D<double>::Scalar* src). Set internal data based on an array of 3 Scalar numbers. { fRho=src[0]; fEta=src[1]; fPhi=src[2]; Restrict(); }. void GetCoordinates(ROOT::Math::CylindricalEta3D<double>::Scalar* dest) const. get internal data into an array of 3 Scalar numbers. { dest[0] = fRho; dest[1] = fEta; dest[2] = fPhi; }. void SetCoordinates(ROOT::Math::CylindricalEta3D<double>::Scalar rho, ROOT::Math::CylindricalEta3D<double>::Scalar eta, ROOT::Math::CylindricalEta3D<double>::Scalar phi). Set internal data based on 3 Scalar numbers. { fRho=rho; fEta=eta; fPhi=phi; Restrict(); }. void GetCoordinates(ROOT::Math::CylindricalEta3D<double>::Scalar& rho, ROOT::Math::CylindricalEta3D<double>::Scalar& eta, ROOT::Math::CylindricalEta3D<double>::Scalar& phi) const. get internal data into 3 Scalar numbers. {rho=fRho; eta=fEta; phi=fPhi;}. Scalar pi(); { return M_PI; }. void Restrict(). T Rho() const; accessors. { return fRho; }. T Eta() const; { return fEta; }. T Phi() const; { return fPhi; }. T X() const; { return fRho*std::cos(fPhi); }. T Y() const; { return fRho*std::sin(fPhi); }. T Z() const. T R() const. T Mag2() const; { return R()*R(); }. T Perp2() const; { return fRho*fRho; }. T Theta() const. void SetRho(double rho); setters (only for data members). set the rho coordinate value keeping eta and phi constant. void SetEta(double eta). set the eta coordinate value keeping rho and phi constant. void SetPhi(double phi). set the phi coordinate value keeping rho and eta constant. void SetXYZ(ROOT::Math::CylindricalEta3D<double>::Scalar xx, ROOT::Math::CylindricalEta3D<double>::Scalar yy, ROOT::Math::CylindricalEta3D<double>::Scalar zz). set all values using cartesian coordinates. void Scale(double a). scale by a scalar quantity a --; for cylindrical eta coords, as long as a >= 0, only rho changes!. Negate(). bool operator==(const ROOT::Math::CylindricalEta3D<double>& rhs) const",MatchSource.WIKI,root/html534/ROOT__Math__CylindricalEta3D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__CylindricalEta3D_double_.html
https://root.cern/root/html534/ROOT__Math__CylindricalEta3D_double_.html:5262,Testability,test,test,5262,"const; { return fPhi; }. T X() const; { return fRho*std::cos(fPhi); }. T Y() const; { return fRho*std::sin(fPhi); }. T Z() const. T R() const. T Mag2() const; { return R()*R(); }. T Perp2() const; { return fRho*fRho; }. T Theta() const. void SetRho(double rho); setters (only for data members). set the rho coordinate value keeping eta and phi constant. void SetEta(double eta). set the eta coordinate value keeping rho and phi constant. void SetPhi(double phi). set the phi coordinate value keeping rho and eta constant. void SetXYZ(ROOT::Math::CylindricalEta3D<double>::Scalar xx, ROOT::Math::CylindricalEta3D<double>::Scalar yy, ROOT::Math::CylindricalEta3D<double>::Scalar zz). set all values using cartesian coordinates. void Scale(double a). scale by a scalar quantity a --; for cylindrical eta coords, as long as a >= 0, only rho changes!. Negate(). bool operator==(const ROOT::Math::CylindricalEta3D<double>& rhs) const. Exact component-by-component equality; Note: Peculiar representaions of the zero vector such as (0,1,0) will; not test as equal to one another. bool operator!=(const ROOT::Math::CylindricalEta3D<double>& rhs) const; {return !(operator==(rhs));}. T x() const; ============= Compatibility section ==================; The following make this coordinate system look enough like a CLHEP; vector that an assignment member template can work with either. { return X();}. T y() const; { return Y();}. T z() const; { return Z(); }. void SetX(ROOT::Math::CylindricalEta3D<double>::Scalar xx); ============= Specializations for improved speed ==================; (none); ====== Set member functions for coordinates in other systems =======. void SetY(ROOT::Math::CylindricalEta3D<double>::Scalar yy). void SetZ(ROOT::Math::CylindricalEta3D<double>::Scalar zz). void SetR(ROOT::Math::CylindricalEta3D<double>::Scalar r). void SetTheta(ROOT::Math::CylindricalEta3D<double>::Scalar theta).  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:58; This page has been automa",MatchSource.WIKI,root/html534/ROOT__Math__CylindricalEta3D_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__CylindricalEta3D_double_.html
https://root.cern/root/html534/ROOT__Math__Derivator.html:6045,Availability,error,error,6045,", double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IMultiGenFunction& f, const double* x, unsigned int icoord = 0, double h = 1E-8); Derivatives for multi-dimension functions. Evaluate the partial derivative of a multi-dim function; with respect coordinate x_icoord at the point x[]. double Eval(ROOT::Math::IParamFunction& f, double x, const double* p, unsigned int ipar = 0, double h = 1E-8). Evaluate the derivative with respect a parameter for one-dim parameteric function; at the point ( x,p[]) with respect the parameter p_ipar. double Eval(ROOT::Math::IParamMultiFunction& f, const double* x, const double* p, unsigned int ipar = 0, double h = 1E-8). Evaluate the derivative with respect a parameter for a multi-dim parameteric function; at the point ( x[],p[]) with respect the parameter p_ipar. int Status() const. return the error status of the last derivative calculation. double Result() const. return the result of the last derivative calculation. double Error() const. return the estimate of the absolute error of the last derivative calculation.  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__Derivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__Derivator.html
https://root.cern/root/html534/ROOT__Math__Derivator.html:6229,Availability,error,error,6229,", double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IMultiGenFunction& f, const double* x, unsigned int icoord = 0, double h = 1E-8); Derivatives for multi-dimension functions. Evaluate the partial derivative of a multi-dim function; with respect coordinate x_icoord at the point x[]. double Eval(ROOT::Math::IParamFunction& f, double x, const double* p, unsigned int ipar = 0, double h = 1E-8). Evaluate the derivative with respect a parameter for one-dim parameteric function; at the point ( x,p[]) with respect the parameter p_ipar. double Eval(ROOT::Math::IParamMultiFunction& f, const double* x, const double* p, unsigned int ipar = 0, double h = 1E-8). Evaluate the derivative with respect a parameter for a multi-dim parameteric function; at the point ( x[],p[]) with respect the parameter p_ipar. int Status() const. return the error status of the last derivative calculation. double Result() const. return the result of the last derivative calculation. double Error() const. return the estimate of the absolute error of the last derivative calculation.  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__Derivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__Derivator.html
https://root.cern/root/html534/ROOT__Math__Derivator.html:3281,Energy Efficiency,adapt,adaptive,3281,"n afterwards with Derivator::SetFunction. explicit Derivator(const IGenFunction &f). Construct using a ROOT::Math::IGenFunction interface. explicit Derivator(const ROOT::Math::Derivator::GSLFuncPointer& f, void* p = 0). Construct using a GSL function pointer type; @param f : free function pointer of the GSL required type; @param p : pointer to the object carrying the function state; (for example the function object itself). virtual ~Derivator(); destructor. Derivator(const Derivator &); disable copying. void SetFunction(const ROOT::Math::IGenFunction& f). Template methods for generic functions; Set the function f for evaluating the derivative.; The function type must implement the assigment operator,; <em> double operator() ( double x ) </em>. SetFunction(const ROOT::Math::Derivator::GSLFuncPointer& f, void* p = 0). double Eval(double x, double h = 1E-8) const. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); @name --- Static methods ---; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the numeric",MatchSource.WIKI,root/html534/ROOT__Math__Derivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__Derivator.html
https://root.cern/root/html534/ROOT__Math__Derivator.html:3448,Energy Efficiency,adapt,adaptive,3448,"h::Derivator::GSLFuncPointer& f, void* p = 0). Construct using a GSL function pointer type; @param f : free function pointer of the GSL required type; @param p : pointer to the object carrying the function state; (for example the function object itself). virtual ~Derivator(); destructor. Derivator(const Derivator &); disable copying. void SetFunction(const ROOT::Math::IGenFunction& f). Template methods for generic functions; Set the function f for evaluating the derivative.; The function type must implement the assigment operator,; <em> double operator() ( double x ) </em>. SetFunction(const ROOT::Math::Derivator::GSLFuncPointer& f, void* p = 0). double Eval(double x, double h = 1E-8) const. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); @name --- Static methods ---; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. doub",MatchSource.WIKI,root/html534/ROOT__Math__Derivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__Derivator.html
https://root.cern/root/html534/ROOT__Math__Derivator.html:3616,Energy Efficiency,adapt,adaptive,3616,"r to the object carrying the function state; (for example the function object itself). virtual ~Derivator(); destructor. Derivator(const Derivator &); disable copying. void SetFunction(const ROOT::Math::IGenFunction& f). Template methods for generic functions; Set the function f for evaluating the derivative.; The function type must implement the assigment operator,; <em> double operator() ( double x ) </em>. SetFunction(const ROOT::Math::Derivator::GSLFuncPointer& f, void* p = 0). double Eval(double x, double h = 1E-8) const. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); @name --- Static methods ---; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive central; ",MatchSource.WIKI,root/html534/ROOT__Math__Derivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__Derivator.html
https://root.cern/root/html534/ROOT__Math__Derivator.html:3859,Energy Efficiency,adapt,adaptive,3859,"neric functions; Set the function f for evaluating the derivative.; The function type must implement the assigment operator,; <em> double operator() ( double x ) </em>. SetFunction(const ROOT::Math::Derivator::GSLFuncPointer& f, void* p = 0). double Eval(double x, double h = 1E-8) const. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); @name --- Static methods ---; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive forward; difference algorithm with a st",MatchSource.WIKI,root/html534/ROOT__Math__Derivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__Derivator.html
https://root.cern/root/html534/ROOT__Math__Derivator.html:4387,Energy Efficiency,adapt,adaptive,4387,"-8) const. Computes the numerical derivative at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); @name --- Static methods ---; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IMultiGenFunction& f, const double* x, unsigned int icoord = 0, double h = 1E-8); Derivatives for multi-dimension functi",MatchSource.WIKI,root/html534/ROOT__Math__Derivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__Derivator.html
https://root.cern/root/html534/ROOT__Math__Derivator.html:4599,Energy Efficiency,adapt,adaptive,4599,"ve at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); @name --- Static methods ---; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IMultiGenFunction& f, const double* x, unsigned int icoord = 0, double h = 1E-8); Derivatives for multi-dimension functions. Evaluate the partial derivative of a multi-dim function; with respect coordinate x_icoord at the point x[]. double Eval(ROOT::Math::IParamFunction& f, double x, const double* p, unsigned int ipar = 0, doubl",MatchSource.WIKI,root/html534/ROOT__Math__Derivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__Derivator.html
https://root.cern/root/html534/ROOT__Math__Derivator.html:4812,Energy Efficiency,adapt,adaptive,4812,"omputes the numerical derivative at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); @name --- Static methods ---; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IMultiGenFunction& f, const double* x, unsigned int icoord = 0, double h = 1E-8); Derivatives for multi-dimension functions. Evaluate the partial derivative of a multi-dim function; with respect coordinate x_icoord at the point x[]. double Eval(ROOT::Math::IParamFunction& f, double x, const double* p, unsigned int ipar = 0, double h = 1E-8). Evaluate the derivative with respect a parameter for one-dim parameteric function; at the point ( x,p[]) with respect the parameter p_ipar. double Eval(ROOT::Math::IParamMultiFunction& f, const double",MatchSource.WIKI,root/html534/ROOT__Math__Derivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__Derivator.html
https://root.cern/root/html534/ROOT__Math__Derivator.html:5100,Energy Efficiency,adapt,adaptive,5100,"; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IMultiGenFunction& f, const double* x, unsigned int icoord = 0, double h = 1E-8); Derivatives for multi-dimension functions. Evaluate the partial derivative of a multi-dim function; with respect coordinate x_icoord at the point x[]. double Eval(ROOT::Math::IParamFunction& f, double x, const double* p, unsigned int ipar = 0, double h = 1E-8). Evaluate the derivative with respect a parameter for one-dim parameteric function; at the point ( x,p[]) with respect the parameter p_ipar. double Eval(ROOT::Math::IParamMultiFunction& f, const double* x, const double* p, unsigned int ipar = 0, double h = 1E-8). Evaluate the derivative with respect a parameter for a multi-dim parameteric function; at the point ( x[],p[]) with respect the parameter p_ipar. int Status() const. return the error status of the last derivative calculation.",MatchSource.WIKI,root/html534/ROOT__Math__Derivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__Derivator.html
https://root.cern/root/html534/ROOT__Math__Derivator.html:2403,Integrability,interface,interface,2403,"EvalBackward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); doubleEvalCentral(double x, double h = 1E-8) const; static doubleEvalCentral(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); doubleEvalForward(double x, double h = 1E-8) const; static doubleEvalForward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); doubleResult() const; voidSetFunction(const ROOT::Math::IGenFunction& f); voidSetFunction(const ROOT::Math::Derivator::GSLFuncPointer& f, void* p = 0); intStatus() const. private:. ROOT::Math::DerivatorDerivator(const ROOT::Math::Derivator&); ROOT::Math::Derivator&operator=(const ROOT::Math::Derivator&). Data Members; private:. ROOT::Math::GSLDerivator*fDerivator. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Derivator(). Empty Construct for a Derivator class; Need to set the function afterwards with Derivator::SetFunction. explicit Derivator(const IGenFunction &f). Construct using a ROOT::Math::IGenFunction interface. explicit Derivator(const ROOT::Math::Derivator::GSLFuncPointer& f, void* p = 0). Construct using a GSL function pointer type; @param f : free function pointer of the GSL required type; @param p : pointer to the object carrying the function state; (for example the function object itself). virtual ~Derivator(); destructor. Derivator(const Derivator &); disable copying. void SetFunction(const ROOT::Math::IGenFunction& f). Template methods for generic functions; Set the function f for evaluating the derivative.; The function type must implement the assigment operator,; <em> double operator() ( double x ) </em>. SetFunction(const ROOT::Math::Derivator::GSLFuncPointer& f, void* p = 0). double Eval(double x, double h = 1E-8) const. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(double x, double h = 1E-8) c",MatchSource.WIKI,root/html534/ROOT__Math__Derivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__Derivator.html
https://root.cern/root/html534/ROOT__Math__Derivator.html:3281,Modifiability,adapt,adaptive,3281,"n afterwards with Derivator::SetFunction. explicit Derivator(const IGenFunction &f). Construct using a ROOT::Math::IGenFunction interface. explicit Derivator(const ROOT::Math::Derivator::GSLFuncPointer& f, void* p = 0). Construct using a GSL function pointer type; @param f : free function pointer of the GSL required type; @param p : pointer to the object carrying the function state; (for example the function object itself). virtual ~Derivator(); destructor. Derivator(const Derivator &); disable copying. void SetFunction(const ROOT::Math::IGenFunction& f). Template methods for generic functions; Set the function f for evaluating the derivative.; The function type must implement the assigment operator,; <em> double operator() ( double x ) </em>. SetFunction(const ROOT::Math::Derivator::GSLFuncPointer& f, void* p = 0). double Eval(double x, double h = 1E-8) const. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); @name --- Static methods ---; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the numeric",MatchSource.WIKI,root/html534/ROOT__Math__Derivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__Derivator.html
https://root.cern/root/html534/ROOT__Math__Derivator.html:3448,Modifiability,adapt,adaptive,3448,"h::Derivator::GSLFuncPointer& f, void* p = 0). Construct using a GSL function pointer type; @param f : free function pointer of the GSL required type; @param p : pointer to the object carrying the function state; (for example the function object itself). virtual ~Derivator(); destructor. Derivator(const Derivator &); disable copying. void SetFunction(const ROOT::Math::IGenFunction& f). Template methods for generic functions; Set the function f for evaluating the derivative.; The function type must implement the assigment operator,; <em> double operator() ( double x ) </em>. SetFunction(const ROOT::Math::Derivator::GSLFuncPointer& f, void* p = 0). double Eval(double x, double h = 1E-8) const. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); @name --- Static methods ---; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. doub",MatchSource.WIKI,root/html534/ROOT__Math__Derivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__Derivator.html
https://root.cern/root/html534/ROOT__Math__Derivator.html:3616,Modifiability,adapt,adaptive,3616,"r to the object carrying the function state; (for example the function object itself). virtual ~Derivator(); destructor. Derivator(const Derivator &); disable copying. void SetFunction(const ROOT::Math::IGenFunction& f). Template methods for generic functions; Set the function f for evaluating the derivative.; The function type must implement the assigment operator,; <em> double operator() ( double x ) </em>. SetFunction(const ROOT::Math::Derivator::GSLFuncPointer& f, void* p = 0). double Eval(double x, double h = 1E-8) const. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); @name --- Static methods ---; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive central; ",MatchSource.WIKI,root/html534/ROOT__Math__Derivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__Derivator.html
https://root.cern/root/html534/ROOT__Math__Derivator.html:3859,Modifiability,adapt,adaptive,3859,"neric functions; Set the function f for evaluating the derivative.; The function type must implement the assigment operator,; <em> double operator() ( double x ) </em>. SetFunction(const ROOT::Math::Derivator::GSLFuncPointer& f, void* p = 0). double Eval(double x, double h = 1E-8) const. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); @name --- Static methods ---; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive forward; difference algorithm with a st",MatchSource.WIKI,root/html534/ROOT__Math__Derivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__Derivator.html
https://root.cern/root/html534/ROOT__Math__Derivator.html:4387,Modifiability,adapt,adaptive,4387,"-8) const. Computes the numerical derivative at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); @name --- Static methods ---; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IMultiGenFunction& f, const double* x, unsigned int icoord = 0, double h = 1E-8); Derivatives for multi-dimension functi",MatchSource.WIKI,root/html534/ROOT__Math__Derivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__Derivator.html
https://root.cern/root/html534/ROOT__Math__Derivator.html:4599,Modifiability,adapt,adaptive,4599,"ve at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(double x, double h = 1E-8) const. Computes the numerical derivative at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); @name --- Static methods ---; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IMultiGenFunction& f, const double* x, unsigned int icoord = 0, double h = 1E-8); Derivatives for multi-dimension functions. Evaluate the partial derivative of a multi-dim function; with respect coordinate x_icoord at the point x[]. double Eval(ROOT::Math::IParamFunction& f, double x, const double* p, unsigned int ipar = 0, doubl",MatchSource.WIKI,root/html534/ROOT__Math__Derivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__Derivator.html
https://root.cern/root/html534/ROOT__Math__Derivator.html:4812,Modifiability,adapt,adaptive,4812,"omputes the numerical derivative at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8); @name --- Static methods ---; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IMultiGenFunction& f, const double* x, unsigned int icoord = 0, double h = 1E-8); Derivatives for multi-dimension functions. Evaluate the partial derivative of a multi-dim function; with respect coordinate x_icoord at the point x[]. double Eval(ROOT::Math::IParamFunction& f, double x, const double* p, unsigned int ipar = 0, double h = 1E-8). Evaluate the derivative with respect a parameter for one-dim parameteric function; at the point ( x,p[]) with respect the parameter p_ipar. double Eval(ROOT::Math::IParamMultiFunction& f, const double",MatchSource.WIKI,root/html534/ROOT__Math__Derivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__Derivator.html
https://root.cern/root/html534/ROOT__Math__Derivator.html:5100,Modifiability,adapt,adaptive,5100,"; This methods don't require to use a Derivator object, and are designed to be used in; fast calculation. Error and status code cannot be retrieved in this case. Computes the numerical derivative of a function f at a point x.; It uses Derivator::EvalCentral to compute the derivative using an; adaptive central difference algorithm with a step size h. double EvalCentral(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive central; difference algorithm with a step size h. double EvalForward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive forward; difference algorithm with a step size h.; The function is evaluated only at points greater than x and at x itself. double EvalBackward(const ROOT::Math::IGenFunction& f, double x, double h = 1E-8). Computes the numerical derivative of a function f at a point x using an adaptive backward; difference algorithm with a step size h.; The function is evaluated only at points less than x and at x itself. double Eval(const ROOT::Math::IMultiGenFunction& f, const double* x, unsigned int icoord = 0, double h = 1E-8); Derivatives for multi-dimension functions. Evaluate the partial derivative of a multi-dim function; with respect coordinate x_icoord at the point x[]. double Eval(ROOT::Math::IParamFunction& f, double x, const double* p, unsigned int ipar = 0, double h = 1E-8). Evaluate the derivative with respect a parameter for one-dim parameteric function; at the point ( x,p[]) with respect the parameter p_ipar. double Eval(ROOT::Math::IParamMultiFunction& f, const double* x, const double* p, unsigned int ipar = 0, double h = 1E-8). Evaluate the derivative with respect a parameter for a multi-dim parameteric function; at the point ( x[],p[]) with respect the parameter p_ipar. int Status() const. return the error status of the last derivative calculation.",MatchSource.WIKI,root/html534/ROOT__Math__Derivator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__Derivator.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_Double32_t__-p1DefaultCoordinateSystemTag_.html:8461,Security,access,access,8461,"T::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const. Data Members; private:. ROOT::Math::Cartesian2D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXY(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). DisplacementVector2D & operator=(const ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 2D vector type, for example, Hep2Vector; Precondition: v must implement methods x() and y(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector2D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). Set internal data based on 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. void GetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b) const. get internal data into 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. { fCoordinates.GetCoordinates(a, b); }. bool operator==(const ROOT::Math::DisplacementVector2D<RO",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_Double32_t__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_Double32_t__-p1DefaultCoordinateSystemTag_.html:9788,Security,access,access,9788,"h::DefaultCoordinateSystemTag>::Scalar b). Set internal data based on 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. void GetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b) const. get internal data into 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. { fCoordinates.GetCoordinates(a, b); }. bool operator==(const ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Mag2() const; ----- Other fundamental properties -----. Magnitute squared ( r^2 in spherical coordinate). { return fCoordinates.Mag2();}. DisplacementVector2D Unit() const. return unit vector parallel to this. DisplacementVector2D<CoordSystem, Tag>& SetX(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a); ------ Setting individual elements present in coordinate system ------. Change X - Cartesian2D coordinates only. Displa",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_Double32_t__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_double__-p1DefaultCoordinateSystemTag_.html:8340,Security,access,access,8340,"g>::Scalarx() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const. Data Members; private:. ROOT::Math::Cartesian2D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXY(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). DisplacementVector2D & operator=(const ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 2D vector type, for example, Hep2Vector; Precondition: v must implement methods x() and y(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector2D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). Set internal data based on 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. void GetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b) const. get internal data into 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. { fCoordinates.GetCoordinates(a, b); }. bool operator==(const ROOT::Math::DisplacementVector2D<ROOT::Math::Cartes",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_double__-p1DefaultCoordinateSystemTag_.html:9643,Security,access,access,9643,"ouble>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). Set internal data based on 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. void GetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b) const. get internal data into 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. { fCoordinates.GetCoordinates(a, b); }. bool operator==(const ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Mag2() const; ----- Other fundamental properties -----. Magnitute squared ( r^2 in spherical coordinate). { return fCoordinates.Mag2();}. DisplacementVector2D Unit() const. return unit vector parallel to this. DisplacementVector2D<CoordSystem, Tag>& SetX(ROOT::Math::DisplacementVector2D<ROOT::Math::Cartesian2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a); ------ Setting individual elements present in coordinate system ------. Change X - Cartesian2D coordinates only. Displaceme",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector2D_-p1Cartesian2D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector2D_-p1Polar2D_Double32_t__-p1DefaultCoordinateSystemTag_.html:8213,Security,access,access,8213,"g>::Scalarx() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const. Data Members; private:. ROOT::Math::Polar2D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXY(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). DisplacementVector2D & operator=(const ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 2D vector type, for example, Hep2Vector; Precondition: v must implement methods x() and y(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector2D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). Set internal data based on 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. void GetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b) const. get internal data into 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. { fCoordinates.GetCoordinates(a, b); }. bool operator==(const ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector2D_-p1Polar2D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector2D_-p1Polar2D_Double32_t__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector2D_-p1Polar2D_Double32_t__-p1DefaultCoordinateSystemTag_.html:9516,Security,access,access,9516,"e32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). Set internal data based on 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. void GetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b) const. get internal data into 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. { fCoordinates.GetCoordinates(a, b); }. bool operator==(const ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Mag2() const; ----- Other fundamental properties -----. Magnitute squared ( r^2 in spherical coordinate). { return fCoordinates.Mag2();}. DisplacementVector2D Unit() const. return unit vector parallel to this. DisplacementVector2D<CoordSystem, Tag>& SetX(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a); ------ Setting individual elements present in coordinate system ------. Change X - Cartesian2D coordinates only. Displaceme",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector2D_-p1Polar2D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector2D_-p1Polar2D_Double32_t__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector2D_-p1Polar2D_double__-p1DefaultCoordinateSystemTag_.html:8098,Security,access,access,8098,"efaultCoordinateSystemTag>::Scalarx() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarY() const; ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalary() const. Data Members; private:. ROOT::Math::Polar2D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXY(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). DisplacementVector2D & operator=(const ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 2D vector type, for example, Hep2Vector; Precondition: v must implement methods x() and y(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector2D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). Set internal data based on 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. void GetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b) const. get internal data into 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. { fCoordinates.GetCoordinates(a, b); }. bool operator==(const ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector2D_-p1Polar2D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector2D_-p1Polar2D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector2D_-p1Polar2D_double__-p1DefaultCoordinateSystemTag_.html:9377,Security,access,access,9377,":Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b). Set internal data based on 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. void GetCoordinates(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b) const. get internal data into 2 Scalar numbers.; These are for example (x,y) for a cartesian vector or (r,phi) for a polar vector. { fCoordinates.GetCoordinates(a, b); }. bool operator==(const ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Mag2() const; ----- Other fundamental properties -----. Magnitute squared ( r^2 in spherical coordinate). { return fCoordinates.Mag2();}. DisplacementVector2D Unit() const. return unit vector parallel to this. DisplacementVector2D<CoordSystem, Tag>& SetX(ROOT::Math::DisplacementVector2D<ROOT::Math::Polar2D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a); ------ Setting individual elements present in coordinate system ------. Change X - Cartesian2D coordinates only. DisplacementVe",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector2D_-p1Polar2D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector2D_-p1Polar2D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1DefaultCoordinateSystemTag_.html:11594,Security,access,access,11594,"OT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cartesian3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT:",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1DefaultCoordinateSystemTag_.html:13609,Security,access,access,13609,"temTag>::Scalar& a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1GlobalCoordinateSystemTag_.html:11386,Security,access,access,11386,"t; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cartesian3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Mat",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1GlobalCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1GlobalCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1GlobalCoordinateSystemTag_.html:13391,Security,access,access,13391,"teSystemTag>::Scalar& a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar& b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1GlobalCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1GlobalCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1LocalCoordinateSystemTag_.html:11302,Security,access,access,11302," const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cartesian3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::L",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1LocalCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1LocalCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1LocalCoordinateSystemTag_.html:13297,Security,access,access,13297,"rdinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar& b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1LocalCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_Double32_t__-p1LocalCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html:24487,Performance,perform,perform,24487,"r3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar ang). Change Phi - Polar3D or CylindricalEta3D coordinates. { fCoordinates.SetPhi(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html:24698,Performance,perform,perform,24698,"Vector3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a scalar quantity. DisplacementVector3D & operator/=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). divide this vector by a scalar",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html:24992,Performance,perform,perform,24992,"splacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a scalar quantity. DisplacementVector3D & operator/=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). divide this vector by a scalar quantity. return operator*( Scalar(-1) ). DisplacementVector3D operator/(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a) const. Division of a vector with a real number. Scalar x() const; Methods providing limited backward name compatibil",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html:25270,Performance,perform,perform,25270,"---- Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a scalar quantity. DisplacementVector3D & operator/=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). divide this vector by a scalar quantity. return operator*( Scalar(-1) ). DisplacementVector3D operator/(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a) const. Division of a vector with a real number. Scalar x() const; Methods providing limited backward name compatibility with CLHEP. { return fCoordinates.X(); }. Scalar y() const; { return fCoordinates.Y(); }. Scalar z() const; { return fCoordinates.Z(); }. Scalar theta() const; { return fCoordinates.Theta(); }. Scalar phi() const; { return fCoordinates.Phi(); }. Scalar eta() con",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html:24400,Safety,avoid,avoid,24400,"th::DefaultCoordinateSystemTag>::Scalar ang). Change Theta - Polar3D coordinates only. { fCoordinates.SetTheta(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetPhi(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar ang). Change Phi - Polar3D or CylindricalEta3D coordinates. { fCoordinates.SetPhi(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html:18885,Security,access,access,18885,"isplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cartesian3D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=( const ForeignVector & v). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordi",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html:20860,Security,access,access,20860,"DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_Double32_t__-p1DefaultCoordinateSystemTag_.html:11768,Security,access,access,11768,"splacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cylindrical3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double3",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_Double32_t__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_Double32_t__-p1DefaultCoordinateSystemTag_.html:13803,Security,access,access,13803,"calar& a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_Double32_t__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html:20461,Performance,perform,perform,20461,"Scalar ang). Change Phi - Polar3D or CylindricalEta3D coordinates. { fCoordinates.SetPhi(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v) const; ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a scalar quantity. DisplacementVector3D & operator/=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). divide this vec",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html:20778,Performance,perform,perform,20778,"es only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v) const; ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a scalar quantity. DisplacementVector3D & operator/=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). divide this vector by a scalar quantity. return operator*( Scalar(-1) ). DisplacementVector3D operator/(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a) const. Division of a vector with a real number. Scalar x() const; Methods providing limited backward name comp",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html:21056,Performance,perform,perform,21056,"ly. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v) const; ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a scalar quantity. DisplacementVector3D & operator/=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). divide this vector by a scalar quantity. return operator*( Scalar(-1) ). DisplacementVector3D operator/(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a) const. Division of a vector with a real number. Scalar x() const; Methods providing limited backward name compatibility with CLHEP. { return fCoordinates.X(); }. Scalar y() const; { return fCoordinates.Y(); }. Scalar z() const; { return fCoordinates.Z(); }. Scalar theta() const; { return fCoordinates.Theta(); }. Scalar phi() const; { return fCoordinates.Phi(); }. Scalar eta",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html:20374,Safety,avoid,avoid,20374,"). Change Theta - Polar3D coordinates only. { fCoordinates.SetTheta(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetPhi(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar ang). Change Phi - Polar3D or CylindricalEta3D coordinates. { fCoordinates.SetPhi(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& v) const; ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::Defau",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html:14750,Security,access,access,14750,"ector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Cylindrical3D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=( const ForeignVector & v). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::Def",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html:16745,Security,access,access,16745,"rdinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b, ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindrical3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cylindrical3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1DefaultCoordinateSystemTag_.html:12029,Security,access,access,12029,"<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::CylindricalEta3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Cylindric",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1DefaultCoordinateSystemTag_.html:14094,Security,access,access,14094,":Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1GlobalCoordinateSystemTag_.html:11816,Security,access,access,11816,"tor3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::CylindricalEta3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEt",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1GlobalCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1GlobalCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1GlobalCoordinateSystemTag_.html:13871,Security,access,access,13871,"ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar& b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::GlobalCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1GlobalCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1GlobalCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1LocalCoordinateSystemTag_.html:11732,Security,access,access,11732,"ntVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::CylindricalEta3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1LocalCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1LocalCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1LocalCoordinateSystemTag_.html:13777,Security,access,access,13777,"& a, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar& b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<Double32_t>,ROOT::Math::LocalCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1LocalCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_Double32_t__-p1LocalCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html:21252,Performance,perform,perform,21252,":CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar ang). Change Phi - Polar3D or CylindricalEta3D coordinates. { fCoordinates.SetPhi(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html:21463,Performance,perform,perform,21463,"oordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a scalar quantity. DisplacementVector3D & operator/=(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). divide this vector b",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html:21757,Performance,perform,perform,21757,"ementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a scalar quantity. DisplacementVector3D & operator/=(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). divide this vector by a scalar quantity. return operator*( Scalar(-1) ). DisplacementVector3D operator/(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a) const. Division of a vector with a real number. Scalar x() const; Methods providing limited backward ",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html:22035,Performance,perform,perform,22035,"---- Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a scalar quantity. DisplacementVector3D & operator/=(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). divide this vector by a scalar quantity. return operator*( Scalar(-1) ). DisplacementVector3D operator/(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a) const. Division of a vector with a real number. Scalar x() const; Methods providing limited backward name compatibility with CLHEP. { return fCoordinates.X(); }. Scalar y() const; { return fCoordinates.Y(); }. Scalar z() const; { return fCoordinates.Z(); }. Scalar theta() const; { return fCoordinates.Theta(); }. Scalar phi() const; { return fCoordinates.Phi(); }. S",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html:21165,Safety,avoid,avoid,21165,"dinateSystemTag>::Scalar ang). Change Theta - Polar3D coordinates only. { fCoordinates.SetTheta(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetPhi(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar ang). Change Phi - Polar3D or CylindricalEta3D coordinates. { fCoordinates.SetPhi(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html:15560,Security,access,access,15560,"::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::CylindricalEta3D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=( const ForeignVector & v). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html:17585,Security,access,access,17585,"g>::Scalar& a, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b, ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::DisplacementVector3D<ROOT::Math::CylindricalEta3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1CylindricalEta3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Polar3D_Double32_t__-p1DefaultCoordinateSystemTag_.html:11246,Security,access,access,11246,"ag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Polar3D<Double32_t>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& ). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordi",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector3D_-p1Polar3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Polar3D_Double32_t__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Polar3D_Double32_t__-p1DefaultCoordinateSystemTag_.html:13221,Security,access,access,13221,"DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<Double32_t>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector3D_-p1Polar3D_Double32_t__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Polar3D_Double32_t__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html:19923,Performance,perform,perform,19923,"acementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar ang). Change Phi - Polar3D or CylindricalEta3D coordinates. { fCoordinates.SetPhi(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a sca",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html:20134,Performance,perform,perform,20134,"lacementVector3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a scalar quantity. DisplacementVector3D & operator/=(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). divide this vector by a scalar quantit",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html:20428,Performance,perform,perform,20428,"::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a scalar quantity. DisplacementVector3D & operator/=(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). divide this vector by a scalar quantity. return operator*( Scalar(-1) ). DisplacementVector3D operator/(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a) const. Division of a vector with a real number. Scalar x() const; Methods providing limited backward name compatibility with CLH",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html:20706,Performance,perform,perform,20706,"---- Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a scalar quantity. DisplacementVector3D & operator/=(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). divide this vector by a scalar quantity. return operator*( Scalar(-1) ). DisplacementVector3D operator/(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a) const. Division of a vector with a real number. Scalar x() const; Methods providing limited backward name compatibility with CLHEP. { return fCoordinates.X(); }. Scalar y() const; { return fCoordinates.Y(); }. Scalar z() const; { return fCoordinates.Z(); }. Scalar theta() const; { return fCoordinates.Theta(); }. Scalar phi() const; { return fCoordinates.Phi(); }. Scalar eta() const; { return",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html:19836,Safety,avoid,avoid,19836,"le>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar ang). Change Theta - Polar3D coordinates only. { fCoordinates.SetTheta(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetPhi(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar ang). Change Phi - Polar3D or CylindricalEta3D coordinates. { fCoordinates.SetPhi(ang); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetRho(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar rr). Change Rho - CylindricalEta3D coordinates only. { fCoordinates.SetRho(rr); return *this;}. DisplacementVector3D<CoordSystem, Tag>& SetEta(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html:14393,Security,access,access,14393,"y() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::ScalarZ() const; ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalarz() const. Data Members; private:. ROOT::Math::Polar3D<double>fCoordinatesinternal coordinate system. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SetXYZ(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). DisplacementVector3D & operator=( const ForeignVector & v). Assignment from a foreign 3D vector type, for example, Hep3Vector; Precondition: v must implement methods x(), y() and z(). CoordSystem Coordinates() const; ------ Set, Get, and access coordinate data ------. Retrieve a copy of the coordinates object. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(const ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* src). Set internal data based on a C-style array of 3 Scalar numbers. { fCoordinates.SetCoordinates(src); return *this; }. DisplacementVector3D<CoordSystem, Tag>& SetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar b, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar c). Set internal data based on 3 Scalar numbers. { fCoordinates.SetCoordinates(a, b, c); return *this; }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scal",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html:16328,Security,access,access,16328,"double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& a, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& b, ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar& c) const. get internal data into 3 Scalar numbers. { fCoordinates.GetCoordinates(a, b, c); }. void GetCoordinates(ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar* dest) const. get internal data into a C-style array of 3 Scalar numbers. { fCoordinates.GetCoordinates(dest); }. bool operator==(const ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const; ------------------- Equality -----------------. Exact equality. bool operator!=(const ROOT::Math::DisplacementVector3D<ROOT::Math::Polar3D<double>,ROOT::Math::DefaultCoordinateSystemTag>& rhs) const. Scalar X() const; ------ Individual element access, in various coordinate systems ------. Cartesian X, converting if necessary from internal coordinate system. { return fCoordinates.X(); }. Scalar Y() const. Cartesian Y, converting if necessary from internal coordinate system. { return fCoordinates.Y(); }. Scalar Z() const. Cartesian Z, converting if necessary from internal coordinate system. { return fCoordinates.Z(); }. Scalar R() const. Polar R, converting if necessary from internal coordinate system. { return fCoordinates.R(); }. Scalar Theta() const. Polar theta, converting if necessary from internal coordinate system. { return fCoordinates.Theta(); }. Scalar Phi() const. Polar phi, converting if necessary from internal coordinate system. { return fCoordinates.Phi(); }. Scalar Eta() const. Polar eta, converting if necessary from internal coordinate system. { return fCoordinates.Eta(); }. Scalar Rho() const. Cylindrical transverse component rho. { return fCoordinates.Rho(); }. Scalar Mag2() const; ----- Other fundamental pro",MatchSource.WIKI,root/html534/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Polar3D_double__-p1DefaultCoordinateSystemTag_.html
https://root.cern/root/html534/ROOT__Math__DistSampler.html:571,Availability,avail,available,571,". ROOT::Math::DistSampler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::DistSampler. class ROOT::Math::DistSampler. Interface class for generic sampling of a distribution,; i.e. generating random numbers according to arbitrary distributions. @ingroup Random. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~DistSampler(); virtual boolGenerate(unsigned int nevt, ROOT::Fit::UnBinData& data); virtual boolGenerate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true); boolGenerate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true); virtual TRandom*GetRandom(); virtual boolInit(const char* = """"); virtual boolInit(const ROOT::Math::DistSamplerOptions& opt); unsigned intNDim() const; const ROOT::Math::IMultiGenFunction&ParentPdf() const; const double*Sample(); virtual boolSample(double* x); virtual doubleSample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolSampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidSetArea(double); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& func); virtual voidSetMode(double); virtual voidSetRandom(TRandom*); voidSetRange(const ROOT::Fit::DataRange& range); voidSetRange(const double* xmin, const double* xmax); voidSetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int). protected:. virtual voidDoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolIsInitialized(); const ROOT::Fit::DataRange&PdfRange() const. Data Members; private:. vector<double>fDatainternal arr",MatchSource.WIKI,root/html534/ROOT__Math__DistSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DistSampler.html
https://root.cern/root/html534/ROOT__Math__DistSampler.html:1263,Availability,error,error,1263," class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::DistSampler. class ROOT::Math::DistSampler. Interface class for generic sampling of a distribution,; i.e. generating random numbers according to arbitrary distributions. @ingroup Random. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~DistSampler(); virtual boolGenerate(unsigned int nevt, ROOT::Fit::UnBinData& data); virtual boolGenerate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true); boolGenerate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true); virtual TRandom*GetRandom(); virtual boolInit(const char* = """"); virtual boolInit(const ROOT::Math::DistSamplerOptions& opt); unsigned intNDim() const; const ROOT::Math::IMultiGenFunction&ParentPdf() const; const double*Sample(); virtual boolSample(double* x); virtual doubleSample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolSampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidSetArea(double); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& func); virtual voidSetMode(double); virtual voidSetRandom(TRandom*); voidSetRange(const ROOT::Fit::DataRange& range); voidSetRange(const double* xmin, const double* xmax); voidSetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int). protected:. virtual voidDoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolIsInitialized(); const ROOT::Fit::DataRange&PdfRange() const. Data Members; private:. vector<double>fDatainternal array used to cached the sample data ; const ROOT::Math::IMultiGenFunction*fFuncinternal function (ND); boolfOwnFuncflag to indicate if the function is owned; ROOT::Fit::DataRange*fRangedata range ",MatchSource.WIKI,root/html534/ROOT__Math__DistSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DistSampler.html
https://root.cern/root/html534/ROOT__Math__DistSampler.html:1358,Availability,error,errors,1358," class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::DistSampler. class ROOT::Math::DistSampler. Interface class for generic sampling of a distribution,; i.e. generating random numbers according to arbitrary distributions. @ingroup Random. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~DistSampler(); virtual boolGenerate(unsigned int nevt, ROOT::Fit::UnBinData& data); virtual boolGenerate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true); boolGenerate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true); virtual TRandom*GetRandom(); virtual boolInit(const char* = """"); virtual boolInit(const ROOT::Math::DistSamplerOptions& opt); unsigned intNDim() const; const ROOT::Math::IMultiGenFunction&ParentPdf() const; const double*Sample(); virtual boolSample(double* x); virtual doubleSample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolSampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidSetArea(double); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& func); virtual voidSetMode(double); virtual voidSetRandom(TRandom*); voidSetRange(const ROOT::Fit::DataRange& range); voidSetRange(const double* xmin, const double* xmax); voidSetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int). protected:. virtual voidDoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolIsInitialized(); const ROOT::Fit::DataRange&PdfRange() const. Data Members; private:. vector<double>fDatainternal array used to cached the sample data ; const ROOT::Math::IMultiGenFunction*fFuncinternal function (ND); boolfOwnFuncflag to indicate if the function is owned; ROOT::Fit::DataRange*fRangedata range ",MatchSource.WIKI,root/html534/ROOT__Math__DistSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DistSampler.html
https://root.cern/root/html534/ROOT__Math__DistSampler.html:4750,Availability,error,error,4750,"sampler; To be implemented by the derived classes who needs it; Returns zero by default. { return 0; }. void SetRange(double xmin, double xmax, int icoord = 0); set range in a given dimension. void SetRange(const double* xmin, const double* xmax); set range for all dimensions. void SetRange(const ROOT::Fit::DataRange& range); set range using DataRange class. void SetMode(double ); set the mode of the distribution (could be useful to some methods); implemented by derived classes if needed. {}. void SetArea(double ); set the normalization area of distribution; implemented by derived classes if needed. {}. const ROOT::Math::IMultiGenFunction & ParentPdf() const; get the parent distribution function (must be called after setting the function). double Sample1D(). sample one event in one dimension; better implementation could be provided by the derived classes. Sample(double* x). const double * Sample(). sample one event and rerturning array x with coordinates. bool SampleBin(double prob, double& value, double* error = 0). sample one bin given an estimated of the pdf in the bin; (this can be function value at the center or its integral in the bin; divided by the bin width); By default do not do random sample, just return the function values; Typically Poisson statistics will be used. bool SampleBins(unsigned int n, const double* prob, double* values, double* errors = 0). sample a set of bins given a vector of probabilities; Typically multinomial statistics will be used and the sum of the probabilities; will be equal to the total number of events to be generated; For sampling the bins indipendently, SampleBin should be used. bool Generate(unsigned int nevt, ROOT::Fit::UnBinData& data). generate a un-binned data sets (fill the given data set); if dataset has already data append to it. bool Generate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true). generate a bin data set .; A range must have been set before (otherwise inf is returned); and t",MatchSource.WIKI,root/html534/ROOT__Math__DistSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DistSampler.html
https://root.cern/root/html534/ROOT__Math__DistSampler.html:5104,Availability,error,errors,5104,"g DataRange class. void SetMode(double ); set the mode of the distribution (could be useful to some methods); implemented by derived classes if needed. {}. void SetArea(double ); set the normalization area of distribution; implemented by derived classes if needed. {}. const ROOT::Math::IMultiGenFunction & ParentPdf() const; get the parent distribution function (must be called after setting the function). double Sample1D(). sample one event in one dimension; better implementation could be provided by the derived classes. Sample(double* x). const double * Sample(). sample one event and rerturning array x with coordinates. bool SampleBin(double prob, double& value, double* error = 0). sample one bin given an estimated of the pdf in the bin; (this can be function value at the center or its integral in the bin; divided by the bin width); By default do not do random sample, just return the function values; Typically Poisson statistics will be used. bool SampleBins(unsigned int n, const double* prob, double* values, double* errors = 0). sample a set of bins given a vector of probabilities; Typically multinomial statistics will be used and the sum of the probabilities; will be equal to the total number of events to be generated; For sampling the bins indipendently, SampleBin should be used. bool Generate(unsigned int nevt, ROOT::Fit::UnBinData& data). generate a un-binned data sets (fill the given data set); if dataset has already data append to it. bool Generate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true). generate a bin data set .; A range must have been set before (otherwise inf is returned); and the bins are equidinstant in the previously defined range; bin center values must be present in given data set; If the sampler is implemented by a random one, the entries; will be binned according to the Poisson distribution; It is assumed the distribution is normalized, otherwise the nevt must be scaled; accordingly. The expected value/bin ",MatchSource.WIKI,root/html534/ROOT__Math__DistSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DistSampler.html
https://root.cern/root/html534/ROOT__Math__DistSampler.html:786,Modifiability,extend,extend,786," class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::DistSampler. class ROOT::Math::DistSampler. Interface class for generic sampling of a distribution,; i.e. generating random numbers according to arbitrary distributions. @ingroup Random. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~DistSampler(); virtual boolGenerate(unsigned int nevt, ROOT::Fit::UnBinData& data); virtual boolGenerate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true); boolGenerate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true); virtual TRandom*GetRandom(); virtual boolInit(const char* = """"); virtual boolInit(const ROOT::Math::DistSamplerOptions& opt); unsigned intNDim() const; const ROOT::Math::IMultiGenFunction&ParentPdf() const; const double*Sample(); virtual boolSample(double* x); virtual doubleSample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolSampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidSetArea(double); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& func); virtual voidSetMode(double); virtual voidSetRandom(TRandom*); voidSetRange(const ROOT::Fit::DataRange& range); voidSetRange(const double* xmin, const double* xmax); voidSetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int). protected:. virtual voidDoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolIsInitialized(); const ROOT::Fit::DataRange&PdfRange() const. Data Members; private:. vector<double>fDatainternal array used to cached the sample data ; const ROOT::Math::IMultiGenFunction*fFuncinternal function (ND); boolfOwnFuncflag to indicate if the function is owned; ROOT::Fit::DataRange*fRangedata range ",MatchSource.WIKI,root/html534/ROOT__Math__DistSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DistSampler.html
https://root.cern/root/html534/ROOT__Math__DistSampler.html:902,Modifiability,extend,extend,902," class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::DistSampler. class ROOT::Math::DistSampler. Interface class for generic sampling of a distribution,; i.e. generating random numbers according to arbitrary distributions. @ingroup Random. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~DistSampler(); virtual boolGenerate(unsigned int nevt, ROOT::Fit::UnBinData& data); virtual boolGenerate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true); boolGenerate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true); virtual TRandom*GetRandom(); virtual boolInit(const char* = """"); virtual boolInit(const ROOT::Math::DistSamplerOptions& opt); unsigned intNDim() const; const ROOT::Math::IMultiGenFunction&ParentPdf() const; const double*Sample(); virtual boolSample(double* x); virtual doubleSample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolSampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidSetArea(double); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& func); virtual voidSetMode(double); virtual voidSetRandom(TRandom*); voidSetRange(const ROOT::Fit::DataRange& range); voidSetRange(const double* xmin, const double* xmax); voidSetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int). protected:. virtual voidDoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolIsInitialized(); const ROOT::Fit::DataRange&PdfRange() const. Data Members; private:. vector<double>fDatainternal array used to cached the sample data ; const ROOT::Math::IMultiGenFunction*fFuncinternal function (ND); boolfOwnFuncflag to indicate if the function is owned; ROOT::Fit::DataRange*fRangedata range ",MatchSource.WIKI,root/html534/ROOT__Math__DistSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DistSampler.html
https://root.cern/root/html534/ROOT__Math__DistSampler.html:5619,Modifiability,extend,extend,5619,"ed classes. Sample(double* x). const double * Sample(). sample one event and rerturning array x with coordinates. bool SampleBin(double prob, double& value, double* error = 0). sample one bin given an estimated of the pdf in the bin; (this can be function value at the center or its integral in the bin; divided by the bin width); By default do not do random sample, just return the function values; Typically Poisson statistics will be used. bool SampleBins(unsigned int n, const double* prob, double* values, double* errors = 0). sample a set of bins given a vector of probabilities; Typically multinomial statistics will be used and the sum of the probabilities; will be equal to the total number of events to be generated; For sampling the bins indipendently, SampleBin should be used. bool Generate(unsigned int nevt, ROOT::Fit::UnBinData& data). generate a un-binned data sets (fill the given data set); if dataset has already data append to it. bool Generate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true). generate a bin data set .; A range must have been set before (otherwise inf is returned); and the bins are equidinstant in the previously defined range; bin center values must be present in given data set; If the sampler is implemented by a random one, the entries; will be binned according to the Poisson distribution; It is assumed the distribution is normalized, otherwise the nevt must be scaled; accordingly. The expected value/bin nexp = f(x_i) * binArea/ nevt; Extend control if use a fixed (i.e. multinomial statistics) or floating total number of events. bool Generate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true). same as before but passing the range in case of 1 dim data. bool IsInitialized(); check if generator have been initialized correctly and one can start generating. const ROOT::Fit::DataRange & PdfRange() const; return the data range of the Pdf . Must be called after set",MatchSource.WIKI,root/html534/ROOT__Math__DistSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DistSampler.html
https://root.cern/root/html534/ROOT__Math__DistSampler.html:6300,Modifiability,extend,extend,6300,"ot do random sample, just return the function values; Typically Poisson statistics will be used. bool SampleBins(unsigned int n, const double* prob, double* values, double* errors = 0). sample a set of bins given a vector of probabilities; Typically multinomial statistics will be used and the sum of the probabilities; will be equal to the total number of events to be generated; For sampling the bins indipendently, SampleBin should be used. bool Generate(unsigned int nevt, ROOT::Fit::UnBinData& data). generate a un-binned data sets (fill the given data set); if dataset has already data append to it. bool Generate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true). generate a bin data set .; A range must have been set before (otherwise inf is returned); and the bins are equidinstant in the previously defined range; bin center values must be present in given data set; If the sampler is implemented by a random one, the entries; will be binned according to the Poisson distribution; It is assumed the distribution is normalized, otherwise the nevt must be scaled; accordingly. The expected value/bin nexp = f(x_i) * binArea/ nevt; Extend control if use a fixed (i.e. multinomial statistics) or floating total number of events. bool Generate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true). same as before but passing the range in case of 1 dim data. bool IsInitialized(); check if generator have been initialized correctly and one can start generating. const ROOT::Fit::DataRange & PdfRange() const; return the data range of the Pdf . Must be called after setting the function.  Author: L. Moneta Fri Sep 22 15:06:47 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__DistSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DistSampler.html
https://root.cern/root/html534/ROOT__Math__DistSampler.html:2012,Performance,cache,cached,2012,"Math::IMultiGenFunction&ParentPdf() const; const double*Sample(); virtual boolSample(double* x); virtual doubleSample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolSampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidSetArea(double); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& func); virtual voidSetMode(double); virtual voidSetRandom(TRandom*); voidSetRange(const ROOT::Fit::DataRange& range); voidSetRange(const double* xmin, const double* xmax); voidSetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int). protected:. virtual voidDoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolIsInitialized(); const ROOT::Fit::DataRange&PdfRange() const. Data Members; private:. vector<double>fDatainternal array used to cached the sample data ; const ROOT::Math::IMultiGenFunction*fFuncinternal function (ND); boolfOwnFuncflag to indicate if the function is owned; ROOT::Fit::DataRange*fRangedata range . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~DistSampler(); virtual destructor. void SetFunction(Function & func, unsigned int dim); set the parent function distribution to use for sampling (generic case). DoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); need to clone to avoid temporary. void SetFunction(const ROOT::Math::IGenFunction& func); set the parent function distribution to use for random sampling (one dim case). unsigned int NDim() const; return the dimension of the parent distribution (and the data). { return fData.size(); }. bool Init(const char* = """"). initialize the generators with the given algorithm; Implemented by derived classes who needs it; (like UnuranSampler); If nothing is specified use default algorithm; from DistSamplerOptions::SetDefaultAlgorithm. { return true;}. bool Init(c",MatchSource.WIKI,root/html534/ROOT__Math__DistSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DistSampler.html
https://root.cern/root/html534/ROOT__Math__DistSampler.html:2544,Safety,avoid,avoid,2544,"ltiGenFunction& func); virtual voidSetMode(double); virtual voidSetRandom(TRandom*); voidSetRange(const ROOT::Fit::DataRange& range); voidSetRange(const double* xmin, const double* xmax); voidSetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int). protected:. virtual voidDoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); boolIsInitialized(); const ROOT::Fit::DataRange&PdfRange() const. Data Members; private:. vector<double>fDatainternal array used to cached the sample data ; const ROOT::Math::IMultiGenFunction*fFuncinternal function (ND); boolfOwnFuncflag to indicate if the function is owned; ROOT::Fit::DataRange*fRangedata range . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~DistSampler(); virtual destructor. void SetFunction(Function & func, unsigned int dim); set the parent function distribution to use for sampling (generic case). DoSetFunction(const ROOT::Math::IMultiGenFunction& func, bool copy); need to clone to avoid temporary. void SetFunction(const ROOT::Math::IGenFunction& func); set the parent function distribution to use for random sampling (one dim case). unsigned int NDim() const; return the dimension of the parent distribution (and the data). { return fData.size(); }. bool Init(const char* = """"). initialize the generators with the given algorithm; Implemented by derived classes who needs it; (like UnuranSampler); If nothing is specified use default algorithm; from DistSamplerOptions::SetDefaultAlgorithm. { return true;}. bool Init(const ROOT::Math::DistSamplerOptions& opt). initialize the generators with the given option; which my include the algorithm but also more if; the method is re-impelmented by derived class; The default implementation calls the above method; passing just the algorithm name. void SetRandom(TRandom* ). Set the random engine to be used; To be implemented by the derived classes who provides; random sampling. {}. void SetSeed(unsi",MatchSource.WIKI,root/html534/ROOT__Math__DistSampler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__DistSampler.html
https://root.cern/root/html534/ROOT__Math__Factory.html:335,Integrability,interface,interfaces,335,". ROOT::Math::Factory. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::Factory. class ROOT::Math::Factory. Factory class holding static functions to create the interfaces like ROOT::Math::Minimizer; via the Plugin Manager. Function Members (Methods); public:. ~Factory(); static ROOT::Math::DistSampler*CreateDistSampler(const string& samplerType = """"); static ROOT::Math::Minimizer*CreateMinimizer(const string& minimizerType = """", const string& algoType = """"); ROOT::Math::FactoryFactory(); ROOT::Math::FactoryFactory(const ROOT::Math::Factory&); ROOT::Math::Factory&operator=(const ROOT::Math::Factory&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ROOT::Math::Minimizer * CreateMinimizer(const string& minimizerType = """", const string& algoType = """"). static method to create the corrisponding Minimizer given the string; Supported Minimizers types are:; Minuit (TMinuit), Minuit2, GSLMultiMin, GSLMultiFit, GSLSimAn, Linear, Fumili, Genetic; If no name is given use default values defined in MinimizerOptions. ROOT::Math::DistSampler * CreateDistSampler(const string& samplerType = """"). static method to create the distribution sampler class given a string specifying the type; Supported sampler types are:; Unuran, Foam; If no name is given use default values defined in DistSamplerOptions.  Author: L. Moneta Fri Dec 22 14:43:33 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__Factory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__Factory.html
https://root.cern/root/html534/ROOT__Math__Functor.html:409,Availability,avail,available,409,". ROOT::Math::Functor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::Functor. class ROOT::Math::Functor: public ROOT::Math::IBaseFunctionMultiDim. LM 7/2/2014: no needed this : make template ctor of Functor1D and GradFunctor1D not; available to CINT s. #if defined(__MAKECINT__) || defined(G__DICTIONARY); needed since CINT initialize it with TRootIOCtor; class TRootIOCtor;. Function Members (Methods); public:. virtual~Functor(); virtual ROOT::Math::Functor::ImplBase*Clone() const; ROOT::Math::FunctorFunctor(); ROOT::Math::FunctorFunctor(const ROOT::Math::Functor& rhs); ROOT::Math::FunctorFunctor(void* p, unsigned int dim, const char* className = 0, const char* methodName = 0); virtual unsigned intNDim() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::Functor&operator=(const ROOT::Math::Functor& rhs). private:. virtual doubleDoEval(const double* x) const. Data Members; private:. auto_ptr<ROOT::Math::FunctorImpl<ROOT::Math::IBaseFunctionMultiDim> >fImplpointer to base functor handler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunc * Clone() const; clone of the function handler (use copy-ctor). unsigned int NDim() const; constructor for multi-dimensional functions. double DoEval(const double* x) const. Functor(). Default constructor. {}. Functor(const PtrObj& p, MemFn memFn, unsigned int dim ). construct from a pointer to member function (multi-dim type). {}. Functor( const Func & f, unsigned int dim ). construct from a callable object of multi-dimension; with the right signature (implementing operator()(double *x). {}. virtual ~Functor(). Destructor (no operations). {}.  Author: L. Moneta Mon Nov 13 15:58:13 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore",MatchSource.WIKI,root/html534/ROOT__Math__Functor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__Functor.html
https://root.cern/root/html534/ROOT__Math__Functor1D.html:413,Availability,avail,available,413,". ROOT::Math::Functor1D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::Functor1D. class ROOT::Math::Functor1D: public ROOT::Math::IBaseFunctionOneDim. LM 7/2/2014: no needed this : make template ctor of Functor1D and GradFunctor1D not; available to CINT s. #if defined(__MAKECINT__) || defined(G__DICTIONARY); needed since CINT initialize it with TRootIOCtor; class TRootIOCtor;. Function Members (Methods); public:. virtual~Functor1D(); virtual ROOT::Math::Functor1D::ImplBase*Clone() const; ROOT::Math::Functor1DFunctor1D(); ROOT::Math::Functor1DFunctor1D(const ROOT::Math::Functor1D& rhs); ROOT::Math::Functor1DFunctor1D(void* p, const char* className = 0, const char* methodName = 0); doubleROOT::Math::IBaseFunctionOneDim::operator()(double x) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(const double* x) const; ROOT::Math::Functor1D&operator=(const ROOT::Math::Functor1D& rhs). private:. virtual doubleDoEval(double x) const. Data Members; private:. auto_ptr<ROOT::Math::FunctorImpl<ROOT::Math::IBaseFunctionOneDim> >fImplpointer to base functor handler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunc * Clone() const; clone of the function handler (use copy-ctor). double DoEval(double x) const. Functor1D(). Default constructor. {}. Functor1D(const ROOT::Math::Functor1D& rhs). construct from a callable object with the right signature; implementing operator() (double x). {}. Functor1D(const PtrObj& p, MemFn memFn). construct from a pointer to member function (1D type). {}. virtual ~Functor1D(). Destructor (no operations). {}.  Author: L. Moneta Mon Nov 13 15:58:13 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For",MatchSource.WIKI,root/html534/ROOT__Math__Functor1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__Functor1D.html
https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html:1828,Availability,error,error,1828," 0); virtual doubleIntegral(); virtual doubleIntegral(const vector<double>& pts); virtual doubleIntegral(double a, double b); virtual doubleIntegralCauchy(double a, double b, double c); virtual doubleIntegralLow(double b); virtual doubleIntegralUp(double a); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double eps); virtual voidSetFunction(const ROOT::Math::IGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double eps); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. private:. virtual doubleDoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Data Members; protected:. doublefEpsAbsAbsolute error.; doublefEpsRelRelative error.; const ROOT::Math::IGenFunction*fFunctionPointer to function used.; doublefLastErrorError from the last stimation.; doublefLastResultResult from the last stimation.; boolfUsedOnceBool value to check if the function was at least called once.; static boolfgAbsValueAbsValue used for the calculation of the integral. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~GaussIntegrator(); Destructor . GaussIntegrator(double absTol = 0, double relTol = 0); Default Constructor. . void AbsValue(bool flag); Static function: set the fgAbsValue flag.; By default TF1::Integral uses the original function value to compute the integral; However, TF1::Moment, CentralMoment require to compute the integral; using the absolute value of the function. void SetRelTolerance(double eps); Implementing VirtualIntegrator Interface; Set the desired relative Error. . { fEpsRel = eps; }. void SetAbsTolerance(double eps); This",MatchSource.WIKI,root/html534/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html:1858,Availability,error,error,1858," virtual doubleIntegral(const vector<double>& pts); virtual doubleIntegral(double a, double b); virtual doubleIntegralCauchy(double a, double b, double c); virtual doubleIntegralLow(double b); virtual doubleIntegralUp(double a); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double eps); virtual voidSetFunction(const ROOT::Math::IGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double eps); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. private:. virtual doubleDoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Data Members; protected:. doublefEpsAbsAbsolute error.; doublefEpsRelRelative error.; const ROOT::Math::IGenFunction*fFunctionPointer to function used.; doublefLastErrorError from the last stimation.; doublefLastResultResult from the last stimation.; boolfUsedOnceBool value to check if the function was at least called once.; static boolfgAbsValueAbsValue used for the calculation of the integral. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~GaussIntegrator(); Destructor . GaussIntegrator(double absTol = 0, double relTol = 0); Default Constructor. . void AbsValue(bool flag); Static function: set the fgAbsValue flag.; By default TF1::Integral uses the original function value to compute the integral; However, TF1::Moment, CentralMoment require to compute the integral; using the absolute value of the function. void SetRelTolerance(double eps); Implementing VirtualIntegrator Interface; Set the desired relative Error. . { fEpsRel = eps; }. void SetAbsTolerance(double eps); This method is not implemented. .",MatchSource.WIKI,root/html534/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html:3935,Availability,error,error,3935,"culation. . double Error() const; Return the estimate of the absolute Error of the last Integral calculation. . int Status() const; return the status of the last integration - 0 in case of success . double Integral(double a, double b); Implementing VirtualIntegratorOneDim Interface. Returns Integral of function between a and b.; Based on original CERNLIB routine DGAUSS by Sigfried Kolbig; converted to C++ by Rene Brun. This function computes, to an attempted specified accuracy, the value; of the integral. Method:; For any interval [a,b] we define g8(a,b) and g16(a,b) to be the 8-point; and 16-point Gaussian quadrature approximations to. and define. Then,. where, starting with x0 = A and finishing with xk = B,; the subdivision points xi(i=1,2,...) are given by. is equal to the first member of the; sequence 1,1/2,1/4,... for which r(xi-1, xi) < EPS.; If, at any stage in the process of subdivision, the ratio. is so small that 1+0.005q is indistinguishable from 1 to; machine accuracy, an error exit occurs with the function value; set equal to zero. Accuracy:; The user provides absolute and relative error bounds (epsrel and epsabs) and the; algorithm will stop when the estimated error is less than the epsabs OR is less; than |I| * epsrel.; Unless there is severe cancellation of positive and negative values of; f(x) over the interval [A,B], the relative error may be considered as; specifying a bound on the <I>relative</I> error of I in the case; |I|&gt;1, and a bound on the absolute error in the case |I|&lt;1. More; precisely, if k is the number of sub-intervals contributing to the; approximation (see Method), and if. then the relation. will nearly always be true, provided the routine terminates without; printing an error message. For functions f having no singularities in; the closed interval [A,B] the accuracy will usually be much higher than; this. Error handling:; The requested accuracy cannot be obtained (see Method).; The function value is set equal to zero. Note 1:;",MatchSource.WIKI,root/html534/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html:4048,Availability,error,error,4048," last integration - 0 in case of success . double Integral(double a, double b); Implementing VirtualIntegratorOneDim Interface. Returns Integral of function between a and b.; Based on original CERNLIB routine DGAUSS by Sigfried Kolbig; converted to C++ by Rene Brun. This function computes, to an attempted specified accuracy, the value; of the integral. Method:; For any interval [a,b] we define g8(a,b) and g16(a,b) to be the 8-point; and 16-point Gaussian quadrature approximations to. and define. Then,. where, starting with x0 = A and finishing with xk = B,; the subdivision points xi(i=1,2,...) are given by. is equal to the first member of the; sequence 1,1/2,1/4,... for which r(xi-1, xi) < EPS.; If, at any stage in the process of subdivision, the ratio. is so small that 1+0.005q is indistinguishable from 1 to; machine accuracy, an error exit occurs with the function value; set equal to zero. Accuracy:; The user provides absolute and relative error bounds (epsrel and epsabs) and the; algorithm will stop when the estimated error is less than the epsabs OR is less; than |I| * epsrel.; Unless there is severe cancellation of positive and negative values of; f(x) over the interval [A,B], the relative error may be considered as; specifying a bound on the <I>relative</I> error of I in the case; |I|&gt;1, and a bound on the absolute error in the case |I|&lt;1. More; precisely, if k is the number of sub-intervals contributing to the; approximation (see Method), and if. then the relation. will nearly always be true, provided the routine terminates without; printing an error message. For functions f having no singularities in; the closed interval [A,B] the accuracy will usually be much higher than; this. Error handling:; The requested accuracy cannot be obtained (see Method).; The function value is set equal to zero. Note 1:; Values of the function f(x) at the interval end-points A and B are not; required. The subprogram may therefore be used when these values are; undefined. do",MatchSource.WIKI,root/html534/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html:4129,Availability,error,error,4129," last integration - 0 in case of success . double Integral(double a, double b); Implementing VirtualIntegratorOneDim Interface. Returns Integral of function between a and b.; Based on original CERNLIB routine DGAUSS by Sigfried Kolbig; converted to C++ by Rene Brun. This function computes, to an attempted specified accuracy, the value; of the integral. Method:; For any interval [a,b] we define g8(a,b) and g16(a,b) to be the 8-point; and 16-point Gaussian quadrature approximations to. and define. Then,. where, starting with x0 = A and finishing with xk = B,; the subdivision points xi(i=1,2,...) are given by. is equal to the first member of the; sequence 1,1/2,1/4,... for which r(xi-1, xi) < EPS.; If, at any stage in the process of subdivision, the ratio. is so small that 1+0.005q is indistinguishable from 1 to; machine accuracy, an error exit occurs with the function value; set equal to zero. Accuracy:; The user provides absolute and relative error bounds (epsrel and epsabs) and the; algorithm will stop when the estimated error is less than the epsabs OR is less; than |I| * epsrel.; Unless there is severe cancellation of positive and negative values of; f(x) over the interval [A,B], the relative error may be considered as; specifying a bound on the <I>relative</I> error of I in the case; |I|&gt;1, and a bound on the absolute error in the case |I|&lt;1. More; precisely, if k is the number of sub-intervals contributing to the; approximation (see Method), and if. then the relation. will nearly always be true, provided the routine terminates without; printing an error message. For functions f having no singularities in; the closed interval [A,B] the accuracy will usually be much higher than; this. Error handling:; The requested accuracy cannot be obtained (see Method).; The function value is set equal to zero. Note 1:; Values of the function f(x) at the interval end-points A and B are not; required. The subprogram may therefore be used when these values are; undefined. do",MatchSource.WIKI,root/html534/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html:4306,Availability,error,error,4306," converted to C++ by Rene Brun. This function computes, to an attempted specified accuracy, the value; of the integral. Method:; For any interval [a,b] we define g8(a,b) and g16(a,b) to be the 8-point; and 16-point Gaussian quadrature approximations to. and define. Then,. where, starting with x0 = A and finishing with xk = B,; the subdivision points xi(i=1,2,...) are given by. is equal to the first member of the; sequence 1,1/2,1/4,... for which r(xi-1, xi) < EPS.; If, at any stage in the process of subdivision, the ratio. is so small that 1+0.005q is indistinguishable from 1 to; machine accuracy, an error exit occurs with the function value; set equal to zero. Accuracy:; The user provides absolute and relative error bounds (epsrel and epsabs) and the; algorithm will stop when the estimated error is less than the epsabs OR is less; than |I| * epsrel.; Unless there is severe cancellation of positive and negative values of; f(x) over the interval [A,B], the relative error may be considered as; specifying a bound on the <I>relative</I> error of I in the case; |I|&gt;1, and a bound on the absolute error in the case |I|&lt;1. More; precisely, if k is the number of sub-intervals contributing to the; approximation (see Method), and if. then the relation. will nearly always be true, provided the routine terminates without; printing an error message. For functions f having no singularities in; the closed interval [A,B] the accuracy will usually be much higher than; this. Error handling:; The requested accuracy cannot be obtained (see Method).; The function value is set equal to zero. Note 1:; Values of the function f(x) at the interval end-points A and B are not; required. The subprogram may therefore be used when these values are; undefined. double Integral(); Returns Integral of function on an infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate va",MatchSource.WIKI,root/html534/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html:4376,Availability,error,error,4376," converted to C++ by Rene Brun. This function computes, to an attempted specified accuracy, the value; of the integral. Method:; For any interval [a,b] we define g8(a,b) and g16(a,b) to be the 8-point; and 16-point Gaussian quadrature approximations to. and define. Then,. where, starting with x0 = A and finishing with xk = B,; the subdivision points xi(i=1,2,...) are given by. is equal to the first member of the; sequence 1,1/2,1/4,... for which r(xi-1, xi) < EPS.; If, at any stage in the process of subdivision, the ratio. is so small that 1+0.005q is indistinguishable from 1 to; machine accuracy, an error exit occurs with the function value; set equal to zero. Accuracy:; The user provides absolute and relative error bounds (epsrel and epsabs) and the; algorithm will stop when the estimated error is less than the epsabs OR is less; than |I| * epsrel.; Unless there is severe cancellation of positive and negative values of; f(x) over the interval [A,B], the relative error may be considered as; specifying a bound on the <I>relative</I> error of I in the case; |I|&gt;1, and a bound on the absolute error in the case |I|&lt;1. More; precisely, if k is the number of sub-intervals contributing to the; approximation (see Method), and if. then the relation. will nearly always be true, provided the routine terminates without; printing an error message. For functions f having no singularities in; the closed interval [A,B] the accuracy will usually be much higher than; this. Error handling:; The requested accuracy cannot be obtained (see Method).; The function value is set equal to zero. Note 1:; Values of the function f(x) at the interval end-points A and B are not; required. The subprogram may therefore be used when these values are; undefined. double Integral(); Returns Integral of function on an infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate va",MatchSource.WIKI,root/html534/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html:4438,Availability,error,error,4438," converted to C++ by Rene Brun. This function computes, to an attempted specified accuracy, the value; of the integral. Method:; For any interval [a,b] we define g8(a,b) and g16(a,b) to be the 8-point; and 16-point Gaussian quadrature approximations to. and define. Then,. where, starting with x0 = A and finishing with xk = B,; the subdivision points xi(i=1,2,...) are given by. is equal to the first member of the; sequence 1,1/2,1/4,... for which r(xi-1, xi) < EPS.; If, at any stage in the process of subdivision, the ratio. is so small that 1+0.005q is indistinguishable from 1 to; machine accuracy, an error exit occurs with the function value; set equal to zero. Accuracy:; The user provides absolute and relative error bounds (epsrel and epsabs) and the; algorithm will stop when the estimated error is less than the epsabs OR is less; than |I| * epsrel.; Unless there is severe cancellation of positive and negative values of; f(x) over the interval [A,B], the relative error may be considered as; specifying a bound on the <I>relative</I> error of I in the case; |I|&gt;1, and a bound on the absolute error in the case |I|&lt;1. More; precisely, if k is the number of sub-intervals contributing to the; approximation (see Method), and if. then the relation. will nearly always be true, provided the routine terminates without; printing an error message. For functions f having no singularities in; the closed interval [A,B] the accuracy will usually be much higher than; this. Error handling:; The requested accuracy cannot be obtained (see Method).; The function value is set equal to zero. Note 1:; Values of the function f(x) at the interval end-points A and B are not; required. The subprogram may therefore be used when these values are; undefined. double Integral(); Returns Integral of function on an infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate va",MatchSource.WIKI,root/html534/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html:4676,Availability,error,error,4676,"with xk = B,; the subdivision points xi(i=1,2,...) are given by. is equal to the first member of the; sequence 1,1/2,1/4,... for which r(xi-1, xi) < EPS.; If, at any stage in the process of subdivision, the ratio. is so small that 1+0.005q is indistinguishable from 1 to; machine accuracy, an error exit occurs with the function value; set equal to zero. Accuracy:; The user provides absolute and relative error bounds (epsrel and epsabs) and the; algorithm will stop when the estimated error is less than the epsabs OR is less; than |I| * epsrel.; Unless there is severe cancellation of positive and negative values of; f(x) over the interval [A,B], the relative error may be considered as; specifying a bound on the <I>relative</I> error of I in the case; |I|&gt;1, and a bound on the absolute error in the case |I|&lt;1. More; precisely, if k is the number of sub-intervals contributing to the; approximation (see Method), and if. then the relation. will nearly always be true, provided the routine terminates without; printing an error message. For functions f having no singularities in; the closed interval [A,B] the accuracy will usually be much higher than; this. Error handling:; The requested accuracy cannot be obtained (see Method).; The function value is set equal to zero. Note 1:; Values of the function f(x) at the interval end-points A and B are not; required. The subprogram may therefore be used when these values are; undefined. double Integral(); Returns Integral of function on an infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. double IntegralUp(double a); Returns Integral of function on an upper semi-infinite interval.; This function computes, to an attempted specified accuracy, the value of the integra",MatchSource.WIKI,root/html534/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html:385,Deployability,integrat,integration,385,". ROOT::Math::GaussIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::GaussIntegrator. class ROOT::Math::GaussIntegrator: public ROOT::Math::VirtualIntegratorOneDim. User class for performing function integration. It will use the Gauss Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. Function Members (Methods); public:. virtual~GaussIntegrator(); voidAbsValue(bool flag); virtual doubleError() const; ROOT::Math::GaussIntegratorGaussIntegrator(const ROOT::Math::GaussIntegrator&); ROOT::Math::GaussIntegratorGaussIntegrator(double absTol = 0, double relTol = 0); virtual doubleIntegral(); virtual doubleIntegral(const vector<double>& pts); virtual doubleIntegral(double a, double b); virtual doubleIntegralCauchy(double a, double b, double c); virtual doubleIntegralLow(double b); virtual doubleIntegralUp(double a); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double eps); virtual voidSetFunction(const ROOT::Math::IGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double eps); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. private:. virtual doubleDoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Data Members; protected:. doublefEpsAbsAbsolute error.; doublefEpsRelRelative error.; const ROOT::Math::IGenFunction*fFunctionPointer to function used.; doublefLastErrorError from the last stimation.; doublefLastResultRes",MatchSource.WIKI,root/html534/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html:440,Deployability,integrat,integration,440,". ROOT::Math::GaussIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::GaussIntegrator. class ROOT::Math::GaussIntegrator: public ROOT::Math::VirtualIntegratorOneDim. User class for performing function integration. It will use the Gauss Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. Function Members (Methods); public:. virtual~GaussIntegrator(); voidAbsValue(bool flag); virtual doubleError() const; ROOT::Math::GaussIntegratorGaussIntegrator(const ROOT::Math::GaussIntegrator&); ROOT::Math::GaussIntegratorGaussIntegrator(double absTol = 0, double relTol = 0); virtual doubleIntegral(); virtual doubleIntegral(const vector<double>& pts); virtual doubleIntegral(double a, double b); virtual doubleIntegralCauchy(double a, double b, double c); virtual doubleIntegralLow(double b); virtual doubleIntegralUp(double a); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double eps); virtual voidSetFunction(const ROOT::Math::IGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double eps); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. private:. virtual doubleDoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Data Members; protected:. doublefEpsAbsAbsolute error.; doublefEpsRelRelative error.; const ROOT::Math::IGenFunction*fFunctionPointer to function used.; doublefLastErrorError from the last stimation.; doublefLastResultRes",MatchSource.WIKI,root/html534/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html:3098,Deployability,integrat,integration,3098,"st called once.; static boolfgAbsValueAbsValue used for the calculation of the integral. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~GaussIntegrator(); Destructor . GaussIntegrator(double absTol = 0, double relTol = 0); Default Constructor. . void AbsValue(bool flag); Static function: set the fgAbsValue flag.; By default TF1::Integral uses the original function value to compute the integral; However, TF1::Moment, CentralMoment require to compute the integral; using the absolute value of the function. void SetRelTolerance(double eps); Implementing VirtualIntegrator Interface; Set the desired relative Error. . { fEpsRel = eps; }. void SetAbsTolerance(double eps); This method is not implemented. . { fEpsAbs = eps; }. double Result() const; Returns the result of the last Integral calculation. . double Error() const; Return the estimate of the absolute Error of the last Integral calculation. . int Status() const; return the status of the last integration - 0 in case of success . double Integral(double a, double b); Implementing VirtualIntegratorOneDim Interface. Returns Integral of function between a and b.; Based on original CERNLIB routine DGAUSS by Sigfried Kolbig; converted to C++ by Rene Brun. This function computes, to an attempted specified accuracy, the value; of the integral. Method:; For any interval [a,b] we define g8(a,b) and g16(a,b) to be the 8-point; and 16-point Gaussian quadrature approximations to. and define. Then,. where, starting with x0 = A and finishing with xk = B,; the subdivision points xi(i=1,2,...) are given by. is equal to the first member of the; sequence 1,1/2,1/4,... for which r(xi-1, xi) < EPS.; If, at any stage in the process of subdivision, the ratio. is so small that 1+0.005q is indistinguishable from 1 to; machine accuracy, an error exit occurs with the function value; set equal to zero. Accuracy:; The user provides absolute and relative error bounds (epsrel and epsabs) and the; a",MatchSource.WIKI,root/html534/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html:5769,Deployability,integrat,integration,5769,"ccuracy will usually be much higher than; this. Error handling:; The requested accuracy cannot be obtained (see Method).; The function value is set equal to zero. Note 1:; Values of the function f(x) at the interval end-points A and B are not; required. The subprogram may therefore be used when these values are; undefined. double Integral(); Returns Integral of function on an infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. double IntegralUp(double a); Returns Integral of function on an upper semi-infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I.; - A: lower end-point of integration interval. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. double IntegralLow(double b); Returns Integral of function on a lower semi-infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I.; - B: upper end-point of integration interval. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. void SetFunction(const ROOT::Math::IGenFunction& ); Set integration function (flag control if function must be copied inside).; \@param f Function to be used in the calculations. double Integral(const vector<double>& pts); This method is not implemented. . double IntegralCauchy(double a, double b, double c); This method is not implemented. . void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options",MatchSource.WIKI,root/html534/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html:6209,Deployability,integrat,integration,6209,"pecified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. double IntegralUp(double a); Returns Integral of function on an upper semi-infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I.; - A: lower end-point of integration interval. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. double IntegralLow(double b); Returns Integral of function on a lower semi-infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I.; - B: upper end-point of integration interval. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. void SetFunction(const ROOT::Math::IGenFunction& ); Set integration function (flag control if function must be copied inside).; \@param f Function to be used in the calculations. double Integral(const vector<double>& pts); This method is not implemented. . double IntegralCauchy(double a, double b, double c); This method is not implemented. . void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. double DoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Integration surrugate method. Return integral of passed function in interval [a,b]; Derived class (like GaussLegendreIntegrator) can re-implement this method to modify to use; an improved algorithm.  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the docum",MatchSource.WIKI,root/html534/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html:6399,Deployability,integrat,integration,6399,"thmetic expression, this function has the approximate value; of the integral I. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. double IntegralUp(double a); Returns Integral of function on an upper semi-infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I.; - A: lower end-point of integration interval. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. double IntegralLow(double b); Returns Integral of function on a lower semi-infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I.; - B: upper end-point of integration interval. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. void SetFunction(const ROOT::Math::IGenFunction& ); Set integration function (flag control if function must be copied inside).; \@param f Function to be used in the calculations. double Integral(const vector<double>& pts); This method is not implemented. . double IntegralCauchy(double a, double b, double c); This method is not implemented. . void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. double DoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Integration surrugate method. Return integral of passed function in interval [a,b]; Derived class (like GaussLegendreIntegrator) can re-implement this method to modify to use; an improved algorithm.  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html:385,Integrability,integrat,integration,385,". ROOT::Math::GaussIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::GaussIntegrator. class ROOT::Math::GaussIntegrator: public ROOT::Math::VirtualIntegratorOneDim. User class for performing function integration. It will use the Gauss Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. Function Members (Methods); public:. virtual~GaussIntegrator(); voidAbsValue(bool flag); virtual doubleError() const; ROOT::Math::GaussIntegratorGaussIntegrator(const ROOT::Math::GaussIntegrator&); ROOT::Math::GaussIntegratorGaussIntegrator(double absTol = 0, double relTol = 0); virtual doubleIntegral(); virtual doubleIntegral(const vector<double>& pts); virtual doubleIntegral(double a, double b); virtual doubleIntegralCauchy(double a, double b, double c); virtual doubleIntegralLow(double b); virtual doubleIntegralUp(double a); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double eps); virtual voidSetFunction(const ROOT::Math::IGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double eps); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. private:. virtual doubleDoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Data Members; protected:. doublefEpsAbsAbsolute error.; doublefEpsRelRelative error.; const ROOT::Math::IGenFunction*fFunctionPointer to function used.; doublefLastErrorError from the last stimation.; doublefLastResultRes",MatchSource.WIKI,root/html534/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html:440,Integrability,integrat,integration,440,". ROOT::Math::GaussIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::GaussIntegrator. class ROOT::Math::GaussIntegrator: public ROOT::Math::VirtualIntegratorOneDim. User class for performing function integration. It will use the Gauss Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. Function Members (Methods); public:. virtual~GaussIntegrator(); voidAbsValue(bool flag); virtual doubleError() const; ROOT::Math::GaussIntegratorGaussIntegrator(const ROOT::Math::GaussIntegrator&); ROOT::Math::GaussIntegratorGaussIntegrator(double absTol = 0, double relTol = 0); virtual doubleIntegral(); virtual doubleIntegral(const vector<double>& pts); virtual doubleIntegral(double a, double b); virtual doubleIntegralCauchy(double a, double b, double c); virtual doubleIntegralLow(double b); virtual doubleIntegralUp(double a); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double eps); virtual voidSetFunction(const ROOT::Math::IGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double eps); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. private:. virtual doubleDoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Data Members; protected:. doublefEpsAbsAbsolute error.; doublefEpsRelRelative error.; const ROOT::Math::IGenFunction*fFunctionPointer to function used.; doublefLastErrorError from the last stimation.; doublefLastResultRes",MatchSource.WIKI,root/html534/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html:3098,Integrability,integrat,integration,3098,"st called once.; static boolfgAbsValueAbsValue used for the calculation of the integral. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~GaussIntegrator(); Destructor . GaussIntegrator(double absTol = 0, double relTol = 0); Default Constructor. . void AbsValue(bool flag); Static function: set the fgAbsValue flag.; By default TF1::Integral uses the original function value to compute the integral; However, TF1::Moment, CentralMoment require to compute the integral; using the absolute value of the function. void SetRelTolerance(double eps); Implementing VirtualIntegrator Interface; Set the desired relative Error. . { fEpsRel = eps; }. void SetAbsTolerance(double eps); This method is not implemented. . { fEpsAbs = eps; }. double Result() const; Returns the result of the last Integral calculation. . double Error() const; Return the estimate of the absolute Error of the last Integral calculation. . int Status() const; return the status of the last integration - 0 in case of success . double Integral(double a, double b); Implementing VirtualIntegratorOneDim Interface. Returns Integral of function between a and b.; Based on original CERNLIB routine DGAUSS by Sigfried Kolbig; converted to C++ by Rene Brun. This function computes, to an attempted specified accuracy, the value; of the integral. Method:; For any interval [a,b] we define g8(a,b) and g16(a,b) to be the 8-point; and 16-point Gaussian quadrature approximations to. and define. Then,. where, starting with x0 = A and finishing with xk = B,; the subdivision points xi(i=1,2,...) are given by. is equal to the first member of the; sequence 1,1/2,1/4,... for which r(xi-1, xi) < EPS.; If, at any stage in the process of subdivision, the ratio. is so small that 1+0.005q is indistinguishable from 1 to; machine accuracy, an error exit occurs with the function value; set equal to zero. Accuracy:; The user provides absolute and relative error bounds (epsrel and epsabs) and the; a",MatchSource.WIKI,root/html534/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html:3293,Integrability,rout,routine,3293,"GaussIntegrator(double absTol = 0, double relTol = 0); Default Constructor. . void AbsValue(bool flag); Static function: set the fgAbsValue flag.; By default TF1::Integral uses the original function value to compute the integral; However, TF1::Moment, CentralMoment require to compute the integral; using the absolute value of the function. void SetRelTolerance(double eps); Implementing VirtualIntegrator Interface; Set the desired relative Error. . { fEpsRel = eps; }. void SetAbsTolerance(double eps); This method is not implemented. . { fEpsAbs = eps; }. double Result() const; Returns the result of the last Integral calculation. . double Error() const; Return the estimate of the absolute Error of the last Integral calculation. . int Status() const; return the status of the last integration - 0 in case of success . double Integral(double a, double b); Implementing VirtualIntegratorOneDim Interface. Returns Integral of function between a and b.; Based on original CERNLIB routine DGAUSS by Sigfried Kolbig; converted to C++ by Rene Brun. This function computes, to an attempted specified accuracy, the value; of the integral. Method:; For any interval [a,b] we define g8(a,b) and g16(a,b) to be the 8-point; and 16-point Gaussian quadrature approximations to. and define. Then,. where, starting with x0 = A and finishing with xk = B,; the subdivision points xi(i=1,2,...) are given by. is equal to the first member of the; sequence 1,1/2,1/4,... for which r(xi-1, xi) < EPS.; If, at any stage in the process of subdivision, the ratio. is so small that 1+0.005q is indistinguishable from 1 to; machine accuracy, an error exit occurs with the function value; set equal to zero. Accuracy:; The user provides absolute and relative error bounds (epsrel and epsabs) and the; algorithm will stop when the estimated error is less than the epsabs OR is less; than |I| * epsrel.; Unless there is severe cancellation of positive and negative values of; f(x) over the interval [A,B], the relative error ",MatchSource.WIKI,root/html534/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html:4636,Integrability,rout,routine,4636,"with xk = B,; the subdivision points xi(i=1,2,...) are given by. is equal to the first member of the; sequence 1,1/2,1/4,... for which r(xi-1, xi) < EPS.; If, at any stage in the process of subdivision, the ratio. is so small that 1+0.005q is indistinguishable from 1 to; machine accuracy, an error exit occurs with the function value; set equal to zero. Accuracy:; The user provides absolute and relative error bounds (epsrel and epsabs) and the; algorithm will stop when the estimated error is less than the epsabs OR is less; than |I| * epsrel.; Unless there is severe cancellation of positive and negative values of; f(x) over the interval [A,B], the relative error may be considered as; specifying a bound on the <I>relative</I> error of I in the case; |I|&gt;1, and a bound on the absolute error in the case |I|&lt;1. More; precisely, if k is the number of sub-intervals contributing to the; approximation (see Method), and if. then the relation. will nearly always be true, provided the routine terminates without; printing an error message. For functions f having no singularities in; the closed interval [A,B] the accuracy will usually be much higher than; this. Error handling:; The requested accuracy cannot be obtained (see Method).; The function value is set equal to zero. Note 1:; Values of the function f(x) at the interval end-points A and B are not; required. The subprogram may therefore be used when these values are; undefined. double Integral(); Returns Integral of function on an infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. double IntegralUp(double a); Returns Integral of function on an upper semi-infinite interval.; This function computes, to an attempted specified accuracy, the value of the integra",MatchSource.WIKI,root/html534/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html:4682,Integrability,message,message,4682,"with xk = B,; the subdivision points xi(i=1,2,...) are given by. is equal to the first member of the; sequence 1,1/2,1/4,... for which r(xi-1, xi) < EPS.; If, at any stage in the process of subdivision, the ratio. is so small that 1+0.005q is indistinguishable from 1 to; machine accuracy, an error exit occurs with the function value; set equal to zero. Accuracy:; The user provides absolute and relative error bounds (epsrel and epsabs) and the; algorithm will stop when the estimated error is less than the epsabs OR is less; than |I| * epsrel.; Unless there is severe cancellation of positive and negative values of; f(x) over the interval [A,B], the relative error may be considered as; specifying a bound on the <I>relative</I> error of I in the case; |I|&gt;1, and a bound on the absolute error in the case |I|&lt;1. More; precisely, if k is the number of sub-intervals contributing to the; approximation (see Method), and if. then the relation. will nearly always be true, provided the routine terminates without; printing an error message. For functions f having no singularities in; the closed interval [A,B] the accuracy will usually be much higher than; this. Error handling:; The requested accuracy cannot be obtained (see Method).; The function value is set equal to zero. Note 1:; Values of the function f(x) at the interval end-points A and B are not; required. The subprogram may therefore be used when these values are; undefined. double Integral(); Returns Integral of function on an infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. double IntegralUp(double a); Returns Integral of function on an upper semi-infinite interval.; This function computes, to an attempted specified accuracy, the value of the integra",MatchSource.WIKI,root/html534/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html:5769,Integrability,integrat,integration,5769,"ccuracy will usually be much higher than; this. Error handling:; The requested accuracy cannot be obtained (see Method).; The function value is set equal to zero. Note 1:; Values of the function f(x) at the interval end-points A and B are not; required. The subprogram may therefore be used when these values are; undefined. double Integral(); Returns Integral of function on an infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. double IntegralUp(double a); Returns Integral of function on an upper semi-infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I.; - A: lower end-point of integration interval. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. double IntegralLow(double b); Returns Integral of function on a lower semi-infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I.; - B: upper end-point of integration interval. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. void SetFunction(const ROOT::Math::IGenFunction& ); Set integration function (flag control if function must be copied inside).; \@param f Function to be used in the calculations. double Integral(const vector<double>& pts); This method is not implemented. . double IntegralCauchy(double a, double b, double c); This method is not implemented. . void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options",MatchSource.WIKI,root/html534/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html:6209,Integrability,integrat,integration,6209,"pecified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. double IntegralUp(double a); Returns Integral of function on an upper semi-infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I.; - A: lower end-point of integration interval. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. double IntegralLow(double b); Returns Integral of function on a lower semi-infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I.; - B: upper end-point of integration interval. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. void SetFunction(const ROOT::Math::IGenFunction& ); Set integration function (flag control if function must be copied inside).; \@param f Function to be used in the calculations. double Integral(const vector<double>& pts); This method is not implemented. . double IntegralCauchy(double a, double b, double c); This method is not implemented. . void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. double DoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Integration surrugate method. Return integral of passed function in interval [a,b]; Derived class (like GaussLegendreIntegrator) can re-implement this method to modify to use; an improved algorithm.  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the docum",MatchSource.WIKI,root/html534/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html:6399,Integrability,integrat,integration,6399,"thmetic expression, this function has the approximate value; of the integral I. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. double IntegralUp(double a); Returns Integral of function on an upper semi-infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I.; - A: lower end-point of integration interval. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. double IntegralLow(double b); Returns Integral of function on a lower semi-infinite interval.; This function computes, to an attempted specified accuracy, the value of the integral:. Usage:; In any arithmetic expression, this function has the approximate value; of the integral I.; - B: upper end-point of integration interval. The integral is mapped onto [0,1] using a transformation then integral computation is surrogated to DoIntegral. void SetFunction(const ROOT::Math::IGenFunction& ); Set integration function (flag control if function must be copied inside).; \@param f Function to be used in the calculations. double Integral(const vector<double>& pts); This method is not implemented. . double IntegralCauchy(double a, double b, double c); This method is not implemented. . void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. double DoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Integration surrugate method. Return integral of passed function in interval [a,b]; Derived class (like GaussLegendreIntegrator) can re-implement this method to modify to use; an improved algorithm.  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html:365,Performance,perform,performing,365,". ROOT::Math::GaussIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::GaussIntegrator. class ROOT::Math::GaussIntegrator: public ROOT::Math::VirtualIntegratorOneDim. User class for performing function integration. It will use the Gauss Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. Function Members (Methods); public:. virtual~GaussIntegrator(); voidAbsValue(bool flag); virtual doubleError() const; ROOT::Math::GaussIntegratorGaussIntegrator(const ROOT::Math::GaussIntegrator&); ROOT::Math::GaussIntegratorGaussIntegrator(double absTol = 0, double relTol = 0); virtual doubleIntegral(); virtual doubleIntegral(const vector<double>& pts); virtual doubleIntegral(double a, double b); virtual doubleIntegralCauchy(double a, double b, double c); virtual doubleIntegralLow(double b); virtual doubleIntegralUp(double a); virtual intROOT::Math::VirtualIntegrator::NEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double eps); virtual voidSetFunction(const ROOT::Math::IGenFunction&); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double eps); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. private:. virtual doubleDoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Data Members; protected:. doublefEpsAbsAbsolute error.; doublefEpsRelRelative error.; const ROOT::Math::IGenFunction*fFunctionPointer to function used.; doublefLastErrorError from the last stimation.; doublefLastResultRes",MatchSource.WIKI,root/html534/ROOT__Math__GaussIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GaussIntegrator.html
https://root.cern/root/html534/ROOT__Math__GaussLegendreIntegrator.html:2573,Availability,error,error,2573,"ual doubleROOT::Math::GaussIntegrator::IntegralLow(double b); virtual doubleROOT::Math::GaussIntegrator::IntegralUp(double a); virtual intNEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleROOT::Math::GaussIntegrator::Result() const; virtual voidSetAbsTolerance(double); virtual voidROOT::Math::GaussIntegrator::SetFunction(const ROOT::Math::IGenFunction&); voidSetNumberPoints(int num); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double); virtual intROOT::Math::GaussIntegrator::Status() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. private:. voidCalcGaussLegendreSamplingPoints(); virtual doubleDoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Data Members; protected:. doubleROOT::Math::GaussIntegrator::fEpsAbsAbsolute error.; doubleROOT::Math::GaussIntegrator::fEpsRelRelative error.; const ROOT::Math::IGenFunction*ROOT::Math::GaussIntegrator::fFunctionPointer to function used.; doubleROOT::Math::GaussIntegrator::fLastErrorError from the last stimation.; doubleROOT::Math::GaussIntegrator::fLastResultResult from the last stimation.; intfNumNumber of points used in the stimation of the integral.; boolROOT::Math::GaussIntegrator::fUsedOnceBool value to check if the function was at least called once.; double*fWWeights of the points used.; double*fXAbscisa of the points used.; static boolROOT::Math::GaussIntegrator::fgAbsValueAbsValue used for the calculation of the integral. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GaussLegendreIntegrator(int num = 10, double eps = 1e-12); Basic contructor of GaussLegendreIntegrator.; \@param num Number of desired points to calculate the integration.; \@param eps Desired relative error. virtual ~Gau",MatchSource.WIKI,root/html534/ROOT__Math__GaussLegendreIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GaussLegendreIntegrator.html
https://root.cern/root/html534/ROOT__Math__GaussLegendreIntegrator.html:2632,Availability,error,error,2632,"b); virtual doubleROOT::Math::GaussIntegrator::IntegralUp(double a); virtual intNEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleROOT::Math::GaussIntegrator::Result() const; virtual voidSetAbsTolerance(double); virtual voidROOT::Math::GaussIntegrator::SetFunction(const ROOT::Math::IGenFunction&); voidSetNumberPoints(int num); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double); virtual intROOT::Math::GaussIntegrator::Status() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. private:. voidCalcGaussLegendreSamplingPoints(); virtual doubleDoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Data Members; protected:. doubleROOT::Math::GaussIntegrator::fEpsAbsAbsolute error.; doubleROOT::Math::GaussIntegrator::fEpsRelRelative error.; const ROOT::Math::IGenFunction*ROOT::Math::GaussIntegrator::fFunctionPointer to function used.; doubleROOT::Math::GaussIntegrator::fLastErrorError from the last stimation.; doubleROOT::Math::GaussIntegrator::fLastResultResult from the last stimation.; intfNumNumber of points used in the stimation of the integral.; boolROOT::Math::GaussIntegrator::fUsedOnceBool value to check if the function was at least called once.; double*fWWeights of the points used.; double*fXAbscisa of the points used.; static boolROOT::Math::GaussIntegrator::fgAbsValueAbsValue used for the calculation of the integral. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GaussLegendreIntegrator(int num = 10, double eps = 1e-12); Basic contructor of GaussLegendreIntegrator.; \@param num Number of desired points to calculate the integration.; \@param eps Desired relative error. virtual ~GaussLegendreIntegrator(); Default Destructor . void SetNumber",MatchSource.WIKI,root/html534/ROOT__Math__GaussLegendreIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GaussLegendreIntegrator.html
https://root.cern/root/html534/ROOT__Math__GaussLegendreIntegrator.html:3531,Availability,error,error,3531,"d:. doubleROOT::Math::GaussIntegrator::fEpsAbsAbsolute error.; doubleROOT::Math::GaussIntegrator::fEpsRelRelative error.; const ROOT::Math::IGenFunction*ROOT::Math::GaussIntegrator::fFunctionPointer to function used.; doubleROOT::Math::GaussIntegrator::fLastErrorError from the last stimation.; doubleROOT::Math::GaussIntegrator::fLastResultResult from the last stimation.; intfNumNumber of points used in the stimation of the integral.; boolROOT::Math::GaussIntegrator::fUsedOnceBool value to check if the function was at least called once.; double*fWWeights of the points used.; double*fXAbscisa of the points used.; static boolROOT::Math::GaussIntegrator::fgAbsValueAbsValue used for the calculation of the integral. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GaussLegendreIntegrator(int num = 10, double eps = 1e-12); Basic contructor of GaussLegendreIntegrator.; \@param num Number of desired points to calculate the integration.; \@param eps Desired relative error. virtual ~GaussLegendreIntegrator(); Default Destructor . void SetNumberPoints(int num); Set the number of points used in the calculation of the; integral . void SetRelTolerance(double ); Set the desired relative Error. . void SetAbsTolerance(double ); This method is not implemented. . void GetWeightVectors(double* x, double* w) const; Returns the arrays x and w containing the abscissa and weight of; the Gauss-Legendre n-point quadrature formula. Gauss-Legendre: W(x)=1 -1<x<1; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}. int GetNumberPoints() const; { return fNum; }. int NEval() const. return number of function evaluations in calculating the integral; This is equivalent to the number of points. { return fNum; }. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. double DoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Integration surrugate method. Return integral of passed function in interval [a,b]; Reimplement method of Gaus",MatchSource.WIKI,root/html534/ROOT__Math__GaussLegendreIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GaussLegendreIntegrator.html
https://root.cern/root/html534/ROOT__Math__GaussLegendreIntegrator.html:401,Deployability,integrat,integration,401,". ROOT::Math::GaussLegendreIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::GaussLegendreIntegrator. class ROOT::Math::GaussLegendreIntegrator: public ROOT::Math::GaussIntegrator. User class for performing function integration. It will use the Gauss-Legendre Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. Function Members (Methods); public:. virtual~GaussLegendreIntegrator(); voidROOT::Math::GaussIntegrator::AbsValue(bool flag); virtual doubleROOT::Math::GaussIntegrator::Error() const; ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(const ROOT::Math::GaussIntegrator&); ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(double absTol = 0, double relTol = 0); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(const ROOT::Math::GaussLegendreIntegrator&); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(int num = 10, double eps = 1e-12); intGetNumberPoints() const; voidGetWeightVectors(double* x, double* w) const; virtual doubleROOT::Math::GaussIntegrator::Integral(); virtual doubleROOT::Math::GaussIntegrator::Integral(const vector<double>& pts); virtual doubleROOT::Math::GaussIntegrator::Integral(double a, double b); virtual doubleROOT::Math::GaussIntegrator::IntegralCauchy(double a, double b, double c); virtual doubleROOT::Math::GaussIntegrator::IntegralLow(double b); virtual doubleROOT::Math::GaussIntegrator::IntegralUp(double a); virtual intNEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleROOT::Math::GaussIntegrator::Result() const; virtual voidSetAbsTolerance(double); virtual voidRO",MatchSource.WIKI,root/html534/ROOT__Math__GaussLegendreIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GaussLegendreIntegrator.html
https://root.cern/root/html534/ROOT__Math__GaussLegendreIntegrator.html:465,Deployability,integrat,integration,465,". ROOT::Math::GaussLegendreIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::GaussLegendreIntegrator. class ROOT::Math::GaussLegendreIntegrator: public ROOT::Math::GaussIntegrator. User class for performing function integration. It will use the Gauss-Legendre Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. Function Members (Methods); public:. virtual~GaussLegendreIntegrator(); voidROOT::Math::GaussIntegrator::AbsValue(bool flag); virtual doubleROOT::Math::GaussIntegrator::Error() const; ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(const ROOT::Math::GaussIntegrator&); ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(double absTol = 0, double relTol = 0); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(const ROOT::Math::GaussLegendreIntegrator&); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(int num = 10, double eps = 1e-12); intGetNumberPoints() const; voidGetWeightVectors(double* x, double* w) const; virtual doubleROOT::Math::GaussIntegrator::Integral(); virtual doubleROOT::Math::GaussIntegrator::Integral(const vector<double>& pts); virtual doubleROOT::Math::GaussIntegrator::Integral(double a, double b); virtual doubleROOT::Math::GaussIntegrator::IntegralCauchy(double a, double b, double c); virtual doubleROOT::Math::GaussIntegrator::IntegralLow(double b); virtual doubleROOT::Math::GaussIntegrator::IntegralUp(double a); virtual intNEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleROOT::Math::GaussIntegrator::Result() const; virtual voidSetAbsTolerance(double); virtual voidRO",MatchSource.WIKI,root/html534/ROOT__Math__GaussLegendreIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GaussLegendreIntegrator.html
https://root.cern/root/html534/ROOT__Math__GaussLegendreIntegrator.html:3488,Deployability,integrat,integration,3488,"T::Math::IGenFunction* func). Data Members; protected:. doubleROOT::Math::GaussIntegrator::fEpsAbsAbsolute error.; doubleROOT::Math::GaussIntegrator::fEpsRelRelative error.; const ROOT::Math::IGenFunction*ROOT::Math::GaussIntegrator::fFunctionPointer to function used.; doubleROOT::Math::GaussIntegrator::fLastErrorError from the last stimation.; doubleROOT::Math::GaussIntegrator::fLastResultResult from the last stimation.; intfNumNumber of points used in the stimation of the integral.; boolROOT::Math::GaussIntegrator::fUsedOnceBool value to check if the function was at least called once.; double*fWWeights of the points used.; double*fXAbscisa of the points used.; static boolROOT::Math::GaussIntegrator::fgAbsValueAbsValue used for the calculation of the integral. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GaussLegendreIntegrator(int num = 10, double eps = 1e-12); Basic contructor of GaussLegendreIntegrator.; \@param num Number of desired points to calculate the integration.; \@param eps Desired relative error. virtual ~GaussLegendreIntegrator(); Default Destructor . void SetNumberPoints(int num); Set the number of points used in the calculation of the; integral . void SetRelTolerance(double ); Set the desired relative Error. . void SetAbsTolerance(double ); This method is not implemented. . void GetWeightVectors(double* x, double* w) const; Returns the arrays x and w containing the abscissa and weight of; the Gauss-Legendre n-point quadrature formula. Gauss-Legendre: W(x)=1 -1<x<1; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}. int GetNumberPoints() const; { return fNum; }. int NEval() const. return number of function evaluations in calculating the integral; This is equivalent to the number of points. { return fNum; }. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. double DoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Integration surrugate method. Return integral of passed f",MatchSource.WIKI,root/html534/ROOT__Math__GaussLegendreIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GaussLegendreIntegrator.html
https://root.cern/root/html534/ROOT__Math__GaussLegendreIntegrator.html:401,Integrability,integrat,integration,401,". ROOT::Math::GaussLegendreIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::GaussLegendreIntegrator. class ROOT::Math::GaussLegendreIntegrator: public ROOT::Math::GaussIntegrator. User class for performing function integration. It will use the Gauss-Legendre Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. Function Members (Methods); public:. virtual~GaussLegendreIntegrator(); voidROOT::Math::GaussIntegrator::AbsValue(bool flag); virtual doubleROOT::Math::GaussIntegrator::Error() const; ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(const ROOT::Math::GaussIntegrator&); ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(double absTol = 0, double relTol = 0); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(const ROOT::Math::GaussLegendreIntegrator&); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(int num = 10, double eps = 1e-12); intGetNumberPoints() const; voidGetWeightVectors(double* x, double* w) const; virtual doubleROOT::Math::GaussIntegrator::Integral(); virtual doubleROOT::Math::GaussIntegrator::Integral(const vector<double>& pts); virtual doubleROOT::Math::GaussIntegrator::Integral(double a, double b); virtual doubleROOT::Math::GaussIntegrator::IntegralCauchy(double a, double b, double c); virtual doubleROOT::Math::GaussIntegrator::IntegralLow(double b); virtual doubleROOT::Math::GaussIntegrator::IntegralUp(double a); virtual intNEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleROOT::Math::GaussIntegrator::Result() const; virtual voidSetAbsTolerance(double); virtual voidRO",MatchSource.WIKI,root/html534/ROOT__Math__GaussLegendreIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GaussLegendreIntegrator.html
https://root.cern/root/html534/ROOT__Math__GaussLegendreIntegrator.html:465,Integrability,integrat,integration,465,". ROOT::Math::GaussLegendreIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::GaussLegendreIntegrator. class ROOT::Math::GaussLegendreIntegrator: public ROOT::Math::GaussIntegrator. User class for performing function integration. It will use the Gauss-Legendre Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. Function Members (Methods); public:. virtual~GaussLegendreIntegrator(); voidROOT::Math::GaussIntegrator::AbsValue(bool flag); virtual doubleROOT::Math::GaussIntegrator::Error() const; ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(const ROOT::Math::GaussIntegrator&); ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(double absTol = 0, double relTol = 0); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(const ROOT::Math::GaussLegendreIntegrator&); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(int num = 10, double eps = 1e-12); intGetNumberPoints() const; voidGetWeightVectors(double* x, double* w) const; virtual doubleROOT::Math::GaussIntegrator::Integral(); virtual doubleROOT::Math::GaussIntegrator::Integral(const vector<double>& pts); virtual doubleROOT::Math::GaussIntegrator::Integral(double a, double b); virtual doubleROOT::Math::GaussIntegrator::IntegralCauchy(double a, double b, double c); virtual doubleROOT::Math::GaussIntegrator::IntegralLow(double b); virtual doubleROOT::Math::GaussIntegrator::IntegralUp(double a); virtual intNEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleROOT::Math::GaussIntegrator::Result() const; virtual voidSetAbsTolerance(double); virtual voidRO",MatchSource.WIKI,root/html534/ROOT__Math__GaussLegendreIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GaussLegendreIntegrator.html
https://root.cern/root/html534/ROOT__Math__GaussLegendreIntegrator.html:3488,Integrability,integrat,integration,3488,"T::Math::IGenFunction* func). Data Members; protected:. doubleROOT::Math::GaussIntegrator::fEpsAbsAbsolute error.; doubleROOT::Math::GaussIntegrator::fEpsRelRelative error.; const ROOT::Math::IGenFunction*ROOT::Math::GaussIntegrator::fFunctionPointer to function used.; doubleROOT::Math::GaussIntegrator::fLastErrorError from the last stimation.; doubleROOT::Math::GaussIntegrator::fLastResultResult from the last stimation.; intfNumNumber of points used in the stimation of the integral.; boolROOT::Math::GaussIntegrator::fUsedOnceBool value to check if the function was at least called once.; double*fWWeights of the points used.; double*fXAbscisa of the points used.; static boolROOT::Math::GaussIntegrator::fgAbsValueAbsValue used for the calculation of the integral. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GaussLegendreIntegrator(int num = 10, double eps = 1e-12); Basic contructor of GaussLegendreIntegrator.; \@param num Number of desired points to calculate the integration.; \@param eps Desired relative error. virtual ~GaussLegendreIntegrator(); Default Destructor . void SetNumberPoints(int num); Set the number of points used in the calculation of the; integral . void SetRelTolerance(double ); Set the desired relative Error. . void SetAbsTolerance(double ); This method is not implemented. . void GetWeightVectors(double* x, double* w) const; Returns the arrays x and w containing the abscissa and weight of; the Gauss-Legendre n-point quadrature formula. Gauss-Legendre: W(x)=1 -1<x<1; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}. int GetNumberPoints() const; { return fNum; }. int NEval() const. return number of function evaluations in calculating the integral; This is equivalent to the number of points. { return fNum; }. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. double DoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Integration surrugate method. Return integral of passed f",MatchSource.WIKI,root/html534/ROOT__Math__GaussLegendreIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GaussLegendreIntegrator.html
https://root.cern/root/html534/ROOT__Math__GaussLegendreIntegrator.html:4632,Integrability,interface,interface,4632,"r(int num = 10, double eps = 1e-12); Basic contructor of GaussLegendreIntegrator.; \@param num Number of desired points to calculate the integration.; \@param eps Desired relative error. virtual ~GaussLegendreIntegrator(); Default Destructor . void SetNumberPoints(int num); Set the number of points used in the calculation of the; integral . void SetRelTolerance(double ); Set the desired relative Error. . void SetAbsTolerance(double ); This method is not implemented. . void GetWeightVectors(double* x, double* w) const; Returns the arrays x and w containing the abscissa and weight of; the Gauss-Legendre n-point quadrature formula. Gauss-Legendre: W(x)=1 -1<x<1; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}. int GetNumberPoints() const; { return fNum; }. int NEval() const. return number of function evaluations in calculating the integral; This is equivalent to the number of points. { return fNum; }. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. double DoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Integration surrugate method. Return integral of passed function in interval [a,b]; Reimplement method of GaussIntegrator using CalcGaussLegendreSamplingPoints. void CalcGaussLegendreSamplingPoints(). Type: unsafe but fast interface filling the arrays x and w (static method). Given the number of sampling points this routine fills the arrays x and w; of length num, containing the abscissa and weight of the Gauss-Legendre; n-point quadrature formula. Gauss-Legendre: W(x)=1 -1<x<1; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}. num is the number of sampling points (>0); x and w are arrays of size num; eps is the relative precision. If num<=0 or eps<=0 no action is done. Reference: Numerical Recipes in C, Second Edition.  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__GaussLegendreIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GaussLegendreIntegrator.html
https://root.cern/root/html534/ROOT__Math__GaussLegendreIntegrator.html:4727,Integrability,rout,routine,4727,"r(int num = 10, double eps = 1e-12); Basic contructor of GaussLegendreIntegrator.; \@param num Number of desired points to calculate the integration.; \@param eps Desired relative error. virtual ~GaussLegendreIntegrator(); Default Destructor . void SetNumberPoints(int num); Set the number of points used in the calculation of the; integral . void SetRelTolerance(double ); Set the desired relative Error. . void SetAbsTolerance(double ); This method is not implemented. . void GetWeightVectors(double* x, double* w) const; Returns the arrays x and w containing the abscissa and weight of; the Gauss-Legendre n-point quadrature formula. Gauss-Legendre: W(x)=1 -1<x<1; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}. int GetNumberPoints() const; { return fNum; }. int NEval() const. return number of function evaluations in calculating the integral; This is equivalent to the number of points. { return fNum; }. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. double DoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Integration surrugate method. Return integral of passed function in interval [a,b]; Reimplement method of GaussIntegrator using CalcGaussLegendreSamplingPoints. void CalcGaussLegendreSamplingPoints(). Type: unsafe but fast interface filling the arrays x and w (static method). Given the number of sampling points this routine fills the arrays x and w; of length num, containing the abscissa and weight of the Gauss-Legendre; n-point quadrature formula. Gauss-Legendre: W(x)=1 -1<x<1; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}. num is the number of sampling points (>0); x and w are arrays of size num; eps is the relative precision. If num<=0 or eps<=0 no action is done. Reference: Numerical Recipes in C, Second Edition.  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__GaussLegendreIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GaussLegendreIntegrator.html
https://root.cern/root/html534/ROOT__Math__GaussLegendreIntegrator.html:381,Performance,perform,performing,381,". ROOT::Math::GaussLegendreIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::GaussLegendreIntegrator. class ROOT::Math::GaussLegendreIntegrator: public ROOT::Math::GaussIntegrator. User class for performing function integration. It will use the Gauss-Legendre Method for function integration in a given interval.; This class is implemented from TF1::Integral(). @ingroup Integration. Function Members (Methods); public:. virtual~GaussLegendreIntegrator(); voidROOT::Math::GaussIntegrator::AbsValue(bool flag); virtual doubleROOT::Math::GaussIntegrator::Error() const; ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(const ROOT::Math::GaussIntegrator&); ROOT::Math::GaussIntegratorROOT::Math::GaussIntegrator::GaussIntegrator(double absTol = 0, double relTol = 0); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(const ROOT::Math::GaussLegendreIntegrator&); ROOT::Math::GaussLegendreIntegratorGaussLegendreIntegrator(int num = 10, double eps = 1e-12); intGetNumberPoints() const; voidGetWeightVectors(double* x, double* w) const; virtual doubleROOT::Math::GaussIntegrator::Integral(); virtual doubleROOT::Math::GaussIntegrator::Integral(const vector<double>& pts); virtual doubleROOT::Math::GaussIntegrator::Integral(double a, double b); virtual doubleROOT::Math::GaussIntegrator::IntegralCauchy(double a, double b, double c); virtual doubleROOT::Math::GaussIntegrator::IntegralLow(double b); virtual doubleROOT::Math::GaussIntegrator::IntegralUp(double a); virtual intNEval() const; ROOT::Math::VirtualIntegratorOneDim&ROOT::Math::VirtualIntegratorOneDim::operator=(const ROOT::Math::VirtualIntegratorOneDim&); virtual ROOT::Math::IntegratorOneDimOptionsOptions() const; virtual doubleROOT::Math::GaussIntegrator::Result() const; virtual voidSetAbsTolerance(double); virtual voidRO",MatchSource.WIKI,root/html534/ROOT__Math__GaussLegendreIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GaussLegendreIntegrator.html
https://root.cern/root/html534/ROOT__Math__GaussLegendreIntegrator.html:4616,Safety,unsafe,unsafe,4616,"r(int num = 10, double eps = 1e-12); Basic contructor of GaussLegendreIntegrator.; \@param num Number of desired points to calculate the integration.; \@param eps Desired relative error. virtual ~GaussLegendreIntegrator(); Default Destructor . void SetNumberPoints(int num); Set the number of points used in the calculation of the; integral . void SetRelTolerance(double ); Set the desired relative Error. . void SetAbsTolerance(double ); This method is not implemented. . void GetWeightVectors(double* x, double* w) const; Returns the arrays x and w containing the abscissa and weight of; the Gauss-Legendre n-point quadrature formula. Gauss-Legendre: W(x)=1 -1<x<1; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}. int GetNumberPoints() const; { return fNum; }. int NEval() const. return number of function evaluations in calculating the integral; This is equivalent to the number of points. { return fNum; }. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. double DoIntegral(double a, double b, const ROOT::Math::IGenFunction* func). Integration surrugate method. Return integral of passed function in interval [a,b]; Reimplement method of GaussIntegrator using CalcGaussLegendreSamplingPoints. void CalcGaussLegendreSamplingPoints(). Type: unsafe but fast interface filling the arrays x and w (static method). Given the number of sampling points this routine fills the arrays x and w; of length num, containing the abscissa and weight of the Gauss-Legendre; n-point quadrature formula. Gauss-Legendre: W(x)=1 -1<x<1; (j+1)P_{j+1} = (2j+1)xP_j-jP_{j-1}. num is the number of sampling points (>0); x and w are arrays of size num; eps is the relative precision. If num<=0 or eps<=0 no action is done. Reference: Numerical Recipes in C, Second Edition.  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__GaussLegendreIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GaussLegendreIntegrator.html
https://root.cern/root/html534/ROOT__Math__GenAlgoOptions.html:2226,Integrability,interface,interface,2226,"erator=(const ROOT::Math::GenAlgoOptions&); virtual voidPrint(ostream& os = std::cout) const; static voidPrintAllDefault(ostream& os = std::cout); doubleROOT::Math::IOptions::RValue(const char* name) const; virtual voidSetIntValue(const char* name, int val); virtual voidSetNamedValue(const char* name, const char* val); virtual voidSetRealValue(const char* name, double val); voidROOT::Math::IOptions::SetValue(const char* name, double val); voidROOT::Math::IOptions::SetValue(const char* name, int val); voidROOT::Math::IOptions::SetValue(const char* name, const char* val). Data Members; private:. map<std::string,int>fIntOptsmap of the integer options ; map<std::string,std::string>fNamOptsmap of the named options; map<std::string,double>fRealOptsmap of the real options . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GenAlgoOptions(); {}. virtual ~GenAlgoOptions(). IOptions * Clone() const; use default copy constructor and assignment operator; generic methods for retrivieng options ; methods implementing the IOptions interface. return new GenAlgoOptions(const ROOT::Math::GenAlgoOptions& ). bool GetRealValue(const char* name, double& val) const; t.b.d need probably to implement in a .cxx file for CINT. bool GetIntValue(const char* name, int& val) const. bool GetNamedValue(const char* name, string& val) const. void SetRealValue(const char* name, double val); method wich need to be re-implemented by the derived classes. void SetIntValue(const char* name, int val). void SetNamedValue(const char* name, const char* val). void Print(ostream& os = std::cout) const; print options. IOptions * FindDefault(const char* algoname); static methods to retrieve the default options; find the option given a name; return 0 if the option is not found. IOptions & Default(const char* algoname); retrieve options given the name; if option is not found create a new GenAlgoOption for the given name. void PrintAllDefault(ostream& os = std::cout); print al",MatchSource.WIKI,root/html534/ROOT__Math__GenAlgoOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GenAlgoOptions.html
https://root.cern/root/html534/ROOT__Math__GeneticMinimizer.html:5235,Availability,error,errors,5235,"Limit(unsigned int ivar, double lower); virtual boolROOT::Math::Minimizer::SetVariableStepSize(unsigned int ivar, double value); virtual boolROOT::Math::Minimizer::SetVariableUpperLimit(unsigned int ivar, double upper); virtual boolROOT::Math::Minimizer::SetVariableValue(unsigned int ivar, double value); virtual boolROOT::Math::Minimizer::SetVariableValues(const double* x); intROOT::Math::Minimizer::Status() const; intROOT::Math::Minimizer::Strategy() const; doubleROOT::Math::Minimizer::Tolerance() const; virtual intROOT::Math::Minimizer::VariableIndex(const string& name) const; virtual stringROOT::Math::Minimizer::VariableName(unsigned int ivar) const; virtual const double*X() const. protected:. voidGetGeneticOptions(ROOT::Math::MinimizerOptions& opt) const. Data Members; protected:. TMVA::IFitterTarget*fFitness; doublefMinValue; ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::fOptionsminimizer options; ROOT::Math::GeneticMinimizerParametersfParameters; vector<TMVA::Interval*>fRanges; vector<double>fResult; intROOT::Math::Minimizer::fStatusstatus of minimizer ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GeneticMinimizer(int i = 0); GeneticMinimizer (int = 0);. virtual ~GeneticMinimizer(). void Clear(). void SetFunction(const ROOT::Math::IMultiGenFunction& func). bool SetLimitedVariable(unsigned int , const string& , double , double , double , double ). bool SetVariable(unsigned int ivar, const string& name, double val, double step). bool SetFixedVariable(unsigned int ivar, const string& name, double val). bool Minimize(). double MinValue() const. double Edm() const. const double * X() const. const double * MinGradient() const. unsigned int NCalls() const. unsigned int NDim() const. unsigned int NFree() const. bool ProvidesError() const. const double * Errors() const. double CovMatrix(unsigned ",MatchSource.WIKI,root/html534/ROOT__Math__GeneticMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GeneticMinimizer.html
https://root.cern/root/html534/ROOT__Math__GeneticMinimizer.html:5252,Security,validat,validated,5252,"Limit(unsigned int ivar, double lower); virtual boolROOT::Math::Minimizer::SetVariableStepSize(unsigned int ivar, double value); virtual boolROOT::Math::Minimizer::SetVariableUpperLimit(unsigned int ivar, double upper); virtual boolROOT::Math::Minimizer::SetVariableValue(unsigned int ivar, double value); virtual boolROOT::Math::Minimizer::SetVariableValues(const double* x); intROOT::Math::Minimizer::Status() const; intROOT::Math::Minimizer::Strategy() const; doubleROOT::Math::Minimizer::Tolerance() const; virtual intROOT::Math::Minimizer::VariableIndex(const string& name) const; virtual stringROOT::Math::Minimizer::VariableName(unsigned int ivar) const; virtual const double*X() const. protected:. voidGetGeneticOptions(ROOT::Math::MinimizerOptions& opt) const. Data Members; protected:. TMVA::IFitterTarget*fFitness; doublefMinValue; ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::fOptionsminimizer options; ROOT::Math::GeneticMinimizerParametersfParameters; vector<TMVA::Interval*>fRanges; vector<double>fResult; intROOT::Math::Minimizer::fStatusstatus of minimizer ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GeneticMinimizer(int i = 0); GeneticMinimizer (int = 0);. virtual ~GeneticMinimizer(). void Clear(). void SetFunction(const ROOT::Math::IMultiGenFunction& func). bool SetLimitedVariable(unsigned int , const string& , double , double , double , double ). bool SetVariable(unsigned int ivar, const string& name, double val, double step). bool SetFixedVariable(unsigned int ivar, const string& name, double val). bool Minimize(). double MinValue() const. double Edm() const. const double * X() const. const double * MinGradient() const. unsigned int NCalls() const. unsigned int NDim() const. unsigned int NFree() const. bool ProvidesError() const. const double * Errors() const. double CovMatrix(unsigned ",MatchSource.WIKI,root/html534/ROOT__Math__GeneticMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GeneticMinimizer.html
https://root.cern/root/html534/ROOT__Math__GoFTest.html:4298,Integrability,interface,interface,4298,"Math::GoFTest::EDistributionfDist; Double_tfMean; vector<std::vector<Double_t> >fSamples; Double_tfSigma; Bool_tfTestSampleFromH0. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GoFTest(UInt_t sample1Size, const Double_t* sample1, UInt_t sample2Size, const Double_t* sample2); Constructor for using only with 2-samples tests. GoFTest(UInt_t sampleSize, const Double_t* sample, ROOT::Math::GoFTest::EDistribution dist = kUndefined); Constructor for using only with 1-sample tests with a specified distribution. GoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Templated constructor for using only with 1-sample tests with a user specified distribution. Instantiate(const Double_t* sample, UInt_t sampleSize). GoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Specialization using IGenFunction interface. SetUserDistribution(const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0). SetDistributionFunction(const ROOT::Math::IGenFunction& cdf, Bool_t isPDF, Double_t xmin, Double_t xmax). void SetUserPDF(const ROOT::Math::IGenFunction& pdf, Double_t xmin = 1, Double_t xmax = 0); Sets the user input distribution as a probability density function for 1-sample tests. void SetUserCDF(const ROOT::Math::IGenFunction& cdf, Double_t xmin = 1, Double_t xmax = 0); Sets the user input distribution as a cumulative distribution function for 1-sample tests; The CDF must return zero. void SetDistribution(ROOT::Math::GoFTest::EDistribution dist); Sets the distribution for the predefined distribution types. virtual ~GoFTest(). Double_t AndersonDarling2SamplesTest(const Char_t* option = ""p"") const. The Anderson-Darling K",MatchSource.WIKI,root/html534/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GoFTest.html
https://root.cern/root/html534/ROOT__Math__GoFTest.html:469,Testability,test,testStat,469,"OOT::Math::GoFTest. class ROOT::Math::GoFTest. Function Members (Methods); public:. virtual~GoFTest(); Double_tAndersonDarling2SamplesTest(const Char_t* option = ""p"") const; voidAndersonDarling2SamplesTest(Double_t& pvalue, Double_t& testStat) const; static voidAndersonDarling2SamplesTest(const ROOT::Fit::BinData& data1, const ROOT::Fit::BinData& data2, Double_t& pvalue, Double_t& testStat); Double_tAndersonDarlingTest(const Char_t* option = ""p"") const; voidAndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const; ROOT::Math::GoFTestGoFTest(UInt_t sampleSize, const Double_t* sample, ROOT::Math::GoFTest::EDistribution dist = kUndefined); ROOT::Math::GoFTestGoFTest(UInt_t sample1Size, const Double_t* sample1, UInt_t sample2Size, const Double_t* sample2); ROOT::Math::GoFTestGoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Double_tKolmogorovSmirnov2SamplesTest(const Char_t* option = ""p"") const; voidKolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const; Double_tKolmogorovSmirnovTest(const Char_t* option = ""p"") const; voidKolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const; Double_toperator()(ROOT::Math::GoFTest::ETestType test = kAD, const Char_t* option = ""p"") const; voidoperator()(ROOT::Math::GoFTest::ETestType test, Double_t& pvalue, Double_t& testStat) const; static Double_tPValueADKSamples(UInt_t nsamples, Double_t A2); voidSetDistribution(ROOT::Math::GoFTest::EDistribution dist); voidSetUserCDF(const ROOT::Math::IGenFunction& cdf, Double_t xmin = 1, Double_t xmax = 0); voidSetUserDistribution(const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); voidSetUserPDF(const ROOT::Math::IGenFunction& pdf, Double_t xmin = 1, Double_t xmax = 0). private:. Double_tExponentialCDF(Double_t x) const; Double_tGaussianCDF(Double_t x",MatchSource.WIKI,root/html534/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GoFTest.html
https://root.cern/root/html534/ROOT__Math__GoFTest.html:619,Testability,test,testStat,619,"OOT::Math::GoFTest. class ROOT::Math::GoFTest. Function Members (Methods); public:. virtual~GoFTest(); Double_tAndersonDarling2SamplesTest(const Char_t* option = ""p"") const; voidAndersonDarling2SamplesTest(Double_t& pvalue, Double_t& testStat) const; static voidAndersonDarling2SamplesTest(const ROOT::Fit::BinData& data1, const ROOT::Fit::BinData& data2, Double_t& pvalue, Double_t& testStat); Double_tAndersonDarlingTest(const Char_t* option = ""p"") const; voidAndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const; ROOT::Math::GoFTestGoFTest(UInt_t sampleSize, const Double_t* sample, ROOT::Math::GoFTest::EDistribution dist = kUndefined); ROOT::Math::GoFTestGoFTest(UInt_t sample1Size, const Double_t* sample1, UInt_t sample2Size, const Double_t* sample2); ROOT::Math::GoFTestGoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Double_tKolmogorovSmirnov2SamplesTest(const Char_t* option = ""p"") const; voidKolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const; Double_tKolmogorovSmirnovTest(const Char_t* option = ""p"") const; voidKolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const; Double_toperator()(ROOT::Math::GoFTest::ETestType test = kAD, const Char_t* option = ""p"") const; voidoperator()(ROOT::Math::GoFTest::ETestType test, Double_t& pvalue, Double_t& testStat) const; static Double_tPValueADKSamples(UInt_t nsamples, Double_t A2); voidSetDistribution(ROOT::Math::GoFTest::EDistribution dist); voidSetUserCDF(const ROOT::Math::IGenFunction& cdf, Double_t xmin = 1, Double_t xmax = 0); voidSetUserDistribution(const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); voidSetUserPDF(const ROOT::Math::IGenFunction& pdf, Double_t xmin = 1, Double_t xmax = 0). private:. Double_tExponentialCDF(Double_t x) const; Double_tGaussianCDF(Double_t x",MatchSource.WIKI,root/html534/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GoFTest.html
https://root.cern/root/html534/ROOT__Math__GoFTest.html:745,Testability,test,testStat,745,"OOT::Math::GoFTest. class ROOT::Math::GoFTest. Function Members (Methods); public:. virtual~GoFTest(); Double_tAndersonDarling2SamplesTest(const Char_t* option = ""p"") const; voidAndersonDarling2SamplesTest(Double_t& pvalue, Double_t& testStat) const; static voidAndersonDarling2SamplesTest(const ROOT::Fit::BinData& data1, const ROOT::Fit::BinData& data2, Double_t& pvalue, Double_t& testStat); Double_tAndersonDarlingTest(const Char_t* option = ""p"") const; voidAndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const; ROOT::Math::GoFTestGoFTest(UInt_t sampleSize, const Double_t* sample, ROOT::Math::GoFTest::EDistribution dist = kUndefined); ROOT::Math::GoFTestGoFTest(UInt_t sample1Size, const Double_t* sample1, UInt_t sample2Size, const Double_t* sample2); ROOT::Math::GoFTestGoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Double_tKolmogorovSmirnov2SamplesTest(const Char_t* option = ""p"") const; voidKolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const; Double_tKolmogorovSmirnovTest(const Char_t* option = ""p"") const; voidKolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const; Double_toperator()(ROOT::Math::GoFTest::ETestType test = kAD, const Char_t* option = ""p"") const; voidoperator()(ROOT::Math::GoFTest::ETestType test, Double_t& pvalue, Double_t& testStat) const; static Double_tPValueADKSamples(UInt_t nsamples, Double_t A2); voidSetDistribution(ROOT::Math::GoFTest::EDistribution dist); voidSetUserCDF(const ROOT::Math::IGenFunction& cdf, Double_t xmin = 1, Double_t xmax = 0); voidSetUserDistribution(const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); voidSetUserPDF(const ROOT::Math::IGenFunction& pdf, Double_t xmin = 1, Double_t xmax = 0). private:. Double_tExponentialCDF(Double_t x) const; Double_tGaussianCDF(Double_t x",MatchSource.WIKI,root/html534/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GoFTest.html
https://root.cern/root/html534/ROOT__Math__GoFTest.html:1343,Testability,test,testStat,1343,"OOT::Math::GoFTest. class ROOT::Math::GoFTest. Function Members (Methods); public:. virtual~GoFTest(); Double_tAndersonDarling2SamplesTest(const Char_t* option = ""p"") const; voidAndersonDarling2SamplesTest(Double_t& pvalue, Double_t& testStat) const; static voidAndersonDarling2SamplesTest(const ROOT::Fit::BinData& data1, const ROOT::Fit::BinData& data2, Double_t& pvalue, Double_t& testStat); Double_tAndersonDarlingTest(const Char_t* option = ""p"") const; voidAndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const; ROOT::Math::GoFTestGoFTest(UInt_t sampleSize, const Double_t* sample, ROOT::Math::GoFTest::EDistribution dist = kUndefined); ROOT::Math::GoFTestGoFTest(UInt_t sample1Size, const Double_t* sample1, UInt_t sample2Size, const Double_t* sample2); ROOT::Math::GoFTestGoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Double_tKolmogorovSmirnov2SamplesTest(const Char_t* option = ""p"") const; voidKolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const; Double_tKolmogorovSmirnovTest(const Char_t* option = ""p"") const; voidKolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const; Double_toperator()(ROOT::Math::GoFTest::ETestType test = kAD, const Char_t* option = ""p"") const; voidoperator()(ROOT::Math::GoFTest::ETestType test, Double_t& pvalue, Double_t& testStat) const; static Double_tPValueADKSamples(UInt_t nsamples, Double_t A2); voidSetDistribution(ROOT::Math::GoFTest::EDistribution dist); voidSetUserCDF(const ROOT::Math::IGenFunction& cdf, Double_t xmin = 1, Double_t xmax = 0); voidSetUserDistribution(const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); voidSetUserPDF(const ROOT::Math::IGenFunction& pdf, Double_t xmin = 1, Double_t xmax = 0). private:. Double_tExponentialCDF(Double_t x) const; Double_tGaussianCDF(Double_t x",MatchSource.WIKI,root/html534/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GoFTest.html
https://root.cern/root/html534/ROOT__Math__GoFTest.html:1479,Testability,test,testStat,1479,"OOT::Math::GoFTest. class ROOT::Math::GoFTest. Function Members (Methods); public:. virtual~GoFTest(); Double_tAndersonDarling2SamplesTest(const Char_t* option = ""p"") const; voidAndersonDarling2SamplesTest(Double_t& pvalue, Double_t& testStat) const; static voidAndersonDarling2SamplesTest(const ROOT::Fit::BinData& data1, const ROOT::Fit::BinData& data2, Double_t& pvalue, Double_t& testStat); Double_tAndersonDarlingTest(const Char_t* option = ""p"") const; voidAndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const; ROOT::Math::GoFTestGoFTest(UInt_t sampleSize, const Double_t* sample, ROOT::Math::GoFTest::EDistribution dist = kUndefined); ROOT::Math::GoFTestGoFTest(UInt_t sample1Size, const Double_t* sample1, UInt_t sample2Size, const Double_t* sample2); ROOT::Math::GoFTestGoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Double_tKolmogorovSmirnov2SamplesTest(const Char_t* option = ""p"") const; voidKolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const; Double_tKolmogorovSmirnovTest(const Char_t* option = ""p"") const; voidKolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const; Double_toperator()(ROOT::Math::GoFTest::ETestType test = kAD, const Char_t* option = ""p"") const; voidoperator()(ROOT::Math::GoFTest::ETestType test, Double_t& pvalue, Double_t& testStat) const; static Double_tPValueADKSamples(UInt_t nsamples, Double_t A2); voidSetDistribution(ROOT::Math::GoFTest::EDistribution dist); voidSetUserCDF(const ROOT::Math::IGenFunction& cdf, Double_t xmin = 1, Double_t xmax = 0); voidSetUserDistribution(const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); voidSetUserPDF(const ROOT::Math::IGenFunction& pdf, Double_t xmin = 1, Double_t xmax = 0). private:. Double_tExponentialCDF(Double_t x) const; Double_tGaussianCDF(Double_t x",MatchSource.WIKI,root/html534/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GoFTest.html
https://root.cern/root/html534/ROOT__Math__GoFTest.html:1546,Testability,test,test,1546,"OOT::Math::GoFTest. class ROOT::Math::GoFTest. Function Members (Methods); public:. virtual~GoFTest(); Double_tAndersonDarling2SamplesTest(const Char_t* option = ""p"") const; voidAndersonDarling2SamplesTest(Double_t& pvalue, Double_t& testStat) const; static voidAndersonDarling2SamplesTest(const ROOT::Fit::BinData& data1, const ROOT::Fit::BinData& data2, Double_t& pvalue, Double_t& testStat); Double_tAndersonDarlingTest(const Char_t* option = ""p"") const; voidAndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const; ROOT::Math::GoFTestGoFTest(UInt_t sampleSize, const Double_t* sample, ROOT::Math::GoFTest::EDistribution dist = kUndefined); ROOT::Math::GoFTestGoFTest(UInt_t sample1Size, const Double_t* sample1, UInt_t sample2Size, const Double_t* sample2); ROOT::Math::GoFTestGoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Double_tKolmogorovSmirnov2SamplesTest(const Char_t* option = ""p"") const; voidKolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const; Double_tKolmogorovSmirnovTest(const Char_t* option = ""p"") const; voidKolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const; Double_toperator()(ROOT::Math::GoFTest::ETestType test = kAD, const Char_t* option = ""p"") const; voidoperator()(ROOT::Math::GoFTest::ETestType test, Double_t& pvalue, Double_t& testStat) const; static Double_tPValueADKSamples(UInt_t nsamples, Double_t A2); voidSetDistribution(ROOT::Math::GoFTest::EDistribution dist); voidSetUserCDF(const ROOT::Math::IGenFunction& cdf, Double_t xmin = 1, Double_t xmax = 0); voidSetUserDistribution(const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); voidSetUserPDF(const ROOT::Math::IGenFunction& pdf, Double_t xmin = 1, Double_t xmax = 0). private:. Double_tExponentialCDF(Double_t x) const; Double_tGaussianCDF(Double_t x",MatchSource.WIKI,root/html534/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GoFTest.html
https://root.cern/root/html534/ROOT__Math__GoFTest.html:1639,Testability,test,test,1639,"OOT::Math::GoFTest. class ROOT::Math::GoFTest. Function Members (Methods); public:. virtual~GoFTest(); Double_tAndersonDarling2SamplesTest(const Char_t* option = ""p"") const; voidAndersonDarling2SamplesTest(Double_t& pvalue, Double_t& testStat) const; static voidAndersonDarling2SamplesTest(const ROOT::Fit::BinData& data1, const ROOT::Fit::BinData& data2, Double_t& pvalue, Double_t& testStat); Double_tAndersonDarlingTest(const Char_t* option = ""p"") const; voidAndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const; ROOT::Math::GoFTestGoFTest(UInt_t sampleSize, const Double_t* sample, ROOT::Math::GoFTest::EDistribution dist = kUndefined); ROOT::Math::GoFTestGoFTest(UInt_t sample1Size, const Double_t* sample1, UInt_t sample2Size, const Double_t* sample2); ROOT::Math::GoFTestGoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Double_tKolmogorovSmirnov2SamplesTest(const Char_t* option = ""p"") const; voidKolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const; Double_tKolmogorovSmirnovTest(const Char_t* option = ""p"") const; voidKolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const; Double_toperator()(ROOT::Math::GoFTest::ETestType test = kAD, const Char_t* option = ""p"") const; voidoperator()(ROOT::Math::GoFTest::ETestType test, Double_t& pvalue, Double_t& testStat) const; static Double_tPValueADKSamples(UInt_t nsamples, Double_t A2); voidSetDistribution(ROOT::Math::GoFTest::EDistribution dist); voidSetUserCDF(const ROOT::Math::IGenFunction& cdf, Double_t xmin = 1, Double_t xmax = 0); voidSetUserDistribution(const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); voidSetUserPDF(const ROOT::Math::IGenFunction& pdf, Double_t xmin = 1, Double_t xmax = 0). private:. Double_tExponentialCDF(Double_t x) const; Double_tGaussianCDF(Double_t x",MatchSource.WIKI,root/html534/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GoFTest.html
https://root.cern/root/html534/ROOT__Math__GoFTest.html:1673,Testability,test,testStat,1673,"OOT::Math::GoFTest. class ROOT::Math::GoFTest. Function Members (Methods); public:. virtual~GoFTest(); Double_tAndersonDarling2SamplesTest(const Char_t* option = ""p"") const; voidAndersonDarling2SamplesTest(Double_t& pvalue, Double_t& testStat) const; static voidAndersonDarling2SamplesTest(const ROOT::Fit::BinData& data1, const ROOT::Fit::BinData& data2, Double_t& pvalue, Double_t& testStat); Double_tAndersonDarlingTest(const Char_t* option = ""p"") const; voidAndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const; ROOT::Math::GoFTestGoFTest(UInt_t sampleSize, const Double_t* sample, ROOT::Math::GoFTest::EDistribution dist = kUndefined); ROOT::Math::GoFTestGoFTest(UInt_t sample1Size, const Double_t* sample1, UInt_t sample2Size, const Double_t* sample2); ROOT::Math::GoFTestGoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Double_tKolmogorovSmirnov2SamplesTest(const Char_t* option = ""p"") const; voidKolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const; Double_tKolmogorovSmirnovTest(const Char_t* option = ""p"") const; voidKolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const; Double_toperator()(ROOT::Math::GoFTest::ETestType test = kAD, const Char_t* option = ""p"") const; voidoperator()(ROOT::Math::GoFTest::ETestType test, Double_t& pvalue, Double_t& testStat) const; static Double_tPValueADKSamples(UInt_t nsamples, Double_t A2); voidSetDistribution(ROOT::Math::GoFTest::EDistribution dist); voidSetUserCDF(const ROOT::Math::IGenFunction& cdf, Double_t xmin = 1, Double_t xmax = 0); voidSetUserDistribution(const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); voidSetUserPDF(const ROOT::Math::IGenFunction& pdf, Double_t xmin = 1, Double_t xmax = 0). private:. Double_tExponentialCDF(Double_t x) const; Double_tGaussianCDF(Double_t x",MatchSource.WIKI,root/html534/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GoFTest.html
https://root.cern/root/html534/ROOT__Math__GoFTest.html:3556,Testability,test,tests,3556,"ePValues(int nsamples, Double_t A2); Double_tLogNormalCDF(Double_t x) const; voidLogSample(); ROOT::Math::GoFTestoperator=(ROOT::Math::GoFTest& gof); Double_tPValueAD1Sample(Double_t A2) const; voidSetCDF(); voidSetDistributionFunction(const ROOT::Math::IGenFunction& cdf, Bool_t isPDF, Double_t xmin, Double_t xmax); voidSetParameters(); voidSetSamples(vector<const Double_t*> samples, const vector<UInt_t> samplesSizes). Data Members; public:. enum EDistribution { kUndefined; kUserDefined; kGaussian; kLogNormal; kExponential; };; enum EUserDistribution { kCDF; kPDF; };; enum ETestType { kAD; kAD2s; kKS; kKS2s; };. private:. auto_ptr<ROOT::Math::IBaseFunctionOneDim>fCDF; vector<Double_t>fCombinedSamples; ROOT::Math::GoFTest::EDistributionfDist; Double_tfMean; vector<std::vector<Double_t> >fSamples; Double_tfSigma; Bool_tfTestSampleFromH0. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GoFTest(UInt_t sample1Size, const Double_t* sample1, UInt_t sample2Size, const Double_t* sample2); Constructor for using only with 2-samples tests. GoFTest(UInt_t sampleSize, const Double_t* sample, ROOT::Math::GoFTest::EDistribution dist = kUndefined); Constructor for using only with 1-sample tests with a specified distribution. GoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Templated constructor for using only with 1-sample tests with a user specified distribution. Instantiate(const Double_t* sample, UInt_t sampleSize). GoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Specialization using IGenFunction interface. SetUserDistribution(const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0). SetDistributio",MatchSource.WIKI,root/html534/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GoFTest.html
https://root.cern/root/html534/ROOT__Math__GoFTest.html:3710,Testability,test,tests,3710,"le_t A2) const; voidSetCDF(); voidSetDistributionFunction(const ROOT::Math::IGenFunction& cdf, Bool_t isPDF, Double_t xmin, Double_t xmax); voidSetParameters(); voidSetSamples(vector<const Double_t*> samples, const vector<UInt_t> samplesSizes). Data Members; public:. enum EDistribution { kUndefined; kUserDefined; kGaussian; kLogNormal; kExponential; };; enum EUserDistribution { kCDF; kPDF; };; enum ETestType { kAD; kAD2s; kKS; kKS2s; };. private:. auto_ptr<ROOT::Math::IBaseFunctionOneDim>fCDF; vector<Double_t>fCombinedSamples; ROOT::Math::GoFTest::EDistributionfDist; Double_tfMean; vector<std::vector<Double_t> >fSamples; Double_tfSigma; Bool_tfTestSampleFromH0. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GoFTest(UInt_t sample1Size, const Double_t* sample1, UInt_t sample2Size, const Double_t* sample2); Constructor for using only with 2-samples tests. GoFTest(UInt_t sampleSize, const Double_t* sample, ROOT::Math::GoFTest::EDistribution dist = kUndefined); Constructor for using only with 1-sample tests with a specified distribution. GoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Templated constructor for using only with 1-sample tests with a user specified distribution. Instantiate(const Double_t* sample, UInt_t sampleSize). GoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Specialization using IGenFunction interface. SetUserDistribution(const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0). SetDistributionFunction(const ROOT::Math::IGenFunction& cdf, Bool_t isPDF, Double_t xmin, Double_t xmax). void SetUserPDF(const ROOT::Math::IGenFunction& pdf, Double_t xmin = 1, Double_t xmax ",MatchSource.WIKI,root/html534/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GoFTest.html
https://root.cern/root/html534/ROOT__Math__GoFTest.html:3982,Testability,test,tests,3982,"samplesSizes). Data Members; public:. enum EDistribution { kUndefined; kUserDefined; kGaussian; kLogNormal; kExponential; };; enum EUserDistribution { kCDF; kPDF; };; enum ETestType { kAD; kAD2s; kKS; kKS2s; };. private:. auto_ptr<ROOT::Math::IBaseFunctionOneDim>fCDF; vector<Double_t>fCombinedSamples; ROOT::Math::GoFTest::EDistributionfDist; Double_tfMean; vector<std::vector<Double_t> >fSamples; Double_tfSigma; Bool_tfTestSampleFromH0. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GoFTest(UInt_t sample1Size, const Double_t* sample1, UInt_t sample2Size, const Double_t* sample2); Constructor for using only with 2-samples tests. GoFTest(UInt_t sampleSize, const Double_t* sample, ROOT::Math::GoFTest::EDistribution dist = kUndefined); Constructor for using only with 1-sample tests with a specified distribution. GoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Templated constructor for using only with 1-sample tests with a user specified distribution. Instantiate(const Double_t* sample, UInt_t sampleSize). GoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Specialization using IGenFunction interface. SetUserDistribution(const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0). SetDistributionFunction(const ROOT::Math::IGenFunction& cdf, Bool_t isPDF, Double_t xmin, Double_t xmax). void SetUserPDF(const ROOT::Math::IGenFunction& pdf, Double_t xmin = 1, Double_t xmax = 0); Sets the user input distribution as a probability density function for 1-sample tests. void SetUserCDF(const ROOT::Math::IGenFunction& cdf, Double_t xmin = 1, Double_t xmax = 0); Sets the user input distribution as a cumulati",MatchSource.WIKI,root/html534/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GoFTest.html
https://root.cern/root/html534/ROOT__Math__GoFTest.html:4740,Testability,test,tests,4740,"kUndefined); Constructor for using only with 1-sample tests with a specified distribution. GoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Templated constructor for using only with 1-sample tests with a user specified distribution. Instantiate(const Double_t* sample, UInt_t sampleSize). GoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Specialization using IGenFunction interface. SetUserDistribution(const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0). SetDistributionFunction(const ROOT::Math::IGenFunction& cdf, Bool_t isPDF, Double_t xmin, Double_t xmax). void SetUserPDF(const ROOT::Math::IGenFunction& pdf, Double_t xmin = 1, Double_t xmax = 0); Sets the user input distribution as a probability density function for 1-sample tests. void SetUserCDF(const ROOT::Math::IGenFunction& cdf, Double_t xmin = 1, Double_t xmax = 0); Sets the user input distribution as a cumulative distribution function for 1-sample tests; The CDF must return zero. void SetDistribution(ROOT::Math::GoFTest::EDistribution dist); Sets the distribution for the predefined distribution types. virtual ~GoFTest(). Double_t AndersonDarling2SamplesTest(const Char_t* option = ""p"") const. The Anderson-Darling K-Sample Test algorithm is described and taken from; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/andeksam.htm; and described and taken from; (1) Scholz F.W., Stephens M.A. (1987), K-sample Anderson-Darling Tests, Journal of the American Statistical Association, 82, 918924. (2-samples variant implemented); */ void AndersonDarling2SamplesTest(Double_t& pvalue, Double_t& testStat) const;. Double_t AndersonDarlingTest(const Char_t* option = ",MatchSource.WIKI,root/html534/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GoFTest.html
https://root.cern/root/html534/ROOT__Math__GoFTest.html:4923,Testability,test,tests,4923,"FTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Templated constructor for using only with 1-sample tests with a user specified distribution. Instantiate(const Double_t* sample, UInt_t sampleSize). GoFTest(UInt_t sampleSize, const Double_t* sample, const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0); Specialization using IGenFunction interface. SetUserDistribution(const ROOT::Math::IGenFunction& dist, ROOT::Math::GoFTest::EUserDistribution userDist = kPDF, Double_t xmin = 1, Double_t xmax = 0). SetDistributionFunction(const ROOT::Math::IGenFunction& cdf, Bool_t isPDF, Double_t xmin, Double_t xmax). void SetUserPDF(const ROOT::Math::IGenFunction& pdf, Double_t xmin = 1, Double_t xmax = 0); Sets the user input distribution as a probability density function for 1-sample tests. void SetUserCDF(const ROOT::Math::IGenFunction& cdf, Double_t xmin = 1, Double_t xmax = 0); Sets the user input distribution as a cumulative distribution function for 1-sample tests; The CDF must return zero. void SetDistribution(ROOT::Math::GoFTest::EDistribution dist); Sets the distribution for the predefined distribution types. virtual ~GoFTest(). Double_t AndersonDarling2SamplesTest(const Char_t* option = ""p"") const. The Anderson-Darling K-Sample Test algorithm is described and taken from; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/andeksam.htm; and described and taken from; (1) Scholz F.W., Stephens M.A. (1987), K-sample Anderson-Darling Tests, Journal of the American Statistical Association, 82, 918924. (2-samples variant implemented); */ void AndersonDarling2SamplesTest(Double_t& pvalue, Double_t& testStat) const;. Double_t AndersonDarlingTest(const Char_t* option = ""p"") const. The Anderson-Darling 1-Sample Test algorithm for a specific distribution is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/andedarl.htm; and describe",MatchSource.WIKI,root/html534/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GoFTest.html
https://root.cern/root/html534/ROOT__Math__GoFTest.html:5587,Testability,test,testStat,5587,"xmin, Double_t xmax). void SetUserPDF(const ROOT::Math::IGenFunction& pdf, Double_t xmin = 1, Double_t xmax = 0); Sets the user input distribution as a probability density function for 1-sample tests. void SetUserCDF(const ROOT::Math::IGenFunction& cdf, Double_t xmin = 1, Double_t xmax = 0); Sets the user input distribution as a cumulative distribution function for 1-sample tests; The CDF must return zero. void SetDistribution(ROOT::Math::GoFTest::EDistribution dist); Sets the distribution for the predefined distribution types. virtual ~GoFTest(). Double_t AndersonDarling2SamplesTest(const Char_t* option = ""p"") const. The Anderson-Darling K-Sample Test algorithm is described and taken from; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/andeksam.htm; and described and taken from; (1) Scholz F.W., Stephens M.A. (1987), K-sample Anderson-Darling Tests, Journal of the American Statistical Association, 82, 918924. (2-samples variant implemented); */ void AndersonDarling2SamplesTest(Double_t& pvalue, Double_t& testStat) const;. Double_t AndersonDarlingTest(const Char_t* option = ""p"") const. The Anderson-Darling 1-Sample Test algorithm for a specific distribution is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/andedarl.htm; and described and taken from (2); Marsaglia J.C.W., Marsaglia G. (2004), Evaluating the Anderson-Darling Distribution, Journal of Statistical Software, Volume 09, Issue i02.; and described and taken from (3); Lewis P.A.W. (1961), The Annals of Mathematical Statistics, Distribution of the Anderson-Darling Statistic, Volume 32, Number 4, 1118-1124.; */ void AndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnov2SamplesTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 2-Samples Test algorithm is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/ks2samp.htm; and described and taken from; http://root.cern.ch/root/html/TMath.",MatchSource.WIKI,root/html534/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GoFTest.html
https://root.cern/root/html534/ROOT__Math__GoFTest.html:6245,Testability,test,testStat,6245,"ribed and taken from; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/andeksam.htm; and described and taken from; (1) Scholz F.W., Stephens M.A. (1987), K-sample Anderson-Darling Tests, Journal of the American Statistical Association, 82, 918924. (2-samples variant implemented); */ void AndersonDarling2SamplesTest(Double_t& pvalue, Double_t& testStat) const;. Double_t AndersonDarlingTest(const Char_t* option = ""p"") const. The Anderson-Darling 1-Sample Test algorithm for a specific distribution is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/andedarl.htm; and described and taken from (2); Marsaglia J.C.W., Marsaglia G. (2004), Evaluating the Anderson-Darling Distribution, Journal of Statistical Software, Volume 09, Issue i02.; and described and taken from (3); Lewis P.A.W. (1961), The Annals of Mathematical Statistics, Distribution of the Anderson-Darling Statistic, Volume 32, Number 4, 1118-1124.; */ void AndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnov2SamplesTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 2-Samples Test algorithm is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/ks2samp.htm; and described and taken from; http://root.cern.ch/root/html/TMath.html#TMath:KolmogorovTest; */ void KolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnovTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 1-Sample Test algorithm for a specific distribution is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/kstest.htm; and described and taken from (4); Press W. H., Teukolsky S.A., Vetterling W.T., Flannery B.P. (2007), Numerical Recipes - The Art of Scientific Computing (Third Edition), Cambridge Univerdity Press; */ void KolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const;. void operator()(ROOT::Math::GoFTest::ETestType test, Dou",MatchSource.WIKI,root/html534/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GoFTest.html
https://root.cern/root/html534/ROOT__Math__GoFTest.html:6640,Testability,test,testStat,6640,";. Double_t AndersonDarlingTest(const Char_t* option = ""p"") const. The Anderson-Darling 1-Sample Test algorithm for a specific distribution is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/andedarl.htm; and described and taken from (2); Marsaglia J.C.W., Marsaglia G. (2004), Evaluating the Anderson-Darling Distribution, Journal of Statistical Software, Volume 09, Issue i02.; and described and taken from (3); Lewis P.A.W. (1961), The Annals of Mathematical Statistics, Distribution of the Anderson-Darling Statistic, Volume 32, Number 4, 1118-1124.; */ void AndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnov2SamplesTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 2-Samples Test algorithm is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/ks2samp.htm; and described and taken from; http://root.cern.ch/root/html/TMath.html#TMath:KolmogorovTest; */ void KolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnovTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 1-Sample Test algorithm for a specific distribution is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/kstest.htm; and described and taken from (4); Press W. H., Teukolsky S.A., Vetterling W.T., Flannery B.P. (2007), Numerical Recipes - The Art of Scientific Computing (Third Edition), Cambridge Univerdity Press; */ void KolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const;. void operator()(ROOT::Math::GoFTest::ETestType test, Double_t& pvalue, Double_t& testStat) const; The class's unary functions. Double_t operator()(ROOT::Math::GoFTest::ETestType test = kAD, const Char_t* option = ""p"") const; Returns default Anderson Darling 1-Sample Test and default p-value; option ""t"" returns the test statistic value; specific to the test type. Double_t PValueADKSamples(UInt_t nsamples, Double_t A2); Computation",MatchSource.WIKI,root/html534/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GoFTest.html
https://root.cern/root/html534/ROOT__Math__GoFTest.html:7151,Testability,test,testStat,7151,"ls of Mathematical Statistics, Distribution of the Anderson-Darling Statistic, Volume 32, Number 4, 1118-1124.; */ void AndersonDarlingTest(Double_t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnov2SamplesTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 2-Samples Test algorithm is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/ks2samp.htm; and described and taken from; http://root.cern.ch/root/html/TMath.html#TMath:KolmogorovTest; */ void KolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnovTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 1-Sample Test algorithm for a specific distribution is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/kstest.htm; and described and taken from (4); Press W. H., Teukolsky S.A., Vetterling W.T., Flannery B.P. (2007), Numerical Recipes - The Art of Scientific Computing (Third Edition), Cambridge Univerdity Press; */ void KolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const;. void operator()(ROOT::Math::GoFTest::ETestType test, Double_t& pvalue, Double_t& testStat) const; The class's unary functions. Double_t operator()(ROOT::Math::GoFTest::ETestType test = kAD, const Char_t* option = ""p"") const; Returns default Anderson Darling 1-Sample Test and default p-value; option ""t"" returns the test statistic value; specific to the test type. Double_t PValueADKSamples(UInt_t nsamples, Double_t A2); Computation of the K-Sample Anderson-Darling Test's p-value as described in (1); given a normalized test statistic. The first variant described in the paper is used. void AndersonDarling2SamplesTest(const ROOT::Fit::BinData& data1, const ROOT::Fit::BinData& data2, Double_t& pvalue, Double_t& testStat); Compute The 2-Sample Anderson Darling test for binned data. GoFTest(). GoFTest operator=(ROOT::Math::GoFTest& gof). void SetCDF(). Double_t LogNormalCDF(Double_t x) const. Double_t Ga",MatchSource.WIKI,root/html534/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GoFTest.html
https://root.cern/root/html534/ROOT__Math__GoFTest.html:7216,Testability,test,test,7216,"ue, Double_t& testStat) const;. Double_t KolmogorovSmirnov2SamplesTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 2-Samples Test algorithm is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/ks2samp.htm; and described and taken from; http://root.cern.ch/root/html/TMath.html#TMath:KolmogorovTest; */ void KolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnovTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 1-Sample Test algorithm for a specific distribution is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/kstest.htm; and described and taken from (4); Press W. H., Teukolsky S.A., Vetterling W.T., Flannery B.P. (2007), Numerical Recipes - The Art of Scientific Computing (Third Edition), Cambridge Univerdity Press; */ void KolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const;. void operator()(ROOT::Math::GoFTest::ETestType test, Double_t& pvalue, Double_t& testStat) const; The class's unary functions. Double_t operator()(ROOT::Math::GoFTest::ETestType test = kAD, const Char_t* option = ""p"") const; Returns default Anderson Darling 1-Sample Test and default p-value; option ""t"" returns the test statistic value; specific to the test type. Double_t PValueADKSamples(UInt_t nsamples, Double_t A2); Computation of the K-Sample Anderson-Darling Test's p-value as described in (1); given a normalized test statistic. The first variant described in the paper is used. void AndersonDarling2SamplesTest(const ROOT::Fit::BinData& data1, const ROOT::Fit::BinData& data2, Double_t& pvalue, Double_t& testStat); Compute The 2-Sample Anderson Darling test for binned data. GoFTest(). GoFTest operator=(ROOT::Math::GoFTest& gof). void SetCDF(). Double_t LogNormalCDF(Double_t x) const. Double_t GaussianCDF(Double_t x) const. Double_t ExponentialCDF(Double_t x) const. Double_t GetSigmaN(const vector<UInt_t>& ns, UInt_t N). Double_t InterpolatePValue",MatchSource.WIKI,root/html534/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GoFTest.html
https://root.cern/root/html534/ROOT__Math__GoFTest.html:7250,Testability,test,testStat,7250,"ue, Double_t& testStat) const;. Double_t KolmogorovSmirnov2SamplesTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 2-Samples Test algorithm is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/ks2samp.htm; and described and taken from; http://root.cern.ch/root/html/TMath.html#TMath:KolmogorovTest; */ void KolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnovTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 1-Sample Test algorithm for a specific distribution is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/kstest.htm; and described and taken from (4); Press W. H., Teukolsky S.A., Vetterling W.T., Flannery B.P. (2007), Numerical Recipes - The Art of Scientific Computing (Third Edition), Cambridge Univerdity Press; */ void KolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const;. void operator()(ROOT::Math::GoFTest::ETestType test, Double_t& pvalue, Double_t& testStat) const; The class's unary functions. Double_t operator()(ROOT::Math::GoFTest::ETestType test = kAD, const Char_t* option = ""p"") const; Returns default Anderson Darling 1-Sample Test and default p-value; option ""t"" returns the test statistic value; specific to the test type. Double_t PValueADKSamples(UInt_t nsamples, Double_t A2); Computation of the K-Sample Anderson-Darling Test's p-value as described in (1); given a normalized test statistic. The first variant described in the paper is used. void AndersonDarling2SamplesTest(const ROOT::Fit::BinData& data1, const ROOT::Fit::BinData& data2, Double_t& pvalue, Double_t& testStat); Compute The 2-Sample Anderson Darling test for binned data. GoFTest(). GoFTest operator=(ROOT::Math::GoFTest& gof). void SetCDF(). Double_t LogNormalCDF(Double_t x) const. Double_t GaussianCDF(Double_t x) const. Double_t ExponentialCDF(Double_t x) const. Double_t GetSigmaN(const vector<UInt_t>& ns, UInt_t N). Double_t InterpolatePValue",MatchSource.WIKI,root/html534/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GoFTest.html
https://root.cern/root/html534/ROOT__Math__GoFTest.html:7347,Testability,test,test,7347,"tl.nist.gov/div898/software/dataplot/refman1/auxillar/ks2samp.htm; and described and taken from; http://root.cern.ch/root/html/TMath.html#TMath:KolmogorovTest; */ void KolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnovTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 1-Sample Test algorithm for a specific distribution is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/kstest.htm; and described and taken from (4); Press W. H., Teukolsky S.A., Vetterling W.T., Flannery B.P. (2007), Numerical Recipes - The Art of Scientific Computing (Third Edition), Cambridge Univerdity Press; */ void KolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const;. void operator()(ROOT::Math::GoFTest::ETestType test, Double_t& pvalue, Double_t& testStat) const; The class's unary functions. Double_t operator()(ROOT::Math::GoFTest::ETestType test = kAD, const Char_t* option = ""p"") const; Returns default Anderson Darling 1-Sample Test and default p-value; option ""t"" returns the test statistic value; specific to the test type. Double_t PValueADKSamples(UInt_t nsamples, Double_t A2); Computation of the K-Sample Anderson-Darling Test's p-value as described in (1); given a normalized test statistic. The first variant described in the paper is used. void AndersonDarling2SamplesTest(const ROOT::Fit::BinData& data1, const ROOT::Fit::BinData& data2, Double_t& pvalue, Double_t& testStat); Compute The 2-Sample Anderson Darling test for binned data. GoFTest(). GoFTest operator=(ROOT::Math::GoFTest& gof). void SetCDF(). Double_t LogNormalCDF(Double_t x) const. Double_t GaussianCDF(Double_t x) const. Double_t ExponentialCDF(Double_t x) const. Double_t GetSigmaN(const vector<UInt_t>& ns, UInt_t N). Double_t InterpolatePValues(int nsamples, Double_t A2). Double_t PValueAD1Sample(Double_t A2) const. void LogSample(). void SetSamples(vector<const Double_t*> samples, const vector<UInt_t> samplesSizes). void",MatchSource.WIKI,root/html534/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GoFTest.html
https://root.cern/root/html534/ROOT__Math__GoFTest.html:7485,Testability,test,test,7485,"tl.nist.gov/div898/software/dataplot/refman1/auxillar/ks2samp.htm; and described and taken from; http://root.cern.ch/root/html/TMath.html#TMath:KolmogorovTest; */ void KolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnovTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 1-Sample Test algorithm for a specific distribution is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/kstest.htm; and described and taken from (4); Press W. H., Teukolsky S.A., Vetterling W.T., Flannery B.P. (2007), Numerical Recipes - The Art of Scientific Computing (Third Edition), Cambridge Univerdity Press; */ void KolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const;. void operator()(ROOT::Math::GoFTest::ETestType test, Double_t& pvalue, Double_t& testStat) const; The class's unary functions. Double_t operator()(ROOT::Math::GoFTest::ETestType test = kAD, const Char_t* option = ""p"") const; Returns default Anderson Darling 1-Sample Test and default p-value; option ""t"" returns the test statistic value; specific to the test type. Double_t PValueADKSamples(UInt_t nsamples, Double_t A2); Computation of the K-Sample Anderson-Darling Test's p-value as described in (1); given a normalized test statistic. The first variant described in the paper is used. void AndersonDarling2SamplesTest(const ROOT::Fit::BinData& data1, const ROOT::Fit::BinData& data2, Double_t& pvalue, Double_t& testStat); Compute The 2-Sample Anderson Darling test for binned data. GoFTest(). GoFTest operator=(ROOT::Math::GoFTest& gof). void SetCDF(). Double_t LogNormalCDF(Double_t x) const. Double_t GaussianCDF(Double_t x) const. Double_t ExponentialCDF(Double_t x) const. Double_t GetSigmaN(const vector<UInt_t>& ns, UInt_t N). Double_t InterpolatePValues(int nsamples, Double_t A2). Double_t PValueAD1Sample(Double_t A2) const. void LogSample(). void SetSamples(vector<const Double_t*> samples, const vector<UInt_t> samplesSizes). void",MatchSource.WIKI,root/html534/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GoFTest.html
https://root.cern/root/html534/ROOT__Math__GoFTest.html:7523,Testability,test,test,7523,"tl.nist.gov/div898/software/dataplot/refman1/auxillar/ks2samp.htm; and described and taken from; http://root.cern.ch/root/html/TMath.html#TMath:KolmogorovTest; */ void KolmogorovSmirnov2SamplesTest(Double_t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnovTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 1-Sample Test algorithm for a specific distribution is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/kstest.htm; and described and taken from (4); Press W. H., Teukolsky S.A., Vetterling W.T., Flannery B.P. (2007), Numerical Recipes - The Art of Scientific Computing (Third Edition), Cambridge Univerdity Press; */ void KolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const;. void operator()(ROOT::Math::GoFTest::ETestType test, Double_t& pvalue, Double_t& testStat) const; The class's unary functions. Double_t operator()(ROOT::Math::GoFTest::ETestType test = kAD, const Char_t* option = ""p"") const; Returns default Anderson Darling 1-Sample Test and default p-value; option ""t"" returns the test statistic value; specific to the test type. Double_t PValueADKSamples(UInt_t nsamples, Double_t A2); Computation of the K-Sample Anderson-Darling Test's p-value as described in (1); given a normalized test statistic. The first variant described in the paper is used. void AndersonDarling2SamplesTest(const ROOT::Fit::BinData& data1, const ROOT::Fit::BinData& data2, Double_t& pvalue, Double_t& testStat); Compute The 2-Sample Anderson Darling test for binned data. GoFTest(). GoFTest operator=(ROOT::Math::GoFTest& gof). void SetCDF(). Double_t LogNormalCDF(Double_t x) const. Double_t GaussianCDF(Double_t x) const. Double_t ExponentialCDF(Double_t x) const. Double_t GetSigmaN(const vector<UInt_t>& ns, UInt_t N). Double_t InterpolatePValues(int nsamples, Double_t A2). Double_t PValueAD1Sample(Double_t A2) const. void LogSample(). void SetSamples(vector<const Double_t*> samples, const vector<UInt_t> samplesSizes). void",MatchSource.WIKI,root/html534/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GoFTest.html
https://root.cern/root/html534/ROOT__Math__GoFTest.html:7691,Testability,test,test,7691,"t& pvalue, Double_t& testStat) const;. Double_t KolmogorovSmirnovTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 1-Sample Test algorithm for a specific distribution is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/kstest.htm; and described and taken from (4); Press W. H., Teukolsky S.A., Vetterling W.T., Flannery B.P. (2007), Numerical Recipes - The Art of Scientific Computing (Third Edition), Cambridge Univerdity Press; */ void KolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const;. void operator()(ROOT::Math::GoFTest::ETestType test, Double_t& pvalue, Double_t& testStat) const; The class's unary functions. Double_t operator()(ROOT::Math::GoFTest::ETestType test = kAD, const Char_t* option = ""p"") const; Returns default Anderson Darling 1-Sample Test and default p-value; option ""t"" returns the test statistic value; specific to the test type. Double_t PValueADKSamples(UInt_t nsamples, Double_t A2); Computation of the K-Sample Anderson-Darling Test's p-value as described in (1); given a normalized test statistic. The first variant described in the paper is used. void AndersonDarling2SamplesTest(const ROOT::Fit::BinData& data1, const ROOT::Fit::BinData& data2, Double_t& pvalue, Double_t& testStat); Compute The 2-Sample Anderson Darling test for binned data. GoFTest(). GoFTest operator=(ROOT::Math::GoFTest& gof). void SetCDF(). Double_t LogNormalCDF(Double_t x) const. Double_t GaussianCDF(Double_t x) const. Double_t ExponentialCDF(Double_t x) const. Double_t GetSigmaN(const vector<UInt_t>& ns, UInt_t N). Double_t InterpolatePValues(int nsamples, Double_t A2). Double_t PValueAD1Sample(Double_t A2) const. void LogSample(). void SetSamples(vector<const Double_t*> samples, const vector<UInt_t> samplesSizes). void SetParameters().  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in genera",MatchSource.WIKI,root/html534/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GoFTest.html
https://root.cern/root/html534/ROOT__Math__GoFTest.html:7884,Testability,test,testStat,7884,"Double_t KolmogorovSmirnovTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 1-Sample Test algorithm for a specific distribution is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/kstest.htm; and described and taken from (4); Press W. H., Teukolsky S.A., Vetterling W.T., Flannery B.P. (2007), Numerical Recipes - The Art of Scientific Computing (Third Edition), Cambridge Univerdity Press; */ void KolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const;. void operator()(ROOT::Math::GoFTest::ETestType test, Double_t& pvalue, Double_t& testStat) const; The class's unary functions. Double_t operator()(ROOT::Math::GoFTest::ETestType test = kAD, const Char_t* option = ""p"") const; Returns default Anderson Darling 1-Sample Test and default p-value; option ""t"" returns the test statistic value; specific to the test type. Double_t PValueADKSamples(UInt_t nsamples, Double_t A2); Computation of the K-Sample Anderson-Darling Test's p-value as described in (1); given a normalized test statistic. The first variant described in the paper is used. void AndersonDarling2SamplesTest(const ROOT::Fit::BinData& data1, const ROOT::Fit::BinData& data2, Double_t& pvalue, Double_t& testStat); Compute The 2-Sample Anderson Darling test for binned data. GoFTest(). GoFTest operator=(ROOT::Math::GoFTest& gof). void SetCDF(). Double_t LogNormalCDF(Double_t x) const. Double_t GaussianCDF(Double_t x) const. Double_t ExponentialCDF(Double_t x) const. Double_t GetSigmaN(const vector<UInt_t>& ns, UInt_t N). Double_t InterpolatePValues(int nsamples, Double_t A2). Double_t PValueAD1Sample(Double_t A2) const. void LogSample(). void SetSamples(vector<const Double_t*> samples, const vector<UInt_t> samplesSizes). void SetParameters().  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GoFTest.html
https://root.cern/root/html534/ROOT__Math__GoFTest.html:7933,Testability,test,test,7933,"Double_t KolmogorovSmirnovTest(const Char_t* option = ""p"") const. The Kolmogorov-Smirnov 1-Sample Test algorithm for a specific distribution is described at; http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/kstest.htm; and described and taken from (4); Press W. H., Teukolsky S.A., Vetterling W.T., Flannery B.P. (2007), Numerical Recipes - The Art of Scientific Computing (Third Edition), Cambridge Univerdity Press; */ void KolmogorovSmirnovTest(Double_t& pvalue, Double_t& testStat) const;. void operator()(ROOT::Math::GoFTest::ETestType test, Double_t& pvalue, Double_t& testStat) const; The class's unary functions. Double_t operator()(ROOT::Math::GoFTest::ETestType test = kAD, const Char_t* option = ""p"") const; Returns default Anderson Darling 1-Sample Test and default p-value; option ""t"" returns the test statistic value; specific to the test type. Double_t PValueADKSamples(UInt_t nsamples, Double_t A2); Computation of the K-Sample Anderson-Darling Test's p-value as described in (1); given a normalized test statistic. The first variant described in the paper is used. void AndersonDarling2SamplesTest(const ROOT::Fit::BinData& data1, const ROOT::Fit::BinData& data2, Double_t& pvalue, Double_t& testStat); Compute The 2-Sample Anderson Darling test for binned data. GoFTest(). GoFTest operator=(ROOT::Math::GoFTest& gof). void SetCDF(). Double_t LogNormalCDF(Double_t x) const. Double_t GaussianCDF(Double_t x) const. Double_t ExponentialCDF(Double_t x) const. Double_t GetSigmaN(const vector<UInt_t>& ns, UInt_t N). Double_t InterpolatePValues(int nsamples, Double_t A2). Double_t PValueAD1Sample(Double_t A2) const. void LogSample(). void SetSamples(vector<const Double_t*> samples, const vector<UInt_t> samplesSizes). void SetParameters().  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__GoFTest.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GoFTest.html
https://root.cern/root/html534/ROOT__Math__GradFunctor.html:425,Availability,avail,available,425,". ROOT::Math::GradFunctor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::GradFunctor. class ROOT::Math::GradFunctor: public ROOT::Math::IGradientFunctionMultiDim. LM 7/2/2014: no needed this : make template ctor of Functor1D and GradFunctor1D not; available to CINT s. #if defined(__MAKECINT__) || defined(G__DICTIONARY); needed since CINT initialize it with TRootIOCtor; class TRootIOCtor;. Function Members (Methods); public:. virtual~GradFunctor(); virtual ROOT::Math::GradFunctor::ImplBase*Clone() const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidROOT::Math::IGradientFunctionMultiDim::FdF(const double* x, double& f, double* df) const; ROOT::Math::GradFunctorGradFunctor(); ROOT::Math::GradFunctorGradFunctor(const ROOT::Math::GradFunctor& rhs); ROOT::Math::GradFunctorGradFunctor(void* p1, void* p2, unsigned int dim); ROOT::Math::GradFunctorGradFunctor(void* p1, unsigned int dim, const char* className, const char* methodName, const char* derivName); virtual voidROOT::Math::IGradientFunctionMultiDim::Gradient(const double* x, double* grad) const; virtual unsigned intNDim() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::GradFunctor&operator=(const ROOT::Math::GradFunctor& rhs). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const. Data Members; private:. auto_ptr<ROOT::Math::FunctorImpl<ROOT::Math::IGradientFunctionMultiDim> >fImplpointer to base grad functor handler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunc * Clone() const; clone of the function handler (use copy-ctor). unsigned int NDim() const; constructor for multi-dimensional functions. double DoEval(co",MatchSource.WIKI,root/html534/ROOT__Math__GradFunctor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GradFunctor.html
https://root.cern/root/html534/ROOT__Math__GradFunctor1D.html:429,Availability,avail,available,429,". ROOT::Math::GradFunctor1D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::GradFunctor1D. class ROOT::Math::GradFunctor1D: public ROOT::Math::IGradientFunctionOneDim. LM 7/2/2014: no needed this : make template ctor of Functor1D and GradFunctor1D not; available to CINT s. #if defined(__MAKECINT__) || defined(G__DICTIONARY); needed since CINT initialize it with TRootIOCtor; class TRootIOCtor;. Function Members (Methods); public:. virtual~GradFunctor1D(); virtual ROOT::Math::GradFunctor1D::ImplBase*Clone() const; doubleROOT::Math::IGradientOneDim::Derivative(double x) const; doubleROOT::Math::IGradientOneDim::Derivative(const double* x) const; virtual voidROOT::Math::IGradientFunctionOneDim::FdF(double x, double& f, double& df) const; ROOT::Math::GradFunctor1DGradFunctor1D(); ROOT::Math::GradFunctor1DGradFunctor1D(const ROOT::Math::GradFunctor1D& rhs); ROOT::Math::GradFunctor1DGradFunctor1D(void* p1, void* p2); ROOT::Math::GradFunctor1DGradFunctor1D(void* p1, const char* className, const char* methodName, const char* derivName); voidROOT::Math::IGradientOneDim::Gradient(const double* x, double* g) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(double x) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(const double* x) const; ROOT::Math::GradFunctor1D&operator=(const ROOT::Math::GradFunctor1D& rhs). private:. virtual doubleDoDerivative(double x) const; virtual doubleDoEval(double x) const. Data Members; private:. auto_ptr<ROOT::Math::FunctorImpl<ROOT::Math::IGradientFunctionOneDim> >fImplpointer to base gradient functor handler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunc * Clone() const; clone of the function handler (use copy-ctor). double DoEval(double x) const. double DoDerivative(double x) const. GradFunctor1D(). Defau",MatchSource.WIKI,root/html534/ROOT__Math__GradFunctor1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GradFunctor1D.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:375,Deployability,integrat,integration,375,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:442,Deployability,integrat,integration,442,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:542,Deployability,integrat,integration,542,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:625,Deployability,integrat,integration,625,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:667,Deployability,integrat,integration,667,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:746,Deployability,integrat,integration,746,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:872,Deployability,integrat,integration,872,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:990,Deployability,integrat,integration,990,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:1043,Deployability,integrat,integration,1043,"lass Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::I",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:1158,Deployability,integrat,integration,1158,"ATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim:",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:1565,Deployability,integrat,integration,1565,"ortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, const ROOT::Math::Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); virtual doubleIntegral(); doubleIntegral(const ROOT::Math::IGenFunction& f); virtual doubleIntegral(const vector<",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:4806,Deployability,integrat,integration,4806,"id* p = 0); voidSetIntegrationRule(ROOT::Math::Integration::GKRule); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double relTolerance); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. protected:. boolCheckFunction(). private:. ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::GSLIntegrator&); ROOT::Math::GSLIntegrator&operator=(const ROOT::Math::GSLIntegrator&). Data Members; private:. doublefAbsTol; doublefError; ROOT::Math::GSLFunctionWrapper*fFunction; size_tfMaxIntervals; intfNEval; doublefRelTol; doublefResult; ROOT::Math::Integration::GKRulefRule; size_tfSize; intfStatus; ROOT::Math::IntegrationOneDim::TypefType; ROOT::Math::GSLIntegrationWorkspace*fWorkspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructors; Default constructor of GSL Integrator for Adaptive Singular integration. @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Inte",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:5123,Deployability,integrat,integration,5123,"egrator(const ROOT::Math::GSLIntegrator&); ROOT::Math::GSLIntegrator&operator=(const ROOT::Math::GSLIntegrator&). Data Members; private:. doublefAbsTol; doublefError; ROOT::Math::GSLFunctionWrapper*fFunction; size_tfMaxIntervals; intfNEval; doublefRelTol; doublefResult; ROOT::Math::Integration::GKRulefRule; size_tfSize; intfStatus; ROOT::Math::IntegrationOneDim::TypefType; ROOT::Math::GSLIntegrationWorkspace*fWorkspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructors; Default constructor of GSL Integrator for Adaptive Singular integration. @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 ",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:5198,Deployability,integrat,integration,5198,"SLIntegrator&operator=(const ROOT::Math::GSLIntegrator&). Data Members; private:. doublefAbsTol; doublefError; ROOT::Math::GSLFunctionWrapper*fFunction; size_tfMaxIntervals; intfNEval; doublefRelTol; doublefResult; ROOT::Math::Integration::GKRulefRule; size_tfSize; intfStatus; ROOT::Math::IntegrationOneDim::TypefType; ROOT::Math::GSLIntegrationWorkspace*fWorkspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructors; Default constructor of GSL Integrator for Adaptive Singular integration. @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (nee",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:5603,Deployability,integrat,integration,5603,"Members; Includes; Libraries. Function documentation; GSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructors; Default constructor of GSL Integrator for Adaptive Singular integration. @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disa",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:6099,Deployability,integrat,integration,6099,"ule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0). Set function from a GSL pointer function type. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); methods using IGenFunct",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:6251,Deployability,integrat,integration,6251,"he Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0). Set function from a GSL pointer function type. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); methods using IGenFunction. evaluate the Integral of a function f over the defined interval (a,b); @param f integratio",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:6796,Deployability,integrat,integration,6796,"ined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0). Set function from a GSL pointer function type. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); methods using IGenFunction. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralCauchy(double a, double b, double c). evaluate the Cauchy principal value of the integral of a previously defined function f ove",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:6827,Deployability,integrat,integration,6827,"ion; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0). Set function from a GSL pointer function type. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); methods using IGenFunction. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralCauchy(double a, double b, double c). evaluate the Cauchy principal value of the integral of a previously defined function f over; the defined interval (a,b) with a sing",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:7237,Deployability,integrat,integration,7237,"stead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0). Set function from a GSL pointer function type. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); methods using IGenFunction. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralCauchy(double a, double b, double c). evaluate the Cauchy principal value of the integral of a previously defined function f over; the defined interval (a,b) with a singularity at c; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must ",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:7357,Deployability,integrat,integration,7357,"e Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0). Set function from a GSL pointer function type. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); methods using IGenFunction. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralCauchy(double a, double b, double c). evaluate the Cauchy principal value of the integral of a previously defined function f over; the defined interval (a,b) with a singularity at c; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value of ",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:7407,Deployability,integrat,integration,7407,"e Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0). Set function from a GSL pointer function type. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); methods using IGenFunction. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralCauchy(double a, double b, double c). evaluate the Cauchy principal value of the integral of a previously defined function f over; the defined interval (a,b) with a singularity at c; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value of ",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:7557,Deployability,integrat,integration,7557,"); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0). Set function from a GSL pointer function type. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); methods using IGenFunction. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralCauchy(double a, double b, double c). evaluate the Cauchy principal value of the integral of a previously defined function f over; the defined interval (a,b) with a singularity at c; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:8162,Deployability,integrat,integration,8162," f, double a, double b); methods using IGenFunction. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralCauchy(double a, double b, double c). evaluate the Cauchy principal value of the integral of a previously defined function f over; the defined interval (a,b) with a singularity at c; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. double Integral(double a, double b). evaluate the Integral of a function f with known singular points over the defined Integral (a,b); @param f integration fun",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:8499,Deployability,integrat,integration,8499,"& f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralCauchy(double a, double b, double c). evaluate the Cauchy principal value of the integral of a previously defined function f over; the defined interval (a,b) with a singularity at c; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. double Integral(double a, double b). evaluate the Integral of a function f with known singular points over the defined Integral (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using ca",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:8619,Deployability,integrat,integration,8619,"he function type must implement the mathlib::IGenFunction interface. double IntegralCauchy(double a, double b, double c). evaluate the Cauchy principal value of the integral of a previously defined function f over; the defined interval (a,b) with a singularity at c; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. double Integral(double a, double b). evaluate the Integral of a function f with known singular points over the defined Integral (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using cached function. evaluate the Integral over the defined interval (a,b) using the function previously set with GSLInte",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:8804,Deployability,integrat,integration,8804,"usly defined function f over; the defined interval (a,b) with a singularity at c; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. double Integral(double a, double b). evaluate the Integral of a function f with known singular points over the defined Integral (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using cached function. evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(). evaluate the Integral over the infinit",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:8924,Deployability,integrat,integration,8924,"b lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. double Integral(double a, double b). evaluate the Integral of a function f with known singular points over the defined Integral (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using cached function. evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(). evaluate the Integral over the infinite interval (-inf,+inf) using the function previously set with GSLIntegrator::SetFunction method. double IntegralUp(doubl",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:9090,Deployability,integrat,integration,9090," principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. double Integral(double a, double b). evaluate the Integral of a function f with known singular points over the defined Integral (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using cached function. evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(). evaluate the Integral over the infinite interval (-inf,+inf) using the function previously set with GSLIntegrator::SetFunction method. double IntegralUp(double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) using the function previously set with GSLIntegrator::SetFunction method.; @p",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:9348,Deployability,integrat,integration,9348,"uble IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. double Integral(double a, double b). evaluate the Integral of a function f with known singular points over the defined Integral (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using cached function. evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(). evaluate the Integral over the infinite interval (-inf,+inf) using the function previously set with GSLIntegrator::SetFunction method. double IntegralUp(double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) using the function previously set with GSLIntegrator::SetFunction method.; @param a lower value of the integration interval. double IntegralLow(double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) using the function previously set with GSLIntegrator::SetFunction method.; @param b upper value of the integration interval. double Inte",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:9636,Deployability,integrat,integration,9636,"aram a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. double Integral(double a, double b). evaluate the Integral of a function f with known singular points over the defined Integral (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using cached function. evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(). evaluate the Integral over the infinite interval (-inf,+inf) using the function previously set with GSLIntegrator::SetFunction method. double IntegralUp(double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) using the function previously set with GSLIntegrator::SetFunction method.; @param a lower value of the integration interval. double IntegralLow(double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) using the function previously set with GSLIntegrator::SetFunction method.; @param b upper value of the integration interval. double Integral( const std::vector<double> & pts). evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method. The function has known singular points.; @param pts vector containing both t",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:9686,Deployability,integrat,integration,9686,"aram a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. double Integral(double a, double b). evaluate the Integral of a function f with known singular points over the defined Integral (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using cached function. evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(). evaluate the Integral over the infinite interval (-inf,+inf) using the function previously set with GSLIntegrator::SetFunction method. double IntegralUp(double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) using the function previously set with GSLIntegrator::SetFunction method.; @param a lower value of the integration interval. double IntegralLow(double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) using the function previously set with GSLIntegrator::SetFunction method.; @param b upper value of the integration interval. double Integral( const std::vector<double> & pts). evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method. The function has known singular points.; @param pts vector containing both t",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:10073,Deployability,integrat,integration,10073,"egral (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using cached function. evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(). evaluate the Integral over the infinite interval (-inf,+inf) using the function previously set with GSLIntegrator::SetFunction method. double IntegralUp(double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) using the function previously set with GSLIntegrator::SetFunction method.; @param a lower value of the integration interval. double IntegralLow(double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) using the function previously set with GSLIntegrator::SetFunction method.; @param b upper value of the integration interval. double Integral( const std::vector<double> & pts). evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method. The function has known singular points.; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); evaluate using free function pointer (same GSL signature). signature for function pointers used by GSL. typedef double ( * GSLFuncPointer ) ( double, void * );. evaluate the Integral of of a function f over",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:10316,Deployability,integrat,integration,10316," first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using cached function. evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(). evaluate the Integral over the infinite interval (-inf,+inf) using the function previously set with GSLIntegrator::SetFunction method. double IntegralUp(double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) using the function previously set with GSLIntegrator::SetFunction method.; @param a lower value of the integration interval. double IntegralLow(double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) using the function previously set with GSLIntegrator::SetFunction method.; @param b upper value of the integration interval. double Integral( const std::vector<double> & pts). evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method. The function has known singular points.; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); evaluate using free function pointer (same GSL signature). signature for function pointers used by GSL. typedef double ( * GSLFuncPointer ) ( double, void * );. evaluate the Integral of of a function f over the defined interval (a,b) passing a free function pointer; The integration function must be a free function and have a signature consistent with GSL functions:. <em>double my_function ( double x, void * p ) { ...... } </em>. This method is t",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:10724,Deployability,integrat,integration,10724,"). evaluate the Integral over the infinite interval (-inf,+inf) using the function previously set with GSLIntegrator::SetFunction method. double IntegralUp(double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) using the function previously set with GSLIntegrator::SetFunction method.; @param a lower value of the integration interval. double IntegralLow(double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) using the function previously set with GSLIntegrator::SetFunction method.; @param b upper value of the integration interval. double Integral( const std::vector<double> & pts). evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method. The function has known singular points.; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); evaluate using free function pointer (same GSL signature). signature for function pointers used by GSL. typedef double ( * GSLFuncPointer ) ( double, void * );. evaluate the Integral of of a function f over the defined interval (a,b) passing a free function pointer; The integration function must be a free function and have a signature consistent with GSL functions:. <em>double my_function ( double x, void * p ) { ...... } </em>. This method is the most efficient since no internal adapter to GSL function is created.; @param f pointer to the integration function; @param p pointer to the Parameters of the function; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(ROOT::Math::GSLFuncPointer f, void* p). evaluate the Integral of a function f over the infinite interval (-inf,+inf) passing a",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:11134,Deployability,integrat,integration,11134,"aluate the Integral of a function f over the over the semi-infinite interval (-inf,b) using the function previously set with GSLIntegrator::SetFunction method.; @param b upper value of the integration interval. double Integral( const std::vector<double> & pts). evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method. The function has known singular points.; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); evaluate using free function pointer (same GSL signature). signature for function pointers used by GSL. typedef double ( * GSLFuncPointer ) ( double, void * );. evaluate the Integral of of a function f over the defined interval (a,b) passing a free function pointer; The integration function must be a free function and have a signature consistent with GSL functions:. <em>double my_function ( double x, void * p ) { ...... } </em>. This method is the most efficient since no internal adapter to GSL function is created.; @param f pointer to the integration function; @param p pointer to the Parameters of the function; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(ROOT::Math::GSLFuncPointer f, void* p). evaluate the Integral of a function f over the infinite interval (-inf,+inf) passing a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double I",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:11409,Deployability,integrat,integration,11409,"GSLIntegrator::SetFunction method. The function has known singular points.; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); evaluate using free function pointer (same GSL signature). signature for function pointers used by GSL. typedef double ( * GSLFuncPointer ) ( double, void * );. evaluate the Integral of of a function f over the defined interval (a,b) passing a free function pointer; The integration function must be a free function and have a signature consistent with GSL functions:. <em>double my_function ( double x, void * p ) { ...... } </em>. This method is the most efficient since no internal adapter to GSL function is created.; @param f pointer to the integration function; @param p pointer to the Parameters of the function; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(ROOT::Math::GSLFuncPointer f, void* p). evaluate the Integral of a function f over the infinite interval (-inf,+inf) passing a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts). evaluate the Integral of a function f with knows singular points over the over a defined interval passing a free function pointer. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:11511,Deployability,integrat,integration,11511,"GSLIntegrator::SetFunction method. The function has known singular points.; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); evaluate using free function pointer (same GSL signature). signature for function pointers used by GSL. typedef double ( * GSLFuncPointer ) ( double, void * );. evaluate the Integral of of a function f over the defined interval (a,b) passing a free function pointer; The integration function must be a free function and have a signature consistent with GSL functions:. <em>double my_function ( double x, void * p ) { ...... } </em>. This method is the most efficient since no internal adapter to GSL function is created.; @param f pointer to the integration function; @param p pointer to the Parameters of the function; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(ROOT::Math::GSLFuncPointer f, void* p). evaluate the Integral of a function f over the infinite interval (-inf,+inf) passing a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts). evaluate the Integral of a function f with knows singular points over the over a defined interval passing a free function pointer. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:11561,Deployability,integrat,integration,11561,"GSLIntegrator::SetFunction method. The function has known singular points.; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); evaluate using free function pointer (same GSL signature). signature for function pointers used by GSL. typedef double ( * GSLFuncPointer ) ( double, void * );. evaluate the Integral of of a function f over the defined interval (a,b) passing a free function pointer; The integration function must be a free function and have a signature consistent with GSL functions:. <em>double my_function ( double x, void * p ) { ...... } </em>. This method is the most efficient since no internal adapter to GSL function is created.; @param f pointer to the integration function; @param p pointer to the Parameters of the function; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(ROOT::Math::GSLFuncPointer f, void* p). evaluate the Integral of a function f over the infinite interval (-inf,+inf) passing a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts). evaluate the Integral of a function f with knows singular points over the over a defined interval passing a free function pointer. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:12971,Deployability,integrat,integration,12971,"on f over the infinite interval (-inf,+inf) passing a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts). evaluate the Integral of a function f with knows singular points over the over a defined interval passing a free function pointer. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. void SetAbsTolerance(double absTolerance). set the desired absolute Error. void SetIntegrationRule(ROOT::Math::Integration::GKRule ). set the integration rule (Gauss-Kronrod rule).; The possible rules are defined in the Integration::GKRule enumeration.; The integration rule can be modified only for ADAPTIVE type integrations. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. IntegrationOneDim::Type GetType() const; get type name. { return fType; }. const char * GetTypeName() const. return the name. bool CheckFunction(); internal method to check validity of GSL function pointer.  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:13087,Deployability,integrat,integration,13087,"on f over the infinite interval (-inf,+inf) passing a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts). evaluate the Integral of a function f with knows singular points over the over a defined interval passing a free function pointer. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. void SetAbsTolerance(double absTolerance). set the desired absolute Error. void SetIntegrationRule(ROOT::Math::Integration::GKRule ). set the integration rule (Gauss-Kronrod rule).; The possible rules are defined in the Integration::GKRule enumeration.; The integration rule can be modified only for ADAPTIVE type integrations. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. IntegrationOneDim::Type GetType() const; get type name. { return fType; }. const char * GetTypeName() const. return the name. bool CheckFunction(); internal method to check validity of GSL function pointer.  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:13143,Deployability,integrat,integrations,13143,"on f over the infinite interval (-inf,+inf) passing a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts). evaluate the Integral of a function f with knows singular points over the over a defined interval passing a free function pointer. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. void SetAbsTolerance(double absTolerance). set the desired absolute Error. void SetIntegrationRule(ROOT::Math::Integration::GKRule ). set the integration rule (Gauss-Kronrod rule).; The possible rules are defined in the Integration::GKRule enumeration.; The integration rule can be modified only for ADAPTIVE type integrations. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. IntegrationOneDim::Type GetType() const; get type name. { return fType; }. const char * GetTypeName() const. return the name. bool CheckFunction(); internal method to check validity of GSL function pointer.  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:599,Energy Efficiency,adapt,adaptive,599,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:616,Energy Efficiency,adapt,adaptive,616,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:863,Energy Efficiency,adapt,adaptive,863,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:11320,Energy Efficiency,efficient,efficient,11320,"ouble Integral( const std::vector<double> & pts). evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method. The function has known singular points.; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); evaluate using free function pointer (same GSL signature). signature for function pointers used by GSL. typedef double ( * GSLFuncPointer ) ( double, void * );. evaluate the Integral of of a function f over the defined interval (a,b) passing a free function pointer; The integration function must be a free function and have a signature consistent with GSL functions:. <em>double my_function ( double x, void * p ) { ...... } </em>. This method is the most efficient since no internal adapter to GSL function is created.; @param f pointer to the integration function; @param p pointer to the Parameters of the function; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(ROOT::Math::GSLFuncPointer f, void* p). evaluate the Integral of a function f over the infinite interval (-inf,+inf) passing a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts). evaluate the Integral of a function f with knows singular points over the over a defined interval passing a free function pointer. double",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:11348,Energy Efficiency,adapt,adapter,11348,"ouble Integral( const std::vector<double> & pts). evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method. The function has known singular points.; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); evaluate using free function pointer (same GSL signature). signature for function pointers used by GSL. typedef double ( * GSLFuncPointer ) ( double, void * );. evaluate the Integral of of a function f over the defined interval (a,b) passing a free function pointer; The integration function must be a free function and have a signature consistent with GSL functions:. <em>double my_function ( double x, void * p ) { ...... } </em>. This method is the most efficient since no internal adapter to GSL function is created.; @param f pointer to the integration function; @param p pointer to the Parameters of the function; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(ROOT::Math::GSLFuncPointer f, void* p). evaluate the Integral of a function f over the infinite interval (-inf,+inf) passing a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts). evaluate the Integral of a function f with knows singular points over the over a defined interval passing a free function pointer. double",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:375,Integrability,integrat,integration,375,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:442,Integrability,integrat,integration,442,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:542,Integrability,integrat,integration,542,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:625,Integrability,integrat,integration,625,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:667,Integrability,integrat,integration,667,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:746,Integrability,integrat,integration,746,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:872,Integrability,integrat,integration,872,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:990,Integrability,integrat,integration,990,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:1043,Integrability,integrat,integration,1043,"lass Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::I",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:1158,Integrability,integrat,integration,1158,"ATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim:",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:1565,Integrability,integrat,integration,1565,"ortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, const ROOT::Math::Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); virtual doubleIntegral(); doubleIntegral(const ROOT::Math::IGenFunction& f); virtual doubleIntegral(const vector<",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:4806,Integrability,integrat,integration,4806,"id* p = 0); voidSetIntegrationRule(ROOT::Math::Integration::GKRule); virtual voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); virtual voidSetRelTolerance(double relTolerance); virtual intStatus() const; virtual ROOT::Math::IntegrationOneDim::TypeROOT::Math::VirtualIntegratorOneDim::Type() const. protected:. boolCheckFunction(). private:. ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::GSLIntegrator&); ROOT::Math::GSLIntegrator&operator=(const ROOT::Math::GSLIntegrator&). Data Members; private:. doublefAbsTol; doublefError; ROOT::Math::GSLFunctionWrapper*fFunction; size_tfMaxIntervals; intfNEval; doublefRelTol; doublefResult; ROOT::Math::Integration::GKRulefRule; size_tfSize; intfStatus; ROOT::Math::IntegrationOneDim::TypefType; ROOT::Math::GSLIntegrationWorkspace*fWorkspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructors; Default constructor of GSL Integrator for Adaptive Singular integration. @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Inte",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:5123,Integrability,integrat,integration,5123,"egrator(const ROOT::Math::GSLIntegrator&); ROOT::Math::GSLIntegrator&operator=(const ROOT::Math::GSLIntegrator&). Data Members; private:. doublefAbsTol; doublefError; ROOT::Math::GSLFunctionWrapper*fFunction; size_tfMaxIntervals; intfNEval; doublefRelTol; doublefResult; ROOT::Math::Integration::GKRulefRule; size_tfSize; intfStatus; ROOT::Math::IntegrationOneDim::TypefType; ROOT::Math::GSLIntegrationWorkspace*fWorkspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructors; Default constructor of GSL Integrator for Adaptive Singular integration. @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 ",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:5198,Integrability,integrat,integration,5198,"SLIntegrator&operator=(const ROOT::Math::GSLIntegrator&). Data Members; private:. doublefAbsTol; doublefError; ROOT::Math::GSLFunctionWrapper*fFunction; size_tfMaxIntervals; intfNEval; doublefRelTol; doublefResult; ROOT::Math::Integration::GKRulefRule; size_tfSize; intfStatus; ROOT::Math::IntegrationOneDim::TypefType; ROOT::Math::GSLIntegrationWorkspace*fWorkspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructors; Default constructor of GSL Integrator for Adaptive Singular integration. @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (nee",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:5603,Integrability,integrat,integration,5603,"Members; Includes; Libraries. Function documentation; GSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructors; Default constructor of GSL Integrator for Adaptive Singular integration. @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disa",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:6099,Integrability,integrat,integration,6099,"ule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0). Set function from a GSL pointer function type. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); methods using IGenFunct",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:6251,Integrability,integrat,integration,6251,"he Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0). Set function from a GSL pointer function type. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); methods using IGenFunction. evaluate the Integral of a function f over the defined interval (a,b); @param f integratio",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:6796,Integrability,integrat,integration,6796,"ined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0). Set function from a GSL pointer function type. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); methods using IGenFunction. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralCauchy(double a, double b, double c). evaluate the Cauchy principal value of the integral of a previously defined function f ove",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:6827,Integrability,integrat,integration,6827,"ion; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0). Set function from a GSL pointer function type. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); methods using IGenFunction. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralCauchy(double a, double b, double c). evaluate the Cauchy principal value of the integral of a previously defined function f over; the defined interval (a,b) with a sing",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:7237,Integrability,integrat,integration,7237,"stead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0). Set function from a GSL pointer function type. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); methods using IGenFunction. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralCauchy(double a, double b, double c). evaluate the Cauchy principal value of the integral of a previously defined function f over; the defined interval (a,b) with a singularity at c; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must ",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:7318,Integrability,interface,interface,7318,"e Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0). Set function from a GSL pointer function type. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); methods using IGenFunction. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralCauchy(double a, double b, double c). evaluate the Cauchy principal value of the integral of a previously defined function f over; the defined interval (a,b) with a singularity at c; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value of ",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:7357,Integrability,integrat,integration,7357,"e Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0). Set function from a GSL pointer function type. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); methods using IGenFunction. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralCauchy(double a, double b, double c). evaluate the Cauchy principal value of the integral of a previously defined function f over; the defined interval (a,b) with a singularity at c; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value of ",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:7407,Integrability,integrat,integration,7407,"e Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0). Set function from a GSL pointer function type. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); methods using IGenFunction. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralCauchy(double a, double b, double c). evaluate the Cauchy principal value of the integral of a previously defined function f over; the defined interval (a,b) with a singularity at c; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value of ",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:7557,Integrability,integrat,integration,7557,"); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0). Set function from a GSL pointer function type. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); methods using IGenFunction. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralCauchy(double a, double b, double c). evaluate the Cauchy principal value of the integral of a previously defined function f over; the defined interval (a,b) with a singularity at c; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:7638,Integrability,interface,interface,7638," GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0). Set function from a GSL pointer function type. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); methods using IGenFunction. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralCauchy(double a, double b, double c). evaluate the Cauchy principal value of the integral of a previously defined function f over; the defined interval (a,b) with a singularity at c; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value o",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:8162,Integrability,integrat,integration,8162," f, double a, double b); methods using IGenFunction. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralCauchy(double a, double b, double c). evaluate the Cauchy principal value of the integral of a previously defined function f over; the defined interval (a,b) with a singularity at c; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. double Integral(double a, double b). evaluate the Integral of a function f with known singular points over the defined Integral (a,b); @param f integration fun",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:8243,Integrability,interface,interface,8243,"unction type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralCauchy(double a, double b, double c). evaluate the Cauchy principal value of the integral of a previously defined function f over; the defined interval (a,b) with a singularity at c; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. double Integral(double a, double b). evaluate the Integral of a function f with known singular points over the defined Integral (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param pts vector containing both the function singular points and the lower/upper",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:8499,Integrability,integrat,integration,8499,"& f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralCauchy(double a, double b, double c). evaluate the Cauchy principal value of the integral of a previously defined function f over; the defined interval (a,b) with a singularity at c; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. double Integral(double a, double b). evaluate the Integral of a function f with known singular points over the defined Integral (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using ca",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:8580,Integrability,interface,interface,8580,"he function type must implement the mathlib::IGenFunction interface. double IntegralCauchy(double a, double b, double c). evaluate the Cauchy principal value of the integral of a previously defined function f over; the defined interval (a,b) with a singularity at c; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. double Integral(double a, double b). evaluate the Integral of a function f with known singular points over the defined Integral (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using cached function. evaluate the Integral over the defined interval (a,b) using the function previously set with GSLInte",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:8619,Integrability,integrat,integration,8619,"he function type must implement the mathlib::IGenFunction interface. double IntegralCauchy(double a, double b, double c). evaluate the Cauchy principal value of the integral of a previously defined function f over; the defined interval (a,b) with a singularity at c; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. double Integral(double a, double b). evaluate the Integral of a function f with known singular points over the defined Integral (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using cached function. evaluate the Integral over the defined interval (a,b) using the function previously set with GSLInte",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:8804,Integrability,integrat,integration,8804,"usly defined function f over; the defined interval (a,b) with a singularity at c; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. double Integral(double a, double b). evaluate the Integral of a function f with known singular points over the defined Integral (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using cached function. evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(). evaluate the Integral over the infinit",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:8885,Integrability,interface,interface,8885,"b lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. double Integral(double a, double b). evaluate the Integral of a function f with known singular points over the defined Integral (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using cached function. evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(). evaluate the Integral over the infinite interval (-inf,+inf) using the function previously set with GSLIntegrator::SetFunction method. double IntegralUp(doubl",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:8924,Integrability,integrat,integration,8924,"b lower interval value; @param c singular value of f. double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. double Integral(double a, double b). evaluate the Integral of a function f with known singular points over the defined Integral (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using cached function. evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(). evaluate the Integral over the infinite interval (-inf,+inf) using the function previously set with GSLIntegrator::SetFunction method. double IntegralUp(doubl",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:9090,Integrability,integrat,integration,9090," principal value of the integral of a function f over the defined interval (a,b); with a singularity at c; @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. double Integral(double a, double b). evaluate the Integral of a function f with known singular points over the defined Integral (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using cached function. evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(). evaluate the Integral over the infinite interval (-inf,+inf) using the function previously set with GSLIntegrator::SetFunction method. double IntegralUp(double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) using the function previously set with GSLIntegrator::SetFunction method.; @p",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:9171,Integrability,interface,interface,9171,"pe must implement the mathlib::IGenFunction interface; @param a lower interval value; @param b lower interval value; @param c singular value of f. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. double Integral(double a, double b). evaluate the Integral of a function f with known singular points over the defined Integral (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using cached function. evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(). evaluate the Integral over the infinite interval (-inf,+inf) using the function previously set with GSLIntegrator::SetFunction method. double IntegralUp(double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) using the function previously set with GSLIntegrator::SetFunction method.; @param a lower value of the integration interval. double IntegralLow(double b). evaluate the Integral of a function f over the over the semi-infinite inte",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:9348,Integrability,integrat,integration,9348,"uble IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. double Integral(double a, double b). evaluate the Integral of a function f with known singular points over the defined Integral (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using cached function. evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(). evaluate the Integral over the infinite interval (-inf,+inf) using the function previously set with GSLIntegrator::SetFunction method. double IntegralUp(double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) using the function previously set with GSLIntegrator::SetFunction method.; @param a lower value of the integration interval. double IntegralLow(double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) using the function previously set with GSLIntegrator::SetFunction method.; @param b upper value of the integration interval. double Inte",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:9636,Integrability,integrat,integration,9636,"aram a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. double Integral(double a, double b). evaluate the Integral of a function f with known singular points over the defined Integral (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using cached function. evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(). evaluate the Integral over the infinite interval (-inf,+inf) using the function previously set with GSLIntegrator::SetFunction method. double IntegralUp(double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) using the function previously set with GSLIntegrator::SetFunction method.; @param a lower value of the integration interval. double IntegralLow(double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) using the function previously set with GSLIntegrator::SetFunction method.; @param b upper value of the integration interval. double Integral( const std::vector<double> & pts). evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method. The function has known singular points.; @param pts vector containing both t",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:9686,Integrability,integrat,integration,9686,"aram a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. double Integral(double a, double b). evaluate the Integral of a function f with known singular points over the defined Integral (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using cached function. evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(). evaluate the Integral over the infinite interval (-inf,+inf) using the function previously set with GSLIntegrator::SetFunction method. double IntegralUp(double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) using the function previously set with GSLIntegrator::SetFunction method.; @param a lower value of the integration interval. double IntegralLow(double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) using the function previously set with GSLIntegrator::SetFunction method.; @param b upper value of the integration interval. double Integral( const std::vector<double> & pts). evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method. The function has known singular points.; @param pts vector containing both t",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:10073,Integrability,integrat,integration,10073,"egral (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using cached function. evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(). evaluate the Integral over the infinite interval (-inf,+inf) using the function previously set with GSLIntegrator::SetFunction method. double IntegralUp(double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) using the function previously set with GSLIntegrator::SetFunction method.; @param a lower value of the integration interval. double IntegralLow(double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) using the function previously set with GSLIntegrator::SetFunction method.; @param b upper value of the integration interval. double Integral( const std::vector<double> & pts). evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method. The function has known singular points.; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); evaluate using free function pointer (same GSL signature). signature for function pointers used by GSL. typedef double ( * GSLFuncPointer ) ( double, void * );. evaluate the Integral of of a function f over",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:10316,Integrability,integrat,integration,10316," first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using cached function. evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(). evaluate the Integral over the infinite interval (-inf,+inf) using the function previously set with GSLIntegrator::SetFunction method. double IntegralUp(double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) using the function previously set with GSLIntegrator::SetFunction method.; @param a lower value of the integration interval. double IntegralLow(double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) using the function previously set with GSLIntegrator::SetFunction method.; @param b upper value of the integration interval. double Integral( const std::vector<double> & pts). evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method. The function has known singular points.; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); evaluate using free function pointer (same GSL signature). signature for function pointers used by GSL. typedef double ( * GSLFuncPointer ) ( double, void * );. evaluate the Integral of of a function f over the defined interval (a,b) passing a free function pointer; The integration function must be a free function and have a signature consistent with GSL functions:. <em>double my_function ( double x, void * p ) { ...... } </em>. This method is t",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:10724,Integrability,integrat,integration,10724,"). evaluate the Integral over the infinite interval (-inf,+inf) using the function previously set with GSLIntegrator::SetFunction method. double IntegralUp(double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) using the function previously set with GSLIntegrator::SetFunction method.; @param a lower value of the integration interval. double IntegralLow(double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) using the function previously set with GSLIntegrator::SetFunction method.; @param b upper value of the integration interval. double Integral( const std::vector<double> & pts). evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method. The function has known singular points.; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); evaluate using free function pointer (same GSL signature). signature for function pointers used by GSL. typedef double ( * GSLFuncPointer ) ( double, void * );. evaluate the Integral of of a function f over the defined interval (a,b) passing a free function pointer; The integration function must be a free function and have a signature consistent with GSL functions:. <em>double my_function ( double x, void * p ) { ...... } </em>. This method is the most efficient since no internal adapter to GSL function is created.; @param f pointer to the integration function; @param p pointer to the Parameters of the function; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(ROOT::Math::GSLFuncPointer f, void* p). evaluate the Integral of a function f over the infinite interval (-inf,+inf) passing a",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:11134,Integrability,integrat,integration,11134,"aluate the Integral of a function f over the over the semi-infinite interval (-inf,b) using the function previously set with GSLIntegrator::SetFunction method.; @param b upper value of the integration interval. double Integral( const std::vector<double> & pts). evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method. The function has known singular points.; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); evaluate using free function pointer (same GSL signature). signature for function pointers used by GSL. typedef double ( * GSLFuncPointer ) ( double, void * );. evaluate the Integral of of a function f over the defined interval (a,b) passing a free function pointer; The integration function must be a free function and have a signature consistent with GSL functions:. <em>double my_function ( double x, void * p ) { ...... } </em>. This method is the most efficient since no internal adapter to GSL function is created.; @param f pointer to the integration function; @param p pointer to the Parameters of the function; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(ROOT::Math::GSLFuncPointer f, void* p). evaluate the Integral of a function f over the infinite interval (-inf,+inf) passing a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double I",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:11348,Integrability,adapter,adapter,11348,"ouble Integral( const std::vector<double> & pts). evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method. The function has known singular points.; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); evaluate using free function pointer (same GSL signature). signature for function pointers used by GSL. typedef double ( * GSLFuncPointer ) ( double, void * );. evaluate the Integral of of a function f over the defined interval (a,b) passing a free function pointer; The integration function must be a free function and have a signature consistent with GSL functions:. <em>double my_function ( double x, void * p ) { ...... } </em>. This method is the most efficient since no internal adapter to GSL function is created.; @param f pointer to the integration function; @param p pointer to the Parameters of the function; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(ROOT::Math::GSLFuncPointer f, void* p). evaluate the Integral of a function f over the infinite interval (-inf,+inf) passing a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts). evaluate the Integral of a function f with knows singular points over the over a defined interval passing a free function pointer. double",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:11409,Integrability,integrat,integration,11409,"GSLIntegrator::SetFunction method. The function has known singular points.; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); evaluate using free function pointer (same GSL signature). signature for function pointers used by GSL. typedef double ( * GSLFuncPointer ) ( double, void * );. evaluate the Integral of of a function f over the defined interval (a,b) passing a free function pointer; The integration function must be a free function and have a signature consistent with GSL functions:. <em>double my_function ( double x, void * p ) { ...... } </em>. This method is the most efficient since no internal adapter to GSL function is created.; @param f pointer to the integration function; @param p pointer to the Parameters of the function; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(ROOT::Math::GSLFuncPointer f, void* p). evaluate the Integral of a function f over the infinite interval (-inf,+inf) passing a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts). evaluate the Integral of a function f with knows singular points over the over a defined interval passing a free function pointer. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:11511,Integrability,integrat,integration,11511,"GSLIntegrator::SetFunction method. The function has known singular points.; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); evaluate using free function pointer (same GSL signature). signature for function pointers used by GSL. typedef double ( * GSLFuncPointer ) ( double, void * );. evaluate the Integral of of a function f over the defined interval (a,b) passing a free function pointer; The integration function must be a free function and have a signature consistent with GSL functions:. <em>double my_function ( double x, void * p ) { ...... } </em>. This method is the most efficient since no internal adapter to GSL function is created.; @param f pointer to the integration function; @param p pointer to the Parameters of the function; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(ROOT::Math::GSLFuncPointer f, void* p). evaluate the Integral of a function f over the infinite interval (-inf,+inf) passing a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts). evaluate the Integral of a function f with knows singular points over the over a defined interval passing a free function pointer. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:11561,Integrability,integrat,integration,11561,"GSLIntegrator::SetFunction method. The function has known singular points.; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); evaluate using free function pointer (same GSL signature). signature for function pointers used by GSL. typedef double ( * GSLFuncPointer ) ( double, void * );. evaluate the Integral of of a function f over the defined interval (a,b) passing a free function pointer; The integration function must be a free function and have a signature consistent with GSL functions:. <em>double my_function ( double x, void * p ) { ...... } </em>. This method is the most efficient since no internal adapter to GSL function is created.; @param f pointer to the integration function; @param p pointer to the Parameters of the function; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(ROOT::Math::GSLFuncPointer f, void* p). evaluate the Integral of a function f over the infinite interval (-inf,+inf) passing a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts). evaluate the Integral of a function f with knows singular points over the over a defined interval passing a free function pointer. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:12971,Integrability,integrat,integration,12971,"on f over the infinite interval (-inf,+inf) passing a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts). evaluate the Integral of a function f with knows singular points over the over a defined interval passing a free function pointer. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. void SetAbsTolerance(double absTolerance). set the desired absolute Error. void SetIntegrationRule(ROOT::Math::Integration::GKRule ). set the integration rule (Gauss-Kronrod rule).; The possible rules are defined in the Integration::GKRule enumeration.; The integration rule can be modified only for ADAPTIVE type integrations. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. IntegrationOneDim::Type GetType() const; get type name. { return fType; }. const char * GetTypeName() const. return the name. bool CheckFunction(); internal method to check validity of GSL function pointer.  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:13087,Integrability,integrat,integration,13087,"on f over the infinite interval (-inf,+inf) passing a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts). evaluate the Integral of a function f with knows singular points over the over a defined interval passing a free function pointer. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. void SetAbsTolerance(double absTolerance). set the desired absolute Error. void SetIntegrationRule(ROOT::Math::Integration::GKRule ). set the integration rule (Gauss-Kronrod rule).; The possible rules are defined in the Integration::GKRule enumeration.; The integration rule can be modified only for ADAPTIVE type integrations. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. IntegrationOneDim::Type GetType() const; get type name. { return fType; }. const char * GetTypeName() const. return the name. bool CheckFunction(); internal method to check validity of GSL function pointer.  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:13143,Integrability,integrat,integrations,13143,"on f over the infinite interval (-inf,+inf) passing a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts). evaluate the Integral of a function f with knows singular points over the over a defined interval passing a free function pointer. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. void SetAbsTolerance(double absTolerance). set the desired absolute Error. void SetIntegrationRule(ROOT::Math::Integration::GKRule ). set the integration rule (Gauss-Kronrod rule).; The possible rules are defined in the Integration::GKRule enumeration.; The integration rule can be modified only for ADAPTIVE type integrations. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. IntegrationOneDim::Type GetType() const; get type name. { return fType; }. const char * GetTypeName() const. return the name. bool CheckFunction(); internal method to check validity of GSL function pointer.  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:599,Modifiability,adapt,adaptive,599,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:616,Modifiability,adapt,adaptive,616,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:863,Modifiability,adapt,adaptive,863,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:6174,Modifiability,plug-in,plug-in,6174,"ule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLFuncPointer f, void* p = 0). Set function from a GSL pointer function type. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); methods using IGenFunct",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:11348,Modifiability,adapt,adapter,11348,"ouble Integral( const std::vector<double> & pts). evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method. The function has known singular points.; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(ROOT::Math::GSLFuncPointer f, void* p, double a, double b); evaluate using free function pointer (same GSL signature). signature for function pointers used by GSL. typedef double ( * GSLFuncPointer ) ( double, void * );. evaluate the Integral of of a function f over the defined interval (a,b) passing a free function pointer; The integration function must be a free function and have a signature consistent with GSL functions:. <em>double my_function ( double x, void * p ) { ...... } </em>. This method is the most efficient since no internal adapter to GSL function is created.; @param f pointer to the integration function; @param p pointer to the Parameters of the function; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(ROOT::Math::GSLFuncPointer f, void* p). evaluate the Integral of a function f over the infinite interval (-inf,+inf) passing a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts). evaluate the Integral of a function f with knows singular points over the over a defined interval passing a free function pointer. double",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:354,Performance,perform,performing,354,". ROOT::Math::GSLIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLIntegrator. class ROOT::Math::GSLIntegrator: public ROOT::Math::VirtualIntegratorOneDim. Class for performing numerical integration of a function in one dimension.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:1380,Performance,perform,performances,1380," algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html"">GSL Manual</A>. @ingroup Integration. Function Members (Methods); public:. virtual~GSLIntegrator(); virtual doubleError() const; ROOT::Math::IntegrationOneDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLIntegratorGSLIntegrator(double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, const ROOT::Math::Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); ROOT::Math::GSLIntegratorGSLIntegrator(const char* type, int rule, double absTol, double relTol, size_",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html:9463,Performance,cache,cached,9463,"n f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. double Integral(double a, double b). evaluate the Integral of a function f with known singular points over the defined Integral (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param pts vector containing both the function singular points and the lower/upper edges of the interval. The vector must have as first element the lower edge of the integration Integral ( \a a) and last element the upper value. double Integral(double a, double b); evaluate using cached function. evaluate the Integral over the defined interval (a,b) using the function previously set with GSLIntegrator::SetFunction method; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(). evaluate the Integral over the infinite interval (-inf,+inf) using the function previously set with GSLIntegrator::SetFunction method. double IntegralUp(double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) using the function previously set with GSLIntegrator::SetFunction method.; @param a lower value of the integration interval. double IntegralLow(double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) using the function previously set with GSLIntegrator::SetFunction method.; @param b upper value of the integration interval. double Integral( const std::vector<double> & pts). evaluate the Integral over the defined interval (a,b) us",MatchSource.WIKI,root/html534/ROOT__Math__GSLIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html:7193,Availability,error,error,7193,"sTolerance). set the desired absolute Error. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt). set the integration options. void SetGenerator(ROOT::Math::GSLRngWrapper* r). set random number generator. void SetType(ROOT::Math::IntegrationMultiDim::Type type). set integration method. void SetTypeName(const char* typeName). set integration method using a name instead of an enumeration. void SetMode(ROOT::Math::MCIntegration::Mode mode). set integration mode for VEGAS method; The possible MODE are :; MCIntegration::kIMPORTANCE (default) : VEGAS will use importance sampling; MCIntegration::kSTRATIFIED : VEGAS will use stratified sampling if certain condition are satisfied; MCIntegration::kIMPORTANCE_ONLY : VEGAS will always use importance smapling. void SetParameters(const VegasParameters &p). set default parameters for VEGAS method. void SetParameters(const MiserParameters &p). set default parameters for MISER method. double Sigma(). set parameters for PLAIN method. void SetPParameters(const PlainParameters &p);. returns the error sigma from the last iteration of the Vegas algorithm. double ChiSqr(). returns chi-squared per degree of freedom for the estimate of the integral in the Vegas algorithm. MCIntegration::Type GetType() const. return the type; (need to be called GetType to avois a conflict with typedef). { return fType; }. const char * GetTypeName() const. return the name. ROOT::Math::IOptions * ExtraOptions() const. get the specific options (for Vegas or Miser); in term of string- name. bool CheckFunction(); internal method to check validity of GSL function pointer. void DoInitialize(); set internally the type of integration method.  Author: Magdalena Slawinska 08/2007  Copyright (c) 2007 ROOT Foundation, CERN/PH-SFT *;  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html:383,Deployability,integrat,integration,383,". ROOT::Math::GSLMCIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLMCIntegrator. class ROOT::Math::GSLMCIntegrator: public ROOT::Math::VirtualIntegratorMultiDim. Class for performing numerical integration of a multidimensional function.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be; instantiate using the plugin manager (plugin name is ""GSLMCIntegrator""). @ingroup MCIntegration. Function Members (Methods); public:. virtual~GSLMCIntegrator(); doubleChiSqr(); virtual doubleError() const; ROOT::Math::IOptions*ExtraOptions() const; ROOT::Math::IntegrationMultiDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLMCIntegratorGSLMCIntegrator(ROOT::Math::IntegrationMultiDim::Type type = MCIntegration::kVEGAS, double absTol = 0, double relTol = 0, unsigned int calls = 0); ROOT::Math::GSLMCIntegratorGSLMCIntegrator(const char* type, double absTol, double relTol, unsigned int calls); virtual doubleIntegral(const double* a, const double* b); doubleIntegral(const ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer& f, unsigned int dim, double* a, double* b, void* p = 0); virtual intNEval() const; virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTolerance); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetFunction(ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer f, unsigned int dim, ",MatchSource.WIKI,root/html534/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html:450,Deployability,integrat,integration,450,". ROOT::Math::GSLMCIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLMCIntegrator. class ROOT::Math::GSLMCIntegrator: public ROOT::Math::VirtualIntegratorMultiDim. Class for performing numerical integration of a multidimensional function.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be; instantiate using the plugin manager (plugin name is ""GSLMCIntegrator""). @ingroup MCIntegration. Function Members (Methods); public:. virtual~GSLMCIntegrator(); doubleChiSqr(); virtual doubleError() const; ROOT::Math::IOptions*ExtraOptions() const; ROOT::Math::IntegrationMultiDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLMCIntegratorGSLMCIntegrator(ROOT::Math::IntegrationMultiDim::Type type = MCIntegration::kVEGAS, double absTol = 0, double relTol = 0, unsigned int calls = 0); ROOT::Math::GSLMCIntegratorGSLMCIntegrator(const char* type, double absTol, double relTol, unsigned int calls); virtual doubleIntegral(const double* a, const double* b); doubleIntegral(const ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer& f, unsigned int dim, double* a, double* b, void* p = 0); virtual intNEval() const; virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTolerance); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetFunction(ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer f, unsigned int dim, ",MatchSource.WIKI,root/html534/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html:550,Deployability,integrat,integration,550,". ROOT::Math::GSLMCIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLMCIntegrator. class ROOT::Math::GSLMCIntegrator: public ROOT::Math::VirtualIntegratorMultiDim. Class for performing numerical integration of a multidimensional function.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be; instantiate using the plugin manager (plugin name is ""GSLMCIntegrator""). @ingroup MCIntegration. Function Members (Methods); public:. virtual~GSLMCIntegrator(); doubleChiSqr(); virtual doubleError() const; ROOT::Math::IOptions*ExtraOptions() const; ROOT::Math::IntegrationMultiDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLMCIntegratorGSLMCIntegrator(ROOT::Math::IntegrationMultiDim::Type type = MCIntegration::kVEGAS, double absTol = 0, double relTol = 0, unsigned int calls = 0); ROOT::Math::GSLMCIntegratorGSLMCIntegrator(const char* type, double absTol, double relTol, unsigned int calls); virtual doubleIntegral(const double* a, const double* b); doubleIntegral(const ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer& f, unsigned int dim, double* a, double* b, void* p = 0); virtual intNEval() const; virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTolerance); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetFunction(ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer f, unsigned int dim, ",MatchSource.WIKI,root/html534/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html:616,Deployability,integrat,integration,616,". ROOT::Math::GSLMCIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLMCIntegrator. class ROOT::Math::GSLMCIntegrator: public ROOT::Math::VirtualIntegratorMultiDim. Class for performing numerical integration of a multidimensional function.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be; instantiate using the plugin manager (plugin name is ""GSLMCIntegrator""). @ingroup MCIntegration. Function Members (Methods); public:. virtual~GSLMCIntegrator(); doubleChiSqr(); virtual doubleError() const; ROOT::Math::IOptions*ExtraOptions() const; ROOT::Math::IntegrationMultiDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLMCIntegratorGSLMCIntegrator(ROOT::Math::IntegrationMultiDim::Type type = MCIntegration::kVEGAS, double absTol = 0, double relTol = 0, unsigned int calls = 0); ROOT::Math::GSLMCIntegratorGSLMCIntegrator(const char* type, double absTol, double relTol, unsigned int calls); virtual doubleIntegral(const double* a, const double* b); doubleIntegral(const ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer& f, unsigned int dim, double* a, double* b, void* p = 0); virtual intNEval() const; virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTolerance); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetFunction(ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer f, unsigned int dim, ",MatchSource.WIKI,root/html534/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html:657,Deployability,integrat,integration,657,". ROOT::Math::GSLMCIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLMCIntegrator. class ROOT::Math::GSLMCIntegrator: public ROOT::Math::VirtualIntegratorMultiDim. Class for performing numerical integration of a multidimensional function.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be; instantiate using the plugin manager (plugin name is ""GSLMCIntegrator""). @ingroup MCIntegration. Function Members (Methods); public:. virtual~GSLMCIntegrator(); doubleChiSqr(); virtual doubleError() const; ROOT::Math::IOptions*ExtraOptions() const; ROOT::Math::IntegrationMultiDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLMCIntegratorGSLMCIntegrator(ROOT::Math::IntegrationMultiDim::Type type = MCIntegration::kVEGAS, double absTol = 0, double relTol = 0, unsigned int calls = 0); ROOT::Math::GSLMCIntegratorGSLMCIntegrator(const char* type, double absTol, double relTol, unsigned int calls); virtual doubleIntegral(const double* a, const double* b); doubleIntegral(const ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer& f, unsigned int dim, double* a, double* b, void* p = 0); virtual intNEval() const; virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTolerance); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetFunction(ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer f, unsigned int dim, ",MatchSource.WIKI,root/html534/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html:3499,Deployability,integrat,integration,3499,"tual ROOT::Math::IntegrationMultiDim::TypeROOT::Math::VirtualIntegratorMultiDim::Type() const. protected:. boolCheckFunction(); voidDoInitialize(). private:. ROOT::Math::GSLMCIntegratorGSLMCIntegrator(const ROOT::Math::GSLMCIntegrator&); ROOT::Math::GSLMCIntegrator&operator=(const ROOT::Math::GSLMCIntegrator&). Data Members; private:. doublefAbsTol; unsigned intfCalls; unsigned intfDim; doublefError; ROOT::Math::GSLMonteFunctionWrapper*fFunction; doublefRelTol; doublefResult; ROOT::Math::GSLRngWrapper*fRng; intfStatus; ROOT::Math::IntegrationMultiDim::TypefType; ROOT::Math::GSLMCIntegrationWorkspace*fWorkspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLMCIntegrator(MCIntegration::Type type = MCIntegration::kVEGAS, double absTol = 0, double relTol = 0, unsigned int calls = 0 ); constructors; /**; constructor of GSL MCIntegrator using all the default options; *; GSLMCIntegrator( );; constructor of GSL MCIntegrator. VEGAS MC is set as default integration type. @param type type of integration. The possible types are defined in the MCIntegration::Type enumeration; Default is VEGAS; @param absTol desired absolute Error; @param relTol desired relative Error; @param calls maximum number of function calls. NOTE: When the default values are used , the options are taken from teh static method of ROOT::Math::IntegratorMultiDimOptions. GSLMCIntegrator(const char* type, double absTol, double relTol, unsigned int calls); constructor of GSL MCIntegrator. VEGAS MC is set as default integration type. @param type type of integration using a char * (required by plug-in manager); @param absTol desired absolute Error; @param relTol desired relative Error; @param calls maximum number of function calls. virtual ~GSLMCIntegrator(). destructor. GSLMCIntegrator(const ROOT::Math::GSLMCIntegrator& ); disable copy ctrs. GSLMCIntegrator & operator=(const ROOT::Math::GSLMCIntegrator& ). void SetFunction(const ROOT::Math::IMultiGenFunction& f); tem",MatchSource.WIKI,root/html534/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html:3537,Deployability,integrat,integration,3537,"ypeROOT::Math::VirtualIntegratorMultiDim::Type() const. protected:. boolCheckFunction(); voidDoInitialize(). private:. ROOT::Math::GSLMCIntegratorGSLMCIntegrator(const ROOT::Math::GSLMCIntegrator&); ROOT::Math::GSLMCIntegrator&operator=(const ROOT::Math::GSLMCIntegrator&). Data Members; private:. doublefAbsTol; unsigned intfCalls; unsigned intfDim; doublefError; ROOT::Math::GSLMonteFunctionWrapper*fFunction; doublefRelTol; doublefResult; ROOT::Math::GSLRngWrapper*fRng; intfStatus; ROOT::Math::IntegrationMultiDim::TypefType; ROOT::Math::GSLMCIntegrationWorkspace*fWorkspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLMCIntegrator(MCIntegration::Type type = MCIntegration::kVEGAS, double absTol = 0, double relTol = 0, unsigned int calls = 0 ); constructors; /**; constructor of GSL MCIntegrator using all the default options; *; GSLMCIntegrator( );; constructor of GSL MCIntegrator. VEGAS MC is set as default integration type. @param type type of integration. The possible types are defined in the MCIntegration::Type enumeration; Default is VEGAS; @param absTol desired absolute Error; @param relTol desired relative Error; @param calls maximum number of function calls. NOTE: When the default values are used , the options are taken from teh static method of ROOT::Math::IntegratorMultiDimOptions. GSLMCIntegrator(const char* type, double absTol, double relTol, unsigned int calls); constructor of GSL MCIntegrator. VEGAS MC is set as default integration type. @param type type of integration using a char * (required by plug-in manager); @param absTol desired absolute Error; @param relTol desired relative Error; @param calls maximum number of function calls. virtual ~GSLMCIntegrator(). destructor. GSLMCIntegrator(const ROOT::Math::GSLMCIntegrator& ); disable copy ctrs. GSLMCIntegrator & operator=(const ROOT::Math::GSLMCIntegrator& ). void SetFunction(const ROOT::Math::IMultiGenFunction& f); template methods for generic functors. met",MatchSource.WIKI,root/html534/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html:4035,Deployability,integrat,integration,4035,":IntegrationMultiDim::TypefType; ROOT::Math::GSLMCIntegrationWorkspace*fWorkspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLMCIntegrator(MCIntegration::Type type = MCIntegration::kVEGAS, double absTol = 0, double relTol = 0, unsigned int calls = 0 ); constructors; /**; constructor of GSL MCIntegrator using all the default options; *; GSLMCIntegrator( );; constructor of GSL MCIntegrator. VEGAS MC is set as default integration type. @param type type of integration. The possible types are defined in the MCIntegration::Type enumeration; Default is VEGAS; @param absTol desired absolute Error; @param relTol desired relative Error; @param calls maximum number of function calls. NOTE: When the default values are used , the options are taken from teh static method of ROOT::Math::IntegratorMultiDimOptions. GSLMCIntegrator(const char* type, double absTol, double relTol, unsigned int calls); constructor of GSL MCIntegrator. VEGAS MC is set as default integration type. @param type type of integration using a char * (required by plug-in manager); @param absTol desired absolute Error; @param relTol desired relative Error; @param calls maximum number of function calls. virtual ~GSLMCIntegrator(). destructor. GSLMCIntegrator(const ROOT::Math::GSLMCIntegrator& ); disable copy ctrs. GSLMCIntegrator & operator=(const ROOT::Math::GSLMCIntegrator& ). void SetFunction(const ROOT::Math::IMultiGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer f, unsigned int dim, void* p = 0). double Integral(const ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer& f, unsigned int dim, double* a, double* b, void* p = 0); methods using GSLMonteFuncPointer. evaluate the Integral of a function f over the defined",MatchSource.WIKI,root/html534/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html:4073,Deployability,integrat,integration,4073,"bers; Includes; Libraries. Function documentation; GSLMCIntegrator(MCIntegration::Type type = MCIntegration::kVEGAS, double absTol = 0, double relTol = 0, unsigned int calls = 0 ); constructors; /**; constructor of GSL MCIntegrator using all the default options; *; GSLMCIntegrator( );; constructor of GSL MCIntegrator. VEGAS MC is set as default integration type. @param type type of integration. The possible types are defined in the MCIntegration::Type enumeration; Default is VEGAS; @param absTol desired absolute Error; @param relTol desired relative Error; @param calls maximum number of function calls. NOTE: When the default values are used , the options are taken from teh static method of ROOT::Math::IntegratorMultiDimOptions. GSLMCIntegrator(const char* type, double absTol, double relTol, unsigned int calls); constructor of GSL MCIntegrator. VEGAS MC is set as default integration type. @param type type of integration using a char * (required by plug-in manager); @param absTol desired absolute Error; @param relTol desired relative Error; @param calls maximum number of function calls. virtual ~GSLMCIntegrator(). destructor. GSLMCIntegrator(const ROOT::Math::GSLMCIntegrator& ); disable copy ctrs. GSLMCIntegrator & operator=(const ROOT::Math::GSLMCIntegrator& ). void SetFunction(const ROOT::Math::IMultiGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer f, unsigned int dim, void* p = 0). double Integral(const ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer& f, unsigned int dim, double* a, double* b, void* p = 0); methods using GSLMonteFuncPointer. evaluate the Integral of a function f over the defined hypercube (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @par",MatchSource.WIKI,root/html534/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html:4558,Deployability,integrat,integration,4558,"possible types are defined in the MCIntegration::Type enumeration; Default is VEGAS; @param absTol desired absolute Error; @param relTol desired relative Error; @param calls maximum number of function calls. NOTE: When the default values are used , the options are taken from teh static method of ROOT::Math::IntegratorMultiDimOptions. GSLMCIntegrator(const char* type, double absTol, double relTol, unsigned int calls); constructor of GSL MCIntegrator. VEGAS MC is set as default integration type. @param type type of integration using a char * (required by plug-in manager); @param absTol desired absolute Error; @param relTol desired relative Error; @param calls maximum number of function calls. virtual ~GSLMCIntegrator(). destructor. GSLMCIntegrator(const ROOT::Math::GSLMCIntegrator& ); disable copy ctrs. GSLMCIntegrator & operator=(const ROOT::Math::GSLMCIntegrator& ). void SetFunction(const ROOT::Math::IMultiGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer f, unsigned int dim, void* p = 0). double Integral(const ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer& f, unsigned int dim, double* a, double* b, void* p = 0); methods using GSLMonteFuncPointer. evaluate the Integral of a function f over the defined hypercube (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const double* a, const double* b). evaluate the integral using the previously defined function. double Result() const; to be added later; double Integral(const GSLMonteFuncPointer & f);; double Integral(GSLMonteFuncPointer f, void * p, double* a, double* b);. return the type of the integr",MatchSource.WIKI,root/html534/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html:4589,Deployability,integrat,integration,4589,"gration::Type enumeration; Default is VEGAS; @param absTol desired absolute Error; @param relTol desired relative Error; @param calls maximum number of function calls. NOTE: When the default values are used , the options are taken from teh static method of ROOT::Math::IntegratorMultiDimOptions. GSLMCIntegrator(const char* type, double absTol, double relTol, unsigned int calls); constructor of GSL MCIntegrator. VEGAS MC is set as default integration type. @param type type of integration using a char * (required by plug-in manager); @param absTol desired absolute Error; @param relTol desired relative Error; @param calls maximum number of function calls. virtual ~GSLMCIntegrator(). destructor. GSLMCIntegrator(const ROOT::Math::GSLMCIntegrator& ); disable copy ctrs. GSLMCIntegrator & operator=(const ROOT::Math::GSLMCIntegrator& ). void SetFunction(const ROOT::Math::IMultiGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer f, unsigned int dim, void* p = 0). double Integral(const ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer& f, unsigned int dim, double* a, double* b, void* p = 0); methods using GSLMonteFuncPointer. evaluate the Integral of a function f over the defined hypercube (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const double* a, const double* b). evaluate the integral using the previously defined function. double Result() const; to be added later; double Integral(const GSLMonteFuncPointer & f);; double Integral(GSLMonteFuncPointer f, void * p, double* a, double* b);. return the type of the integration used. MCIntegration::Type MCType() ",MatchSource.WIKI,root/html534/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html:5057,Deployability,integrat,integration,5057," default integration type. @param type type of integration using a char * (required by plug-in manager); @param absTol desired absolute Error; @param relTol desired relative Error; @param calls maximum number of function calls. virtual ~GSLMCIntegrator(). destructor. GSLMCIntegrator(const ROOT::Math::GSLMCIntegrator& ); disable copy ctrs. GSLMCIntegrator & operator=(const ROOT::Math::GSLMCIntegrator& ). void SetFunction(const ROOT::Math::IMultiGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer f, unsigned int dim, void* p = 0). double Integral(const ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer& f, unsigned int dim, double* a, double* b, void* p = 0); methods using GSLMonteFuncPointer. evaluate the Integral of a function f over the defined hypercube (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const double* a, const double* b). evaluate the integral using the previously defined function. double Result() const; to be added later; double Integral(const GSLMonteFuncPointer & f);; double Integral(GSLMonteFuncPointer f, void * p, double* a, double* b);. return the type of the integration used. MCIntegration::Type MCType() const;. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral; (This is an fixed by the user). { return fCalls; }. void SetRelTolerance(double relTolerance); setter for cont",MatchSource.WIKI,root/html534/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html:5177,Deployability,integrat,integration,5177,"rror; @param relTol desired relative Error; @param calls maximum number of function calls. virtual ~GSLMCIntegrator(). destructor. GSLMCIntegrator(const ROOT::Math::GSLMCIntegrator& ); disable copy ctrs. GSLMCIntegrator & operator=(const ROOT::Math::GSLMCIntegrator& ). void SetFunction(const ROOT::Math::IMultiGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer f, unsigned int dim, void* p = 0). double Integral(const ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer& f, unsigned int dim, double* a, double* b, void* p = 0); methods using GSLMonteFuncPointer. evaluate the Integral of a function f over the defined hypercube (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const double* a, const double* b). evaluate the integral using the previously defined function. double Result() const; to be added later; double Integral(const GSLMonteFuncPointer & f);; double Integral(GSLMonteFuncPointer f, void * p, double* a, double* b);. return the type of the integration used. MCIntegration::Type MCType() const;. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral; (This is an fixed by the user). { return fCalls; }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. void SetAbsTolerance(double absTolerance). set the desi",MatchSource.WIKI,root/html534/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html:5227,Deployability,integrat,integration,5227,"rror; @param relTol desired relative Error; @param calls maximum number of function calls. virtual ~GSLMCIntegrator(). destructor. GSLMCIntegrator(const ROOT::Math::GSLMCIntegrator& ); disable copy ctrs. GSLMCIntegrator & operator=(const ROOT::Math::GSLMCIntegrator& ). void SetFunction(const ROOT::Math::IMultiGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer f, unsigned int dim, void* p = 0). double Integral(const ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer& f, unsigned int dim, double* a, double* b, void* p = 0); methods using GSLMonteFuncPointer. evaluate the Integral of a function f over the defined hypercube (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const double* a, const double* b). evaluate the integral using the previously defined function. double Result() const; to be added later; double Integral(const GSLMonteFuncPointer & f);; double Integral(GSLMonteFuncPointer f, void * p, double* a, double* b);. return the type of the integration used. MCIntegration::Type MCType() const;. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral; (This is an fixed by the user). { return fCalls; }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. void SetAbsTolerance(double absTolerance). set the desi",MatchSource.WIKI,root/html534/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html:5548,Deployability,integrat,integration,5548,"the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer f, unsigned int dim, void* p = 0). double Integral(const ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer& f, unsigned int dim, double* a, double* b, void* p = 0); methods using GSLMonteFuncPointer. evaluate the Integral of a function f over the defined hypercube (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const double* a, const double* b). evaluate the integral using the previously defined function. double Result() const; to be added later; double Integral(const GSLMonteFuncPointer & f);; double Integral(GSLMonteFuncPointer f, void * p, double* a, double* b);. return the type of the integration used. MCIntegration::Type MCType() const;. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral; (This is an fixed by the user). { return fCalls; }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. void SetAbsTolerance(double absTolerance). set the desired absolute Error. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt). set the integration options. void SetGenerator(ROOT::Math::GSLRngWrapper* r). set random number generator. void SetType(ROOT::Math::IntegrationMultiDim::Type type). set integration method. void SetTypeName(const char* typeName). set integration method using a name instead of an enumeration. voi",MatchSource.WIKI,root/html534/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html:6258,Deployability,integrat,integration,6258,"l(const double* a, const double* b). evaluate the integral using the previously defined function. double Result() const; to be added later; double Integral(const GSLMonteFuncPointer & f);; double Integral(GSLMonteFuncPointer f, void * p, double* a, double* b);. return the type of the integration used. MCIntegration::Type MCType() const;. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral; (This is an fixed by the user). { return fCalls; }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. void SetAbsTolerance(double absTolerance). set the desired absolute Error. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt). set the integration options. void SetGenerator(ROOT::Math::GSLRngWrapper* r). set random number generator. void SetType(ROOT::Math::IntegrationMultiDim::Type type). set integration method. void SetTypeName(const char* typeName). set integration method using a name instead of an enumeration. void SetMode(ROOT::Math::MCIntegration::Mode mode). set integration mode for VEGAS method; The possible MODE are :; MCIntegration::kIMPORTANCE (default) : VEGAS will use importance sampling; MCIntegration::kSTRATIFIED : VEGAS will use stratified sampling if certain condition are satisfied; MCIntegration::kIMPORTANCE_ONLY : VEGAS will always use importance smapling. void SetParameters(const VegasParameters &p). set default parameters for VEGAS method. void SetParameters(const MiserParameters &p). set default parameters for MISER method. double Sigma(). set parameters for PLAIN method. void SetPParameters(const PlainParameters &p);. returns the error sigma from the last iteration of the Vegas algorithm. double ChiS",MatchSource.WIKI,root/html534/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html:6419,Deployability,integrat,integration,6419,"SLMonteFuncPointer & f);; double Integral(GSLMonteFuncPointer f, void * p, double* a, double* b);. return the type of the integration used. MCIntegration::Type MCType() const;. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral; (This is an fixed by the user). { return fCalls; }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. void SetAbsTolerance(double absTolerance). set the desired absolute Error. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt). set the integration options. void SetGenerator(ROOT::Math::GSLRngWrapper* r). set random number generator. void SetType(ROOT::Math::IntegrationMultiDim::Type type). set integration method. void SetTypeName(const char* typeName). set integration method using a name instead of an enumeration. void SetMode(ROOT::Math::MCIntegration::Mode mode). set integration mode for VEGAS method; The possible MODE are :; MCIntegration::kIMPORTANCE (default) : VEGAS will use importance sampling; MCIntegration::kSTRATIFIED : VEGAS will use stratified sampling if certain condition are satisfied; MCIntegration::kIMPORTANCE_ONLY : VEGAS will always use importance smapling. void SetParameters(const VegasParameters &p). set default parameters for VEGAS method. void SetParameters(const MiserParameters &p). set default parameters for MISER method. double Sigma(). set parameters for PLAIN method. void SetPParameters(const PlainParameters &p);. returns the error sigma from the last iteration of the Vegas algorithm. double ChiSqr(). returns chi-squared per degree of freedom for the estimate of the integral in the Vegas algorithm. MCIntegration::Type GetType() const. return the type; (ne",MatchSource.WIKI,root/html534/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html:6483,Deployability,integrat,integration,6483,"a, double* b);. return the type of the integration used. MCIntegration::Type MCType() const;. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral; (This is an fixed by the user). { return fCalls; }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. void SetAbsTolerance(double absTolerance). set the desired absolute Error. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt). set the integration options. void SetGenerator(ROOT::Math::GSLRngWrapper* r). set random number generator. void SetType(ROOT::Math::IntegrationMultiDim::Type type). set integration method. void SetTypeName(const char* typeName). set integration method using a name instead of an enumeration. void SetMode(ROOT::Math::MCIntegration::Mode mode). set integration mode for VEGAS method; The possible MODE are :; MCIntegration::kIMPORTANCE (default) : VEGAS will use importance sampling; MCIntegration::kSTRATIFIED : VEGAS will use stratified sampling if certain condition are satisfied; MCIntegration::kIMPORTANCE_ONLY : VEGAS will always use importance smapling. void SetParameters(const VegasParameters &p). set default parameters for VEGAS method. void SetParameters(const MiserParameters &p). set default parameters for MISER method. double Sigma(). set parameters for PLAIN method. void SetPParameters(const PlainParameters &p);. returns the error sigma from the last iteration of the Vegas algorithm. double ChiSqr(). returns chi-squared per degree of freedom for the estimate of the integral in the Vegas algorithm. MCIntegration::Type GetType() const. return the type; (need to be called GetType to avois a conflict with typedef). { return fType; }. const ",MatchSource.WIKI,root/html534/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html:6598,Deployability,integrat,integration,6598,. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral; (This is an fixed by the user). { return fCalls; }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. void SetAbsTolerance(double absTolerance). set the desired absolute Error. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt). set the integration options. void SetGenerator(ROOT::Math::GSLRngWrapper* r). set random number generator. void SetType(ROOT::Math::IntegrationMultiDim::Type type). set integration method. void SetTypeName(const char* typeName). set integration method using a name instead of an enumeration. void SetMode(ROOT::Math::MCIntegration::Mode mode). set integration mode for VEGAS method; The possible MODE are :; MCIntegration::kIMPORTANCE (default) : VEGAS will use importance sampling; MCIntegration::kSTRATIFIED : VEGAS will use stratified sampling if certain condition are satisfied; MCIntegration::kIMPORTANCE_ONLY : VEGAS will always use importance smapling. void SetParameters(const VegasParameters &p). set default parameters for VEGAS method. void SetParameters(const MiserParameters &p). set default parameters for MISER method. double Sigma(). set parameters for PLAIN method. void SetPParameters(const PlainParameters &p);. returns the error sigma from the last iteration of the Vegas algorithm. double ChiSqr(). returns chi-squared per degree of freedom for the estimate of the integral in the Vegas algorithm. MCIntegration::Type GetType() const. return the type; (need to be called GetType to avois a conflict with typedef). { return fType; }. const char * GetTypeName() const. return the name. ROOT::Math::IOptions * ExtraOptions() const. get the specific options (for Vegas or Miser); in term of string- name. bool CheckFunction(); internal method to check validity of GSL function pointer,MatchSource.WIKI,root/html534/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html:7801,Deployability,integrat,integration,7801,"sTolerance). set the desired absolute Error. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt). set the integration options. void SetGenerator(ROOT::Math::GSLRngWrapper* r). set random number generator. void SetType(ROOT::Math::IntegrationMultiDim::Type type). set integration method. void SetTypeName(const char* typeName). set integration method using a name instead of an enumeration. void SetMode(ROOT::Math::MCIntegration::Mode mode). set integration mode for VEGAS method; The possible MODE are :; MCIntegration::kIMPORTANCE (default) : VEGAS will use importance sampling; MCIntegration::kSTRATIFIED : VEGAS will use stratified sampling if certain condition are satisfied; MCIntegration::kIMPORTANCE_ONLY : VEGAS will always use importance smapling. void SetParameters(const VegasParameters &p). set default parameters for VEGAS method. void SetParameters(const MiserParameters &p). set default parameters for MISER method. double Sigma(). set parameters for PLAIN method. void SetPParameters(const PlainParameters &p);. returns the error sigma from the last iteration of the Vegas algorithm. double ChiSqr(). returns chi-squared per degree of freedom for the estimate of the integral in the Vegas algorithm. MCIntegration::Type GetType() const. return the type; (need to be called GetType to avois a conflict with typedef). { return fType; }. const char * GetTypeName() const. return the name. ROOT::Math::IOptions * ExtraOptions() const. get the specific options (for Vegas or Miser); in term of string- name. bool CheckFunction(); internal method to check validity of GSL function pointer. void DoInitialize(); set internally the type of integration method.  Author: Magdalena Slawinska 08/2007  Copyright (c) 2007 ROOT Foundation, CERN/PH-SFT *;  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html:383,Integrability,integrat,integration,383,". ROOT::Math::GSLMCIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLMCIntegrator. class ROOT::Math::GSLMCIntegrator: public ROOT::Math::VirtualIntegratorMultiDim. Class for performing numerical integration of a multidimensional function.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be; instantiate using the plugin manager (plugin name is ""GSLMCIntegrator""). @ingroup MCIntegration. Function Members (Methods); public:. virtual~GSLMCIntegrator(); doubleChiSqr(); virtual doubleError() const; ROOT::Math::IOptions*ExtraOptions() const; ROOT::Math::IntegrationMultiDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLMCIntegratorGSLMCIntegrator(ROOT::Math::IntegrationMultiDim::Type type = MCIntegration::kVEGAS, double absTol = 0, double relTol = 0, unsigned int calls = 0); ROOT::Math::GSLMCIntegratorGSLMCIntegrator(const char* type, double absTol, double relTol, unsigned int calls); virtual doubleIntegral(const double* a, const double* b); doubleIntegral(const ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer& f, unsigned int dim, double* a, double* b, void* p = 0); virtual intNEval() const; virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTolerance); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetFunction(ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer f, unsigned int dim, ",MatchSource.WIKI,root/html534/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html:450,Integrability,integrat,integration,450,". ROOT::Math::GSLMCIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLMCIntegrator. class ROOT::Math::GSLMCIntegrator: public ROOT::Math::VirtualIntegratorMultiDim. Class for performing numerical integration of a multidimensional function.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be; instantiate using the plugin manager (plugin name is ""GSLMCIntegrator""). @ingroup MCIntegration. Function Members (Methods); public:. virtual~GSLMCIntegrator(); doubleChiSqr(); virtual doubleError() const; ROOT::Math::IOptions*ExtraOptions() const; ROOT::Math::IntegrationMultiDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLMCIntegratorGSLMCIntegrator(ROOT::Math::IntegrationMultiDim::Type type = MCIntegration::kVEGAS, double absTol = 0, double relTol = 0, unsigned int calls = 0); ROOT::Math::GSLMCIntegratorGSLMCIntegrator(const char* type, double absTol, double relTol, unsigned int calls); virtual doubleIntegral(const double* a, const double* b); doubleIntegral(const ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer& f, unsigned int dim, double* a, double* b, void* p = 0); virtual intNEval() const; virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTolerance); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetFunction(ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer f, unsigned int dim, ",MatchSource.WIKI,root/html534/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html:550,Integrability,integrat,integration,550,". ROOT::Math::GSLMCIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLMCIntegrator. class ROOT::Math::GSLMCIntegrator: public ROOT::Math::VirtualIntegratorMultiDim. Class for performing numerical integration of a multidimensional function.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be; instantiate using the plugin manager (plugin name is ""GSLMCIntegrator""). @ingroup MCIntegration. Function Members (Methods); public:. virtual~GSLMCIntegrator(); doubleChiSqr(); virtual doubleError() const; ROOT::Math::IOptions*ExtraOptions() const; ROOT::Math::IntegrationMultiDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLMCIntegratorGSLMCIntegrator(ROOT::Math::IntegrationMultiDim::Type type = MCIntegration::kVEGAS, double absTol = 0, double relTol = 0, unsigned int calls = 0); ROOT::Math::GSLMCIntegratorGSLMCIntegrator(const char* type, double absTol, double relTol, unsigned int calls); virtual doubleIntegral(const double* a, const double* b); doubleIntegral(const ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer& f, unsigned int dim, double* a, double* b, void* p = 0); virtual intNEval() const; virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTolerance); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetFunction(ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer f, unsigned int dim, ",MatchSource.WIKI,root/html534/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html:616,Integrability,integrat,integration,616,". ROOT::Math::GSLMCIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLMCIntegrator. class ROOT::Math::GSLMCIntegrator: public ROOT::Math::VirtualIntegratorMultiDim. Class for performing numerical integration of a multidimensional function.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be; instantiate using the plugin manager (plugin name is ""GSLMCIntegrator""). @ingroup MCIntegration. Function Members (Methods); public:. virtual~GSLMCIntegrator(); doubleChiSqr(); virtual doubleError() const; ROOT::Math::IOptions*ExtraOptions() const; ROOT::Math::IntegrationMultiDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLMCIntegratorGSLMCIntegrator(ROOT::Math::IntegrationMultiDim::Type type = MCIntegration::kVEGAS, double absTol = 0, double relTol = 0, unsigned int calls = 0); ROOT::Math::GSLMCIntegratorGSLMCIntegrator(const char* type, double absTol, double relTol, unsigned int calls); virtual doubleIntegral(const double* a, const double* b); doubleIntegral(const ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer& f, unsigned int dim, double* a, double* b, void* p = 0); virtual intNEval() const; virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTolerance); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetFunction(ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer f, unsigned int dim, ",MatchSource.WIKI,root/html534/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html:657,Integrability,integrat,integration,657,". ROOT::Math::GSLMCIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLMCIntegrator. class ROOT::Math::GSLMCIntegrator: public ROOT::Math::VirtualIntegratorMultiDim. Class for performing numerical integration of a multidimensional function.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be; instantiate using the plugin manager (plugin name is ""GSLMCIntegrator""). @ingroup MCIntegration. Function Members (Methods); public:. virtual~GSLMCIntegrator(); doubleChiSqr(); virtual doubleError() const; ROOT::Math::IOptions*ExtraOptions() const; ROOT::Math::IntegrationMultiDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLMCIntegratorGSLMCIntegrator(ROOT::Math::IntegrationMultiDim::Type type = MCIntegration::kVEGAS, double absTol = 0, double relTol = 0, unsigned int calls = 0); ROOT::Math::GSLMCIntegratorGSLMCIntegrator(const char* type, double absTol, double relTol, unsigned int calls); virtual doubleIntegral(const double* a, const double* b); doubleIntegral(const ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer& f, unsigned int dim, double* a, double* b, void* p = 0); virtual intNEval() const; virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTolerance); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetFunction(ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer f, unsigned int dim, ",MatchSource.WIKI,root/html534/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html:813,Integrability,interface,interface,813,". ROOT::Math::GSLMCIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLMCIntegrator. class ROOT::Math::GSLMCIntegrator: public ROOT::Math::VirtualIntegratorMultiDim. Class for performing numerical integration of a multidimensional function.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be; instantiate using the plugin manager (plugin name is ""GSLMCIntegrator""). @ingroup MCIntegration. Function Members (Methods); public:. virtual~GSLMCIntegrator(); doubleChiSqr(); virtual doubleError() const; ROOT::Math::IOptions*ExtraOptions() const; ROOT::Math::IntegrationMultiDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLMCIntegratorGSLMCIntegrator(ROOT::Math::IntegrationMultiDim::Type type = MCIntegration::kVEGAS, double absTol = 0, double relTol = 0, unsigned int calls = 0); ROOT::Math::GSLMCIntegratorGSLMCIntegrator(const char* type, double absTol, double relTol, unsigned int calls); virtual doubleIntegral(const double* a, const double* b); doubleIntegral(const ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer& f, unsigned int dim, double* a, double* b, void* p = 0); virtual intNEval() const; virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTolerance); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetFunction(ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer f, unsigned int dim, ",MatchSource.WIKI,root/html534/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html:3499,Integrability,integrat,integration,3499,"tual ROOT::Math::IntegrationMultiDim::TypeROOT::Math::VirtualIntegratorMultiDim::Type() const. protected:. boolCheckFunction(); voidDoInitialize(). private:. ROOT::Math::GSLMCIntegratorGSLMCIntegrator(const ROOT::Math::GSLMCIntegrator&); ROOT::Math::GSLMCIntegrator&operator=(const ROOT::Math::GSLMCIntegrator&). Data Members; private:. doublefAbsTol; unsigned intfCalls; unsigned intfDim; doublefError; ROOT::Math::GSLMonteFunctionWrapper*fFunction; doublefRelTol; doublefResult; ROOT::Math::GSLRngWrapper*fRng; intfStatus; ROOT::Math::IntegrationMultiDim::TypefType; ROOT::Math::GSLMCIntegrationWorkspace*fWorkspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLMCIntegrator(MCIntegration::Type type = MCIntegration::kVEGAS, double absTol = 0, double relTol = 0, unsigned int calls = 0 ); constructors; /**; constructor of GSL MCIntegrator using all the default options; *; GSLMCIntegrator( );; constructor of GSL MCIntegrator. VEGAS MC is set as default integration type. @param type type of integration. The possible types are defined in the MCIntegration::Type enumeration; Default is VEGAS; @param absTol desired absolute Error; @param relTol desired relative Error; @param calls maximum number of function calls. NOTE: When the default values are used , the options are taken from teh static method of ROOT::Math::IntegratorMultiDimOptions. GSLMCIntegrator(const char* type, double absTol, double relTol, unsigned int calls); constructor of GSL MCIntegrator. VEGAS MC is set as default integration type. @param type type of integration using a char * (required by plug-in manager); @param absTol desired absolute Error; @param relTol desired relative Error; @param calls maximum number of function calls. virtual ~GSLMCIntegrator(). destructor. GSLMCIntegrator(const ROOT::Math::GSLMCIntegrator& ); disable copy ctrs. GSLMCIntegrator & operator=(const ROOT::Math::GSLMCIntegrator& ). void SetFunction(const ROOT::Math::IMultiGenFunction& f); tem",MatchSource.WIKI,root/html534/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html:3537,Integrability,integrat,integration,3537,"ypeROOT::Math::VirtualIntegratorMultiDim::Type() const. protected:. boolCheckFunction(); voidDoInitialize(). private:. ROOT::Math::GSLMCIntegratorGSLMCIntegrator(const ROOT::Math::GSLMCIntegrator&); ROOT::Math::GSLMCIntegrator&operator=(const ROOT::Math::GSLMCIntegrator&). Data Members; private:. doublefAbsTol; unsigned intfCalls; unsigned intfDim; doublefError; ROOT::Math::GSLMonteFunctionWrapper*fFunction; doublefRelTol; doublefResult; ROOT::Math::GSLRngWrapper*fRng; intfStatus; ROOT::Math::IntegrationMultiDim::TypefType; ROOT::Math::GSLMCIntegrationWorkspace*fWorkspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLMCIntegrator(MCIntegration::Type type = MCIntegration::kVEGAS, double absTol = 0, double relTol = 0, unsigned int calls = 0 ); constructors; /**; constructor of GSL MCIntegrator using all the default options; *; GSLMCIntegrator( );; constructor of GSL MCIntegrator. VEGAS MC is set as default integration type. @param type type of integration. The possible types are defined in the MCIntegration::Type enumeration; Default is VEGAS; @param absTol desired absolute Error; @param relTol desired relative Error; @param calls maximum number of function calls. NOTE: When the default values are used , the options are taken from teh static method of ROOT::Math::IntegratorMultiDimOptions. GSLMCIntegrator(const char* type, double absTol, double relTol, unsigned int calls); constructor of GSL MCIntegrator. VEGAS MC is set as default integration type. @param type type of integration using a char * (required by plug-in manager); @param absTol desired absolute Error; @param relTol desired relative Error; @param calls maximum number of function calls. virtual ~GSLMCIntegrator(). destructor. GSLMCIntegrator(const ROOT::Math::GSLMCIntegrator& ); disable copy ctrs. GSLMCIntegrator & operator=(const ROOT::Math::GSLMCIntegrator& ). void SetFunction(const ROOT::Math::IMultiGenFunction& f); template methods for generic functors. met",MatchSource.WIKI,root/html534/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html:4035,Integrability,integrat,integration,4035,":IntegrationMultiDim::TypefType; ROOT::Math::GSLMCIntegrationWorkspace*fWorkspace. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLMCIntegrator(MCIntegration::Type type = MCIntegration::kVEGAS, double absTol = 0, double relTol = 0, unsigned int calls = 0 ); constructors; /**; constructor of GSL MCIntegrator using all the default options; *; GSLMCIntegrator( );; constructor of GSL MCIntegrator. VEGAS MC is set as default integration type. @param type type of integration. The possible types are defined in the MCIntegration::Type enumeration; Default is VEGAS; @param absTol desired absolute Error; @param relTol desired relative Error; @param calls maximum number of function calls. NOTE: When the default values are used , the options are taken from teh static method of ROOT::Math::IntegratorMultiDimOptions. GSLMCIntegrator(const char* type, double absTol, double relTol, unsigned int calls); constructor of GSL MCIntegrator. VEGAS MC is set as default integration type. @param type type of integration using a char * (required by plug-in manager); @param absTol desired absolute Error; @param relTol desired relative Error; @param calls maximum number of function calls. virtual ~GSLMCIntegrator(). destructor. GSLMCIntegrator(const ROOT::Math::GSLMCIntegrator& ); disable copy ctrs. GSLMCIntegrator & operator=(const ROOT::Math::GSLMCIntegrator& ). void SetFunction(const ROOT::Math::IMultiGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer f, unsigned int dim, void* p = 0). double Integral(const ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer& f, unsigned int dim, double* a, double* b, void* p = 0); methods using GSLMonteFuncPointer. evaluate the Integral of a function f over the defined",MatchSource.WIKI,root/html534/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html:4073,Integrability,integrat,integration,4073,"bers; Includes; Libraries. Function documentation; GSLMCIntegrator(MCIntegration::Type type = MCIntegration::kVEGAS, double absTol = 0, double relTol = 0, unsigned int calls = 0 ); constructors; /**; constructor of GSL MCIntegrator using all the default options; *; GSLMCIntegrator( );; constructor of GSL MCIntegrator. VEGAS MC is set as default integration type. @param type type of integration. The possible types are defined in the MCIntegration::Type enumeration; Default is VEGAS; @param absTol desired absolute Error; @param relTol desired relative Error; @param calls maximum number of function calls. NOTE: When the default values are used , the options are taken from teh static method of ROOT::Math::IntegratorMultiDimOptions. GSLMCIntegrator(const char* type, double absTol, double relTol, unsigned int calls); constructor of GSL MCIntegrator. VEGAS MC is set as default integration type. @param type type of integration using a char * (required by plug-in manager); @param absTol desired absolute Error; @param relTol desired relative Error; @param calls maximum number of function calls. virtual ~GSLMCIntegrator(). destructor. GSLMCIntegrator(const ROOT::Math::GSLMCIntegrator& ); disable copy ctrs. GSLMCIntegrator & operator=(const ROOT::Math::GSLMCIntegrator& ). void SetFunction(const ROOT::Math::IMultiGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer f, unsigned int dim, void* p = 0). double Integral(const ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer& f, unsigned int dim, double* a, double* b, void* p = 0); methods using GSLMonteFuncPointer. evaluate the Integral of a function f over the defined hypercube (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @par",MatchSource.WIKI,root/html534/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html:4558,Integrability,integrat,integration,4558,"possible types are defined in the MCIntegration::Type enumeration; Default is VEGAS; @param absTol desired absolute Error; @param relTol desired relative Error; @param calls maximum number of function calls. NOTE: When the default values are used , the options are taken from teh static method of ROOT::Math::IntegratorMultiDimOptions. GSLMCIntegrator(const char* type, double absTol, double relTol, unsigned int calls); constructor of GSL MCIntegrator. VEGAS MC is set as default integration type. @param type type of integration using a char * (required by plug-in manager); @param absTol desired absolute Error; @param relTol desired relative Error; @param calls maximum number of function calls. virtual ~GSLMCIntegrator(). destructor. GSLMCIntegrator(const ROOT::Math::GSLMCIntegrator& ); disable copy ctrs. GSLMCIntegrator & operator=(const ROOT::Math::GSLMCIntegrator& ). void SetFunction(const ROOT::Math::IMultiGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer f, unsigned int dim, void* p = 0). double Integral(const ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer& f, unsigned int dim, double* a, double* b, void* p = 0); methods using GSLMonteFuncPointer. evaluate the Integral of a function f over the defined hypercube (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const double* a, const double* b). evaluate the integral using the previously defined function. double Result() const; to be added later; double Integral(const GSLMonteFuncPointer & f);; double Integral(GSLMonteFuncPointer f, void * p, double* a, double* b);. return the type of the integr",MatchSource.WIKI,root/html534/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html:4589,Integrability,integrat,integration,4589,"gration::Type enumeration; Default is VEGAS; @param absTol desired absolute Error; @param relTol desired relative Error; @param calls maximum number of function calls. NOTE: When the default values are used , the options are taken from teh static method of ROOT::Math::IntegratorMultiDimOptions. GSLMCIntegrator(const char* type, double absTol, double relTol, unsigned int calls); constructor of GSL MCIntegrator. VEGAS MC is set as default integration type. @param type type of integration using a char * (required by plug-in manager); @param absTol desired absolute Error; @param relTol desired relative Error; @param calls maximum number of function calls. virtual ~GSLMCIntegrator(). destructor. GSLMCIntegrator(const ROOT::Math::GSLMCIntegrator& ); disable copy ctrs. GSLMCIntegrator & operator=(const ROOT::Math::GSLMCIntegrator& ). void SetFunction(const ROOT::Math::IMultiGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer f, unsigned int dim, void* p = 0). double Integral(const ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer& f, unsigned int dim, double* a, double* b, void* p = 0); methods using GSLMonteFuncPointer. evaluate the Integral of a function f over the defined hypercube (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const double* a, const double* b). evaluate the integral using the previously defined function. double Result() const; to be added later; double Integral(const GSLMonteFuncPointer & f);; double Integral(GSLMonteFuncPointer f, void * p, double* a, double* b);. return the type of the integration used. MCIntegration::Type MCType() ",MatchSource.WIKI,root/html534/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html:5057,Integrability,integrat,integration,5057," default integration type. @param type type of integration using a char * (required by plug-in manager); @param absTol desired absolute Error; @param relTol desired relative Error; @param calls maximum number of function calls. virtual ~GSLMCIntegrator(). destructor. GSLMCIntegrator(const ROOT::Math::GSLMCIntegrator& ); disable copy ctrs. GSLMCIntegrator & operator=(const ROOT::Math::GSLMCIntegrator& ). void SetFunction(const ROOT::Math::IMultiGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer f, unsigned int dim, void* p = 0). double Integral(const ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer& f, unsigned int dim, double* a, double* b, void* p = 0); methods using GSLMonteFuncPointer. evaluate the Integral of a function f over the defined hypercube (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const double* a, const double* b). evaluate the integral using the previously defined function. double Result() const; to be added later; double Integral(const GSLMonteFuncPointer & f);; double Integral(GSLMonteFuncPointer f, void * p, double* a, double* b);. return the type of the integration used. MCIntegration::Type MCType() const;. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral; (This is an fixed by the user). { return fCalls; }. void SetRelTolerance(double relTolerance); setter for cont",MatchSource.WIKI,root/html534/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html:5138,Integrability,interface,interface,5138,"rror; @param relTol desired relative Error; @param calls maximum number of function calls. virtual ~GSLMCIntegrator(). destructor. GSLMCIntegrator(const ROOT::Math::GSLMCIntegrator& ); disable copy ctrs. GSLMCIntegrator & operator=(const ROOT::Math::GSLMCIntegrator& ). void SetFunction(const ROOT::Math::IMultiGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer f, unsigned int dim, void* p = 0). double Integral(const ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer& f, unsigned int dim, double* a, double* b, void* p = 0); methods using GSLMonteFuncPointer. evaluate the Integral of a function f over the defined hypercube (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const double* a, const double* b). evaluate the integral using the previously defined function. double Result() const; to be added later; double Integral(const GSLMonteFuncPointer & f);; double Integral(GSLMonteFuncPointer f, void * p, double* a, double* b);. return the type of the integration used. MCIntegration::Type MCType() const;. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral; (This is an fixed by the user). { return fCalls; }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. void SetAbsTolerance(double absTolerance). set the desi",MatchSource.WIKI,root/html534/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html:5177,Integrability,integrat,integration,5177,"rror; @param relTol desired relative Error; @param calls maximum number of function calls. virtual ~GSLMCIntegrator(). destructor. GSLMCIntegrator(const ROOT::Math::GSLMCIntegrator& ); disable copy ctrs. GSLMCIntegrator & operator=(const ROOT::Math::GSLMCIntegrator& ). void SetFunction(const ROOT::Math::IMultiGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer f, unsigned int dim, void* p = 0). double Integral(const ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer& f, unsigned int dim, double* a, double* b, void* p = 0); methods using GSLMonteFuncPointer. evaluate the Integral of a function f over the defined hypercube (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const double* a, const double* b). evaluate the integral using the previously defined function. double Result() const; to be added later; double Integral(const GSLMonteFuncPointer & f);; double Integral(GSLMonteFuncPointer f, void * p, double* a, double* b);. return the type of the integration used. MCIntegration::Type MCType() const;. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral; (This is an fixed by the user). { return fCalls; }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. void SetAbsTolerance(double absTolerance). set the desi",MatchSource.WIKI,root/html534/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html:5227,Integrability,integrat,integration,5227,"rror; @param relTol desired relative Error; @param calls maximum number of function calls. virtual ~GSLMCIntegrator(). destructor. GSLMCIntegrator(const ROOT::Math::GSLMCIntegrator& ); disable copy ctrs. GSLMCIntegrator & operator=(const ROOT::Math::GSLMCIntegrator& ). void SetFunction(const ROOT::Math::IMultiGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer f, unsigned int dim, void* p = 0). double Integral(const ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer& f, unsigned int dim, double* a, double* b, void* p = 0); methods using GSLMonteFuncPointer. evaluate the Integral of a function f over the defined hypercube (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const double* a, const double* b). evaluate the integral using the previously defined function. double Result() const; to be added later; double Integral(const GSLMonteFuncPointer & f);; double Integral(GSLMonteFuncPointer f, void * p, double* a, double* b);. return the type of the integration used. MCIntegration::Type MCType() const;. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral; (This is an fixed by the user). { return fCalls; }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. void SetAbsTolerance(double absTolerance). set the desi",MatchSource.WIKI,root/html534/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html:5548,Integrability,integrat,integration,5548,"the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer f, unsigned int dim, void* p = 0). double Integral(const ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer& f, unsigned int dim, double* a, double* b, void* p = 0); methods using GSLMonteFuncPointer. evaluate the Integral of a function f over the defined hypercube (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const double* a, const double* b). evaluate the integral using the previously defined function. double Result() const; to be added later; double Integral(const GSLMonteFuncPointer & f);; double Integral(GSLMonteFuncPointer f, void * p, double* a, double* b);. return the type of the integration used. MCIntegration::Type MCType() const;. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral; (This is an fixed by the user). { return fCalls; }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. void SetAbsTolerance(double absTolerance). set the desired absolute Error. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt). set the integration options. void SetGenerator(ROOT::Math::GSLRngWrapper* r). set random number generator. void SetType(ROOT::Math::IntegrationMultiDim::Type type). set integration method. void SetTypeName(const char* typeName). set integration method using a name instead of an enumeration. voi",MatchSource.WIKI,root/html534/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html:6258,Integrability,integrat,integration,6258,"l(const double* a, const double* b). evaluate the integral using the previously defined function. double Result() const; to be added later; double Integral(const GSLMonteFuncPointer & f);; double Integral(GSLMonteFuncPointer f, void * p, double* a, double* b);. return the type of the integration used. MCIntegration::Type MCType() const;. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral; (This is an fixed by the user). { return fCalls; }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. void SetAbsTolerance(double absTolerance). set the desired absolute Error. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt). set the integration options. void SetGenerator(ROOT::Math::GSLRngWrapper* r). set random number generator. void SetType(ROOT::Math::IntegrationMultiDim::Type type). set integration method. void SetTypeName(const char* typeName). set integration method using a name instead of an enumeration. void SetMode(ROOT::Math::MCIntegration::Mode mode). set integration mode for VEGAS method; The possible MODE are :; MCIntegration::kIMPORTANCE (default) : VEGAS will use importance sampling; MCIntegration::kSTRATIFIED : VEGAS will use stratified sampling if certain condition are satisfied; MCIntegration::kIMPORTANCE_ONLY : VEGAS will always use importance smapling. void SetParameters(const VegasParameters &p). set default parameters for VEGAS method. void SetParameters(const MiserParameters &p). set default parameters for MISER method. double Sigma(). set parameters for PLAIN method. void SetPParameters(const PlainParameters &p);. returns the error sigma from the last iteration of the Vegas algorithm. double ChiS",MatchSource.WIKI,root/html534/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html:6419,Integrability,integrat,integration,6419,"SLMonteFuncPointer & f);; double Integral(GSLMonteFuncPointer f, void * p, double* a, double* b);. return the type of the integration used. MCIntegration::Type MCType() const;. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral; (This is an fixed by the user). { return fCalls; }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. void SetAbsTolerance(double absTolerance). set the desired absolute Error. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt). set the integration options. void SetGenerator(ROOT::Math::GSLRngWrapper* r). set random number generator. void SetType(ROOT::Math::IntegrationMultiDim::Type type). set integration method. void SetTypeName(const char* typeName). set integration method using a name instead of an enumeration. void SetMode(ROOT::Math::MCIntegration::Mode mode). set integration mode for VEGAS method; The possible MODE are :; MCIntegration::kIMPORTANCE (default) : VEGAS will use importance sampling; MCIntegration::kSTRATIFIED : VEGAS will use stratified sampling if certain condition are satisfied; MCIntegration::kIMPORTANCE_ONLY : VEGAS will always use importance smapling. void SetParameters(const VegasParameters &p). set default parameters for VEGAS method. void SetParameters(const MiserParameters &p). set default parameters for MISER method. double Sigma(). set parameters for PLAIN method. void SetPParameters(const PlainParameters &p);. returns the error sigma from the last iteration of the Vegas algorithm. double ChiSqr(). returns chi-squared per degree of freedom for the estimate of the integral in the Vegas algorithm. MCIntegration::Type GetType() const. return the type; (ne",MatchSource.WIKI,root/html534/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html:6483,Integrability,integrat,integration,6483,"a, double* b);. return the type of the integration used. MCIntegration::Type MCType() const;. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral; (This is an fixed by the user). { return fCalls; }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. void SetAbsTolerance(double absTolerance). set the desired absolute Error. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt). set the integration options. void SetGenerator(ROOT::Math::GSLRngWrapper* r). set random number generator. void SetType(ROOT::Math::IntegrationMultiDim::Type type). set integration method. void SetTypeName(const char* typeName). set integration method using a name instead of an enumeration. void SetMode(ROOT::Math::MCIntegration::Mode mode). set integration mode for VEGAS method; The possible MODE are :; MCIntegration::kIMPORTANCE (default) : VEGAS will use importance sampling; MCIntegration::kSTRATIFIED : VEGAS will use stratified sampling if certain condition are satisfied; MCIntegration::kIMPORTANCE_ONLY : VEGAS will always use importance smapling. void SetParameters(const VegasParameters &p). set default parameters for VEGAS method. void SetParameters(const MiserParameters &p). set default parameters for MISER method. double Sigma(). set parameters for PLAIN method. void SetPParameters(const PlainParameters &p);. returns the error sigma from the last iteration of the Vegas algorithm. double ChiSqr(). returns chi-squared per degree of freedom for the estimate of the integral in the Vegas algorithm. MCIntegration::Type GetType() const. return the type; (need to be called GetType to avois a conflict with typedef). { return fType; }. const ",MatchSource.WIKI,root/html534/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html:6598,Integrability,integrat,integration,6598,. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral; (This is an fixed by the user). { return fCalls; }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. void SetAbsTolerance(double absTolerance). set the desired absolute Error. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt). set the integration options. void SetGenerator(ROOT::Math::GSLRngWrapper* r). set random number generator. void SetType(ROOT::Math::IntegrationMultiDim::Type type). set integration method. void SetTypeName(const char* typeName). set integration method using a name instead of an enumeration. void SetMode(ROOT::Math::MCIntegration::Mode mode). set integration mode for VEGAS method; The possible MODE are :; MCIntegration::kIMPORTANCE (default) : VEGAS will use importance sampling; MCIntegration::kSTRATIFIED : VEGAS will use stratified sampling if certain condition are satisfied; MCIntegration::kIMPORTANCE_ONLY : VEGAS will always use importance smapling. void SetParameters(const VegasParameters &p). set default parameters for VEGAS method. void SetParameters(const MiserParameters &p). set default parameters for MISER method. double Sigma(). set parameters for PLAIN method. void SetPParameters(const PlainParameters &p);. returns the error sigma from the last iteration of the Vegas algorithm. double ChiSqr(). returns chi-squared per degree of freedom for the estimate of the integral in the Vegas algorithm. MCIntegration::Type GetType() const. return the type; (need to be called GetType to avois a conflict with typedef). { return fType; }. const char * GetTypeName() const. return the name. ROOT::Math::IOptions * ExtraOptions() const. get the specific options (for Vegas or Miser); in term of string- name. bool CheckFunction(); internal method to check validity of GSL function pointer,MatchSource.WIKI,root/html534/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html:7801,Integrability,integrat,integration,7801,"sTolerance). set the desired absolute Error. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt). set the integration options. void SetGenerator(ROOT::Math::GSLRngWrapper* r). set random number generator. void SetType(ROOT::Math::IntegrationMultiDim::Type type). set integration method. void SetTypeName(const char* typeName). set integration method using a name instead of an enumeration. void SetMode(ROOT::Math::MCIntegration::Mode mode). set integration mode for VEGAS method; The possible MODE are :; MCIntegration::kIMPORTANCE (default) : VEGAS will use importance sampling; MCIntegration::kSTRATIFIED : VEGAS will use stratified sampling if certain condition are satisfied; MCIntegration::kIMPORTANCE_ONLY : VEGAS will always use importance smapling. void SetParameters(const VegasParameters &p). set default parameters for VEGAS method. void SetParameters(const MiserParameters &p). set default parameters for MISER method. double Sigma(). set parameters for PLAIN method. void SetPParameters(const PlainParameters &p);. returns the error sigma from the last iteration of the Vegas algorithm. double ChiSqr(). returns chi-squared per degree of freedom for the estimate of the integral in the Vegas algorithm. MCIntegration::Type GetType() const. return the type; (need to be called GetType to avois a conflict with typedef). { return fType; }. const char * GetTypeName() const. return the name. ROOT::Math::IOptions * ExtraOptions() const. get the specific options (for Vegas or Miser); in term of string- name. bool CheckFunction(); internal method to check validity of GSL function pointer. void DoInitialize(); set internally the type of integration method.  Author: Magdalena Slawinska 08/2007  Copyright (c) 2007 ROOT Foundation, CERN/PH-SFT *;  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html:897,Modifiability,plugin,plugin,897,". ROOT::Math::GSLMCIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLMCIntegrator. class ROOT::Math::GSLMCIntegrator: public ROOT::Math::VirtualIntegratorMultiDim. Class for performing numerical integration of a multidimensional function.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be; instantiate using the plugin manager (plugin name is ""GSLMCIntegrator""). @ingroup MCIntegration. Function Members (Methods); public:. virtual~GSLMCIntegrator(); doubleChiSqr(); virtual doubleError() const; ROOT::Math::IOptions*ExtraOptions() const; ROOT::Math::IntegrationMultiDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLMCIntegratorGSLMCIntegrator(ROOT::Math::IntegrationMultiDim::Type type = MCIntegration::kVEGAS, double absTol = 0, double relTol = 0, unsigned int calls = 0); ROOT::Math::GSLMCIntegratorGSLMCIntegrator(const char* type, double absTol, double relTol, unsigned int calls); virtual doubleIntegral(const double* a, const double* b); doubleIntegral(const ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer& f, unsigned int dim, double* a, double* b, void* p = 0); virtual intNEval() const; virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTolerance); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetFunction(ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer f, unsigned int dim, ",MatchSource.WIKI,root/html534/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html:913,Modifiability,plugin,plugin,913,". ROOT::Math::GSLMCIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLMCIntegrator. class ROOT::Math::GSLMCIntegrator: public ROOT::Math::VirtualIntegratorMultiDim. Class for performing numerical integration of a multidimensional function.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be; instantiate using the plugin manager (plugin name is ""GSLMCIntegrator""). @ingroup MCIntegration. Function Members (Methods); public:. virtual~GSLMCIntegrator(); doubleChiSqr(); virtual doubleError() const; ROOT::Math::IOptions*ExtraOptions() const; ROOT::Math::IntegrationMultiDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLMCIntegratorGSLMCIntegrator(ROOT::Math::IntegrationMultiDim::Type type = MCIntegration::kVEGAS, double absTol = 0, double relTol = 0, unsigned int calls = 0); ROOT::Math::GSLMCIntegratorGSLMCIntegrator(const char* type, double absTol, double relTol, unsigned int calls); virtual doubleIntegral(const double* a, const double* b); doubleIntegral(const ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer& f, unsigned int dim, double* a, double* b, void* p = 0); virtual intNEval() const; virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTolerance); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetFunction(ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer f, unsigned int dim, ",MatchSource.WIKI,root/html534/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html:4113,Modifiability,plug-in,plug-in,4113,"bers; Includes; Libraries. Function documentation; GSLMCIntegrator(MCIntegration::Type type = MCIntegration::kVEGAS, double absTol = 0, double relTol = 0, unsigned int calls = 0 ); constructors; /**; constructor of GSL MCIntegrator using all the default options; *; GSLMCIntegrator( );; constructor of GSL MCIntegrator. VEGAS MC is set as default integration type. @param type type of integration. The possible types are defined in the MCIntegration::Type enumeration; Default is VEGAS; @param absTol desired absolute Error; @param relTol desired relative Error; @param calls maximum number of function calls. NOTE: When the default values are used , the options are taken from teh static method of ROOT::Math::IntegratorMultiDimOptions. GSLMCIntegrator(const char* type, double absTol, double relTol, unsigned int calls); constructor of GSL MCIntegrator. VEGAS MC is set as default integration type. @param type type of integration using a char * (required by plug-in manager); @param absTol desired absolute Error; @param relTol desired relative Error; @param calls maximum number of function calls. virtual ~GSLMCIntegrator(). destructor. GSLMCIntegrator(const ROOT::Math::GSLMCIntegrator& ); disable copy ctrs. GSLMCIntegrator & operator=(const ROOT::Math::GSLMCIntegrator& ). void SetFunction(const ROOT::Math::IMultiGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function type must implement the assigment operator, <em> double operator() ( double x ) </em>. void SetFunction(ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer f, unsigned int dim, void* p = 0). double Integral(const ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer& f, unsigned int dim, double* a, double* b, void* p = 0); methods using GSLMonteFuncPointer. evaluate the Integral of a function f over the defined hypercube (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @par",MatchSource.WIKI,root/html534/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html:362,Performance,perform,performing,362,". ROOT::Math::GSLMCIntegrator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLMCIntegrator. class ROOT::Math::GSLMCIntegrator: public ROOT::Math::VirtualIntegratorMultiDim. Class for performing numerical integration of a multidimensional function.; It uses the numerical integration algorithms of GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. It implements also the interface ROOT::Math::VirtualIntegratorMultiDim so it can be; instantiate using the plugin manager (plugin name is ""GSLMCIntegrator""). @ingroup MCIntegration. Function Members (Methods); public:. virtual~GSLMCIntegrator(); doubleChiSqr(); virtual doubleError() const; ROOT::Math::IOptions*ExtraOptions() const; ROOT::Math::IntegrationMultiDim::TypeGetType() const; const char*GetTypeName() const; ROOT::Math::GSLMCIntegratorGSLMCIntegrator(ROOT::Math::IntegrationMultiDim::Type type = MCIntegration::kVEGAS, double absTol = 0, double relTol = 0, unsigned int calls = 0); ROOT::Math::GSLMCIntegratorGSLMCIntegrator(const char* type, double absTol, double relTol, unsigned int calls); virtual doubleIntegral(const double* a, const double* b); doubleIntegral(const ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer& f, unsigned int dim, double* a, double* b, void* p = 0); virtual intNEval() const; virtual ROOT::Math::IntegratorMultiDimOptionsOptions() const; virtual doubleResult() const; virtual voidSetAbsTolerance(double absTolerance); virtual voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetFunction(ROOT::Math::GSLMCIntegrator::GSLMonteFuncPointer f, unsigned int dim, ",MatchSource.WIKI,root/html534/ROOT__Math__GSLMCIntegrator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMCIntegrator.html
https://root.cern/root/html534/ROOT__Math__GSLMinimizer.html:7021,Availability,error,errors,7021,"nction*ROOT::Math::BasicMinimizer::TransformFunction() const; virtual intROOT::Math::BasicMinimizer::VariableIndex(const string& name) const; virtual stringROOT::Math::BasicMinimizer::VariableName(unsigned int ivar) const; virtual const double*ROOT::Math::BasicMinimizer::X() const. protected:. boolROOT::Math::BasicMinimizer::CheckDimension() const; boolROOT::Math::BasicMinimizer::CheckObjFunction() const; ROOT::Math::MinimTransformFunction*ROOT::Math::BasicMinimizer::CreateTransformation(vector<double>& startValues, const ROOT::Math::IMultiGradFunction* func = 0); voidROOT::Math::BasicMinimizer::SetFinalValues(const double* x); voidROOT::Math::BasicMinimizer::SetMinValue(double val). private:. ROOT::Math::GSLMinimizerGSLMinimizer(const ROOT::Math::GSLMinimizer&); ROOT::Math::GSLMinimizer&operator=(const ROOT::Math::GSLMinimizer& rhs). Data Members; protected:. ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::fOptionsminimizer options; intROOT::Math::Minimizer::fStatusstatus of minimizer ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. ROOT::Math::GSLMultiMinimizer*fGSLMultiMin; doublefLSToleranceLine Search Tolerance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLMinimizer(ROOT::Math::EGSLMinimizerType type = ROOT::Math::kConjugateFR). Default constructor. GSLMinimizer(const char* type). Constructor with a string giving name of algorithm. virtual ~GSLMinimizer(). Destructor. GSLMinimizer(const ROOT::Math::GSLMinimizer& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. {}. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set the function to minimize. { BasicMinimizer::SetFunction(func);}. bool Minimize(); method to perform the minimization. double Edm() const; return expected distance reached from t",MatchSource.WIKI,root/html534/ROOT__Math__GSLMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMinimizer.html
https://root.cern/root/html534/ROOT__Math__GSLMinimizer.html:8180,Availability,error,error,8180," protected:. ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::fOptionsminimizer options; intROOT::Math::Minimizer::fStatusstatus of minimizer ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. ROOT::Math::GSLMultiMinimizer*fGSLMultiMin; doublefLSToleranceLine Search Tolerance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLMinimizer(ROOT::Math::EGSLMinimizerType type = ROOT::Math::kConjugateFR). Default constructor. GSLMinimizer(const char* type). Constructor with a string giving name of algorithm. virtual ~GSLMinimizer(). Destructor. GSLMinimizer(const ROOT::Math::GSLMinimizer& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. {}. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set the function to minimize. { BasicMinimizer::SetFunction(func);}. bool Minimize(); method to perform the minimization. double Edm() const; return expected distance reached from the minimum. const double * MinGradient() const; return pointer to gradient values at the minimum. unsigned int NCalls() const; number of function calls to reach the minimum. bool ProvidesError() const; minimizer provides error and error matrix. { return false; }. const double * Errors() const; return errors at the minimum. double CovMatrix(unsigned int , unsigned int ) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. { return 0; }.  Author: L. Moneta Wed Oct 18 11:48:00 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__GSLMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMinimizer.html
https://root.cern/root/html534/ROOT__Math__GSLMinimizer.html:8190,Availability,error,error,8190," protected:. ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::fOptionsminimizer options; intROOT::Math::Minimizer::fStatusstatus of minimizer ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. ROOT::Math::GSLMultiMinimizer*fGSLMultiMin; doublefLSToleranceLine Search Tolerance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLMinimizer(ROOT::Math::EGSLMinimizerType type = ROOT::Math::kConjugateFR). Default constructor. GSLMinimizer(const char* type). Constructor with a string giving name of algorithm. virtual ~GSLMinimizer(). Destructor. GSLMinimizer(const ROOT::Math::GSLMinimizer& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. {}. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set the function to minimize. { BasicMinimizer::SetFunction(func);}. bool Minimize(); method to perform the minimization. double Edm() const; return expected distance reached from the minimum. const double * MinGradient() const; return pointer to gradient values at the minimum. unsigned int NCalls() const; number of function calls to reach the minimum. bool ProvidesError() const; minimizer provides error and error matrix. { return false; }. const double * Errors() const; return errors at the minimum. double CovMatrix(unsigned int , unsigned int ) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. { return 0; }.  Author: L. Moneta Wed Oct 18 11:48:00 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__GSLMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMinimizer.html
https://root.cern/root/html534/ROOT__Math__GSLMinimizer.html:8261,Availability,error,errors,8261," protected:. ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::fOptionsminimizer options; intROOT::Math::Minimizer::fStatusstatus of minimizer ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. ROOT::Math::GSLMultiMinimizer*fGSLMultiMin; doublefLSToleranceLine Search Tolerance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLMinimizer(ROOT::Math::EGSLMinimizerType type = ROOT::Math::kConjugateFR). Default constructor. GSLMinimizer(const char* type). Constructor with a string giving name of algorithm. virtual ~GSLMinimizer(). Destructor. GSLMinimizer(const ROOT::Math::GSLMinimizer& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. {}. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set the function to minimize. { BasicMinimizer::SetFunction(func);}. bool Minimize(); method to perform the minimization. double Edm() const; return expected distance reached from the minimum. const double * MinGradient() const; return pointer to gradient values at the minimum. unsigned int NCalls() const; number of function calls to reach the minimum. bool ProvidesError() const; minimizer provides error and error matrix. { return false; }. const double * Errors() const; return errors at the minimum. double CovMatrix(unsigned int , unsigned int ) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. { return 0; }.  Author: L. Moneta Wed Oct 18 11:48:00 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__GSLMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMinimizer.html
https://root.cern/root/html534/ROOT__Math__GSLMinimizer.html:8468,Availability,error,errors,8468," protected:. ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::fOptionsminimizer options; intROOT::Math::Minimizer::fStatusstatus of minimizer ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. ROOT::Math::GSLMultiMinimizer*fGSLMultiMin; doublefLSToleranceLine Search Tolerance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLMinimizer(ROOT::Math::EGSLMinimizerType type = ROOT::Math::kConjugateFR). Default constructor. GSLMinimizer(const char* type). Constructor with a string giving name of algorithm. virtual ~GSLMinimizer(). Destructor. GSLMinimizer(const ROOT::Math::GSLMinimizer& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. {}. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set the function to minimize. { BasicMinimizer::SetFunction(func);}. bool Minimize(); method to perform the minimization. double Edm() const; return expected distance reached from the minimum. const double * MinGradient() const; return pointer to gradient values at the minimum. unsigned int NCalls() const; number of function calls to reach the minimum. bool ProvidesError() const; minimizer provides error and error matrix. { return false; }. const double * Errors() const; return errors at the minimum. double CovMatrix(unsigned int , unsigned int ) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. { return 0; }.  Author: L. Moneta Wed Oct 18 11:48:00 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__GSLMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMinimizer.html
https://root.cern/root/html534/ROOT__Math__GSLMinimizer.html:397,Integrability,interface,interface,397,". ROOT::Math::GSLMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLMinimizer. class ROOT::Math::GSLMinimizer: public ROOT::Math::BasicMinimizer. GSLMinimizer class.; Implementation of the ROOT::Math::Minimizer interface using the GSL multi-dimensional; minimization algorithms. See <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Multidimensional-Minimization.html"">GSL doc</A>; from more info on the GSL minimization algorithms. The class implements the ROOT::Math::Minimizer interface and can be instantiated using the; ROOT plugin manager (plugin name is ""GSLMultiMin""). The varius minimization algorithms; (conjugatefr, conjugatepr, bfgs, etc..) can be passed as enumerations and also as a string.; The default algorithm is conjugatefr (Fletcher-Reeves conjugate gradient algorithm). @ingroup MultiMin. Function Members (Methods); public:. virtual~GSLMinimizer(); ROOT::Math::BasicMinimizerROOT::Math::BasicMinimizer::BasicMinimizer(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolROOT::Math::Minimizer::Contour(unsigned int ivar, unsigned int jvar, unsigned int& npoints, double* xi, double* xj); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int, unsigned int) const; virtual intROOT::Math::Minimizer::CovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolROOT::Math::BasicMinimizer::FixVariable(unsigned int ivar); virtual boolROOT::Math::Minimizer::GetCovMatrix(double* covMat) const; virtual boolROOT::Math::Minimizer::GetHessianMatrix(double* hMat) const; virtual boolROOT::Math::Minimizer::GetMinosError(unsigned int ivar, double& errLow, double& errUp, int option = 0); virtual boolROOT::Math::BasicMinimizer::Ge",MatchSource.WIKI,root/html534/ROOT__Math__GSLMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMinimizer.html
https://root.cern/root/html534/ROOT__Math__GSLMinimizer.html:674,Integrability,interface,interface,674,". ROOT::Math::GSLMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLMinimizer. class ROOT::Math::GSLMinimizer: public ROOT::Math::BasicMinimizer. GSLMinimizer class.; Implementation of the ROOT::Math::Minimizer interface using the GSL multi-dimensional; minimization algorithms. See <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Multidimensional-Minimization.html"">GSL doc</A>; from more info on the GSL minimization algorithms. The class implements the ROOT::Math::Minimizer interface and can be instantiated using the; ROOT plugin manager (plugin name is ""GSLMultiMin""). The varius minimization algorithms; (conjugatefr, conjugatepr, bfgs, etc..) can be passed as enumerations and also as a string.; The default algorithm is conjugatefr (Fletcher-Reeves conjugate gradient algorithm). @ingroup MultiMin. Function Members (Methods); public:. virtual~GSLMinimizer(); ROOT::Math::BasicMinimizerROOT::Math::BasicMinimizer::BasicMinimizer(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolROOT::Math::Minimizer::Contour(unsigned int ivar, unsigned int jvar, unsigned int& npoints, double* xi, double* xj); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int, unsigned int) const; virtual intROOT::Math::Minimizer::CovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolROOT::Math::BasicMinimizer::FixVariable(unsigned int ivar); virtual boolROOT::Math::Minimizer::GetCovMatrix(double* covMat) const; virtual boolROOT::Math::Minimizer::GetHessianMatrix(double* hMat) const; virtual boolROOT::Math::Minimizer::GetMinosError(unsigned int ivar, double& errLow, double& errUp, int option = 0); virtual boolROOT::Math::BasicMinimizer::Ge",MatchSource.WIKI,root/html534/ROOT__Math__GSLMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMinimizer.html
https://root.cern/root/html534/ROOT__Math__GSLMinimizer.html:724,Modifiability,plugin,plugin,724,". ROOT::Math::GSLMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLMinimizer. class ROOT::Math::GSLMinimizer: public ROOT::Math::BasicMinimizer. GSLMinimizer class.; Implementation of the ROOT::Math::Minimizer interface using the GSL multi-dimensional; minimization algorithms. See <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Multidimensional-Minimization.html"">GSL doc</A>; from more info on the GSL minimization algorithms. The class implements the ROOT::Math::Minimizer interface and can be instantiated using the; ROOT plugin manager (plugin name is ""GSLMultiMin""). The varius minimization algorithms; (conjugatefr, conjugatepr, bfgs, etc..) can be passed as enumerations and also as a string.; The default algorithm is conjugatefr (Fletcher-Reeves conjugate gradient algorithm). @ingroup MultiMin. Function Members (Methods); public:. virtual~GSLMinimizer(); ROOT::Math::BasicMinimizerROOT::Math::BasicMinimizer::BasicMinimizer(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolROOT::Math::Minimizer::Contour(unsigned int ivar, unsigned int jvar, unsigned int& npoints, double* xi, double* xj); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int, unsigned int) const; virtual intROOT::Math::Minimizer::CovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolROOT::Math::BasicMinimizer::FixVariable(unsigned int ivar); virtual boolROOT::Math::Minimizer::GetCovMatrix(double* covMat) const; virtual boolROOT::Math::Minimizer::GetHessianMatrix(double* hMat) const; virtual boolROOT::Math::Minimizer::GetMinosError(unsigned int ivar, double& errLow, double& errUp, int option = 0); virtual boolROOT::Math::BasicMinimizer::Ge",MatchSource.WIKI,root/html534/ROOT__Math__GSLMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMinimizer.html
https://root.cern/root/html534/ROOT__Math__GSLMinimizer.html:740,Modifiability,plugin,plugin,740,". ROOT::Math::GSLMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLMinimizer. class ROOT::Math::GSLMinimizer: public ROOT::Math::BasicMinimizer. GSLMinimizer class.; Implementation of the ROOT::Math::Minimizer interface using the GSL multi-dimensional; minimization algorithms. See <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Multidimensional-Minimization.html"">GSL doc</A>; from more info on the GSL minimization algorithms. The class implements the ROOT::Math::Minimizer interface and can be instantiated using the; ROOT plugin manager (plugin name is ""GSLMultiMin""). The varius minimization algorithms; (conjugatefr, conjugatepr, bfgs, etc..) can be passed as enumerations and also as a string.; The default algorithm is conjugatefr (Fletcher-Reeves conjugate gradient algorithm). @ingroup MultiMin. Function Members (Methods); public:. virtual~GSLMinimizer(); ROOT::Math::BasicMinimizerROOT::Math::BasicMinimizer::BasicMinimizer(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolROOT::Math::Minimizer::Contour(unsigned int ivar, unsigned int jvar, unsigned int& npoints, double* xi, double* xj); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int, unsigned int) const; virtual intROOT::Math::Minimizer::CovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolROOT::Math::BasicMinimizer::FixVariable(unsigned int ivar); virtual boolROOT::Math::Minimizer::GetCovMatrix(double* covMat) const; virtual boolROOT::Math::Minimizer::GetHessianMatrix(double* hMat) const; virtual boolROOT::Math::Minimizer::GetMinosError(unsigned int ivar, double& errLow, double& errUp, int option = 0); virtual boolROOT::Math::BasicMinimizer::Ge",MatchSource.WIKI,root/html534/ROOT__Math__GSLMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMinimizer.html
https://root.cern/root/html534/ROOT__Math__GSLMinimizer.html:8382,Modifiability,variab,variable,8382," protected:. ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::fOptionsminimizer options; intROOT::Math::Minimizer::fStatusstatus of minimizer ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. ROOT::Math::GSLMultiMinimizer*fGSLMultiMin; doublefLSToleranceLine Search Tolerance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLMinimizer(ROOT::Math::EGSLMinimizerType type = ROOT::Math::kConjugateFR). Default constructor. GSLMinimizer(const char* type). Constructor with a string giving name of algorithm. virtual ~GSLMinimizer(). Destructor. GSLMinimizer(const ROOT::Math::GSLMinimizer& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. {}. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set the function to minimize. { BasicMinimizer::SetFunction(func);}. bool Minimize(); method to perform the minimization. double Edm() const; return expected distance reached from the minimum. const double * MinGradient() const; return pointer to gradient values at the minimum. unsigned int NCalls() const; number of function calls to reach the minimum. bool ProvidesError() const; minimizer provides error and error matrix. { return false; }. const double * Errors() const; return errors at the minimum. double CovMatrix(unsigned int , unsigned int ) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. { return 0; }.  Author: L. Moneta Wed Oct 18 11:48:00 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__GSLMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMinimizer.html
https://root.cern/root/html534/ROOT__Math__GSLMinimizer.html:8440,Modifiability,variab,variables,8440," protected:. ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::fOptionsminimizer options; intROOT::Math::Minimizer::fStatusstatus of minimizer ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. ROOT::Math::GSLMultiMinimizer*fGSLMultiMin; doublefLSToleranceLine Search Tolerance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLMinimizer(ROOT::Math::EGSLMinimizerType type = ROOT::Math::kConjugateFR). Default constructor. GSLMinimizer(const char* type). Constructor with a string giving name of algorithm. virtual ~GSLMinimizer(). Destructor. GSLMinimizer(const ROOT::Math::GSLMinimizer& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. {}. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set the function to minimize. { BasicMinimizer::SetFunction(func);}. bool Minimize(); method to perform the minimization. double Edm() const; return expected distance reached from the minimum. const double * MinGradient() const; return pointer to gradient values at the minimum. unsigned int NCalls() const; number of function calls to reach the minimum. bool ProvidesError() const; minimizer provides error and error matrix. { return false; }. const double * Errors() const; return errors at the minimum. double CovMatrix(unsigned int , unsigned int ) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. { return 0; }.  Author: L. Moneta Wed Oct 18 11:48:00 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__GSLMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMinimizer.html
https://root.cern/root/html534/ROOT__Math__GSLMinimizer.html:7874,Performance,perform,perform,7874," protected:. ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::fOptionsminimizer options; intROOT::Math::Minimizer::fStatusstatus of minimizer ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. ROOT::Math::GSLMultiMinimizer*fGSLMultiMin; doublefLSToleranceLine Search Tolerance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLMinimizer(ROOT::Math::EGSLMinimizerType type = ROOT::Math::kConjugateFR). Default constructor. GSLMinimizer(const char* type). Constructor with a string giving name of algorithm. virtual ~GSLMinimizer(). Destructor. GSLMinimizer(const ROOT::Math::GSLMinimizer& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. {}. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set the function to minimize. { BasicMinimizer::SetFunction(func);}. bool Minimize(); method to perform the minimization. double Edm() const; return expected distance reached from the minimum. const double * MinGradient() const; return pointer to gradient values at the minimum. unsigned int NCalls() const; number of function calls to reach the minimum. bool ProvidesError() const; minimizer provides error and error matrix. { return false; }. const double * Errors() const; return errors at the minimum. double CovMatrix(unsigned int , unsigned int ) const; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. { return 0; }.  Author: L. Moneta Wed Oct 18 11:48:00 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__GSLMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMinimizer.html
https://root.cern/root/html534/ROOT__Math__GSLMinimizer.html:7038,Security,validat,validated,7038,"nction*ROOT::Math::BasicMinimizer::TransformFunction() const; virtual intROOT::Math::BasicMinimizer::VariableIndex(const string& name) const; virtual stringROOT::Math::BasicMinimizer::VariableName(unsigned int ivar) const; virtual const double*ROOT::Math::BasicMinimizer::X() const. protected:. boolROOT::Math::BasicMinimizer::CheckDimension() const; boolROOT::Math::BasicMinimizer::CheckObjFunction() const; ROOT::Math::MinimTransformFunction*ROOT::Math::BasicMinimizer::CreateTransformation(vector<double>& startValues, const ROOT::Math::IMultiGradFunction* func = 0); voidROOT::Math::BasicMinimizer::SetFinalValues(const double* x); voidROOT::Math::BasicMinimizer::SetMinValue(double val). private:. ROOT::Math::GSLMinimizerGSLMinimizer(const ROOT::Math::GSLMinimizer&); ROOT::Math::GSLMinimizer&operator=(const ROOT::Math::GSLMinimizer& rhs). Data Members; protected:. ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::fOptionsminimizer options; intROOT::Math::Minimizer::fStatusstatus of minimizer ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. ROOT::Math::GSLMultiMinimizer*fGSLMultiMin; doublefLSToleranceLine Search Tolerance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLMinimizer(ROOT::Math::EGSLMinimizerType type = ROOT::Math::kConjugateFR). Default constructor. GSLMinimizer(const char* type). Constructor with a string giving name of algorithm. virtual ~GSLMinimizer(). Destructor. GSLMinimizer(const ROOT::Math::GSLMinimizer& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. {}. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set the function to minimize. { BasicMinimizer::SetFunction(func);}. bool Minimize(); method to perform the minimization. double Edm() const; return expected distance reached from t",MatchSource.WIKI,root/html534/ROOT__Math__GSLMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMinimizer.html
https://root.cern/root/html534/ROOT__Math__GSLMinimizer1D.html:2832,Availability,error,error,2832,"h::GSLFunctionWrapper*fFunction; boolfIsSet; intfIter; doublefLow; doublefMin; ROOT::Math::GSL1DMinimizerWrapper*fMinimizer; intfStatusstatus of last minimization (==0 ok =1 failed); doublefUp; doublefXlow; doublefXmin; doublefXup. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; explicit GSLMinimizer1D(Minim1D::Type type=Minim1D::kBRENT). Construct the minimizer passing the minimizer type using the Minim1D::Algorithm enumeration. virtual ~GSLMinimizer1D(). Destructor: free allocated resources. GSLMinimizer1D(const GSLMinimizer1D &); usually copying is non trivial, so we make this unaccessible. void SetFunction( const UserFunc & f, double xmin, double xlow, double xup). Set, or reset, minimizer to use the function f and the initial search interval [xlow, xup], with a guess for the location of the minimum xmin.; The condition : \f$ f(xlow) > f(xmin) < f(xup)\f$ must be satisfied. int Iterate(). Perform a minimizer iteration and; if an unexepcted problem occurr then an error code will be returned. double XMinimum() const. Return current estimate of the position of the minimum. double XLower() const. Return current lower bound of the minimization interval. double XUpper() const. Return current upper bound of the minimization interval. double FValMinimum() const. Return function value at current estimate of the minimum. double FValLower() const. Return function value at current lower bound of the minimization interval. double FValUpper() const. Return function value at current upper bound of the minimization interval. bool Minimize(int maxIter, double absTol, double relTol). Find minimum position iterating until convergence specified by the absolute and relative tolerance or; the maximum number of iteration is reached; Return true is result is successfull; \@param maxIter maximum number of iteration; \@param absTol desired absolute error in the minimum position; \@param absTol desired relative error in the minimum position. int ",MatchSource.WIKI,root/html534/ROOT__Math__GSLMinimizer1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMinimizer1D.html
https://root.cern/root/html534/ROOT__Math__GSLMinimizer1D.html:3537,Availability,toler,tolerance,3537,"et, or reset, minimizer to use the function f and the initial search interval [xlow, xup], with a guess for the location of the minimum xmin.; The condition : \f$ f(xlow) > f(xmin) < f(xup)\f$ must be satisfied. int Iterate(). Perform a minimizer iteration and; if an unexepcted problem occurr then an error code will be returned. double XMinimum() const. Return current estimate of the position of the minimum. double XLower() const. Return current lower bound of the minimization interval. double XUpper() const. Return current upper bound of the minimization interval. double FValMinimum() const. Return function value at current estimate of the minimum. double FValLower() const. Return function value at current lower bound of the minimization interval. double FValUpper() const. Return function value at current upper bound of the minimization interval. bool Minimize(int maxIter, double absTol, double relTol). Find minimum position iterating until convergence specified by the absolute and relative tolerance or; the maximum number of iteration is reached; Return true is result is successfull; \@param maxIter maximum number of iteration; \@param absTol desired absolute error in the minimum position; \@param absTol desired relative error in the minimum position. int Iterations() const. Return number of iteration used to find minimum. int Status() const. Return status of last minimization. { return fStatus; }. const char * Name() const. Return name of minimization algorithm. int TestInterval(double xlow, double xup, double epsAbs, double epsRel). Test convergence of the interval.; The test returns success if; \f[; |x_{min}-x_{truemin}| < epsAbs + epsRel *x_{truemin}; \f].  Author: L. Moneta, A. Zsenei 08/2005  Copyright (c) 2004 moneta, CERN/PH-SFT *;  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__GSLMinimizer1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMinimizer1D.html
https://root.cern/root/html534/ROOT__Math__GSLMinimizer1D.html:3710,Availability,error,error,3710,"et, or reset, minimizer to use the function f and the initial search interval [xlow, xup], with a guess for the location of the minimum xmin.; The condition : \f$ f(xlow) > f(xmin) < f(xup)\f$ must be satisfied. int Iterate(). Perform a minimizer iteration and; if an unexepcted problem occurr then an error code will be returned. double XMinimum() const. Return current estimate of the position of the minimum. double XLower() const. Return current lower bound of the minimization interval. double XUpper() const. Return current upper bound of the minimization interval. double FValMinimum() const. Return function value at current estimate of the minimum. double FValLower() const. Return function value at current lower bound of the minimization interval. double FValUpper() const. Return function value at current upper bound of the minimization interval. bool Minimize(int maxIter, double absTol, double relTol). Find minimum position iterating until convergence specified by the absolute and relative tolerance or; the maximum number of iteration is reached; Return true is result is successfull; \@param maxIter maximum number of iteration; \@param absTol desired absolute error in the minimum position; \@param absTol desired relative error in the minimum position. int Iterations() const. Return number of iteration used to find minimum. int Status() const. Return status of last minimization. { return fStatus; }. const char * Name() const. Return name of minimization algorithm. int TestInterval(double xlow, double xup, double epsAbs, double epsRel). Test convergence of the interval.; The test returns success if; \f[; |x_{min}-x_{truemin}| < epsAbs + epsRel *x_{truemin}; \f].  Author: L. Moneta, A. Zsenei 08/2005  Copyright (c) 2004 moneta, CERN/PH-SFT *;  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__GSLMinimizer1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMinimizer1D.html
https://root.cern/root/html534/ROOT__Math__GSLMinimizer1D.html:3773,Availability,error,error,3773,"et, or reset, minimizer to use the function f and the initial search interval [xlow, xup], with a guess for the location of the minimum xmin.; The condition : \f$ f(xlow) > f(xmin) < f(xup)\f$ must be satisfied. int Iterate(). Perform a minimizer iteration and; if an unexepcted problem occurr then an error code will be returned. double XMinimum() const. Return current estimate of the position of the minimum. double XLower() const. Return current lower bound of the minimization interval. double XUpper() const. Return current upper bound of the minimization interval. double FValMinimum() const. Return function value at current estimate of the minimum. double FValLower() const. Return function value at current lower bound of the minimization interval. double FValUpper() const. Return function value at current upper bound of the minimization interval. bool Minimize(int maxIter, double absTol, double relTol). Find minimum position iterating until convergence specified by the absolute and relative tolerance or; the maximum number of iteration is reached; Return true is result is successfull; \@param maxIter maximum number of iteration; \@param absTol desired absolute error in the minimum position; \@param absTol desired relative error in the minimum position. int Iterations() const. Return number of iteration used to find minimum. int Status() const. Return status of last minimization. { return fStatus; }. const char * Name() const. Return name of minimization algorithm. int TestInterval(double xlow, double xup, double epsAbs, double epsRel). Test convergence of the interval.; The test returns success if; \f[; |x_{min}-x_{truemin}| < epsAbs + epsRel *x_{truemin}; \f].  Author: L. Moneta, A. Zsenei 08/2005  Copyright (c) 2004 moneta, CERN/PH-SFT *;  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__GSLMinimizer1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMinimizer1D.html
https://root.cern/root/html534/ROOT__Math__GSLMinimizer1D.html:2329,Energy Efficiency,allocate,allocated,2329,"ion(ROOT::Math::GSLFuncPointer f, void* params, double xmin, double xlow, double xup); virtual intStatus() const; static intTestInterval(double xlow, double xup, double epsAbs, double epsRel); virtual doubleXLower() const; virtual doubleXMinimum() const; virtual doubleXUpper() const. private:. ROOT::Math::GSLMinimizer1DGSLMinimizer1D(const ROOT::Math::GSLMinimizer1D&); ROOT::Math::GSLMinimizer1D&operator=(const ROOT::Math::GSLMinimizer1D&). Data Members; private:. ROOT::Math::GSLFunctionWrapper*fFunction; boolfIsSet; intfIter; doublefLow; doublefMin; ROOT::Math::GSL1DMinimizerWrapper*fMinimizer; intfStatusstatus of last minimization (==0 ok =1 failed); doublefUp; doublefXlow; doublefXmin; doublefXup. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; explicit GSLMinimizer1D(Minim1D::Type type=Minim1D::kBRENT). Construct the minimizer passing the minimizer type using the Minim1D::Algorithm enumeration. virtual ~GSLMinimizer1D(). Destructor: free allocated resources. GSLMinimizer1D(const GSLMinimizer1D &); usually copying is non trivial, so we make this unaccessible. void SetFunction( const UserFunc & f, double xmin, double xlow, double xup). Set, or reset, minimizer to use the function f and the initial search interval [xlow, xup], with a guess for the location of the minimum xmin.; The condition : \f$ f(xlow) > f(xmin) < f(xup)\f$ must be satisfied. int Iterate(). Perform a minimizer iteration and; if an unexepcted problem occurr then an error code will be returned. double XMinimum() const. Return current estimate of the position of the minimum. double XLower() const. Return current lower bound of the minimization interval. double XUpper() const. Return current upper bound of the minimization interval. double FValMinimum() const. Return function value at current estimate of the minimum. double FValLower() const. Return function value at current lower bound of the minimization interval. double FValUpper() const. Return function",MatchSource.WIKI,root/html534/ROOT__Math__GSLMinimizer1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMinimizer1D.html
https://root.cern/root/html534/ROOT__Math__GSLMinimizer1D.html:4132,Testability,test,test,4132,"et, or reset, minimizer to use the function f and the initial search interval [xlow, xup], with a guess for the location of the minimum xmin.; The condition : \f$ f(xlow) > f(xmin) < f(xup)\f$ must be satisfied. int Iterate(). Perform a minimizer iteration and; if an unexepcted problem occurr then an error code will be returned. double XMinimum() const. Return current estimate of the position of the minimum. double XLower() const. Return current lower bound of the minimization interval. double XUpper() const. Return current upper bound of the minimization interval. double FValMinimum() const. Return function value at current estimate of the minimum. double FValLower() const. Return function value at current lower bound of the minimization interval. double FValUpper() const. Return function value at current upper bound of the minimization interval. bool Minimize(int maxIter, double absTol, double relTol). Find minimum position iterating until convergence specified by the absolute and relative tolerance or; the maximum number of iteration is reached; Return true is result is successfull; \@param maxIter maximum number of iteration; \@param absTol desired absolute error in the minimum position; \@param absTol desired relative error in the minimum position. int Iterations() const. Return number of iteration used to find minimum. int Status() const. Return status of last minimization. { return fStatus; }. const char * Name() const. Return name of minimization algorithm. int TestInterval(double xlow, double xup, double epsAbs, double epsRel). Test convergence of the interval.; The test returns success if; \f[; |x_{min}-x_{truemin}| < epsAbs + epsRel *x_{truemin}; \f].  Author: L. Moneta, A. Zsenei 08/2005  Copyright (c) 2004 moneta, CERN/PH-SFT *;  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__GSLMinimizer1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMinimizer1D.html
https://root.cern/root/html534/ROOT__Math__GSLMinimizer1D.html:739,Usability,simpl,simplest,739,". ROOT::Math::GSLMinimizer1D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLMinimizer1D. class ROOT::Math::GSLMinimizer1D: public ROOT::Math::IMinimizer1D. Minimizer for arbitrary one dimensional functions. Implemented using GSL, for detailed description see:; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/One-dimensional-Minimization.html"">GSL online doc</A>. The algorithms uspported are only bracketing algorithm which do not use derivatives information.; The algorithms which can be chosen at construction time are GOLDENSECTION, whic is the simplest method; but the slowest and BRENT (the default one) which combines the golden section with a parabolic interpolation. This class does not support copying; @ingroup Min1D. Function Members (Methods); public:. virtual~GSLMinimizer1D(); virtual doubleFValLower() const; virtual doubleFValMinimum() const; virtual doubleFValUpper() const; ROOT::Math::GSLMinimizer1DGSLMinimizer1D(ROOT::Math::Minim1D::Type type = Minim1D::kBRENT); intIterate(); virtual intIterations() const; virtual boolMinimize(int maxIter, double absTol, double relTol); virtual const char*Name() const; voidSetFunction(ROOT::Math::GSLFuncPointer f, void* params, double xmin, double xlow, double xup); virtual intStatus() const; static intTestInterval(double xlow, double xup, double epsAbs, double epsRel); virtual doubleXLower() const; virtual doubleXMinimum() const; virtual doubleXUpper() const. private:. ROOT::Math::GSLMinimizer1DGSLMinimizer1D(const ROOT::Math::GSLMinimizer1D&); ROOT::Math::GSLMinimizer1D&operator=(const ROOT::Math::GSLMinimizer1D&). Data Members; private:. ROOT::Math::GSLFunctionWrapper*fFunction; boolfIsSet; intfIter; doublefLow; doublefMin; ROOT::Math::GSL1DMinimizerWrapper*fMinimizer; intfStatusstatus of last minimization (==0 ok =1 failed); doublefUp;",MatchSource.WIKI,root/html534/ROOT__Math__GSLMinimizer1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMinimizer1D.html
https://root.cern/root/html534/ROOT__Math__GSLMultiRootFinder.html:713,Availability,avail,available,713,". ROOT::Math::GSLMultiRootFinder. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLMultiRootFinder. class ROOT::Math::GSLMultiRootFinder. Class for Multidimensional root finding algorithms bassed on GSL. This class is used to solve a; non-linear system of equations:. f1(x1,....xn) = 0; f2(x1,....xn) = 0; ..................; fn(x1,....xn) = 0. See the GSL <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Multidimensional-Root_002dFinding.html""> online manual</A> for; information on the GSL MultiRoot finding algorithms. The available GSL algorithms require the derivatives of the supplied functions or not (they are; computed internally by GSL). In the first case the user needs to provide a list of multidimensional functions implementing the; gradient interface (ROOT::Math::IMultiGradFunction) while in the second case it is enough to supply a list of; functions impelmenting the ROOT::Math::IMultiGenFunction interface.; The available algorithms requiring derivatives (see also the GSL; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Algorithms-using-Derivatives.html"">documentation</A> ); are the followings:; <ul>; <li><tt>ROOT::Math::GSLMultiRootFinder::kHybridSJ</tt> with name <it>""HybridSJ""</it>: modified Powell's hybrid; method as implemented in HYBRJ in MINPACK; <li><tt>ROOT::Math::GSLMultiRootFinder::kHybridJ</tt> with name <it>""HybridJ""</it>: unscaled version of the; previous algorithm</li>; <li><tt>ROOT::Math::GSLMultiRootFinder::kNewton</tt> with name <it>""Newton""</it>: Newton method </li>; <li><tt>ROOT::Math::GSLMultiRootFinder::kGNewton</tt> with name <it>""GNewton""</it>: modified Newton method </li>; </ul>; The algorithms without derivatives (see also the GSL; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Algorithms-without-Derivatives.html"">documentation</A> ",MatchSource.WIKI,root/html534/ROOT__Math__GSLMultiRootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMultiRootFinder.html
https://root.cern/root/html534/ROOT__Math__GSLMultiRootFinder.html:1118,Availability,avail,available,1118,"s description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLMultiRootFinder. class ROOT::Math::GSLMultiRootFinder. Class for Multidimensional root finding algorithms bassed on GSL. This class is used to solve a; non-linear system of equations:. f1(x1,....xn) = 0; f2(x1,....xn) = 0; ..................; fn(x1,....xn) = 0. See the GSL <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Multidimensional-Root_002dFinding.html""> online manual</A> for; information on the GSL MultiRoot finding algorithms. The available GSL algorithms require the derivatives of the supplied functions or not (they are; computed internally by GSL). In the first case the user needs to provide a list of multidimensional functions implementing the; gradient interface (ROOT::Math::IMultiGradFunction) while in the second case it is enough to supply a list of; functions impelmenting the ROOT::Math::IMultiGenFunction interface.; The available algorithms requiring derivatives (see also the GSL; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Algorithms-using-Derivatives.html"">documentation</A> ); are the followings:; <ul>; <li><tt>ROOT::Math::GSLMultiRootFinder::kHybridSJ</tt> with name <it>""HybridSJ""</it>: modified Powell's hybrid; method as implemented in HYBRJ in MINPACK; <li><tt>ROOT::Math::GSLMultiRootFinder::kHybridJ</tt> with name <it>""HybridJ""</it>: unscaled version of the; previous algorithm</li>; <li><tt>ROOT::Math::GSLMultiRootFinder::kNewton</tt> with name <it>""Newton""</it>: Newton method </li>; <li><tt>ROOT::Math::GSLMultiRootFinder::kGNewton</tt> with name <it>""GNewton""</it>: modified Newton method </li>; </ul>; The algorithms without derivatives (see also the GSL; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Algorithms-without-Derivatives.html"">documentation</A> ); are the followings:; <ul>; <li><tt>ROOT::Math::GSLMultiRootFinder::kHybridS</tt> with name <it>""HybridS""</it>: same as HybridSJ but using; finate differ",MatchSource.WIKI,root/html534/ROOT__Math__GSLMultiRootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMultiRootFinder.html
https://root.cern/root/html534/ROOT__Math__GSLMultiRootFinder.html:6320,Availability,toler,tolerance,6320,"onst ROOT::Math::IMultiGenFunction& func). add (set) a single function fi(x1,...xn) which is part of the system of; specifying the begin and end of the iterator.; If using a derivative type algorithm the function must implement the; ROOT::Math::IMultiGradFunction interface; Return the current number of function in the list and 0 if failed to add the function. unsigned int Dim() const. return the number of sunctions set in the class.; The number must be equal to the dimension of the functions. { return fFunctions.size(); }. void Clear(); clear list of functions. const double * X() const; return the root X values solving the system. const double * FVal() const; return the function values f(X) solving the system; i.e. they must be close to zero at the solution. const double * Dx() const; return the last step size. bool Solve(const double* x, int maxIter = 0, double absTol = 0, double relTol = 0). Find the root starting from the point X;; Use the number of iteration and tolerance if given otherwise use; default parameter values which can be defined by; the static method SetDefault... int Iterations() const; Return number of iterations. int Status() const; Return the status of last root finding. { return fStatus; }. const char * Name() const; Return the algorithm name. void SetPrintLevel(int level). set print level; level = 0 quiet (no messages print); = 1 print only the result; = 3 max debug. Print result at each iteration. { fPrintLevel = level; }. int PrintLevel() const; return the print level. { return fPrintLevel; }. void SetDefaultTolerance(double abstol, double reltol = 0); -- static methods to set configurations; set tolerance (absolute and relative); relative tolerance is only use to verify the convergence; do it is a minor parameter. void SetDefaultMaxIterations(int maxiter); set maximum number of iterations. void PrintState(ostream& os = std::cout); print iteration state. std::pair<bool,int> GetType(const char* name); return type given a name. void ClearFuncti",MatchSource.WIKI,root/html534/ROOT__Math__GSLMultiRootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMultiRootFinder.html
https://root.cern/root/html534/ROOT__Math__GSLMultiRootFinder.html:6987,Availability,toler,tolerance,6987,"d to add the function. unsigned int Dim() const. return the number of sunctions set in the class.; The number must be equal to the dimension of the functions. { return fFunctions.size(); }. void Clear(); clear list of functions. const double * X() const; return the root X values solving the system. const double * FVal() const; return the function values f(X) solving the system; i.e. they must be close to zero at the solution. const double * Dx() const; return the last step size. bool Solve(const double* x, int maxIter = 0, double absTol = 0, double relTol = 0). Find the root starting from the point X;; Use the number of iteration and tolerance if given otherwise use; default parameter values which can be defined by; the static method SetDefault... int Iterations() const; Return number of iterations. int Status() const; Return the status of last root finding. { return fStatus; }. const char * Name() const; Return the algorithm name. void SetPrintLevel(int level). set print level; level = 0 quiet (no messages print); = 1 print only the result; = 3 max debug. Print result at each iteration. { fPrintLevel = level; }. int PrintLevel() const; return the print level. { return fPrintLevel; }. void SetDefaultTolerance(double abstol, double reltol = 0); -- static methods to set configurations; set tolerance (absolute and relative); relative tolerance is only use to verify the convergence; do it is a minor parameter. void SetDefaultMaxIterations(int maxiter); set maximum number of iterations. void PrintState(ostream& os = std::cout); print iteration state. std::pair<bool,int> GetType(const char* name); return type given a name. void ClearFunctions(); clear list of functions.  Author: L. Moneta 03/2011  Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *;  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__GSLMultiRootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMultiRootFinder.html
https://root.cern/root/html534/ROOT__Math__GSLMultiRootFinder.html:7031,Availability,toler,tolerance,7031,"d to add the function. unsigned int Dim() const. return the number of sunctions set in the class.; The number must be equal to the dimension of the functions. { return fFunctions.size(); }. void Clear(); clear list of functions. const double * X() const; return the root X values solving the system. const double * FVal() const; return the function values f(X) solving the system; i.e. they must be close to zero at the solution. const double * Dx() const; return the last step size. bool Solve(const double* x, int maxIter = 0, double absTol = 0, double relTol = 0). Find the root starting from the point X;; Use the number of iteration and tolerance if given otherwise use; default parameter values which can be defined by; the static method SetDefault... int Iterations() const; Return number of iterations. int Status() const; Return the status of last root finding. { return fStatus; }. const char * Name() const; Return the algorithm name. void SetPrintLevel(int level). set print level; level = 0 quiet (no messages print); = 1 print only the result; = 3 max debug. Print result at each iteration. { fPrintLevel = level; }. int PrintLevel() const; return the print level. { return fPrintLevel; }. void SetDefaultTolerance(double abstol, double reltol = 0); -- static methods to set configurations; set tolerance (absolute and relative); relative tolerance is only use to verify the convergence; do it is a minor parameter. void SetDefaultMaxIterations(int maxiter); set maximum number of iterations. void PrintState(ostream& os = std::cout); print iteration state. std::pair<bool,int> GetType(const char* name); return type given a name. void ClearFunctions(); clear list of functions.  Author: L. Moneta 03/2011  Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *;  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__GSLMultiRootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMultiRootFinder.html
https://root.cern/root/html534/ROOT__Math__GSLMultiRootFinder.html:6967,Deployability,configurat,configurations,6967,"d to add the function. unsigned int Dim() const. return the number of sunctions set in the class.; The number must be equal to the dimension of the functions. { return fFunctions.size(); }. void Clear(); clear list of functions. const double * X() const; return the root X values solving the system. const double * FVal() const; return the function values f(X) solving the system; i.e. they must be close to zero at the solution. const double * Dx() const; return the last step size. bool Solve(const double* x, int maxIter = 0, double absTol = 0, double relTol = 0). Find the root starting from the point X;; Use the number of iteration and tolerance if given otherwise use; default parameter values which can be defined by; the static method SetDefault... int Iterations() const; Return number of iterations. int Status() const; Return the status of last root finding. { return fStatus; }. const char * Name() const; Return the algorithm name. void SetPrintLevel(int level). set print level; level = 0 quiet (no messages print); = 1 print only the result; = 3 max debug. Print result at each iteration. { fPrintLevel = level; }. int PrintLevel() const; return the print level. { return fPrintLevel; }. void SetDefaultTolerance(double abstol, double reltol = 0); -- static methods to set configurations; set tolerance (absolute and relative); relative tolerance is only use to verify the convergence; do it is a minor parameter. void SetDefaultMaxIterations(int maxiter); set maximum number of iterations. void PrintState(ostream& os = std::cout); print iteration state. std::pair<bool,int> GetType(const char* name); return type given a name. void ClearFunctions(); clear list of functions.  Author: L. Moneta 03/2011  Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *;  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__GSLMultiRootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMultiRootFinder.html
https://root.cern/root/html534/ROOT__Math__GSLMultiRootFinder.html:943,Integrability,interface,interface,943,". ROOT::Math::GSLMultiRootFinder. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLMultiRootFinder. class ROOT::Math::GSLMultiRootFinder. Class for Multidimensional root finding algorithms bassed on GSL. This class is used to solve a; non-linear system of equations:. f1(x1,....xn) = 0; f2(x1,....xn) = 0; ..................; fn(x1,....xn) = 0. See the GSL <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Multidimensional-Root_002dFinding.html""> online manual</A> for; information on the GSL MultiRoot finding algorithms. The available GSL algorithms require the derivatives of the supplied functions or not (they are; computed internally by GSL). In the first case the user needs to provide a list of multidimensional functions implementing the; gradient interface (ROOT::Math::IMultiGradFunction) while in the second case it is enough to supply a list of; functions impelmenting the ROOT::Math::IMultiGenFunction interface.; The available algorithms requiring derivatives (see also the GSL; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Algorithms-using-Derivatives.html"">documentation</A> ); are the followings:; <ul>; <li><tt>ROOT::Math::GSLMultiRootFinder::kHybridSJ</tt> with name <it>""HybridSJ""</it>: modified Powell's hybrid; method as implemented in HYBRJ in MINPACK; <li><tt>ROOT::Math::GSLMultiRootFinder::kHybridJ</tt> with name <it>""HybridJ""</it>: unscaled version of the; previous algorithm</li>; <li><tt>ROOT::Math::GSLMultiRootFinder::kNewton</tt> with name <it>""Newton""</it>: Newton method </li>; <li><tt>ROOT::Math::GSLMultiRootFinder::kGNewton</tt> with name <it>""GNewton""</it>: modified Newton method </li>; </ul>; The algorithms without derivatives (see also the GSL; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Algorithms-without-Derivatives.html"">documentation</A> ",MatchSource.WIKI,root/html534/ROOT__Math__GSLMultiRootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMultiRootFinder.html
https://root.cern/root/html534/ROOT__Math__GSLMultiRootFinder.html:1102,Integrability,interface,interface,1102,". ROOT::Math::GSLMultiRootFinder. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLMultiRootFinder. class ROOT::Math::GSLMultiRootFinder. Class for Multidimensional root finding algorithms bassed on GSL. This class is used to solve a; non-linear system of equations:. f1(x1,....xn) = 0; f2(x1,....xn) = 0; ..................; fn(x1,....xn) = 0. See the GSL <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Multidimensional-Root_002dFinding.html""> online manual</A> for; information on the GSL MultiRoot finding algorithms. The available GSL algorithms require the derivatives of the supplied functions or not (they are; computed internally by GSL). In the first case the user needs to provide a list of multidimensional functions implementing the; gradient interface (ROOT::Math::IMultiGradFunction) while in the second case it is enough to supply a list of; functions impelmenting the ROOT::Math::IMultiGenFunction interface.; The available algorithms requiring derivatives (see also the GSL; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Algorithms-using-Derivatives.html"">documentation</A> ); are the followings:; <ul>; <li><tt>ROOT::Math::GSLMultiRootFinder::kHybridSJ</tt> with name <it>""HybridSJ""</it>: modified Powell's hybrid; method as implemented in HYBRJ in MINPACK; <li><tt>ROOT::Math::GSLMultiRootFinder::kHybridJ</tt> with name <it>""HybridJ""</it>: unscaled version of the; previous algorithm</li>; <li><tt>ROOT::Math::GSLMultiRootFinder::kNewton</tt> with name <it>""Newton""</it>: Newton method </li>; <li><tt>ROOT::Math::GSLMultiRootFinder::kGNewton</tt> with name <it>""GNewton""</it>: modified Newton method </li>; </ul>; The algorithms without derivatives (see also the GSL; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Algorithms-without-Derivatives.html"">documentation</A> ",MatchSource.WIKI,root/html534/ROOT__Math__GSLMultiRootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMultiRootFinder.html
https://root.cern/root/html534/ROOT__Math__GSLMultiRootFinder.html:5603,Integrability,interface,interface,5603,"tFinder(EDerivType type); create a multi-root finder based on an algorithm requiring function derivative. GSLMultiRootFinder(const char* name = 0). create a multi-root finder using a string.; The names are those defined in the GSL manuals; after having remived the GSL prefix (gsl_multiroot_fsolver).; Default algorithm is ""hybrids"" (without derivative). virtual ~GSLMultiRootFinder(); destructor. GSLMultiRootFinder(const GSLMultiRootFinder &); usually copying is non trivial, so we make this unaccessible. void SetType(EType type); set the type for an algorithm without derivatives. void SetType(EDerivType type); set the type of algorithm using derivatives. void SetType(const char* name); set the type using a string. int AddFunction(const ROOT::Math::IMultiGenFunction& func). add (set) a single function fi(x1,...xn) which is part of the system of; specifying the begin and end of the iterator.; If using a derivative type algorithm the function must implement the; ROOT::Math::IMultiGradFunction interface; Return the current number of function in the list and 0 if failed to add the function. unsigned int Dim() const. return the number of sunctions set in the class.; The number must be equal to the dimension of the functions. { return fFunctions.size(); }. void Clear(); clear list of functions. const double * X() const; return the root X values solving the system. const double * FVal() const; return the function values f(X) solving the system; i.e. they must be close to zero at the solution. const double * Dx() const; return the last step size. bool Solve(const double* x, int maxIter = 0, double absTol = 0, double relTol = 0). Find the root starting from the point X;; Use the number of iteration and tolerance if given otherwise use; default parameter values which can be defined by; the static method SetDefault... int Iterations() const; Return number of iterations. int Status() const; Return the status of last root finding. { return fStatus; }. const char * Name() const; Ret",MatchSource.WIKI,root/html534/ROOT__Math__GSLMultiRootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMultiRootFinder.html
https://root.cern/root/html534/ROOT__Math__GSLMultiRootFinder.html:6692,Integrability,message,messages,6692,"d to add the function. unsigned int Dim() const. return the number of sunctions set in the class.; The number must be equal to the dimension of the functions. { return fFunctions.size(); }. void Clear(); clear list of functions. const double * X() const; return the root X values solving the system. const double * FVal() const; return the function values f(X) solving the system; i.e. they must be close to zero at the solution. const double * Dx() const; return the last step size. bool Solve(const double* x, int maxIter = 0, double absTol = 0, double relTol = 0). Find the root starting from the point X;; Use the number of iteration and tolerance if given otherwise use; default parameter values which can be defined by; the static method SetDefault... int Iterations() const; Return number of iterations. int Status() const; Return the status of last root finding. { return fStatus; }. const char * Name() const; Return the algorithm name. void SetPrintLevel(int level). set print level; level = 0 quiet (no messages print); = 1 print only the result; = 3 max debug. Print result at each iteration. { fPrintLevel = level; }. int PrintLevel() const; return the print level. { return fPrintLevel; }. void SetDefaultTolerance(double abstol, double reltol = 0); -- static methods to set configurations; set tolerance (absolute and relative); relative tolerance is only use to verify the convergence; do it is a minor parameter. void SetDefaultMaxIterations(int maxiter); set maximum number of iterations. void PrintState(ostream& os = std::cout); print iteration state. std::pair<bool,int> GetType(const char* name); return type given a name. void ClearFunctions(); clear list of functions.  Author: L. Moneta 03/2011  Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *;  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__GSLMultiRootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMultiRootFinder.html
https://root.cern/root/html534/ROOT__Math__GSLMultiRootFinder.html:6967,Modifiability,config,configurations,6967,"d to add the function. unsigned int Dim() const. return the number of sunctions set in the class.; The number must be equal to the dimension of the functions. { return fFunctions.size(); }. void Clear(); clear list of functions. const double * X() const; return the root X values solving the system. const double * FVal() const; return the function values f(X) solving the system; i.e. they must be close to zero at the solution. const double * Dx() const; return the last step size. bool Solve(const double* x, int maxIter = 0, double absTol = 0, double relTol = 0). Find the root starting from the point X;; Use the number of iteration and tolerance if given otherwise use; default parameter values which can be defined by; the static method SetDefault... int Iterations() const; Return number of iterations. int Status() const; Return the status of last root finding. { return fStatus; }. const char * Name() const; Return the algorithm name. void SetPrintLevel(int level). set print level; level = 0 quiet (no messages print); = 1 print only the result; = 3 max debug. Print result at each iteration. { fPrintLevel = level; }. int PrintLevel() const; return the print level. { return fPrintLevel; }. void SetDefaultTolerance(double abstol, double reltol = 0); -- static methods to set configurations; set tolerance (absolute and relative); relative tolerance is only use to verify the convergence; do it is a minor parameter. void SetDefaultMaxIterations(int maxiter); set maximum number of iterations. void PrintState(ostream& os = std::cout); print iteration state. std::pair<bool,int> GetType(const char* name); return type given a name. void ClearFunctions(); clear list of functions.  Author: L. Moneta 03/2011  Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *;  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__GSLMultiRootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMultiRootFinder.html
https://root.cern/root/html534/ROOT__Math__GSLMultiRootFinder.html:5882,Usability,clear,clear,5882,"root_fsolver).; Default algorithm is ""hybrids"" (without derivative). virtual ~GSLMultiRootFinder(); destructor. GSLMultiRootFinder(const GSLMultiRootFinder &); usually copying is non trivial, so we make this unaccessible. void SetType(EType type); set the type for an algorithm without derivatives. void SetType(EDerivType type); set the type of algorithm using derivatives. void SetType(const char* name); set the type using a string. int AddFunction(const ROOT::Math::IMultiGenFunction& func). add (set) a single function fi(x1,...xn) which is part of the system of; specifying the begin and end of the iterator.; If using a derivative type algorithm the function must implement the; ROOT::Math::IMultiGradFunction interface; Return the current number of function in the list and 0 if failed to add the function. unsigned int Dim() const. return the number of sunctions set in the class.; The number must be equal to the dimension of the functions. { return fFunctions.size(); }. void Clear(); clear list of functions. const double * X() const; return the root X values solving the system. const double * FVal() const; return the function values f(X) solving the system; i.e. they must be close to zero at the solution. const double * Dx() const; return the last step size. bool Solve(const double* x, int maxIter = 0, double absTol = 0, double relTol = 0). Find the root starting from the point X;; Use the number of iteration and tolerance if given otherwise use; default parameter values which can be defined by; the static method SetDefault... int Iterations() const; Return number of iterations. int Status() const; Return the status of last root finding. { return fStatus; }. const char * Name() const; Return the algorithm name. void SetPrintLevel(int level). set print level; level = 0 quiet (no messages print); = 1 print only the result; = 3 max debug. Print result at each iteration. { fPrintLevel = level; }. int PrintLevel() const; return the print level. { return fPrintLevel; }. void ",MatchSource.WIKI,root/html534/ROOT__Math__GSLMultiRootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMultiRootFinder.html
https://root.cern/root/html534/ROOT__Math__GSLMultiRootFinder.html:7346,Usability,clear,clear,7346,"d to add the function. unsigned int Dim() const. return the number of sunctions set in the class.; The number must be equal to the dimension of the functions. { return fFunctions.size(); }. void Clear(); clear list of functions. const double * X() const; return the root X values solving the system. const double * FVal() const; return the function values f(X) solving the system; i.e. they must be close to zero at the solution. const double * Dx() const; return the last step size. bool Solve(const double* x, int maxIter = 0, double absTol = 0, double relTol = 0). Find the root starting from the point X;; Use the number of iteration and tolerance if given otherwise use; default parameter values which can be defined by; the static method SetDefault... int Iterations() const; Return number of iterations. int Status() const; Return the status of last root finding. { return fStatus; }. const char * Name() const; Return the algorithm name. void SetPrintLevel(int level). set print level; level = 0 quiet (no messages print); = 1 print only the result; = 3 max debug. Print result at each iteration. { fPrintLevel = level; }. int PrintLevel() const; return the print level. { return fPrintLevel; }. void SetDefaultTolerance(double abstol, double reltol = 0); -- static methods to set configurations; set tolerance (absolute and relative); relative tolerance is only use to verify the convergence; do it is a minor parameter. void SetDefaultMaxIterations(int maxiter); set maximum number of iterations. void PrintState(ostream& os = std::cout); print iteration state. std::pair<bool,int> GetType(const char* name); return type given a name. void ClearFunctions(); clear list of functions.  Author: L. Moneta 03/2011  Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *;  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__GSLMultiRootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMultiRootFinder.html
https://root.cern/root/html534/ROOT__Math__GSLNLSMinimizer.html:6754,Availability,error,errors,6754,"th::BasicMinimizer::TransformFunction() const; virtual intROOT::Math::BasicMinimizer::VariableIndex(const string& name) const; virtual stringROOT::Math::BasicMinimizer::VariableName(unsigned int ivar) const; virtual const double*ROOT::Math::BasicMinimizer::X() const. protected:. boolROOT::Math::BasicMinimizer::CheckDimension() const; boolROOT::Math::BasicMinimizer::CheckObjFunction() const; ROOT::Math::MinimTransformFunction*ROOT::Math::BasicMinimizer::CreateTransformation(vector<double>& startValues, const ROOT::Math::IMultiGradFunction* func = 0); voidROOT::Math::BasicMinimizer::SetFinalValues(const double* x); voidROOT::Math::BasicMinimizer::SetMinValue(double val). private:. ROOT::Math::GSLNLSMinimizerGSLNLSMinimizer(const ROOT::Math::GSLNLSMinimizer&); ROOT::Math::GSLNLSMinimizer&operator=(const ROOT::Math::GSLNLSMinimizer& rhs). Data Members; protected:. ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::fOptionsminimizer options; intROOT::Math::Minimizer::fStatusstatus of minimizer ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. const ROOT::Math::FitMethodFunction*fChi2Funcpointer to Least square function; vector<double>fCovMatrixcov matrix (stored as cov[ i * dim + j] ; doublefEdmedm value; vector<double>fErrors; ROOT::Math::GSLMultiFit*fGSLMultiFitpointer to GSL multi fit solver ; doublefLSToleranceLine Search Tolerance; unsigned intfNFreedimension of the internal function to be minimized ; vector<LSResidualFunc>fResiduals! transient Vector of the residual functions; unsigned intfSizenumber of fit points (residuals). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; operator=(const ROOT::Math::GSLNLSMinimizer& rhs). GSLNLSMinimizer(int type = 0). Default constructor. ~GSLNLSMinimizer(). Destructor (no operations). GSLNLSMinimizer(const ROOT::Math::GSLNLSMinimizer& ); usually copying is non trivial, so we make this unaccessible. Cop",MatchSource.WIKI,root/html534/ROOT__Math__GSLNLSMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLNLSMinimizer.html
https://root.cern/root/html534/ROOT__Math__GSLNLSMinimizer.html:8449,Availability,error,error,8449,"unctions; unsigned intfSizenumber of fit points (residuals). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; operator=(const ROOT::Math::GSLNLSMinimizer& rhs). GSLNLSMinimizer(int type = 0). Default constructor. ~GSLNLSMinimizer(). Destructor (no operations). GSLNLSMinimizer(const ROOT::Math::GSLNLSMinimizer& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. {}. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set gradient the function to minimize. bool Minimize(); method to perform the minimization. double Edm() const; return expected distance reached from the minimum. const double * MinGradient() const; return pointer to gradient values at the minimum. unsigned int NCalls() const; number of function calls to reach the minimum. { return (fChi2Func) ? fChi2Func->NCalls() : 0; }. bool ProvidesError() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total; virtual unsigned int NFree() const { return fNFree; }; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return (fErrors.size() > 0) ? &fErrors.front() : 0; }. double CovMatrix(unsigned int , unsigned int ) const; {; static std::vector<double> err;; err.resize(fDim);; return &err.front();; }; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const; return covariance matrix status.  Author: L. Moneta Wed Dec 20 17:16:32 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__GSLNLSMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLNLSMinimizer.html
https://root.cern/root/html534/ROOT__Math__GSLNLSMinimizer.html:8459,Availability,error,error,8459,"unctions; unsigned intfSizenumber of fit points (residuals). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; operator=(const ROOT::Math::GSLNLSMinimizer& rhs). GSLNLSMinimizer(int type = 0). Default constructor. ~GSLNLSMinimizer(). Destructor (no operations). GSLNLSMinimizer(const ROOT::Math::GSLNLSMinimizer& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. {}. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set gradient the function to minimize. bool Minimize(); method to perform the minimization. double Edm() const; return expected distance reached from the minimum. const double * MinGradient() const; return pointer to gradient values at the minimum. unsigned int NCalls() const; number of function calls to reach the minimum. { return (fChi2Func) ? fChi2Func->NCalls() : 0; }. bool ProvidesError() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total; virtual unsigned int NFree() const { return fNFree; }; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return (fErrors.size() > 0) ? &fErrors.front() : 0; }. double CovMatrix(unsigned int , unsigned int ) const; {; static std::vector<double> err;; err.resize(fDim);; return &err.front();; }; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const; return covariance matrix status.  Author: L. Moneta Wed Dec 20 17:16:32 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__GSLNLSMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLNLSMinimizer.html
https://root.cern/root/html534/ROOT__Math__GSLNLSMinimizer.html:8529,Availability,error,errors,8529,"unctions; unsigned intfSizenumber of fit points (residuals). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; operator=(const ROOT::Math::GSLNLSMinimizer& rhs). GSLNLSMinimizer(int type = 0). Default constructor. ~GSLNLSMinimizer(). Destructor (no operations). GSLNLSMinimizer(const ROOT::Math::GSLNLSMinimizer& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. {}. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set gradient the function to minimize. bool Minimize(); method to perform the minimization. double Edm() const; return expected distance reached from the minimum. const double * MinGradient() const; return pointer to gradient values at the minimum. unsigned int NCalls() const; number of function calls to reach the minimum. { return (fChi2Func) ? fChi2Func->NCalls() : 0; }. bool ProvidesError() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total; virtual unsigned int NFree() const { return fNFree; }; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return (fErrors.size() > 0) ? &fErrors.front() : 0; }. double CovMatrix(unsigned int , unsigned int ) const; {; static std::vector<double> err;; err.resize(fDim);; return &err.front();; }; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const; return covariance matrix status.  Author: L. Moneta Wed Dec 20 17:16:32 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__GSLNLSMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLNLSMinimizer.html
https://root.cern/root/html534/ROOT__Math__GSLNLSMinimizer.html:8873,Availability,error,errors,8873,"unctions; unsigned intfSizenumber of fit points (residuals). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; operator=(const ROOT::Math::GSLNLSMinimizer& rhs). GSLNLSMinimizer(int type = 0). Default constructor. ~GSLNLSMinimizer(). Destructor (no operations). GSLNLSMinimizer(const ROOT::Math::GSLNLSMinimizer& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. {}. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set gradient the function to minimize. bool Minimize(); method to perform the minimization. double Edm() const; return expected distance reached from the minimum. const double * MinGradient() const; return pointer to gradient values at the minimum. unsigned int NCalls() const; number of function calls to reach the minimum. { return (fChi2Func) ? fChi2Func->NCalls() : 0; }. bool ProvidesError() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total; virtual unsigned int NFree() const { return fNFree; }; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return (fErrors.size() > 0) ? &fErrors.front() : 0; }. double CovMatrix(unsigned int , unsigned int ) const; {; static std::vector<double> err;; err.resize(fDim);; return &err.front();; }; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const; return covariance matrix status.  Author: L. Moneta Wed Dec 20 17:16:32 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__GSLNLSMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLNLSMinimizer.html
https://root.cern/root/html534/ROOT__Math__GSLNLSMinimizer.html:642,Integrability,wrap,wraps,642,". ROOT::Math::GSLNLSMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLNLSMinimizer. class ROOT::Math::GSLNLSMinimizer: public ROOT::Math::BasicMinimizer. LSResidualFunc class description.; Internal class used for accessing the residuals of the Least Square function; and their derivates which are estimated numerically using GSL numerical derivation.; The class contains a pointer to the fit method function and an index specifying; the i-th residual and wraps it in a multi-dim gradient function interface; ROOT::Math::IGradientFunctionMultiDim.; The class is used by ROOT::Math::GSLNLSMinimizer (GSL non linear least square fitter). @ingroup MultiMin. Function Members (Methods); public:. virtual~GSLNLSMinimizer(); ROOT::Math::BasicMinimizerROOT::Math::BasicMinimizer::BasicMinimizer(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolROOT::Math::Minimizer::Contour(unsigned int ivar, unsigned int jvar, unsigned int& npoints, double* xi, double* xj); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int, unsigned int) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolROOT::Math::BasicMinimizer::FixVariable(unsigned int ivar); virtual boolROOT::Math::Minimizer::GetCovMatrix(double* covMat) const; virtual boolROOT::Math::Minimizer::GetHessianMatrix(double* hMat) const; virtual boolROOT::Math::Minimizer::GetMinosError(unsigned int ivar, double& errLow, double& errUp, int option = 0); virtual boolROOT::Math::BasicMinimizer::GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings& varObj) const; virtual doubleROOT::Math::Minimizer::GlobalCC(unsigned int ivar) const; const ROOT::Math::IMultiGradF",MatchSource.WIKI,root/html534/ROOT__Math__GSLNLSMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLNLSMinimizer.html
https://root.cern/root/html534/ROOT__Math__GSLNLSMinimizer.html:684,Integrability,interface,interface,684,". ROOT::Math::GSLNLSMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLNLSMinimizer. class ROOT::Math::GSLNLSMinimizer: public ROOT::Math::BasicMinimizer. LSResidualFunc class description.; Internal class used for accessing the residuals of the Least Square function; and their derivates which are estimated numerically using GSL numerical derivation.; The class contains a pointer to the fit method function and an index specifying; the i-th residual and wraps it in a multi-dim gradient function interface; ROOT::Math::IGradientFunctionMultiDim.; The class is used by ROOT::Math::GSLNLSMinimizer (GSL non linear least square fitter). @ingroup MultiMin. Function Members (Methods); public:. virtual~GSLNLSMinimizer(); ROOT::Math::BasicMinimizerROOT::Math::BasicMinimizer::BasicMinimizer(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolROOT::Math::Minimizer::Contour(unsigned int ivar, unsigned int jvar, unsigned int& npoints, double* xi, double* xj); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int, unsigned int) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolROOT::Math::BasicMinimizer::FixVariable(unsigned int ivar); virtual boolROOT::Math::Minimizer::GetCovMatrix(double* covMat) const; virtual boolROOT::Math::Minimizer::GetHessianMatrix(double* hMat) const; virtual boolROOT::Math::Minimizer::GetMinosError(unsigned int ivar, double& errLow, double& errUp, int option = 0); virtual boolROOT::Math::BasicMinimizer::GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings& varObj) const; virtual doubleROOT::Math::Minimizer::GlobalCC(unsigned int ivar) const; const ROOT::Math::IMultiGradF",MatchSource.WIKI,root/html534/ROOT__Math__GSLNLSMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLNLSMinimizer.html
https://root.cern/root/html534/ROOT__Math__GSLNLSMinimizer.html:8283,Modifiability,variab,variables,8283,"unctions; unsigned intfSizenumber of fit points (residuals). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; operator=(const ROOT::Math::GSLNLSMinimizer& rhs). GSLNLSMinimizer(int type = 0). Default constructor. ~GSLNLSMinimizer(). Destructor (no operations). GSLNLSMinimizer(const ROOT::Math::GSLNLSMinimizer& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. {}. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set gradient the function to minimize. bool Minimize(); method to perform the minimization. double Edm() const; return expected distance reached from the minimum. const double * MinGradient() const; return pointer to gradient values at the minimum. unsigned int NCalls() const; number of function calls to reach the minimum. { return (fChi2Func) ? fChi2Func->NCalls() : 0; }. bool ProvidesError() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total; virtual unsigned int NFree() const { return fNFree; }; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return (fErrors.size() > 0) ? &fErrors.front() : 0; }. double CovMatrix(unsigned int , unsigned int ) const; {; static std::vector<double> err;; err.resize(fDim);; return &err.front();; }; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const; return covariance matrix status.  Author: L. Moneta Wed Dec 20 17:16:32 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__GSLNLSMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLNLSMinimizer.html
https://root.cern/root/html534/ROOT__Math__GSLNLSMinimizer.html:8787,Modifiability,variab,variable,8787,"unctions; unsigned intfSizenumber of fit points (residuals). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; operator=(const ROOT::Math::GSLNLSMinimizer& rhs). GSLNLSMinimizer(int type = 0). Default constructor. ~GSLNLSMinimizer(). Destructor (no operations). GSLNLSMinimizer(const ROOT::Math::GSLNLSMinimizer& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. {}. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set gradient the function to minimize. bool Minimize(); method to perform the minimization. double Edm() const; return expected distance reached from the minimum. const double * MinGradient() const; return pointer to gradient values at the minimum. unsigned int NCalls() const; number of function calls to reach the minimum. { return (fChi2Func) ? fChi2Func->NCalls() : 0; }. bool ProvidesError() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total; virtual unsigned int NFree() const { return fNFree; }; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return (fErrors.size() > 0) ? &fErrors.front() : 0; }. double CovMatrix(unsigned int , unsigned int ) const; {; static std::vector<double> err;; err.resize(fDim);; return &err.front();; }; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const; return covariance matrix status.  Author: L. Moneta Wed Dec 20 17:16:32 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__GSLNLSMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLNLSMinimizer.html
https://root.cern/root/html534/ROOT__Math__GSLNLSMinimizer.html:8845,Modifiability,variab,variables,8845,"unctions; unsigned intfSizenumber of fit points (residuals). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; operator=(const ROOT::Math::GSLNLSMinimizer& rhs). GSLNLSMinimizer(int type = 0). Default constructor. ~GSLNLSMinimizer(). Destructor (no operations). GSLNLSMinimizer(const ROOT::Math::GSLNLSMinimizer& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. {}. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set gradient the function to minimize. bool Minimize(); method to perform the minimization. double Edm() const; return expected distance reached from the minimum. const double * MinGradient() const; return pointer to gradient values at the minimum. unsigned int NCalls() const; number of function calls to reach the minimum. { return (fChi2Func) ? fChi2Func->NCalls() : 0; }. bool ProvidesError() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total; virtual unsigned int NFree() const { return fNFree; }; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return (fErrors.size() > 0) ? &fErrors.front() : 0; }. double CovMatrix(unsigned int , unsigned int ) const; {; static std::vector<double> err;; err.resize(fDim);; return &err.front();; }; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const; return covariance matrix status.  Author: L. Moneta Wed Dec 20 17:16:32 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__GSLNLSMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLNLSMinimizer.html
https://root.cern/root/html534/ROOT__Math__GSLNLSMinimizer.html:7930,Performance,perform,perform,7930,"Matrixcov matrix (stored as cov[ i * dim + j] ; doublefEdmedm value; vector<double>fErrors; ROOT::Math::GSLMultiFit*fGSLMultiFitpointer to GSL multi fit solver ; doublefLSToleranceLine Search Tolerance; unsigned intfNFreedimension of the internal function to be minimized ; vector<LSResidualFunc>fResiduals! transient Vector of the residual functions; unsigned intfSizenumber of fit points (residuals). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; operator=(const ROOT::Math::GSLNLSMinimizer& rhs). GSLNLSMinimizer(int type = 0). Default constructor. ~GSLNLSMinimizer(). Destructor (no operations). GSLNLSMinimizer(const ROOT::Math::GSLNLSMinimizer& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. {}. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set gradient the function to minimize. bool Minimize(); method to perform the minimization. double Edm() const; return expected distance reached from the minimum. const double * MinGradient() const; return pointer to gradient values at the minimum. unsigned int NCalls() const; number of function calls to reach the minimum. { return (fChi2Func) ? fChi2Func->NCalls() : 0; }. bool ProvidesError() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total; virtual unsigned int NFree() const { return fNFree; }; minimizer provides error and error matrix. { return true; }. const double * Errors() const; return errors at the minimum. { return (fErrors.size() > 0) ? &fErrors.front() : 0; }. double CovMatrix(unsigned int , unsigned int ) const; {; static std::vector<double> err;; err.resize(fDim);; return &err.front();; }; return covariance matrices elements; if the variable is fixed the matrix is zero; The ordering of the variables is the same as in errors. int CovMatrixStatus() const; return covariance m",MatchSource.WIKI,root/html534/ROOT__Math__GSLNLSMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLNLSMinimizer.html
https://root.cern/root/html534/ROOT__Math__GSLNLSMinimizer.html:400,Security,access,accessing,400,". ROOT::Math::GSLNLSMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLNLSMinimizer. class ROOT::Math::GSLNLSMinimizer: public ROOT::Math::BasicMinimizer. LSResidualFunc class description.; Internal class used for accessing the residuals of the Least Square function; and their derivates which are estimated numerically using GSL numerical derivation.; The class contains a pointer to the fit method function and an index specifying; the i-th residual and wraps it in a multi-dim gradient function interface; ROOT::Math::IGradientFunctionMultiDim.; The class is used by ROOT::Math::GSLNLSMinimizer (GSL non linear least square fitter). @ingroup MultiMin. Function Members (Methods); public:. virtual~GSLNLSMinimizer(); ROOT::Math::BasicMinimizerROOT::Math::BasicMinimizer::BasicMinimizer(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolROOT::Math::Minimizer::Contour(unsigned int ivar, unsigned int jvar, unsigned int& npoints, double* xi, double* xj); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int, unsigned int) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolROOT::Math::BasicMinimizer::FixVariable(unsigned int ivar); virtual boolROOT::Math::Minimizer::GetCovMatrix(double* covMat) const; virtual boolROOT::Math::Minimizer::GetHessianMatrix(double* hMat) const; virtual boolROOT::Math::Minimizer::GetMinosError(unsigned int ivar, double& errLow, double& errUp, int option = 0); virtual boolROOT::Math::BasicMinimizer::GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings& varObj) const; virtual doubleROOT::Math::Minimizer::GlobalCC(unsigned int ivar) const; const ROOT::Math::IMultiGradF",MatchSource.WIKI,root/html534/ROOT__Math__GSLNLSMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLNLSMinimizer.html
https://root.cern/root/html534/ROOT__Math__GSLNLSMinimizer.html:6771,Security,validat,validated,6771,"th::BasicMinimizer::TransformFunction() const; virtual intROOT::Math::BasicMinimizer::VariableIndex(const string& name) const; virtual stringROOT::Math::BasicMinimizer::VariableName(unsigned int ivar) const; virtual const double*ROOT::Math::BasicMinimizer::X() const. protected:. boolROOT::Math::BasicMinimizer::CheckDimension() const; boolROOT::Math::BasicMinimizer::CheckObjFunction() const; ROOT::Math::MinimTransformFunction*ROOT::Math::BasicMinimizer::CreateTransformation(vector<double>& startValues, const ROOT::Math::IMultiGradFunction* func = 0); voidROOT::Math::BasicMinimizer::SetFinalValues(const double* x); voidROOT::Math::BasicMinimizer::SetMinValue(double val). private:. ROOT::Math::GSLNLSMinimizerGSLNLSMinimizer(const ROOT::Math::GSLNLSMinimizer&); ROOT::Math::GSLNLSMinimizer&operator=(const ROOT::Math::GSLNLSMinimizer& rhs). Data Members; protected:. ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::fOptionsminimizer options; intROOT::Math::Minimizer::fStatusstatus of minimizer ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. const ROOT::Math::FitMethodFunction*fChi2Funcpointer to Least square function; vector<double>fCovMatrixcov matrix (stored as cov[ i * dim + j] ; doublefEdmedm value; vector<double>fErrors; ROOT::Math::GSLMultiFit*fGSLMultiFitpointer to GSL multi fit solver ; doublefLSToleranceLine Search Tolerance; unsigned intfNFreedimension of the internal function to be minimized ; vector<LSResidualFunc>fResiduals! transient Vector of the residual functions; unsigned intfSizenumber of fit points (residuals). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; operator=(const ROOT::Math::GSLNLSMinimizer& rhs). GSLNLSMinimizer(int type = 0). Default constructor. ~GSLNLSMinimizer(). Destructor (no operations). GSLNLSMinimizer(const ROOT::Math::GSLNLSMinimizer& ); usually copying is non trivial, so we make this unaccessible. Cop",MatchSource.WIKI,root/html534/ROOT__Math__GSLNLSMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLNLSMinimizer.html
https://root.cern/root/html534/ROOT__Math__GSLRandomEngine.html:595,Availability,avail,available,595,". ROOT::Math::GSLRandomEngine. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLRandomEngine. class ROOT::Math::GSLRandomEngine. GSLRandomEngine; Base class for all GSL random engines,; normally user instantiate the derived classes; which creates internally the generator. The main GSL generators (see; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Random-number-generator-algorithms.html"">; here</A>) are available as derived classes; In addition to generate uniform numbers it provides method for; generating numbers according to pre-defined distributions; using the GSL functions from; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Random-Number-Distributions.html"">; GSL random number distributions</A>. @ingroup Random. Function Members (Methods); public:. virtual~GSLRandomEngine(); unsigned intBinomial(double p, unsigned int n) const; doubleCauchy(double a) const; doubleChiSquare(double nu) const; voidDir2D(double& x, double& y) const; voidDir3D(double& x, double& y, double& z) const; doubleExponential(double mu) const; doubleFDist(double nu1, double nu2) const; doubleGamma(double a, double b) const; doubleGaussian(double sigma) const; voidGaussian2D(double sigmaX, double sigmaY, double rho, double& x, double& y) const; doubleGaussianRatio(double sigma) const; doubleGaussianTail(double a, double sigma) const; doubleGaussianZig(double sigma) const; ROOT::Math::GSLRandomEngineGSLRandomEngine(); ROOT::Math::GSLRandomEngineGSLRandomEngine(ROOT::Math::GSLRngWrapper* rng); ROOT::Math::GSLRandomEngineGSLRandomEngine(const ROOT::Math::GSLRandomEngine& eng); voidInitialize(); doubleLandau() const; doubleLogNormal(double zeta, double sigma) const; vector<unsigned int>Multinomial(unsigned int ntot, const vector<double>& p) const; stringName() const; unsigned intNegativeBinomial(double",MatchSource.WIKI,root/html534/ROOT__Math__GSLRandomEngine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLRandomEngine.html
https://root.cern/root/html534/ROOT__Math__GSLRandomEngine.html:3691,Availability,avail,available,3691,"tion; GSLRandomEngine(). default constructor. No creation of rng is done.; If then Initialize() is called an engine is created; based on default GSL type (MT). GSLRandomEngine( GSLRngWrapper * rng). create from an existing rng.; User manage the rng pointer which is then deleted olny by calling Terminate(). GSLRandomEngine(const GSLRandomEngine & eng). Copy constructor : clone the contained GSL generator. GSLRandomEngine & operator=(const ROOT::Math::GSLRandomEngine& eng). Assignment operator : make a deep copy of the contained GSL generator. void Initialize(). initialize the generator; If no rng is present the default one based on Mersenne and Twister is created. void Terminate(). delete pointer to contained rng. virtual ~GSLRandomEngine(). call Terminate(). double operator()() const. Generate a random number between ]0,1]; 0 is excluded and 1 is included. unsigned int RndmInt(unsigned int max) const. Generate an integer number between [0,max-1] (including 0 and max-1); if max is larger than available range of algorithm; an error message is printed and zero is returned. void RandomArray(double* begin, double* end) const. Generate an array of random numbers.; The iterators points to the random numbers. std::string Name() const. return name of generator. unsigned int Size() const. return the state size of generator. void SetSeed(unsigned int seed) const. set the random generator seed. double Gaussian(double sigma) const; @name Random Distributions; Implemented using the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Random-Number-Distributions.html"">; GSL Random number Distributions</A>. @{. Gaussian distribution - default method is Box-Muller (polar method). double GaussianZig(double sigma) const. Gaussian distribution - Ziggurat method. double GaussianRatio(double sigma) const. Gaussian distribution - Ratio method. double GaussianTail(double a, double sigma) const. Gaussian Tail distribution. void Gaussian2D(double sigmaX, double sigmaY, double rho, doub",MatchSource.WIKI,root/html534/ROOT__Math__GSLRandomEngine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLRandomEngine.html
https://root.cern/root/html534/ROOT__Math__GSLRandomEngine.html:3724,Availability,error,error,3724,"tion; GSLRandomEngine(). default constructor. No creation of rng is done.; If then Initialize() is called an engine is created; based on default GSL type (MT). GSLRandomEngine( GSLRngWrapper * rng). create from an existing rng.; User manage the rng pointer which is then deleted olny by calling Terminate(). GSLRandomEngine(const GSLRandomEngine & eng). Copy constructor : clone the contained GSL generator. GSLRandomEngine & operator=(const ROOT::Math::GSLRandomEngine& eng). Assignment operator : make a deep copy of the contained GSL generator. void Initialize(). initialize the generator; If no rng is present the default one based on Mersenne and Twister is created. void Terminate(). delete pointer to contained rng. virtual ~GSLRandomEngine(). call Terminate(). double operator()() const. Generate a random number between ]0,1]; 0 is excluded and 1 is included. unsigned int RndmInt(unsigned int max) const. Generate an integer number between [0,max-1] (including 0 and max-1); if max is larger than available range of algorithm; an error message is printed and zero is returned. void RandomArray(double* begin, double* end) const. Generate an array of random numbers.; The iterators points to the random numbers. std::string Name() const. return name of generator. unsigned int Size() const. return the state size of generator. void SetSeed(unsigned int seed) const. set the random generator seed. double Gaussian(double sigma) const; @name Random Distributions; Implemented using the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Random-Number-Distributions.html"">; GSL Random number Distributions</A>. @{. Gaussian distribution - default method is Box-Muller (polar method). double GaussianZig(double sigma) const. Gaussian distribution - Ziggurat method. double GaussianRatio(double sigma) const. Gaussian distribution - Ratio method. double GaussianTail(double a, double sigma) const. Gaussian Tail distribution. void Gaussian2D(double sigmaX, double sigmaY, double rho, doub",MatchSource.WIKI,root/html534/ROOT__Math__GSLRandomEngine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLRandomEngine.html
https://root.cern/root/html534/ROOT__Math__GSLRandomEngine.html:2567,Integrability,wrap,wrapper,2567,"st; doubleGaussianZig(double sigma) const; ROOT::Math::GSLRandomEngineGSLRandomEngine(); ROOT::Math::GSLRandomEngineGSLRandomEngine(ROOT::Math::GSLRngWrapper* rng); ROOT::Math::GSLRandomEngineGSLRandomEngine(const ROOT::Math::GSLRandomEngine& eng); voidInitialize(); doubleLandau() const; doubleLogNormal(double zeta, double sigma) const; vector<unsigned int>Multinomial(unsigned int ntot, const vector<double>& p) const; stringName() const; unsigned intNegativeBinomial(double p, double n) const; doubleoperator()() const; ROOT::Math::GSLRandomEngine&operator=(const ROOT::Math::GSLRandomEngine& eng); unsigned intPoisson(double mu) const; voidRandomArray(double* begin, double* end) const; unsigned intRndmInt(unsigned int max) const; voidSetSeed(unsigned int seed) const; unsigned intSize() const; doubletDist(double nu) const; voidTerminate(). protected:. voidSetType(ROOT::Math::GSLRngWrapper* r). Data Members; private:. unsigned intfCurTimecurrent time used to seed the generator; ROOT::Math::GSLRngWrapper*fRngpointer to GSL generator wrapper (managed by the class). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLRandomEngine(). default constructor. No creation of rng is done.; If then Initialize() is called an engine is created; based on default GSL type (MT). GSLRandomEngine( GSLRngWrapper * rng). create from an existing rng.; User manage the rng pointer which is then deleted olny by calling Terminate(). GSLRandomEngine(const GSLRandomEngine & eng). Copy constructor : clone the contained GSL generator. GSLRandomEngine & operator=(const ROOT::Math::GSLRandomEngine& eng). Assignment operator : make a deep copy of the contained GSL generator. void Initialize(). initialize the generator; If no rng is present the default one based on Mersenne and Twister is created. void Terminate(). delete pointer to contained rng. virtual ~GSLRandomEngine(). call Terminate(). double operator()() const. Generate a random number between ]0,1]; 0 is",MatchSource.WIKI,root/html534/ROOT__Math__GSLRandomEngine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLRandomEngine.html
https://root.cern/root/html534/ROOT__Math__GSLRandomEngine.html:3730,Integrability,message,message,3730,"tion; GSLRandomEngine(). default constructor. No creation of rng is done.; If then Initialize() is called an engine is created; based on default GSL type (MT). GSLRandomEngine( GSLRngWrapper * rng). create from an existing rng.; User manage the rng pointer which is then deleted olny by calling Terminate(). GSLRandomEngine(const GSLRandomEngine & eng). Copy constructor : clone the contained GSL generator. GSLRandomEngine & operator=(const ROOT::Math::GSLRandomEngine& eng). Assignment operator : make a deep copy of the contained GSL generator. void Initialize(). initialize the generator; If no rng is present the default one based on Mersenne and Twister is created. void Terminate(). delete pointer to contained rng. virtual ~GSLRandomEngine(). call Terminate(). double operator()() const. Generate a random number between ]0,1]; 0 is excluded and 1 is included. unsigned int RndmInt(unsigned int max) const. Generate an integer number between [0,max-1] (including 0 and max-1); if max is larger than available range of algorithm; an error message is printed and zero is returned. void RandomArray(double* begin, double* end) const. Generate an array of random numbers.; The iterators points to the random numbers. std::string Name() const. return name of generator. unsigned int Size() const. return the state size of generator. void SetSeed(unsigned int seed) const. set the random generator seed. double Gaussian(double sigma) const; @name Random Distributions; Implemented using the; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Random-Number-Distributions.html"">; GSL Random number Distributions</A>. @{. Gaussian distribution - default method is Box-Muller (polar method). double GaussianZig(double sigma) const. Gaussian distribution - Ziggurat method. double GaussianRatio(double sigma) const. Gaussian distribution - Ratio method. double GaussianTail(double a, double sigma) const. Gaussian Tail distribution. void Gaussian2D(double sigmaX, double sigmaY, double rho, doub",MatchSource.WIKI,root/html534/ROOT__Math__GSLRandomEngine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLRandomEngine.html
https://root.cern/root/html534/ROOT__Math__GSLRngGFSR4.html:619,Availability,avail,available,619,". ROOT::Math::GSLRngGFSR4. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLRngGFSR4. class ROOT::Math::GSLRngGFSR4: public ROOT::Math::GSLRandomEngine. GSLRandomEngine; Base class for all GSL random engines,; normally user instantiate the derived classes; which creates internally the generator. The main GSL generators (see; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Random-number-generator-algorithms.html"">; here</A>) are available as derived classes; In addition to generate uniform numbers it provides method for; generating numbers according to pre-defined distributions; using the GSL functions from; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Random-Number-Distributions.html"">; GSL random number distributions</A>. @ingroup Random. Function Members (Methods); public:. ~GSLRngGFSR4(); unsigned intROOT::Math::GSLRandomEngine::Binomial(double p, unsigned int n) const; doubleROOT::Math::GSLRandomEngine::Cauchy(double a) const; doubleROOT::Math::GSLRandomEngine::ChiSquare(double nu) const; voidROOT::Math::GSLRandomEngine::Dir2D(double& x, double& y) const; voidROOT::Math::GSLRandomEngine::Dir3D(double& x, double& y, double& z) const; doubleROOT::Math::GSLRandomEngine::Exponential(double mu) const; doubleROOT::Math::GSLRandomEngine::FDist(double nu1, double nu2) const; doubleROOT::Math::GSLRandomEngine::Gamma(double a, double b) const; doubleROOT::Math::GSLRandomEngine::Gaussian(double sigma) const; voidROOT::Math::GSLRandomEngine::Gaussian2D(double sigmaX, double sigmaY, double rho, double& x, double& y) const; doubleROOT::Math::GSLRandomEngine::GaussianRatio(double sigma) const; doubleROOT::Math::GSLRandomEngine::GaussianTail(double a, double sigma) const; doubleROOT::Math::GSLRandomEngine::GaussianZig(double sigma) const; ROOT::Math::GSLRandomEngineROOT::Math::GSLRa",MatchSource.WIKI,root/html534/ROOT__Math__GSLRngGFSR4.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLRngGFSR4.html
https://root.cern/root/html534/ROOT__Math__GSLRngMT.html:610,Availability,avail,available,610,". ROOT::Math::GSLRngMT. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLRngMT. class ROOT::Math::GSLRngMT: public ROOT::Math::GSLRandomEngine. GSLRandomEngine; Base class for all GSL random engines,; normally user instantiate the derived classes; which creates internally the generator. The main GSL generators (see; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Random-number-generator-algorithms.html"">; here</A>) are available as derived classes; In addition to generate uniform numbers it provides method for; generating numbers according to pre-defined distributions; using the GSL functions from; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Random-Number-Distributions.html"">; GSL random number distributions</A>. @ingroup Random. Function Members (Methods); public:. ~GSLRngMT(); unsigned intROOT::Math::GSLRandomEngine::Binomial(double p, unsigned int n) const; doubleROOT::Math::GSLRandomEngine::Cauchy(double a) const; doubleROOT::Math::GSLRandomEngine::ChiSquare(double nu) const; voidROOT::Math::GSLRandomEngine::Dir2D(double& x, double& y) const; voidROOT::Math::GSLRandomEngine::Dir3D(double& x, double& y, double& z) const; doubleROOT::Math::GSLRandomEngine::Exponential(double mu) const; doubleROOT::Math::GSLRandomEngine::FDist(double nu1, double nu2) const; doubleROOT::Math::GSLRandomEngine::Gamma(double a, double b) const; doubleROOT::Math::GSLRandomEngine::Gaussian(double sigma) const; voidROOT::Math::GSLRandomEngine::Gaussian2D(double sigmaX, double sigmaY, double rho, double& x, double& y) const; doubleROOT::Math::GSLRandomEngine::GaussianRatio(double sigma) const; doubleROOT::Math::GSLRandomEngine::GaussianTail(double a, double sigma) const; doubleROOT::Math::GSLRandomEngine::GaussianZig(double sigma) const; ROOT::Math::GSLRandomEngineROOT::Math::GSLRandomEngine::",MatchSource.WIKI,root/html534/ROOT__Math__GSLRngMT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLRngMT.html
https://root.cern/root/html534/ROOT__Math__GSLRngRanLux.html:622,Availability,avail,available,622,". ROOT::Math::GSLRngRanLux. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLRngRanLux. class ROOT::Math::GSLRngRanLux: public ROOT::Math::GSLRandomEngine. GSLRandomEngine; Base class for all GSL random engines,; normally user instantiate the derived classes; which creates internally the generator. The main GSL generators (see; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Random-number-generator-algorithms.html"">; here</A>) are available as derived classes; In addition to generate uniform numbers it provides method for; generating numbers according to pre-defined distributions; using the GSL functions from; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Random-Number-Distributions.html"">; GSL random number distributions</A>. @ingroup Random. Function Members (Methods); public:. ~GSLRngRanLux(); unsigned intROOT::Math::GSLRandomEngine::Binomial(double p, unsigned int n) const; doubleROOT::Math::GSLRandomEngine::Cauchy(double a) const; doubleROOT::Math::GSLRandomEngine::ChiSquare(double nu) const; voidROOT::Math::GSLRandomEngine::Dir2D(double& x, double& y) const; voidROOT::Math::GSLRandomEngine::Dir3D(double& x, double& y, double& z) const; doubleROOT::Math::GSLRandomEngine::Exponential(double mu) const; doubleROOT::Math::GSLRandomEngine::FDist(double nu1, double nu2) const; doubleROOT::Math::GSLRandomEngine::Gamma(double a, double b) const; doubleROOT::Math::GSLRandomEngine::Gaussian(double sigma) const; voidROOT::Math::GSLRandomEngine::Gaussian2D(double sigmaX, double sigmaY, double rho, double& x, double& y) const; doubleROOT::Math::GSLRandomEngine::GaussianRatio(double sigma) const; doubleROOT::Math::GSLRandomEngine::GaussianTail(double a, double sigma) const; doubleROOT::Math::GSLRandomEngine::GaussianZig(double sigma) const; ROOT::Math::GSLRandomEngineROOT::Math::G",MatchSource.WIKI,root/html534/ROOT__Math__GSLRngRanLux.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLRngRanLux.html
https://root.cern/root/html534/ROOT__Math__GSLRngRanLuxD1.html:628,Availability,avail,available,628,". ROOT::Math::GSLRngRanLuxD1. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLRngRanLuxD1. class ROOT::Math::GSLRngRanLuxD1: public ROOT::Math::GSLRandomEngine. GSLRandomEngine; Base class for all GSL random engines,; normally user instantiate the derived classes; which creates internally the generator. The main GSL generators (see; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Random-number-generator-algorithms.html"">; here</A>) are available as derived classes; In addition to generate uniform numbers it provides method for; generating numbers according to pre-defined distributions; using the GSL functions from; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Random-Number-Distributions.html"">; GSL random number distributions</A>. @ingroup Random. Function Members (Methods); public:. ~GSLRngRanLuxD1(); unsigned intROOT::Math::GSLRandomEngine::Binomial(double p, unsigned int n) const; doubleROOT::Math::GSLRandomEngine::Cauchy(double a) const; doubleROOT::Math::GSLRandomEngine::ChiSquare(double nu) const; voidROOT::Math::GSLRandomEngine::Dir2D(double& x, double& y) const; voidROOT::Math::GSLRandomEngine::Dir3D(double& x, double& y, double& z) const; doubleROOT::Math::GSLRandomEngine::Exponential(double mu) const; doubleROOT::Math::GSLRandomEngine::FDist(double nu1, double nu2) const; doubleROOT::Math::GSLRandomEngine::Gamma(double a, double b) const; doubleROOT::Math::GSLRandomEngine::Gaussian(double sigma) const; voidROOT::Math::GSLRandomEngine::Gaussian2D(double sigmaX, double sigmaY, double rho, double& x, double& y) const; doubleROOT::Math::GSLRandomEngine::GaussianRatio(double sigma) const; doubleROOT::Math::GSLRandomEngine::GaussianTail(double a, double sigma) const; doubleROOT::Math::GSLRandomEngine::GaussianZig(double sigma) const; ROOT::Math::GSLRandomEngineROOT:",MatchSource.WIKI,root/html534/ROOT__Math__GSLRngRanLuxD1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLRngRanLuxD1.html
https://root.cern/root/html534/ROOT__Math__GSLRngRanLuxD2.html:628,Availability,avail,available,628,". ROOT::Math::GSLRngRanLuxD2. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLRngRanLuxD2. class ROOT::Math::GSLRngRanLuxD2: public ROOT::Math::GSLRandomEngine. GSLRandomEngine; Base class for all GSL random engines,; normally user instantiate the derived classes; which creates internally the generator. The main GSL generators (see; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Random-number-generator-algorithms.html"">; here</A>) are available as derived classes; In addition to generate uniform numbers it provides method for; generating numbers according to pre-defined distributions; using the GSL functions from; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Random-Number-Distributions.html"">; GSL random number distributions</A>. @ingroup Random. This class is also known as (typedefs to this class)ROOT::Math::GSLRngRanLux48. Function Members (Methods); public:. ~GSLRngRanLuxD2(); unsigned intROOT::Math::GSLRandomEngine::Binomial(double p, unsigned int n) const; doubleROOT::Math::GSLRandomEngine::Cauchy(double a) const; doubleROOT::Math::GSLRandomEngine::ChiSquare(double nu) const; voidROOT::Math::GSLRandomEngine::Dir2D(double& x, double& y) const; voidROOT::Math::GSLRandomEngine::Dir3D(double& x, double& y, double& z) const; doubleROOT::Math::GSLRandomEngine::Exponential(double mu) const; doubleROOT::Math::GSLRandomEngine::FDist(double nu1, double nu2) const; doubleROOT::Math::GSLRandomEngine::Gamma(double a, double b) const; doubleROOT::Math::GSLRandomEngine::Gaussian(double sigma) const; voidROOT::Math::GSLRandomEngine::Gaussian2D(double sigmaX, double sigmaY, double rho, double& x, double& y) const; doubleROOT::Math::GSLRandomEngine::GaussianRatio(double sigma) const; doubleROOT::Math::GSLRandomEngine::GaussianTail(double a, double sigma) const; doubleROOT::Math::GS",MatchSource.WIKI,root/html534/ROOT__Math__GSLRngRanLuxD2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLRngRanLuxD2.html
https://root.cern/root/html534/ROOT__Math__GSLRngRanLuxS1.html:628,Availability,avail,available,628,". ROOT::Math::GSLRngRanLuxS1. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLRngRanLuxS1. class ROOT::Math::GSLRngRanLuxS1: public ROOT::Math::GSLRandomEngine. GSLRandomEngine; Base class for all GSL random engines,; normally user instantiate the derived classes; which creates internally the generator. The main GSL generators (see; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Random-number-generator-algorithms.html"">; here</A>) are available as derived classes; In addition to generate uniform numbers it provides method for; generating numbers according to pre-defined distributions; using the GSL functions from; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Random-Number-Distributions.html"">; GSL random number distributions</A>. @ingroup Random. This class is also known as (typedefs to this class)ROOT::Math::GSLRngRanLux1. Function Members (Methods); public:. ~GSLRngRanLuxS1(); unsigned intROOT::Math::GSLRandomEngine::Binomial(double p, unsigned int n) const; doubleROOT::Math::GSLRandomEngine::Cauchy(double a) const; doubleROOT::Math::GSLRandomEngine::ChiSquare(double nu) const; voidROOT::Math::GSLRandomEngine::Dir2D(double& x, double& y) const; voidROOT::Math::GSLRandomEngine::Dir3D(double& x, double& y, double& z) const; doubleROOT::Math::GSLRandomEngine::Exponential(double mu) const; doubleROOT::Math::GSLRandomEngine::FDist(double nu1, double nu2) const; doubleROOT::Math::GSLRandomEngine::Gamma(double a, double b) const; doubleROOT::Math::GSLRandomEngine::Gaussian(double sigma) const; voidROOT::Math::GSLRandomEngine::Gaussian2D(double sigmaX, double sigmaY, double rho, double& x, double& y) const; doubleROOT::Math::GSLRandomEngine::GaussianRatio(double sigma) const; doubleROOT::Math::GSLRandomEngine::GaussianTail(double a, double sigma) const; doubleROOT::Math::GSL",MatchSource.WIKI,root/html534/ROOT__Math__GSLRngRanLuxS1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLRngRanLuxS1.html
https://root.cern/root/html534/ROOT__Math__GSLRngRanLuxS2.html:628,Availability,avail,available,628,". ROOT::Math::GSLRngRanLuxS2. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLRngRanLuxS2. class ROOT::Math::GSLRngRanLuxS2: public ROOT::Math::GSLRandomEngine. GSLRandomEngine; Base class for all GSL random engines,; normally user instantiate the derived classes; which creates internally the generator. The main GSL generators (see; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Random-number-generator-algorithms.html"">; here</A>) are available as derived classes; In addition to generate uniform numbers it provides method for; generating numbers according to pre-defined distributions; using the GSL functions from; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Random-Number-Distributions.html"">; GSL random number distributions</A>. @ingroup Random. This class is also known as (typedefs to this class)ROOT::Math::GSLRngRanLux2. Function Members (Methods); public:. ~GSLRngRanLuxS2(); unsigned intROOT::Math::GSLRandomEngine::Binomial(double p, unsigned int n) const; doubleROOT::Math::GSLRandomEngine::Cauchy(double a) const; doubleROOT::Math::GSLRandomEngine::ChiSquare(double nu) const; voidROOT::Math::GSLRandomEngine::Dir2D(double& x, double& y) const; voidROOT::Math::GSLRandomEngine::Dir3D(double& x, double& y, double& z) const; doubleROOT::Math::GSLRandomEngine::Exponential(double mu) const; doubleROOT::Math::GSLRandomEngine::FDist(double nu1, double nu2) const; doubleROOT::Math::GSLRandomEngine::Gamma(double a, double b) const; doubleROOT::Math::GSLRandomEngine::Gaussian(double sigma) const; voidROOT::Math::GSLRandomEngine::Gaussian2D(double sigmaX, double sigmaY, double rho, double& x, double& y) const; doubleROOT::Math::GSLRandomEngine::GaussianRatio(double sigma) const; doubleROOT::Math::GSLRandomEngine::GaussianTail(double a, double sigma) const; doubleROOT::Math::GSL",MatchSource.WIKI,root/html534/ROOT__Math__GSLRngRanLuxS2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLRngRanLuxS2.html
https://root.cern/root/html534/ROOT__Math__GSLRngTaus.html:616,Availability,avail,available,616,". ROOT::Math::GSLRngTaus. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLRngTaus. class ROOT::Math::GSLRngTaus: public ROOT::Math::GSLRandomEngine. GSLRandomEngine; Base class for all GSL random engines,; normally user instantiate the derived classes; which creates internally the generator. The main GSL generators (see; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Random-number-generator-algorithms.html"">; here</A>) are available as derived classes; In addition to generate uniform numbers it provides method for; generating numbers according to pre-defined distributions; using the GSL functions from; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Random-Number-Distributions.html"">; GSL random number distributions</A>. @ingroup Random. Function Members (Methods); public:. ~GSLRngTaus(); unsigned intROOT::Math::GSLRandomEngine::Binomial(double p, unsigned int n) const; doubleROOT::Math::GSLRandomEngine::Cauchy(double a) const; doubleROOT::Math::GSLRandomEngine::ChiSquare(double nu) const; voidROOT::Math::GSLRandomEngine::Dir2D(double& x, double& y) const; voidROOT::Math::GSLRandomEngine::Dir3D(double& x, double& y, double& z) const; doubleROOT::Math::GSLRandomEngine::Exponential(double mu) const; doubleROOT::Math::GSLRandomEngine::FDist(double nu1, double nu2) const; doubleROOT::Math::GSLRandomEngine::Gamma(double a, double b) const; doubleROOT::Math::GSLRandomEngine::Gaussian(double sigma) const; voidROOT::Math::GSLRandomEngine::Gaussian2D(double sigmaX, double sigmaY, double rho, double& x, double& y) const; doubleROOT::Math::GSLRandomEngine::GaussianRatio(double sigma) const; doubleROOT::Math::GSLRandomEngine::GaussianTail(double a, double sigma) const; doubleROOT::Math::GSLRandomEngine::GaussianZig(double sigma) const; ROOT::Math::GSLRandomEngineROOT::Math::GSLRandom",MatchSource.WIKI,root/html534/ROOT__Math__GSLRngTaus.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLRngTaus.html
https://root.cern/root/html534/ROOT__Math__GSLRootFinder.html:2763,Availability,error,error,2763,"virtual boolSetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); boolSetFunction(ROOT::Math::GSLRootFinder::GSLFuncPointer f, void* params, double xlow, double xup); virtual boolSolve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); virtual intStatus() const. protected:. voidFreeSolver(); voidSetSolver(ROOT::Math::GSLRootFSolver* s). private:. ROOT::Math::GSLRootFinderGSLRootFinder(const ROOT::Math::GSLRootFinder&); ROOT::Math::GSLRootFinder&operator=(const ROOT::Math::GSLRootFinder&). Data Members; private:. ROOT::Math::GSLFunctionWrapper*fFunction; intfIter; doublefRoot; ROOT::Math::GSLRootFSolver*fS; intfStatus; boolfValidInterval; doublefXlow; doublefXup. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLRootFinder(). virtual ~GSLRootFinder(). GSLRootFinder(const ROOT::Math::GSLRootFinder& ); usually copying is non trivial, so we make this unaccessible. bool SetFunction(const ROOT::Math::IGradFunction& , double ). bool SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup). bool SetFunction(ROOT::Math::GSLRootFinder::GSLFuncPointer f, void* params, double xlow, double xup). int Iterate(); iterate to find ROOTS return GSL_CONTINUE if iteration was successful or another error. double Root() const. bool Solve(int maxIter = 100, double absTol = 1E-8, double relTol = 1E-10); double XLower() const;; double XUpper() const;; Find the root. int Iterations() const; Return number of iterations. int Status() const; Return the status of last root finding. { return fStatus; }. const char * Name() const. void SetSolver(ROOT::Math::GSLRootFSolver* s). void FreeSolver().  Author: L. Moneta, A. Zsenei 08/2005  Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *;  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__GSLRootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLRootFinder.html
https://root.cern/root/html534/ROOT__Math__GSLSimAnFunc.html:3279,Deployability,configurat,configuration,3279,"algorithm). GSLSimAnFunc(). derived classes might need to re-define completely the class. {}. virtual ~GSLSimAnFunc(); virtual distructor (no operations). { }. GSLSimAnFunc & FastCopy(const ROOT::Math::GSLSimAnFunc& f). fast copy method called by GSL simuated annealing internally; copy only the things which have been changed; must be re-implemented by derived classes if needed. GSLSimAnFunc * Clone() const. clone method. Needs to be re-implemented by the derived classes for deep copying. return new GSLSimAnFunc(const ROOT::Math::GSLSimAnFunc& ). double Energy() const. evaluate the energy ( objective function value); re-implement by derived classes if needed to be modified. void Step(const ROOT::Math::GSLRandomEngine& r, double maxstep). change the x[i] value using a random value urndm generated between [0,1]; up to a maximum value maxstep; re-implement by derived classes if needed to be modified. double Distance(const ROOT::Math::GSLSimAnFunc& func) const. calculate the distance (metric) between this one and another configuration; Presently a cartesian metric is used.; re-implement by derived classes if needed to be modified. void Print(). print the position in the standard output ostream; GSL prints in addition n iteration, n function calls, temperature and energy; re-implement by derived classes if necessary. void SetX(const double* x). change the x values (used by sim annealing to take a step). void SetX(unsigned int i, double x). unsigned int NDim() const; { return fX.size(); }. double X(unsigned int i) const; { return fX[i]; }. const std::vector<double> & X() const; { return fX; }. double Scale(unsigned int i) const; { return fScale[i]; }.  Author: L. Moneta Thu Jan 25 11:13:48 2007  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__GSLSimAnFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLSimAnFunc.html
https://root.cern/root/html534/ROOT__Math__GSLSimAnFunc.html:2835,Energy Efficiency,energy,energy,2835,"st double* x). construct from an interface of a multi-dimensional function. GSLSimAnFunc(const ROOT::Math::IMultiGenFunction& func, const double* x, const double* scale). construct from an interface of a multi-dimensional function; Use optionally a scale factor (for each coordinate) which can be used to scale the step sizes; (this is used for example by the minimization algorithm). GSLSimAnFunc(). derived classes might need to re-define completely the class. {}. virtual ~GSLSimAnFunc(); virtual distructor (no operations). { }. GSLSimAnFunc & FastCopy(const ROOT::Math::GSLSimAnFunc& f). fast copy method called by GSL simuated annealing internally; copy only the things which have been changed; must be re-implemented by derived classes if needed. GSLSimAnFunc * Clone() const. clone method. Needs to be re-implemented by the derived classes for deep copying. return new GSLSimAnFunc(const ROOT::Math::GSLSimAnFunc& ). double Energy() const. evaluate the energy ( objective function value); re-implement by derived classes if needed to be modified. void Step(const ROOT::Math::GSLRandomEngine& r, double maxstep). change the x[i] value using a random value urndm generated between [0,1]; up to a maximum value maxstep; re-implement by derived classes if needed to be modified. double Distance(const ROOT::Math::GSLSimAnFunc& func) const. calculate the distance (metric) between this one and another configuration; Presently a cartesian metric is used.; re-implement by derived classes if needed to be modified. void Print(). print the position in the standard output ostream; GSL prints in addition n iteration, n function calls, temperature and energy; re-implement by derived classes if necessary. void SetX(const double* x). change the x values (used by sim annealing to take a step). void SetX(unsigned int i, double x). unsigned int NDim() const; { return fX.size(); }. double X(unsigned int i) const; { return fX[i]; }. const std::vector<double> & X() const; { return fX; }. double Scale(u",MatchSource.WIKI,root/html534/ROOT__Math__GSLSimAnFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLSimAnFunc.html
https://root.cern/root/html534/ROOT__Math__GSLSimAnFunc.html:3526,Energy Efficiency,energy,energy,3526,"algorithm). GSLSimAnFunc(). derived classes might need to re-define completely the class. {}. virtual ~GSLSimAnFunc(); virtual distructor (no operations). { }. GSLSimAnFunc & FastCopy(const ROOT::Math::GSLSimAnFunc& f). fast copy method called by GSL simuated annealing internally; copy only the things which have been changed; must be re-implemented by derived classes if needed. GSLSimAnFunc * Clone() const. clone method. Needs to be re-implemented by the derived classes for deep copying. return new GSLSimAnFunc(const ROOT::Math::GSLSimAnFunc& ). double Energy() const. evaluate the energy ( objective function value); re-implement by derived classes if needed to be modified. void Step(const ROOT::Math::GSLRandomEngine& r, double maxstep). change the x[i] value using a random value urndm generated between [0,1]; up to a maximum value maxstep; re-implement by derived classes if needed to be modified. double Distance(const ROOT::Math::GSLSimAnFunc& func) const. calculate the distance (metric) between this one and another configuration; Presently a cartesian metric is used.; re-implement by derived classes if needed to be modified. void Print(). print the position in the standard output ostream; GSL prints in addition n iteration, n function calls, temperature and energy; re-implement by derived classes if necessary. void SetX(const double* x). change the x values (used by sim annealing to take a step). void SetX(unsigned int i, double x). unsigned int NDim() const; { return fX.size(); }. double X(unsigned int i) const; { return fX[i]; }. const std::vector<double> & X() const; { return fX; }. double Scale(unsigned int i) const; { return fScale[i]; }.  Author: L. Moneta Thu Jan 25 11:13:48 2007  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__GSLSimAnFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLSimAnFunc.html
https://root.cern/root/html534/ROOT__Math__GSLSimAnFunc.html:1907,Integrability,interface,interface,1907," virtual ROOT::Math::GSLSimAnFunc&FastCopy(const ROOT::Math::GSLSimAnFunc& f); ROOT::Math::GSLSimAnFuncGSLSimAnFunc(const ROOT::Math::GSLSimAnFunc&); ROOT::Math::GSLSimAnFuncGSLSimAnFunc(const ROOT::Math::IMultiGenFunction& func, const double* x); ROOT::Math::GSLSimAnFuncGSLSimAnFunc(const ROOT::Math::IMultiGenFunction& func, const double* x, const double* scale); unsigned intNDim() const; virtual voidPrint(); doubleScale(unsigned int i) const; voidSetX(const double* x); voidSetX(unsigned int i, double x); virtual voidStep(const ROOT::Math::GSLRandomEngine& r, double maxstep); const vector<double>&X() const; doubleX(unsigned int i) const. protected:. ROOT::Math::GSLSimAnFuncGSLSimAnFunc(). Data Members; private:. const ROOT::Math::IMultiGenFunction*fFunc; vector<double>fScale; vector<double>fX. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLSimAnFunc(const ROOT::Math::IMultiGenFunction& func, const double* x). construct from an interface of a multi-dimensional function. GSLSimAnFunc(const ROOT::Math::IMultiGenFunction& func, const double* x, const double* scale). construct from an interface of a multi-dimensional function; Use optionally a scale factor (for each coordinate) which can be used to scale the step sizes; (this is used for example by the minimization algorithm). GSLSimAnFunc(). derived classes might need to re-define completely the class. {}. virtual ~GSLSimAnFunc(); virtual distructor (no operations). { }. GSLSimAnFunc & FastCopy(const ROOT::Math::GSLSimAnFunc& f). fast copy method called by GSL simuated annealing internally; copy only the things which have been changed; must be re-implemented by derived classes if needed. GSLSimAnFunc * Clone() const. clone method. Needs to be re-implemented by the derived classes for deep copying. return new GSLSimAnFunc(const ROOT::Math::GSLSimAnFunc& ). double Energy() const. evaluate the energy ( objective function value); re-implement by derived classes if needed to be ",MatchSource.WIKI,root/html534/ROOT__Math__GSLSimAnFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLSimAnFunc.html
https://root.cern/root/html534/ROOT__Math__GSLSimAnFunc.html:2063,Integrability,interface,interface,2063,"st double* x); ROOT::Math::GSLSimAnFuncGSLSimAnFunc(const ROOT::Math::IMultiGenFunction& func, const double* x, const double* scale); unsigned intNDim() const; virtual voidPrint(); doubleScale(unsigned int i) const; voidSetX(const double* x); voidSetX(unsigned int i, double x); virtual voidStep(const ROOT::Math::GSLRandomEngine& r, double maxstep); const vector<double>&X() const; doubleX(unsigned int i) const. protected:. ROOT::Math::GSLSimAnFuncGSLSimAnFunc(). Data Members; private:. const ROOT::Math::IMultiGenFunction*fFunc; vector<double>fScale; vector<double>fX. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLSimAnFunc(const ROOT::Math::IMultiGenFunction& func, const double* x). construct from an interface of a multi-dimensional function. GSLSimAnFunc(const ROOT::Math::IMultiGenFunction& func, const double* x, const double* scale). construct from an interface of a multi-dimensional function; Use optionally a scale factor (for each coordinate) which can be used to scale the step sizes; (this is used for example by the minimization algorithm). GSLSimAnFunc(). derived classes might need to re-define completely the class. {}. virtual ~GSLSimAnFunc(); virtual distructor (no operations). { }. GSLSimAnFunc & FastCopy(const ROOT::Math::GSLSimAnFunc& f). fast copy method called by GSL simuated annealing internally; copy only the things which have been changed; must be re-implemented by derived classes if needed. GSLSimAnFunc * Clone() const. clone method. Needs to be re-implemented by the derived classes for deep copying. return new GSLSimAnFunc(const ROOT::Math::GSLSimAnFunc& ). double Energy() const. evaluate the energy ( objective function value); re-implement by derived classes if needed to be modified. void Step(const ROOT::Math::GSLRandomEngine& r, double maxstep). change the x[i] value using a random value urndm generated between [0,1]; up to a maximum value maxstep; re-implement by derived classes if needed to be modi",MatchSource.WIKI,root/html534/ROOT__Math__GSLSimAnFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLSimAnFunc.html
https://root.cern/root/html534/ROOT__Math__GSLSimAnFunc.html:3279,Modifiability,config,configuration,3279,"algorithm). GSLSimAnFunc(). derived classes might need to re-define completely the class. {}. virtual ~GSLSimAnFunc(); virtual distructor (no operations). { }. GSLSimAnFunc & FastCopy(const ROOT::Math::GSLSimAnFunc& f). fast copy method called by GSL simuated annealing internally; copy only the things which have been changed; must be re-implemented by derived classes if needed. GSLSimAnFunc * Clone() const. clone method. Needs to be re-implemented by the derived classes for deep copying. return new GSLSimAnFunc(const ROOT::Math::GSLSimAnFunc& ). double Energy() const. evaluate the energy ( objective function value); re-implement by derived classes if needed to be modified. void Step(const ROOT::Math::GSLRandomEngine& r, double maxstep). change the x[i] value using a random value urndm generated between [0,1]; up to a maximum value maxstep; re-implement by derived classes if needed to be modified. double Distance(const ROOT::Math::GSLSimAnFunc& func) const. calculate the distance (metric) between this one and another configuration; Presently a cartesian metric is used.; re-implement by derived classes if needed to be modified. void Print(). print the position in the standard output ostream; GSL prints in addition n iteration, n function calls, temperature and energy; re-implement by derived classes if necessary. void SetX(const double* x). change the x values (used by sim annealing to take a step). void SetX(unsigned int i, double x). unsigned int NDim() const; { return fX.size(); }. double X(unsigned int i) const; { return fX[i]; }. const std::vector<double> & X() const; { return fX; }. double Scale(unsigned int i) const; { return fScale[i]; }.  Author: L. Moneta Thu Jan 25 11:13:48 2007  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__GSLSimAnFunc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLSimAnFunc.html
https://root.cern/root/html534/ROOT__Math__GSLSimAnMinimizer.html:6824,Availability,error,errors,6824,"ROOT::Math::MinimTransformFunction*ROOT::Math::BasicMinimizer::TransformFunction() const; virtual intROOT::Math::BasicMinimizer::VariableIndex(const string& name) const; virtual stringROOT::Math::BasicMinimizer::VariableName(unsigned int ivar) const; virtual const double*ROOT::Math::BasicMinimizer::X() const. protected:. boolROOT::Math::BasicMinimizer::CheckDimension() const; boolROOT::Math::BasicMinimizer::CheckObjFunction() const; ROOT::Math::MinimTransformFunction*ROOT::Math::BasicMinimizer::CreateTransformation(vector<double>& startValues, const ROOT::Math::IMultiGradFunction* func = 0); voidROOT::Math::BasicMinimizer::SetFinalValues(const double* x); voidROOT::Math::BasicMinimizer::SetMinValue(double val). private:. ROOT::Math::GSLSimAnMinimizerGSLSimAnMinimizer(const ROOT::Math::GSLSimAnMinimizer&); ROOT::Math::GSLSimAnMinimizer&operator=(const ROOT::Math::GSLSimAnMinimizer& rhs). Data Members; protected:. ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::fOptionsminimizer options; intROOT::Math::Minimizer::fStatusstatus of minimizer ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. ROOT::Math::GSLSimAnnealingfSolver. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLSimAnMinimizer(int type = 0). Default constructor. virtual ~GSLSimAnMinimizer(). Destructor (no operations). GSLSimAnMinimizer(const ROOT::Math::GSLSimAnMinimizer& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. {}. bool Minimize(); method to perform the minimization. unsigned int NCalls() const; number of calls.  Author: L. Moneta Wed Dec 20 17:16:32 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__GSLSimAnMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLSimAnMinimizer.html
https://root.cern/root/html534/ROOT__Math__GSLSimAnMinimizer.html:571,Integrability,interface,interface,571,". ROOT::Math::GSLSimAnMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLSimAnMinimizer. class ROOT::Math::GSLSimAnMinimizer: public ROOT::Math::BasicMinimizer. GSLSimAnMinimizer class for minimization using simulated annealing; using the algorithm from; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Simulated-Annealing.html"">; GSL</A>.; It implements the ROOT::Minimizer interface and; a plug-in (name ""GSLSimAn"") exists to instantiate this class via the plug-in manager. @ingroup MultiMin. Function Members (Methods); public:. virtual~GSLSimAnMinimizer(); ROOT::Math::BasicMinimizerROOT::Math::BasicMinimizer::BasicMinimizer(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolROOT::Math::Minimizer::Contour(unsigned int ivar, unsigned int jvar, unsigned int& npoints, double* xi, double* xj); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleROOT::Math::Minimizer::CovMatrix(unsigned int ivar, unsigned int jvar) const; virtual intROOT::Math::Minimizer::CovMatrixStatus() const; virtual doubleROOT::Math::Minimizer::Edm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*ROOT::Math::Minimizer::Errors() const; virtual boolROOT::Math::BasicMinimizer::FixVariable(unsigned int ivar); virtual boolROOT::Math::Minimizer::GetCovMatrix(double* covMat) const; virtual boolROOT::Math::Minimizer::GetHessianMatrix(double* hMat) const; virtual boolROOT::Math::Minimizer::GetMinosError(unsigned int ivar, double& errLow, double& errUp, int option = 0); virtual boolROOT::Math::BasicMinimizer::GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings& varObj) const; virtual doubleROOT::Math::Minimizer::GlobalCC(unsigned int ivar) const; const ROOT::Math::IMultiGradFunction*ROOT::Math::BasicMinimizer::GradObjFun",MatchSource.WIKI,root/html534/ROOT__Math__GSLSimAnMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLSimAnMinimizer.html
https://root.cern/root/html534/ROOT__Math__GSLSimAnMinimizer.html:588,Modifiability,plug-in,plug-in,588,". ROOT::Math::GSLSimAnMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLSimAnMinimizer. class ROOT::Math::GSLSimAnMinimizer: public ROOT::Math::BasicMinimizer. GSLSimAnMinimizer class for minimization using simulated annealing; using the algorithm from; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Simulated-Annealing.html"">; GSL</A>.; It implements the ROOT::Minimizer interface and; a plug-in (name ""GSLSimAn"") exists to instantiate this class via the plug-in manager. @ingroup MultiMin. Function Members (Methods); public:. virtual~GSLSimAnMinimizer(); ROOT::Math::BasicMinimizerROOT::Math::BasicMinimizer::BasicMinimizer(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolROOT::Math::Minimizer::Contour(unsigned int ivar, unsigned int jvar, unsigned int& npoints, double* xi, double* xj); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleROOT::Math::Minimizer::CovMatrix(unsigned int ivar, unsigned int jvar) const; virtual intROOT::Math::Minimizer::CovMatrixStatus() const; virtual doubleROOT::Math::Minimizer::Edm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*ROOT::Math::Minimizer::Errors() const; virtual boolROOT::Math::BasicMinimizer::FixVariable(unsigned int ivar); virtual boolROOT::Math::Minimizer::GetCovMatrix(double* covMat) const; virtual boolROOT::Math::Minimizer::GetHessianMatrix(double* hMat) const; virtual boolROOT::Math::Minimizer::GetMinosError(unsigned int ivar, double& errLow, double& errUp, int option = 0); virtual boolROOT::Math::BasicMinimizer::GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings& varObj) const; virtual doubleROOT::Math::Minimizer::GlobalCC(unsigned int ivar) const; const ROOT::Math::IMultiGradFunction*ROOT::Math::BasicMinimizer::GradObjFun",MatchSource.WIKI,root/html534/ROOT__Math__GSLSimAnMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLSimAnMinimizer.html
https://root.cern/root/html534/ROOT__Math__GSLSimAnMinimizer.html:655,Modifiability,plug-in,plug-in,655,". ROOT::Math::GSLSimAnMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::GSLSimAnMinimizer. class ROOT::Math::GSLSimAnMinimizer: public ROOT::Math::BasicMinimizer. GSLSimAnMinimizer class for minimization using simulated annealing; using the algorithm from; <A HREF=""http://www.gnu.org/software/gsl/manual/html_node/Simulated-Annealing.html"">; GSL</A>.; It implements the ROOT::Minimizer interface and; a plug-in (name ""GSLSimAn"") exists to instantiate this class via the plug-in manager. @ingroup MultiMin. Function Members (Methods); public:. virtual~GSLSimAnMinimizer(); ROOT::Math::BasicMinimizerROOT::Math::BasicMinimizer::BasicMinimizer(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolROOT::Math::Minimizer::Contour(unsigned int ivar, unsigned int jvar, unsigned int& npoints, double* xi, double* xj); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleROOT::Math::Minimizer::CovMatrix(unsigned int ivar, unsigned int jvar) const; virtual intROOT::Math::Minimizer::CovMatrixStatus() const; virtual doubleROOT::Math::Minimizer::Edm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*ROOT::Math::Minimizer::Errors() const; virtual boolROOT::Math::BasicMinimizer::FixVariable(unsigned int ivar); virtual boolROOT::Math::Minimizer::GetCovMatrix(double* covMat) const; virtual boolROOT::Math::Minimizer::GetHessianMatrix(double* hMat) const; virtual boolROOT::Math::Minimizer::GetMinosError(unsigned int ivar, double& errLow, double& errUp, int option = 0); virtual boolROOT::Math::BasicMinimizer::GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings& varObj) const; virtual doubleROOT::Math::Minimizer::GlobalCC(unsigned int ivar) const; const ROOT::Math::IMultiGradFunction*ROOT::Math::BasicMinimizer::GradObjFun",MatchSource.WIKI,root/html534/ROOT__Math__GSLSimAnMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLSimAnMinimizer.html
https://root.cern/root/html534/ROOT__Math__GSLSimAnMinimizer.html:7309,Performance,perform,perform,7309,"ROOT::Math::MinimTransformFunction*ROOT::Math::BasicMinimizer::TransformFunction() const; virtual intROOT::Math::BasicMinimizer::VariableIndex(const string& name) const; virtual stringROOT::Math::BasicMinimizer::VariableName(unsigned int ivar) const; virtual const double*ROOT::Math::BasicMinimizer::X() const. protected:. boolROOT::Math::BasicMinimizer::CheckDimension() const; boolROOT::Math::BasicMinimizer::CheckObjFunction() const; ROOT::Math::MinimTransformFunction*ROOT::Math::BasicMinimizer::CreateTransformation(vector<double>& startValues, const ROOT::Math::IMultiGradFunction* func = 0); voidROOT::Math::BasicMinimizer::SetFinalValues(const double* x); voidROOT::Math::BasicMinimizer::SetMinValue(double val). private:. ROOT::Math::GSLSimAnMinimizerGSLSimAnMinimizer(const ROOT::Math::GSLSimAnMinimizer&); ROOT::Math::GSLSimAnMinimizer&operator=(const ROOT::Math::GSLSimAnMinimizer& rhs). Data Members; protected:. ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::fOptionsminimizer options; intROOT::Math::Minimizer::fStatusstatus of minimizer ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. ROOT::Math::GSLSimAnnealingfSolver. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLSimAnMinimizer(int type = 0). Default constructor. virtual ~GSLSimAnMinimizer(). Destructor (no operations). GSLSimAnMinimizer(const ROOT::Math::GSLSimAnMinimizer& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. {}. bool Minimize(); method to perform the minimization. unsigned int NCalls() const; number of calls.  Author: L. Moneta Wed Dec 20 17:16:32 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__GSLSimAnMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLSimAnMinimizer.html
https://root.cern/root/html534/ROOT__Math__GSLSimAnMinimizer.html:6841,Security,validat,validated,6841,"ROOT::Math::MinimTransformFunction*ROOT::Math::BasicMinimizer::TransformFunction() const; virtual intROOT::Math::BasicMinimizer::VariableIndex(const string& name) const; virtual stringROOT::Math::BasicMinimizer::VariableName(unsigned int ivar) const; virtual const double*ROOT::Math::BasicMinimizer::X() const. protected:. boolROOT::Math::BasicMinimizer::CheckDimension() const; boolROOT::Math::BasicMinimizer::CheckObjFunction() const; ROOT::Math::MinimTransformFunction*ROOT::Math::BasicMinimizer::CreateTransformation(vector<double>& startValues, const ROOT::Math::IMultiGradFunction* func = 0); voidROOT::Math::BasicMinimizer::SetFinalValues(const double* x); voidROOT::Math::BasicMinimizer::SetMinValue(double val). private:. ROOT::Math::GSLSimAnMinimizerGSLSimAnMinimizer(const ROOT::Math::GSLSimAnMinimizer&); ROOT::Math::GSLSimAnMinimizer&operator=(const ROOT::Math::GSLSimAnMinimizer& rhs). Data Members; protected:. ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::fOptionsminimizer options; intROOT::Math::Minimizer::fStatusstatus of minimizer ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. ROOT::Math::GSLSimAnnealingfSolver. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GSLSimAnMinimizer(int type = 0). Default constructor. virtual ~GSLSimAnMinimizer(). Destructor (no operations). GSLSimAnMinimizer(const ROOT::Math::GSLSimAnMinimizer& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. {}. bool Minimize(); method to perform the minimization. unsigned int NCalls() const; number of calls.  Author: L. Moneta Wed Dec 20 17:16:32 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__GSLSimAnMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLSimAnMinimizer.html
https://root.cern/root/html534/ROOT__Math__IBaseFunctionMultiDim.html:2171,Availability,avail,available,2171,"ion, ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::BaseFunction, ROOT::Math::Functor::ImplBase, ROOT::Fit::Chi2FCN<ROOT::Math::IBaseFunctionMultiDim>::BaseFunction, ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::BaseFunction, ROOT::Math::IParametricFunctionMultiDim::BaseFunc, ROOT::Math::MinimTransformFunction::BaseFunc, ROOT::Math::IParametricGradFunctionMultiDim::BaseFunc, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseFunction, ROOT::Math::IBaseFunctionMultiDim::BaseFunc, ROOT::Math::GradFunctor::ImplBase, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseFunction, ROOT::Math::IGradientFunctionMultiDim::BaseFunc, ROOT::Fit::Fitter::BaseFunc, ROOT::Math::WrappedMultiTF1::BaseFunc, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseFunction. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~IBaseFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*Clone() const; virtual unsigned intNDim() const; doubleoperator()(const double* x) const; ROOT::Math::IBaseFunctionMultiDim&operator=(const ROOT::Math::IBaseFunctionMultiDim&). private:. virtual doubleDoEval(const double* x) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IBaseFunctionMultiDim(). virtual destructor. {}. IBaseFunctionMultiDim * Clone() const. Clone a function.; Each derived class must implement his version of the Clone method. unsigned int NDim() const. Retrieve the dimension of the function. double operator()(const double* x) const. Evaluate the function at a point x[].; Use the pure virtual private method DoEval which must be implemented by the sub-classes. return DoEval(x).  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comm",MatchSource.WIKI,root/html534/ROOT__Math__IBaseFunctionMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IBaseFunctionMultiDim.html
https://root.cern/root/html534/ROOT__Math__IBaseFunctionMultiDim.html:616,Integrability,interface,interface,616,". ROOT::Math::IBaseFunctionMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IBaseFunctionMultiDim. class ROOT::Math::IBaseFunctionMultiDim. Documentation for the abstract class IBaseFunctionMultiDim.; Interface (abstract class) for generic functions objects of multi-dimension; Provides a method to evaluate the function given a vector of coordinate values,; by implementing operator() (const double *).; In addition it defines the interface for copying functions via the pure virtual method Clone(); and the interface for getting the function dimension via the NDim() method.; Derived classes must implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::IMultiGenFunction, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseFunction, ROOT::Fit::Chi2FCN<ROOT::Math::IGradientFunctionMultiDim>::BaseFunction, ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::BaseFunction, ROOT::Math::Functor::ImplBase, ROOT::Fit::Chi2FCN<ROOT::Math::IBaseFunctionMultiDim>::BaseFunction, ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::BaseFunction, ROOT::Math::IParametricFunctionMultiDim::BaseFunc, ROOT::Math::MinimTransformFunction::BaseFunc, ROOT::Math::IParametricGradFunctionMultiDim::BaseFunc, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseFunction, ROOT::Math::IBaseFunctionMultiDim::BaseFunc, ROOT::Math::GradFunctor::ImplBase, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseFunction, ROOT::Math::IGradientFunctionMultiDim::BaseFunc, ROOT::Fit::Fitter::BaseFunc, ROOT::Math::WrappedMultiTF1::BaseFunc, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradi",MatchSource.WIKI,root/html534/ROOT__Math__IBaseFunctionMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IBaseFunctionMultiDim.html
https://root.cern/root/html534/ROOT__Math__IBaseFunctionMultiDim.html:693,Integrability,interface,interface,693,". ROOT::Math::IBaseFunctionMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IBaseFunctionMultiDim. class ROOT::Math::IBaseFunctionMultiDim. Documentation for the abstract class IBaseFunctionMultiDim.; Interface (abstract class) for generic functions objects of multi-dimension; Provides a method to evaluate the function given a vector of coordinate values,; by implementing operator() (const double *).; In addition it defines the interface for copying functions via the pure virtual method Clone(); and the interface for getting the function dimension via the NDim() method.; Derived classes must implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::IMultiGenFunction, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseFunction, ROOT::Fit::Chi2FCN<ROOT::Math::IGradientFunctionMultiDim>::BaseFunction, ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::BaseFunction, ROOT::Math::Functor::ImplBase, ROOT::Fit::Chi2FCN<ROOT::Math::IBaseFunctionMultiDim>::BaseFunction, ROOT::Math::BasicFitMethodFunction<ROOT::Math::IBaseFunctionMultiDim>::BaseFunction, ROOT::Math::IParametricFunctionMultiDim::BaseFunc, ROOT::Math::MinimTransformFunction::BaseFunc, ROOT::Math::IParametricGradFunctionMultiDim::BaseFunc, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseFunction, ROOT::Math::IBaseFunctionMultiDim::BaseFunc, ROOT::Math::GradFunctor::ImplBase, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseFunction, ROOT::Math::IGradientFunctionMultiDim::BaseFunc, ROOT::Fit::Fitter::BaseFunc, ROOT::Math::WrappedMultiTF1::BaseFunc, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradi",MatchSource.WIKI,root/html534/ROOT__Math__IBaseFunctionMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IBaseFunctionMultiDim.html
https://root.cern/root/html534/ROOT__Math__IBaseFunctionOneDim.html:1512,Availability,avail,available,1512," a vector of coordinate values,; by implementing operator() (const double *).; In addition it defines the interface for copying functions via the pure virtual method Clone(); and the interface for getting the function dimension via the NDim() method.; Derived classes must implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::IParametricGradFunctionOneDim::BaseFunc, ROOT::Math::Functor1D::ImplBase, ROOT::Math::WrappedTF1::BaseFunc, ROOT::Math::IBaseFunctionOneDim::BaseFunc, ROOT::Math::GradFunctor1D::ImplBase, ROOT::Math::IGradientFunctionOneDim::BaseFunc, ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>::BaseFunc, ROOT::Math::IParametricFunctionOneDim::BaseFunc, ROOT::Math::IGenFunction. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~IBaseFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*Clone() const; doubleoperator()(double x) const; doubleoperator()(const double* x) const; ROOT::Math::IBaseFunctionOneDim&operator=(const ROOT::Math::IBaseFunctionOneDim&). private:. virtual doubleDoEval(double x) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IBaseFunctionMultiDim * Clone() const. Clone a function.; Each derived class must implement his version of the Clone method. double operator()(const double* x) const. Evaluate the function at a point x[].; Use the pure virtual private method DoEval which must be implemented by the sub-classes. return DoEval(x). double operator()(double x) const. Template method to eveluate the function using the begin of an iterator; User is responsible to provide correct size for the iterator. virtual ~IBaseFunctionOneDim(). virtual destructor. {}.  Last changed: root/mathcore:$Id$  ",MatchSource.WIKI,root/html534/ROOT__Math__IBaseFunctionOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IBaseFunctionOneDim.html
https://root.cern/root/html534/ROOT__Math__IBaseFunctionOneDim.html:610,Integrability,interface,interface,610,". ROOT::Math::IBaseFunctionOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IBaseFunctionOneDim. class ROOT::Math::IBaseFunctionOneDim. Documentation for the abstract class IBaseFunctionMultiDim.; Interface (abstract class) for generic functions objects of multi-dimension; Provides a method to evaluate the function given a vector of coordinate values,; by implementing operator() (const double *).; In addition it defines the interface for copying functions via the pure virtual method Clone(); and the interface for getting the function dimension via the NDim() method.; Derived classes must implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::IParametricGradFunctionOneDim::BaseFunc, ROOT::Math::Functor1D::ImplBase, ROOT::Math::WrappedTF1::BaseFunc, ROOT::Math::IBaseFunctionOneDim::BaseFunc, ROOT::Math::GradFunctor1D::ImplBase, ROOT::Math::IGradientFunctionOneDim::BaseFunc, ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>::BaseFunc, ROOT::Math::IParametricFunctionOneDim::BaseFunc, ROOT::Math::IGenFunction. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~IBaseFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*Clone() const; doubleoperator()(double x) const; doubleoperator()(const double* x) const; ROOT::Math::IBaseFunctionOneDim&operator=(const ROOT::Math::IBaseFunctionOneDim&). private:. virtual doubleDoEval(double x) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IBaseFunctionMultiDim * Clone() const. Clone a function.; Each derived c",MatchSource.WIKI,root/html534/ROOT__Math__IBaseFunctionOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IBaseFunctionOneDim.html
https://root.cern/root/html534/ROOT__Math__IBaseFunctionOneDim.html:687,Integrability,interface,interface,687,". ROOT::Math::IBaseFunctionOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IBaseFunctionOneDim. class ROOT::Math::IBaseFunctionOneDim. Documentation for the abstract class IBaseFunctionMultiDim.; Interface (abstract class) for generic functions objects of multi-dimension; Provides a method to evaluate the function given a vector of coordinate values,; by implementing operator() (const double *).; In addition it defines the interface for copying functions via the pure virtual method Clone(); and the interface for getting the function dimension via the NDim() method.; Derived classes must implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::IParametricGradFunctionOneDim::BaseFunc, ROOT::Math::Functor1D::ImplBase, ROOT::Math::WrappedTF1::BaseFunc, ROOT::Math::IBaseFunctionOneDim::BaseFunc, ROOT::Math::GradFunctor1D::ImplBase, ROOT::Math::IGradientFunctionOneDim::BaseFunc, ROOT::Math::ParamFunction<ROOT::Math::IParametricGradFunctionOneDim>::BaseFunc, ROOT::Math::IParametricFunctionOneDim::BaseFunc, ROOT::Math::IGenFunction. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~IBaseFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*Clone() const; doubleoperator()(double x) const; doubleoperator()(const double* x) const; ROOT::Math::IBaseFunctionOneDim&operator=(const ROOT::Math::IBaseFunctionOneDim&). private:. virtual doubleDoEval(double x) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IBaseFunctionMultiDim * Clone() const. Clone a function.; Each derived c",MatchSource.WIKI,root/html534/ROOT__Math__IBaseFunctionOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IBaseFunctionOneDim.html
https://root.cern/root/html534/ROOT__Math__IBaseParam.html:773,Availability,avail,available,773,". ROOT::Math::IBaseParam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IBaseParam. class ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~IBaseParam(); virtual unsigned intNPar() const; ROOT::Math::IBaseParam&operator=(const ROOT::Math::IBaseParam&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IBaseParam(). Virtual Destructor (no operations). {}. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values. to be defined: can user change number of params ? At the moment no. unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero); Overwrite if want to avoid the default name (""Par_0, Par_1, ..."").  Author: L. Moneta Tue Nov 14 14:20:07 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general p",MatchSource.WIKI,root/html534/ROOT__Math__IBaseParam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IBaseParam.html
https://root.cern/root/html534/ROOT__Math__IBaseParam.html:356,Integrability,interface,interface,356,". ROOT::Math::IBaseParam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IBaseParam. class ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~IBaseParam(); virtual unsigned intNPar() const; ROOT::Math::IBaseParam&operator=(const ROOT::Math::IBaseParam&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IBaseParam(). Virtual Destructor (no operations). {}. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values. to be defined: can user change number of params ? At the moment no. unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero); Overwrite if want to avoid the default name (""Par_0, Par_1, ..."").  Author: L. Moneta Tue Nov 14 14:20:07 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general p",MatchSource.WIKI,root/html534/ROOT__Math__IBaseParam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IBaseParam.html
https://root.cern/root/html534/ROOT__Math__IBaseParam.html:455,Safety,avoid,avoid,455,". ROOT::Math::IBaseParam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IBaseParam. class ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~IBaseParam(); virtual unsigned intNPar() const; ROOT::Math::IBaseParam&operator=(const ROOT::Math::IBaseParam&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IBaseParam(). Virtual Destructor (no operations). {}. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values. to be defined: can user change number of params ? At the moment no. unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero); Overwrite if want to avoid the default name (""Par_0, Par_1, ..."").  Author: L. Moneta Tue Nov 14 14:20:07 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general p",MatchSource.WIKI,root/html534/ROOT__Math__IBaseParam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IBaseParam.html
https://root.cern/root/html534/ROOT__Math__IBaseParam.html:1663,Safety,avoid,avoid,1663,"s:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IBaseParam. class ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~IBaseParam(); virtual unsigned intNPar() const; ROOT::Math::IBaseParam&operator=(const ROOT::Math::IBaseParam&); virtual stringParameterName(unsigned int i) const; virtual const double*Parameters() const; virtual voidSetParameters(const double* p). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IBaseParam(). Virtual Destructor (no operations). {}. const double * Parameters() const. Access the parameter values. void SetParameters(const double* p). Set the parameter values; @param p vector of doubles containing the parameter values. to be defined: can user change number of params ? At the moment no. unsigned int NPar() const. Return the number of Parameters. std::string ParameterName(unsigned int i) const. Return the name of the i-th parameter (starting from zero); Overwrite if want to avoid the default name (""Par_0, Par_1, ..."").  Author: L. Moneta Tue Nov 14 14:20:07 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__IBaseParam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IBaseParam.html
https://root.cern/root/html534/ROOT__Math__IGradientFunctionMultiDim.html:1382,Availability,avail,available,1382,"im, public ROOT::Math::IGradientMultiDim. Documentation for the abstract class IBaseFunctionMultiDim.; Interface (abstract class) for generic functions objects of multi-dimension; Provides a method to evaluate the function given a vector of coordinate values,; by implementing operator() (const double *).; In addition it defines the interface for copying functions via the pure virtual method Clone(); and the interface for getting the function dimension via the NDim() method.; Derived classes must implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::IParametricGradFunctionMultiDim::BaseGradFunc, ROOT::Fit::Fitter::BaseGradFunc, ROOT::Math::MinimTransformFunction::BaseGradFunc, ROOT::Math::IMultiGradFunction. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~IGradientFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidFdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* grad) const; virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::IGradientFunctionMultiDim&operator=(const ROOT::Math::IGradientFunctionMultiDim&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Gradient(const double* x, double* grad) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. void FdF(const double* x, double& f, double* df) const. Optimized ",MatchSource.WIKI,root/html534/ROOT__Math__IGradientFunctionMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IGradientFunctionMultiDim.html
https://root.cern/root/html534/ROOT__Math__IGradientFunctionMultiDim.html:2269,Energy Efficiency,efficient,efficient,2269,"lass is also known as (typedefs to this class)ROOT::Math::IParametricGradFunctionMultiDim::BaseGradFunc, ROOT::Fit::Fitter::BaseGradFunc, ROOT::Math::MinimTransformFunction::BaseGradFunc, ROOT::Math::IMultiGradFunction. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~IGradientFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidFdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* grad) const; virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::IGradientFunctionMultiDim&operator=(const ROOT::Math::IGradientFunctionMultiDim&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Gradient(const double* x, double* grad) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientFunctionMultiDim(). Virtual Destructor (no operations). {}.  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__IGradientFunctionMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IGradientFunctionMultiDim.html
https://root.cern/root/html534/ROOT__Math__IGradientFunctionMultiDim.html:2525,Energy Efficiency,efficient,efficient,2525,"lass is also known as (typedefs to this class)ROOT::Math::IParametricGradFunctionMultiDim::BaseGradFunc, ROOT::Fit::Fitter::BaseGradFunc, ROOT::Math::MinimTransformFunction::BaseGradFunc, ROOT::Math::IMultiGradFunction. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~IGradientFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidFdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* grad) const; virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::IGradientFunctionMultiDim&operator=(const ROOT::Math::IGradientFunctionMultiDim&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Gradient(const double* x, double* grad) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientFunctionMultiDim(). Virtual Destructor (no operations). {}.  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__IGradientFunctionMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IGradientFunctionMultiDim.html
https://root.cern/root/html534/ROOT__Math__IGradientFunctionMultiDim.html:708,Integrability,interface,interface,708,". ROOT::Math::IGradientFunctionMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IGradientFunctionMultiDim. class ROOT::Math::IGradientFunctionMultiDim: public ROOT::Math::IBaseFunctionMultiDim, public ROOT::Math::IGradientMultiDim. Documentation for the abstract class IBaseFunctionMultiDim.; Interface (abstract class) for generic functions objects of multi-dimension; Provides a method to evaluate the function given a vector of coordinate values,; by implementing operator() (const double *).; In addition it defines the interface for copying functions via the pure virtual method Clone(); and the interface for getting the function dimension via the NDim() method.; Derived classes must implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::IParametricGradFunctionMultiDim::BaseGradFunc, ROOT::Fit::Fitter::BaseGradFunc, ROOT::Math::MinimTransformFunction::BaseGradFunc, ROOT::Math::IMultiGradFunction. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~IGradientFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidFdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* grad) const; virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::IGradientFunctionMultiDim&operator=(const ROOT::Math::IGradientFunctionMultiDim&",MatchSource.WIKI,root/html534/ROOT__Math__IGradientFunctionMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IGradientFunctionMultiDim.html
https://root.cern/root/html534/ROOT__Math__IGradientFunctionMultiDim.html:785,Integrability,interface,interface,785,". ROOT::Math::IGradientFunctionMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IGradientFunctionMultiDim. class ROOT::Math::IGradientFunctionMultiDim: public ROOT::Math::IBaseFunctionMultiDim, public ROOT::Math::IGradientMultiDim. Documentation for the abstract class IBaseFunctionMultiDim.; Interface (abstract class) for generic functions objects of multi-dimension; Provides a method to evaluate the function given a vector of coordinate values,; by implementing operator() (const double *).; In addition it defines the interface for copying functions via the pure virtual method Clone(); and the interface for getting the function dimension via the NDim() method.; Derived classes must implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::IParametricGradFunctionMultiDim::BaseGradFunc, ROOT::Fit::Fitter::BaseGradFunc, ROOT::Math::MinimTransformFunction::BaseGradFunc, ROOT::Math::IMultiGradFunction. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~IGradientFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidFdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* grad) const; virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::IGradientFunctionMultiDim&operator=(const ROOT::Math::IGradientFunctionMultiDim&",MatchSource.WIKI,root/html534/ROOT__Math__IGradientFunctionMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IGradientFunctionMultiDim.html
https://root.cern/root/html534/ROOT__Math__IGradientFunctionMultiDim.html:2616,Performance,perform,performances,2616,"lass is also known as (typedefs to this class)ROOT::Math::IParametricGradFunctionMultiDim::BaseGradFunc, ROOT::Fit::Fitter::BaseGradFunc, ROOT::Math::MinimTransformFunction::BaseGradFunc, ROOT::Math::IMultiGradFunction. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~IGradientFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual voidFdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* grad) const; virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; ROOT::Math::IGradientFunctionMultiDim&operator=(const ROOT::Math::IGradientFunctionMultiDim&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Gradient(const double* x, double* grad) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientFunctionMultiDim(). Virtual Destructor (no operations). {}.  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__IGradientFunctionMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IGradientFunctionMultiDim.html
https://root.cern/root/html534/ROOT__Math__IGradientFunctionOneDim.html:1282,Availability,avail,available,1282,"ctionOneDim. class ROOT::Math::IGradientFunctionOneDim: public ROOT::Math::IBaseFunctionOneDim, public ROOT::Math::IGradientOneDim. Documentation for the abstract class IBaseFunctionMultiDim.; Interface (abstract class) for generic functions objects of multi-dimension; Provides a method to evaluate the function given a vector of coordinate values,; by implementing operator() (const double *).; In addition it defines the interface for copying functions via the pure virtual method Clone(); and the interface for getting the function dimension via the NDim() method.; Derived classes must implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::IParametricGradFunctionOneDim::BaseGradFunc, ROOT::Math::IGradFunction. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~IGradientFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; doubleROOT::Math::IGradientOneDim::Derivative(double x) const; doubleROOT::Math::IGradientOneDim::Derivative(const double* x) const; virtual voidFdF(double x, double& f, double& df) const; voidROOT::Math::IGradientOneDim::Gradient(const double* x, double* g) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(double x) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(const double* x) const; ROOT::Math::IGradientFunctionOneDim&operator=(const ROOT::Math::IGradientFunctionOneDim&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void FdF(double x, double& f, double& df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same ",MatchSource.WIKI,root/html534/ROOT__Math__IGradientFunctionOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IGradientFunctionOneDim.html
https://root.cern/root/html534/ROOT__Math__IGradientFunctionOneDim.html:2237,Energy Efficiency,efficient,efficient,2237,"pure virtual method Clone(); and the interface for getting the function dimension via the NDim() method.; Derived classes must implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::IParametricGradFunctionOneDim::BaseGradFunc, ROOT::Math::IGradFunction. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~IGradientFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; doubleROOT::Math::IGradientOneDim::Derivative(double x) const; doubleROOT::Math::IGradientOneDim::Derivative(const double* x) const; virtual voidFdF(double x, double& f, double& df) const; voidROOT::Math::IGradientOneDim::Gradient(const double* x, double* g) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(double x) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(const double* x) const; ROOT::Math::IGradientFunctionOneDim&operator=(const ROOT::Math::IGradientFunctionOneDim&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void FdF(double x, double& f, double& df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientFunctionOneDim(). Virtual Destructor (no operations). {}.  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__IGradientFunctionOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IGradientFunctionOneDim.html
https://root.cern/root/html534/ROOT__Math__IGradientFunctionOneDim.html:698,Integrability,interface,interface,698,". ROOT::Math::IGradientFunctionOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IGradientFunctionOneDim. class ROOT::Math::IGradientFunctionOneDim: public ROOT::Math::IBaseFunctionOneDim, public ROOT::Math::IGradientOneDim. Documentation for the abstract class IBaseFunctionMultiDim.; Interface (abstract class) for generic functions objects of multi-dimension; Provides a method to evaluate the function given a vector of coordinate values,; by implementing operator() (const double *).; In addition it defines the interface for copying functions via the pure virtual method Clone(); and the interface for getting the function dimension via the NDim() method.; Derived classes must implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::IParametricGradFunctionOneDim::BaseGradFunc, ROOT::Math::IGradFunction. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~IGradientFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; doubleROOT::Math::IGradientOneDim::Derivative(double x) const; doubleROOT::Math::IGradientOneDim::Derivative(const double* x) const; virtual voidFdF(double x, double& f, double& df) const; voidROOT::Math::IGradientOneDim::Gradient(const double* x, double* g) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(double x) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(const double* x) const; ROOT::Math::IGradientFunctionOneDim&operator=(const ROOT::Math::IGradientFunctionOneDim&). Class Charts. Inheritance; Inherited Members; Includes; Librarie",MatchSource.WIKI,root/html534/ROOT__Math__IGradientFunctionOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IGradientFunctionOneDim.html
https://root.cern/root/html534/ROOT__Math__IGradientFunctionOneDim.html:775,Integrability,interface,interface,775,". ROOT::Math::IGradientFunctionOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IGradientFunctionOneDim. class ROOT::Math::IGradientFunctionOneDim: public ROOT::Math::IBaseFunctionOneDim, public ROOT::Math::IGradientOneDim. Documentation for the abstract class IBaseFunctionMultiDim.; Interface (abstract class) for generic functions objects of multi-dimension; Provides a method to evaluate the function given a vector of coordinate values,; by implementing operator() (const double *).; In addition it defines the interface for copying functions via the pure virtual method Clone(); and the interface for getting the function dimension via the NDim() method.; Derived classes must implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::IParametricGradFunctionOneDim::BaseGradFunc, ROOT::Math::IGradFunction. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~IGradientFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; doubleROOT::Math::IGradientOneDim::Derivative(double x) const; doubleROOT::Math::IGradientOneDim::Derivative(const double* x) const; virtual voidFdF(double x, double& f, double& df) const; voidROOT::Math::IGradientOneDim::Gradient(const double* x, double* g) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(double x) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(const double* x) const; ROOT::Math::IGradientFunctionOneDim&operator=(const ROOT::Math::IGradientFunctionOneDim&). Class Charts. Inheritance; Inherited Members; Includes; Librarie",MatchSource.WIKI,root/html534/ROOT__Math__IGradientFunctionOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IGradientFunctionOneDim.html
https://root.cern/root/html534/ROOT__Math__IGradientFunctionOneDim.html:2328,Performance,perform,performances,2328,"pure virtual method Clone(); and the interface for getting the function dimension via the NDim() method.; Derived classes must implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::IParametricGradFunctionOneDim::BaseGradFunc, ROOT::Math::IGradFunction. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~IGradientFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; doubleROOT::Math::IGradientOneDim::Derivative(double x) const; doubleROOT::Math::IGradientOneDim::Derivative(const double* x) const; virtual voidFdF(double x, double& f, double& df) const; voidROOT::Math::IGradientOneDim::Gradient(const double* x, double* g) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(double x) const; doubleROOT::Math::IBaseFunctionOneDim::operator()(const double* x) const; ROOT::Math::IGradientFunctionOneDim&operator=(const ROOT::Math::IGradientFunctionOneDim&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void FdF(double x, double& f, double& df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientFunctionOneDim(). Virtual Destructor (no operations). {}.  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__IGradientFunctionOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IGradientFunctionOneDim.html
https://root.cern/root/html534/ROOT__Math__IGradientMultiDim.html:1153,Availability,avail,available,1153,"ons:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IGradientMultiDim. class ROOT::Math::IGradientMultiDim. Documentation for the abstract class IBaseFunctionMultiDim.; Interface (abstract class) for generic functions objects of multi-dimension; Provides a method to evaluate the function given a vector of coordinate values,; by implementing operator() (const double *).; In addition it defines the interface for copying functions via the pure virtual method Clone(); and the interface for getting the function dimension via the NDim() method.; Derived classes must implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::IGradientFunctionMultiDim::BaseGrad. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~IGradientMultiDim(); doubleDerivative(const double* x, unsigned int icoord = 0) const; virtual voidFdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* grad) const; ROOT::Math::IGradientMultiDim&operator=(const ROOT::Math::IGradientMultiDim&). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IGradientMultiDim(); virual destructor. {}. void Gradient(const double* x, double* grad) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double* x, unsigned int icoord = 0) const. Return the partial derivative with respect to the passed coordinate. return DoDerivative(x, icoord). void FdF(const double* x, double& f, double* df) const.",MatchSource.WIKI,root/html534/ROOT__Math__IGradientMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IGradientMultiDim.html
https://root.cern/root/html534/ROOT__Math__IGradientMultiDim.html:1883,Energy Efficiency,efficient,efficient,1883,"e NDim() method.; Derived classes must implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::IGradientFunctionMultiDim::BaseGrad. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~IGradientMultiDim(); doubleDerivative(const double* x, unsigned int icoord = 0) const; virtual voidFdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* grad) const; ROOT::Math::IGradientMultiDim&operator=(const ROOT::Math::IGradientMultiDim&). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IGradientMultiDim(); virual destructor. {}. void Gradient(const double* x, double* grad) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double* x, unsigned int icoord = 0) const. Return the partial derivative with respect to the passed coordinate. return DoDerivative(x, icoord). void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time.  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__IGradientMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IGradientMultiDim.html
https://root.cern/root/html534/ROOT__Math__IGradientMultiDim.html:2307,Energy Efficiency,efficient,efficient,2307,"e NDim() method.; Derived classes must implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::IGradientFunctionMultiDim::BaseGrad. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~IGradientMultiDim(); doubleDerivative(const double* x, unsigned int icoord = 0) const; virtual voidFdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* grad) const; ROOT::Math::IGradientMultiDim&operator=(const ROOT::Math::IGradientMultiDim&). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IGradientMultiDim(); virual destructor. {}. void Gradient(const double* x, double* grad) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double* x, unsigned int icoord = 0) const. Return the partial derivative with respect to the passed coordinate. return DoDerivative(x, icoord). void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time.  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__IGradientMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IGradientMultiDim.html
https://root.cern/root/html534/ROOT__Math__IGradientMultiDim.html:604,Integrability,interface,interface,604,". ROOT::Math::IGradientMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IGradientMultiDim. class ROOT::Math::IGradientMultiDim. Documentation for the abstract class IBaseFunctionMultiDim.; Interface (abstract class) for generic functions objects of multi-dimension; Provides a method to evaluate the function given a vector of coordinate values,; by implementing operator() (const double *).; In addition it defines the interface for copying functions via the pure virtual method Clone(); and the interface for getting the function dimension via the NDim() method.; Derived classes must implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::IGradientFunctionMultiDim::BaseGrad. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~IGradientMultiDim(); doubleDerivative(const double* x, unsigned int icoord = 0) const; virtual voidFdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* grad) const; ROOT::Math::IGradientMultiDim&operator=(const ROOT::Math::IGradientMultiDim&). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IGradientMultiDim(); virual destructor. {}. void Gradient(const double* x, double* grad) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double* x, unsigned int icoord = 0) const. Return the ",MatchSource.WIKI,root/html534/ROOT__Math__IGradientMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IGradientMultiDim.html
https://root.cern/root/html534/ROOT__Math__IGradientMultiDim.html:681,Integrability,interface,interface,681,". ROOT::Math::IGradientMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IGradientMultiDim. class ROOT::Math::IGradientMultiDim. Documentation for the abstract class IBaseFunctionMultiDim.; Interface (abstract class) for generic functions objects of multi-dimension; Provides a method to evaluate the function given a vector of coordinate values,; by implementing operator() (const double *).; In addition it defines the interface for copying functions via the pure virtual method Clone(); and the interface for getting the function dimension via the NDim() method.; Derived classes must implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::IGradientFunctionMultiDim::BaseGrad. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~IGradientMultiDim(); doubleDerivative(const double* x, unsigned int icoord = 0) const; virtual voidFdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* grad) const; ROOT::Math::IGradientMultiDim&operator=(const ROOT::Math::IGradientMultiDim&). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IGradientMultiDim(); virual destructor. {}. void Gradient(const double* x, double* grad) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double* x, unsigned int icoord = 0) const. Return the ",MatchSource.WIKI,root/html534/ROOT__Math__IGradientMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IGradientMultiDim.html
https://root.cern/root/html534/ROOT__Math__IGradientMultiDim.html:2398,Performance,perform,performances,2398,"e NDim() method.; Derived classes must implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::IGradientFunctionMultiDim::BaseGrad. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~IGradientMultiDim(); doubleDerivative(const double* x, unsigned int icoord = 0) const; virtual voidFdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* grad) const; ROOT::Math::IGradientMultiDim&operator=(const ROOT::Math::IGradientMultiDim&). private:. virtual doubleDoDerivative(const double* x, unsigned int icoord) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IGradientMultiDim(); virual destructor. {}. void Gradient(const double* x, double* grad) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double* x, unsigned int icoord = 0) const. Return the partial derivative with respect to the passed coordinate. return DoDerivative(x, icoord). void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time.  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__IGradientMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IGradientMultiDim.html
https://root.cern/root/html534/ROOT__Math__IGradientOneDim.html:1176,Availability,avail,available,1176,"function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IGradientOneDim. class ROOT::Math::IGradientOneDim. Documentation for the abstract class IBaseFunctionMultiDim.; Interface (abstract class) for generic functions objects of multi-dimension; Provides a method to evaluate the function given a vector of coordinate values,; by implementing operator() (const double *).; In addition it defines the interface for copying functions via the pure virtual method Clone(); and the interface for getting the function dimension via the NDim() method.; Derived classes must implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::IGradientFunctionOneDim::BaseGrad, ROOT::Math::WrappedTF1::IGrad. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~IGradientOneDim(); doubleDerivative(double x) const; doubleDerivative(const double* x) const; virtual voidFdF(double x, double& f, double& df) const; voidFdF(const double* x, double& f, double* df) const; voidGradient(const double* x, double* g) const; ROOT::Math::IGradientOneDim&operator=(const ROOT::Math::IGradientOneDim&). private:. virtual doubleDoDerivative(double x) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Gradient(const double* x, double* g) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double * x, unsigned int icoord = 0). Return the partial derivative with respect to the passed coordinate. return DoDerivative(x, icoord). void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time th",MatchSource.WIKI,root/html534/ROOT__Math__IGradientOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IGradientOneDim.html
https://root.cern/root/html534/ROOT__Math__IGradientOneDim.html:1862,Energy Efficiency,efficient,efficient,1862,"on in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::IGradientFunctionOneDim::BaseGrad, ROOT::Math::WrappedTF1::IGrad. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~IGradientOneDim(); doubleDerivative(double x) const; doubleDerivative(const double* x) const; virtual voidFdF(double x, double& f, double& df) const; voidFdF(const double* x, double& f, double* df) const; voidGradient(const double* x, double* g) const; ROOT::Math::IGradientOneDim&operator=(const ROOT::Math::IGradientOneDim&). private:. virtual doubleDoDerivative(double x) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Gradient(const double* x, double* g) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double * x, unsigned int icoord = 0). Return the partial derivative with respect to the passed coordinate. return DoDerivative(x, icoord). void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientOneDim(); virtual destructor. {}. double Derivative(double x) const. Return the derivative of the function at a point x; Use the private method DoDerivative. void FdF(double x, double& f, double& df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is oft",MatchSource.WIKI,root/html534/ROOT__Math__IGradientOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IGradientOneDim.html
https://root.cern/root/html534/ROOT__Math__IGradientOneDim.html:2281,Energy Efficiency,efficient,efficient,2281,"; doubleDerivative(const double* x) const; virtual voidFdF(double x, double& f, double& df) const; voidFdF(const double* x, double& f, double* df) const; voidGradient(const double* x, double* g) const; ROOT::Math::IGradientOneDim&operator=(const ROOT::Math::IGradientOneDim&). private:. virtual doubleDoDerivative(double x) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Gradient(const double* x, double* g) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double * x, unsigned int icoord = 0). Return the partial derivative with respect to the passed coordinate. return DoDerivative(x, icoord). void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientOneDim(); virtual destructor. {}. double Derivative(double x) const. Return the derivative of the function at a point x; Use the private method DoDerivative. void FdF(double x, double& f, double& df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time.  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a m",MatchSource.WIKI,root/html534/ROOT__Math__IGradientOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IGradientOneDim.html
https://root.cern/root/html534/ROOT__Math__IGradientOneDim.html:2865,Energy Efficiency,efficient,efficient,2865,"nst double* x) const; virtual voidFdF(double x, double& f, double& df) const; voidFdF(const double* x, double& f, double* df) const; voidGradient(const double* x, double* g) const; ROOT::Math::IGradientOneDim&operator=(const ROOT::Math::IGradientOneDim&). private:. virtual doubleDoDerivative(double x) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Gradient(const double* x, double* g) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double * x, unsigned int icoord = 0). Return the partial derivative with respect to the passed coordinate. return DoDerivative(x, icoord). void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientOneDim(); virtual destructor. {}. double Derivative(double x) const. Return the derivative of the function at a point x; Use the private method DoDerivative. void FdF(double x, double& f, double& df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time.  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__IGradientOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IGradientOneDim.html
https://root.cern/root/html534/ROOT__Math__IGradientOneDim.html:598,Integrability,interface,interface,598,". ROOT::Math::IGradientOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IGradientOneDim. class ROOT::Math::IGradientOneDim. Documentation for the abstract class IBaseFunctionMultiDim.; Interface (abstract class) for generic functions objects of multi-dimension; Provides a method to evaluate the function given a vector of coordinate values,; by implementing operator() (const double *).; In addition it defines the interface for copying functions via the pure virtual method Clone(); and the interface for getting the function dimension via the NDim() method.; Derived classes must implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::IGradientFunctionOneDim::BaseGrad, ROOT::Math::WrappedTF1::IGrad. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~IGradientOneDim(); doubleDerivative(double x) const; doubleDerivative(const double* x) const; virtual voidFdF(double x, double& f, double& df) const; voidFdF(const double* x, double& f, double* df) const; voidGradient(const double* x, double* g) const; ROOT::Math::IGradientOneDim&operator=(const ROOT::Math::IGradientOneDim&). private:. virtual doubleDoDerivative(double x) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Gradient(const double* x, double* g) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double * x, unsigned int icoord = 0). Return the partial derivative with re",MatchSource.WIKI,root/html534/ROOT__Math__IGradientOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IGradientOneDim.html
https://root.cern/root/html534/ROOT__Math__IGradientOneDim.html:675,Integrability,interface,interface,675,". ROOT::Math::IGradientOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IGradientOneDim. class ROOT::Math::IGradientOneDim. Documentation for the abstract class IBaseFunctionMultiDim.; Interface (abstract class) for generic functions objects of multi-dimension; Provides a method to evaluate the function given a vector of coordinate values,; by implementing operator() (const double *).; In addition it defines the interface for copying functions via the pure virtual method Clone(); and the interface for getting the function dimension via the NDim() method.; Derived classes must implement the pure private virtual method DoEval(const double *) for the; function evaluation in addition to NDim() and Clone(). @ingroup GenFunc. This class is also known as (typedefs to this class)ROOT::Math::IGradientFunctionOneDim::BaseGrad, ROOT::Math::WrappedTF1::IGrad. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~IGradientOneDim(); doubleDerivative(double x) const; doubleDerivative(const double* x) const; virtual voidFdF(double x, double& f, double& df) const; voidFdF(const double* x, double& f, double* df) const; voidGradient(const double* x, double* g) const; ROOT::Math::IGradientOneDim&operator=(const ROOT::Math::IGradientOneDim&). private:. virtual doubleDoDerivative(double x) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Gradient(const double* x, double* g) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double * x, unsigned int icoord = 0). Return the partial derivative with re",MatchSource.WIKI,root/html534/ROOT__Math__IGradientOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IGradientOneDim.html
https://root.cern/root/html534/ROOT__Math__IGradientOneDim.html:2372,Performance,perform,performances,2372,"nst double* x) const; virtual voidFdF(double x, double& f, double& df) const; voidFdF(const double* x, double& f, double* df) const; voidGradient(const double* x, double* g) const; ROOT::Math::IGradientOneDim&operator=(const ROOT::Math::IGradientOneDim&). private:. virtual doubleDoDerivative(double x) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Gradient(const double* x, double* g) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double * x, unsigned int icoord = 0). Return the partial derivative with respect to the passed coordinate. return DoDerivative(x, icoord). void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientOneDim(); virtual destructor. {}. double Derivative(double x) const. Return the derivative of the function at a point x; Use the private method DoDerivative. void FdF(double x, double& f, double& df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time.  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__IGradientOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IGradientOneDim.html
https://root.cern/root/html534/ROOT__Math__IGradientOneDim.html:2956,Performance,perform,performances,2956,"nst double* x) const; virtual voidFdF(double x, double& f, double& df) const; voidFdF(const double* x, double& f, double* df) const; voidGradient(const double* x, double* g) const; ROOT::Math::IGradientOneDim&operator=(const ROOT::Math::IGradientOneDim&). private:. virtual doubleDoDerivative(double x) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Gradient(const double* x, double* g) const. Evaluate all the vector of function derivatives (gradient) at a point x.; Derived classes must re-implement if it is more efficient than evaluting one at a time. double Derivative(const double * x, unsigned int icoord = 0). Return the partial derivative with respect to the passed coordinate. return DoDerivative(x, icoord). void FdF(const double* x, double& f, double* df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time. virtual ~IGradientOneDim(); virtual destructor. {}. double Derivative(double x) const. Return the derivative of the function at a point x; Use the private method DoDerivative. void FdF(double x, double& f, double& df) const. Optimized method to evaluate at the same time the function value and derivative at a point x.; Often both value and derivatives are needed and it is often more efficient to compute them at the same time.; Derived class should implement this method if performances play an important role and if it is faster to; evaluate value and derivative at the same time.  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__IGradientOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IGradientOneDim.html
https://root.cern/root/html534/ROOT__Math__IMinimizer1D.html:519,Availability,avail,available,519,". ROOT::Math::IMinimizer1D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IMinimizer1D. class ROOT::Math::IMinimizer1D. Interface class for numerical methods for one-dimensional minimization. @ingroup Min1D. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~IMinimizer1D(); virtual doubleFValLower() const; virtual doubleFValMinimum() const; virtual doubleFValUpper() const; virtual intIterations() const; virtual boolMinimize(int maxIter, double absTol, double relTol); virtual const char*Name() const; ROOT::Math::IMinimizer1D&operator=(const ROOT::Math::IMinimizer1D&); virtual intStatus() const; virtual doubleXLower() const; virtual doubleXMinimum() const; virtual doubleXUpper() const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IMinimizer1D(); {}. double XMinimum() const. * Return current estimate of the position of the minimum. double XLower() const. * Return current lower bound of the minimization interval. double XUpper() const. * Return current upper bound of the minimization interval. double FValMinimum() const. * Return function value at current estimate of the minimum. double FValLower() const. * Return function value at current lower bound of the minimization interval. double FValUpper() const. * Return function value at current upper bound of the minimization interval. bool Minimize(int maxIter, double absTol, double relTol). * Find minimum position iterating until convergence specified by the absolute and relative tolerance or; * the maximum number of iteration is reached; * Return true if iterations converged successfully; * \@param maxIter maximum number of iteration; * \@param absTol desired absolute err",MatchSource.WIKI,root/html534/ROOT__Math__IMinimizer1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IMinimizer1D.html
https://root.cern/root/html534/ROOT__Math__IMinimizer1D.html:1805,Availability,toler,tolerance,1805,"rtual doubleFValMinimum() const; virtual doubleFValUpper() const; virtual intIterations() const; virtual boolMinimize(int maxIter, double absTol, double relTol); virtual const char*Name() const; ROOT::Math::IMinimizer1D&operator=(const ROOT::Math::IMinimizer1D&); virtual intStatus() const; virtual doubleXLower() const; virtual doubleXMinimum() const; virtual doubleXUpper() const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IMinimizer1D(); {}. double XMinimum() const. * Return current estimate of the position of the minimum. double XLower() const. * Return current lower bound of the minimization interval. double XUpper() const. * Return current upper bound of the minimization interval. double FValMinimum() const. * Return function value at current estimate of the minimum. double FValLower() const. * Return function value at current lower bound of the minimization interval. double FValUpper() const. * Return function value at current upper bound of the minimization interval. bool Minimize(int maxIter, double absTol, double relTol). * Find minimum position iterating until convergence specified by the absolute and relative tolerance or; * the maximum number of iteration is reached; * Return true if iterations converged successfully; * \@param maxIter maximum number of iteration; * \@param absTol desired absolute error in the minimum position; * \@param absTol desired relative error in the minimum position. int Iterations() const. * Return number of iteration used to find minimum. const char * Name() const. * Return name of minimization algorithm. int Status() const; Returns the status of the previous estimate .  Author: David Gonzalez Maline 2/2008  Copyright (c) 2004 Maline, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__IMinimizer1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IMinimizer1D.html
https://root.cern/root/html534/ROOT__Math__IMinimizer1D.html:1998,Availability,error,error,1998,"rtual doubleFValMinimum() const; virtual doubleFValUpper() const; virtual intIterations() const; virtual boolMinimize(int maxIter, double absTol, double relTol); virtual const char*Name() const; ROOT::Math::IMinimizer1D&operator=(const ROOT::Math::IMinimizer1D&); virtual intStatus() const; virtual doubleXLower() const; virtual doubleXMinimum() const; virtual doubleXUpper() const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IMinimizer1D(); {}. double XMinimum() const. * Return current estimate of the position of the minimum. double XLower() const. * Return current lower bound of the minimization interval. double XUpper() const. * Return current upper bound of the minimization interval. double FValMinimum() const. * Return function value at current estimate of the minimum. double FValLower() const. * Return function value at current lower bound of the minimization interval. double FValUpper() const. * Return function value at current upper bound of the minimization interval. bool Minimize(int maxIter, double absTol, double relTol). * Find minimum position iterating until convergence specified by the absolute and relative tolerance or; * the maximum number of iteration is reached; * Return true if iterations converged successfully; * \@param maxIter maximum number of iteration; * \@param absTol desired absolute error in the minimum position; * \@param absTol desired relative error in the minimum position. int Iterations() const. * Return number of iteration used to find minimum. const char * Name() const. * Return name of minimization algorithm. int Status() const; Returns the status of the previous estimate .  Author: David Gonzalez Maline 2/2008  Copyright (c) 2004 Maline, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__IMinimizer1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IMinimizer1D.html
https://root.cern/root/html534/ROOT__Math__IMinimizer1D.html:2063,Availability,error,error,2063,"rtual doubleFValMinimum() const; virtual doubleFValUpper() const; virtual intIterations() const; virtual boolMinimize(int maxIter, double absTol, double relTol); virtual const char*Name() const; ROOT::Math::IMinimizer1D&operator=(const ROOT::Math::IMinimizer1D&); virtual intStatus() const; virtual doubleXLower() const; virtual doubleXMinimum() const; virtual doubleXUpper() const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IMinimizer1D(); {}. double XMinimum() const. * Return current estimate of the position of the minimum. double XLower() const. * Return current lower bound of the minimization interval. double XUpper() const. * Return current upper bound of the minimization interval. double FValMinimum() const. * Return function value at current estimate of the minimum. double FValLower() const. * Return function value at current lower bound of the minimization interval. double FValUpper() const. * Return function value at current upper bound of the minimization interval. bool Minimize(int maxIter, double absTol, double relTol). * Find minimum position iterating until convergence specified by the absolute and relative tolerance or; * the maximum number of iteration is reached; * Return true if iterations converged successfully; * \@param maxIter maximum number of iteration; * \@param absTol desired absolute error in the minimum position; * \@param absTol desired relative error in the minimum position. int Iterations() const. * Return number of iteration used to find minimum. const char * Name() const. * Return name of minimization algorithm. int Status() const; Returns the status of the previous estimate .  Author: David Gonzalez Maline 2/2008  Copyright (c) 2004 Maline, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__IMinimizer1D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IMinimizer1D.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:5159,Availability,error,error,5159,"y only to MC integratioon methods). this is ambigous; template<class Function>; IntegratorMultiDim(Function & f, unsigned int dim, IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int ncall = 100000) {; fIntegrator = CreateIntegrator(type, absTol, relTol, ncall);; SetFunction(f, dim);; }; destructor. IntegratorMultiDim(const ROOT::Math::IntegratorMultiDim& ); disable copy constructur and assignment operator. {}. IntegratorMultiDim & operator=(const ROOT::Math::IntegratorMultiDim& ); { return *this; }. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. double Result() const; return result of last integration. { return fIntegrator == 0 ? 0 : fIntegrator->Result(); }. double Error() const; return integration error. { return fIntegrator == 0 ? 0 : fIntegrator->Error(); }. int Status() const; return the Error Status of the last Integral calculation. { return fIntegrator == 0 ? -1 : fIntegrator->Status(); }. void SetRelTolerance(double relTol); return number of function evaluations in calculating the integral; unsigned int NEval() const { return fNEval; }; set the relative tolerance. { if (fIntegrator) fIntegrator->SetRelTolerance(relTol); }. void SetAbsTolerance(double absTol); set absolute tolerance. { if (fIntegrator) fIntegrator->SetAbsTolerance(absTol); }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options. { if (fIntegrator) fIntegrator->SetOptions(opt); }. VirtualIntegratorMultiDim * GetIntegrator(); return a pointer to integrator object. { return fIntegrator; }. std::string Name() const; return name of integrator. { return (fIntegrator) ? Options().Integrator() : std::string(""""); }. IntegrationMultiDim::Type GetType(const char* name); ",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:5528,Availability,toler,tolerance,5528,"e, absTol, relTol, ncall);; SetFunction(f, dim);; }; destructor. IntegratorMultiDim(const ROOT::Math::IntegratorMultiDim& ); disable copy constructur and assignment operator. {}. IntegratorMultiDim & operator=(const ROOT::Math::IntegratorMultiDim& ); { return *this; }. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. double Result() const; return result of last integration. { return fIntegrator == 0 ? 0 : fIntegrator->Result(); }. double Error() const; return integration error. { return fIntegrator == 0 ? 0 : fIntegrator->Error(); }. int Status() const; return the Error Status of the last Integral calculation. { return fIntegrator == 0 ? -1 : fIntegrator->Status(); }. void SetRelTolerance(double relTol); return number of function evaluations in calculating the integral; unsigned int NEval() const { return fNEval; }; set the relative tolerance. { if (fIntegrator) fIntegrator->SetRelTolerance(relTol); }. void SetAbsTolerance(double absTol); set absolute tolerance. { if (fIntegrator) fIntegrator->SetAbsTolerance(absTol); }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options. { if (fIntegrator) fIntegrator->SetOptions(opt); }. VirtualIntegratorMultiDim * GetIntegrator(); return a pointer to integrator object. { return fIntegrator; }. std::string Name() const; return name of integrator. { return (fIntegrator) ? Options().Integrator() : std::string(""""); }. IntegrationMultiDim::Type GetType(const char* name); static function to get the enumeration from a string. std::string GetName(ROOT::Math::IntegrationMultiDim::Type ); static function to get a string from the enumeration. VirtualIntegratorMultiDim * CreateIntegrator(ROOT::Math::IntegrationMultiDim::Type type, double absTol, double relTol, unsigned int ncall).",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:5649,Availability,toler,tolerance,5649,"ntegratorMultiDim & operator=(const ROOT::Math::IntegratorMultiDim& ); { return *this; }. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. double Result() const; return result of last integration. { return fIntegrator == 0 ? 0 : fIntegrator->Result(); }. double Error() const; return integration error. { return fIntegrator == 0 ? 0 : fIntegrator->Error(); }. int Status() const; return the Error Status of the last Integral calculation. { return fIntegrator == 0 ? -1 : fIntegrator->Status(); }. void SetRelTolerance(double relTol); return number of function evaluations in calculating the integral; unsigned int NEval() const { return fNEval; }; set the relative tolerance. { if (fIntegrator) fIntegrator->SetRelTolerance(relTol); }. void SetAbsTolerance(double absTol); set absolute tolerance. { if (fIntegrator) fIntegrator->SetAbsTolerance(absTol); }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options. { if (fIntegrator) fIntegrator->SetOptions(opt); }. VirtualIntegratorMultiDim * GetIntegrator(); return a pointer to integrator object. { return fIntegrator; }. std::string Name() const; return name of integrator. { return (fIntegrator) ? Options().Integrator() : std::string(""""); }. IntegrationMultiDim::Type GetType(const char* name); static function to get the enumeration from a string. std::string GetName(ROOT::Math::IntegrationMultiDim::Type ); static function to get a string from the enumeration. VirtualIntegratorMultiDim * CreateIntegrator(ROOT::Math::IntegrationMultiDim::Type type, double absTol, double relTol, unsigned int ncall).  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT ",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:358,Deployability,integrat,integration,358,". ROOT::Math::IntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IntegratorMultiDim. class ROOT::Math::IntegratorMultiDim. User class for performing multidimensional integration. By default uses adaptive multi-dimensional integration using the algorithm from Genz Mallik; implemented in the class ROOT::Math::AdaptiveIntegratorMultiDim otherwise it can uses via the; plug-in manager the MC integration class (ROOT::Math::GSLMCIntegration) from MathMore. @ingroup Integration. Function Members (Methods); public:. virtual~IntegratorMultiDim(); doubleError() const; ROOT::Math::VirtualIntegratorMultiDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationMultiDim::Type); static ROOT::Math::IntegrationMultiDim::TypeGetType(const char* name); doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); ROOT::Math::IntegratorMultiDimIntegratorMultiDim(ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); ROOT::Math::IntegratorMultiDimIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); stringName() const; ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleResult() const; voidSetAbsTolerance(double absTol); voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); voidSetRelTolerance(double relTol); intStatus() const. protected:. ROOT::Math::VirtualIntegratorMultiDim*CreateIntegrator(ROOT::Math::IntegrationMultiDim::Type type, double absTol, double relTol, unsigned int ncall). private:. ROOT::Ma",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:414,Deployability,integrat,integration,414,". ROOT::Math::IntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IntegratorMultiDim. class ROOT::Math::IntegratorMultiDim. User class for performing multidimensional integration. By default uses adaptive multi-dimensional integration using the algorithm from Genz Mallik; implemented in the class ROOT::Math::AdaptiveIntegratorMultiDim otherwise it can uses via the; plug-in manager the MC integration class (ROOT::Math::GSLMCIntegration) from MathMore. @ingroup Integration. Function Members (Methods); public:. virtual~IntegratorMultiDim(); doubleError() const; ROOT::Math::VirtualIntegratorMultiDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationMultiDim::Type); static ROOT::Math::IntegrationMultiDim::TypeGetType(const char* name); doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); ROOT::Math::IntegratorMultiDimIntegratorMultiDim(ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); ROOT::Math::IntegratorMultiDimIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); stringName() const; ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleResult() const; voidSetAbsTolerance(double absTol); voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); voidSetRelTolerance(double relTol); intStatus() const. protected:. ROOT::Math::VirtualIntegratorMultiDim*CreateIntegrator(ROOT::Math::IntegrationMultiDim::Type type, double absTol, double relTol, unsigned int ncall). private:. ROOT::Ma",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:582,Deployability,integrat,integration,582,". ROOT::Math::IntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IntegratorMultiDim. class ROOT::Math::IntegratorMultiDim. User class for performing multidimensional integration. By default uses adaptive multi-dimensional integration using the algorithm from Genz Mallik; implemented in the class ROOT::Math::AdaptiveIntegratorMultiDim otherwise it can uses via the; plug-in manager the MC integration class (ROOT::Math::GSLMCIntegration) from MathMore. @ingroup Integration. Function Members (Methods); public:. virtual~IntegratorMultiDim(); doubleError() const; ROOT::Math::VirtualIntegratorMultiDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationMultiDim::Type); static ROOT::Math::IntegrationMultiDim::TypeGetType(const char* name); doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); ROOT::Math::IntegratorMultiDimIntegratorMultiDim(ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); ROOT::Math::IntegratorMultiDimIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); stringName() const; ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleResult() const; voidSetAbsTolerance(double absTol); voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); voidSetRelTolerance(double relTol); intStatus() const. protected:. ROOT::Math::VirtualIntegratorMultiDim*CreateIntegrator(ROOT::Math::IntegrationMultiDim::Type type, double absTol, double relTol, unsigned int ncall). private:. ROOT::Ma",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:2340,Deployability,integrat,integrator,2340,"ll = 0); ROOT::Math::IntegratorMultiDimIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); stringName() const; ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleResult() const; voidSetAbsTolerance(double absTol); voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); voidSetRelTolerance(double relTol); intStatus() const. protected:. ROOT::Math::VirtualIntegratorMultiDim*CreateIntegrator(ROOT::Math::IntegrationMultiDim::Type type, double absTol, double relTol, unsigned int ncall). private:. ROOT::Math::IntegratorMultiDimIntegratorMultiDim(const ROOT::Math::IntegratorMultiDim&); ROOT::Math::IntegratorMultiDim&operator=(const ROOT::Math::IntegratorMultiDim&). Data Members; private:. auto_ptr<ROOT::Math::IBaseFunctionMultiDim>fFuncpointer to owned function; ROOT::Math::VirtualIntegratorMultiDim*fIntegratorpointer to multi-dimensional integrator base class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IntegratorMultiDim(ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic constructor of multi dimensional Integrator. By default uses the Adaptive integration method. @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. In case no parameter values are passed the default ones used in IntegratorMultiDimOptions are used. IntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic Constructor of multi dimensional Integrator passing a function. By defaul",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:2694,Deployability,integrat,integration,2694,"nction& f); voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); voidSetRelTolerance(double relTol); intStatus() const. protected:. ROOT::Math::VirtualIntegratorMultiDim*CreateIntegrator(ROOT::Math::IntegrationMultiDim::Type type, double absTol, double relTol, unsigned int ncall). private:. ROOT::Math::IntegratorMultiDimIntegratorMultiDim(const ROOT::Math::IntegratorMultiDim&); ROOT::Math::IntegratorMultiDim&operator=(const ROOT::Math::IntegratorMultiDim&). Data Members; private:. auto_ptr<ROOT::Math::IBaseFunctionMultiDim>fFuncpointer to owned function; ROOT::Math::VirtualIntegratorMultiDim*fIntegratorpointer to multi-dimensional integrator base class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IntegratorMultiDim(ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic constructor of multi dimensional Integrator. By default uses the Adaptive integration method. @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. In case no parameter values are passed the default ones used in IntegratorMultiDimOptions are used. IntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic Constructor of multi dimensional Integrator passing a function. By default uses the adaptive integration method. @param f integration function (multi-dim interface); @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). SetFunction(const ROOT::Math::IMultiGenFunction& f). virtual ~IntegratorMultiDim(); remove template constru",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:2726,Deployability,integrat,integration,2726,"orMultiDimOptions& opt); voidSetRelTolerance(double relTol); intStatus() const. protected:. ROOT::Math::VirtualIntegratorMultiDim*CreateIntegrator(ROOT::Math::IntegrationMultiDim::Type type, double absTol, double relTol, unsigned int ncall). private:. ROOT::Math::IntegratorMultiDimIntegratorMultiDim(const ROOT::Math::IntegratorMultiDim&); ROOT::Math::IntegratorMultiDim&operator=(const ROOT::Math::IntegratorMultiDim&). Data Members; private:. auto_ptr<ROOT::Math::IBaseFunctionMultiDim>fFuncpointer to owned function; ROOT::Math::VirtualIntegratorMultiDim*fIntegratorpointer to multi-dimensional integrator base class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IntegratorMultiDim(ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic constructor of multi dimensional Integrator. By default uses the Adaptive integration method. @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. In case no parameter values are passed the default ones used in IntegratorMultiDimOptions are used. IntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic Constructor of multi dimensional Integrator passing a function. By default uses the adaptive integration method. @param f integration function (multi-dim interface); @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). SetFunction(const ROOT::Math::IMultiGenFunction& f). virtual ~IntegratorMultiDim(); remove template constructor since is ambigous; Template Constructor of multi",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:3294,Deployability,integrat,integration,3294,"torMultiDim*fIntegratorpointer to multi-dimensional integrator base class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IntegratorMultiDim(ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic constructor of multi dimensional Integrator. By default uses the Adaptive integration method. @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. In case no parameter values are passed the default ones used in IntegratorMultiDimOptions are used. IntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic Constructor of multi dimensional Integrator passing a function. By default uses the adaptive integration method. @param f integration function (multi-dim interface); @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). SetFunction(const ROOT::Math::IMultiGenFunction& f). virtual ~IntegratorMultiDim(); remove template constructor since is ambigous; Template Constructor of multi dimensional Integrator passing a generic function. By default uses the adaptive integration method. @param f integration function (generic function implementin operator()(const double *); @param dim function dimension; @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). this is ambigous; template<class Function>; IntegratorMultiDim(Function & f, unsigned int dim, IntegrationMultiD",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:3323,Deployability,integrat,integration,3323," Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IntegratorMultiDim(ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic constructor of multi dimensional Integrator. By default uses the Adaptive integration method. @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. In case no parameter values are passed the default ones used in IntegratorMultiDimOptions are used. IntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic Constructor of multi dimensional Integrator passing a function. By default uses the adaptive integration method. @param f integration function (multi-dim interface); @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). SetFunction(const ROOT::Math::IMultiGenFunction& f). virtual ~IntegratorMultiDim(); remove template constructor since is ambigous; Template Constructor of multi dimensional Integrator passing a generic function. By default uses the adaptive integration method. @param f integration function (generic function implementin operator()(const double *); @param dim function dimension; @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). this is ambigous; template<class Function>; IntegratorMultiDim(Function & f, unsigned int dim, IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double r",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:3379,Deployability,integrat,integration,3379," Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IntegratorMultiDim(ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic constructor of multi dimensional Integrator. By default uses the Adaptive integration method. @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. In case no parameter values are passed the default ones used in IntegratorMultiDimOptions are used. IntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic Constructor of multi dimensional Integrator passing a function. By default uses the adaptive integration method. @param f integration function (multi-dim interface); @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). SetFunction(const ROOT::Math::IMultiGenFunction& f). virtual ~IntegratorMultiDim(); remove template constructor since is ambigous; Template Constructor of multi dimensional Integrator passing a generic function. By default uses the adaptive integration method. @param f integration function (generic function implementin operator()(const double *); @param dim function dimension; @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). this is ambigous; template<class Function>; IntegratorMultiDim(Function & f, unsigned int dim, IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double r",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:3559,Deployability,integrat,integratioon,3559,"im::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic constructor of multi dimensional Integrator. By default uses the Adaptive integration method. @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. In case no parameter values are passed the default ones used in IntegratorMultiDimOptions are used. IntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic Constructor of multi dimensional Integrator passing a function. By default uses the adaptive integration method. @param f integration function (multi-dim interface); @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). SetFunction(const ROOT::Math::IMultiGenFunction& f). virtual ~IntegratorMultiDim(); remove template constructor since is ambigous; Template Constructor of multi dimensional Integrator passing a generic function. By default uses the adaptive integration method. @param f integration function (generic function implementin operator()(const double *); @param dim function dimension; @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). this is ambigous; template<class Function>; IntegratorMultiDim(Function & f, unsigned int dim, IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int ncall = 100000) {; fIntegrator = CreateIntegrator(type, absTol, relTol, ncall);; SetFunction(f, dim);; }; de",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:3823,Deployability,integrat,integration,3823,"m relTol desired relative Error; @param size maximum number of sub-intervals. In case no parameter values are passed the default ones used in IntegratorMultiDimOptions are used. IntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic Constructor of multi dimensional Integrator passing a function. By default uses the adaptive integration method. @param f integration function (multi-dim interface); @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). SetFunction(const ROOT::Math::IMultiGenFunction& f). virtual ~IntegratorMultiDim(); remove template constructor since is ambigous; Template Constructor of multi dimensional Integrator passing a generic function. By default uses the adaptive integration method. @param f integration function (generic function implementin operator()(const double *); @param dim function dimension; @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). this is ambigous; template<class Function>; IntegratorMultiDim(Function & f, unsigned int dim, IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int ncall = 100000) {; fIntegrator = CreateIntegrator(type, absTol, relTol, ncall);; SetFunction(f, dim);; }; destructor. IntegratorMultiDim(const ROOT::Math::IntegratorMultiDim& ); disable copy constructur and assignment operator. {}. IntegratorMultiDim & operator=(const ROOT::Math::IntegratorMultiDim& ); { return *this; }. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously g",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:3852,Deployability,integrat,integration,3852,"sed the default ones used in IntegratorMultiDimOptions are used. IntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic Constructor of multi dimensional Integrator passing a function. By default uses the adaptive integration method. @param f integration function (multi-dim interface); @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). SetFunction(const ROOT::Math::IMultiGenFunction& f). virtual ~IntegratorMultiDim(); remove template constructor since is ambigous; Template Constructor of multi dimensional Integrator passing a generic function. By default uses the adaptive integration method. @param f integration function (generic function implementin operator()(const double *); @param dim function dimension; @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). this is ambigous; template<class Function>; IntegratorMultiDim(Function & f, unsigned int dim, IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int ncall = 100000) {; fIntegrator = CreateIntegrator(type, absTol, relTol, ncall);; SetFunction(f, dim);; }; destructor. IntegratorMultiDim(const ROOT::Math::IntegratorMultiDim& ); disable copy constructur and assignment operator. {}. IntegratorMultiDim & operator=(const ROOT::Math::IntegratorMultiDim& ); { return *this; }. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. double Integral(const ROOT::Math::IMultiGenFunction& f, const double* x",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:3974,Deployability,integrat,integration,3974,"sed the default ones used in IntegratorMultiDimOptions are used. IntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic Constructor of multi dimensional Integrator passing a function. By default uses the adaptive integration method. @param f integration function (multi-dim interface); @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). SetFunction(const ROOT::Math::IMultiGenFunction& f). virtual ~IntegratorMultiDim(); remove template constructor since is ambigous; Template Constructor of multi dimensional Integrator passing a generic function. By default uses the adaptive integration method. @param f integration function (generic function implementin operator()(const double *); @param dim function dimension; @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). this is ambigous; template<class Function>; IntegratorMultiDim(Function & f, unsigned int dim, IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int ncall = 100000) {; fIntegrator = CreateIntegrator(type, absTol, relTol, ncall);; SetFunction(f, dim);; }; destructor. IntegratorMultiDim(const ROOT::Math::IntegratorMultiDim& ); disable copy constructur and assignment operator. {}. IntegratorMultiDim & operator=(const ROOT::Math::IntegratorMultiDim& ); { return *this; }. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. double Integral(const ROOT::Math::IMultiGenFunction& f, const double* x",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:4154,Deployability,integrat,integratioon,4154,"= IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic Constructor of multi dimensional Integrator passing a function. By default uses the adaptive integration method. @param f integration function (multi-dim interface); @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). SetFunction(const ROOT::Math::IMultiGenFunction& f). virtual ~IntegratorMultiDim(); remove template constructor since is ambigous; Template Constructor of multi dimensional Integrator passing a generic function. By default uses the adaptive integration method. @param f integration function (generic function implementin operator()(const double *); @param dim function dimension; @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). this is ambigous; template<class Function>; IntegratorMultiDim(Function & f, unsigned int dim, IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int ncall = 100000) {; fIntegrator = CreateIntegrator(type, absTol, relTol, ncall);; SetFunction(f, dim);; }; destructor. IntegratorMultiDim(const ROOT::Math::IntegratorMultiDim& ); disable copy constructur and assignment operator. {}. IntegratorMultiDim & operator=(const ROOT::Math::IntegratorMultiDim& ); { return *this; }. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. double Result() const; return result of last integration. { return fIntegrator == 0 ? 0 : fInteg",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:5047,Deployability,integrat,integration,5047,"bsTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). this is ambigous; template<class Function>; IntegratorMultiDim(Function & f, unsigned int dim, IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int ncall = 100000) {; fIntegrator = CreateIntegrator(type, absTol, relTol, ncall);; SetFunction(f, dim);; }; destructor. IntegratorMultiDim(const ROOT::Math::IntegratorMultiDim& ); disable copy constructur and assignment operator. {}. IntegratorMultiDim & operator=(const ROOT::Math::IntegratorMultiDim& ); { return *this; }. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. double Result() const; return result of last integration. { return fIntegrator == 0 ? 0 : fIntegrator->Result(); }. double Error() const; return integration error. { return fIntegrator == 0 ? 0 : fIntegrator->Error(); }. int Status() const; return the Error Status of the last Integral calculation. { return fIntegrator == 0 ? -1 : fIntegrator->Status(); }. void SetRelTolerance(double relTol); return number of function evaluations in calculating the integral; unsigned int NEval() const { return fNEval; }; set the relative tolerance. { if (fIntegrator) fIntegrator->SetRelTolerance(relTol); }. void SetAbsTolerance(double absTol); set absolute tolerance. { if (fIntegrator) fIntegrator->SetAbsTolerance(absTol); }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options. { if (fIntegrator) fIntegrator->SetOptions(opt); }. VirtualIntegratorMultiDim * GetIntegrator(); return a pointer to integrator object. { return fIntegrator; }. std::string Name() const; return name of integrator. { return (fI",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:5147,Deployability,integrat,integration,5147,"y only to MC integratioon methods). this is ambigous; template<class Function>; IntegratorMultiDim(Function & f, unsigned int dim, IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int ncall = 100000) {; fIntegrator = CreateIntegrator(type, absTol, relTol, ncall);; SetFunction(f, dim);; }; destructor. IntegratorMultiDim(const ROOT::Math::IntegratorMultiDim& ); disable copy constructur and assignment operator. {}. IntegratorMultiDim & operator=(const ROOT::Math::IntegratorMultiDim& ); { return *this; }. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. double Result() const; return result of last integration. { return fIntegrator == 0 ? 0 : fIntegrator->Result(); }. double Error() const; return integration error. { return fIntegrator == 0 ? 0 : fIntegrator->Error(); }. int Status() const; return the Error Status of the last Integral calculation. { return fIntegrator == 0 ? -1 : fIntegrator->Status(); }. void SetRelTolerance(double relTol); return number of function evaluations in calculating the integral; unsigned int NEval() const { return fNEval; }; set the relative tolerance. { if (fIntegrator) fIntegrator->SetRelTolerance(relTol); }. void SetAbsTolerance(double absTol); set absolute tolerance. { if (fIntegrator) fIntegrator->SetAbsTolerance(absTol); }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options. { if (fIntegrator) fIntegrator->SetOptions(opt); }. VirtualIntegratorMultiDim * GetIntegrator(); return a pointer to integrator object. { return fIntegrator; }. std::string Name() const; return name of integrator. { return (fIntegrator) ? Options().Integrator() : std::string(""""); }. IntegrationMultiDim::Type GetType(const char* name); ",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:5921,Deployability,integrat,integrator,5921,"IntegratorMultiDim& ); { return *this; }. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. double Result() const; return result of last integration. { return fIntegrator == 0 ? 0 : fIntegrator->Result(); }. double Error() const; return integration error. { return fIntegrator == 0 ? 0 : fIntegrator->Error(); }. int Status() const; return the Error Status of the last Integral calculation. { return fIntegrator == 0 ? -1 : fIntegrator->Status(); }. void SetRelTolerance(double relTol); return number of function evaluations in calculating the integral; unsigned int NEval() const { return fNEval; }; set the relative tolerance. { if (fIntegrator) fIntegrator->SetRelTolerance(relTol); }. void SetAbsTolerance(double absTol); set absolute tolerance. { if (fIntegrator) fIntegrator->SetAbsTolerance(absTol); }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options. { if (fIntegrator) fIntegrator->SetOptions(opt); }. VirtualIntegratorMultiDim * GetIntegrator(); return a pointer to integrator object. { return fIntegrator; }. std::string Name() const; return name of integrator. { return (fIntegrator) ? Options().Integrator() : std::string(""""); }. IntegrationMultiDim::Type GetType(const char* name); static function to get the enumeration from a string. std::string GetName(ROOT::Math::IntegrationMultiDim::Type ); static function to get a string from the enumeration. VirtualIntegratorMultiDim * CreateIntegrator(ROOT::Math::IntegrationMultiDim::Type type, double absTol, double relTol, unsigned int ncall).  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:6006,Deployability,integrat,integrator,6006,"IntegratorMultiDim& ); { return *this; }. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. double Result() const; return result of last integration. { return fIntegrator == 0 ? 0 : fIntegrator->Result(); }. double Error() const; return integration error. { return fIntegrator == 0 ? 0 : fIntegrator->Error(); }. int Status() const; return the Error Status of the last Integral calculation. { return fIntegrator == 0 ? -1 : fIntegrator->Status(); }. void SetRelTolerance(double relTol); return number of function evaluations in calculating the integral; unsigned int NEval() const { return fNEval; }; set the relative tolerance. { if (fIntegrator) fIntegrator->SetRelTolerance(relTol); }. void SetAbsTolerance(double absTol); set absolute tolerance. { if (fIntegrator) fIntegrator->SetAbsTolerance(absTol); }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options. { if (fIntegrator) fIntegrator->SetOptions(opt); }. VirtualIntegratorMultiDim * GetIntegrator(); return a pointer to integrator object. { return fIntegrator; }. std::string Name() const; return name of integrator. { return (fIntegrator) ? Options().Integrator() : std::string(""""); }. IntegrationMultiDim::Type GetType(const char* name); static function to get the enumeration from a string. std::string GetName(ROOT::Math::IntegrationMultiDim::Type ); static function to get a string from the enumeration. VirtualIntegratorMultiDim * CreateIntegrator(ROOT::Math::IntegrationMultiDim::Type type, double absTol, double relTol, unsigned int ncall).  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:387,Energy Efficiency,adapt,adaptive,387,". ROOT::Math::IntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IntegratorMultiDim. class ROOT::Math::IntegratorMultiDim. User class for performing multidimensional integration. By default uses adaptive multi-dimensional integration using the algorithm from Genz Mallik; implemented in the class ROOT::Math::AdaptiveIntegratorMultiDim otherwise it can uses via the; plug-in manager the MC integration class (ROOT::Math::GSLMCIntegration) from MathMore. @ingroup Integration. Function Members (Methods); public:. virtual~IntegratorMultiDim(); doubleError() const; ROOT::Math::VirtualIntegratorMultiDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationMultiDim::Type); static ROOT::Math::IntegrationMultiDim::TypeGetType(const char* name); doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); ROOT::Math::IntegratorMultiDimIntegratorMultiDim(ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); ROOT::Math::IntegratorMultiDimIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); stringName() const; ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleResult() const; voidSetAbsTolerance(double absTol); voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); voidSetRelTolerance(double relTol); intStatus() const. protected:. ROOT::Math::VirtualIntegratorMultiDim*CreateIntegrator(ROOT::Math::IntegrationMultiDim::Type type, double absTol, double relTol, unsigned int ncall). private:. ROOT::Ma",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:2744,Energy Efficiency,adapt,adaptive,2744,"orMultiDimOptions& opt); voidSetRelTolerance(double relTol); intStatus() const. protected:. ROOT::Math::VirtualIntegratorMultiDim*CreateIntegrator(ROOT::Math::IntegrationMultiDim::Type type, double absTol, double relTol, unsigned int ncall). private:. ROOT::Math::IntegratorMultiDimIntegratorMultiDim(const ROOT::Math::IntegratorMultiDim&); ROOT::Math::IntegratorMultiDim&operator=(const ROOT::Math::IntegratorMultiDim&). Data Members; private:. auto_ptr<ROOT::Math::IBaseFunctionMultiDim>fFuncpointer to owned function; ROOT::Math::VirtualIntegratorMultiDim*fIntegratorpointer to multi-dimensional integrator base class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IntegratorMultiDim(ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic constructor of multi dimensional Integrator. By default uses the Adaptive integration method. @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. In case no parameter values are passed the default ones used in IntegratorMultiDimOptions are used. IntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic Constructor of multi dimensional Integrator passing a function. By default uses the adaptive integration method. @param f integration function (multi-dim interface); @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). SetFunction(const ROOT::Math::IMultiGenFunction& f). virtual ~IntegratorMultiDim(); remove template constructor since is ambigous; Template Constructor of multi",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:3285,Energy Efficiency,adapt,adaptive,3285,"torMultiDim*fIntegratorpointer to multi-dimensional integrator base class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IntegratorMultiDim(ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic constructor of multi dimensional Integrator. By default uses the Adaptive integration method. @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. In case no parameter values are passed the default ones used in IntegratorMultiDimOptions are used. IntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic Constructor of multi dimensional Integrator passing a function. By default uses the adaptive integration method. @param f integration function (multi-dim interface); @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). SetFunction(const ROOT::Math::IMultiGenFunction& f). virtual ~IntegratorMultiDim(); remove template constructor since is ambigous; Template Constructor of multi dimensional Integrator passing a generic function. By default uses the adaptive integration method. @param f integration function (generic function implementin operator()(const double *); @param dim function dimension; @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). this is ambigous; template<class Function>; IntegratorMultiDim(Function & f, unsigned int dim, IntegrationMultiD",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:3397,Energy Efficiency,adapt,adaptive,3397," Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IntegratorMultiDim(ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic constructor of multi dimensional Integrator. By default uses the Adaptive integration method. @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. In case no parameter values are passed the default ones used in IntegratorMultiDimOptions are used. IntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic Constructor of multi dimensional Integrator passing a function. By default uses the adaptive integration method. @param f integration function (multi-dim interface); @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). SetFunction(const ROOT::Math::IMultiGenFunction& f). virtual ~IntegratorMultiDim(); remove template constructor since is ambigous; Template Constructor of multi dimensional Integrator passing a generic function. By default uses the adaptive integration method. @param f integration function (generic function implementin operator()(const double *); @param dim function dimension; @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). this is ambigous; template<class Function>; IntegratorMultiDim(Function & f, unsigned int dim, IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double r",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:3814,Energy Efficiency,adapt,adaptive,3814,"m relTol desired relative Error; @param size maximum number of sub-intervals. In case no parameter values are passed the default ones used in IntegratorMultiDimOptions are used. IntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic Constructor of multi dimensional Integrator passing a function. By default uses the adaptive integration method. @param f integration function (multi-dim interface); @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). SetFunction(const ROOT::Math::IMultiGenFunction& f). virtual ~IntegratorMultiDim(); remove template constructor since is ambigous; Template Constructor of multi dimensional Integrator passing a generic function. By default uses the adaptive integration method. @param f integration function (generic function implementin operator()(const double *); @param dim function dimension; @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). this is ambigous; template<class Function>; IntegratorMultiDim(Function & f, unsigned int dim, IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int ncall = 100000) {; fIntegrator = CreateIntegrator(type, absTol, relTol, ncall);; SetFunction(f, dim);; }; destructor. IntegratorMultiDim(const ROOT::Math::IntegratorMultiDim& ); disable copy constructur and assignment operator. {}. IntegratorMultiDim & operator=(const ROOT::Math::IntegratorMultiDim& ); { return *this; }. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously g",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:3992,Energy Efficiency,adapt,adaptive,3992,"sed the default ones used in IntegratorMultiDimOptions are used. IntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic Constructor of multi dimensional Integrator passing a function. By default uses the adaptive integration method. @param f integration function (multi-dim interface); @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). SetFunction(const ROOT::Math::IMultiGenFunction& f). virtual ~IntegratorMultiDim(); remove template constructor since is ambigous; Template Constructor of multi dimensional Integrator passing a generic function. By default uses the adaptive integration method. @param f integration function (generic function implementin operator()(const double *); @param dim function dimension; @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). this is ambigous; template<class Function>; IntegratorMultiDim(Function & f, unsigned int dim, IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int ncall = 100000) {; fIntegrator = CreateIntegrator(type, absTol, relTol, ncall);; SetFunction(f, dim);; }; destructor. IntegratorMultiDim(const ROOT::Math::IntegratorMultiDim& ); disable copy constructur and assignment operator. {}. IntegratorMultiDim & operator=(const ROOT::Math::IntegratorMultiDim& ); { return *this; }. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. double Integral(const ROOT::Math::IMultiGenFunction& f, const double* x",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:358,Integrability,integrat,integration,358,". ROOT::Math::IntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IntegratorMultiDim. class ROOT::Math::IntegratorMultiDim. User class for performing multidimensional integration. By default uses adaptive multi-dimensional integration using the algorithm from Genz Mallik; implemented in the class ROOT::Math::AdaptiveIntegratorMultiDim otherwise it can uses via the; plug-in manager the MC integration class (ROOT::Math::GSLMCIntegration) from MathMore. @ingroup Integration. Function Members (Methods); public:. virtual~IntegratorMultiDim(); doubleError() const; ROOT::Math::VirtualIntegratorMultiDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationMultiDim::Type); static ROOT::Math::IntegrationMultiDim::TypeGetType(const char* name); doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); ROOT::Math::IntegratorMultiDimIntegratorMultiDim(ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); ROOT::Math::IntegratorMultiDimIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); stringName() const; ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleResult() const; voidSetAbsTolerance(double absTol); voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); voidSetRelTolerance(double relTol); intStatus() const. protected:. ROOT::Math::VirtualIntegratorMultiDim*CreateIntegrator(ROOT::Math::IntegrationMultiDim::Type type, double absTol, double relTol, unsigned int ncall). private:. ROOT::Ma",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:414,Integrability,integrat,integration,414,". ROOT::Math::IntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IntegratorMultiDim. class ROOT::Math::IntegratorMultiDim. User class for performing multidimensional integration. By default uses adaptive multi-dimensional integration using the algorithm from Genz Mallik; implemented in the class ROOT::Math::AdaptiveIntegratorMultiDim otherwise it can uses via the; plug-in manager the MC integration class (ROOT::Math::GSLMCIntegration) from MathMore. @ingroup Integration. Function Members (Methods); public:. virtual~IntegratorMultiDim(); doubleError() const; ROOT::Math::VirtualIntegratorMultiDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationMultiDim::Type); static ROOT::Math::IntegrationMultiDim::TypeGetType(const char* name); doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); ROOT::Math::IntegratorMultiDimIntegratorMultiDim(ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); ROOT::Math::IntegratorMultiDimIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); stringName() const; ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleResult() const; voidSetAbsTolerance(double absTol); voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); voidSetRelTolerance(double relTol); intStatus() const. protected:. ROOT::Math::VirtualIntegratorMultiDim*CreateIntegrator(ROOT::Math::IntegrationMultiDim::Type type, double absTol, double relTol, unsigned int ncall). private:. ROOT::Ma",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:582,Integrability,integrat,integration,582,". ROOT::Math::IntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IntegratorMultiDim. class ROOT::Math::IntegratorMultiDim. User class for performing multidimensional integration. By default uses adaptive multi-dimensional integration using the algorithm from Genz Mallik; implemented in the class ROOT::Math::AdaptiveIntegratorMultiDim otherwise it can uses via the; plug-in manager the MC integration class (ROOT::Math::GSLMCIntegration) from MathMore. @ingroup Integration. Function Members (Methods); public:. virtual~IntegratorMultiDim(); doubleError() const; ROOT::Math::VirtualIntegratorMultiDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationMultiDim::Type); static ROOT::Math::IntegrationMultiDim::TypeGetType(const char* name); doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); ROOT::Math::IntegratorMultiDimIntegratorMultiDim(ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); ROOT::Math::IntegratorMultiDimIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); stringName() const; ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleResult() const; voidSetAbsTolerance(double absTol); voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); voidSetRelTolerance(double relTol); intStatus() const. protected:. ROOT::Math::VirtualIntegratorMultiDim*CreateIntegrator(ROOT::Math::IntegrationMultiDim::Type type, double absTol, double relTol, unsigned int ncall). private:. ROOT::Ma",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:2340,Integrability,integrat,integrator,2340,"ll = 0); ROOT::Math::IntegratorMultiDimIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); stringName() const; ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleResult() const; voidSetAbsTolerance(double absTol); voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); voidSetRelTolerance(double relTol); intStatus() const. protected:. ROOT::Math::VirtualIntegratorMultiDim*CreateIntegrator(ROOT::Math::IntegrationMultiDim::Type type, double absTol, double relTol, unsigned int ncall). private:. ROOT::Math::IntegratorMultiDimIntegratorMultiDim(const ROOT::Math::IntegratorMultiDim&); ROOT::Math::IntegratorMultiDim&operator=(const ROOT::Math::IntegratorMultiDim&). Data Members; private:. auto_ptr<ROOT::Math::IBaseFunctionMultiDim>fFuncpointer to owned function; ROOT::Math::VirtualIntegratorMultiDim*fIntegratorpointer to multi-dimensional integrator base class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IntegratorMultiDim(ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic constructor of multi dimensional Integrator. By default uses the Adaptive integration method. @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. In case no parameter values are passed the default ones used in IntegratorMultiDimOptions are used. IntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic Constructor of multi dimensional Integrator passing a function. By defaul",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:2694,Integrability,integrat,integration,2694,"nction& f); voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); voidSetRelTolerance(double relTol); intStatus() const. protected:. ROOT::Math::VirtualIntegratorMultiDim*CreateIntegrator(ROOT::Math::IntegrationMultiDim::Type type, double absTol, double relTol, unsigned int ncall). private:. ROOT::Math::IntegratorMultiDimIntegratorMultiDim(const ROOT::Math::IntegratorMultiDim&); ROOT::Math::IntegratorMultiDim&operator=(const ROOT::Math::IntegratorMultiDim&). Data Members; private:. auto_ptr<ROOT::Math::IBaseFunctionMultiDim>fFuncpointer to owned function; ROOT::Math::VirtualIntegratorMultiDim*fIntegratorpointer to multi-dimensional integrator base class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IntegratorMultiDim(ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic constructor of multi dimensional Integrator. By default uses the Adaptive integration method. @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. In case no parameter values are passed the default ones used in IntegratorMultiDimOptions are used. IntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic Constructor of multi dimensional Integrator passing a function. By default uses the adaptive integration method. @param f integration function (multi-dim interface); @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). SetFunction(const ROOT::Math::IMultiGenFunction& f). virtual ~IntegratorMultiDim(); remove template constru",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:2726,Integrability,integrat,integration,2726,"orMultiDimOptions& opt); voidSetRelTolerance(double relTol); intStatus() const. protected:. ROOT::Math::VirtualIntegratorMultiDim*CreateIntegrator(ROOT::Math::IntegrationMultiDim::Type type, double absTol, double relTol, unsigned int ncall). private:. ROOT::Math::IntegratorMultiDimIntegratorMultiDim(const ROOT::Math::IntegratorMultiDim&); ROOT::Math::IntegratorMultiDim&operator=(const ROOT::Math::IntegratorMultiDim&). Data Members; private:. auto_ptr<ROOT::Math::IBaseFunctionMultiDim>fFuncpointer to owned function; ROOT::Math::VirtualIntegratorMultiDim*fIntegratorpointer to multi-dimensional integrator base class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IntegratorMultiDim(ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic constructor of multi dimensional Integrator. By default uses the Adaptive integration method. @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. In case no parameter values are passed the default ones used in IntegratorMultiDimOptions are used. IntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic Constructor of multi dimensional Integrator passing a function. By default uses the adaptive integration method. @param f integration function (multi-dim interface); @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). SetFunction(const ROOT::Math::IMultiGenFunction& f). virtual ~IntegratorMultiDim(); remove template constructor since is ambigous; Template Constructor of multi",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:3294,Integrability,integrat,integration,3294,"torMultiDim*fIntegratorpointer to multi-dimensional integrator base class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IntegratorMultiDim(ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic constructor of multi dimensional Integrator. By default uses the Adaptive integration method. @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. In case no parameter values are passed the default ones used in IntegratorMultiDimOptions are used. IntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic Constructor of multi dimensional Integrator passing a function. By default uses the adaptive integration method. @param f integration function (multi-dim interface); @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). SetFunction(const ROOT::Math::IMultiGenFunction& f). virtual ~IntegratorMultiDim(); remove template constructor since is ambigous; Template Constructor of multi dimensional Integrator passing a generic function. By default uses the adaptive integration method. @param f integration function (generic function implementin operator()(const double *); @param dim function dimension; @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). this is ambigous; template<class Function>; IntegratorMultiDim(Function & f, unsigned int dim, IntegrationMultiD",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:3323,Integrability,integrat,integration,3323," Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IntegratorMultiDim(ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic constructor of multi dimensional Integrator. By default uses the Adaptive integration method. @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. In case no parameter values are passed the default ones used in IntegratorMultiDimOptions are used. IntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic Constructor of multi dimensional Integrator passing a function. By default uses the adaptive integration method. @param f integration function (multi-dim interface); @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). SetFunction(const ROOT::Math::IMultiGenFunction& f). virtual ~IntegratorMultiDim(); remove template constructor since is ambigous; Template Constructor of multi dimensional Integrator passing a generic function. By default uses the adaptive integration method. @param f integration function (generic function implementin operator()(const double *); @param dim function dimension; @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). this is ambigous; template<class Function>; IntegratorMultiDim(Function & f, unsigned int dim, IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double r",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:3355,Integrability,interface,interface,3355," Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IntegratorMultiDim(ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic constructor of multi dimensional Integrator. By default uses the Adaptive integration method. @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. In case no parameter values are passed the default ones used in IntegratorMultiDimOptions are used. IntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic Constructor of multi dimensional Integrator passing a function. By default uses the adaptive integration method. @param f integration function (multi-dim interface); @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). SetFunction(const ROOT::Math::IMultiGenFunction& f). virtual ~IntegratorMultiDim(); remove template constructor since is ambigous; Template Constructor of multi dimensional Integrator passing a generic function. By default uses the adaptive integration method. @param f integration function (generic function implementin operator()(const double *); @param dim function dimension; @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). this is ambigous; template<class Function>; IntegratorMultiDim(Function & f, unsigned int dim, IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double r",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:3379,Integrability,integrat,integration,3379," Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IntegratorMultiDim(ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic constructor of multi dimensional Integrator. By default uses the Adaptive integration method. @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. In case no parameter values are passed the default ones used in IntegratorMultiDimOptions are used. IntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic Constructor of multi dimensional Integrator passing a function. By default uses the adaptive integration method. @param f integration function (multi-dim interface); @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). SetFunction(const ROOT::Math::IMultiGenFunction& f). virtual ~IntegratorMultiDim(); remove template constructor since is ambigous; Template Constructor of multi dimensional Integrator passing a generic function. By default uses the adaptive integration method. @param f integration function (generic function implementin operator()(const double *); @param dim function dimension; @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). this is ambigous; template<class Function>; IntegratorMultiDim(Function & f, unsigned int dim, IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double r",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:3559,Integrability,integrat,integratioon,3559,"im::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic constructor of multi dimensional Integrator. By default uses the Adaptive integration method. @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. In case no parameter values are passed the default ones used in IntegratorMultiDimOptions are used. IntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic Constructor of multi dimensional Integrator passing a function. By default uses the adaptive integration method. @param f integration function (multi-dim interface); @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). SetFunction(const ROOT::Math::IMultiGenFunction& f). virtual ~IntegratorMultiDim(); remove template constructor since is ambigous; Template Constructor of multi dimensional Integrator passing a generic function. By default uses the adaptive integration method. @param f integration function (generic function implementin operator()(const double *); @param dim function dimension; @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). this is ambigous; template<class Function>; IntegratorMultiDim(Function & f, unsigned int dim, IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int ncall = 100000) {; fIntegrator = CreateIntegrator(type, absTol, relTol, ncall);; SetFunction(f, dim);; }; de",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:3823,Integrability,integrat,integration,3823,"m relTol desired relative Error; @param size maximum number of sub-intervals. In case no parameter values are passed the default ones used in IntegratorMultiDimOptions are used. IntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic Constructor of multi dimensional Integrator passing a function. By default uses the adaptive integration method. @param f integration function (multi-dim interface); @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). SetFunction(const ROOT::Math::IMultiGenFunction& f). virtual ~IntegratorMultiDim(); remove template constructor since is ambigous; Template Constructor of multi dimensional Integrator passing a generic function. By default uses the adaptive integration method. @param f integration function (generic function implementin operator()(const double *); @param dim function dimension; @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). this is ambigous; template<class Function>; IntegratorMultiDim(Function & f, unsigned int dim, IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int ncall = 100000) {; fIntegrator = CreateIntegrator(type, absTol, relTol, ncall);; SetFunction(f, dim);; }; destructor. IntegratorMultiDim(const ROOT::Math::IntegratorMultiDim& ); disable copy constructur and assignment operator. {}. IntegratorMultiDim & operator=(const ROOT::Math::IntegratorMultiDim& ); { return *this; }. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously g",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:3852,Integrability,integrat,integration,3852,"sed the default ones used in IntegratorMultiDimOptions are used. IntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic Constructor of multi dimensional Integrator passing a function. By default uses the adaptive integration method. @param f integration function (multi-dim interface); @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). SetFunction(const ROOT::Math::IMultiGenFunction& f). virtual ~IntegratorMultiDim(); remove template constructor since is ambigous; Template Constructor of multi dimensional Integrator passing a generic function. By default uses the adaptive integration method. @param f integration function (generic function implementin operator()(const double *); @param dim function dimension; @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). this is ambigous; template<class Function>; IntegratorMultiDim(Function & f, unsigned int dim, IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int ncall = 100000) {; fIntegrator = CreateIntegrator(type, absTol, relTol, ncall);; SetFunction(f, dim);; }; destructor. IntegratorMultiDim(const ROOT::Math::IntegratorMultiDim& ); disable copy constructur and assignment operator. {}. IntegratorMultiDim & operator=(const ROOT::Math::IntegratorMultiDim& ); { return *this; }. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. double Integral(const ROOT::Math::IMultiGenFunction& f, const double* x",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:3974,Integrability,integrat,integration,3974,"sed the default ones used in IntegratorMultiDimOptions are used. IntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic Constructor of multi dimensional Integrator passing a function. By default uses the adaptive integration method. @param f integration function (multi-dim interface); @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). SetFunction(const ROOT::Math::IMultiGenFunction& f). virtual ~IntegratorMultiDim(); remove template constructor since is ambigous; Template Constructor of multi dimensional Integrator passing a generic function. By default uses the adaptive integration method. @param f integration function (generic function implementin operator()(const double *); @param dim function dimension; @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). this is ambigous; template<class Function>; IntegratorMultiDim(Function & f, unsigned int dim, IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int ncall = 100000) {; fIntegrator = CreateIntegrator(type, absTol, relTol, ncall);; SetFunction(f, dim);; }; destructor. IntegratorMultiDim(const ROOT::Math::IntegratorMultiDim& ); disable copy constructur and assignment operator. {}. IntegratorMultiDim & operator=(const ROOT::Math::IntegratorMultiDim& ); { return *this; }. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. double Integral(const ROOT::Math::IMultiGenFunction& f, const double* x",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:4154,Integrability,integrat,integratioon,4154,"= IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic Constructor of multi dimensional Integrator passing a function. By default uses the adaptive integration method. @param f integration function (multi-dim interface); @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). SetFunction(const ROOT::Math::IMultiGenFunction& f). virtual ~IntegratorMultiDim(); remove template constructor since is ambigous; Template Constructor of multi dimensional Integrator passing a generic function. By default uses the adaptive integration method. @param f integration function (generic function implementin operator()(const double *); @param dim function dimension; @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). this is ambigous; template<class Function>; IntegratorMultiDim(Function & f, unsigned int dim, IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int ncall = 100000) {; fIntegrator = CreateIntegrator(type, absTol, relTol, ncall);; SetFunction(f, dim);; }; destructor. IntegratorMultiDim(const ROOT::Math::IntegratorMultiDim& ); disable copy constructur and assignment operator. {}. IntegratorMultiDim & operator=(const ROOT::Math::IntegratorMultiDim& ); { return *this; }. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. double Result() const; return result of last integration. { return fIntegrator == 0 ? 0 : fInteg",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:5047,Integrability,integrat,integration,5047,"bsTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). this is ambigous; template<class Function>; IntegratorMultiDim(Function & f, unsigned int dim, IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int ncall = 100000) {; fIntegrator = CreateIntegrator(type, absTol, relTol, ncall);; SetFunction(f, dim);; }; destructor. IntegratorMultiDim(const ROOT::Math::IntegratorMultiDim& ); disable copy constructur and assignment operator. {}. IntegratorMultiDim & operator=(const ROOT::Math::IntegratorMultiDim& ); { return *this; }. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. double Result() const; return result of last integration. { return fIntegrator == 0 ? 0 : fIntegrator->Result(); }. double Error() const; return integration error. { return fIntegrator == 0 ? 0 : fIntegrator->Error(); }. int Status() const; return the Error Status of the last Integral calculation. { return fIntegrator == 0 ? -1 : fIntegrator->Status(); }. void SetRelTolerance(double relTol); return number of function evaluations in calculating the integral; unsigned int NEval() const { return fNEval; }; set the relative tolerance. { if (fIntegrator) fIntegrator->SetRelTolerance(relTol); }. void SetAbsTolerance(double absTol); set absolute tolerance. { if (fIntegrator) fIntegrator->SetAbsTolerance(absTol); }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options. { if (fIntegrator) fIntegrator->SetOptions(opt); }. VirtualIntegratorMultiDim * GetIntegrator(); return a pointer to integrator object. { return fIntegrator; }. std::string Name() const; return name of integrator. { return (fI",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:5147,Integrability,integrat,integration,5147,"y only to MC integratioon methods). this is ambigous; template<class Function>; IntegratorMultiDim(Function & f, unsigned int dim, IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int ncall = 100000) {; fIntegrator = CreateIntegrator(type, absTol, relTol, ncall);; SetFunction(f, dim);; }; destructor. IntegratorMultiDim(const ROOT::Math::IntegratorMultiDim& ); disable copy constructur and assignment operator. {}. IntegratorMultiDim & operator=(const ROOT::Math::IntegratorMultiDim& ); { return *this; }. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. double Result() const; return result of last integration. { return fIntegrator == 0 ? 0 : fIntegrator->Result(); }. double Error() const; return integration error. { return fIntegrator == 0 ? 0 : fIntegrator->Error(); }. int Status() const; return the Error Status of the last Integral calculation. { return fIntegrator == 0 ? -1 : fIntegrator->Status(); }. void SetRelTolerance(double relTol); return number of function evaluations in calculating the integral; unsigned int NEval() const { return fNEval; }; set the relative tolerance. { if (fIntegrator) fIntegrator->SetRelTolerance(relTol); }. void SetAbsTolerance(double absTol); set absolute tolerance. { if (fIntegrator) fIntegrator->SetAbsTolerance(absTol); }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options. { if (fIntegrator) fIntegrator->SetOptions(opt); }. VirtualIntegratorMultiDim * GetIntegrator(); return a pointer to integrator object. { return fIntegrator; }. std::string Name() const; return name of integrator. { return (fIntegrator) ? Options().Integrator() : std::string(""""); }. IntegrationMultiDim::Type GetType(const char* name); ",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:5921,Integrability,integrat,integrator,5921,"IntegratorMultiDim& ); { return *this; }. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. double Result() const; return result of last integration. { return fIntegrator == 0 ? 0 : fIntegrator->Result(); }. double Error() const; return integration error. { return fIntegrator == 0 ? 0 : fIntegrator->Error(); }. int Status() const; return the Error Status of the last Integral calculation. { return fIntegrator == 0 ? -1 : fIntegrator->Status(); }. void SetRelTolerance(double relTol); return number of function evaluations in calculating the integral; unsigned int NEval() const { return fNEval; }; set the relative tolerance. { if (fIntegrator) fIntegrator->SetRelTolerance(relTol); }. void SetAbsTolerance(double absTol); set absolute tolerance. { if (fIntegrator) fIntegrator->SetAbsTolerance(absTol); }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options. { if (fIntegrator) fIntegrator->SetOptions(opt); }. VirtualIntegratorMultiDim * GetIntegrator(); return a pointer to integrator object. { return fIntegrator; }. std::string Name() const; return name of integrator. { return (fIntegrator) ? Options().Integrator() : std::string(""""); }. IntegrationMultiDim::Type GetType(const char* name); static function to get the enumeration from a string. std::string GetName(ROOT::Math::IntegrationMultiDim::Type ); static function to get a string from the enumeration. VirtualIntegratorMultiDim * CreateIntegrator(ROOT::Math::IntegrationMultiDim::Type type, double absTol, double relTol, unsigned int ncall).  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:6006,Integrability,integrat,integrator,6006,"IntegratorMultiDim& ); { return *this; }. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. double Result() const; return result of last integration. { return fIntegrator == 0 ? 0 : fIntegrator->Result(); }. double Error() const; return integration error. { return fIntegrator == 0 ? 0 : fIntegrator->Error(); }. int Status() const; return the Error Status of the last Integral calculation. { return fIntegrator == 0 ? -1 : fIntegrator->Status(); }. void SetRelTolerance(double relTol); return number of function evaluations in calculating the integral; unsigned int NEval() const { return fNEval; }; set the relative tolerance. { if (fIntegrator) fIntegrator->SetRelTolerance(relTol); }. void SetAbsTolerance(double absTol); set absolute tolerance. { if (fIntegrator) fIntegrator->SetAbsTolerance(absTol); }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options. { if (fIntegrator) fIntegrator->SetOptions(opt); }. VirtualIntegratorMultiDim * GetIntegrator(); return a pointer to integrator object. { return fIntegrator; }. std::string Name() const; return name of integrator. { return (fIntegrator) ? Options().Integrator() : std::string(""""); }. IntegrationMultiDim::Type GetType(const char* name); static function to get the enumeration from a string. std::string GetName(ROOT::Math::IntegrationMultiDim::Type ); static function to get a string from the enumeration. VirtualIntegratorMultiDim * CreateIntegrator(ROOT::Math::IntegrationMultiDim::Type type, double absTol, double relTol, unsigned int ncall).  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:387,Modifiability,adapt,adaptive,387,". ROOT::Math::IntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IntegratorMultiDim. class ROOT::Math::IntegratorMultiDim. User class for performing multidimensional integration. By default uses adaptive multi-dimensional integration using the algorithm from Genz Mallik; implemented in the class ROOT::Math::AdaptiveIntegratorMultiDim otherwise it can uses via the; plug-in manager the MC integration class (ROOT::Math::GSLMCIntegration) from MathMore. @ingroup Integration. Function Members (Methods); public:. virtual~IntegratorMultiDim(); doubleError() const; ROOT::Math::VirtualIntegratorMultiDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationMultiDim::Type); static ROOT::Math::IntegrationMultiDim::TypeGetType(const char* name); doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); ROOT::Math::IntegratorMultiDimIntegratorMultiDim(ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); ROOT::Math::IntegratorMultiDimIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); stringName() const; ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleResult() const; voidSetAbsTolerance(double absTol); voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); voidSetRelTolerance(double relTol); intStatus() const. protected:. ROOT::Math::VirtualIntegratorMultiDim*CreateIntegrator(ROOT::Math::IntegrationMultiDim::Type type, double absTol, double relTol, unsigned int ncall). private:. ROOT::Ma",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:559,Modifiability,plug-in,plug-in,559,". ROOT::Math::IntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IntegratorMultiDim. class ROOT::Math::IntegratorMultiDim. User class for performing multidimensional integration. By default uses adaptive multi-dimensional integration using the algorithm from Genz Mallik; implemented in the class ROOT::Math::AdaptiveIntegratorMultiDim otherwise it can uses via the; plug-in manager the MC integration class (ROOT::Math::GSLMCIntegration) from MathMore. @ingroup Integration. Function Members (Methods); public:. virtual~IntegratorMultiDim(); doubleError() const; ROOT::Math::VirtualIntegratorMultiDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationMultiDim::Type); static ROOT::Math::IntegrationMultiDim::TypeGetType(const char* name); doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); ROOT::Math::IntegratorMultiDimIntegratorMultiDim(ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); ROOT::Math::IntegratorMultiDimIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); stringName() const; ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleResult() const; voidSetAbsTolerance(double absTol); voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); voidSetRelTolerance(double relTol); intStatus() const. protected:. ROOT::Math::VirtualIntegratorMultiDim*CreateIntegrator(ROOT::Math::IntegrationMultiDim::Type type, double absTol, double relTol, unsigned int ncall). private:. ROOT::Ma",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:2744,Modifiability,adapt,adaptive,2744,"orMultiDimOptions& opt); voidSetRelTolerance(double relTol); intStatus() const. protected:. ROOT::Math::VirtualIntegratorMultiDim*CreateIntegrator(ROOT::Math::IntegrationMultiDim::Type type, double absTol, double relTol, unsigned int ncall). private:. ROOT::Math::IntegratorMultiDimIntegratorMultiDim(const ROOT::Math::IntegratorMultiDim&); ROOT::Math::IntegratorMultiDim&operator=(const ROOT::Math::IntegratorMultiDim&). Data Members; private:. auto_ptr<ROOT::Math::IBaseFunctionMultiDim>fFuncpointer to owned function; ROOT::Math::VirtualIntegratorMultiDim*fIntegratorpointer to multi-dimensional integrator base class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IntegratorMultiDim(ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic constructor of multi dimensional Integrator. By default uses the Adaptive integration method. @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. In case no parameter values are passed the default ones used in IntegratorMultiDimOptions are used. IntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic Constructor of multi dimensional Integrator passing a function. By default uses the adaptive integration method. @param f integration function (multi-dim interface); @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). SetFunction(const ROOT::Math::IMultiGenFunction& f). virtual ~IntegratorMultiDim(); remove template constructor since is ambigous; Template Constructor of multi",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:3285,Modifiability,adapt,adaptive,3285,"torMultiDim*fIntegratorpointer to multi-dimensional integrator base class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IntegratorMultiDim(ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic constructor of multi dimensional Integrator. By default uses the Adaptive integration method. @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. In case no parameter values are passed the default ones used in IntegratorMultiDimOptions are used. IntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic Constructor of multi dimensional Integrator passing a function. By default uses the adaptive integration method. @param f integration function (multi-dim interface); @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). SetFunction(const ROOT::Math::IMultiGenFunction& f). virtual ~IntegratorMultiDim(); remove template constructor since is ambigous; Template Constructor of multi dimensional Integrator passing a generic function. By default uses the adaptive integration method. @param f integration function (generic function implementin operator()(const double *); @param dim function dimension; @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). this is ambigous; template<class Function>; IntegratorMultiDim(Function & f, unsigned int dim, IntegrationMultiD",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:3397,Modifiability,adapt,adaptive,3397," Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IntegratorMultiDim(ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic constructor of multi dimensional Integrator. By default uses the Adaptive integration method. @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. In case no parameter values are passed the default ones used in IntegratorMultiDimOptions are used. IntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic Constructor of multi dimensional Integrator passing a function. By default uses the adaptive integration method. @param f integration function (multi-dim interface); @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). SetFunction(const ROOT::Math::IMultiGenFunction& f). virtual ~IntegratorMultiDim(); remove template constructor since is ambigous; Template Constructor of multi dimensional Integrator passing a generic function. By default uses the adaptive integration method. @param f integration function (generic function implementin operator()(const double *); @param dim function dimension; @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). this is ambigous; template<class Function>; IntegratorMultiDim(Function & f, unsigned int dim, IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double r",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:3814,Modifiability,adapt,adaptive,3814,"m relTol desired relative Error; @param size maximum number of sub-intervals. In case no parameter values are passed the default ones used in IntegratorMultiDimOptions are used. IntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic Constructor of multi dimensional Integrator passing a function. By default uses the adaptive integration method. @param f integration function (multi-dim interface); @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). SetFunction(const ROOT::Math::IMultiGenFunction& f). virtual ~IntegratorMultiDim(); remove template constructor since is ambigous; Template Constructor of multi dimensional Integrator passing a generic function. By default uses the adaptive integration method. @param f integration function (generic function implementin operator()(const double *); @param dim function dimension; @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). this is ambigous; template<class Function>; IntegratorMultiDim(Function & f, unsigned int dim, IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int ncall = 100000) {; fIntegrator = CreateIntegrator(type, absTol, relTol, ncall);; SetFunction(f, dim);; }; destructor. IntegratorMultiDim(const ROOT::Math::IntegratorMultiDim& ); disable copy constructur and assignment operator. {}. IntegratorMultiDim & operator=(const ROOT::Math::IntegratorMultiDim& ); { return *this; }. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously g",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:3992,Modifiability,adapt,adaptive,3992,"sed the default ones used in IntegratorMultiDimOptions are used. IntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); Generic Constructor of multi dimensional Integrator passing a function. By default uses the adaptive integration method. @param f integration function (multi-dim interface); @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). SetFunction(const ROOT::Math::IMultiGenFunction& f). virtual ~IntegratorMultiDim(); remove template constructor since is ambigous; Template Constructor of multi dimensional Integrator passing a generic function. By default uses the adaptive integration method. @param f integration function (generic function implementin operator()(const double *); @param dim function dimension; @param type integration type (adaptive, MC methods, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param ncall number of function calls (apply only to MC integratioon methods). this is ambigous; template<class Function>; IntegratorMultiDim(Function & f, unsigned int dim, IntegrationMultiDim::Type type = IntegrationMultiDim::kADAPTIVE, double absTol = 1.E-9, double relTol = 1E-6, unsigned int ncall = 100000) {; fIntegrator = CreateIntegrator(type, absTol, relTol, ncall);; SetFunction(f, dim);; }; destructor. IntegratorMultiDim(const ROOT::Math::IntegratorMultiDim& ); disable copy constructur and assignment operator. {}. IntegratorMultiDim & operator=(const ROOT::Math::IntegratorMultiDim& ); { return *this; }. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. double Integral(const ROOT::Math::IMultiGenFunction& f, const double* x",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html:330,Performance,perform,performing,330,". ROOT::Math::IntegratorMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IntegratorMultiDim. class ROOT::Math::IntegratorMultiDim. User class for performing multidimensional integration. By default uses adaptive multi-dimensional integration using the algorithm from Genz Mallik; implemented in the class ROOT::Math::AdaptiveIntegratorMultiDim otherwise it can uses via the; plug-in manager the MC integration class (ROOT::Math::GSLMCIntegration) from MathMore. @ingroup Integration. Function Members (Methods); public:. virtual~IntegratorMultiDim(); doubleError() const; ROOT::Math::VirtualIntegratorMultiDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationMultiDim::Type); static ROOT::Math::IntegrationMultiDim::TypeGetType(const char* name); doubleIntegral(const double* xmin, const double* xmax); doubleIntegral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); ROOT::Math::IntegratorMultiDimIntegratorMultiDim(ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); ROOT::Math::IntegratorMultiDimIntegratorMultiDim(const ROOT::Math::IMultiGenFunction& f, ROOT::Math::IntegrationMultiDim::Type type = IntegrationMultiDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int ncall = 0); stringName() const; ROOT::Math::IntegratorMultiDimOptionsOptions() const; doubleResult() const; voidSetAbsTolerance(double absTol); voidSetFunction(const ROOT::Math::IMultiGenFunction& f); voidSetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); voidSetRelTolerance(double relTol); intStatus() const. protected:. ROOT::Math::VirtualIntegratorMultiDim*CreateIntegrator(ROOT::Math::IntegrationMultiDim::Type type, double absTol, double relTol, unsigned int ncall). private:. ROOT::Ma",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDimOptions.html:2573,Availability,toler,tolerance,2573,; voidROOT::Math::BaseIntegratorOptions::SetAbsTolerance(double tol); static voidSetDefaultAbsTolerance(double tol); static voidSetDefaultIntegrator(const char* name); static voidSetDefaultNCalls(unsigned int ncall); static voidSetDefaultRelTolerance(double tol); static voidSetDefaultWKSize(unsigned int size); voidROOT::Math::BaseIntegratorOptions::SetExtraOptions(const ROOT::Math::IOptions& opt); voidSetIntegrator(const char* name); voidSetNCalls(unsigned int calls); voidROOT::Math::BaseIntegratorOptions::SetRelTolerance(double tol); voidROOT::Math::BaseIntegratorOptions::SetWKSize(unsigned int size); unsigned intROOT::Math::BaseIntegratorOptions::WKSize() const. protected:. voidROOT::Math::BaseIntegratorOptions::ClearExtra(). Data Members; protected:. doubleROOT::Math::BaseIntegratorOptions::fAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*ROOT::Math::BaseIntegratorOptions::fExtraOptionsextra options ; intROOT::Math::BaseIntegratorOptions::fIntegTypeIntegrator type (value converted from enum); unsigned intROOT::Math::BaseIntegratorOptions::fNCalls(max) funxtion calls; doubleROOT::Math::BaseIntegratorOptions::fRelTolerancerelative tolerance ; unsigned intROOT::Math::BaseIntegratorOptions::fWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::IntegratorMultiDimOptions& rhs); assignment operators. std::string Integrator() const; name of 1D integrator. IntegrationOneDim::Type IntegratorType() const; type of the integrator (return the enumeration type). { return (IntegrationOneDim::Type) fIntegType; }. void SetIntegrator(const char* name); set 1D integrator name. void Print(ostream& os = std::cout) const; print all the options. void SetDefaultIntegrator(const char* name); static methods for setting and retrieving the default options. void SetDefaultAbsTolerance(double tol). void SetDefaultRelTolerance(double tol). void SetDefaultWKSize(unsigned int size,MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDimOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDimOptions.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDimOptions.html:2902,Availability,toler,tolerance,2902,; voidROOT::Math::BaseIntegratorOptions::SetAbsTolerance(double tol); static voidSetDefaultAbsTolerance(double tol); static voidSetDefaultIntegrator(const char* name); static voidSetDefaultNCalls(unsigned int ncall); static voidSetDefaultRelTolerance(double tol); static voidSetDefaultWKSize(unsigned int size); voidROOT::Math::BaseIntegratorOptions::SetExtraOptions(const ROOT::Math::IOptions& opt); voidSetIntegrator(const char* name); voidSetNCalls(unsigned int calls); voidROOT::Math::BaseIntegratorOptions::SetRelTolerance(double tol); voidROOT::Math::BaseIntegratorOptions::SetWKSize(unsigned int size); unsigned intROOT::Math::BaseIntegratorOptions::WKSize() const. protected:. voidROOT::Math::BaseIntegratorOptions::ClearExtra(). Data Members; protected:. doubleROOT::Math::BaseIntegratorOptions::fAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*ROOT::Math::BaseIntegratorOptions::fExtraOptionsextra options ; intROOT::Math::BaseIntegratorOptions::fIntegTypeIntegrator type (value converted from enum); unsigned intROOT::Math::BaseIntegratorOptions::fNCalls(max) funxtion calls; doubleROOT::Math::BaseIntegratorOptions::fRelTolerancerelative tolerance ; unsigned intROOT::Math::BaseIntegratorOptions::fWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::IntegratorMultiDimOptions& rhs); assignment operators. std::string Integrator() const; name of 1D integrator. IntegrationOneDim::Type IntegratorType() const; type of the integrator (return the enumeration type). { return (IntegrationOneDim::Type) fIntegType; }. void SetIntegrator(const char* name); set 1D integrator name. void Print(ostream& os = std::cout) const; print all the options. void SetDefaultIntegrator(const char* name); static methods for setting and retrieving the default options. void SetDefaultAbsTolerance(double tol). void SetDefaultRelTolerance(double tol). void SetDefaultWKSize(unsigned int size,MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDimOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDimOptions.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDimOptions.html:403,Deployability,integrat,integration,403,". ROOT::Math::IntegratorMultiDimOptions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IntegratorMultiDimOptions. class ROOT::Math::IntegratorMultiDimOptions: public ROOT::Math::BaseIntegratorOptions. Base class for Numerical integration options; common in 1D and multi-dimension; This is an internal class and is not supposed to be instantiated by the user. @ingroup Integration. Function Members (Methods); public:. virtual~IntegratorMultiDimOptions(); doubleROOT::Math::BaseIntegratorOptions::AbsTolerance() const; static ROOT::Math::IOptions&Default(const char* name); static doubleDefaultAbsTolerance(); static stringDefaultIntegrator(); static ROOT::Math::IntegrationMultiDim::TypeDefaultIntegratorType(); static unsigned intDefaultNCalls(); static doubleDefaultRelTolerance(); static unsigned intDefaultWKSize(); ROOT::Math::IOptions*ROOT::Math::BaseIntegratorOptions::ExtraOptions() const; static ROOT::Math::IOptions*FindDefault(const char* name); virtual stringIntegrator() const; ROOT::Math::IntegratorMultiDimOptionsIntegratorMultiDimOptions(ROOT::Math::IOptions* extraOpts = 0); ROOT::Math::IntegratorMultiDimOptionsIntegratorMultiDimOptions(const ROOT::Math::IntegratorMultiDimOptions& rhs); ROOT::Math::IntegrationMultiDim::TypeIntegratorType() const; unsigned intNCalls() const; ROOT::Math::IntegratorMultiDimOptions&operator=(const ROOT::Math::IntegratorMultiDimOptions& rhs); voidPrint(ostream& os = std::cout) const; static voidPrintDefault(const char* name = 0, ostream& os = std::cout); doubleROOT::Math::BaseIntegratorOptions::RelTolerance() const; voidROOT::Math::BaseIntegratorOptions::SetAbsTolerance(double tol); static voidSetDefaultAbsTolerance(double tol); static voidSetDefaultIntegrator(const char* name); static voidSetDefaultNCalls(unsigned int ncall); static voidSetDefaultRelTolerance(doub",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDimOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDimOptions.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDimOptions.html:3225,Deployability,integrat,integrator,3225,"nt calls); voidROOT::Math::BaseIntegratorOptions::SetRelTolerance(double tol); voidROOT::Math::BaseIntegratorOptions::SetWKSize(unsigned int size); unsigned intROOT::Math::BaseIntegratorOptions::WKSize() const. protected:. voidROOT::Math::BaseIntegratorOptions::ClearExtra(). Data Members; protected:. doubleROOT::Math::BaseIntegratorOptions::fAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*ROOT::Math::BaseIntegratorOptions::fExtraOptionsextra options ; intROOT::Math::BaseIntegratorOptions::fIntegTypeIntegrator type (value converted from enum); unsigned intROOT::Math::BaseIntegratorOptions::fNCalls(max) funxtion calls; doubleROOT::Math::BaseIntegratorOptions::fRelTolerancerelative tolerance ; unsigned intROOT::Math::BaseIntegratorOptions::fWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::IntegratorMultiDimOptions& rhs); assignment operators. std::string Integrator() const; name of 1D integrator. IntegrationOneDim::Type IntegratorType() const; type of the integrator (return the enumeration type). { return (IntegrationOneDim::Type) fIntegType; }. void SetIntegrator(const char* name); set 1D integrator name. void Print(ostream& os = std::cout) const; print all the options. void SetDefaultIntegrator(const char* name); static methods for setting and retrieving the default options. void SetDefaultAbsTolerance(double tol). void SetDefaultRelTolerance(double tol). void SetDefaultWKSize(unsigned int size). std::string DefaultIntegrator(). IntegrationOneDim::Type DefaultIntegratorType(). double DefaultAbsTolerance(). double DefaultRelTolerance(). unsigned int DefaultWKSize(). ROOT::Math::IOptions & Default(const char* name); retrieve specific options - if not existing create a IOptions. ROOT::Math::IOptions * FindDefault(const char* name); find specific options - return 0 if not existing. void PrintDefault(const char* name = 0, ostream& os = std::cout); print",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDimOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDimOptions.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDimOptions.html:3297,Deployability,integrat,integrator,3297,"voidROOT::Math::BaseIntegratorOptions::SetWKSize(unsigned int size); unsigned intROOT::Math::BaseIntegratorOptions::WKSize() const. protected:. voidROOT::Math::BaseIntegratorOptions::ClearExtra(). Data Members; protected:. doubleROOT::Math::BaseIntegratorOptions::fAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*ROOT::Math::BaseIntegratorOptions::fExtraOptionsextra options ; intROOT::Math::BaseIntegratorOptions::fIntegTypeIntegrator type (value converted from enum); unsigned intROOT::Math::BaseIntegratorOptions::fNCalls(max) funxtion calls; doubleROOT::Math::BaseIntegratorOptions::fRelTolerancerelative tolerance ; unsigned intROOT::Math::BaseIntegratorOptions::fWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::IntegratorMultiDimOptions& rhs); assignment operators. std::string Integrator() const; name of 1D integrator. IntegrationOneDim::Type IntegratorType() const; type of the integrator (return the enumeration type). { return (IntegrationOneDim::Type) fIntegType; }. void SetIntegrator(const char* name); set 1D integrator name. void Print(ostream& os = std::cout) const; print all the options. void SetDefaultIntegrator(const char* name); static methods for setting and retrieving the default options. void SetDefaultAbsTolerance(double tol). void SetDefaultRelTolerance(double tol). void SetDefaultWKSize(unsigned int size). std::string DefaultIntegrator(). IntegrationOneDim::Type DefaultIntegratorType(). double DefaultAbsTolerance(). double DefaultRelTolerance(). unsigned int DefaultWKSize(). ROOT::Math::IOptions & Default(const char* name); retrieve specific options - if not existing create a IOptions. ROOT::Math::IOptions * FindDefault(const char* name); find specific options - return 0 if not existing. void PrintDefault(const char* name = 0, ostream& os = std::cout); print only the specified default options. IntegratorMultiDimOptions(IOptions * extr",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDimOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDimOptions.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDimOptions.html:3434,Deployability,integrat,integrator,3434,"protected:. voidROOT::Math::BaseIntegratorOptions::ClearExtra(). Data Members; protected:. doubleROOT::Math::BaseIntegratorOptions::fAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*ROOT::Math::BaseIntegratorOptions::fExtraOptionsextra options ; intROOT::Math::BaseIntegratorOptions::fIntegTypeIntegrator type (value converted from enum); unsigned intROOT::Math::BaseIntegratorOptions::fNCalls(max) funxtion calls; doubleROOT::Math::BaseIntegratorOptions::fRelTolerancerelative tolerance ; unsigned intROOT::Math::BaseIntegratorOptions::fWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::IntegratorMultiDimOptions& rhs); assignment operators. std::string Integrator() const; name of 1D integrator. IntegrationOneDim::Type IntegratorType() const; type of the integrator (return the enumeration type). { return (IntegrationOneDim::Type) fIntegType; }. void SetIntegrator(const char* name); set 1D integrator name. void Print(ostream& os = std::cout) const; print all the options. void SetDefaultIntegrator(const char* name); static methods for setting and retrieving the default options. void SetDefaultAbsTolerance(double tol). void SetDefaultRelTolerance(double tol). void SetDefaultWKSize(unsigned int size). std::string DefaultIntegrator(). IntegrationOneDim::Type DefaultIntegratorType(). double DefaultAbsTolerance(). double DefaultRelTolerance(). unsigned int DefaultWKSize(). ROOT::Math::IOptions & Default(const char* name); retrieve specific options - if not existing create a IOptions. ROOT::Math::IOptions * FindDefault(const char* name); find specific options - return 0 if not existing. void PrintDefault(const char* name = 0, ostream& os = std::cout); print only the specified default options. IntegratorMultiDimOptions(IOptions * extraOpts = 0); constructor using the default options; can pass a pointer to extra options (N.B. pointer will be managed by the class). ",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDimOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDimOptions.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDimOptions.html:403,Integrability,integrat,integration,403,". ROOT::Math::IntegratorMultiDimOptions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IntegratorMultiDimOptions. class ROOT::Math::IntegratorMultiDimOptions: public ROOT::Math::BaseIntegratorOptions. Base class for Numerical integration options; common in 1D and multi-dimension; This is an internal class and is not supposed to be instantiated by the user. @ingroup Integration. Function Members (Methods); public:. virtual~IntegratorMultiDimOptions(); doubleROOT::Math::BaseIntegratorOptions::AbsTolerance() const; static ROOT::Math::IOptions&Default(const char* name); static doubleDefaultAbsTolerance(); static stringDefaultIntegrator(); static ROOT::Math::IntegrationMultiDim::TypeDefaultIntegratorType(); static unsigned intDefaultNCalls(); static doubleDefaultRelTolerance(); static unsigned intDefaultWKSize(); ROOT::Math::IOptions*ROOT::Math::BaseIntegratorOptions::ExtraOptions() const; static ROOT::Math::IOptions*FindDefault(const char* name); virtual stringIntegrator() const; ROOT::Math::IntegratorMultiDimOptionsIntegratorMultiDimOptions(ROOT::Math::IOptions* extraOpts = 0); ROOT::Math::IntegratorMultiDimOptionsIntegratorMultiDimOptions(const ROOT::Math::IntegratorMultiDimOptions& rhs); ROOT::Math::IntegrationMultiDim::TypeIntegratorType() const; unsigned intNCalls() const; ROOT::Math::IntegratorMultiDimOptions&operator=(const ROOT::Math::IntegratorMultiDimOptions& rhs); voidPrint(ostream& os = std::cout) const; static voidPrintDefault(const char* name = 0, ostream& os = std::cout); doubleROOT::Math::BaseIntegratorOptions::RelTolerance() const; voidROOT::Math::BaseIntegratorOptions::SetAbsTolerance(double tol); static voidSetDefaultAbsTolerance(double tol); static voidSetDefaultIntegrator(const char* name); static voidSetDefaultNCalls(unsigned int ncall); static voidSetDefaultRelTolerance(doub",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDimOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDimOptions.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDimOptions.html:3225,Integrability,integrat,integrator,3225,"nt calls); voidROOT::Math::BaseIntegratorOptions::SetRelTolerance(double tol); voidROOT::Math::BaseIntegratorOptions::SetWKSize(unsigned int size); unsigned intROOT::Math::BaseIntegratorOptions::WKSize() const. protected:. voidROOT::Math::BaseIntegratorOptions::ClearExtra(). Data Members; protected:. doubleROOT::Math::BaseIntegratorOptions::fAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*ROOT::Math::BaseIntegratorOptions::fExtraOptionsextra options ; intROOT::Math::BaseIntegratorOptions::fIntegTypeIntegrator type (value converted from enum); unsigned intROOT::Math::BaseIntegratorOptions::fNCalls(max) funxtion calls; doubleROOT::Math::BaseIntegratorOptions::fRelTolerancerelative tolerance ; unsigned intROOT::Math::BaseIntegratorOptions::fWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::IntegratorMultiDimOptions& rhs); assignment operators. std::string Integrator() const; name of 1D integrator. IntegrationOneDim::Type IntegratorType() const; type of the integrator (return the enumeration type). { return (IntegrationOneDim::Type) fIntegType; }. void SetIntegrator(const char* name); set 1D integrator name. void Print(ostream& os = std::cout) const; print all the options. void SetDefaultIntegrator(const char* name); static methods for setting and retrieving the default options. void SetDefaultAbsTolerance(double tol). void SetDefaultRelTolerance(double tol). void SetDefaultWKSize(unsigned int size). std::string DefaultIntegrator(). IntegrationOneDim::Type DefaultIntegratorType(). double DefaultAbsTolerance(). double DefaultRelTolerance(). unsigned int DefaultWKSize(). ROOT::Math::IOptions & Default(const char* name); retrieve specific options - if not existing create a IOptions. ROOT::Math::IOptions * FindDefault(const char* name); find specific options - return 0 if not existing. void PrintDefault(const char* name = 0, ostream& os = std::cout); print",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDimOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDimOptions.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDimOptions.html:3297,Integrability,integrat,integrator,3297,"voidROOT::Math::BaseIntegratorOptions::SetWKSize(unsigned int size); unsigned intROOT::Math::BaseIntegratorOptions::WKSize() const. protected:. voidROOT::Math::BaseIntegratorOptions::ClearExtra(). Data Members; protected:. doubleROOT::Math::BaseIntegratorOptions::fAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*ROOT::Math::BaseIntegratorOptions::fExtraOptionsextra options ; intROOT::Math::BaseIntegratorOptions::fIntegTypeIntegrator type (value converted from enum); unsigned intROOT::Math::BaseIntegratorOptions::fNCalls(max) funxtion calls; doubleROOT::Math::BaseIntegratorOptions::fRelTolerancerelative tolerance ; unsigned intROOT::Math::BaseIntegratorOptions::fWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::IntegratorMultiDimOptions& rhs); assignment operators. std::string Integrator() const; name of 1D integrator. IntegrationOneDim::Type IntegratorType() const; type of the integrator (return the enumeration type). { return (IntegrationOneDim::Type) fIntegType; }. void SetIntegrator(const char* name); set 1D integrator name. void Print(ostream& os = std::cout) const; print all the options. void SetDefaultIntegrator(const char* name); static methods for setting and retrieving the default options. void SetDefaultAbsTolerance(double tol). void SetDefaultRelTolerance(double tol). void SetDefaultWKSize(unsigned int size). std::string DefaultIntegrator(). IntegrationOneDim::Type DefaultIntegratorType(). double DefaultAbsTolerance(). double DefaultRelTolerance(). unsigned int DefaultWKSize(). ROOT::Math::IOptions & Default(const char* name); retrieve specific options - if not existing create a IOptions. ROOT::Math::IOptions * FindDefault(const char* name); find specific options - return 0 if not existing. void PrintDefault(const char* name = 0, ostream& os = std::cout); print only the specified default options. IntegratorMultiDimOptions(IOptions * extr",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDimOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDimOptions.html
https://root.cern/root/html534/ROOT__Math__IntegratorMultiDimOptions.html:3434,Integrability,integrat,integrator,3434,"protected:. voidROOT::Math::BaseIntegratorOptions::ClearExtra(). Data Members; protected:. doubleROOT::Math::BaseIntegratorOptions::fAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*ROOT::Math::BaseIntegratorOptions::fExtraOptionsextra options ; intROOT::Math::BaseIntegratorOptions::fIntegTypeIntegrator type (value converted from enum); unsigned intROOT::Math::BaseIntegratorOptions::fNCalls(max) funxtion calls; doubleROOT::Math::BaseIntegratorOptions::fRelTolerancerelative tolerance ; unsigned intROOT::Math::BaseIntegratorOptions::fWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::IntegratorMultiDimOptions& rhs); assignment operators. std::string Integrator() const; name of 1D integrator. IntegrationOneDim::Type IntegratorType() const; type of the integrator (return the enumeration type). { return (IntegrationOneDim::Type) fIntegType; }. void SetIntegrator(const char* name); set 1D integrator name. void Print(ostream& os = std::cout) const; print all the options. void SetDefaultIntegrator(const char* name); static methods for setting and retrieving the default options. void SetDefaultAbsTolerance(double tol). void SetDefaultRelTolerance(double tol). void SetDefaultWKSize(unsigned int size). std::string DefaultIntegrator(). IntegrationOneDim::Type DefaultIntegratorType(). double DefaultAbsTolerance(). double DefaultRelTolerance(). unsigned int DefaultWKSize(). ROOT::Math::IOptions & Default(const char* name); retrieve specific options - if not existing create a IOptions. ROOT::Math::IOptions * FindDefault(const char* name); find specific options - return 0 if not existing. void PrintDefault(const char* name = 0, ostream& os = std::cout); print only the specified default options. IntegratorMultiDimOptions(IOptions * extraOpts = 0); constructor using the default options; can pass a pointer to extra options (N.B. pointer will be managed by the class). ",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorMultiDimOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorMultiDimOptions.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:345,Deployability,integrat,integration,345,". ROOT::Math::IntegratorOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IntegratorOneDim. class ROOT::Math::IntegratorOneDim. User Class for performing numerical integration of a function in one dimension.; It uses the plug-in manager to load advanced numerical integration algorithms from GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. @ingroup Integration. This class is also known as (typedefs to this class)ROOT::Math::Integrator. Function Members (Methods); public:. virtual~IntegratorOneDim(); doubleError() const; ROOT::Math::VirtualIntegratorOneDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationOneDim::Type); static ROOT::Ma",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:445,Deployability,integrat,integration,445,". ROOT::Math::IntegratorOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IntegratorOneDim. class ROOT::Math::IntegratorOneDim. User Class for performing numerical integration of a function in one dimension.; It uses the plug-in manager to load advanced numerical integration algorithms from GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. @ingroup Integration. This class is also known as (typedefs to this class)ROOT::Math::Integrator. Function Members (Methods); public:. virtual~IntegratorOneDim(); doubleError() const; ROOT::Math::VirtualIntegratorOneDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationOneDim::Type); static ROOT::Ma",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:547,Deployability,integrat,integration,547,". ROOT::Math::IntegratorOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IntegratorOneDim. class ROOT::Math::IntegratorOneDim. User Class for performing numerical integration of a function in one dimension.; It uses the plug-in manager to load advanced numerical integration algorithms from GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. @ingroup Integration. This class is also known as (typedefs to this class)ROOT::Math::Integrator. Function Members (Methods); public:. virtual~IntegratorOneDim(); doubleError() const; ROOT::Math::VirtualIntegratorOneDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationOneDim::Type); static ROOT::Ma",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:630,Deployability,integrat,integration,630,". ROOT::Math::IntegratorOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IntegratorOneDim. class ROOT::Math::IntegratorOneDim. User Class for performing numerical integration of a function in one dimension.; It uses the plug-in manager to load advanced numerical integration algorithms from GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. @ingroup Integration. This class is also known as (typedefs to this class)ROOT::Math::Integrator. Function Members (Methods); public:. virtual~IntegratorOneDim(); doubleError() const; ROOT::Math::VirtualIntegratorOneDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationOneDim::Type); static ROOT::Ma",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:672,Deployability,integrat,integration,672,". ROOT::Math::IntegratorOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IntegratorOneDim. class ROOT::Math::IntegratorOneDim. User Class for performing numerical integration of a function in one dimension.; It uses the plug-in manager to load advanced numerical integration algorithms from GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. @ingroup Integration. This class is also known as (typedefs to this class)ROOT::Math::Integrator. Function Members (Methods); public:. virtual~IntegratorOneDim(); doubleError() const; ROOT::Math::VirtualIntegratorOneDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationOneDim::Type); static ROOT::Ma",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:751,Deployability,integrat,integration,751,". ROOT::Math::IntegratorOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IntegratorOneDim. class ROOT::Math::IntegratorOneDim. User Class for performing numerical integration of a function in one dimension.; It uses the plug-in manager to load advanced numerical integration algorithms from GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. @ingroup Integration. This class is also known as (typedefs to this class)ROOT::Math::Integrator. Function Members (Methods); public:. virtual~IntegratorOneDim(); doubleError() const; ROOT::Math::VirtualIntegratorOneDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationOneDim::Type); static ROOT::Ma",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:877,Deployability,integrat,integration,877,". ROOT::Math::IntegratorOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IntegratorOneDim. class ROOT::Math::IntegratorOneDim. User Class for performing numerical integration of a function in one dimension.; It uses the plug-in manager to load advanced numerical integration algorithms from GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. @ingroup Integration. This class is also known as (typedefs to this class)ROOT::Math::Integrator. Function Members (Methods); public:. virtual~IntegratorOneDim(); doubleError() const; ROOT::Math::VirtualIntegratorOneDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationOneDim::Type); static ROOT::Ma",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:995,Deployability,integrat,integration,995,". ROOT::Math::IntegratorOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IntegratorOneDim. class ROOT::Math::IntegratorOneDim. User Class for performing numerical integration of a function in one dimension.; It uses the plug-in manager to load advanced numerical integration algorithms from GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. @ingroup Integration. This class is also known as (typedefs to this class)ROOT::Math::Integrator. Function Members (Methods); public:. virtual~IntegratorOneDim(); doubleError() const; ROOT::Math::VirtualIntegratorOneDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationOneDim::Type); static ROOT::Ma",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:1048,Deployability,integrat,integration,1048,"ss Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IntegratorOneDim. class ROOT::Math::IntegratorOneDim. User Class for performing numerical integration of a function in one dimension.; It uses the plug-in manager to load advanced numerical integration algorithms from GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. @ingroup Integration. This class is also known as (typedefs to this class)ROOT::Math::Integrator. Function Members (Methods); public:. virtual~IntegratorOneDim(); doubleError() const; ROOT::Math::VirtualIntegratorOneDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationOneDim::Type); static ROOT::Math::IntegrationOneDim::TypeGetType(const char* name); doubleInt",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:1163,Deployability,integrat,integration,1163,"HCORE;  ROOT::Math::IntegratorOneDim. class ROOT::Math::IntegratorOneDim. User Class for performing numerical integration of a function in one dimension.; It uses the plug-in manager to load advanced numerical integration algorithms from GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. @ingroup Integration. This class is also known as (typedefs to this class)ROOT::Math::Integrator. Function Members (Methods); public:. virtual~IntegratorOneDim(); doubleError() const; ROOT::Math::VirtualIntegratorOneDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationOneDim::Type); static ROOT::Math::IntegrationOneDim::TypeGetType(const char* name); doubleIntegral(); doubleIntegral(const ROOT::Math::IGenFunction& f); doubleIntegral(const vector<double>& pts); doubleIntegral(const ROOT::Math::IGenFunction& f, const vector<doub",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:1570,Deployability,integrat,integration,1570,"ortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. @ingroup Integration. This class is also known as (typedefs to this class)ROOT::Math::Integrator. Function Members (Methods); public:. virtual~IntegratorOneDim(); doubleError() const; ROOT::Math::VirtualIntegratorOneDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationOneDim::Type); static ROOT::Math::IntegrationOneDim::TypeGetType(const char* name); doubleIntegral(); doubleIntegral(const ROOT::Math::IGenFunction& f); doubleIntegral(const vector<double>& pts); doubleIntegral(const ROOT::Math::IGenFunction& f, const vector<double>& pts); doubleIntegral(double a, double b); doubleIntegral(const ROOT::Math::IGenFunction& f, double a, double b); doubleIntegralCauchy(double a, double b, double c); doubleIntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c); doubleIntegralLow(double b); doubleIntegralLow(const ROOT::Math::IGenFunction& f, double ",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:4070,Deployability,integrat,integrator,4070,"::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0); stringName() const; intNEval() const; doubleoperator()(double x); ROOT::Math::IntegratorOneDimOptionsOptions() const; doubleResult() const; voidSetAbsTolerance(double absTolerance); voidSetFunction(const ROOT::Math::IGenFunction& f, bool copy = false); voidSetFunction(const ROOT::Math::IMultiGenFunction& f, unsigned int icoord, const double* x); voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); voidSetRelTolerance(double relTolerance); intStatus() const. protected:. ROOT::Math::VirtualIntegratorOneDim*CreateIntegrator(ROOT::Math::IntegrationOneDim::Type type, double absTol, double relTol, unsigned int size, int rule). private:. ROOT::Math::IntegratorOneDimIntegratorOneDim(const ROOT::Math::IntegratorOneDim&); ROOT::Math::IntegratorOneDim&operator=(const ROOT::Math::IntegratorOneDim&). Data Members; private:. auto_ptr<ROOT::Math::IBaseFunctionOneDim>fFuncpointer to owned function; ROOT::Math::VirtualIntegratorOneDim*fIntegratorpointer to integrator interface class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetFunction( Function & f). double Integral(const ROOT::Math::IGenFunction& f, double a, double b). double Integral(double a, double b). double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). IntegratorOneDim(ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, unsigned int rule = 0); constructors. Constructor of one dimensional Integrator, default type is adaptive. @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL kADAPTIVE type). Possible type values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPT",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:4688,Deployability,integrat,integration,4688,"le relTol, unsigned int size, int rule). private:. ROOT::Math::IntegratorOneDimIntegratorOneDim(const ROOT::Math::IntegratorOneDim&); ROOT::Math::IntegratorOneDim&operator=(const ROOT::Math::IntegratorOneDim&). Data Members; private:. auto_ptr<ROOT::Math::IBaseFunctionOneDim>fFuncpointer to owned function; ROOT::Math::VirtualIntegratorOneDim*fIntegratorpointer to integrator interface class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetFunction( Function & f). double Integral(const ROOT::Math::IGenFunction& f, double a, double b). double Integral(double a, double b). double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). IntegratorOneDim(ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, unsigned int rule = 0); constructors. Constructor of one dimensional Integrator, default type is adaptive. @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL kADAPTIVE type). Possible type values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPTIVESINGULAR (from GSL), kNONADAPTIVE (from GSL); Possible rule values are kGAUS15 (rule = 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6); lower rules are indicated for singular functions while higher for smooth functions to get better accuracies. NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Constructor of one dimensional Integrator passing a functi",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:4885,Deployability,integrat,integration,4885,"m&); ROOT::Math::IntegratorOneDim&operator=(const ROOT::Math::IntegratorOneDim&). Data Members; private:. auto_ptr<ROOT::Math::IBaseFunctionOneDim>fFuncpointer to owned function; ROOT::Math::VirtualIntegratorOneDim*fIntegratorpointer to integrator interface class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetFunction( Function & f). double Integral(const ROOT::Math::IGenFunction& f, double a, double b). double Integral(double a, double b). double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). IntegratorOneDim(ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, unsigned int rule = 0); constructors. Constructor of one dimensional Integrator, default type is adaptive. @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL kADAPTIVE type). Possible type values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPTIVESINGULAR (from GSL), kNONADAPTIVE (from GSL); Possible rule values are kGAUS15 (rule = 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6); lower rules are indicated for singular functions while higher for smooth functions to get better accuracies. NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Constructor of one dimensional Integrator passing a function interface. @param f integration function (1D interface). It is copied inside; @param type integration type (adaptive, non-adap",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:5728,Deployability,integrat,integration,5728,"ram absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL kADAPTIVE type). Possible type values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPTIVESINGULAR (from GSL), kNONADAPTIVE (from GSL); Possible rule values are kGAUS15 (rule = 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6); lower rules are indicated for singular functions while higher for smooth functions to get better accuracies. NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Constructor of one dimensional Integrator passing a function interface. @param f integration function (1D interface). It is copied inside; @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. SetFunction(const ROOT::Math::IGenFunction& f, bool copy = false). IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Template Constructor of one dimensional Integrator passing a generic function object. @param f integration function (any C++ callable object implementing operator()(double x); @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired r",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:5798,Deployability,integrat,integration,5798,"ve Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL kADAPTIVE type). Possible type values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPTIVESINGULAR (from GSL), kNONADAPTIVE (from GSL); Possible rule values are kGAUS15 (rule = 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6); lower rules are indicated for singular functions while higher for smooth functions to get better accuracies. NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Constructor of one dimensional Integrator passing a function interface. @param f integration function (1D interface). It is copied inside; @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. SetFunction(const ROOT::Math::IGenFunction& f, bool copy = false). IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Template Constructor of one dimensional Integrator passing a generic function object. @param f integration function (any C++ callable object implementing operator()(double x); @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @pa",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:5995,Deployability,integrat,integration,5995,"ype values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPTIVESINGULAR (from GSL), kNONADAPTIVE (from GSL); Possible rule values are kGAUS15 (rule = 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6); lower rules are indicated for singular functions while higher for smooth functions to get better accuracies. NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Constructor of one dimensional Integrator passing a function interface. @param f integration function (1D interface). It is copied inside; @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. SetFunction(const ROOT::Math::IGenFunction& f, bool copy = false). IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Template Constructor of one dimensional Integrator passing a generic function object. @param f integration function (any C++ callable object implementing operator()(double x); @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). virtual ~IntegratorOneDim(); destructor (will delete contained pointe",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:6537,Deployability,integrat,integration,6537,"ol = 0, unsigned int size = 0, int rule = 0). Constructor of one dimensional Integrator passing a function interface. @param f integration function (1D interface). It is copied inside; @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. SetFunction(const ROOT::Math::IGenFunction& f, bool copy = false). IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Template Constructor of one dimensional Integrator passing a generic function object. @param f integration function (any C++ callable object implementing operator()(double x); @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). virtual ~IntegratorOneDim(); destructor (will delete contained pointer). IntegratorOneDim & operator=(const ROOT::Math::IntegratorOneDim& ); { return *this; }. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); integration methods using a function. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const ROOT::Math::IGenFunction& f, double a, double b). evaluate the Integral of a function f over the defined interval (a,b); @param f integration function.",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:6630,Deployability,integrat,integration,6630,"ol = 0, unsigned int size = 0, int rule = 0). Constructor of one dimensional Integrator passing a function interface. @param f integration function (1D interface). It is copied inside; @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. SetFunction(const ROOT::Math::IGenFunction& f, bool copy = false). IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Template Constructor of one dimensional Integrator passing a generic function object. @param f integration function (any C++ callable object implementing operator()(double x); @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). virtual ~IntegratorOneDim(); destructor (will delete contained pointer). IntegratorOneDim & operator=(const ROOT::Math::IntegratorOneDim& ); { return *this; }. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); integration methods using a function. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const ROOT::Math::IGenFunction& f, double a, double b). evaluate the Integral of a function f over the defined interval (a,b); @param f integration function.",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:6827,Deployability,integrat,integration,6827,"ed inside; @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. SetFunction(const ROOT::Math::IGenFunction& f, bool copy = false). IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Template Constructor of one dimensional Integrator passing a generic function object. @param f integration function (any C++ callable object implementing operator()(double x); @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). virtual ~IntegratorOneDim(); destructor (will delete contained pointer). IntegratorOneDim & operator=(const ROOT::Math::IntegratorOneDim& ); { return *this; }. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); integration methods using a function. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const ROOT::Math::IGenFunction& f, double a, double b). evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. re",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:7106,Deployability,integrat,integration,7106,"values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. SetFunction(const ROOT::Math::IGenFunction& f, bool copy = false). IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Template Constructor of one dimensional Integrator passing a generic function object. @param f integration function (any C++ callable object implementing operator()(double x); @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). virtual ~IntegratorOneDim(); destructor (will delete contained pointer). IntegratorOneDim & operator=(const ROOT::Math::IntegratorOneDim& ); { return *this; }. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); integration methods using a function. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const ROOT::Math::IGenFunction& f, double a, double b). evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. return Integral(const ROOT::Math::IGenFunction& f, const vector<double>& pts). double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x). tem",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:7224,Deployability,integrat,integration,7224,"OOT::Math::IGenFunction& f, bool copy = false). IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Template Constructor of one dimensional Integrator passing a generic function object. @param f integration function (any C++ callable object implementing operator()(double x); @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). virtual ~IntegratorOneDim(); destructor (will delete contained pointer). IntegratorOneDim & operator=(const ROOT::Math::IntegratorOneDim& ); { return *this; }. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); integration methods using a function. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const ROOT::Math::IGenFunction& f, double a, double b). evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. return Integral(const ROOT::Math::IGenFunction& f, const vector<double>& pts). double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x). template<class Function>; double Integral(const Function & f);. evaluate the Integral of a function f over th",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:7357,Deployability,integrat,integration,7357," IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Template Constructor of one dimensional Integrator passing a generic function object. @param f integration function (any C++ callable object implementing operator()(double x); @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). virtual ~IntegratorOneDim(); destructor (will delete contained pointer). IntegratorOneDim & operator=(const ROOT::Math::IntegratorOneDim& ); { return *this; }. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); integration methods using a function. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const ROOT::Math::IGenFunction& f, double a, double b). evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. return Integral(const ROOT::Math::IGenFunction& f, const vector<double>& pts). double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x). template<class Function>; double Integral(const Function & f);. evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double In",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:7407,Deployability,integrat,integration,7407," IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Template Constructor of one dimensional Integrator passing a generic function object. @param f integration function (any C++ callable object implementing operator()(double x); @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). virtual ~IntegratorOneDim(); destructor (will delete contained pointer). IntegratorOneDim & operator=(const ROOT::Math::IntegratorOneDim& ); { return *this; }. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); integration methods using a function. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const ROOT::Math::IGenFunction& f, double a, double b). evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. return Integral(const ROOT::Math::IGenFunction& f, const vector<double>& pts). double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x). template<class Function>; double Integral(const Function & f);. evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double In",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:7581,Deployability,integrat,integration,7581,"nction (any C++ callable object implementing operator()(double x); @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). virtual ~IntegratorOneDim(); destructor (will delete contained pointer). IntegratorOneDim & operator=(const ROOT::Math::IntegratorOneDim& ); { return *this; }. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); integration methods using a function. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const ROOT::Math::IGenFunction& f, double a, double b). evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. return Integral(const ROOT::Math::IGenFunction& f, const vector<double>& pts). double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x). template<class Function>; double Integral(const Function & f);. evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must be a C++ callable object ",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:7701,Deployability,integrat,integration,7701,"absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). virtual ~IntegratorOneDim(); destructor (will delete contained pointer). IntegratorOneDim & operator=(const ROOT::Math::IntegratorOneDim& ); { return *this; }. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); integration methods using a function. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const ROOT::Math::IGenFunction& f, double a, double b). evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. return Integral(const ROOT::Math::IGenFunction& f, const vector<double>& pts). double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x). template<class Function>; double Integral(const Function & f);. evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval. template<class Function>; double IntegralUp(Functio",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:7751,Deployability,integrat,integration,7751,"absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). virtual ~IntegratorOneDim(); destructor (will delete contained pointer). IntegratorOneDim & operator=(const ROOT::Math::IntegratorOneDim& ); { return *this; }. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); integration methods using a function. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const ROOT::Math::IGenFunction& f, double a, double b). evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. return Integral(const ROOT::Math::IGenFunction& f, const vector<double>& pts). double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x). template<class Function>; double Integral(const Function & f);. evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval. template<class Function>; double IntegralUp(Functio",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:7980,Deployability,integrat,integration,7980," IntegratorOneDim & operator=(const ROOT::Math::IntegratorOneDim& ); { return *this; }. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); integration methods using a function. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const ROOT::Math::IGenFunction& f, double a, double b). evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. return Integral(const ROOT::Math::IGenFunction& f, const vector<double>& pts). double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x). template<class Function>; double Integral(const Function & f);. evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval. template<class Function>; double IntegralUp(Function & f, double a);. evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. return Int",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:8236,Deployability,integrat,integration,8236,"erval (a,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const ROOT::Math::IGenFunction& f, double a, double b). evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. return Integral(const ROOT::Math::IGenFunction& f, const vector<double>& pts). double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x). template<class Function>; double Integral(const Function & f);. evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval. template<class Function>; double IntegralUp(Function & f, double a);. evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. return IntegralUp(double a). double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must be a C++ callable object impl",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:8481,Deployability,integrat,integration,8481,"onst ROOT::Math::IGenFunction& f, double a, double b). evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. return Integral(const ROOT::Math::IGenFunction& f, const vector<double>& pts). double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x). template<class Function>; double Integral(const Function & f);. evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval. template<class Function>; double IntegralUp(Function & f, double a);. evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. return IntegralUp(double a). double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param b upper value of the integration interval. template<class Function>; double IntegralLow(Function & f, double b);. evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @pa",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:8614,Deployability,integrat,integration,8614,"b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. return Integral(const ROOT::Math::IGenFunction& f, const vector<double>& pts). double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x). template<class Function>; double Integral(const Function & f);. evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval. template<class Function>; double IntegralUp(Function & f, double a);. evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. return IntegralUp(double a). double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param b upper value of the integration interval. template<class Function>; double IntegralLow(Function & f, double b);. evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of ",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:8795,Deployability,integrat,integration,8795,"on interval. return Integral(const ROOT::Math::IGenFunction& f, const vector<double>& pts). double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x). template<class Function>; double Integral(const Function & f);. evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval. template<class Function>; double IntegralUp(Function & f, double a);. evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. return IntegralUp(double a). double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param b upper value of the integration interval. template<class Function>; double IntegralLow(Function & f, double b);. evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. return IntegralLow(double b). double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integ",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:8915,Deployability,integrat,integration,8915,"enFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x). template<class Function>; double Integral(const Function & f);. evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval. template<class Function>; double IntegralUp(Function & f, double a);. evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. return IntegralUp(double a). double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param b upper value of the integration interval. template<class Function>; double IntegralLow(Function & f, double b);. evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. return IntegralLow(double b). double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b) with a singularity at c; @param f integration function. The fun",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:9129,Deployability,integrat,integration,9129,"ate<class Function>; double Integral(const Function & f);. evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval. template<class Function>; double IntegralUp(Function & f, double a);. evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. return IntegralUp(double a). double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param b upper value of the integration interval. template<class Function>; double IntegralLow(Function & f, double b);. evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. return IntegralLow(double b). double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b) with a singularity at c; @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval; @param c position of singularity. doub",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:9262,Deployability,integrat,integration,9262,"inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval. template<class Function>; double IntegralUp(Function & f, double a);. evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. return IntegralUp(double a). double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param b upper value of the integration interval. template<class Function>; double IntegralLow(Function & f, double b);. evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. return IntegralLow(double b). double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b) with a singularity at c; @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval; @param c position of singularity. double operator()(double x). define operator() for IntegralLow. double Result() const. return the Result of the last Integral calcu",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:9453,Deployability,integrat,integration,9453,"of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval. template<class Function>; double IntegralUp(Function & f, double a);. evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. return IntegralUp(double a). double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param b upper value of the integration interval. template<class Function>; double IntegralLow(Function & f, double b);. evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. return IntegralLow(double b). double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b) with a singularity at c; @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval; @param c position of singularity. double operator()(double x). define operator() for IntegralLow. double Result() const. return the Result of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Result(); }. double Error() const. return the estimate of the absolute Error of the last Integral calculation. { return fIntegrator == 0 ? 0 : f",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:9573,Deployability,integrat,integration,9573," callable object implementing operator()(double x); @param a lower value of the integration interval. template<class Function>; double IntegralUp(Function & f, double a);. evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. return IntegralUp(double a). double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param b upper value of the integration interval. template<class Function>; double IntegralLow(Function & f, double b);. evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. return IntegralLow(double b). double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b) with a singularity at c; @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval; @param c position of singularity. double operator()(double x). define operator() for IntegralLow. double Result() const. return the Result of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Result(); }. double Error() const. return the estimate of the absolute Error of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Error(); }. int Status() const. return the Error Status of the last Integral calculation. { return fIntegrat",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:9847,Deployability,integrat,integration,9847,"am f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. return IntegralUp(double a). double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param b upper value of the integration interval. template<class Function>; double IntegralLow(Function & f, double b);. evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. return IntegralLow(double b). double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b) with a singularity at c; @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval; @param c position of singularity. double operator()(double x). define operator() for IntegralLow. double Result() const. return the Result of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Result(); }. double Error() const. return the estimate of the absolute Error of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Error(); }. int Status() const. return the Error Status of the last Integral calculation. { return fIntegrator == 0 ? -1 : fIntegrator->Status(); }. int NEval() const. return number of function evaluations in calculating the integral; (if integrator do not implement this function returns -1). { return fIntegrator == 0 ? -1 : fIntegrator->NEval(); }. void SetRelT",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:9980,Deployability,integrat,integration,9980,"egralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param b upper value of the integration interval. template<class Function>; double IntegralLow(Function & f, double b);. evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. return IntegralLow(double b). double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b) with a singularity at c; @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval; @param c position of singularity. double operator()(double x). define operator() for IntegralLow. double Result() const. return the Result of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Result(); }. double Error() const. return the estimate of the absolute Error of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Error(); }. int Status() const. return the Error Status of the last Integral calculation. { return fIntegrator == 0 ? -1 : fIntegrator->Status(); }. int NEval() const. return number of function evaluations in calculating the integral; (if integrator do not implement this function returns -1). { return fIntegrator == 0 ? -1 : fIntegrator->NEval(); }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. { if (fIntegrator) fIntegrator->SetRelTolerance(relTolerance",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:10030,Deployability,integrat,integration,10030,"egralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param b upper value of the integration interval. template<class Function>; double IntegralLow(Function & f, double b);. evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. return IntegralLow(double b). double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b) with a singularity at c; @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval; @param c position of singularity. double operator()(double x). define operator() for IntegralLow. double Result() const. return the Result of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Result(); }. double Error() const. return the estimate of the absolute Error of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Error(); }. int Status() const. return the Error Status of the last Integral calculation. { return fIntegrator == 0 ? -1 : fIntegrator->Status(); }. int NEval() const. return number of function evaluations in calculating the integral; (if integrator do not implement this function returns -1). { return fIntegrator == 0 ? -1 : fIntegrator->NEval(); }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. { if (fIntegrator) fIntegrator->SetRelTolerance(relTolerance",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:10665,Deployability,integrat,integrator,10665,"T::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b) with a singularity at c; @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval; @param c position of singularity. double operator()(double x). define operator() for IntegralLow. double Result() const. return the Result of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Result(); }. double Error() const. return the estimate of the absolute Error of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Error(); }. int Status() const. return the Error Status of the last Integral calculation. { return fIntegrator == 0 ? -1 : fIntegrator->Status(); }. int NEval() const. return number of function evaluations in calculating the integral; (if integrator do not implement this function returns -1). { return fIntegrator == 0 ? -1 : fIntegrator->NEval(); }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. { if (fIntegrator) fIntegrator->SetRelTolerance(relTolerance); }. void SetAbsTolerance(double absTolerance). set the desired absolute Error. { if (fIntegrator) fIntegrator->SetAbsTolerance(absTolerance); }. VirtualIntegratorOneDim * GetIntegrator(). return a pointer to integrator object. { return fIntegrator; }. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt). set the options. { if (fIntegrator) fIntegrator->SetOptions(opt); }. std::string Name() const; return name of integrator. { return (fIntegrator) ? Options().Integrator() : std::string(""""); }. IntegrationOneDim::Type GetType(const char* name); static function to get the enumeration from a string. std::string GetName(ROOT::Math::IntegrationOneDim::Type ); stat",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:11187,Deployability,integrat,integrator,11187,"ularity. double operator()(double x). define operator() for IntegralLow. double Result() const. return the Result of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Result(); }. double Error() const. return the estimate of the absolute Error of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Error(); }. int Status() const. return the Error Status of the last Integral calculation. { return fIntegrator == 0 ? -1 : fIntegrator->Status(); }. int NEval() const. return number of function evaluations in calculating the integral; (if integrator do not implement this function returns -1). { return fIntegrator == 0 ? -1 : fIntegrator->NEval(); }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. { if (fIntegrator) fIntegrator->SetRelTolerance(relTolerance); }. void SetAbsTolerance(double absTolerance). set the desired absolute Error. { if (fIntegrator) fIntegrator->SetAbsTolerance(absTolerance); }. VirtualIntegratorOneDim * GetIntegrator(). return a pointer to integrator object. { return fIntegrator; }. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt). set the options. { if (fIntegrator) fIntegrator->SetOptions(opt); }. std::string Name() const; return name of integrator. { return (fIntegrator) ? Options().Integrator() : std::string(""""); }. IntegrationOneDim::Type GetType(const char* name); static function to get the enumeration from a string. std::string GetName(ROOT::Math::IntegrationOneDim::Type ); static function to get a string from the enumeration. VirtualIntegratorOneDim * CreateIntegrator(ROOT::Math::IntegrationOneDim::Type type, double absTol, double relTol, unsigned int size, int rule).  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:11406,Deployability,integrat,integrator,11406,"ularity. double operator()(double x). define operator() for IntegralLow. double Result() const. return the Result of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Result(); }. double Error() const. return the estimate of the absolute Error of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Error(); }. int Status() const. return the Error Status of the last Integral calculation. { return fIntegrator == 0 ? -1 : fIntegrator->Status(); }. int NEval() const. return number of function evaluations in calculating the integral; (if integrator do not implement this function returns -1). { return fIntegrator == 0 ? -1 : fIntegrator->NEval(); }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. { if (fIntegrator) fIntegrator->SetRelTolerance(relTolerance); }. void SetAbsTolerance(double absTolerance). set the desired absolute Error. { if (fIntegrator) fIntegrator->SetAbsTolerance(absTolerance); }. VirtualIntegratorOneDim * GetIntegrator(). return a pointer to integrator object. { return fIntegrator; }. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt). set the options. { if (fIntegrator) fIntegrator->SetOptions(opt); }. std::string Name() const; return name of integrator. { return (fIntegrator) ? Options().Integrator() : std::string(""""); }. IntegrationOneDim::Type GetType(const char* name); static function to get the enumeration from a string. std::string GetName(ROOT::Math::IntegrationOneDim::Type ); static function to get a string from the enumeration. VirtualIntegratorOneDim * CreateIntegrator(ROOT::Math::IntegrationOneDim::Type type, double absTol, double relTol, unsigned int size, int rule).  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:604,Energy Efficiency,adapt,adaptive,604,". ROOT::Math::IntegratorOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IntegratorOneDim. class ROOT::Math::IntegratorOneDim. User Class for performing numerical integration of a function in one dimension.; It uses the plug-in manager to load advanced numerical integration algorithms from GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. @ingroup Integration. This class is also known as (typedefs to this class)ROOT::Math::Integrator. Function Members (Methods); public:. virtual~IntegratorOneDim(); doubleError() const; ROOT::Math::VirtualIntegratorOneDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationOneDim::Type); static ROOT::Ma",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:621,Energy Efficiency,adapt,adaptive,621,". ROOT::Math::IntegratorOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IntegratorOneDim. class ROOT::Math::IntegratorOneDim. User Class for performing numerical integration of a function in one dimension.; It uses the plug-in manager to load advanced numerical integration algorithms from GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. @ingroup Integration. This class is also known as (typedefs to this class)ROOT::Math::Integrator. Function Members (Methods); public:. virtual~IntegratorOneDim(); doubleError() const; ROOT::Math::VirtualIntegratorOneDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationOneDim::Type); static ROOT::Ma",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:868,Energy Efficiency,adapt,adaptive,868,". ROOT::Math::IntegratorOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IntegratorOneDim. class ROOT::Math::IntegratorOneDim. User Class for performing numerical integration of a function in one dimension.; It uses the plug-in manager to load advanced numerical integration algorithms from GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. @ingroup Integration. This class is also known as (typedefs to this class)ROOT::Math::Integrator. Function Members (Methods); public:. virtual~IntegratorOneDim(); doubleError() const; ROOT::Math::VirtualIntegratorOneDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationOneDim::Type); static ROOT::Ma",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:4666,Energy Efficiency,adapt,adaptive,4666,"or(ROOT::Math::IntegrationOneDim::Type type, double absTol, double relTol, unsigned int size, int rule). private:. ROOT::Math::IntegratorOneDimIntegratorOneDim(const ROOT::Math::IntegratorOneDim&); ROOT::Math::IntegratorOneDim&operator=(const ROOT::Math::IntegratorOneDim&). Data Members; private:. auto_ptr<ROOT::Math::IBaseFunctionOneDim>fFuncpointer to owned function; ROOT::Math::VirtualIntegratorOneDim*fIntegratorpointer to integrator interface class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetFunction( Function & f). double Integral(const ROOT::Math::IGenFunction& f, double a, double b). double Integral(double a, double b). double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). IntegratorOneDim(ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, unsigned int rule = 0); constructors. Constructor of one dimensional Integrator, default type is adaptive. @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL kADAPTIVE type). Possible type values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPTIVESINGULAR (from GSL), kNONADAPTIVE (from GSL); Possible rule values are kGAUS15 (rule = 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6); lower rules are indicated for singular functions while higher for smooth functions to get better accuracies. NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule ",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:4706,Energy Efficiency,adapt,adaptive,4706,"le relTol, unsigned int size, int rule). private:. ROOT::Math::IntegratorOneDimIntegratorOneDim(const ROOT::Math::IntegratorOneDim&); ROOT::Math::IntegratorOneDim&operator=(const ROOT::Math::IntegratorOneDim&). Data Members; private:. auto_ptr<ROOT::Math::IBaseFunctionOneDim>fFuncpointer to owned function; ROOT::Math::VirtualIntegratorOneDim*fIntegratorpointer to integrator interface class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetFunction( Function & f). double Integral(const ROOT::Math::IGenFunction& f, double a, double b). double Integral(double a, double b). double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). IntegratorOneDim(ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, unsigned int rule = 0); constructors. Constructor of one dimensional Integrator, default type is adaptive. @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL kADAPTIVE type). Possible type values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPTIVESINGULAR (from GSL), kNONADAPTIVE (from GSL); Possible rule values are kGAUS15 (rule = 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6); lower rules are indicated for singular functions while higher for smooth functions to get better accuracies. NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Constructor of one dimensional Integrator passing a functi",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:4720,Energy Efficiency,adapt,adaptive,4720,"le relTol, unsigned int size, int rule). private:. ROOT::Math::IntegratorOneDimIntegratorOneDim(const ROOT::Math::IntegratorOneDim&); ROOT::Math::IntegratorOneDim&operator=(const ROOT::Math::IntegratorOneDim&). Data Members; private:. auto_ptr<ROOT::Math::IBaseFunctionOneDim>fFuncpointer to owned function; ROOT::Math::VirtualIntegratorOneDim*fIntegratorpointer to integrator interface class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetFunction( Function & f). double Integral(const ROOT::Math::IGenFunction& f, double a, double b). double Integral(double a, double b). double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). IntegratorOneDim(ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, unsigned int rule = 0); constructors. Constructor of one dimensional Integrator, default type is adaptive. @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL kADAPTIVE type). Possible type values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPTIVESINGULAR (from GSL), kNONADAPTIVE (from GSL); Possible rule values are kGAUS15 (rule = 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6); lower rules are indicated for singular functions while higher for smooth functions to get better accuracies. NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Constructor of one dimensional Integrator passing a functi",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:5816,Energy Efficiency,adapt,adaptive,5816,"ve Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL kADAPTIVE type). Possible type values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPTIVESINGULAR (from GSL), kNONADAPTIVE (from GSL); Possible rule values are kGAUS15 (rule = 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6); lower rules are indicated for singular functions while higher for smooth functions to get better accuracies. NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Constructor of one dimensional Integrator passing a function interface. @param f integration function (1D interface). It is copied inside; @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. SetFunction(const ROOT::Math::IGenFunction& f, bool copy = false). IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Template Constructor of one dimensional Integrator passing a generic function object. @param f integration function (any C++ callable object implementing operator()(double x); @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @pa",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:5830,Energy Efficiency,adapt,adaptive,5830,"ve Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL kADAPTIVE type). Possible type values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPTIVESINGULAR (from GSL), kNONADAPTIVE (from GSL); Possible rule values are kGAUS15 (rule = 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6); lower rules are indicated for singular functions while higher for smooth functions to get better accuracies. NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Constructor of one dimensional Integrator passing a function interface. @param f integration function (1D interface). It is copied inside; @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. SetFunction(const ROOT::Math::IGenFunction& f, bool copy = false). IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Template Constructor of one dimensional Integrator passing a generic function object. @param f integration function (any C++ callable object implementing operator()(double x); @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @pa",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:6648,Energy Efficiency,adapt,adaptive,6648,"ol = 0, unsigned int size = 0, int rule = 0). Constructor of one dimensional Integrator passing a function interface. @param f integration function (1D interface). It is copied inside; @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. SetFunction(const ROOT::Math::IGenFunction& f, bool copy = false). IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Template Constructor of one dimensional Integrator passing a generic function object. @param f integration function (any C++ callable object implementing operator()(double x); @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). virtual ~IntegratorOneDim(); destructor (will delete contained pointer). IntegratorOneDim & operator=(const ROOT::Math::IntegratorOneDim& ); { return *this; }. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); integration methods using a function. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const ROOT::Math::IGenFunction& f, double a, double b). evaluate the Integral of a function f over the defined interval (a,b); @param f integration function.",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:6662,Energy Efficiency,adapt,adaptive,6662,"ol = 0, unsigned int size = 0, int rule = 0). Constructor of one dimensional Integrator passing a function interface. @param f integration function (1D interface). It is copied inside; @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. SetFunction(const ROOT::Math::IGenFunction& f, bool copy = false). IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Template Constructor of one dimensional Integrator passing a generic function object. @param f integration function (any C++ callable object implementing operator()(double x); @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). virtual ~IntegratorOneDim(); destructor (will delete contained pointer). IntegratorOneDim & operator=(const ROOT::Math::IntegratorOneDim& ); { return *this; }. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); integration methods using a function. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const ROOT::Math::IGenFunction& f, double a, double b). evaluate the Integral of a function f over the defined interval (a,b); @param f integration function.",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:345,Integrability,integrat,integration,345,". ROOT::Math::IntegratorOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IntegratorOneDim. class ROOT::Math::IntegratorOneDim. User Class for performing numerical integration of a function in one dimension.; It uses the plug-in manager to load advanced numerical integration algorithms from GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. @ingroup Integration. This class is also known as (typedefs to this class)ROOT::Math::Integrator. Function Members (Methods); public:. virtual~IntegratorOneDim(); doubleError() const; ROOT::Math::VirtualIntegratorOneDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationOneDim::Type); static ROOT::Ma",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:445,Integrability,integrat,integration,445,". ROOT::Math::IntegratorOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IntegratorOneDim. class ROOT::Math::IntegratorOneDim. User Class for performing numerical integration of a function in one dimension.; It uses the plug-in manager to load advanced numerical integration algorithms from GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. @ingroup Integration. This class is also known as (typedefs to this class)ROOT::Math::Integrator. Function Members (Methods); public:. virtual~IntegratorOneDim(); doubleError() const; ROOT::Math::VirtualIntegratorOneDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationOneDim::Type); static ROOT::Ma",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:547,Integrability,integrat,integration,547,". ROOT::Math::IntegratorOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IntegratorOneDim. class ROOT::Math::IntegratorOneDim. User Class for performing numerical integration of a function in one dimension.; It uses the plug-in manager to load advanced numerical integration algorithms from GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. @ingroup Integration. This class is also known as (typedefs to this class)ROOT::Math::Integrator. Function Members (Methods); public:. virtual~IntegratorOneDim(); doubleError() const; ROOT::Math::VirtualIntegratorOneDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationOneDim::Type); static ROOT::Ma",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:630,Integrability,integrat,integration,630,". ROOT::Math::IntegratorOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IntegratorOneDim. class ROOT::Math::IntegratorOneDim. User Class for performing numerical integration of a function in one dimension.; It uses the plug-in manager to load advanced numerical integration algorithms from GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. @ingroup Integration. This class is also known as (typedefs to this class)ROOT::Math::Integrator. Function Members (Methods); public:. virtual~IntegratorOneDim(); doubleError() const; ROOT::Math::VirtualIntegratorOneDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationOneDim::Type); static ROOT::Ma",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:672,Integrability,integrat,integration,672,". ROOT::Math::IntegratorOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IntegratorOneDim. class ROOT::Math::IntegratorOneDim. User Class for performing numerical integration of a function in one dimension.; It uses the plug-in manager to load advanced numerical integration algorithms from GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. @ingroup Integration. This class is also known as (typedefs to this class)ROOT::Math::Integrator. Function Members (Methods); public:. virtual~IntegratorOneDim(); doubleError() const; ROOT::Math::VirtualIntegratorOneDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationOneDim::Type); static ROOT::Ma",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:751,Integrability,integrat,integration,751,". ROOT::Math::IntegratorOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IntegratorOneDim. class ROOT::Math::IntegratorOneDim. User Class for performing numerical integration of a function in one dimension.; It uses the plug-in manager to load advanced numerical integration algorithms from GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. @ingroup Integration. This class is also known as (typedefs to this class)ROOT::Math::Integrator. Function Members (Methods); public:. virtual~IntegratorOneDim(); doubleError() const; ROOT::Math::VirtualIntegratorOneDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationOneDim::Type); static ROOT::Ma",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:877,Integrability,integrat,integration,877,". ROOT::Math::IntegratorOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IntegratorOneDim. class ROOT::Math::IntegratorOneDim. User Class for performing numerical integration of a function in one dimension.; It uses the plug-in manager to load advanced numerical integration algorithms from GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. @ingroup Integration. This class is also known as (typedefs to this class)ROOT::Math::Integrator. Function Members (Methods); public:. virtual~IntegratorOneDim(); doubleError() const; ROOT::Math::VirtualIntegratorOneDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationOneDim::Type); static ROOT::Ma",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:995,Integrability,integrat,integration,995,". ROOT::Math::IntegratorOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IntegratorOneDim. class ROOT::Math::IntegratorOneDim. User Class for performing numerical integration of a function in one dimension.; It uses the plug-in manager to load advanced numerical integration algorithms from GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. @ingroup Integration. This class is also known as (typedefs to this class)ROOT::Math::Integrator. Function Members (Methods); public:. virtual~IntegratorOneDim(); doubleError() const; ROOT::Math::VirtualIntegratorOneDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationOneDim::Type); static ROOT::Ma",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:1048,Integrability,integrat,integration,1048,"ss Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IntegratorOneDim. class ROOT::Math::IntegratorOneDim. User Class for performing numerical integration of a function in one dimension.; It uses the plug-in manager to load advanced numerical integration algorithms from GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. @ingroup Integration. This class is also known as (typedefs to this class)ROOT::Math::Integrator. Function Members (Methods); public:. virtual~IntegratorOneDim(); doubleError() const; ROOT::Math::VirtualIntegratorOneDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationOneDim::Type); static ROOT::Math::IntegrationOneDim::TypeGetType(const char* name); doubleInt",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:1163,Integrability,integrat,integration,1163,"HCORE;  ROOT::Math::IntegratorOneDim. class ROOT::Math::IntegratorOneDim. User Class for performing numerical integration of a function in one dimension.; It uses the plug-in manager to load advanced numerical integration algorithms from GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. @ingroup Integration. This class is also known as (typedefs to this class)ROOT::Math::Integrator. Function Members (Methods); public:. virtual~IntegratorOneDim(); doubleError() const; ROOT::Math::VirtualIntegratorOneDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationOneDim::Type); static ROOT::Math::IntegrationOneDim::TypeGetType(const char* name); doubleIntegral(); doubleIntegral(const ROOT::Math::IGenFunction& f); doubleIntegral(const vector<double>& pts); doubleIntegral(const ROOT::Math::IGenFunction& f, const vector<doub",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:1570,Integrability,integrat,integration,1570,"ortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. @ingroup Integration. This class is also known as (typedefs to this class)ROOT::Math::Integrator. Function Members (Methods); public:. virtual~IntegratorOneDim(); doubleError() const; ROOT::Math::VirtualIntegratorOneDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationOneDim::Type); static ROOT::Math::IntegrationOneDim::TypeGetType(const char* name); doubleIntegral(); doubleIntegral(const ROOT::Math::IGenFunction& f); doubleIntegral(const vector<double>& pts); doubleIntegral(const ROOT::Math::IGenFunction& f, const vector<double>& pts); doubleIntegral(double a, double b); doubleIntegral(const ROOT::Math::IGenFunction& f, double a, double b); doubleIntegralCauchy(double a, double b, double c); doubleIntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c); doubleIntegralLow(double b); doubleIntegralLow(const ROOT::Math::IGenFunction& f, double ",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:4070,Integrability,integrat,integrator,4070,"::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0); stringName() const; intNEval() const; doubleoperator()(double x); ROOT::Math::IntegratorOneDimOptionsOptions() const; doubleResult() const; voidSetAbsTolerance(double absTolerance); voidSetFunction(const ROOT::Math::IGenFunction& f, bool copy = false); voidSetFunction(const ROOT::Math::IMultiGenFunction& f, unsigned int icoord, const double* x); voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); voidSetRelTolerance(double relTolerance); intStatus() const. protected:. ROOT::Math::VirtualIntegratorOneDim*CreateIntegrator(ROOT::Math::IntegrationOneDim::Type type, double absTol, double relTol, unsigned int size, int rule). private:. ROOT::Math::IntegratorOneDimIntegratorOneDim(const ROOT::Math::IntegratorOneDim&); ROOT::Math::IntegratorOneDim&operator=(const ROOT::Math::IntegratorOneDim&). Data Members; private:. auto_ptr<ROOT::Math::IBaseFunctionOneDim>fFuncpointer to owned function; ROOT::Math::VirtualIntegratorOneDim*fIntegratorpointer to integrator interface class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetFunction( Function & f). double Integral(const ROOT::Math::IGenFunction& f, double a, double b). double Integral(double a, double b). double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). IntegratorOneDim(ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, unsigned int rule = 0); constructors. Constructor of one dimensional Integrator, default type is adaptive. @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL kADAPTIVE type). Possible type values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPT",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:4081,Integrability,interface,interface,4081,"::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0); stringName() const; intNEval() const; doubleoperator()(double x); ROOT::Math::IntegratorOneDimOptionsOptions() const; doubleResult() const; voidSetAbsTolerance(double absTolerance); voidSetFunction(const ROOT::Math::IGenFunction& f, bool copy = false); voidSetFunction(const ROOT::Math::IMultiGenFunction& f, unsigned int icoord, const double* x); voidSetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); voidSetRelTolerance(double relTolerance); intStatus() const. protected:. ROOT::Math::VirtualIntegratorOneDim*CreateIntegrator(ROOT::Math::IntegrationOneDim::Type type, double absTol, double relTol, unsigned int size, int rule). private:. ROOT::Math::IntegratorOneDimIntegratorOneDim(const ROOT::Math::IntegratorOneDim&); ROOT::Math::IntegratorOneDim&operator=(const ROOT::Math::IntegratorOneDim&). Data Members; private:. auto_ptr<ROOT::Math::IBaseFunctionOneDim>fFuncpointer to owned function; ROOT::Math::VirtualIntegratorOneDim*fIntegratorpointer to integrator interface class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetFunction( Function & f). double Integral(const ROOT::Math::IGenFunction& f, double a, double b). double Integral(double a, double b). double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). IntegratorOneDim(ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, unsigned int rule = 0); constructors. Constructor of one dimensional Integrator, default type is adaptive. @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL kADAPTIVE type). Possible type values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPT",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:4688,Integrability,integrat,integration,4688,"le relTol, unsigned int size, int rule). private:. ROOT::Math::IntegratorOneDimIntegratorOneDim(const ROOT::Math::IntegratorOneDim&); ROOT::Math::IntegratorOneDim&operator=(const ROOT::Math::IntegratorOneDim&). Data Members; private:. auto_ptr<ROOT::Math::IBaseFunctionOneDim>fFuncpointer to owned function; ROOT::Math::VirtualIntegratorOneDim*fIntegratorpointer to integrator interface class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetFunction( Function & f). double Integral(const ROOT::Math::IGenFunction& f, double a, double b). double Integral(double a, double b). double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). IntegratorOneDim(ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, unsigned int rule = 0); constructors. Constructor of one dimensional Integrator, default type is adaptive. @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL kADAPTIVE type). Possible type values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPTIVESINGULAR (from GSL), kNONADAPTIVE (from GSL); Possible rule values are kGAUS15 (rule = 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6); lower rules are indicated for singular functions while higher for smooth functions to get better accuracies. NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Constructor of one dimensional Integrator passing a functi",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:4885,Integrability,integrat,integration,4885,"m&); ROOT::Math::IntegratorOneDim&operator=(const ROOT::Math::IntegratorOneDim&). Data Members; private:. auto_ptr<ROOT::Math::IBaseFunctionOneDim>fFuncpointer to owned function; ROOT::Math::VirtualIntegratorOneDim*fIntegratorpointer to integrator interface class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetFunction( Function & f). double Integral(const ROOT::Math::IGenFunction& f, double a, double b). double Integral(double a, double b). double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). IntegratorOneDim(ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, unsigned int rule = 0); constructors. Constructor of one dimensional Integrator, default type is adaptive. @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL kADAPTIVE type). Possible type values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPTIVESINGULAR (from GSL), kNONADAPTIVE (from GSL); Possible rule values are kGAUS15 (rule = 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6); lower rules are indicated for singular functions while higher for smooth functions to get better accuracies. NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Constructor of one dimensional Integrator passing a function interface. @param f integration function (1D interface). It is copied inside; @param type integration type (adaptive, non-adap",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:5708,Integrability,interface,interface,5708," type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL kADAPTIVE type). Possible type values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPTIVESINGULAR (from GSL), kNONADAPTIVE (from GSL); Possible rule values are kGAUS15 (rule = 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6); lower rules are indicated for singular functions while higher for smooth functions to get better accuracies. NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Constructor of one dimensional Integrator passing a function interface. @param f integration function (1D interface). It is copied inside; @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. SetFunction(const ROOT::Math::IGenFunction& f, bool copy = false). IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Template Constructor of one dimensional Integrator passing a generic function object. @param f integration function (any C++ callable object implementing operator()(double x); @param type integration type (adaptive, non-adaptive, etc..); @p",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:5728,Integrability,integrat,integration,5728,"ram absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL kADAPTIVE type). Possible type values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPTIVESINGULAR (from GSL), kNONADAPTIVE (from GSL); Possible rule values are kGAUS15 (rule = 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6); lower rules are indicated for singular functions while higher for smooth functions to get better accuracies. NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Constructor of one dimensional Integrator passing a function interface. @param f integration function (1D interface). It is copied inside; @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. SetFunction(const ROOT::Math::IGenFunction& f, bool copy = false). IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Template Constructor of one dimensional Integrator passing a generic function object. @param f integration function (any C++ callable object implementing operator()(double x); @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired r",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:5753,Integrability,interface,interface,5753,"ram absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL kADAPTIVE type). Possible type values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPTIVESINGULAR (from GSL), kNONADAPTIVE (from GSL); Possible rule values are kGAUS15 (rule = 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6); lower rules are indicated for singular functions while higher for smooth functions to get better accuracies. NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Constructor of one dimensional Integrator passing a function interface. @param f integration function (1D interface). It is copied inside; @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. SetFunction(const ROOT::Math::IGenFunction& f, bool copy = false). IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Template Constructor of one dimensional Integrator passing a generic function object. @param f integration function (any C++ callable object implementing operator()(double x); @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired r",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:5798,Integrability,integrat,integration,5798,"ve Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL kADAPTIVE type). Possible type values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPTIVESINGULAR (from GSL), kNONADAPTIVE (from GSL); Possible rule values are kGAUS15 (rule = 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6); lower rules are indicated for singular functions while higher for smooth functions to get better accuracies. NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Constructor of one dimensional Integrator passing a function interface. @param f integration function (1D interface). It is copied inside; @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. SetFunction(const ROOT::Math::IGenFunction& f, bool copy = false). IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Template Constructor of one dimensional Integrator passing a generic function object. @param f integration function (any C++ callable object implementing operator()(double x); @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @pa",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:5995,Integrability,integrat,integration,5995,"ype values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPTIVESINGULAR (from GSL), kNONADAPTIVE (from GSL); Possible rule values are kGAUS15 (rule = 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6); lower rules are indicated for singular functions while higher for smooth functions to get better accuracies. NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Constructor of one dimensional Integrator passing a function interface. @param f integration function (1D interface). It is copied inside; @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. SetFunction(const ROOT::Math::IGenFunction& f, bool copy = false). IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Template Constructor of one dimensional Integrator passing a generic function object. @param f integration function (any C++ callable object implementing operator()(double x); @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). virtual ~IntegratorOneDim(); destructor (will delete contained pointe",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:6537,Integrability,integrat,integration,6537,"ol = 0, unsigned int size = 0, int rule = 0). Constructor of one dimensional Integrator passing a function interface. @param f integration function (1D interface). It is copied inside; @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. SetFunction(const ROOT::Math::IGenFunction& f, bool copy = false). IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Template Constructor of one dimensional Integrator passing a generic function object. @param f integration function (any C++ callable object implementing operator()(double x); @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). virtual ~IntegratorOneDim(); destructor (will delete contained pointer). IntegratorOneDim & operator=(const ROOT::Math::IntegratorOneDim& ); { return *this; }. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); integration methods using a function. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const ROOT::Math::IGenFunction& f, double a, double b). evaluate the Integral of a function f over the defined interval (a,b); @param f integration function.",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:6630,Integrability,integrat,integration,6630,"ol = 0, unsigned int size = 0, int rule = 0). Constructor of one dimensional Integrator passing a function interface. @param f integration function (1D interface). It is copied inside; @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. SetFunction(const ROOT::Math::IGenFunction& f, bool copy = false). IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Template Constructor of one dimensional Integrator passing a generic function object. @param f integration function (any C++ callable object implementing operator()(double x); @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). virtual ~IntegratorOneDim(); destructor (will delete contained pointer). IntegratorOneDim & operator=(const ROOT::Math::IntegratorOneDim& ); { return *this; }. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); integration methods using a function. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const ROOT::Math::IGenFunction& f, double a, double b). evaluate the Integral of a function f over the defined interval (a,b); @param f integration function.",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:6827,Integrability,integrat,integration,6827,"ed inside; @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. SetFunction(const ROOT::Math::IGenFunction& f, bool copy = false). IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Template Constructor of one dimensional Integrator passing a generic function object. @param f integration function (any C++ callable object implementing operator()(double x); @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). virtual ~IntegratorOneDim(); destructor (will delete contained pointer). IntegratorOneDim & operator=(const ROOT::Math::IntegratorOneDim& ); { return *this; }. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); integration methods using a function. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const ROOT::Math::IGenFunction& f, double a, double b). evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. re",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:7106,Integrability,integrat,integration,7106,"values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. SetFunction(const ROOT::Math::IGenFunction& f, bool copy = false). IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Template Constructor of one dimensional Integrator passing a generic function object. @param f integration function (any C++ callable object implementing operator()(double x); @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). virtual ~IntegratorOneDim(); destructor (will delete contained pointer). IntegratorOneDim & operator=(const ROOT::Math::IntegratorOneDim& ); { return *this; }. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); integration methods using a function. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const ROOT::Math::IGenFunction& f, double a, double b). evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. return Integral(const ROOT::Math::IGenFunction& f, const vector<double>& pts). double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x). tem",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:7224,Integrability,integrat,integration,7224,"OOT::Math::IGenFunction& f, bool copy = false). IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Template Constructor of one dimensional Integrator passing a generic function object. @param f integration function (any C++ callable object implementing operator()(double x); @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). virtual ~IntegratorOneDim(); destructor (will delete contained pointer). IntegratorOneDim & operator=(const ROOT::Math::IntegratorOneDim& ); { return *this; }. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); integration methods using a function. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const ROOT::Math::IGenFunction& f, double a, double b). evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. return Integral(const ROOT::Math::IGenFunction& f, const vector<double>& pts). double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x). template<class Function>; double Integral(const Function & f);. evaluate the Integral of a function f over th",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:7357,Integrability,integrat,integration,7357," IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Template Constructor of one dimensional Integrator passing a generic function object. @param f integration function (any C++ callable object implementing operator()(double x); @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). virtual ~IntegratorOneDim(); destructor (will delete contained pointer). IntegratorOneDim & operator=(const ROOT::Math::IntegratorOneDim& ); { return *this; }. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); integration methods using a function. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const ROOT::Math::IGenFunction& f, double a, double b). evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. return Integral(const ROOT::Math::IGenFunction& f, const vector<double>& pts). double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x). template<class Function>; double Integral(const Function & f);. evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double In",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:7407,Integrability,integrat,integration,7407," IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Template Constructor of one dimensional Integrator passing a generic function object. @param f integration function (any C++ callable object implementing operator()(double x); @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). virtual ~IntegratorOneDim(); destructor (will delete contained pointer). IntegratorOneDim & operator=(const ROOT::Math::IntegratorOneDim& ); { return *this; }. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); integration methods using a function. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const ROOT::Math::IGenFunction& f, double a, double b). evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. return Integral(const ROOT::Math::IGenFunction& f, const vector<double>& pts). double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x). template<class Function>; double Integral(const Function & f);. evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double In",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:7581,Integrability,integrat,integration,7581,"nction (any C++ callable object implementing operator()(double x); @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). virtual ~IntegratorOneDim(); destructor (will delete contained pointer). IntegratorOneDim & operator=(const ROOT::Math::IntegratorOneDim& ); { return *this; }. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); integration methods using a function. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const ROOT::Math::IGenFunction& f, double a, double b). evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. return Integral(const ROOT::Math::IGenFunction& f, const vector<double>& pts). double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x). template<class Function>; double Integral(const Function & f);. evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must be a C++ callable object ",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:7662,Integrability,interface,interface,7662,"absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). virtual ~IntegratorOneDim(); destructor (will delete contained pointer). IntegratorOneDim & operator=(const ROOT::Math::IntegratorOneDim& ); { return *this; }. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); integration methods using a function. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const ROOT::Math::IGenFunction& f, double a, double b). evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. return Integral(const ROOT::Math::IGenFunction& f, const vector<double>& pts). double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x). template<class Function>; double Integral(const Function & f);. evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval. template<class Function>; double IntegralUp(Functio",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:7701,Integrability,integrat,integration,7701,"absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). virtual ~IntegratorOneDim(); destructor (will delete contained pointer). IntegratorOneDim & operator=(const ROOT::Math::IntegratorOneDim& ); { return *this; }. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); integration methods using a function. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const ROOT::Math::IGenFunction& f, double a, double b). evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. return Integral(const ROOT::Math::IGenFunction& f, const vector<double>& pts). double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x). template<class Function>; double Integral(const Function & f);. evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval. template<class Function>; double IntegralUp(Functio",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:7751,Integrability,integrat,integration,7751,"absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). virtual ~IntegratorOneDim(); destructor (will delete contained pointer). IntegratorOneDim & operator=(const ROOT::Math::IntegratorOneDim& ); { return *this; }. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); integration methods using a function. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const ROOT::Math::IGenFunction& f, double a, double b). evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. return Integral(const ROOT::Math::IGenFunction& f, const vector<double>& pts). double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x). template<class Function>; double Integral(const Function & f);. evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval. template<class Function>; double IntegralUp(Functio",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:7980,Integrability,integrat,integration,7980," IntegratorOneDim & operator=(const ROOT::Math::IntegratorOneDim& ); { return *this; }. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); integration methods using a function. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const ROOT::Math::IGenFunction& f, double a, double b). evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. return Integral(const ROOT::Math::IGenFunction& f, const vector<double>& pts). double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x). template<class Function>; double Integral(const Function & f);. evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval. template<class Function>; double IntegralUp(Function & f, double a);. evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. return Int",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:8236,Integrability,integrat,integration,8236,"erval (a,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const ROOT::Math::IGenFunction& f, double a, double b). evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. return Integral(const ROOT::Math::IGenFunction& f, const vector<double>& pts). double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x). template<class Function>; double Integral(const Function & f);. evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval. template<class Function>; double IntegralUp(Function & f, double a);. evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. return IntegralUp(double a). double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must be a C++ callable object impl",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:8317,Integrability,interface,interface,8317,"t implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const ROOT::Math::IGenFunction& f, double a, double b). evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. return Integral(const ROOT::Math::IGenFunction& f, const vector<double>& pts). double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x). template<class Function>; double Integral(const Function & f);. evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval. template<class Function>; double IntegralUp(Function & f, double a);. evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. return IntegralUp(double a). double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param b upper value of the integration interval. template",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:8481,Integrability,integrat,integration,8481,"onst ROOT::Math::IGenFunction& f, double a, double b). evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. return Integral(const ROOT::Math::IGenFunction& f, const vector<double>& pts). double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x). template<class Function>; double Integral(const Function & f);. evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval. template<class Function>; double IntegralUp(Function & f, double a);. evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. return IntegralUp(double a). double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param b upper value of the integration interval. template<class Function>; double IntegralLow(Function & f, double b);. evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @pa",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:8614,Integrability,integrat,integration,8614,"b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval; @param b upper value of the integration interval. return Integral(const ROOT::Math::IGenFunction& f, const vector<double>& pts). double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x). template<class Function>; double Integral(const Function & f);. evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval. template<class Function>; double IntegralUp(Function & f, double a);. evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. return IntegralUp(double a). double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param b upper value of the integration interval. template<class Function>; double IntegralLow(Function & f, double b);. evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of ",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:8795,Integrability,integrat,integration,8795,"on interval. return Integral(const ROOT::Math::IGenFunction& f, const vector<double>& pts). double Integral(const IGenFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x). template<class Function>; double Integral(const Function & f);. evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval. template<class Function>; double IntegralUp(Function & f, double a);. evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. return IntegralUp(double a). double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param b upper value of the integration interval. template<class Function>; double IntegralLow(Function & f, double b);. evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. return IntegralLow(double b). double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integ",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:8876,Integrability,interface,interface,8876,"enFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x). template<class Function>; double Integral(const Function & f);. evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval. template<class Function>; double IntegralUp(Function & f, double a);. evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. return IntegralUp(double a). double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param b upper value of the integration interval. template<class Function>; double IntegralLow(Function & f, double b);. evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. return IntegralLow(double b). double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b) with a singularity at c; @param f integration function. The fun",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:8915,Integrability,integrat,integration,8915,"enFunction & f). evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x). template<class Function>; double Integral(const Function & f);. evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval. template<class Function>; double IntegralUp(Function & f, double a);. evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. return IntegralUp(double a). double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param b upper value of the integration interval. template<class Function>; double IntegralLow(Function & f, double b);. evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. return IntegralLow(double b). double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b) with a singularity at c; @param f integration function. The fun",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:9129,Integrability,integrat,integration,9129,"ate<class Function>; double Integral(const Function & f);. evaluate the Integral of a function f over the infinite interval (-inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval. template<class Function>; double IntegralUp(Function & f, double a);. evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. return IntegralUp(double a). double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param b upper value of the integration interval. template<class Function>; double IntegralLow(Function & f, double b);. evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. return IntegralLow(double b). double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b) with a singularity at c; @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval; @param c position of singularity. doub",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:9262,Integrability,integrat,integration,9262,"inf,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface. double IntegralUp(const ROOT::Math::IGenFunction& f, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval. template<class Function>; double IntegralUp(Function & f, double a);. evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. return IntegralUp(double a). double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param b upper value of the integration interval. template<class Function>; double IntegralLow(Function & f, double b);. evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. return IntegralLow(double b). double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b) with a singularity at c; @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval; @param c position of singularity. double operator()(double x). define operator() for IntegralLow. double Result() const. return the Result of the last Integral calcu",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:9453,Integrability,integrat,integration,9453,"of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval. template<class Function>; double IntegralUp(Function & f, double a);. evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. return IntegralUp(double a). double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param b upper value of the integration interval. template<class Function>; double IntegralLow(Function & f, double b);. evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. return IntegralLow(double b). double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b) with a singularity at c; @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval; @param c position of singularity. double operator()(double x). define operator() for IntegralLow. double Result() const. return the Result of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Result(); }. double Error() const. return the estimate of the absolute Error of the last Integral calculation. { return fIntegrator == 0 ? 0 : f",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:9534,Integrability,interface,interface,9534," callable object implementing operator()(double x); @param a lower value of the integration interval. template<class Function>; double IntegralUp(Function & f, double a);. evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. return IntegralUp(double a). double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param b upper value of the integration interval. template<class Function>; double IntegralLow(Function & f, double b);. evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. return IntegralLow(double b). double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b) with a singularity at c; @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval; @param c position of singularity. double operator()(double x). define operator() for IntegralLow. double Result() const. return the Result of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Result(); }. double Error() const. return the estimate of the absolute Error of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Error(); }. int Status() const. return the Error Status of the last Integral calculation. { return fIntegrat",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:9573,Integrability,integrat,integration,9573," callable object implementing operator()(double x); @param a lower value of the integration interval. template<class Function>; double IntegralUp(Function & f, double a);. evaluate the Integral of a function f over the semi-infinite interval (a,+inf); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. return IntegralUp(double a). double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param b upper value of the integration interval. template<class Function>; double IntegralLow(Function & f, double b);. evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. return IntegralLow(double b). double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b) with a singularity at c; @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval; @param c position of singularity. double operator()(double x). define operator() for IntegralLow. double Result() const. return the Result of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Result(); }. double Error() const. return the estimate of the absolute Error of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Error(); }. int Status() const. return the Error Status of the last Integral calculation. { return fIntegrat",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:9847,Integrability,integrat,integration,9847,"am f integration function. The function type must implement the mathlib::IGenFunction interface; @param a lower value of the integration interval. return IntegralUp(double a). double IntegralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param b upper value of the integration interval. template<class Function>; double IntegralLow(Function & f, double b);. evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. return IntegralLow(double b). double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b) with a singularity at c; @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval; @param c position of singularity. double operator()(double x). define operator() for IntegralLow. double Result() const. return the Result of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Result(); }. double Error() const. return the estimate of the absolute Error of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Error(); }. int Status() const. return the Error Status of the last Integral calculation. { return fIntegrator == 0 ? -1 : fIntegrator->Status(); }. int NEval() const. return number of function evaluations in calculating the integral; (if integrator do not implement this function returns -1). { return fIntegrator == 0 ? -1 : fIntegrator->NEval(); }. void SetRelT",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:9980,Integrability,integrat,integration,9980,"egralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param b upper value of the integration interval. template<class Function>; double IntegralLow(Function & f, double b);. evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. return IntegralLow(double b). double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b) with a singularity at c; @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval; @param c position of singularity. double operator()(double x). define operator() for IntegralLow. double Result() const. return the Result of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Result(); }. double Error() const. return the estimate of the absolute Error of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Error(); }. int Status() const. return the Error Status of the last Integral calculation. { return fIntegrator == 0 ? -1 : fIntegrator->Status(); }. int NEval() const. return number of function evaluations in calculating the integral; (if integrator do not implement this function returns -1). { return fIntegrator == 0 ? -1 : fIntegrator->NEval(); }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. { if (fIntegrator) fIntegrator->SetRelTolerance(relTolerance",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:10030,Integrability,integrat,integration,10030,"egralLow(const ROOT::Math::IGenFunction& f, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param b upper value of the integration interval. template<class Function>; double IntegralLow(Function & f, double b);. evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b); @param f integration function. The function type must implement the mathlib::IGenFunction interface; @param b upper value of the integration interval. return IntegralLow(double b). double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b) with a singularity at c; @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval; @param c position of singularity. double operator()(double x). define operator() for IntegralLow. double Result() const. return the Result of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Result(); }. double Error() const. return the estimate of the absolute Error of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Error(); }. int Status() const. return the Error Status of the last Integral calculation. { return fIntegrator == 0 ? -1 : fIntegrator->Status(); }. int NEval() const. return number of function evaluations in calculating the integral; (if integrator do not implement this function returns -1). { return fIntegrator == 0 ? -1 : fIntegrator->NEval(); }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. { if (fIntegrator) fIntegrator->SetRelTolerance(relTolerance",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:10665,Integrability,integrat,integrator,10665,"T::Math::IGenFunction& f, double a, double b, double c). evaluate the Cauchy principal value of the integral of a function f over the defined interval (a,b) with a singularity at c; @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval; @param c position of singularity. double operator()(double x). define operator() for IntegralLow. double Result() const. return the Result of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Result(); }. double Error() const. return the estimate of the absolute Error of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Error(); }. int Status() const. return the Error Status of the last Integral calculation. { return fIntegrator == 0 ? -1 : fIntegrator->Status(); }. int NEval() const. return number of function evaluations in calculating the integral; (if integrator do not implement this function returns -1). { return fIntegrator == 0 ? -1 : fIntegrator->NEval(); }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. { if (fIntegrator) fIntegrator->SetRelTolerance(relTolerance); }. void SetAbsTolerance(double absTolerance). set the desired absolute Error. { if (fIntegrator) fIntegrator->SetAbsTolerance(absTolerance); }. VirtualIntegratorOneDim * GetIntegrator(). return a pointer to integrator object. { return fIntegrator; }. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt). set the options. { if (fIntegrator) fIntegrator->SetOptions(opt); }. std::string Name() const; return name of integrator. { return (fIntegrator) ? Options().Integrator() : std::string(""""); }. IntegrationOneDim::Type GetType(const char* name); static function to get the enumeration from a string. std::string GetName(ROOT::Math::IntegrationOneDim::Type ); stat",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:11187,Integrability,integrat,integrator,11187,"ularity. double operator()(double x). define operator() for IntegralLow. double Result() const. return the Result of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Result(); }. double Error() const. return the estimate of the absolute Error of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Error(); }. int Status() const. return the Error Status of the last Integral calculation. { return fIntegrator == 0 ? -1 : fIntegrator->Status(); }. int NEval() const. return number of function evaluations in calculating the integral; (if integrator do not implement this function returns -1). { return fIntegrator == 0 ? -1 : fIntegrator->NEval(); }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. { if (fIntegrator) fIntegrator->SetRelTolerance(relTolerance); }. void SetAbsTolerance(double absTolerance). set the desired absolute Error. { if (fIntegrator) fIntegrator->SetAbsTolerance(absTolerance); }. VirtualIntegratorOneDim * GetIntegrator(). return a pointer to integrator object. { return fIntegrator; }. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt). set the options. { if (fIntegrator) fIntegrator->SetOptions(opt); }. std::string Name() const; return name of integrator. { return (fIntegrator) ? Options().Integrator() : std::string(""""); }. IntegrationOneDim::Type GetType(const char* name); static function to get the enumeration from a string. std::string GetName(ROOT::Math::IntegrationOneDim::Type ); static function to get a string from the enumeration. VirtualIntegratorOneDim * CreateIntegrator(ROOT::Math::IntegrationOneDim::Type type, double absTol, double relTol, unsigned int size, int rule).  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:11406,Integrability,integrat,integrator,11406,"ularity. double operator()(double x). define operator() for IntegralLow. double Result() const. return the Result of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Result(); }. double Error() const. return the estimate of the absolute Error of the last Integral calculation. { return fIntegrator == 0 ? 0 : fIntegrator->Error(); }. int Status() const. return the Error Status of the last Integral calculation. { return fIntegrator == 0 ? -1 : fIntegrator->Status(); }. int NEval() const. return number of function evaluations in calculating the integral; (if integrator do not implement this function returns -1). { return fIntegrator == 0 ? -1 : fIntegrator->NEval(); }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. { if (fIntegrator) fIntegrator->SetRelTolerance(relTolerance); }. void SetAbsTolerance(double absTolerance). set the desired absolute Error. { if (fIntegrator) fIntegrator->SetAbsTolerance(absTolerance); }. VirtualIntegratorOneDim * GetIntegrator(). return a pointer to integrator object. { return fIntegrator; }. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt). set the options. { if (fIntegrator) fIntegrator->SetOptions(opt); }. std::string Name() const; return name of integrator. { return (fIntegrator) ? Options().Integrator() : std::string(""""); }. IntegrationOneDim::Type GetType(const char* name); static function to get the enumeration from a string. std::string GetName(ROOT::Math::IntegrationOneDim::Type ); static function to get a string from the enumeration. VirtualIntegratorOneDim * CreateIntegrator(ROOT::Math::IntegrationOneDim::Type type, double absTol, double relTol, unsigned int size, int rule).  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:402,Modifiability,plug-in,plug-in,402,". ROOT::Math::IntegratorOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IntegratorOneDim. class ROOT::Math::IntegratorOneDim. User Class for performing numerical integration of a function in one dimension.; It uses the plug-in manager to load advanced numerical integration algorithms from GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. @ingroup Integration. This class is also known as (typedefs to this class)ROOT::Math::Integrator. Function Members (Methods); public:. virtual~IntegratorOneDim(); doubleError() const; ROOT::Math::VirtualIntegratorOneDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationOneDim::Type); static ROOT::Ma",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:604,Modifiability,adapt,adaptive,604,". ROOT::Math::IntegratorOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IntegratorOneDim. class ROOT::Math::IntegratorOneDim. User Class for performing numerical integration of a function in one dimension.; It uses the plug-in manager to load advanced numerical integration algorithms from GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. @ingroup Integration. This class is also known as (typedefs to this class)ROOT::Math::Integrator. Function Members (Methods); public:. virtual~IntegratorOneDim(); doubleError() const; ROOT::Math::VirtualIntegratorOneDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationOneDim::Type); static ROOT::Ma",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:621,Modifiability,adapt,adaptive,621,". ROOT::Math::IntegratorOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IntegratorOneDim. class ROOT::Math::IntegratorOneDim. User Class for performing numerical integration of a function in one dimension.; It uses the plug-in manager to load advanced numerical integration algorithms from GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. @ingroup Integration. This class is also known as (typedefs to this class)ROOT::Math::Integrator. Function Members (Methods); public:. virtual~IntegratorOneDim(); doubleError() const; ROOT::Math::VirtualIntegratorOneDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationOneDim::Type); static ROOT::Ma",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:868,Modifiability,adapt,adaptive,868,". ROOT::Math::IntegratorOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IntegratorOneDim. class ROOT::Math::IntegratorOneDim. User Class for performing numerical integration of a function in one dimension.; It uses the plug-in manager to load advanced numerical integration algorithms from GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. @ingroup Integration. This class is also known as (typedefs to this class)ROOT::Math::Integrator. Function Members (Methods); public:. virtual~IntegratorOneDim(); doubleError() const; ROOT::Math::VirtualIntegratorOneDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationOneDim::Type); static ROOT::Ma",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:4666,Modifiability,adapt,adaptive,4666,"or(ROOT::Math::IntegrationOneDim::Type type, double absTol, double relTol, unsigned int size, int rule). private:. ROOT::Math::IntegratorOneDimIntegratorOneDim(const ROOT::Math::IntegratorOneDim&); ROOT::Math::IntegratorOneDim&operator=(const ROOT::Math::IntegratorOneDim&). Data Members; private:. auto_ptr<ROOT::Math::IBaseFunctionOneDim>fFuncpointer to owned function; ROOT::Math::VirtualIntegratorOneDim*fIntegratorpointer to integrator interface class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetFunction( Function & f). double Integral(const ROOT::Math::IGenFunction& f, double a, double b). double Integral(double a, double b). double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). IntegratorOneDim(ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, unsigned int rule = 0); constructors. Constructor of one dimensional Integrator, default type is adaptive. @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL kADAPTIVE type). Possible type values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPTIVESINGULAR (from GSL), kNONADAPTIVE (from GSL); Possible rule values are kGAUS15 (rule = 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6); lower rules are indicated for singular functions while higher for smooth functions to get better accuracies. NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule ",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:4706,Modifiability,adapt,adaptive,4706,"le relTol, unsigned int size, int rule). private:. ROOT::Math::IntegratorOneDimIntegratorOneDim(const ROOT::Math::IntegratorOneDim&); ROOT::Math::IntegratorOneDim&operator=(const ROOT::Math::IntegratorOneDim&). Data Members; private:. auto_ptr<ROOT::Math::IBaseFunctionOneDim>fFuncpointer to owned function; ROOT::Math::VirtualIntegratorOneDim*fIntegratorpointer to integrator interface class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetFunction( Function & f). double Integral(const ROOT::Math::IGenFunction& f, double a, double b). double Integral(double a, double b). double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). IntegratorOneDim(ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, unsigned int rule = 0); constructors. Constructor of one dimensional Integrator, default type is adaptive. @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL kADAPTIVE type). Possible type values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPTIVESINGULAR (from GSL), kNONADAPTIVE (from GSL); Possible rule values are kGAUS15 (rule = 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6); lower rules are indicated for singular functions while higher for smooth functions to get better accuracies. NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Constructor of one dimensional Integrator passing a functi",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:4720,Modifiability,adapt,adaptive,4720,"le relTol, unsigned int size, int rule). private:. ROOT::Math::IntegratorOneDimIntegratorOneDim(const ROOT::Math::IntegratorOneDim&); ROOT::Math::IntegratorOneDim&operator=(const ROOT::Math::IntegratorOneDim&). Data Members; private:. auto_ptr<ROOT::Math::IBaseFunctionOneDim>fFuncpointer to owned function; ROOT::Math::VirtualIntegratorOneDim*fIntegratorpointer to integrator interface class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetFunction( Function & f). double Integral(const ROOT::Math::IGenFunction& f, double a, double b). double Integral(double a, double b). double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). IntegratorOneDim(ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, unsigned int rule = 0); constructors. Constructor of one dimensional Integrator, default type is adaptive. @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL kADAPTIVE type). Possible type values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPTIVESINGULAR (from GSL), kNONADAPTIVE (from GSL); Possible rule values are kGAUS15 (rule = 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6); lower rules are indicated for singular functions while higher for smooth functions to get better accuracies. NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Constructor of one dimensional Integrator passing a functi",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:5816,Modifiability,adapt,adaptive,5816,"ve Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL kADAPTIVE type). Possible type values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPTIVESINGULAR (from GSL), kNONADAPTIVE (from GSL); Possible rule values are kGAUS15 (rule = 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6); lower rules are indicated for singular functions while higher for smooth functions to get better accuracies. NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Constructor of one dimensional Integrator passing a function interface. @param f integration function (1D interface). It is copied inside; @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. SetFunction(const ROOT::Math::IGenFunction& f, bool copy = false). IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Template Constructor of one dimensional Integrator passing a generic function object. @param f integration function (any C++ callable object implementing operator()(double x); @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @pa",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:5830,Modifiability,adapt,adaptive,5830,"ve Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL kADAPTIVE type). Possible type values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPTIVESINGULAR (from GSL), kNONADAPTIVE (from GSL); Possible rule values are kGAUS15 (rule = 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6); lower rules are indicated for singular functions while higher for smooth functions to get better accuracies. NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Constructor of one dimensional Integrator passing a function interface. @param f integration function (1D interface). It is copied inside; @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. SetFunction(const ROOT::Math::IGenFunction& f, bool copy = false). IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Template Constructor of one dimensional Integrator passing a generic function object. @param f integration function (any C++ callable object implementing operator()(double x); @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @pa",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:6648,Modifiability,adapt,adaptive,6648,"ol = 0, unsigned int size = 0, int rule = 0). Constructor of one dimensional Integrator passing a function interface. @param f integration function (1D interface). It is copied inside; @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. SetFunction(const ROOT::Math::IGenFunction& f, bool copy = false). IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Template Constructor of one dimensional Integrator passing a generic function object. @param f integration function (any C++ callable object implementing operator()(double x); @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). virtual ~IntegratorOneDim(); destructor (will delete contained pointer). IntegratorOneDim & operator=(const ROOT::Math::IntegratorOneDim& ); { return *this; }. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); integration methods using a function. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const ROOT::Math::IGenFunction& f, double a, double b). evaluate the Integral of a function f over the defined interval (a,b); @param f integration function.",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:6662,Modifiability,adapt,adaptive,6662,"ol = 0, unsigned int size = 0, int rule = 0). Constructor of one dimensional Integrator passing a function interface. @param f integration function (1D interface). It is copied inside; @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. SetFunction(const ROOT::Math::IGenFunction& f, bool copy = false). IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Template Constructor of one dimensional Integrator passing a generic function object. @param f integration function (any C++ callable object implementing operator()(double x); @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). virtual ~IntegratorOneDim(); destructor (will delete contained pointer). IntegratorOneDim & operator=(const ROOT::Math::IntegratorOneDim& ); { return *this; }. double Integral(const ROOT::Math::IGenFunction& f, double a, double b); integration methods using a function. evaluate the Integral of a function f over the defined interval (a,b); @param f integration function. The function type must be a C++ callable object implementing operator()(double x); @param a lower value of the integration interval; @param b upper value of the integration interval. double Integral(const ROOT::Math::IGenFunction& f, double a, double b). evaluate the Integral of a function f over the defined interval (a,b); @param f integration function.",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:324,Performance,perform,performing,324,". ROOT::Math::IntegratorOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IntegratorOneDim. class ROOT::Math::IntegratorOneDim. User Class for performing numerical integration of a function in one dimension.; It uses the plug-in manager to load advanced numerical integration algorithms from GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. @ingroup Integration. This class is also known as (typedefs to this class)ROOT::Math::Integrator. Function Members (Methods); public:. virtual~IntegratorOneDim(); doubleError() const; ROOT::Math::VirtualIntegratorOneDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationOneDim::Type); static ROOT::Ma",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:421,Performance,load,load,421,". ROOT::Math::IntegratorOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IntegratorOneDim. class ROOT::Math::IntegratorOneDim. User Class for performing numerical integration of a function in one dimension.; It uses the plug-in manager to load advanced numerical integration algorithms from GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. @ingroup Integration. This class is also known as (typedefs to this class)ROOT::Math::Integrator. Function Members (Methods); public:. virtual~IntegratorOneDim(); doubleError() const; ROOT::Math::VirtualIntegratorOneDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationOneDim::Type); static ROOT::Ma",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:1385,Performance,perform,performances,1385,"lgorithms from GSL, which reimplements the; algorithms used in the QUADPACK, a numerical integration package written in Fortran. Various types of adaptive and non-adaptive integration are supported. These include; integration over infinite and semi-infinite ranges and singular integrals. The integration type is selected using the Integration::type enumeration; in the class constructor.; The default type is adaptive integration with singularity; (ADAPTIVESINGULAR or QAGS in the QUADPACK convention) applying a Gauss-Kronrod 21-point integration rule.; In the case of ADAPTIVE type, the integration rule can also be specified via the; Integration::GKRule. The default rule is 31 points. In the case of integration over infinite and semi-infinite ranges, the type used is always; ADAPTIVESINGULAR applying a transformation from the original interval into (0,1). The ADAPTIVESINGULAR type is the most sophicticated type. When performances are; important, it is then recommened to use the NONADAPTIVE type in case of smooth functions or; ADAPTIVE with a lower Gauss-Kronrod rule. For detailed description on GSL integration algorithms see the; <A HREF=""http://www.gnu.org/software/gsl/manual/gsl-ref_16.html#SEC248"">GSL Manual</A>. @ingroup Integration. This class is also known as (typedefs to this class)ROOT::Math::Integrator. Function Members (Methods); public:. virtual~IntegratorOneDim(); doubleError() const; ROOT::Math::VirtualIntegratorOneDim*GetIntegrator(); static stringGetName(ROOT::Math::IntegrationOneDim::Type); static ROOT::Math::IntegrationOneDim::TypeGetType(const char* name); doubleIntegral(); doubleIntegral(const ROOT::Math::IGenFunction& f); doubleIntegral(const vector<double>& pts); doubleIntegral(const ROOT::Math::IGenFunction& f, const vector<double>& pts); doubleIntegral(double a, double b); doubleIntegral(const ROOT::Math::IGenFunction& f, double a, double b); doubleIntegralCauchy(double a, double b, double c); doubleIntegralCauchy(const ROOT::Math::IGenFunction& f",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html:4968,Usability,simpl,simple,4968,"e; Inherited Members; Includes; Libraries. Function documentation; void SetFunction( Function & f). double Integral(const ROOT::Math::IGenFunction& f, double a, double b). double Integral(double a, double b). double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). IntegratorOneDim(ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, unsigned int rule = 0); constructors. Constructor of one dimensional Integrator, default type is adaptive. @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL kADAPTIVE type). Possible type values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPTIVESINGULAR (from GSL), kNONADAPTIVE (from GSL); Possible rule values are kGAUS15 (rule = 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6); lower rules are indicated for singular functions while higher for smooth functions to get better accuracies. NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Constructor of one dimensional Integrator passing a function interface. @param f integration function (1D interface). It is copied inside; @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). NOTE: When the default values are passed, the values used are taken from the defa",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDim.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDimOptions.html:2543,Availability,toler,tolerance,2543," const; voidROOT::Math::BaseIntegratorOptions::SetAbsTolerance(double tol); static voidSetDefaultAbsTolerance(double tol); static voidSetDefaultIntegrator(const char* name); static voidSetDefaultNPoints(unsigned int n); static voidSetDefaultRelTolerance(double tol); static voidSetDefaultWKSize(unsigned int size); voidROOT::Math::BaseIntegratorOptions::SetExtraOptions(const ROOT::Math::IOptions& opt); voidSetIntegrator(const char* name); voidSetNPoints(unsigned int n); voidROOT::Math::BaseIntegratorOptions::SetRelTolerance(double tol); voidROOT::Math::BaseIntegratorOptions::SetWKSize(unsigned int size); unsigned intROOT::Math::BaseIntegratorOptions::WKSize() const. protected:. voidROOT::Math::BaseIntegratorOptions::ClearExtra(). Data Members; protected:. doubleROOT::Math::BaseIntegratorOptions::fAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*ROOT::Math::BaseIntegratorOptions::fExtraOptionsextra options ; intROOT::Math::BaseIntegratorOptions::fIntegTypeIntegrator type (value converted from enum); unsigned intROOT::Math::BaseIntegratorOptions::fNCalls(max) funxtion calls; doubleROOT::Math::BaseIntegratorOptions::fRelTolerancerelative tolerance ; unsigned intROOT::Math::BaseIntegratorOptions::fWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::IntegratorOneDimOptions& rhs); assignment operators. std::string Integrator() const; name of 1D integrator. IntegratorOneDimOptions(IOptions * extraOpts = 0); constructor using the default options; can pass a pointer to extra options (N.B. pointer will be managed by the class). virtual ~IntegratorOneDimOptions(); {}. IntegratorOneDimOptions(const IntegratorOneDimOptions & rhs); copy constructor. {}. void SetNPoints(unsigned int n); specific method for one-dim; set number of points rule; values of 1,2,3,4,5,6 corresponds to 15,21,31,41,51,61 and they are used in GSL adaptive; values > 6 corresponds to the actual ",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDimOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDimOptions.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDimOptions.html:2872,Availability,toler,tolerance,2872," const; voidROOT::Math::BaseIntegratorOptions::SetAbsTolerance(double tol); static voidSetDefaultAbsTolerance(double tol); static voidSetDefaultIntegrator(const char* name); static voidSetDefaultNPoints(unsigned int n); static voidSetDefaultRelTolerance(double tol); static voidSetDefaultWKSize(unsigned int size); voidROOT::Math::BaseIntegratorOptions::SetExtraOptions(const ROOT::Math::IOptions& opt); voidSetIntegrator(const char* name); voidSetNPoints(unsigned int n); voidROOT::Math::BaseIntegratorOptions::SetRelTolerance(double tol); voidROOT::Math::BaseIntegratorOptions::SetWKSize(unsigned int size); unsigned intROOT::Math::BaseIntegratorOptions::WKSize() const. protected:. voidROOT::Math::BaseIntegratorOptions::ClearExtra(). Data Members; protected:. doubleROOT::Math::BaseIntegratorOptions::fAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*ROOT::Math::BaseIntegratorOptions::fExtraOptionsextra options ; intROOT::Math::BaseIntegratorOptions::fIntegTypeIntegrator type (value converted from enum); unsigned intROOT::Math::BaseIntegratorOptions::fNCalls(max) funxtion calls; doubleROOT::Math::BaseIntegratorOptions::fRelTolerancerelative tolerance ; unsigned intROOT::Math::BaseIntegratorOptions::fWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::IntegratorOneDimOptions& rhs); assignment operators. std::string Integrator() const; name of 1D integrator. IntegratorOneDimOptions(IOptions * extraOpts = 0); constructor using the default options; can pass a pointer to extra options (N.B. pointer will be managed by the class). virtual ~IntegratorOneDimOptions(); {}. IntegratorOneDimOptions(const IntegratorOneDimOptions & rhs); copy constructor. {}. void SetNPoints(unsigned int n); specific method for one-dim; set number of points rule; values of 1,2,3,4,5,6 corresponds to 15,21,31,41,51,61 and they are used in GSL adaptive; values > 6 corresponds to the actual ",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDimOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDimOptions.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDimOptions.html:397,Deployability,integrat,integration,397,". ROOT::Math::IntegratorOneDimOptions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IntegratorOneDimOptions. class ROOT::Math::IntegratorOneDimOptions: public ROOT::Math::BaseIntegratorOptions. Base class for Numerical integration options; common in 1D and multi-dimension; This is an internal class and is not supposed to be instantiated by the user. @ingroup Integration. Function Members (Methods); public:. virtual~IntegratorOneDimOptions(); doubleROOT::Math::BaseIntegratorOptions::AbsTolerance() const; static ROOT::Math::IOptions&Default(const char* name); static doubleDefaultAbsTolerance(); static stringDefaultIntegrator(); static ROOT::Math::IntegrationOneDim::TypeDefaultIntegratorType(); static unsigned intDefaultNPoints(); static doubleDefaultRelTolerance(); static unsigned intDefaultWKSize(); ROOT::Math::IOptions*ROOT::Math::BaseIntegratorOptions::ExtraOptions() const; static ROOT::Math::IOptions*FindDefault(const char* name); virtual stringIntegrator() const; ROOT::Math::IntegratorOneDimOptionsIntegratorOneDimOptions(ROOT::Math::IOptions* extraOpts = 0); ROOT::Math::IntegratorOneDimOptionsIntegratorOneDimOptions(const ROOT::Math::IntegratorOneDimOptions& rhs); ROOT::Math::IntegrationOneDim::TypeIntegratorType() const; unsigned intNPoints() const; ROOT::Math::IntegratorOneDimOptions&operator=(const ROOT::Math::IntegratorOneDimOptions& rhs); voidPrint(ostream& os = std::cout) const; static voidPrintDefault(const char* name = 0, ostream& os = std::cout); doubleROOT::Math::BaseIntegratorOptions::RelTolerance() const; voidROOT::Math::BaseIntegratorOptions::SetAbsTolerance(double tol); static voidSetDefaultAbsTolerance(double tol); static voidSetDefaultIntegrator(const char* name); static voidSetDefaultNPoints(unsigned int n); static voidSetDefaultRelTolerance(double tol); static voidSetDefa",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDimOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDimOptions.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDimOptions.html:3193,Deployability,integrat,integrator,3193,"gned int n); voidROOT::Math::BaseIntegratorOptions::SetRelTolerance(double tol); voidROOT::Math::BaseIntegratorOptions::SetWKSize(unsigned int size); unsigned intROOT::Math::BaseIntegratorOptions::WKSize() const. protected:. voidROOT::Math::BaseIntegratorOptions::ClearExtra(). Data Members; protected:. doubleROOT::Math::BaseIntegratorOptions::fAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*ROOT::Math::BaseIntegratorOptions::fExtraOptionsextra options ; intROOT::Math::BaseIntegratorOptions::fIntegTypeIntegrator type (value converted from enum); unsigned intROOT::Math::BaseIntegratorOptions::fNCalls(max) funxtion calls; doubleROOT::Math::BaseIntegratorOptions::fRelTolerancerelative tolerance ; unsigned intROOT::Math::BaseIntegratorOptions::fWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::IntegratorOneDimOptions& rhs); assignment operators. std::string Integrator() const; name of 1D integrator. IntegratorOneDimOptions(IOptions * extraOpts = 0); constructor using the default options; can pass a pointer to extra options (N.B. pointer will be managed by the class). virtual ~IntegratorOneDimOptions(); {}. IntegratorOneDimOptions(const IntegratorOneDimOptions & rhs); copy constructor. {}. void SetNPoints(unsigned int n); specific method for one-dim; set number of points rule; values of 1,2,3,4,5,6 corresponds to 15,21,31,41,51,61 and they are used in GSL adaptive; values > 6 corresponds to the actual points and they are used by teh GaussLegendre integrator. { fNCalls = n; }. unsigned int NPoints() const; maximum number of function calls. { return fNCalls; }. IntegrationOneDim::Type IntegratorType() const; type of the integrator (return the enumeration type). { return (IntegrationOneDim::Type) fIntegType; }. void SetIntegrator(const char* name); set 1D integrator name. void Print(ostream& os = std::cout) const; print all the options. void SetDefaultInteg",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDimOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDimOptions.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDimOptions.html:3762,Deployability,integrat,integrator,3762,"s ; intROOT::Math::BaseIntegratorOptions::fIntegTypeIntegrator type (value converted from enum); unsigned intROOT::Math::BaseIntegratorOptions::fNCalls(max) funxtion calls; doubleROOT::Math::BaseIntegratorOptions::fRelTolerancerelative tolerance ; unsigned intROOT::Math::BaseIntegratorOptions::fWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::IntegratorOneDimOptions& rhs); assignment operators. std::string Integrator() const; name of 1D integrator. IntegratorOneDimOptions(IOptions * extraOpts = 0); constructor using the default options; can pass a pointer to extra options (N.B. pointer will be managed by the class). virtual ~IntegratorOneDimOptions(); {}. IntegratorOneDimOptions(const IntegratorOneDimOptions & rhs); copy constructor. {}. void SetNPoints(unsigned int n); specific method for one-dim; set number of points rule; values of 1,2,3,4,5,6 corresponds to 15,21,31,41,51,61 and they are used in GSL adaptive; values > 6 corresponds to the actual points and they are used by teh GaussLegendre integrator. { fNCalls = n; }. unsigned int NPoints() const; maximum number of function calls. { return fNCalls; }. IntegrationOneDim::Type IntegratorType() const; type of the integrator (return the enumeration type). { return (IntegrationOneDim::Type) fIntegType; }. void SetIntegrator(const char* name); set 1D integrator name. void Print(ostream& os = std::cout) const; print all the options. void SetDefaultIntegrator(const char* name); static methods for setting and retrieving the default options. void SetDefaultAbsTolerance(double tol). void SetDefaultRelTolerance(double tol). void SetDefaultWKSize(unsigned int size). void SetDefaultNPoints(unsigned int n). std::string DefaultIntegrator(). IntegrationOneDim::Type DefaultIntegratorType(). double DefaultAbsTolerance(). double DefaultRelTolerance(). unsigned int DefaultWKSize(). unsigned int DefaultNPoints(). ROOT",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDimOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDimOptions.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDimOptions.html:3937,Deployability,integrat,integrator,3937,"ns::fWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::IntegratorOneDimOptions& rhs); assignment operators. std::string Integrator() const; name of 1D integrator. IntegratorOneDimOptions(IOptions * extraOpts = 0); constructor using the default options; can pass a pointer to extra options (N.B. pointer will be managed by the class). virtual ~IntegratorOneDimOptions(); {}. IntegratorOneDimOptions(const IntegratorOneDimOptions & rhs); copy constructor. {}. void SetNPoints(unsigned int n); specific method for one-dim; set number of points rule; values of 1,2,3,4,5,6 corresponds to 15,21,31,41,51,61 and they are used in GSL adaptive; values > 6 corresponds to the actual points and they are used by teh GaussLegendre integrator. { fNCalls = n; }. unsigned int NPoints() const; maximum number of function calls. { return fNCalls; }. IntegrationOneDim::Type IntegratorType() const; type of the integrator (return the enumeration type). { return (IntegrationOneDim::Type) fIntegType; }. void SetIntegrator(const char* name); set 1D integrator name. void Print(ostream& os = std::cout) const; print all the options. void SetDefaultIntegrator(const char* name); static methods for setting and retrieving the default options. void SetDefaultAbsTolerance(double tol). void SetDefaultRelTolerance(double tol). void SetDefaultWKSize(unsigned int size). void SetDefaultNPoints(unsigned int n). std::string DefaultIntegrator(). IntegrationOneDim::Type DefaultIntegratorType(). double DefaultAbsTolerance(). double DefaultRelTolerance(). unsigned int DefaultWKSize(). unsigned int DefaultNPoints(). ROOT::Math::IOptions & Default(const char* name); retrieve specific options - if not existing create a IOptions. ROOT::Math::IOptions * FindDefault(const char* name); find specific options - return 0 if not existing. void PrintDefault(const char* name = 0, ostream& os = std::cout); print only t",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDimOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDimOptions.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDimOptions.html:4074,Deployability,integrat,integrator,4074,"Options & operator=(const ROOT::Math::IntegratorOneDimOptions& rhs); assignment operators. std::string Integrator() const; name of 1D integrator. IntegratorOneDimOptions(IOptions * extraOpts = 0); constructor using the default options; can pass a pointer to extra options (N.B. pointer will be managed by the class). virtual ~IntegratorOneDimOptions(); {}. IntegratorOneDimOptions(const IntegratorOneDimOptions & rhs); copy constructor. {}. void SetNPoints(unsigned int n); specific method for one-dim; set number of points rule; values of 1,2,3,4,5,6 corresponds to 15,21,31,41,51,61 and they are used in GSL adaptive; values > 6 corresponds to the actual points and they are used by teh GaussLegendre integrator. { fNCalls = n; }. unsigned int NPoints() const; maximum number of function calls. { return fNCalls; }. IntegrationOneDim::Type IntegratorType() const; type of the integrator (return the enumeration type). { return (IntegrationOneDim::Type) fIntegType; }. void SetIntegrator(const char* name); set 1D integrator name. void Print(ostream& os = std::cout) const; print all the options. void SetDefaultIntegrator(const char* name); static methods for setting and retrieving the default options. void SetDefaultAbsTolerance(double tol). void SetDefaultRelTolerance(double tol). void SetDefaultWKSize(unsigned int size). void SetDefaultNPoints(unsigned int n). std::string DefaultIntegrator(). IntegrationOneDim::Type DefaultIntegratorType(). double DefaultAbsTolerance(). double DefaultRelTolerance(). unsigned int DefaultWKSize(). unsigned int DefaultNPoints(). ROOT::Math::IOptions & Default(const char* name); retrieve specific options - if not existing create a IOptions. ROOT::Math::IOptions * FindDefault(const char* name); find specific options - return 0 if not existing. void PrintDefault(const char* name = 0, ostream& os = std::cout); print only the specified default options.  Author: L. Moneta Fri Aug 15 2008  Copyright (c) 2008 LCG ROOT Math Team, CERN/PH-SFT *;  Last cha",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDimOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDimOptions.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDimOptions.html:3669,Energy Efficiency,adapt,adaptive,3669,"s ; intROOT::Math::BaseIntegratorOptions::fIntegTypeIntegrator type (value converted from enum); unsigned intROOT::Math::BaseIntegratorOptions::fNCalls(max) funxtion calls; doubleROOT::Math::BaseIntegratorOptions::fRelTolerancerelative tolerance ; unsigned intROOT::Math::BaseIntegratorOptions::fWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::IntegratorOneDimOptions& rhs); assignment operators. std::string Integrator() const; name of 1D integrator. IntegratorOneDimOptions(IOptions * extraOpts = 0); constructor using the default options; can pass a pointer to extra options (N.B. pointer will be managed by the class). virtual ~IntegratorOneDimOptions(); {}. IntegratorOneDimOptions(const IntegratorOneDimOptions & rhs); copy constructor. {}. void SetNPoints(unsigned int n); specific method for one-dim; set number of points rule; values of 1,2,3,4,5,6 corresponds to 15,21,31,41,51,61 and they are used in GSL adaptive; values > 6 corresponds to the actual points and they are used by teh GaussLegendre integrator. { fNCalls = n; }. unsigned int NPoints() const; maximum number of function calls. { return fNCalls; }. IntegrationOneDim::Type IntegratorType() const; type of the integrator (return the enumeration type). { return (IntegrationOneDim::Type) fIntegType; }. void SetIntegrator(const char* name); set 1D integrator name. void Print(ostream& os = std::cout) const; print all the options. void SetDefaultIntegrator(const char* name); static methods for setting and retrieving the default options. void SetDefaultAbsTolerance(double tol). void SetDefaultRelTolerance(double tol). void SetDefaultWKSize(unsigned int size). void SetDefaultNPoints(unsigned int n). std::string DefaultIntegrator(). IntegrationOneDim::Type DefaultIntegratorType(). double DefaultAbsTolerance(). double DefaultRelTolerance(). unsigned int DefaultWKSize(). unsigned int DefaultNPoints(). ROOT",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDimOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDimOptions.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDimOptions.html:397,Integrability,integrat,integration,397,". ROOT::Math::IntegratorOneDimOptions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IntegratorOneDimOptions. class ROOT::Math::IntegratorOneDimOptions: public ROOT::Math::BaseIntegratorOptions. Base class for Numerical integration options; common in 1D and multi-dimension; This is an internal class and is not supposed to be instantiated by the user. @ingroup Integration. Function Members (Methods); public:. virtual~IntegratorOneDimOptions(); doubleROOT::Math::BaseIntegratorOptions::AbsTolerance() const; static ROOT::Math::IOptions&Default(const char* name); static doubleDefaultAbsTolerance(); static stringDefaultIntegrator(); static ROOT::Math::IntegrationOneDim::TypeDefaultIntegratorType(); static unsigned intDefaultNPoints(); static doubleDefaultRelTolerance(); static unsigned intDefaultWKSize(); ROOT::Math::IOptions*ROOT::Math::BaseIntegratorOptions::ExtraOptions() const; static ROOT::Math::IOptions*FindDefault(const char* name); virtual stringIntegrator() const; ROOT::Math::IntegratorOneDimOptionsIntegratorOneDimOptions(ROOT::Math::IOptions* extraOpts = 0); ROOT::Math::IntegratorOneDimOptionsIntegratorOneDimOptions(const ROOT::Math::IntegratorOneDimOptions& rhs); ROOT::Math::IntegrationOneDim::TypeIntegratorType() const; unsigned intNPoints() const; ROOT::Math::IntegratorOneDimOptions&operator=(const ROOT::Math::IntegratorOneDimOptions& rhs); voidPrint(ostream& os = std::cout) const; static voidPrintDefault(const char* name = 0, ostream& os = std::cout); doubleROOT::Math::BaseIntegratorOptions::RelTolerance() const; voidROOT::Math::BaseIntegratorOptions::SetAbsTolerance(double tol); static voidSetDefaultAbsTolerance(double tol); static voidSetDefaultIntegrator(const char* name); static voidSetDefaultNPoints(unsigned int n); static voidSetDefaultRelTolerance(double tol); static voidSetDefa",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDimOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDimOptions.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDimOptions.html:3193,Integrability,integrat,integrator,3193,"gned int n); voidROOT::Math::BaseIntegratorOptions::SetRelTolerance(double tol); voidROOT::Math::BaseIntegratorOptions::SetWKSize(unsigned int size); unsigned intROOT::Math::BaseIntegratorOptions::WKSize() const. protected:. voidROOT::Math::BaseIntegratorOptions::ClearExtra(). Data Members; protected:. doubleROOT::Math::BaseIntegratorOptions::fAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*ROOT::Math::BaseIntegratorOptions::fExtraOptionsextra options ; intROOT::Math::BaseIntegratorOptions::fIntegTypeIntegrator type (value converted from enum); unsigned intROOT::Math::BaseIntegratorOptions::fNCalls(max) funxtion calls; doubleROOT::Math::BaseIntegratorOptions::fRelTolerancerelative tolerance ; unsigned intROOT::Math::BaseIntegratorOptions::fWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::IntegratorOneDimOptions& rhs); assignment operators. std::string Integrator() const; name of 1D integrator. IntegratorOneDimOptions(IOptions * extraOpts = 0); constructor using the default options; can pass a pointer to extra options (N.B. pointer will be managed by the class). virtual ~IntegratorOneDimOptions(); {}. IntegratorOneDimOptions(const IntegratorOneDimOptions & rhs); copy constructor. {}. void SetNPoints(unsigned int n); specific method for one-dim; set number of points rule; values of 1,2,3,4,5,6 corresponds to 15,21,31,41,51,61 and they are used in GSL adaptive; values > 6 corresponds to the actual points and they are used by teh GaussLegendre integrator. { fNCalls = n; }. unsigned int NPoints() const; maximum number of function calls. { return fNCalls; }. IntegrationOneDim::Type IntegratorType() const; type of the integrator (return the enumeration type). { return (IntegrationOneDim::Type) fIntegType; }. void SetIntegrator(const char* name); set 1D integrator name. void Print(ostream& os = std::cout) const; print all the options. void SetDefaultInteg",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDimOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDimOptions.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDimOptions.html:3762,Integrability,integrat,integrator,3762,"s ; intROOT::Math::BaseIntegratorOptions::fIntegTypeIntegrator type (value converted from enum); unsigned intROOT::Math::BaseIntegratorOptions::fNCalls(max) funxtion calls; doubleROOT::Math::BaseIntegratorOptions::fRelTolerancerelative tolerance ; unsigned intROOT::Math::BaseIntegratorOptions::fWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::IntegratorOneDimOptions& rhs); assignment operators. std::string Integrator() const; name of 1D integrator. IntegratorOneDimOptions(IOptions * extraOpts = 0); constructor using the default options; can pass a pointer to extra options (N.B. pointer will be managed by the class). virtual ~IntegratorOneDimOptions(); {}. IntegratorOneDimOptions(const IntegratorOneDimOptions & rhs); copy constructor. {}. void SetNPoints(unsigned int n); specific method for one-dim; set number of points rule; values of 1,2,3,4,5,6 corresponds to 15,21,31,41,51,61 and they are used in GSL adaptive; values > 6 corresponds to the actual points and they are used by teh GaussLegendre integrator. { fNCalls = n; }. unsigned int NPoints() const; maximum number of function calls. { return fNCalls; }. IntegrationOneDim::Type IntegratorType() const; type of the integrator (return the enumeration type). { return (IntegrationOneDim::Type) fIntegType; }. void SetIntegrator(const char* name); set 1D integrator name. void Print(ostream& os = std::cout) const; print all the options. void SetDefaultIntegrator(const char* name); static methods for setting and retrieving the default options. void SetDefaultAbsTolerance(double tol). void SetDefaultRelTolerance(double tol). void SetDefaultWKSize(unsigned int size). void SetDefaultNPoints(unsigned int n). std::string DefaultIntegrator(). IntegrationOneDim::Type DefaultIntegratorType(). double DefaultAbsTolerance(). double DefaultRelTolerance(). unsigned int DefaultWKSize(). unsigned int DefaultNPoints(). ROOT",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDimOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDimOptions.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDimOptions.html:3937,Integrability,integrat,integrator,3937,"ns::fWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::IntegratorOneDimOptions& rhs); assignment operators. std::string Integrator() const; name of 1D integrator. IntegratorOneDimOptions(IOptions * extraOpts = 0); constructor using the default options; can pass a pointer to extra options (N.B. pointer will be managed by the class). virtual ~IntegratorOneDimOptions(); {}. IntegratorOneDimOptions(const IntegratorOneDimOptions & rhs); copy constructor. {}. void SetNPoints(unsigned int n); specific method for one-dim; set number of points rule; values of 1,2,3,4,5,6 corresponds to 15,21,31,41,51,61 and they are used in GSL adaptive; values > 6 corresponds to the actual points and they are used by teh GaussLegendre integrator. { fNCalls = n; }. unsigned int NPoints() const; maximum number of function calls. { return fNCalls; }. IntegrationOneDim::Type IntegratorType() const; type of the integrator (return the enumeration type). { return (IntegrationOneDim::Type) fIntegType; }. void SetIntegrator(const char* name); set 1D integrator name. void Print(ostream& os = std::cout) const; print all the options. void SetDefaultIntegrator(const char* name); static methods for setting and retrieving the default options. void SetDefaultAbsTolerance(double tol). void SetDefaultRelTolerance(double tol). void SetDefaultWKSize(unsigned int size). void SetDefaultNPoints(unsigned int n). std::string DefaultIntegrator(). IntegrationOneDim::Type DefaultIntegratorType(). double DefaultAbsTolerance(). double DefaultRelTolerance(). unsigned int DefaultWKSize(). unsigned int DefaultNPoints(). ROOT::Math::IOptions & Default(const char* name); retrieve specific options - if not existing create a IOptions. ROOT::Math::IOptions * FindDefault(const char* name); find specific options - return 0 if not existing. void PrintDefault(const char* name = 0, ostream& os = std::cout); print only t",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDimOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDimOptions.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDimOptions.html:4074,Integrability,integrat,integrator,4074,"Options & operator=(const ROOT::Math::IntegratorOneDimOptions& rhs); assignment operators. std::string Integrator() const; name of 1D integrator. IntegratorOneDimOptions(IOptions * extraOpts = 0); constructor using the default options; can pass a pointer to extra options (N.B. pointer will be managed by the class). virtual ~IntegratorOneDimOptions(); {}. IntegratorOneDimOptions(const IntegratorOneDimOptions & rhs); copy constructor. {}. void SetNPoints(unsigned int n); specific method for one-dim; set number of points rule; values of 1,2,3,4,5,6 corresponds to 15,21,31,41,51,61 and they are used in GSL adaptive; values > 6 corresponds to the actual points and they are used by teh GaussLegendre integrator. { fNCalls = n; }. unsigned int NPoints() const; maximum number of function calls. { return fNCalls; }. IntegrationOneDim::Type IntegratorType() const; type of the integrator (return the enumeration type). { return (IntegrationOneDim::Type) fIntegType; }. void SetIntegrator(const char* name); set 1D integrator name. void Print(ostream& os = std::cout) const; print all the options. void SetDefaultIntegrator(const char* name); static methods for setting and retrieving the default options. void SetDefaultAbsTolerance(double tol). void SetDefaultRelTolerance(double tol). void SetDefaultWKSize(unsigned int size). void SetDefaultNPoints(unsigned int n). std::string DefaultIntegrator(). IntegrationOneDim::Type DefaultIntegratorType(). double DefaultAbsTolerance(). double DefaultRelTolerance(). unsigned int DefaultWKSize(). unsigned int DefaultNPoints(). ROOT::Math::IOptions & Default(const char* name); retrieve specific options - if not existing create a IOptions. ROOT::Math::IOptions * FindDefault(const char* name); find specific options - return 0 if not existing. void PrintDefault(const char* name = 0, ostream& os = std::cout); print only the specified default options.  Author: L. Moneta Fri Aug 15 2008  Copyright (c) 2008 LCG ROOT Math Team, CERN/PH-SFT *;  Last cha",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDimOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDimOptions.html
https://root.cern/root/html534/ROOT__Math__IntegratorOneDimOptions.html:3669,Modifiability,adapt,adaptive,3669,"s ; intROOT::Math::BaseIntegratorOptions::fIntegTypeIntegrator type (value converted from enum); unsigned intROOT::Math::BaseIntegratorOptions::fNCalls(max) funxtion calls; doubleROOT::Math::BaseIntegratorOptions::fRelTolerancerelative tolerance ; unsigned intROOT::Math::BaseIntegratorOptions::fWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::IntegratorOneDimOptions& rhs); assignment operators. std::string Integrator() const; name of 1D integrator. IntegratorOneDimOptions(IOptions * extraOpts = 0); constructor using the default options; can pass a pointer to extra options (N.B. pointer will be managed by the class). virtual ~IntegratorOneDimOptions(); {}. IntegratorOneDimOptions(const IntegratorOneDimOptions & rhs); copy constructor. {}. void SetNPoints(unsigned int n); specific method for one-dim; set number of points rule; values of 1,2,3,4,5,6 corresponds to 15,21,31,41,51,61 and they are used in GSL adaptive; values > 6 corresponds to the actual points and they are used by teh GaussLegendre integrator. { fNCalls = n; }. unsigned int NPoints() const; maximum number of function calls. { return fNCalls; }. IntegrationOneDim::Type IntegratorType() const; type of the integrator (return the enumeration type). { return (IntegrationOneDim::Type) fIntegType; }. void SetIntegrator(const char* name); set 1D integrator name. void Print(ostream& os = std::cout) const; print all the options. void SetDefaultIntegrator(const char* name); static methods for setting and retrieving the default options. void SetDefaultAbsTolerance(double tol). void SetDefaultRelTolerance(double tol). void SetDefaultWKSize(unsigned int size). void SetDefaultNPoints(unsigned int n). std::string DefaultIntegrator(). IntegrationOneDim::Type DefaultIntegratorType(). double DefaultAbsTolerance(). double DefaultRelTolerance(). unsigned int DefaultWKSize(). unsigned int DefaultNPoints(). ROOT",MatchSource.WIKI,root/html534/ROOT__Math__IntegratorOneDimOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IntegratorOneDimOptions.html
https://root.cern/root/html534/ROOT__Math__Interpolator.html:488,Availability,avail,available,488,". ROOT::Math::Interpolator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::Interpolator. class ROOT::Math::Interpolator. Class for performing function interpolation of points.; The class is instantiated with an interpolation methods, passed as an enumeration in the constructor.; See Interpolation::Type for the available interpolation algorithms, which are implemented using GSL.; See also the <A HREF=http://www.gnu.org/software/gsl/manual/html_node/Interpolation.html"">GSL manual</A> for more information.; The class provides additional methods for computing derivatives and integrals of interpolating functions. This class does not support copying.; @ingroup Interpolation. Function Members (Methods); public:. virtual~Interpolator(); doubleDeriv(double x) const; doubleDeriv2(double x) const; doubleEval(double x) const; doubleInteg(double a, double b) const; ROOT::Math::InterpolatorInterpolator(unsigned int ndata = 0, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE); ROOT::Math::InterpolatorInterpolator(const vector<double>& x, const vector<double>& y, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE); boolSetData(const vector<double>& x, const vector<double>& y); boolSetData(unsigned int ndata, const double* x, const double* y); stringType() const; stringTypeGet() const. private:. ROOT::Math::InterpolatorInterpolator(const ROOT::Math::Interpolator&); ROOT::Math::Interpolator&operator=(const ROOT::Math::Interpolator&). Data Members; private:. ROOT::Math::GSLInterpolator*fInterppointer to GSL interpolator class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Interpolator(unsigned int ndata = 0, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE). Constructs an interpolator class from number of data points and with Int",MatchSource.WIKI,root/html534/ROOT__Math__Interpolator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__Interpolator.html
https://root.cern/root/html534/ROOT__Math__Interpolator.html:2501,Deployability,continuous,continuous,2501,"nterpolator(const ROOT::Math::Interpolator&); ROOT::Math::Interpolator&operator=(const ROOT::Math::Interpolator&). Data Members; private:. ROOT::Math::GSLInterpolator*fInterppointer to GSL interpolator class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Interpolator(unsigned int ndata = 0, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE). Constructs an interpolator class from number of data points and with Interpolation::Type type.; The data can be set later on with the SetData method.; In case the data size is not known, better using the default of zero or the next constructor later on.; The default interpolation type is Cubic spline. Interpolator(const vector<double>& x, const vector<double>& y, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE). Constructs an interpolator class from vector of data points \f$ (x_i, y_i )\f$ and with Interpolation::Type type.; The method will compute a continuous interpolating function \f$ y(x) \f$ such that \f$ y_i = y ( x_i )\f$.; The default interpolation type is Cubic spline. virtual ~Interpolator(). Interpolator(const ROOT::Math::Interpolator& ); usually copying is non trivial, so we make this unaccessible. bool SetData(const vector<double>& x, const vector<double>& y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used in the constructor (ndata); If this is not the case a new re-initialization is performed with the new data size. bool SetData(unsigned int ndata, const double* x, const double* y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used when constructing the class (ndata); If this is not the case a new re-initialization is performed with the new data size. double Eval(double x) const. Return the interpolated value at point x. double Deriv(double x) const. Return the derivative of the interpolated function at point x. double Der",MatchSource.WIKI,root/html534/ROOT__Math__Interpolator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__Interpolator.html
https://root.cern/root/html534/ROOT__Math__Interpolator.html:2873,Energy Efficiency,efficient,efficient,2873,"an interpolator class from number of data points and with Interpolation::Type type.; The data can be set later on with the SetData method.; In case the data size is not known, better using the default of zero or the next constructor later on.; The default interpolation type is Cubic spline. Interpolator(const vector<double>& x, const vector<double>& y, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE). Constructs an interpolator class from vector of data points \f$ (x_i, y_i )\f$ and with Interpolation::Type type.; The method will compute a continuous interpolating function \f$ y(x) \f$ such that \f$ y_i = y ( x_i )\f$.; The default interpolation type is Cubic spline. virtual ~Interpolator(). Interpolator(const ROOT::Math::Interpolator& ); usually copying is non trivial, so we make this unaccessible. bool SetData(const vector<double>& x, const vector<double>& y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used in the constructor (ndata); If this is not the case a new re-initialization is performed with the new data size. bool SetData(unsigned int ndata, const double* x, const double* y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used when constructing the class (ndata); If this is not the case a new re-initialization is performed with the new data size. double Eval(double x) const. Return the interpolated value at point x. double Deriv(double x) const. Return the derivative of the interpolated function at point x. double Deriv2(double x) const. Return the second derivative of the interpolated function at point x. double Integ(double a, double b) const. Return the Integral of the interpolated function over the range [a,b]. std::string Type() const. Return the type of interpolation method. std::string TypeGet() const.  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. F",MatchSource.WIKI,root/html534/ROOT__Math__Interpolator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__Interpolator.html
https://root.cern/root/html534/ROOT__Math__Interpolator.html:3164,Energy Efficiency,efficient,efficient,3164,"on with the SetData method.; In case the data size is not known, better using the default of zero or the next constructor later on.; The default interpolation type is Cubic spline. Interpolator(const vector<double>& x, const vector<double>& y, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE). Constructs an interpolator class from vector of data points \f$ (x_i, y_i )\f$ and with Interpolation::Type type.; The method will compute a continuous interpolating function \f$ y(x) \f$ such that \f$ y_i = y ( x_i )\f$.; The default interpolation type is Cubic spline. virtual ~Interpolator(). Interpolator(const ROOT::Math::Interpolator& ); usually copying is non trivial, so we make this unaccessible. bool SetData(const vector<double>& x, const vector<double>& y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used in the constructor (ndata); If this is not the case a new re-initialization is performed with the new data size. bool SetData(unsigned int ndata, const double* x, const double* y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used when constructing the class (ndata); If this is not the case a new re-initialization is performed with the new data size. double Eval(double x) const. Return the interpolated value at point x. double Deriv(double x) const. Return the derivative of the interpolated function at point x. double Deriv2(double x) const. Return the second derivative of the interpolated function at point x. double Integ(double a, double b) const. Return the Integral of the interpolated function over the range [a,b]. std::string Type() const. Return the type of interpolation method. std::string TypeGet() const.  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__Interpolator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__Interpolator.html
https://root.cern/root/html534/ROOT__Math__Interpolator.html:307,Performance,perform,performing,307,". ROOT::Math::Interpolator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHMORE;  ROOT::Math::Interpolator. class ROOT::Math::Interpolator. Class for performing function interpolation of points.; The class is instantiated with an interpolation methods, passed as an enumeration in the constructor.; See Interpolation::Type for the available interpolation algorithms, which are implemented using GSL.; See also the <A HREF=http://www.gnu.org/software/gsl/manual/html_node/Interpolation.html"">GSL manual</A> for more information.; The class provides additional methods for computing derivatives and integrals of interpolating functions. This class does not support copying.; @ingroup Interpolation. Function Members (Methods); public:. virtual~Interpolator(); doubleDeriv(double x) const; doubleDeriv2(double x) const; doubleEval(double x) const; doubleInteg(double a, double b) const; ROOT::Math::InterpolatorInterpolator(unsigned int ndata = 0, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE); ROOT::Math::InterpolatorInterpolator(const vector<double>& x, const vector<double>& y, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE); boolSetData(const vector<double>& x, const vector<double>& y); boolSetData(unsigned int ndata, const double* x, const double* y); stringType() const; stringTypeGet() const. private:. ROOT::Math::InterpolatorInterpolator(const ROOT::Math::Interpolator&); ROOT::Math::Interpolator&operator=(const ROOT::Math::Interpolator&). Data Members; private:. ROOT::Math::GSLInterpolator*fInterppointer to GSL interpolator class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Interpolator(unsigned int ndata = 0, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE). Constructs an interpolator class from number of data points and with Int",MatchSource.WIKI,root/html534/ROOT__Math__Interpolator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__Interpolator.html
https://root.cern/root/html534/ROOT__Math__Interpolator.html:3019,Performance,perform,performed,3019,"an interpolator class from number of data points and with Interpolation::Type type.; The data can be set later on with the SetData method.; In case the data size is not known, better using the default of zero or the next constructor later on.; The default interpolation type is Cubic spline. Interpolator(const vector<double>& x, const vector<double>& y, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE). Constructs an interpolator class from vector of data points \f$ (x_i, y_i )\f$ and with Interpolation::Type type.; The method will compute a continuous interpolating function \f$ y(x) \f$ such that \f$ y_i = y ( x_i )\f$.; The default interpolation type is Cubic spline. virtual ~Interpolator(). Interpolator(const ROOT::Math::Interpolator& ); usually copying is non trivial, so we make this unaccessible. bool SetData(const vector<double>& x, const vector<double>& y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used in the constructor (ndata); If this is not the case a new re-initialization is performed with the new data size. bool SetData(unsigned int ndata, const double* x, const double* y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used when constructing the class (ndata); If this is not the case a new re-initialization is performed with the new data size. double Eval(double x) const. Return the interpolated value at point x. double Deriv(double x) const. Return the derivative of the interpolated function at point x. double Deriv2(double x) const. Return the second derivative of the interpolated function at point x. double Integ(double a, double b) const. Return the Integral of the interpolated function over the range [a,b]. std::string Type() const. Return the type of interpolation method. std::string TypeGet() const.  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. F",MatchSource.WIKI,root/html534/ROOT__Math__Interpolator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__Interpolator.html
https://root.cern/root/html534/ROOT__Math__Interpolator.html:3319,Performance,perform,performed,3319,"on with the SetData method.; In case the data size is not known, better using the default of zero or the next constructor later on.; The default interpolation type is Cubic spline. Interpolator(const vector<double>& x, const vector<double>& y, ROOT::Math::Interpolation::Type type = Interpolation::kCSPLINE). Constructs an interpolator class from vector of data points \f$ (x_i, y_i )\f$ and with Interpolation::Type type.; The method will compute a continuous interpolating function \f$ y(x) \f$ such that \f$ y_i = y ( x_i )\f$.; The default interpolation type is Cubic spline. virtual ~Interpolator(). Interpolator(const ROOT::Math::Interpolator& ); usually copying is non trivial, so we make this unaccessible. bool SetData(const vector<double>& x, const vector<double>& y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used in the constructor (ndata); If this is not the case a new re-initialization is performed with the new data size. bool SetData(unsigned int ndata, const double* x, const double* y). Set the data vector ( x[] and y[] ); To be efficient, the size of the data must be the same of the value used when constructing the class (ndata); If this is not the case a new re-initialization is performed with the new data size. double Eval(double x) const. Return the interpolated value at point x. double Deriv(double x) const. Return the derivative of the interpolated function at point x. double Deriv2(double x) const. Return the second derivative of the interpolated function at point x. double Integ(double a, double b) const. Return the Integral of the interpolated function over the range [a,b]. std::string Type() const. Return the type of interpolation method. std::string TypeGet() const.  Last changed: root/mathmore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__Interpolator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__Interpolator.html
https://root.cern/root/html534/ROOT__Math__IOptions.html:516,Availability,avail,available,516,". ROOT::Math::IOptions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IOptions. class ROOT::Math::IOptions. Generic interface for defining configuration options of a numerical algorithm. @ingroup NumAlgo. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~IOptions(); virtual ROOT::Math::IOptions*Clone() const; virtual boolGetIntValue(const char*, int&) const; virtual boolGetNamedValue(const char*, string&) const; virtual boolGetRealValue(const char*, double&) const; intIValue(const char* name) const; stringNamedValue(const char* name) const; ROOT::Math::IOptions&operator=(const ROOT::Math::IOptions&); virtual voidPrint(ostream& = std::cout) const; doubleRValue(const char* name) const; virtual voidSetIntValue(const char*, int); virtual voidSetNamedValue(const char*, const char*); virtual voidSetRealValue(const char*, double); voidSetValue(const char* name, double val); voidSetValue(const char* name, int val); voidSetValue(const char* name, const char* val). private:. boolDoGetValue(const char* name, double& val) const; boolDoGetValue(const char* name, int& val) const; boolDoGetValue(const char* name, string& val) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IOptions(). IOptions * Clone() const; copy the options. void SetValue(const char* name, double val); generic methods for retrivieng options ; set option value. { SetRealValue(name,val);}. void SetValue(const char* name, int val); { SetIntValue(name,val);}. void SetValue(const char* name, const char* val); { SetNamedValue(name,val);}. double RValue(const char* name) const. int IValue(const char* name) const. std::string NamedValue(const char* name) const. boo",MatchSource.WIKI,root/html534/ROOT__Math__IOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IOptions.html
https://root.cern/root/html534/ROOT__Math__IOptions.html:316,Deployability,configurat,configuration,316,". ROOT::Math::IOptions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IOptions. class ROOT::Math::IOptions. Generic interface for defining configuration options of a numerical algorithm. @ingroup NumAlgo. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~IOptions(); virtual ROOT::Math::IOptions*Clone() const; virtual boolGetIntValue(const char*, int&) const; virtual boolGetNamedValue(const char*, string&) const; virtual boolGetRealValue(const char*, double&) const; intIValue(const char* name) const; stringNamedValue(const char* name) const; ROOT::Math::IOptions&operator=(const ROOT::Math::IOptions&); virtual voidPrint(ostream& = std::cout) const; doubleRValue(const char* name) const; virtual voidSetIntValue(const char*, int); virtual voidSetNamedValue(const char*, const char*); virtual voidSetRealValue(const char*, double); voidSetValue(const char* name, double val); voidSetValue(const char* name, int val); voidSetValue(const char* name, const char* val). private:. boolDoGetValue(const char* name, double& val) const; boolDoGetValue(const char* name, int& val) const; boolDoGetValue(const char* name, string& val) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IOptions(). IOptions * Clone() const; copy the options. void SetValue(const char* name, double val); generic methods for retrivieng options ; set option value. { SetRealValue(name,val);}. void SetValue(const char* name, int val); { SetIntValue(name,val);}. void SetValue(const char* name, const char* val); { SetNamedValue(name,val);}. double RValue(const char* name) const. int IValue(const char* name) const. std::string NamedValue(const char* name) const. boo",MatchSource.WIKI,root/html534/ROOT__Math__IOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IOptions.html
https://root.cern/root/html534/ROOT__Math__IOptions.html:293,Integrability,interface,interface,293,". ROOT::Math::IOptions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IOptions. class ROOT::Math::IOptions. Generic interface for defining configuration options of a numerical algorithm. @ingroup NumAlgo. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~IOptions(); virtual ROOT::Math::IOptions*Clone() const; virtual boolGetIntValue(const char*, int&) const; virtual boolGetNamedValue(const char*, string&) const; virtual boolGetRealValue(const char*, double&) const; intIValue(const char* name) const; stringNamedValue(const char* name) const; ROOT::Math::IOptions&operator=(const ROOT::Math::IOptions&); virtual voidPrint(ostream& = std::cout) const; doubleRValue(const char* name) const; virtual voidSetIntValue(const char*, int); virtual voidSetNamedValue(const char*, const char*); virtual voidSetRealValue(const char*, double); voidSetValue(const char* name, double val); voidSetValue(const char* name, int val); voidSetValue(const char* name, const char* val). private:. boolDoGetValue(const char* name, double& val) const; boolDoGetValue(const char* name, int& val) const; boolDoGetValue(const char* name, string& val) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IOptions(). IOptions * Clone() const; copy the options. void SetValue(const char* name, double val); generic methods for retrivieng options ; set option value. { SetRealValue(name,val);}. void SetValue(const char* name, int val); { SetIntValue(name,val);}. void SetValue(const char* name, const char* val); { SetNamedValue(name,val);}. double RValue(const char* name) const. int IValue(const char* name) const. std::string NamedValue(const char* name) const. boo",MatchSource.WIKI,root/html534/ROOT__Math__IOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IOptions.html
https://root.cern/root/html534/ROOT__Math__IOptions.html:316,Modifiability,config,configuration,316,". ROOT::Math::IOptions. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IOptions. class ROOT::Math::IOptions. Generic interface for defining configuration options of a numerical algorithm. @ingroup NumAlgo. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. virtual~IOptions(); virtual ROOT::Math::IOptions*Clone() const; virtual boolGetIntValue(const char*, int&) const; virtual boolGetNamedValue(const char*, string&) const; virtual boolGetRealValue(const char*, double&) const; intIValue(const char* name) const; stringNamedValue(const char* name) const; ROOT::Math::IOptions&operator=(const ROOT::Math::IOptions&); virtual voidPrint(ostream& = std::cout) const; doubleRValue(const char* name) const; virtual voidSetIntValue(const char*, int); virtual voidSetNamedValue(const char*, const char*); virtual voidSetRealValue(const char*, double); voidSetValue(const char* name, double val); voidSetValue(const char* name, int val); voidSetValue(const char* name, const char* val). private:. boolDoGetValue(const char* name, double& val) const; boolDoGetValue(const char* name, int& val) const; boolDoGetValue(const char* name, string& val) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IOptions(). IOptions * Clone() const; copy the options. void SetValue(const char* name, double val); generic methods for retrivieng options ; set option value. { SetRealValue(name,val);}. void SetValue(const char* name, int val); { SetIntValue(name,val);}. void SetValue(const char* name, const char* val); { SetNamedValue(name,val);}. double RValue(const char* name) const. int IValue(const char* name) const. std::string NamedValue(const char* name) const. boo",MatchSource.WIKI,root/html534/ROOT__Math__IOptions.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IOptions.html
https://root.cern/root/html534/ROOT__Math__IParametricFunctionMultiDim.html:1597,Availability,avail,available,1597,"fining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Math::IParamMultiFunction, ROOT::Fit::Fitter::IModelFunction, ROOT::Fit::FitResult::IModelFunction, ROOT::Math::IParametricGradFunctionMultiDim::BaseParamFunc, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction, ROOT::Fit::Chi2FCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Fit::Chi2FCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. ~IParametricFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(const double* x, const double* p) const; ROOT::Math::IParametricFunctionMultiDim&operator=(const ROOT::Math::IParametricFunctionMultiDim&); virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() const; virtual voidROOT::Math::IBaseParam::SetParameters(const double* p). private:. virtual doubleDoEval(const double* x) const; virtual doubleDoEvalPar(const double* x, const double* p) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; double operator()(const double* x, const double* p) const. Evaluate function at a point x and for given parameters p.; This method d",MatchSource.WIKI,root/html534/ROOT__Math__IParametricFunctionMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IParametricFunctionMultiDim.html
https://root.cern/root/html534/ROOT__Math__IParametricFunctionMultiDim.html:480,Integrability,interface,interface,480,". ROOT::Math::IParametricFunctionMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IParametricFunctionMultiDim. class ROOT::Math::IParametricFunctionMultiDim: public ROOT::Math::IBaseFunctionMultiDim, public ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Math::IParamMultiFunction, ROOT::Fit::Fitter::IModelFunction, ROOT::Fit::FitResult::IModelFunction, ROOT::Math::IParametricGradFunctionMultiDim::BaseParamFunc, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction, ROOT::Fit::Chi2FCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Fit::Chi2FCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. ~IParametricFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(const double* x, const double* p) const; ROOT::Math::IParametricFunctionMultiDim&operator=(const ROOT:",MatchSource.WIKI,root/html534/ROOT__Math__IParametricFunctionMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IParametricFunctionMultiDim.html
https://root.cern/root/html534/ROOT__Math__IParametricFunctionMultiDim.html:2959,Integrability,interface,interface,2959,":Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Fit::Chi2FCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. ~IParametricFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(const double* x, const double* p) const; ROOT::Math::IParametricFunctionMultiDim&operator=(const ROOT::Math::IParametricFunctionMultiDim&); virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() const; virtual voidROOT::Math::IBaseParam::SetParameters(const double* p). private:. virtual doubleDoEval(const double* x) const; virtual doubleDoEvalPar(const double* x, const double* p) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; double operator()(const double* x, const double* p) const. Evaluate function at a point x and for given parameters p.; This method does not change the internal status of the function (internal parameter values).; If for some reason one prefers caching the parameter values, SetParameters(p) and then operator()(x) should be; called.; Use the pure virtual function DoEvalPar to implement it. return DoEvalPar(x, p). double DoEval(const double* x) const. Implement the ROOT::Math::IBaseFunctionMultiDim interface DoEval(x) using the cached parameter values.  Author: L. Moneta Tue Nov 14 14:20:07 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__IParametricFunctionMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IParametricFunctionMultiDim.html
https://root.cern/root/html534/ROOT__Math__IParametricFunctionMultiDim.html:2989,Performance,cache,cached,2989,":Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Fit::Chi2FCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. ~IParametricFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(const double* x, const double* p) const; ROOT::Math::IParametricFunctionMultiDim&operator=(const ROOT::Math::IParametricFunctionMultiDim&); virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() const; virtual voidROOT::Math::IBaseParam::SetParameters(const double* p). private:. virtual doubleDoEval(const double* x) const; virtual doubleDoEvalPar(const double* x, const double* p) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; double operator()(const double* x, const double* p) const. Evaluate function at a point x and for given parameters p.; This method does not change the internal status of the function (internal parameter values).; If for some reason one prefers caching the parameter values, SetParameters(p) and then operator()(x) should be; called.; Use the pure virtual function DoEvalPar to implement it. return DoEvalPar(x, p). double DoEval(const double* x) const. Implement the ROOT::Math::IBaseFunctionMultiDim interface DoEval(x) using the cached parameter values.  Author: L. Moneta Tue Nov 14 14:20:07 2006  Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *;  Last changed: root/mathcore:$Id$  Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html534/ROOT__Math__IParametricFunctionMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IParametricFunctionMultiDim.html
https://root.cern/root/html534/ROOT__Math__IParametricFunctionMultiDim.html:579,Safety,avoid,avoid,579,". ROOT::Math::IParametricFunctionMultiDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IParametricFunctionMultiDim. class ROOT::Math::IParametricFunctionMultiDim: public ROOT::Math::IBaseFunctionMultiDim, public ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Math::IParamMultiFunction, ROOT::Fit::Fitter::IModelFunction, ROOT::Fit::FitResult::IModelFunction, ROOT::Math::IParametricGradFunctionMultiDim::BaseParamFunc, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction, ROOT::Fit::Chi2FCN<ROOT::Math::IBaseFunctionMultiDim>::IModelFunction, ROOT::Fit::Chi2FCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. ~IParametricFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*ROOT::Math::IBaseFunctionMultiDim::Clone() const; virtual unsigned intROOT::Math::IBaseFunctionMultiDim::NDim() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(const double* x, const double* p) const; ROOT::Math::IParametricFunctionMultiDim&operator=(const ROOT:",MatchSource.WIKI,root/html534/ROOT__Math__IParametricFunctionMultiDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IParametricFunctionMultiDim.html
https://root.cern/root/html534/ROOT__Math__IParametricFunctionOneDim.html:1064,Availability,avail,available,1064,"OOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IParametricFunctionOneDim. class ROOT::Math::IParametricFunctionOneDim: public ROOT::Math::IBaseFunctionOneDim, public ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Math::IParamFunction, ROOT::Math::IParametricGradFunctionOneDim::BaseParamFunc, ROOT::Fit::Fitter::IModel1DFunction. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. ~IParametricFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(double x, const double* p) const; doubleoperator()(const double* x, const double* p) const; ROOT::Math::IParametricFunctionOneDim&operator=(const ROOT::Math::IParametricFunctionOneDim&); virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() const; virtual voidROOT::Math::IBaseParam::SetParameters(const double* p). private:. virtual doubleDoEval(double x) const; virtual doubleDoEvalPar(double x, const double* p) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; double operator()(const double* x, const double* p) const. Evaluate function at a point x and for given parameters p.; This method does not change the internal status of the ",MatchSource.WIKI,root/html534/ROOT__Math__IParametricFunctionOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IParametricFunctionOneDim.html
https://root.cern/root/html534/ROOT__Math__IParametricFunctionOneDim.html:472,Integrability,interface,interface,472,". ROOT::Math::IParametricFunctionOneDim. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT;  MATH;  MATHCORE;  ROOT::Math::IParametricFunctionOneDim. class ROOT::Math::IParametricFunctionOneDim: public ROOT::Math::IBaseFunctionOneDim, public ROOT::Math::IBaseParam. Documentation for the abstract class IBaseParam.; It defines the interface for dealing with the function parameters; This is used only for internal convinience, to avoid redefining the Parameter API; for the one and the multi-dim functions.; Concrete class should derive from ROOT::Math::IParamFunction and not from this class. @ingroup ParamFunc. This class is also known as (typedefs to this class)ROOT::Math::IParamFunction, ROOT::Math::IParametricGradFunctionOneDim::BaseParamFunc, ROOT::Fit::Fitter::IModel1DFunction. Function Members (Methods); This is an abstract class, constructors will not be documented.; Look at the header to check for available constructors.; public:. ~IParametricFunctionOneDim(); virtual ROOT::Math::IBaseFunctionOneDim*ROOT::Math::IBaseFunctionOneDim::Clone() const; virtual unsigned intROOT::Math::IBaseParam::NPar() const; doubleoperator()(double x, const double* p) const; doubleoperator()(const double* x, const double* p) const; ROOT::Math::IParametricFunctionOneDim&operator=(const ROOT::Math::IParametricFunctionOneDim&); virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() const; virtual voidROOT::Math::IBaseParam::SetParameters(const double* p). private:. virtual doubleDoEval(double x) const; virtual doubleDoEvalPar(double x, const double* p) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; double operator()(const double* x, const double* p) const. Evaluate function at a point x and for given parameters p.;",MatchSource.WIKI,root/html534/ROOT__Math__IParametricFunctionOneDim.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html534/ROOT__Math__IParametricFunctionOneDim.html
