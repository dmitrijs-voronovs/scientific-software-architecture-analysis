id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:2818,Availability,error,errors,2818,"e C++20 standard these constructs are; well-defined, so activating pedantic mode in C++20 has no effect.). **Examples**. .. code-block:: cpp. static_assert(sizeof(int) == 4, ""assuming 32-bit int""). void basic_examples(int a, int b) {; if (b < 0) {; b = a << b; // warn: right operand is negative in left shift; } else if (b >= 32) {; b = a >> b; // warn: right shift overflows the capacity of 'int'; }; }. int pedantic_examples(int a, int b) {; if (a < 0) {; return a >> b; // warn: left operand is negative in right shift; }; a = 1000u << 31; // OK, overflow of unsigned value is well-defined, a == 0; if (b > 10) {; a = b << 31; // this is undefined before C++20, but the checker doesn't; // warn because it doesn't know the exact value of b; }; return 1000 << 31; // warn: this overflows the capacity of 'int'; }. **Solution**. Ensure the shift operands are in proper range before shifting. .. _core-CallAndMessage:. core.CallAndMessage (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for logical errors for function calls and Objective-C message expressions (e.g., uninitialized arguments, null function pointers). .. literalinclude:: checkers/callandmessage_example.c; :language: objc. .. _core-DivideZero:. core.DivideZero (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for division by zero. .. literalinclude:: checkers/dividezero_example.c; :language: c. .. _core-NonNullParamChecker:. core.NonNullParamChecker (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for null pointers passed as arguments to a function whose arguments are references or marked with the 'nonnull' attribute. .. code-block:: cpp. int f(int *p) __attribute__((nonnull));. void test(int *p) {; if (!p); f(p); // warn; }. .. _core-NullDereference:. core.NullDereference (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for dereferences of null pointers. This checker specifically does; not report null pointer dereferences for x86 and x86-64 targets when the; address space is 256",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:7671,Availability,error,errors,7671,"eturn:. core.uninitialized.UndefReturn (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for uninitialized values being returned to the caller. .. code-block:: c. int test() {; int x;; return x; // warn; }. .. _core-uninitialized-NewArraySize:. core.uninitialized.NewArraySize (C++); """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Check if the element count in new[] is garbage or undefined. .. code-block:: cpp. void test() {; int n;; int *arr = new int[n]; // warn: Element count in new[] is a garbage value; delete[] arr;; }. .. _cplusplus-checkers:. cplusplus; ^^^^^^^^^. C++ Checkers. .. _cplusplus-InnerPointer:. cplusplus.InnerPointer (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for inner pointers of C++ containers used after re/deallocation. Many container methods in the C++ standard library are known to invalidate; ""references"" (including actual references, iterators and raw pointers) to; elements of the container. Using such references after they are invalidated; causes undefined behavior, which is a common source of memory errors in C++ that; this checker is capable of finding. The checker is currently limited to ``std::string`` objects and doesn't; recognize some of the more sophisticated approaches to passing unowned pointers; around, such as ``std::string_view``. .. code-block:: cpp. void deref_after_assignment() {; std::string s = ""llvm"";; const char *c = s.data(); // note: pointer to inner buffer of 'std::string' obtained here; s = ""clang""; // note: inner buffer of 'std::string' reallocated by call to 'operator='; consume(c); // warn: inner pointer of container used after re/deallocation; }. const char *return_temp(int x) {; return std::to_string(x).c_str(); // warn: inner pointer of container used after re/deallocation; // note: pointer to inner buffer of 'std::string' obtained here; // note: inner buffer of 'std::string' deallocated by call to destructor; }. .. _cplusplus-NewDelete:. cplusplus.NewDelete (C++); """"""""""""""""""""""""""""""""""""""""""""""""""; Check for double-free and use-af",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:10822,Availability,error,errors,10822,"e constructor. This checker is capable of checking the `SEI CERT C++ coding rule STR51-CPP.; Do not attempt to create a std::string from a null pointer; <https://wiki.sei.cmu.edu/confluence/x/E3s-BQ>`__. .. code-block:: cpp. #include <string>. void f(const char *p) {; if (!p) {; std::string msg(p); // warn: The parameter must not be null; }; }. .. _deadcode-checkers:. deadcode; ^^^^^^^^. Dead Code Checkers. .. _deadcode-DeadStores:. deadcode.DeadStores (C); """"""""""""""""""""""""""""""""""""""""""""""; Check for values stored to variables that are never read afterwards. .. code-block:: c. void test() {; int x;; x = 1; // warn; }. The ``WarnForDeadNestedAssignments`` option enables the checker to emit; warnings for nested dead assignments. You can disable with the; ``-analyzer-config deadcode.DeadStores:WarnForDeadNestedAssignments=false``.; *Defaults to true*. Would warn for this e.g.:; if ((y = make_int())) {; }. .. _nullability-checkers:. nullability; ^^^^^^^^^^^. Objective C checkers that warn for null pointer passing and dereferencing errors. .. _nullability-NullPassedToNonnull:. nullability.NullPassedToNonnull (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns when a null pointer is passed to a pointer which has a _Nonnull type. .. code-block:: objc. if (name != nil); return;; // Warning: nil passed to a callee that requires a non-null 1st parameter; NSString *greeting = [@""Hello "" stringByAppendingString:name];. .. _nullability-NullReturnedFromNonnull:. nullability.NullReturnedFromNonnull (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns when a null pointer is returned from a function that has _Nonnull return type. .. code-block:: objc. - (nonnull id)firstChild {; id result = nil;; if ([_children count] > 0); result = _children[0];. // Warning: nil returned from a method that is expected; // to return a non-null value; return result;; }. .. _nullability-NullableDereferenced:. nullability.NullableDereferenced (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns when a ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:21030,Availability,error,error,21030,"t+may+invalidate+it>`_ and `ENV34-C <https://wiki.sei.cmu.edu/confluence/display/c/ENV34-C.+Do+not+store+pointers+returned+by+certain+functions>`_. * **ENV31-C**:; Rule is about the possible problem with ``main`` function's third argument, environment pointer,; ""envp"". When environment array is modified using some modification function; such as ``putenv``, ``setenv`` or others, It may happen that memory is reallocated,; however ""envp"" is not updated to reflect the changes and points to old memory; region. * **ENV34-C**:; Some functions return a pointer to a statically allocated buffer.; Consequently, subsequent call of these functions will invalidate previous; pointer. These functions include: ``getenv``, ``localeconv``, ``asctime``, ``setlocale``, ``strerror``. .. code-block:: c. int main(int argc, const char *argv[], const char *envp[]) {; if (setenv(""MY_NEW_VAR"", ""new_value"", 1) != 0) {; // setenv call may invalidate 'envp'; /* Handle error */; }; if (envp != NULL) {; for (size_t i = 0; envp[i] != NULL; ++i) {; puts(envp[i]);; // envp may no longer point to the current environment; // this program has unanticipated behavior, since envp; // does not reflect changes made by setenv function.; }; }; return 0;; }. void previous_call_invalidation() {; char *p, *pp;. p = getenv(""VAR"");; setenv(""SOMEVAR"", ""VALUE"", /*overwrite = */1);; // call to 'setenv' may invalidate p. *p;; // dereferencing invalid pointer; }. The ``InvalidatingGetEnv`` option is available for treating ``getenv`` calls as; invalidating. When enabled, the checker issues a warning if ``getenv`` is called; multiple times and their results are used without first creating a copy.; This level of strictness might be considered overly pedantic for the commonly; used ``getenv`` implementations. To enable this option, use:; ``-analyzer-config security.cert.env.InvalidPtr:InvalidatingGetEnv=true``. By default, this option is set to *false*. When this option is enabled, warnings will be generated for scenarios lik",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:21547,Availability,avail,available,21547,"nd points to old memory; region. * **ENV34-C**:; Some functions return a pointer to a statically allocated buffer.; Consequently, subsequent call of these functions will invalidate previous; pointer. These functions include: ``getenv``, ``localeconv``, ``asctime``, ``setlocale``, ``strerror``. .. code-block:: c. int main(int argc, const char *argv[], const char *envp[]) {; if (setenv(""MY_NEW_VAR"", ""new_value"", 1) != 0) {; // setenv call may invalidate 'envp'; /* Handle error */; }; if (envp != NULL) {; for (size_t i = 0; envp[i] != NULL; ++i) {; puts(envp[i]);; // envp may no longer point to the current environment; // this program has unanticipated behavior, since envp; // does not reflect changes made by setenv function.; }; }; return 0;; }. void previous_call_invalidation() {; char *p, *pp;. p = getenv(""VAR"");; setenv(""SOMEVAR"", ""VALUE"", /*overwrite = */1);; // call to 'setenv' may invalidate p. *p;; // dereferencing invalid pointer; }. The ``InvalidatingGetEnv`` option is available for treating ``getenv`` calls as; invalidating. When enabled, the checker issues a warning if ``getenv`` is called; multiple times and their results are used without first creating a copy.; This level of strictness might be considered overly pedantic for the commonly; used ``getenv`` implementations. To enable this option, use:; ``-analyzer-config security.cert.env.InvalidPtr:InvalidatingGetEnv=true``. By default, this option is set to *false*. When this option is enabled, warnings will be generated for scenarios like the; following:. .. code-block:: c. char* p = getenv(""VAR"");; char* pp = getenv(""VAR2""); // assumes this call can invalidate `env`; strlen(p); // warns about accessing invalid ptr. .. _security-FloatLoopCounter:. security.FloatLoopCounter (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on using a floating point value as a loop counter (CERT: FLP30-C, FLP30-CPP). .. code-block:: c. void test() {; for (float x = 0.1f; x <= 1.0f; x += 0.1f) {} // warn; }. .. _security-insecureAPI-U",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:24462,Availability,avail,available,24462,"; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'getpw' function. .. code-block:: c. void test() {; char buff[1024];; getpw(2, buff); // warn; }. .. _security-insecureAPI-gets:. security.insecureAPI.gets (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'gets' function. .. code-block:: c. void test() {; char buff[1024];; gets(buff); // warn; }. .. _security-insecureAPI-mkstemp:. security.insecureAPI.mkstemp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn when 'mkstemp' is passed fewer than 6 X's in the format string. .. code-block:: c. void test() {; mkstemp(""XX""); // warn; }. .. _security-insecureAPI-mktemp:. security.insecureAPI.mktemp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the ``mktemp`` function. .. code-block:: c. void test() {; char *x = mktemp(""/tmp/zxcv""); // warn: insecure, use mkstemp; }. .. _security-insecureAPI-rand:. security.insecureAPI.rand (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of inferior random number generating functions (only if arc4random function is available):; ``drand48, erand48, jrand48, lcong48, lrand48, mrand48, nrand48, random, rand_r``. .. code-block:: c. void test() {; random(); // warn; }. .. _security-insecureAPI-strcpy:. security.insecureAPI.strcpy (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the ``strcpy`` and ``strcat`` functions. .. code-block:: c. void test() {; char x[4];; char *y = ""abcd"";. strcpy(x, y); // warn; }. .. _security-insecureAPI-vfork:. security.insecureAPI.vfork (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'vfork' function. .. code-block:: c. void test() {; vfork(); // warn; }. .. _security-insecureAPI-DeprecatedOrUnsafeBufferHandling:. security.insecureAPI.DeprecatedOrUnsafeBufferHandling (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on occurrences of unsafe or deprecated buffer handling functions, which now have a secure variant: ``sprintf, fprintf, vsprintf, scanf, wscanf, fscanf, fwscanf, vscanf, vwscanf, vfscanf, vfwscanf, sscanf, sws",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:26181,Availability,failure,failure,26181,"nsecureAPI.DeprecatedOrUnsafeBufferHandling (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on occurrences of unsafe or deprecated buffer handling functions, which now have a secure variant: ``sprintf, fprintf, vsprintf, scanf, wscanf, fscanf, fwscanf, vscanf, vwscanf, vfscanf, vfwscanf, sscanf, swscanf, vsscanf, vswscanf, swprintf, snprintf, vswprintf, vsnprintf, memcpy, memmove, strncpy, strncat, memset``. .. code-block:: c. void test() {; char buf [5];; strncpy(buf, ""a"", 1); // warn; }. .. _unix-checkers:. unix; ^^^^; POSIX/Unix checkers. .. _unix-API:. unix.API (C); """"""""""""""""""""""""; Check calls to various UNIX/Posix functions: ``open, pthread_once, calloc, malloc, realloc, alloca``. .. literalinclude:: checkers/unix_api_example.c; :language: c. .. _unix-Errno:. unix.Errno (C); """""""""""""""""""""""""""". Check for improper use of ``errno``.; This checker implements partially CERT rule; `ERR30-C. Set errno to zero before calling a library function known to set errno,; and check errno only after the function returns a value indicating failure; <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152351>`_.; The checker can find the first read of ``errno`` after successful standard; function calls. The C and POSIX standards often do not define if a standard library function; may change value of ``errno`` if the call does not fail.; Therefore, ``errno`` should only be used if it is known from the return value; of a function that the call has failed.; There are exceptions to this rule (for example ``strtol``) but the affected; functions are not yet supported by the checker.; The return values for the failure cases are documented in the standard Linux man; pages of the functions and in the `POSIX standard <https://pubs.opengroup.org/onlinepubs/9699919799/>`_. .. code-block:: c. int unsafe_errno_read(int sock, void *data, int data_size) {; if (send(sock, data, data_size, 0) != data_size) {; // 'send' can be successful even if not all data was sent;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:26770,Availability,failure,failure,26770," realloc, alloca``. .. literalinclude:: checkers/unix_api_example.c; :language: c. .. _unix-Errno:. unix.Errno (C); """""""""""""""""""""""""""". Check for improper use of ``errno``.; This checker implements partially CERT rule; `ERR30-C. Set errno to zero before calling a library function known to set errno,; and check errno only after the function returns a value indicating failure; <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152351>`_.; The checker can find the first read of ``errno`` after successful standard; function calls. The C and POSIX standards often do not define if a standard library function; may change value of ``errno`` if the call does not fail.; Therefore, ``errno`` should only be used if it is known from the return value; of a function that the call has failed.; There are exceptions to this rule (for example ``strtol``) but the affected; functions are not yet supported by the checker.; The return values for the failure cases are documented in the standard Linux man; pages of the functions and in the `POSIX standard <https://pubs.opengroup.org/onlinepubs/9699919799/>`_. .. code-block:: c. int unsafe_errno_read(int sock, void *data, int data_size) {; if (send(sock, data, data_size, 0) != data_size) {; // 'send' can be successful even if not all data was sent; if (errno == 1) { // An undefined value may be read from 'errno'; return 0;; }; }; return 1;; }. The checker :ref:`unix-StdCLibraryFunctions` must be turned on to get the; warnings from this checker. The supported functions are the same as by; :ref:`unix-StdCLibraryFunctions`. The ``ModelPOSIX`` option of that; checker affects the set of checked functions. **Parameters**. The ``AllowErrnoReadOutsideConditionExpressions`` option allows read of the; errno value if the value is not used in a condition (in ``if`` statements,; loops, conditional expressions, ``switch`` statements). For example ``errno``; can be stored into a variable without getting a warning by the checker. .. code-block:",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:28206,Availability,error,error,28206,"o'; return 0;; }; }; return 1;; }. The checker :ref:`unix-StdCLibraryFunctions` must be turned on to get the; warnings from this checker. The supported functions are the same as by; :ref:`unix-StdCLibraryFunctions`. The ``ModelPOSIX`` option of that; checker affects the set of checked functions. **Parameters**. The ``AllowErrnoReadOutsideConditionExpressions`` option allows read of the; errno value if the value is not used in a condition (in ``if`` statements,; loops, conditional expressions, ``switch`` statements). For example ``errno``; can be stored into a variable without getting a warning by the checker. .. code-block:: c. int unsafe_errno_read(int sock, void *data, int data_size) {; if (send(sock, data, data_size, 0) != data_size) {; int err = errno;; // warning if 'AllowErrnoReadOutsideConditionExpressions' is false; // no warning if 'AllowErrnoReadOutsideConditionExpressions' is true; }; return 1;; }. Default value of this option is ``true``. This allows save of the errno value; for possible later error handling. **Limitations**. - Only the very first usage of ``errno`` is checked after an affected function; call. Value of ``errno`` is not followed when it is stored into a variable; or returned from a function.; - Documentation of function ``lseek`` is not clear about what happens if the; function returns different value than the expected file position but not -1.; To avoid possible false-positives ``errno`` is allowed to be used in this; case. .. _unix-Malloc:. unix.Malloc (C); """"""""""""""""""""""""""""""; Check for memory leaks, double free, and use-after-free problems. Traces memory managed by malloc()/free(). .. literalinclude:: checkers/unix_malloc_example.c; :language: c. .. _unix-MallocSizeof:. unix.MallocSizeof (C); """"""""""""""""""""""""""""""""""""""""""; Check for dubious ``malloc`` arguments involving ``sizeof``. .. code-block:: c. void test() {; long *p = malloc(sizeof(short));; // warn: result is converted to 'long *', which is; // incompatible with operand type 'short'; fre",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:33705,Availability,error,error,33705," ret = isalnum(256); // \; // warning: Function argument outside of allowed range; (void)ret;; }. void buffer_size_violation(FILE *file) {; enum { BUFFER_SIZE = 1024 };; wchar_t wbuf[BUFFER_SIZE];. const size_t size = sizeof(*wbuf); // 4; const size_t nitems = sizeof(wbuf); // 4096. // Below we receive a warning because the 3rd parameter should be the; // number of elements to read, not the size in bytes. This case is a known; // vulnerability described by the ARR38-C SEI-CERT rule.; fread(wbuf, size, nitems, file);; }. int test_alnum_symbolic(int x) {; int ret = isalnum(x);; // after the call, ret is assumed to be in the range [-1, 255]. if (ret > 255) // impossible (infeasible branch); if (x == 0); return ret / x; // division by zero is not reported; return ret;; }. Additionally to the argument and return value conditions, this checker also adds; state of the value ``errno`` if applicable to the analysis. Many system; functions set the ``errno`` value only if an error occurs (together with a; specific return value of the function), otherwise it becomes undefined. This; checker changes the analysis state to contain such information. This data is; used by other checkers, for example :ref:`unix-Errno`. **Limitations**. The checker can not always provide notes about the values of the arguments.; Without this information it is hard to confirm if the constraint is indeed; violated. The argument values are shown if they are known constants or the value; is determined by previous (not too complicated) assumptions. The checker can produce false positives in cases such as if the program has; invariants not known to the analyzer engine or the bug report path contains; calls to unknown functions. In these cases the analyzer fails to detect the real; range of the argument. **Parameters**. The checker models functions (and emits diagnostics) from the C standard by; default. The ``ModelPOSIX`` option enables modeling (and emit diagnostics) of; additional functions that are define",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:38413,Availability,error,error,38413,"ace MyClass2 : MyClass1; - (float)foo;; @end. @implementation MyClass2; - (float)foo { return 1.0; } // warn; @end. .. _osx-cocoa-Loops:. osx.cocoa.Loops; """"""""""""""""""""""""""""""; Improved modeling of loops using Cocoa collection types. .. _osx-cocoa-MissingSuperCall:. osx.cocoa.MissingSuperCall (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C methods that lack a necessary call to super. .. code-block:: objc. @interface Test : UIViewController; @end; @implementation test; - (void)viewDidLoad {} // warn; @end. .. _osx-cocoa-NSAutoreleasePool:. osx.cocoa.NSAutoreleasePool (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn for suboptimal uses of NSAutoreleasePool in Objective-C GC mode. .. code-block:: objc. void test() {; NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];; [pool release]; // warn; }. .. _osx-cocoa-NSError:. osx.cocoa.NSError (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""; Check usage of NSError parameters. .. code-block:: objc. @interface A : NSObject; - (void)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error;; @end. @implementation A; - (void)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error {; // warn: method accepting NSError"""""""""""""""""""""""""""""""""""""""""""""""" should have a non-void; // return value; }; @end. @interface A : NSObject; - (BOOL)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error;; @end. @implementation A; - (BOOL)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error {; *error = 0; // warn: potential null dereference; return 0;; }; @end. .. _osx-cocoa-NilArg:. osx.cocoa.NilArg (ObjC); """"""""""""""""""""""""""""""""""""""""""""""; Check for prohibited nil arguments to ObjC method calls. - caseInsensitiveCompare:; - compare:; - compare:options:; - compare:options:range:; - compare:options:range:locale:; - componentsSeparatedByCharactersInSet:; - initWithFormat:. .. code-block:: objc. NSComparisonResult test(NSString *s) {; NSString *aString = nil;; return [s caseInsensitiveCompare:aString];; // warn: argument to 'NSString' method; // 'caseInsensitiveCompare:' cannot be nil; }. .. _osx-cocoa-NonNil",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:38492,Availability,error,error,38492,"s:. osx.cocoa.Loops; """"""""""""""""""""""""""""""; Improved modeling of loops using Cocoa collection types. .. _osx-cocoa-MissingSuperCall:. osx.cocoa.MissingSuperCall (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C methods that lack a necessary call to super. .. code-block:: objc. @interface Test : UIViewController; @end; @implementation test; - (void)viewDidLoad {} // warn; @end. .. _osx-cocoa-NSAutoreleasePool:. osx.cocoa.NSAutoreleasePool (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn for suboptimal uses of NSAutoreleasePool in Objective-C GC mode. .. code-block:: objc. void test() {; NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];; [pool release]; // warn; }. .. _osx-cocoa-NSError:. osx.cocoa.NSError (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""; Check usage of NSError parameters. .. code-block:: objc. @interface A : NSObject; - (void)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error;; @end. @implementation A; - (void)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error {; // warn: method accepting NSError"""""""""""""""""""""""""""""""""""""""""""""""" should have a non-void; // return value; }; @end. @interface A : NSObject; - (BOOL)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error;; @end. @implementation A; - (BOOL)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error {; *error = 0; // warn: potential null dereference; return 0;; }; @end. .. _osx-cocoa-NilArg:. osx.cocoa.NilArg (ObjC); """"""""""""""""""""""""""""""""""""""""""""""; Check for prohibited nil arguments to ObjC method calls. - caseInsensitiveCompare:; - compare:; - compare:options:; - compare:options:range:; - compare:options:range:locale:; - componentsSeparatedByCharactersInSet:; - initWithFormat:. .. code-block:: objc. NSComparisonResult test(NSString *s) {; NSString *aString = nil;; return [s caseInsensitiveCompare:aString];; // warn: argument to 'NSString' method; // 'caseInsensitiveCompare:' cannot be nil; }. .. _osx-cocoa-NonNilReturnValue:. osx.cocoa.NonNilReturnValue; """"""""""""""""""""""""""""""""""""""""""""""""""""""; Models the APIs that are guaranteed to return a non-nil value",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:38680,Availability,error,error,38680,"ocoa.MissingSuperCall (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C methods that lack a necessary call to super. .. code-block:: objc. @interface Test : UIViewController; @end; @implementation test; - (void)viewDidLoad {} // warn; @end. .. _osx-cocoa-NSAutoreleasePool:. osx.cocoa.NSAutoreleasePool (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn for suboptimal uses of NSAutoreleasePool in Objective-C GC mode. .. code-block:: objc. void test() {; NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];; [pool release]; // warn; }. .. _osx-cocoa-NSError:. osx.cocoa.NSError (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""; Check usage of NSError parameters. .. code-block:: objc. @interface A : NSObject; - (void)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error;; @end. @implementation A; - (void)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error {; // warn: method accepting NSError"""""""""""""""""""""""""""""""""""""""""""""""" should have a non-void; // return value; }; @end. @interface A : NSObject; - (BOOL)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error;; @end. @implementation A; - (BOOL)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error {; *error = 0; // warn: potential null dereference; return 0;; }; @end. .. _osx-cocoa-NilArg:. osx.cocoa.NilArg (ObjC); """"""""""""""""""""""""""""""""""""""""""""""; Check for prohibited nil arguments to ObjC method calls. - caseInsensitiveCompare:; - compare:; - compare:options:; - compare:options:range:; - compare:options:range:locale:; - componentsSeparatedByCharactersInSet:; - initWithFormat:. .. code-block:: objc. NSComparisonResult test(NSString *s) {; NSString *aString = nil;; return [s caseInsensitiveCompare:aString];; // warn: argument to 'NSString' method; // 'caseInsensitiveCompare:' cannot be nil; }. .. _osx-cocoa-NonNilReturnValue:. osx.cocoa.NonNilReturnValue; """"""""""""""""""""""""""""""""""""""""""""""""""""""; Models the APIs that are guaranteed to return a non-nil value. .. _osx-cocoa-ObjCGenerics:. osx.cocoa.ObjCGenerics (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for type errors when using Objectiv",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:38759,Availability,error,error,38759,"ary call to super. .. code-block:: objc. @interface Test : UIViewController; @end; @implementation test; - (void)viewDidLoad {} // warn; @end. .. _osx-cocoa-NSAutoreleasePool:. osx.cocoa.NSAutoreleasePool (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn for suboptimal uses of NSAutoreleasePool in Objective-C GC mode. .. code-block:: objc. void test() {; NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];; [pool release]; // warn; }. .. _osx-cocoa-NSError:. osx.cocoa.NSError (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""; Check usage of NSError parameters. .. code-block:: objc. @interface A : NSObject; - (void)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error;; @end. @implementation A; - (void)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error {; // warn: method accepting NSError"""""""""""""""""""""""""""""""""""""""""""""""" should have a non-void; // return value; }; @end. @interface A : NSObject; - (BOOL)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error;; @end. @implementation A; - (BOOL)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error {; *error = 0; // warn: potential null dereference; return 0;; }; @end. .. _osx-cocoa-NilArg:. osx.cocoa.NilArg (ObjC); """"""""""""""""""""""""""""""""""""""""""""""; Check for prohibited nil arguments to ObjC method calls. - caseInsensitiveCompare:; - compare:; - compare:options:; - compare:options:range:; - compare:options:range:locale:; - componentsSeparatedByCharactersInSet:; - initWithFormat:. .. code-block:: objc. NSComparisonResult test(NSString *s) {; NSString *aString = nil;; return [s caseInsensitiveCompare:aString];; // warn: argument to 'NSString' method; // 'caseInsensitiveCompare:' cannot be nil; }. .. _osx-cocoa-NonNilReturnValue:. osx.cocoa.NonNilReturnValue; """"""""""""""""""""""""""""""""""""""""""""""""""""""; Models the APIs that are guaranteed to return a non-nil value. .. _osx-cocoa-ObjCGenerics:. osx.cocoa.ObjCGenerics (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for type errors when using Objective-C generics. .. code-block:: objc. NSMutableArray *names = [NSMutableArray array];; NSMutableArray *birthDates = ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:38769,Availability,error,error,38769,"ary call to super. .. code-block:: objc. @interface Test : UIViewController; @end; @implementation test; - (void)viewDidLoad {} // warn; @end. .. _osx-cocoa-NSAutoreleasePool:. osx.cocoa.NSAutoreleasePool (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn for suboptimal uses of NSAutoreleasePool in Objective-C GC mode. .. code-block:: objc. void test() {; NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];; [pool release]; // warn; }. .. _osx-cocoa-NSError:. osx.cocoa.NSError (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""; Check usage of NSError parameters. .. code-block:: objc. @interface A : NSObject; - (void)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error;; @end. @implementation A; - (void)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error {; // warn: method accepting NSError"""""""""""""""""""""""""""""""""""""""""""""""" should have a non-void; // return value; }; @end. @interface A : NSObject; - (BOOL)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error;; @end. @implementation A; - (BOOL)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error {; *error = 0; // warn: potential null dereference; return 0;; }; @end. .. _osx-cocoa-NilArg:. osx.cocoa.NilArg (ObjC); """"""""""""""""""""""""""""""""""""""""""""""; Check for prohibited nil arguments to ObjC method calls. - caseInsensitiveCompare:; - compare:; - compare:options:; - compare:options:range:; - compare:options:range:locale:; - componentsSeparatedByCharactersInSet:; - initWithFormat:. .. code-block:: objc. NSComparisonResult test(NSString *s) {; NSString *aString = nil;; return [s caseInsensitiveCompare:aString];; // warn: argument to 'NSString' method; // 'caseInsensitiveCompare:' cannot be nil; }. .. _osx-cocoa-NonNilReturnValue:. osx.cocoa.NonNilReturnValue; """"""""""""""""""""""""""""""""""""""""""""""""""""""; Models the APIs that are guaranteed to return a non-nil value. .. _osx-cocoa-ObjCGenerics:. osx.cocoa.ObjCGenerics (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for type errors when using Objective-C generics. .. code-block:: objc. NSMutableArray *names = [NSMutableArray array];; NSMutableArray *birthDates = ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:39625,Availability,error,errors,39625,"nterface A : NSObject; - (BOOL)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error;; @end. @implementation A; - (BOOL)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error {; *error = 0; // warn: potential null dereference; return 0;; }; @end. .. _osx-cocoa-NilArg:. osx.cocoa.NilArg (ObjC); """"""""""""""""""""""""""""""""""""""""""""""; Check for prohibited nil arguments to ObjC method calls. - caseInsensitiveCompare:; - compare:; - compare:options:; - compare:options:range:; - compare:options:range:locale:; - componentsSeparatedByCharactersInSet:; - initWithFormat:. .. code-block:: objc. NSComparisonResult test(NSString *s) {; NSString *aString = nil;; return [s caseInsensitiveCompare:aString];; // warn: argument to 'NSString' method; // 'caseInsensitiveCompare:' cannot be nil; }. .. _osx-cocoa-NonNilReturnValue:. osx.cocoa.NonNilReturnValue; """"""""""""""""""""""""""""""""""""""""""""""""""""""; Models the APIs that are guaranteed to return a non-nil value. .. _osx-cocoa-ObjCGenerics:. osx.cocoa.ObjCGenerics (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for type errors when using Objective-C generics. .. code-block:: objc. NSMutableArray *names = [NSMutableArray array];; NSMutableArray *birthDates = names;. // Warning: Conversion from value of type 'NSDate *'; // to incompatible type 'NSString *'; [birthDates addObject: [NSDate date]];. .. _osx-cocoa-RetainCount:. osx.cocoa.RetainCount (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for leaks and improper reference count management. .. code-block:: objc. void test() {; NSString *s = [[NSString alloc] init]; // warn; }. CFStringRef test(char *bytes) {; return CFStringCreateWithCStringNoCopy(; 0, bytes, NSNEXTSTEPStringEncoding, 0); // warn; }. .. _osx-cocoa-RunLoopAutoreleaseLeak:. osx.cocoa.RunLoopAutoreleaseLeak; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for leaked memory in autorelease pools that will never be drained. .. _osx-cocoa-SelfInit:. osx.cocoa.SelfInit (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""; Check that 'self' is properly initialized inside an initializer method. .. code-block:: ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:42179,Availability,error,error,42179,"bject {; NSObject *_ivar;; }; @end. @implementation SuperDeallocThenReleaseIvarClass; - (void)dealloc {; [super dealloc];; [_ivar release]; // warn; }; @end. .. _osx-cocoa-UnusedIvars:. osx.cocoa.UnusedIvars (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about private ivars that are never used. .. code-block:: objc. @interface MyObj : NSObject {; @private; id x; // warn; }; @end. @implementation MyObj; @end. .. _osx-cocoa-VariadicMethodTypes:. osx.cocoa.VariadicMethodTypes (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for passing non-Objective-C types to variadic collection; initialization methods that expect only Objective-C types. .. code-block:: objc. void test() {; [NSSet setWithObjects:@""Foo"", ""Bar"", nil];; // warn: argument should be an ObjC pointer type, not 'char *'; }. .. _osx-coreFoundation-CFError:. osx.coreFoundation.CFError (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check usage of CFErrorRef* parameters. .. code-block:: c. void test(CFErrorRef *error) {; // warn: function accepting CFErrorRef* should have a; // non-void return; }. int foo(CFErrorRef *error) {; *error = 0; // warn: potential null dereference; return 0;; }. .. _osx-coreFoundation-CFNumber:. osx.coreFoundation.CFNumber (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for proper uses of CFNumber APIs. .. code-block:: c. CFNumberRef test(unsigned char x) {; return CFNumberCreate(0, kCFNumberSInt16Type, &x);; // warn: 8 bit integer is used to initialize a 16 bit integer; }. .. _osx-coreFoundation-CFRetainRelease:. osx.coreFoundation.CFRetainRelease (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for null arguments to CFRetain/CFRelease/CFMakeCollectable. .. code-block:: c. void test(CFTypeRef p) {; if (!p); CFRetain(p); // warn; }. void test(int x, CFTypeRef p) {; if (p); return;. CFRelease(p); // warn; }. .. _osx-coreFoundation-containers-OutOfBounds:. osx.coreFoundation.containers.OutOfBounds (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Checks for index out-of-bounds when using 'CFArray' A",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:42287,Availability,error,error,42287," {; [super dealloc];; [_ivar release]; // warn; }; @end. .. _osx-cocoa-UnusedIvars:. osx.cocoa.UnusedIvars (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about private ivars that are never used. .. code-block:: objc. @interface MyObj : NSObject {; @private; id x; // warn; }; @end. @implementation MyObj; @end. .. _osx-cocoa-VariadicMethodTypes:. osx.cocoa.VariadicMethodTypes (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for passing non-Objective-C types to variadic collection; initialization methods that expect only Objective-C types. .. code-block:: objc. void test() {; [NSSet setWithObjects:@""Foo"", ""Bar"", nil];; // warn: argument should be an ObjC pointer type, not 'char *'; }. .. _osx-coreFoundation-CFError:. osx.coreFoundation.CFError (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check usage of CFErrorRef* parameters. .. code-block:: c. void test(CFErrorRef *error) {; // warn: function accepting CFErrorRef* should have a; // non-void return; }. int foo(CFErrorRef *error) {; *error = 0; // warn: potential null dereference; return 0;; }. .. _osx-coreFoundation-CFNumber:. osx.coreFoundation.CFNumber (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for proper uses of CFNumber APIs. .. code-block:: c. CFNumberRef test(unsigned char x) {; return CFNumberCreate(0, kCFNumberSInt16Type, &x);; // warn: 8 bit integer is used to initialize a 16 bit integer; }. .. _osx-coreFoundation-CFRetainRelease:. osx.coreFoundation.CFRetainRelease (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for null arguments to CFRetain/CFRelease/CFMakeCollectable. .. code-block:: c. void test(CFTypeRef p) {; if (!p); CFRetain(p); // warn; }. void test(int x, CFTypeRef p) {; if (p); return;. CFRelease(p); // warn; }. .. _osx-coreFoundation-containers-OutOfBounds:. osx.coreFoundation.containers.OutOfBounds (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Checks for index out-of-bounds when using 'CFArray' API. .. code-block:: c. void test() {; CFArrayRef A = CFArrayCreate(0, 0, 0, &kCFTypeArrayCallBacks);; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:42298,Availability,error,error,42298," {; [super dealloc];; [_ivar release]; // warn; }; @end. .. _osx-cocoa-UnusedIvars:. osx.cocoa.UnusedIvars (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about private ivars that are never used. .. code-block:: objc. @interface MyObj : NSObject {; @private; id x; // warn; }; @end. @implementation MyObj; @end. .. _osx-cocoa-VariadicMethodTypes:. osx.cocoa.VariadicMethodTypes (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for passing non-Objective-C types to variadic collection; initialization methods that expect only Objective-C types. .. code-block:: objc. void test() {; [NSSet setWithObjects:@""Foo"", ""Bar"", nil];; // warn: argument should be an ObjC pointer type, not 'char *'; }. .. _osx-coreFoundation-CFError:. osx.coreFoundation.CFError (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check usage of CFErrorRef* parameters. .. code-block:: c. void test(CFErrorRef *error) {; // warn: function accepting CFErrorRef* should have a; // non-void return; }. int foo(CFErrorRef *error) {; *error = 0; // warn: potential null dereference; return 0;; }. .. _osx-coreFoundation-CFNumber:. osx.coreFoundation.CFNumber (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for proper uses of CFNumber APIs. .. code-block:: c. CFNumberRef test(unsigned char x) {; return CFNumberCreate(0, kCFNumberSInt16Type, &x);; // warn: 8 bit integer is used to initialize a 16 bit integer; }. .. _osx-coreFoundation-CFRetainRelease:. osx.coreFoundation.CFRetainRelease (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for null arguments to CFRetain/CFRelease/CFMakeCollectable. .. code-block:: c. void test(CFTypeRef p) {; if (!p); CFRetain(p); // warn; }. void test(int x, CFTypeRef p) {; if (p); return;. CFRelease(p); // warn; }. .. _osx-coreFoundation-containers-OutOfBounds:. osx.coreFoundation.containers.OutOfBounds (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Checks for index out-of-bounds when using 'CFArray' API. .. code-block:: c. void test() {; CFArrayRef A = CFArrayCreate(0, 0, 0, &kCFTypeArrayCallBacks);; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:44457,Availability,avail,available,44457,"Values (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns if 'CFArray', 'CFDictionary', 'CFSet' are created with non-pointer-size values. .. code-block:: c. void test() {; int x[] = { 1 };; CFArrayRef A = CFArrayCreate(0, (const void """""""""""""""""""""""""""""""""""""""""""""""")x, 1,; &kCFTypeArrayCallBacks); // warn; }. Fuchsia; ^^^^^^^. Fuchsia is an open source capability-based operating system currently being; developed by Google. This section describes checkers that can find various; misuses of Fuchsia APIs. .. _fuchsia-HandleChecker:. fuchsia.HandleChecker; """"""""""""""""""""""""""""""""""""""""""""""""""""""""; Handles identify resources. Similar to pointers they can be leaked,; double freed, or use after freed. This check attempts to find such problems. .. code-block:: cpp. void checkLeak08(int tag) {; zx_handle_t sa, sb;; zx_channel_create(0, &sa, &sb);; if (tag); zx_handle_close(sa);; use(sb); // Warn: Potential leak of handle; zx_handle_close(sb);; }. WebKit; ^^^^^^. WebKit is an open-source web browser engine available for macOS, iOS and Linux.; This section describes checkers that can find issues in WebKit codebase. Most of the checkers focus on memory management for which WebKit uses custom implementation of reference counted smartpointers. Checkers are formulated in terms related to ref-counting:; - *Ref-counted type* is either ``Ref<T>`` or ``RefPtr<T>``.; - *Ref-countable type* is any type that implements ``ref()`` and ``deref()`` methods as ``RefPtr<>`` is a template (i. e. relies on duck typing).; - *Uncounted type* is ref-countable but not ref-counted type. .. _webkit-RefCntblBaseVirtualDtor:. webkit.RefCntblBaseVirtualDtor; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; All uncounted types used as base classes must have a virtual destructor. Ref-counted types hold their ref-countable data by a raw pointer and allow implicit upcasting from ref-counted pointer to derived type to ref-counted pointer to base type. This might lead to an object of (dynamic) derived type being deleted via poi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:47881,Availability,error,errors,47881,"); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Reports similar pieces of code. .. code-block:: c. void log();. int max(int a, int b) { // warn; log();; if (a > b); return a;; return b;; }. int maxClone(int x, int y) { // similar code here; log();; if (x > y); return x;; return y;; }. alpha.core; ^^^^^^^^^^. .. _alpha-core-BoolAssignment:. alpha.core.BoolAssignment (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about assigning non-{0,1} values to boolean variables. .. code-block:: objc. void test() {; BOOL b = -1; // warn; }. .. _alpha-core-C11Lock:. alpha.core.C11Lock; """"""""""""""""""""""""""""""""""""; Similarly to :ref:`alpha.unix.PthreadLock <alpha-unix-PthreadLock>`, checks for; the locking/unlocking of ``mtx_t`` mutexes. .. code-block:: cpp. mtx_t mtx1;. void bad1(void); {; mtx_lock(&mtx1);; mtx_lock(&mtx1); // warn: This lock has already been acquired; }. .. _alpha-core-CallAndMessageUnInitRefArg:. alpha.core.CallAndMessageUnInitRefArg (C,C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for logical errors for function calls and Objective-C; message expressions (e.g., uninitialized arguments, null function pointers, and pointer to undefined variables). .. code-block:: c. void test(void) {; int t;; int &p = t;; int &s = p;; int &q = s;; foo(q); // warn; }. void test(void) {; int x;; foo(&x); // warn; }. .. _alpha-core-CastSize:. alpha.core.CastSize (C); """"""""""""""""""""""""""""""""""""""""""""""; Check when casting a malloc'ed type ``T``, whether the size is a multiple of the size of ``T``. .. code-block:: c. void test() {; int *x = (int *) malloc(11); // warn; }. .. _alpha-core-CastToStruct:. alpha.core.CastToStruct (C, C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for cast from non-struct pointer to struct pointer. .. code-block:: cpp. // C; struct s {};. void test(int *p) {; struct s *ps = (struct s *) p; // warn; }. // C++; class c {};. void test(int *p) {; c *pc = (c *) p; // warn; }. .. _alpha-core-Conversion:. alpha.core.Conversion (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:63694,Availability,error,errors,63694,"ultiplication operation. - It is an AST-based checker, thus it does not make use of the; path-sensitive taint-analysis. .. _alpha-security-MmapWriteExec:. alpha.security.MmapWriteExec (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on mmap() calls that are both writable and executable. .. code-block:: c. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. .. _alpha-security-ReturnPtrRange:. alpha.security.ReturnPtrRange (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for an out-of-bound pointer being returned to callers. .. code-block:: c. static int A[10];. int *test() {; int *p = A + 10;; return p; // warn; }. int test(void) {; int x;; return x; // warn: undefined or garbage returned; }. alpha.security.cert; ^^^^^^^^^^^^^^^^^^^. SEI CERT checkers which tries to find errors based on their `C coding rules <https://wiki.sei.cmu.edu/confluence/display/c/2+Rules>`_. .. _alpha-security-cert-pos-checkers:. alpha.security.cert.pos; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `POSIX C coding rules <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152405>`_. .. _alpha-security-cert-pos-34c:. alpha.security.cert.pos.34c; """"""""""""""""""""""""""""""""""""""""""""""""""""""; Finds calls to the ``putenv`` function which pass a pointer to an automatic variable as the argument. .. code-block:: c. int func(const char *var) {; char env[1024];; int retval = snprintf(env, sizeof(env),""TEST=%s"", var);; if (retval < 0 || (size_t)retval >= sizeof(env)) {; /* Handle error */; }. return putenv(env); // putenv function should not be called with auto variables; }. Limitations:. - Technically, one can pass automatic variables to ``putenv``,; but one needs to ensure that the given environment key stays; alive until it's removed or overwritten.; Since the analyzer cannot keep track of wh",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:64380,Availability,error,error,64380,"Range:. alpha.security.ReturnPtrRange (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for an out-of-bound pointer being returned to callers. .. code-block:: c. static int A[10];. int *test() {; int *p = A + 10;; return p; // warn; }. int test(void) {; int x;; return x; // warn: undefined or garbage returned; }. alpha.security.cert; ^^^^^^^^^^^^^^^^^^^. SEI CERT checkers which tries to find errors based on their `C coding rules <https://wiki.sei.cmu.edu/confluence/display/c/2+Rules>`_. .. _alpha-security-cert-pos-checkers:. alpha.security.cert.pos; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `POSIX C coding rules <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152405>`_. .. _alpha-security-cert-pos-34c:. alpha.security.cert.pos.34c; """"""""""""""""""""""""""""""""""""""""""""""""""""""; Finds calls to the ``putenv`` function which pass a pointer to an automatic variable as the argument. .. code-block:: c. int func(const char *var) {; char env[1024];; int retval = snprintf(env, sizeof(env),""TEST=%s"", var);; if (retval < 0 || (size_t)retval >= sizeof(env)) {; /* Handle error */; }. return putenv(env); // putenv function should not be called with auto variables; }. Limitations:. - Technically, one can pass automatic variables to ``putenv``,; but one needs to ensure that the given environment key stays; alive until it's removed or overwritten.; Since the analyzer cannot keep track of which envvars get overwritten; and when, it needs to be slightly more aggressive and warn for such; cases too, leading in some cases to false-positive reports like this:. .. code-block:: c. void baz() {; char env[] = ""NAME=value"";; putenv(env); // false-positive warning: putenv function should not be called...; // More code...; putenv((char *)""NAME=anothervalue"");; // This putenv call overwrites the previous entry, thus that can no longer dangle.; } // 'env' array becomes dead only here. alpha.security.cert.env; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `Environment C coding rules <https://wik",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:64617,Availability,alive,alive,64617," warn: undefined or garbage returned; }. alpha.security.cert; ^^^^^^^^^^^^^^^^^^^. SEI CERT checkers which tries to find errors based on their `C coding rules <https://wiki.sei.cmu.edu/confluence/display/c/2+Rules>`_. .. _alpha-security-cert-pos-checkers:. alpha.security.cert.pos; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `POSIX C coding rules <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152405>`_. .. _alpha-security-cert-pos-34c:. alpha.security.cert.pos.34c; """"""""""""""""""""""""""""""""""""""""""""""""""""""; Finds calls to the ``putenv`` function which pass a pointer to an automatic variable as the argument. .. code-block:: c. int func(const char *var) {; char env[1024];; int retval = snprintf(env, sizeof(env),""TEST=%s"", var);; if (retval < 0 || (size_t)retval >= sizeof(env)) {; /* Handle error */; }. return putenv(env); // putenv function should not be called with auto variables; }. Limitations:. - Technically, one can pass automatic variables to ``putenv``,; but one needs to ensure that the given environment key stays; alive until it's removed or overwritten.; Since the analyzer cannot keep track of which envvars get overwritten; and when, it needs to be slightly more aggressive and warn for such; cases too, leading in some cases to false-positive reports like this:. .. code-block:: c. void baz() {; char env[] = ""NAME=value"";; putenv(env); // false-positive warning: putenv function should not be called...; // More code...; putenv((char *)""NAME=anothervalue"");; // This putenv call overwrites the previous entry, thus that can no longer dangle.; } // 'env' array becomes dead only here. alpha.security.cert.env; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `Environment C coding rules <https://wiki.sei.cmu.edu/confluence/x/JdcxBQ>`_. alpha.security.taint; ^^^^^^^^^^^^^^^^^^^^. Checkers implementing; `taint analysis <https://en.wikipedia.org/wiki/Taint_checking>`_. .. _alpha-security-taint-TaintPropagation:. alpha.security.taint.TaintPropagation (C, C++); """"""""""""""""",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:82964,Availability,error,error,82964,");; consume(uncounted); // warn; }. Although we are enforcing member variables to be ref-counted by `webkit.NoUncountedMemberChecker` any method of the same class still has unrestricted access to these. Since from a caller's perspective we can't guarantee a particular member won't get modified by callee (directly or indirectly) we don't consider values obtained from members safe. Note: It's likely this heuristic could be made more precise with fewer false positives - for example calls to free functions that don't have any parameter other than the pointer should be safe as the callee won't be able to tamper with the member unless it's a global variable. .. code-block:: cpp. struct Foo {; RefPtr<RefCountable> member;; void consume(RefCountable*) { /* ... */ }; void bugprone() {; consume(member.get()); // warn; }; };. The implementation of this rule is a heuristic - we define a whitelist of kinds of values that are considered safe to be passed as arguments. If we can't prove an argument is safe it's considered an error. Allowed kinds of arguments:. - values obtained from ref-counted objects (including temporaries as those survive the call too). .. code-block:: cpp. RefCountable* provide_uncounted();; void consume(RefCountable*);. void foo() {; RefPtr<RefCountable> rc = makeRef(provide_uncounted());; consume(rc.get()); // ok; consume(makeRef(provide_uncounted()).get()); // ok; }. - forwarding uncounted arguments from caller to callee. .. code-block:: cpp. void foo(RefCountable& a) {; bar(a); // ok; }. Caller of ``foo()`` is responsible for ``a``'s lifetime. - ``this`` pointer. .. code-block:: cpp. void Foo::foo() {; baz(this); // ok; }. Caller of ``foo()`` is responsible for keeping the memory pointed to by ``this`` pointer safe. - constants. .. code-block:: cpp. foo(nullptr, NULL, 0); // ok. We also define a set of safe transformations which if passed a safe value as an input provide (usually it's the return value) a safe value (or an object that provides safe values).",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:11973,Deployability,update,updateNextData,11973,"ame != nil); return;; // Warning: nil passed to a callee that requires a non-null 1st parameter; NSString *greeting = [@""Hello "" stringByAppendingString:name];. .. _nullability-NullReturnedFromNonnull:. nullability.NullReturnedFromNonnull (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns when a null pointer is returned from a function that has _Nonnull return type. .. code-block:: objc. - (nonnull id)firstChild {; id result = nil;; if ([_children count] > 0); result = _children[0];. // Warning: nil returned from a method that is expected; // to return a non-null value; return result;; }. .. _nullability-NullableDereferenced:. nullability.NullableDereferenced (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns when a nullable pointer is dereferenced. .. code-block:: objc. struct LinkedList {; int data;; struct LinkedList *next;; };. struct LinkedList * _Nullable getNext(struct LinkedList *l);. void updateNextData(struct LinkedList *list, int newData) {; struct LinkedList *next = getNext(list);; // Warning: Nullable pointer is dereferenced; next->data = 7;; }. .. _nullability-NullablePassedToNonnull:. nullability.NullablePassedToNonnull (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns when a nullable pointer is passed to a pointer which has a _Nonnull type. .. code-block:: objc. typedef struct Dummy { int val; } Dummy;; Dummy *_Nullable returnsNullable();; void takesNonnull(Dummy *_Nonnull);. void test() {; Dummy *p = returnsNullable();; takesNonnull(p); // warn; }. .. _nullability-NullableReturnedFromNonnull:. nullability.NullableReturnedFromNonnull (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns when a nullable pointer is returned from a function that has _Nonnull return type. .. _optin-checkers:. optin; ^^^^^. Checkers for portability, performance or coding style specific rules. .. _optin-core-EnumCastOutOfRange:. optin.core.EnumCastOutOfRange (C, C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for integer to enumeration casts t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:20524,Deployability,update,updated,20524,"patch. .. _optin-performance-Padding:. optin.performance.Padding; """"""""""""""""""""""""""""""""""""""""""""""""""; Check for excessively padded structs. .. _optin-portability-UnixAPI:. optin.portability.UnixAPI; """"""""""""""""""""""""""""""""""""""""""""""""""; Finds implementation-defined behavior in UNIX/Posix functions. .. _security-checkers:. security; ^^^^^^^^. Security related checkers. .. _security-cert-env-InvalidPtr:. security.cert.env.InvalidPtr; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Corresponds to SEI CERT Rules `ENV31-C <https://wiki.sei.cmu.edu/confluence/display/c/ENV31-C.+Do+not+rely+on+an+environment+pointer+following+an+operation+that+may+invalidate+it>`_ and `ENV34-C <https://wiki.sei.cmu.edu/confluence/display/c/ENV34-C.+Do+not+store+pointers+returned+by+certain+functions>`_. * **ENV31-C**:; Rule is about the possible problem with ``main`` function's third argument, environment pointer,; ""envp"". When environment array is modified using some modification function; such as ``putenv``, ``setenv`` or others, It may happen that memory is reallocated,; however ""envp"" is not updated to reflect the changes and points to old memory; region. * **ENV34-C**:; Some functions return a pointer to a statically allocated buffer.; Consequently, subsequent call of these functions will invalidate previous; pointer. These functions include: ``getenv``, ``localeconv``, ``asctime``, ``setlocale``, ``strerror``. .. code-block:: c. int main(int argc, const char *argv[], const char *envp[]) {; if (setenv(""MY_NEW_VAR"", ""new_value"", 1) != 0) {; // setenv call may invalidate 'envp'; /* Handle error */; }; if (envp != NULL) {; for (size_t i = 0; envp[i] != NULL; ++i) {; puts(envp[i]);; // envp may no longer point to the current environment; // this program has unanticipated behavior, since envp; // does not reflect changes made by setenv function.; }; }; return 0;; }. void previous_call_invalidation() {; char *p, *pp;. p = getenv(""VAR"");; setenv(""SOMEVAR"", ""VALUE"", /*overwrite = */1);; // call to 'setenv' may invalidate p. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:36674,Deployability,release,release,36674,"ptor objectForKey:@""PhotoCount""];; // Warning: Comparing a pointer value of type 'NSNumber *'; // to a scalar integer value; if (photoCount > 0) {; [self displayPhotos];; }. .. _osx-SecKeychainAPI:. osx.SecKeychainAPI (C); """"""""""""""""""""""""""""""""""""""""""""; Check for proper uses of Secure Keychain APIs. .. literalinclude:: checkers/seckeychainapi_example.m; :language: objc. .. _osx-cocoa-AtSync:. osx.cocoa.AtSync (ObjC); """"""""""""""""""""""""""""""""""""""""""""""; Check for nil pointers used as mutexes for @synchronized. .. code-block:: objc. void test(id x) {; if (!x); @synchronized(x) {} // warn: nil value used as mutex; }. void test() {; id y;; @synchronized(y) {} // warn: uninitialized value used as mutex; }. .. _osx-cocoa-AutoreleaseWrite:. osx.cocoa.AutoreleaseWrite; """"""""""""""""""""""""""""""""""""""""""""""""""""; Warn about potentially crashing writes to autoreleasing objects from different autoreleasing pools in Objective-C. .. _osx-cocoa-ClassRelease:. osx.cocoa.ClassRelease (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for sending 'retain', 'release', or 'autorelease' directly to a Class. .. code-block:: objc. @interface MyClass : NSObject; @end. void test(void) {; [MyClass release]; // warn; }. .. _osx-cocoa-Dealloc:. osx.cocoa.Dealloc (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C classes that lack a correct implementation of -dealloc. .. literalinclude:: checkers/dealloc_example.m; :language: objc. .. _osx-cocoa-IncompatibleMethodTypes:. osx.cocoa.IncompatibleMethodTypes (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C method signatures with type incompatibilities. .. code-block:: objc. @interface MyClass1 : NSObject; - (int)foo;; @end. @implementation MyClass1; - (int)foo { return 1; }; @end. @interface MyClass2 : MyClass1; - (float)foo;; @end. @implementation MyClass2; - (float)foo { return 1.0; } // warn; @end. .. _osx-cocoa-Loops:. osx.cocoa.Loops; """"""""""""""""""""""""""""""; Improved modeling of loops using Cocoa collection types. .. _osx-cocoa-MissingSuperCall:. osx.cocoa.Mi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:36809,Deployability,release,release,36809,"[self displayPhotos];; }. .. _osx-SecKeychainAPI:. osx.SecKeychainAPI (C); """"""""""""""""""""""""""""""""""""""""""""; Check for proper uses of Secure Keychain APIs. .. literalinclude:: checkers/seckeychainapi_example.m; :language: objc. .. _osx-cocoa-AtSync:. osx.cocoa.AtSync (ObjC); """"""""""""""""""""""""""""""""""""""""""""""; Check for nil pointers used as mutexes for @synchronized. .. code-block:: objc. void test(id x) {; if (!x); @synchronized(x) {} // warn: nil value used as mutex; }. void test() {; id y;; @synchronized(y) {} // warn: uninitialized value used as mutex; }. .. _osx-cocoa-AutoreleaseWrite:. osx.cocoa.AutoreleaseWrite; """"""""""""""""""""""""""""""""""""""""""""""""""""; Warn about potentially crashing writes to autoreleasing objects from different autoreleasing pools in Objective-C. .. _osx-cocoa-ClassRelease:. osx.cocoa.ClassRelease (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for sending 'retain', 'release', or 'autorelease' directly to a Class. .. code-block:: objc. @interface MyClass : NSObject; @end. void test(void) {; [MyClass release]; // warn; }. .. _osx-cocoa-Dealloc:. osx.cocoa.Dealloc (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C classes that lack a correct implementation of -dealloc. .. literalinclude:: checkers/dealloc_example.m; :language: objc. .. _osx-cocoa-IncompatibleMethodTypes:. osx.cocoa.IncompatibleMethodTypes (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C method signatures with type incompatibilities. .. code-block:: objc. @interface MyClass1 : NSObject; - (int)foo;; @end. @implementation MyClass1; - (int)foo { return 1; }; @end. @interface MyClass2 : MyClass1; - (float)foo;; @end. @implementation MyClass2; - (float)foo { return 1.0; } // warn; @end. .. _osx-cocoa-Loops:. osx.cocoa.Loops; """"""""""""""""""""""""""""""; Improved modeling of loops using Cocoa collection types. .. _osx-cocoa-MissingSuperCall:. osx.cocoa.MissingSuperCall (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C methods that lack a necessary call to super. .. code-block:: objc. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:38187,Deployability,release,release,38187,"""""""""""""""""""""""""""""""""""; Warn about Objective-C method signatures with type incompatibilities. .. code-block:: objc. @interface MyClass1 : NSObject; - (int)foo;; @end. @implementation MyClass1; - (int)foo { return 1; }; @end. @interface MyClass2 : MyClass1; - (float)foo;; @end. @implementation MyClass2; - (float)foo { return 1.0; } // warn; @end. .. _osx-cocoa-Loops:. osx.cocoa.Loops; """"""""""""""""""""""""""""""; Improved modeling of loops using Cocoa collection types. .. _osx-cocoa-MissingSuperCall:. osx.cocoa.MissingSuperCall (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C methods that lack a necessary call to super. .. code-block:: objc. @interface Test : UIViewController; @end; @implementation test; - (void)viewDidLoad {} // warn; @end. .. _osx-cocoa-NSAutoreleasePool:. osx.cocoa.NSAutoreleasePool (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn for suboptimal uses of NSAutoreleasePool in Objective-C GC mode. .. code-block:: objc. void test() {; NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];; [pool release]; // warn; }. .. _osx-cocoa-NSError:. osx.cocoa.NSError (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""; Check usage of NSError parameters. .. code-block:: objc. @interface A : NSObject; - (void)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error;; @end. @implementation A; - (void)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error {; // warn: method accepting NSError"""""""""""""""""""""""""""""""""""""""""""""""" should have a non-void; // return value; }; @end. @interface A : NSObject; - (BOOL)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error;; @end. @implementation A; - (BOOL)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error {; *error = 0; // warn: potential null dereference; return 0;; }; @end. .. _osx-cocoa-NilArg:. osx.cocoa.NilArg (ObjC); """"""""""""""""""""""""""""""""""""""""""""""; Check for prohibited nil arguments to ObjC method calls. - caseInsensitiveCompare:; - compare:; - compare:options:; - compare:options:range:; - compare:options:range:locale:; - componentsSeparatedByCharactersInSet:; - initWithFormat:. .. code-blo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:41341,Deployability,release,release,41341,"cocoa.RunLoopAutoreleaseLeak; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for leaked memory in autorelease pools that will never be drained. .. _osx-cocoa-SelfInit:. osx.cocoa.SelfInit (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""; Check that 'self' is properly initialized inside an initializer method. .. code-block:: objc. @interface MyObj : NSObject {; id x;; }; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; x = 0; // warn: instance variable used while 'self' is not; // initialized; return 0;; }; @end. @interface MyObj : NSObject; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; return self; // warn: returning uninitialized 'self'; }; @end. .. _osx-cocoa-SuperDealloc:. osx.cocoa.SuperDealloc (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about improper use of '[super dealloc]' in Objective-C. .. code-block:: objc. @interface SuperDeallocThenReleaseIvarClass : NSObject {; NSObject *_ivar;; }; @end. @implementation SuperDeallocThenReleaseIvarClass; - (void)dealloc {; [super dealloc];; [_ivar release]; // warn; }; @end. .. _osx-cocoa-UnusedIvars:. osx.cocoa.UnusedIvars (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about private ivars that are never used. .. code-block:: objc. @interface MyObj : NSObject {; @private; id x; // warn; }; @end. @implementation MyObj; @end. .. _osx-cocoa-VariadicMethodTypes:. osx.cocoa.VariadicMethodTypes (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for passing non-Objective-C types to variadic collection; initialization methods that expect only Objective-C types. .. code-block:: objc. void test() {; [NSSet setWithObjects:@""Foo"", ""Bar"", nil];; // warn: argument should be an ObjC pointer type, not 'char *'; }. .. _osx-coreFoundation-CFError:. osx.coreFoundation.CFError (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check usage of CFErrorRef* parameters. .. code-block:: c. void test(CFErrorRef *error) {; // warn: function accepting CFErrorRef* should have a; // non-void return; }. int foo(CFErrorRef *error) {; *error = 0",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:46739,Deployability,patch,patches,46739,"mberChecker:. webkit.NoUncountedMemberChecker; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Raw pointers and references to uncounted types can't be used as class members. Only ref-counted types are allowed. .. code-block:: cpp. struct RefCntbl {; void ref() {}; void deref() {}; };. struct Foo {; RefCntbl * ptr; // warn; RefCntbl & ptr; // warn; // ...; };. .. _webkit-UncountedLambdaCapturesChecker:. webkit.UncountedLambdaCapturesChecker; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Raw pointers and references to uncounted types can't be captured in lambdas. Only ref-counted types are allowed. .. code-block:: cpp. struct RefCntbl {; void ref() {}; void deref() {}; };. void foo(RefCntbl* a, RefCntbl& b) {; [&, a](){ // warn about 'a'; do_something(b); // warn about 'b'; };; };. .. _alpha-checkers:. Experimental Checkers; ---------------------. *These are checkers with known issues or limitations that keep them from being on by default. They are likely to have false positives. Bug reports and especially patches are welcome.*. alpha.clone; ^^^^^^^^^^^. .. _alpha-clone-CloneChecker:. alpha.clone.CloneChecker (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Reports similar pieces of code. .. code-block:: c. void log();. int max(int a, int b) { // warn; log();; if (a > b); return a;; return b;; }. int maxClone(int x, int y) { // similar code here; log();; if (x > y); return x;; return y;; }. alpha.core; ^^^^^^^^^^. .. _alpha-core-BoolAssignment:. alpha.core.BoolAssignment (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about assigning non-{0,1} values to boolean variables. .. code-block:: objc. void test() {; BOOL b = -1; // warn; }. .. _alpha-core-C11Lock:. alpha.core.C11Lock; """"""""""""""""""""""""""""""""""""; Similarly to :ref:`alpha.unix.PthreadLock <alpha-unix-PthreadLock>`, checks for; the locking/unlocking of ``mtx_t`` mutexes. .. code-block:: cpp. mtx_t mtx1;. void bad1(void); {; mtx_lock(&mtx1);; mtx_lock(&mtx1); // warn: This lock has already been acquired; }. .. _alpha-core-CallAnd",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:68250,Deployability,configurat,configuration,68250,"lem. One can protect against such attack by for example checking if the provided; input refers to a valid file and removing any invalid user input. .. code-block:: c. // No vulnerability anymore, but we still get the warning; void sanitizeFileName(char* filename){; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; filename[0]='\0';; }; }; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; sanitizeFileName(filename);// filename is safe after this point; if (!filename[0]); return -1;; strcat(cmd, filename);; system(cmd); // Superfluous Warning: Untrusted data is passed to a system call; }. Unfortunately, the checker cannot discover automatically that the programmer; have performed data sanitation, so it still emits the warning. One can get rid of this superfluous warning by telling by specifying the; sanitation functions in the taint configuration file (see; :doc:`user-docs/TaintAnalysisConfiguration`). .. code-block:: YAML. Filters:; - Name: sanitizeFileName; Args: [0]. The clang invocation to pass the configuration file location:. .. code-block:: bash. clang --analyze -Xclang -analyzer-config -Xclang alpha.security.taint.TaintPropagation:Config=`pwd`/taint_config.yml ... If you are validating your inputs instead of sanitizing them, or don't want to; mention each sanitizing function in our configuration,; you can use a more generic approach. Introduce a generic no-op `csa_mark_sanitized(..)` function to; tell the Clang Static Analyzer; that the variable is safe to be used on that analysis path. .. code-block:: c. // Marking sanitized variables safe.; // No vulnerability anymore, no warning. // User csa_mark_sanitize function is for the analyzer only; #ifdef __clang_analyzer__; void csa_mark_sanitized(const void *);; #endif. int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char f",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:68423,Deployability,configurat,configuration,68423,"more, but we still get the warning; void sanitizeFileName(char* filename){; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; filename[0]='\0';; }; }; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; sanitizeFileName(filename);// filename is safe after this point; if (!filename[0]); return -1;; strcat(cmd, filename);; system(cmd); // Superfluous Warning: Untrusted data is passed to a system call; }. Unfortunately, the checker cannot discover automatically that the programmer; have performed data sanitation, so it still emits the warning. One can get rid of this superfluous warning by telling by specifying the; sanitation functions in the taint configuration file (see; :doc:`user-docs/TaintAnalysisConfiguration`). .. code-block:: YAML. Filters:; - Name: sanitizeFileName; Args: [0]. The clang invocation to pass the configuration file location:. .. code-block:: bash. clang --analyze -Xclang -analyzer-config -Xclang alpha.security.taint.TaintPropagation:Config=`pwd`/taint_config.yml ... If you are validating your inputs instead of sanitizing them, or don't want to; mention each sanitizing function in our configuration,; you can use a more generic approach. Introduce a generic no-op `csa_mark_sanitized(..)` function to; tell the Clang Static Analyzer; that the variable is safe to be used on that analysis path. .. code-block:: c. // Marking sanitized variables safe.; // No vulnerability anymore, no warning. // User csa_mark_sanitize function is for the analyzer only; #ifdef __clang_analyzer__; void csa_mark_sanitized(const void *);; #endif. int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename);; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; return -1;; }; #ifdef __clang_an",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:68716,Deployability,configurat,configuration,68716,"ename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; sanitizeFileName(filename);// filename is safe after this point; if (!filename[0]); return -1;; strcat(cmd, filename);; system(cmd); // Superfluous Warning: Untrusted data is passed to a system call; }. Unfortunately, the checker cannot discover automatically that the programmer; have performed data sanitation, so it still emits the warning. One can get rid of this superfluous warning by telling by specifying the; sanitation functions in the taint configuration file (see; :doc:`user-docs/TaintAnalysisConfiguration`). .. code-block:: YAML. Filters:; - Name: sanitizeFileName; Args: [0]. The clang invocation to pass the configuration file location:. .. code-block:: bash. clang --analyze -Xclang -analyzer-config -Xclang alpha.security.taint.TaintPropagation:Config=`pwd`/taint_config.yml ... If you are validating your inputs instead of sanitizing them, or don't want to; mention each sanitizing function in our configuration,; you can use a more generic approach. Introduce a generic no-op `csa_mark_sanitized(..)` function to; tell the Clang Static Analyzer; that the variable is safe to be used on that analysis path. .. code-block:: c. // Marking sanitized variables safe.; // No vulnerability anymore, no warning. // User csa_mark_sanitize function is for the analyzer only; #ifdef __clang_analyzer__; void csa_mark_sanitized(const void *);; #endif. int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename);; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; return -1;; }; #ifdef __clang_analyzer__; csa_mark_sanitized(filename); // Indicating to CSA that filename variable is safe to be used after this point; #endif; strcat(cmd, filename);; system(cmd); // No warning; }. Similarly to the previous example, you need to; define a `Filter` function in",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:69692,Deployability,configurat,configuration,69692,"tion each sanitizing function in our configuration,; you can use a more generic approach. Introduce a generic no-op `csa_mark_sanitized(..)` function to; tell the Clang Static Analyzer; that the variable is safe to be used on that analysis path. .. code-block:: c. // Marking sanitized variables safe.; // No vulnerability anymore, no warning. // User csa_mark_sanitize function is for the analyzer only; #ifdef __clang_analyzer__; void csa_mark_sanitized(const void *);; #endif. int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename);; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; return -1;; }; #ifdef __clang_analyzer__; csa_mark_sanitized(filename); // Indicating to CSA that filename variable is safe to be used after this point; #endif; strcat(cmd, filename);; system(cmd); // No warning; }. Similarly to the previous example, you need to; define a `Filter` function in a `YAML` configuration file; and add the `csa_mark_sanitized` function. .. code-block:: YAML. Filters:; - Name: csa_mark_sanitized; Args: [0]. Then calling `csa_mark_sanitized(X)` will tell the analyzer that `X` is safe to; be used after this point, because its contents are verified. It is the; responsibility of the programmer to ensure that this verification was indeed; correct. Please note that `csa_mark_sanitized` function is only declared and; used during Clang Static Analysis and skipped in (production) builds. Further examples of injection vulnerabilities this checker can find. .. code-block:: c. void test() {; char x = getchar(); // 'x' marked as tainted; system(&x); // warn: untrusted data is passed to a system call; }. // note: compiler internally checks if the second param to; // sprintf is a string literal or not.; // Use -Wno-format-security to suppress compiler warning.; void test() {; char s[10], buf[10];; fscanf(stdin, ""%s"", s); // 's' marked as tainted. sprintf(buf,",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:70978,Deployability,configurat,configuration,70978,"ts are verified. It is the; responsibility of the programmer to ensure that this verification was indeed; correct. Please note that `csa_mark_sanitized` function is only declared and; used during Clang Static Analysis and skipped in (production) builds. Further examples of injection vulnerabilities this checker can find. .. code-block:: c. void test() {; char x = getchar(); // 'x' marked as tainted; system(&x); // warn: untrusted data is passed to a system call; }. // note: compiler internally checks if the second param to; // sprintf is a string literal or not.; // Use -Wno-format-security to suppress compiler warning.; void test() {; char s[10], buf[10];; fscanf(stdin, ""%s"", s); // 's' marked as tainted. sprintf(buf, s); // warn: untrusted data used as a format string; }. void test() {; size_t ts;; scanf(""%zd"", &ts); // 'ts' marked as tainted; int *p = (int *)malloc(ts * sizeof(int));; // warn: untrusted data used as buffer size; }. There are built-in sources, propagations and sinks even if no external taint; configuration is provided. Default sources:; ``_IO_getc``, ``fdopen``, ``fopen``, ``freopen``, ``get_current_dir_name``,; ``getch``, ``getchar``, ``getchar_unlocked``, ``getwd``, ``getcwd``,; ``getgroups``, ``gethostname``, ``getlogin``, ``getlogin_r``, ``getnameinfo``,; ``gets``, ``gets_s``, ``getseuserbyname``, ``readlink``, ``readlinkat``,; ``scanf``, ``scanf_s``, ``socket``, ``wgetch``. Default propagations rules:; ``atoi``, ``atol``, ``atoll``, ``basename``, ``dirname``, ``fgetc``,; ``fgetln``, ``fgets``, ``fnmatch``, ``fread``, ``fscanf``, ``fscanf_s``,; ``index``, ``inflate``, ``isalnum``, ``isalpha``, ``isascii``, ``isblank``,; ``iscntrl``, ``isdigit``, ``isgraph``, ``islower``, ``isprint``, ``ispunct``,; ``isspace``, ``isupper``, ``isxdigit``, ``memchr``, ``memrchr``, ``sscanf``,; ``getc``, ``getc_unlocked``, ``getdelim``, ``getline``, ``getw``, ``memcmp``,; ``memcpy``, ``memmem``, ``memmove``, ``mbtowc``, ``pread``, ``qsort``,; ``qsort_r``, ``rawmemc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:72778,Deployability,configurat,configuration,72778,"mrchr``, ``sscanf``,; ``getc``, ``getc_unlocked``, ``getdelim``, ``getline``, ``getw``, ``memcmp``,; ``memcpy``, ``memmem``, ``memmove``, ``mbtowc``, ``pread``, ``qsort``,; ``qsort_r``, ``rawmemchr``, ``read``, ``recv``, ``recvfrom``, ``rindex``,; ``strcasestr``, ``strchr``, ``strchrnul``, ``strcasecmp``, ``strcmp``,; ``strcspn``, ``strncasecmp``, ``strncmp``, ``strndup``,; ``strndupa``, ``strpbrk``, ``strrchr``, ``strsep``, ``strspn``,; ``strstr``, ``strtol``, ``strtoll``, ``strtoul``, ``strtoull``, ``tolower``,; ``toupper``, ``ttyname``, ``ttyname_r``, ``wctomb``, ``wcwidth``. Default sinks:; ``printf``, ``setproctitle``, ``system``, ``popen``, ``execl``, ``execle``,; ``execlp``, ``execv``, ``execvp``, ``execvP``, ``execve``, ``dlopen``,; ``memcpy``, ``memmove``, ``strncpy``, ``strndup``, ``malloc``, ``calloc``,; ``alloca``, ``memccpy``, ``realloc``, ``bcopy``. Please note that there are no built-in filter functions. One can configure their own taint sources, sinks, and propagation rules by; providing a configuration file via checker option; ``alpha.security.taint.TaintPropagation:Config``. The configuration file is in; `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format. The; taint-related options defined in the config file extend but do not override the; built-in sources, rules, sinks. The format of the external taint configuration; file is not stable, and could change without any notice even in a non-backward; compatible way. For a more detailed description of configuration options, please see the; :doc:`user-docs/TaintAnalysisConfiguration`. For an example see; :ref:`clangsa-taint-configuration-example`. **Configuration**. * `Config` Specifies the name of the YAML configuration file. The user can; define their own taint sources and sinks. **Related Guidelines**. * `CWE Data Neutralization Issues; <https://cwe.mitre.org/data/definitions/137.html>`_; * `SEI Cert STR02-C. Sanitize data passed to complex subsystems; <https://wiki.sei.cmu.edu/con",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:72871,Deployability,configurat,configuration,72871,"``, ``mbtowc``, ``pread``, ``qsort``,; ``qsort_r``, ``rawmemchr``, ``read``, ``recv``, ``recvfrom``, ``rindex``,; ``strcasestr``, ``strchr``, ``strchrnul``, ``strcasecmp``, ``strcmp``,; ``strcspn``, ``strncasecmp``, ``strncmp``, ``strndup``,; ``strndupa``, ``strpbrk``, ``strrchr``, ``strsep``, ``strspn``,; ``strstr``, ``strtol``, ``strtoll``, ``strtoul``, ``strtoull``, ``tolower``,; ``toupper``, ``ttyname``, ``ttyname_r``, ``wctomb``, ``wcwidth``. Default sinks:; ``printf``, ``setproctitle``, ``system``, ``popen``, ``execl``, ``execle``,; ``execlp``, ``execv``, ``execvp``, ``execvP``, ``execve``, ``dlopen``,; ``memcpy``, ``memmove``, ``strncpy``, ``strndup``, ``malloc``, ``calloc``,; ``alloca``, ``memccpy``, ``realloc``, ``bcopy``. Please note that there are no built-in filter functions. One can configure their own taint sources, sinks, and propagation rules by; providing a configuration file via checker option; ``alpha.security.taint.TaintPropagation:Config``. The configuration file is in; `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format. The; taint-related options defined in the config file extend but do not override the; built-in sources, rules, sinks. The format of the external taint configuration; file is not stable, and could change without any notice even in a non-backward; compatible way. For a more detailed description of configuration options, please see the; :doc:`user-docs/TaintAnalysisConfiguration`. For an example see; :ref:`clangsa-taint-configuration-example`. **Configuration**. * `Config` Specifies the name of the YAML configuration file. The user can; define their own taint sources and sinks. **Related Guidelines**. * `CWE Data Neutralization Issues; <https://cwe.mitre.org/data/definitions/137.html>`_; * `SEI Cert STR02-C. Sanitize data passed to complex subsystems; <https://wiki.sei.cmu.edu/confluence/display/c/STR02-C.+Sanitize+data+passed+to+complex+subsystems>`_; * `SEI Cert ENV33-C. Do not call system(); <https://wiki.sei",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:73120,Deployability,configurat,configuration,73120,"`, ``strrchr``, ``strsep``, ``strspn``,; ``strstr``, ``strtol``, ``strtoll``, ``strtoul``, ``strtoull``, ``tolower``,; ``toupper``, ``ttyname``, ``ttyname_r``, ``wctomb``, ``wcwidth``. Default sinks:; ``printf``, ``setproctitle``, ``system``, ``popen``, ``execl``, ``execle``,; ``execlp``, ``execv``, ``execvp``, ``execvP``, ``execve``, ``dlopen``,; ``memcpy``, ``memmove``, ``strncpy``, ``strndup``, ``malloc``, ``calloc``,; ``alloca``, ``memccpy``, ``realloc``, ``bcopy``. Please note that there are no built-in filter functions. One can configure their own taint sources, sinks, and propagation rules by; providing a configuration file via checker option; ``alpha.security.taint.TaintPropagation:Config``. The configuration file is in; `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format. The; taint-related options defined in the config file extend but do not override the; built-in sources, rules, sinks. The format of the external taint configuration; file is not stable, and could change without any notice even in a non-backward; compatible way. For a more detailed description of configuration options, please see the; :doc:`user-docs/TaintAnalysisConfiguration`. For an example see; :ref:`clangsa-taint-configuration-example`. **Configuration**. * `Config` Specifies the name of the YAML configuration file. The user can; define their own taint sources and sinks. **Related Guidelines**. * `CWE Data Neutralization Issues; <https://cwe.mitre.org/data/definitions/137.html>`_; * `SEI Cert STR02-C. Sanitize data passed to complex subsystems; <https://wiki.sei.cmu.edu/confluence/display/c/STR02-C.+Sanitize+data+passed+to+complex+subsystems>`_; * `SEI Cert ENV33-C. Do not call system(); <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152177>`_; * `ENV03-C. Sanitize the environment when invoking external programs; <https://wiki.sei.cmu.edu/confluence/display/c/ENV03-C.+Sanitize+the+environment+when+invoking+external+programs>`_. **Limitations**. *",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:73266,Deployability,configurat,configuration,73266," ``ttyname``, ``ttyname_r``, ``wctomb``, ``wcwidth``. Default sinks:; ``printf``, ``setproctitle``, ``system``, ``popen``, ``execl``, ``execle``,; ``execlp``, ``execv``, ``execvp``, ``execvP``, ``execve``, ``dlopen``,; ``memcpy``, ``memmove``, ``strncpy``, ``strndup``, ``malloc``, ``calloc``,; ``alloca``, ``memccpy``, ``realloc``, ``bcopy``. Please note that there are no built-in filter functions. One can configure their own taint sources, sinks, and propagation rules by; providing a configuration file via checker option; ``alpha.security.taint.TaintPropagation:Config``. The configuration file is in; `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format. The; taint-related options defined in the config file extend but do not override the; built-in sources, rules, sinks. The format of the external taint configuration; file is not stable, and could change without any notice even in a non-backward; compatible way. For a more detailed description of configuration options, please see the; :doc:`user-docs/TaintAnalysisConfiguration`. For an example see; :ref:`clangsa-taint-configuration-example`. **Configuration**. * `Config` Specifies the name of the YAML configuration file. The user can; define their own taint sources and sinks. **Related Guidelines**. * `CWE Data Neutralization Issues; <https://cwe.mitre.org/data/definitions/137.html>`_; * `SEI Cert STR02-C. Sanitize data passed to complex subsystems; <https://wiki.sei.cmu.edu/confluence/display/c/STR02-C.+Sanitize+data+passed+to+complex+subsystems>`_; * `SEI Cert ENV33-C. Do not call system(); <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152177>`_; * `ENV03-C. Sanitize the environment when invoking external programs; <https://wiki.sei.cmu.edu/confluence/display/c/ENV03-C.+Sanitize+the+environment+when+invoking+external+programs>`_. **Limitations**. * The taintedness property is not propagated through function calls which are; unknown (or too complex) to the analyzer, unless there",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:73390,Deployability,configurat,configuration-example,73390,"itle``, ``system``, ``popen``, ``execl``, ``execle``,; ``execlp``, ``execv``, ``execvp``, ``execvP``, ``execve``, ``dlopen``,; ``memcpy``, ``memmove``, ``strncpy``, ``strndup``, ``malloc``, ``calloc``,; ``alloca``, ``memccpy``, ``realloc``, ``bcopy``. Please note that there are no built-in filter functions. One can configure their own taint sources, sinks, and propagation rules by; providing a configuration file via checker option; ``alpha.security.taint.TaintPropagation:Config``. The configuration file is in; `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format. The; taint-related options defined in the config file extend but do not override the; built-in sources, rules, sinks. The format of the external taint configuration; file is not stable, and could change without any notice even in a non-backward; compatible way. For a more detailed description of configuration options, please see the; :doc:`user-docs/TaintAnalysisConfiguration`. For an example see; :ref:`clangsa-taint-configuration-example`. **Configuration**. * `Config` Specifies the name of the YAML configuration file. The user can; define their own taint sources and sinks. **Related Guidelines**. * `CWE Data Neutralization Issues; <https://cwe.mitre.org/data/definitions/137.html>`_; * `SEI Cert STR02-C. Sanitize data passed to complex subsystems; <https://wiki.sei.cmu.edu/confluence/display/c/STR02-C.+Sanitize+data+passed+to+complex+subsystems>`_; * `SEI Cert ENV33-C. Do not call system(); <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152177>`_; * `ENV03-C. Sanitize the environment when invoking external programs; <https://wiki.sei.cmu.edu/confluence/display/c/ENV03-C.+Sanitize+the+environment+when+invoking+external+programs>`_. **Limitations**. * The taintedness property is not propagated through function calls which are; unknown (or too complex) to the analyzer, unless there is a specific; propagation rule built-in to the checker or given in the YAML configuration",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:73475,Deployability,configurat,configuration,73475,"ecvp``, ``execvP``, ``execve``, ``dlopen``,; ``memcpy``, ``memmove``, ``strncpy``, ``strndup``, ``malloc``, ``calloc``,; ``alloca``, ``memccpy``, ``realloc``, ``bcopy``. Please note that there are no built-in filter functions. One can configure their own taint sources, sinks, and propagation rules by; providing a configuration file via checker option; ``alpha.security.taint.TaintPropagation:Config``. The configuration file is in; `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format. The; taint-related options defined in the config file extend but do not override the; built-in sources, rules, sinks. The format of the external taint configuration; file is not stable, and could change without any notice even in a non-backward; compatible way. For a more detailed description of configuration options, please see the; :doc:`user-docs/TaintAnalysisConfiguration`. For an example see; :ref:`clangsa-taint-configuration-example`. **Configuration**. * `Config` Specifies the name of the YAML configuration file. The user can; define their own taint sources and sinks. **Related Guidelines**. * `CWE Data Neutralization Issues; <https://cwe.mitre.org/data/definitions/137.html>`_; * `SEI Cert STR02-C. Sanitize data passed to complex subsystems; <https://wiki.sei.cmu.edu/confluence/display/c/STR02-C.+Sanitize+data+passed+to+complex+subsystems>`_; * `SEI Cert ENV33-C. Do not call system(); <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152177>`_; * `ENV03-C. Sanitize the environment when invoking external programs; <https://wiki.sei.cmu.edu/confluence/display/c/ENV03-C.+Sanitize+the+environment+when+invoking+external+programs>`_. **Limitations**. * The taintedness property is not propagated through function calls which are; unknown (or too complex) to the analyzer, unless there is a specific; propagation rule built-in to the checker or given in the YAML configuration; file. This causes potential true positive findings to be lost. alpha.unix; ^^^^^",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:74368,Deployability,configurat,configuration,74368,"uration options, please see the; :doc:`user-docs/TaintAnalysisConfiguration`. For an example see; :ref:`clangsa-taint-configuration-example`. **Configuration**. * `Config` Specifies the name of the YAML configuration file. The user can; define their own taint sources and sinks. **Related Guidelines**. * `CWE Data Neutralization Issues; <https://cwe.mitre.org/data/definitions/137.html>`_; * `SEI Cert STR02-C. Sanitize data passed to complex subsystems; <https://wiki.sei.cmu.edu/confluence/display/c/STR02-C.+Sanitize+data+passed+to+complex+subsystems>`_; * `SEI Cert ENV33-C. Do not call system(); <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152177>`_; * `ENV03-C. Sanitize the environment when invoking external programs; <https://wiki.sei.cmu.edu/confluence/display/c/ENV03-C.+Sanitize+the+environment+when+invoking+external+programs>`_. **Limitations**. * The taintedness property is not propagated through function calls which are; unknown (or too complex) to the analyzer, unless there is a specific; propagation rule built-in to the checker or given in the YAML configuration; file. This causes potential true positive findings to be lost. alpha.unix; ^^^^^^^^^^. .. _alpha-unix-BlockInCriticalSection:. alpha.unix.BlockInCriticalSection (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for calls to blocking functions inside a critical section.; Applies to: ``lock, unlock, sleep, getc, fgets, read, recv, pthread_mutex_lock,``; `` pthread_mutex_unlock, mtx_lock, mtx_timedlock, mtx_trylock, mtx_unlock, lock_guard, unique_lock``. .. code-block:: c. void test() {; std::mutex m;; m.lock();; sleep(3); // warn: a blocking function sleep is called inside a critical; // section; m.unlock();; }. .. _alpha-unix-Chroot:. alpha.unix.Chroot (C); """"""""""""""""""""""""""""""""""""""""""; Check improper use of chroot. .. code-block:: c. void f();. void test() {; chroot(""/usr/local"");; f(); // warn: no call of chdir(""/"") immediately after chroot; }. .. _alpha-unix-PthreadLock:. alpha.uni",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:20653,Energy Efficiency,allocate,allocated,20653," optin.portability.UnixAPI; """"""""""""""""""""""""""""""""""""""""""""""""""; Finds implementation-defined behavior in UNIX/Posix functions. .. _security-checkers:. security; ^^^^^^^^. Security related checkers. .. _security-cert-env-InvalidPtr:. security.cert.env.InvalidPtr; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Corresponds to SEI CERT Rules `ENV31-C <https://wiki.sei.cmu.edu/confluence/display/c/ENV31-C.+Do+not+rely+on+an+environment+pointer+following+an+operation+that+may+invalidate+it>`_ and `ENV34-C <https://wiki.sei.cmu.edu/confluence/display/c/ENV34-C.+Do+not+store+pointers+returned+by+certain+functions>`_. * **ENV31-C**:; Rule is about the possible problem with ``main`` function's third argument, environment pointer,; ""envp"". When environment array is modified using some modification function; such as ``putenv``, ``setenv`` or others, It may happen that memory is reallocated,; however ""envp"" is not updated to reflect the changes and points to old memory; region. * **ENV34-C**:; Some functions return a pointer to a statically allocated buffer.; Consequently, subsequent call of these functions will invalidate previous; pointer. These functions include: ``getenv``, ``localeconv``, ``asctime``, ``setlocale``, ``strerror``. .. code-block:: c. int main(int argc, const char *argv[], const char *envp[]) {; if (setenv(""MY_NEW_VAR"", ""new_value"", 1) != 0) {; // setenv call may invalidate 'envp'; /* Handle error */; }; if (envp != NULL) {; for (size_t i = 0; envp[i] != NULL; ++i) {; puts(envp[i]);; // envp may no longer point to the current environment; // this program has unanticipated behavior, since envp; // does not reflect changes made by setenv function.; }; }; return 0;; }. void previous_call_invalidation() {; char *p, *pp;. p = getenv(""VAR"");; setenv(""SOMEVAR"", ""VALUE"", /*overwrite = */1);; // call to 'setenv' may invalidate p. *p;; // dereferencing invalid pointer; }. The ``InvalidatingGetEnv`` option is available for treating ``getenv`` calls as; invalidating. When enabled, the checke",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:40435,Energy Efficiency,drain,drained,40435,"NonNilReturnValue:. osx.cocoa.NonNilReturnValue; """"""""""""""""""""""""""""""""""""""""""""""""""""""; Models the APIs that are guaranteed to return a non-nil value. .. _osx-cocoa-ObjCGenerics:. osx.cocoa.ObjCGenerics (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for type errors when using Objective-C generics. .. code-block:: objc. NSMutableArray *names = [NSMutableArray array];; NSMutableArray *birthDates = names;. // Warning: Conversion from value of type 'NSDate *'; // to incompatible type 'NSString *'; [birthDates addObject: [NSDate date]];. .. _osx-cocoa-RetainCount:. osx.cocoa.RetainCount (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for leaks and improper reference count management. .. code-block:: objc. void test() {; NSString *s = [[NSString alloc] init]; // warn; }. CFStringRef test(char *bytes) {; return CFStringCreateWithCStringNoCopy(; 0, bytes, NSNEXTSTEPStringEncoding, 0); // warn; }. .. _osx-cocoa-RunLoopAutoreleaseLeak:. osx.cocoa.RunLoopAutoreleaseLeak; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for leaked memory in autorelease pools that will never be drained. .. _osx-cocoa-SelfInit:. osx.cocoa.SelfInit (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""; Check that 'self' is properly initialized inside an initializer method. .. code-block:: objc. @interface MyObj : NSObject {; id x;; }; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; x = 0; // warn: instance variable used while 'self' is not; // initialized; return 0;; }; @end. @interface MyObj : NSObject; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; return self; // warn: returning uninitialized 'self'; }; @end. .. _osx-cocoa-SuperDealloc:. osx.cocoa.SuperDealloc (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about improper use of '[super dealloc]' in Objective-C. .. code-block:: objc. @interface SuperDeallocThenReleaseIvarClass : NSObject {; NSObject *_ivar;; }; @end. @implementation SuperDeallocThenReleaseIvarClass; - (void)dealloc {; [super dealloc];; [_ivar release]; // warn; }; @end. .. _osx-c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:51602,Energy Efficiency,allocate,allocated,51602,"ointerSub (C); """"""""""""""""""""""""""""""""""""""""""""""""""; Check for pointer subtractions on two pointers pointing to different memory chunks. .. code-block:: c. void test() {; int x, y;; int d = &y - &x; // warn; }. .. _alpha-core-SizeofPtr:. alpha.core.SizeofPtr (C); """"""""""""""""""""""""""""""""""""""""""""""""; Warn about unintended use of ``sizeof()`` on pointer expressions. .. code-block:: c. struct s {};. int test(struct s *p) {; return sizeof(p);; // warn: sizeof(ptr) can produce an unexpected result; }. .. _alpha-core-StackAddressAsyncEscape:. alpha.core.StackAddressAsyncEscape (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check that addresses to stack memory do not escape the function that involves dispatch_after or dispatch_async.; This checker is a part of ``core.StackAddressEscape``, but is temporarily disabled until some false positives are fixed. .. code-block:: c. dispatch_block_t test_block_inside_block_async_leak() {; int x = 123;; void (^inner)(void) = ^void(void) {; int y = x;; ++y;; };; void (^outer)(void) = ^void(void) {; int z = x;; ++z;; inner();; };; return outer; // warn: address of stack-allocated block is captured by a; // returned block; }. .. _alpha-core-StdVariant:. alpha.core.StdVariant (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""; Check if a value of active type is retrieved from an ``std::variant`` instance with ``std::get``.; In case of bad variant type access (the accessed type differs from the active type); a warning is emitted. Currently, this checker does not take exception handling into account. .. code-block:: cpp. void test() {; std::variant<int, char> v = 25;; char c = stg::get<char>(v); // warn: ""int"" is the active alternative; }. .. _alpha-core-TestAfterDivZero:. alpha.core.TestAfterDivZero (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for division by variable that is later compared against 0.; Either the comparison is useless or there is division by zero. .. code-block:: c. void test(int x) {; var = 77 / x;; if (x == 0) { } // warn; }. alpha.cplusplus; ^^^^^^^^^^^^^^^. ..",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:57022,Energy Efficiency,allocate,allocate,57022,"de:. alpha.deadcode.UnreachableCode (C, C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check unreachable code. .. code-block:: cpp. // C; int test() {; int x = 1;; while(x);; return x; // warn; }. // C++; void test() {; int a = 2;. while (a > 1); a--;. if (a > 1); a++; // warn; }. // Objective-C; void test(id x) {; return;; [x retain]; // warn; }. alpha.fuchsia; ^^^^^^^^^^^^^. .. _alpha-fuchsia-lock:. alpha.fuchsia.Lock; """"""""""""""""""""""""""""""""""""; Similarly to :ref:`alpha.unix.PthreadLock <alpha-unix-PthreadLock>`, checks for; the locking/unlocking of fuchsia mutexes. .. code-block:: cpp. spin_lock_t mtx1;. void bad1(void); {; spin_lock(&mtx1);; spin_lock(&mtx1);	// warn: This lock has already been acquired; }. alpha.llvm; ^^^^^^^^^^. .. _alpha-llvm-Conventions:. alpha.llvm.Conventions; """""""""""""""""""""""""""""""""""""""""""". Check code for LLVM codebase conventions:. * A StringRef should not be bound to a temporary std::string whose lifetime is shorter than the StringRef's.; * Clang AST nodes should not have fields that can allocate memory. alpha.osx; ^^^^^^^^^. .. _alpha-osx-cocoa-DirectIvarAssignment:. alpha.osx.cocoa.DirectIvarAssignment (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for direct assignments to instance variables. .. code-block:: objc. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) foo;; @end. @implementation MyClass; - (void) foo {; _A = 0; // warn; }; @end. .. _alpha-osx-cocoa-DirectIvarAssignmentForAnnotatedFunctions:. alpha.osx.cocoa.DirectIvarAssignmentForAnnotatedFunctions (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for direct assignments to instance variables in; the methods annotated with ``objc_no_direct_instance_variable_assignment``. .. code-block:: objc. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) fAnnotated __attribute__((; annotate(""objc_no_direct_instance_variable_assignment"")));; - (void) fNotAnnotated;; @end. @implementation MyClass; - (void) fAnnotated {;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:81023,Energy Efficiency,allocate,allocated,81023," buffer.; }. More details at the corresponding `GitHub issue <https://github.com/llvm/llvm-project/issues/43459>`_. .. _alpha-nondeterminism-PointerIteration:. alpha.nondeterminism.PointerIteration (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for non-determinism caused by iterating unordered containers of pointers. .. code-block:: c. void test() {; int a = 1, b = 2;; std::unordered_set<int *> UnorderedPtrSet = {&a, &b};. for (auto i : UnorderedPtrSet) // warn; f(i);; }. .. _alpha-nondeterminism-PointerSorting:. alpha.nondeterminism.PointerSorting (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for non-determinism caused by sorting of pointers. .. code-block:: c. void test() {; int a = 1, b = 2;; std::vector<int *> V = {&a, &b};; std::sort(V.begin(), V.end()); // warn; }. alpha.WebKit; ^^^^^^^^^^^^. .. _alpha-webkit-UncountedCallArgsChecker:. alpha.webkit.UncountedCallArgsChecker; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; The goal of this rule is to make sure that lifetime of any dynamically allocated ref-countable object passed as a call argument spans past the end of the call. This applies to call to any function, method, lambda, function pointer or functor. Ref-countable types aren't supposed to be allocated on stack so we check arguments for parameters of raw pointers and references to uncounted types. Here are some examples of situations that we warn about as they *might* be potentially unsafe. The logic is that either we're able to guarantee that an argument is safe or it's considered if not a bug then bug-prone. .. code-block:: cpp. RefCountable* provide_uncounted();; void consume(RefCountable*);. // In these cases we can't make sure callee won't directly or indirectly call `deref()` on the argument which could make it unsafe from such point until the end of the call. void foo1() {; consume(provide_uncounted()); // warn; }. void foo2() {; RefCountable* uncounted = provide_uncounted();; consume(uncounted); // warn; }. Although we are enforcing",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:81237,Energy Efficiency,allocate,allocated,81237,"minism caused by iterating unordered containers of pointers. .. code-block:: c. void test() {; int a = 1, b = 2;; std::unordered_set<int *> UnorderedPtrSet = {&a, &b};. for (auto i : UnorderedPtrSet) // warn; f(i);; }. .. _alpha-nondeterminism-PointerSorting:. alpha.nondeterminism.PointerSorting (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for non-determinism caused by sorting of pointers. .. code-block:: c. void test() {; int a = 1, b = 2;; std::vector<int *> V = {&a, &b};; std::sort(V.begin(), V.end()); // warn; }. alpha.WebKit; ^^^^^^^^^^^^. .. _alpha-webkit-UncountedCallArgsChecker:. alpha.webkit.UncountedCallArgsChecker; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; The goal of this rule is to make sure that lifetime of any dynamically allocated ref-countable object passed as a call argument spans past the end of the call. This applies to call to any function, method, lambda, function pointer or functor. Ref-countable types aren't supposed to be allocated on stack so we check arguments for parameters of raw pointers and references to uncounted types. Here are some examples of situations that we warn about as they *might* be potentially unsafe. The logic is that either we're able to guarantee that an argument is safe or it's considered if not a bug then bug-prone. .. code-block:: cpp. RefCountable* provide_uncounted();; void consume(RefCountable*);. // In these cases we can't make sure callee won't directly or indirectly call `deref()` on the argument which could make it unsafe from such point until the end of the call. void foo1() {; consume(provide_uncounted()); // warn; }. void foo2() {; RefCountable* uncounted = provide_uncounted();; consume(uncounted); // warn; }. Although we are enforcing member variables to be ref-counted by `webkit.NoUncountedMemberChecker` any method of the same class still has unrestricted access to these. Since from a caller's perspective we can't guarantee a particular member won't get modified by callee (directly or indirectly) w",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:2860,Integrability,message,message,2860,"e C++20 standard these constructs are; well-defined, so activating pedantic mode in C++20 has no effect.). **Examples**. .. code-block:: cpp. static_assert(sizeof(int) == 4, ""assuming 32-bit int""). void basic_examples(int a, int b) {; if (b < 0) {; b = a << b; // warn: right operand is negative in left shift; } else if (b >= 32) {; b = a >> b; // warn: right shift overflows the capacity of 'int'; }; }. int pedantic_examples(int a, int b) {; if (a < 0) {; return a >> b; // warn: left operand is negative in right shift; }; a = 1000u << 31; // OK, overflow of unsigned value is well-defined, a == 0; if (b > 10) {; a = b << 31; // this is undefined before C++20, but the checker doesn't; // warn because it doesn't know the exact value of b; }; return 1000 << 31; // warn: this overflows the capacity of 'int'; }. **Solution**. Ensure the shift operands are in proper range before shifting. .. _core-CallAndMessage:. core.CallAndMessage (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for logical errors for function calls and Objective-C message expressions (e.g., uninitialized arguments, null function pointers). .. literalinclude:: checkers/callandmessage_example.c; :language: objc. .. _core-DivideZero:. core.DivideZero (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for division by zero. .. literalinclude:: checkers/dividezero_example.c; :language: c. .. _core-NonNullParamChecker:. core.NonNullParamChecker (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for null pointers passed as arguments to a function whose arguments are references or marked with the 'nonnull' attribute. .. code-block:: cpp. int f(int *p) __attribute__((nonnull));. void test(int *p) {; if (!p); f(p); // warn; }. .. _core-NullDereference:. core.NullDereference (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for dereferences of null pointers. This checker specifically does; not report null pointer dereferences for x86 and x86-64 targets when the; address space is 256",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:4541,Integrability,interface,interface,4541,"reference:. core.NullDereference (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for dereferences of null pointers. This checker specifically does; not report null pointer dereferences for x86 and x86-64 targets when the; address space is 256 (x86 GS Segment), 257 (x86 FS Segment), or 258 (x86 SS; segment). See `X86/X86-64 Language Extensions; <https://clang.llvm.org/docs/LanguageExtensions.html#memory-references-to-specified-segments>`__; for reference. The ``SuppressAddressSpaces`` option suppresses; warnings for null dereferences of all pointers with address spaces. You can; disable this behavior with the option; ``-analyzer-config core.NullDereference:SuppressAddressSpaces=false``.; *Defaults to true*. .. code-block:: objc. // C; void test(int *p) {; if (p); return;. int x = p[0]; // warn; }. // C; void test(int *p) {; if (!p); *p = 0; // warn; }. // C++; class C {; public:; int x;; };. void test() {; C *pc = 0;; int k = pc->x; // warn; }. // Objective-C; @interface MyClass {; @public; int x;; }; @end. void test() {; MyClass *obj = 0;; obj->x = 1; // warn; }. .. _core-StackAddressEscape:. core.StackAddressEscape (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""; Check that addresses to stack memory do not escape the function. .. code-block:: c. char const *p;. void test() {; char const str[] = ""string"";; p = str; // warn; }. void* test() {; return __builtin_alloca(12); // warn; }. void test() {; static int *x;; int y;; x = &y; // warn; }. .. _core-UndefinedBinaryOperatorResult:. core.UndefinedBinaryOperatorResult (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for undefined results of binary operators. .. code-block:: c. void test() {; int x;; int y = x + 1; // warn: left operand is garbage; }. .. _core-VLASize:. core.VLASize (C); """"""""""""""""""""""""""""""""; Check for declarations of Variable Length Arrays of undefined or zero size. Check for declarations of VLA of undefined or zero size. .. code-block:: c. void test() {; int x;; int vla1[x]; // warn: garbage as size; }. voi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:36140,Integrability,synchroniz,synchronized,36140,"rsion (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for erroneous conversions of objects representing numbers into numbers. .. code-block:: objc. NSNumber *photoCount = [albumDescriptor objectForKey:@""PhotoCount""];; // Warning: Comparing a pointer value of type 'NSNumber *'; // to a scalar integer value; if (photoCount > 0) {; [self displayPhotos];; }. .. _osx-ObjCProperty:. osx.ObjCProperty (ObjC); """"""""""""""""""""""""""""""""""""""""""""""; Check for proper uses of Objective-C properties. .. code-block:: objc. NSNumber *photoCount = [albumDescriptor objectForKey:@""PhotoCount""];; // Warning: Comparing a pointer value of type 'NSNumber *'; // to a scalar integer value; if (photoCount > 0) {; [self displayPhotos];; }. .. _osx-SecKeychainAPI:. osx.SecKeychainAPI (C); """"""""""""""""""""""""""""""""""""""""""""; Check for proper uses of Secure Keychain APIs. .. literalinclude:: checkers/seckeychainapi_example.m; :language: objc. .. _osx-cocoa-AtSync:. osx.cocoa.AtSync (ObjC); """"""""""""""""""""""""""""""""""""""""""""""; Check for nil pointers used as mutexes for @synchronized. .. code-block:: objc. void test(id x) {; if (!x); @synchronized(x) {} // warn: nil value used as mutex; }. void test() {; id y;; @synchronized(y) {} // warn: uninitialized value used as mutex; }. .. _osx-cocoa-AutoreleaseWrite:. osx.cocoa.AutoreleaseWrite; """"""""""""""""""""""""""""""""""""""""""""""""""""; Warn about potentially crashing writes to autoreleasing objects from different autoreleasing pools in Objective-C. .. _osx-cocoa-ClassRelease:. osx.cocoa.ClassRelease (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for sending 'retain', 'release', or 'autorelease' directly to a Class. .. code-block:: objc. @interface MyClass : NSObject; @end. void test(void) {; [MyClass release]; // warn; }. .. _osx-cocoa-Dealloc:. osx.cocoa.Dealloc (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C classes that lack a correct implementation of -dealloc. .. literalinclude:: checkers/dealloc_example.m; :language: objc. .. _osx-cocoa-IncompatibleMethodTypes:. osx.cocoa.Inco",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:36205,Integrability,synchroniz,synchronized,36205,"senting numbers into numbers. .. code-block:: objc. NSNumber *photoCount = [albumDescriptor objectForKey:@""PhotoCount""];; // Warning: Comparing a pointer value of type 'NSNumber *'; // to a scalar integer value; if (photoCount > 0) {; [self displayPhotos];; }. .. _osx-ObjCProperty:. osx.ObjCProperty (ObjC); """"""""""""""""""""""""""""""""""""""""""""""; Check for proper uses of Objective-C properties. .. code-block:: objc. NSNumber *photoCount = [albumDescriptor objectForKey:@""PhotoCount""];; // Warning: Comparing a pointer value of type 'NSNumber *'; // to a scalar integer value; if (photoCount > 0) {; [self displayPhotos];; }. .. _osx-SecKeychainAPI:. osx.SecKeychainAPI (C); """"""""""""""""""""""""""""""""""""""""""""; Check for proper uses of Secure Keychain APIs. .. literalinclude:: checkers/seckeychainapi_example.m; :language: objc. .. _osx-cocoa-AtSync:. osx.cocoa.AtSync (ObjC); """"""""""""""""""""""""""""""""""""""""""""""; Check for nil pointers used as mutexes for @synchronized. .. code-block:: objc. void test(id x) {; if (!x); @synchronized(x) {} // warn: nil value used as mutex; }. void test() {; id y;; @synchronized(y) {} // warn: uninitialized value used as mutex; }. .. _osx-cocoa-AutoreleaseWrite:. osx.cocoa.AutoreleaseWrite; """"""""""""""""""""""""""""""""""""""""""""""""""""; Warn about potentially crashing writes to autoreleasing objects from different autoreleasing pools in Objective-C. .. _osx-cocoa-ClassRelease:. osx.cocoa.ClassRelease (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for sending 'retain', 'release', or 'autorelease' directly to a Class. .. code-block:: objc. @interface MyClass : NSObject; @end. void test(void) {; [MyClass release]; // warn; }. .. _osx-cocoa-Dealloc:. osx.cocoa.Dealloc (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C classes that lack a correct implementation of -dealloc. .. literalinclude:: checkers/dealloc_example.m; :language: objc. .. _osx-cocoa-IncompatibleMethodTypes:. osx.cocoa.IncompatibleMethodTypes (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C method signatures wi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:36284,Integrability,synchroniz,synchronized,36284,"ptor objectForKey:@""PhotoCount""];; // Warning: Comparing a pointer value of type 'NSNumber *'; // to a scalar integer value; if (photoCount > 0) {; [self displayPhotos];; }. .. _osx-ObjCProperty:. osx.ObjCProperty (ObjC); """"""""""""""""""""""""""""""""""""""""""""""; Check for proper uses of Objective-C properties. .. code-block:: objc. NSNumber *photoCount = [albumDescriptor objectForKey:@""PhotoCount""];; // Warning: Comparing a pointer value of type 'NSNumber *'; // to a scalar integer value; if (photoCount > 0) {; [self displayPhotos];; }. .. _osx-SecKeychainAPI:. osx.SecKeychainAPI (C); """"""""""""""""""""""""""""""""""""""""""""; Check for proper uses of Secure Keychain APIs. .. literalinclude:: checkers/seckeychainapi_example.m; :language: objc. .. _osx-cocoa-AtSync:. osx.cocoa.AtSync (ObjC); """"""""""""""""""""""""""""""""""""""""""""""; Check for nil pointers used as mutexes for @synchronized. .. code-block:: objc. void test(id x) {; if (!x); @synchronized(x) {} // warn: nil value used as mutex; }. void test() {; id y;; @synchronized(y) {} // warn: uninitialized value used as mutex; }. .. _osx-cocoa-AutoreleaseWrite:. osx.cocoa.AutoreleaseWrite; """"""""""""""""""""""""""""""""""""""""""""""""""""; Warn about potentially crashing writes to autoreleasing objects from different autoreleasing pools in Objective-C. .. _osx-cocoa-ClassRelease:. osx.cocoa.ClassRelease (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for sending 'retain', 'release', or 'autorelease' directly to a Class. .. code-block:: objc. @interface MyClass : NSObject; @end. void test(void) {; [MyClass release]; // warn; }. .. _osx-cocoa-Dealloc:. osx.cocoa.Dealloc (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C classes that lack a correct implementation of -dealloc. .. literalinclude:: checkers/dealloc_example.m; :language: objc. .. _osx-cocoa-IncompatibleMethodTypes:. osx.cocoa.IncompatibleMethodTypes (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C method signatures with type incompatibilities. .. code-block:: objc. @interface MyClass1 : NSObject; - (int",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:36745,Integrability,interface,interface,36745,"calar integer value; if (photoCount > 0) {; [self displayPhotos];; }. .. _osx-SecKeychainAPI:. osx.SecKeychainAPI (C); """"""""""""""""""""""""""""""""""""""""""""; Check for proper uses of Secure Keychain APIs. .. literalinclude:: checkers/seckeychainapi_example.m; :language: objc. .. _osx-cocoa-AtSync:. osx.cocoa.AtSync (ObjC); """"""""""""""""""""""""""""""""""""""""""""""; Check for nil pointers used as mutexes for @synchronized. .. code-block:: objc. void test(id x) {; if (!x); @synchronized(x) {} // warn: nil value used as mutex; }. void test() {; id y;; @synchronized(y) {} // warn: uninitialized value used as mutex; }. .. _osx-cocoa-AutoreleaseWrite:. osx.cocoa.AutoreleaseWrite; """"""""""""""""""""""""""""""""""""""""""""""""""""; Warn about potentially crashing writes to autoreleasing objects from different autoreleasing pools in Objective-C. .. _osx-cocoa-ClassRelease:. osx.cocoa.ClassRelease (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for sending 'retain', 'release', or 'autorelease' directly to a Class. .. code-block:: objc. @interface MyClass : NSObject; @end. void test(void) {; [MyClass release]; // warn; }. .. _osx-cocoa-Dealloc:. osx.cocoa.Dealloc (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C classes that lack a correct implementation of -dealloc. .. literalinclude:: checkers/dealloc_example.m; :language: objc. .. _osx-cocoa-IncompatibleMethodTypes:. osx.cocoa.IncompatibleMethodTypes (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C method signatures with type incompatibilities. .. code-block:: objc. @interface MyClass1 : NSObject; - (int)foo;; @end. @implementation MyClass1; - (int)foo { return 1; }; @end. @interface MyClass2 : MyClass1; - (float)foo;; @end. @implementation MyClass2; - (float)foo { return 1.0; } // warn; @end. .. _osx-cocoa-Loops:. osx.cocoa.Loops; """"""""""""""""""""""""""""""; Improved modeling of loops using Cocoa collection types. .. _osx-cocoa-MissingSuperCall:. osx.cocoa.MissingSuperCall (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C methods that lack a nece",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:37268,Integrability,interface,interface,37268,"nized(y) {} // warn: uninitialized value used as mutex; }. .. _osx-cocoa-AutoreleaseWrite:. osx.cocoa.AutoreleaseWrite; """"""""""""""""""""""""""""""""""""""""""""""""""""; Warn about potentially crashing writes to autoreleasing objects from different autoreleasing pools in Objective-C. .. _osx-cocoa-ClassRelease:. osx.cocoa.ClassRelease (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for sending 'retain', 'release', or 'autorelease' directly to a Class. .. code-block:: objc. @interface MyClass : NSObject; @end. void test(void) {; [MyClass release]; // warn; }. .. _osx-cocoa-Dealloc:. osx.cocoa.Dealloc (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C classes that lack a correct implementation of -dealloc. .. literalinclude:: checkers/dealloc_example.m; :language: objc. .. _osx-cocoa-IncompatibleMethodTypes:. osx.cocoa.IncompatibleMethodTypes (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C method signatures with type incompatibilities. .. code-block:: objc. @interface MyClass1 : NSObject; - (int)foo;; @end. @implementation MyClass1; - (int)foo { return 1; }; @end. @interface MyClass2 : MyClass1; - (float)foo;; @end. @implementation MyClass2; - (float)foo { return 1.0; } // warn; @end. .. _osx-cocoa-Loops:. osx.cocoa.Loops; """"""""""""""""""""""""""""""; Improved modeling of loops using Cocoa collection types. .. _osx-cocoa-MissingSuperCall:. osx.cocoa.MissingSuperCall (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C methods that lack a necessary call to super. .. code-block:: objc. @interface Test : UIViewController; @end; @implementation test; - (void)viewDidLoad {} // warn; @end. .. _osx-cocoa-NSAutoreleasePool:. osx.cocoa.NSAutoreleasePool (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn for suboptimal uses of NSAutoreleasePool in Objective-C GC mode. .. code-block:: objc. void test() {; NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];; [pool release]; // warn; }. .. _osx-cocoa-NSError:. osx.cocoa.NSError (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""; Check u",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:37377,Integrability,interface,interface,37377,"aseWrite; """"""""""""""""""""""""""""""""""""""""""""""""""""; Warn about potentially crashing writes to autoreleasing objects from different autoreleasing pools in Objective-C. .. _osx-cocoa-ClassRelease:. osx.cocoa.ClassRelease (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for sending 'retain', 'release', or 'autorelease' directly to a Class. .. code-block:: objc. @interface MyClass : NSObject; @end. void test(void) {; [MyClass release]; // warn; }. .. _osx-cocoa-Dealloc:. osx.cocoa.Dealloc (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C classes that lack a correct implementation of -dealloc. .. literalinclude:: checkers/dealloc_example.m; :language: objc. .. _osx-cocoa-IncompatibleMethodTypes:. osx.cocoa.IncompatibleMethodTypes (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C method signatures with type incompatibilities. .. code-block:: objc. @interface MyClass1 : NSObject; - (int)foo;; @end. @implementation MyClass1; - (int)foo { return 1; }; @end. @interface MyClass2 : MyClass1; - (float)foo;; @end. @implementation MyClass2; - (float)foo { return 1.0; } // warn; @end. .. _osx-cocoa-Loops:. osx.cocoa.Loops; """"""""""""""""""""""""""""""; Improved modeling of loops using Cocoa collection types. .. _osx-cocoa-MissingSuperCall:. osx.cocoa.MissingSuperCall (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C methods that lack a necessary call to super. .. code-block:: objc. @interface Test : UIViewController; @end; @implementation test; - (void)viewDidLoad {} // warn; @end. .. _osx-cocoa-NSAutoreleasePool:. osx.cocoa.NSAutoreleasePool (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn for suboptimal uses of NSAutoreleasePool in Objective-C GC mode. .. code-block:: objc. void test() {; NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];; [pool release]; // warn; }. .. _osx-cocoa-NSError:. osx.cocoa.NSError (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""; Check usage of NSError parameters. .. code-block:: objc. @interface A : NSObject; - (void)foo:(NSError """"""""""""""""""""""""""""",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:37806,Integrability,interface,interface,37806,"osx.cocoa.Dealloc (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C classes that lack a correct implementation of -dealloc. .. literalinclude:: checkers/dealloc_example.m; :language: objc. .. _osx-cocoa-IncompatibleMethodTypes:. osx.cocoa.IncompatibleMethodTypes (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C method signatures with type incompatibilities. .. code-block:: objc. @interface MyClass1 : NSObject; - (int)foo;; @end. @implementation MyClass1; - (int)foo { return 1; }; @end. @interface MyClass2 : MyClass1; - (float)foo;; @end. @implementation MyClass2; - (float)foo { return 1.0; } // warn; @end. .. _osx-cocoa-Loops:. osx.cocoa.Loops; """"""""""""""""""""""""""""""; Improved modeling of loops using Cocoa collection types. .. _osx-cocoa-MissingSuperCall:. osx.cocoa.MissingSuperCall (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C methods that lack a necessary call to super. .. code-block:: objc. @interface Test : UIViewController; @end; @implementation test; - (void)viewDidLoad {} // warn; @end. .. _osx-cocoa-NSAutoreleasePool:. osx.cocoa.NSAutoreleasePool (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn for suboptimal uses of NSAutoreleasePool in Objective-C GC mode. .. code-block:: objc. void test() {; NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];; [pool release]; // warn; }. .. _osx-cocoa-NSError:. osx.cocoa.NSError (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""; Check usage of NSError parameters. .. code-block:: objc. @interface A : NSObject; - (void)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error;; @end. @implementation A; - (void)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error {; // warn: method accepting NSError"""""""""""""""""""""""""""""""""""""""""""""""" should have a non-void; // return value; }; @end. @interface A : NSObject; - (BOOL)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error;; @end. @implementation A; - (BOOL)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error {; *error = 0; // warn: potential null dereference; return 0;; }; @end. .. _osx-cocoa-NilA",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:38343,Integrability,interface,interface,38343,"ace MyClass2 : MyClass1; - (float)foo;; @end. @implementation MyClass2; - (float)foo { return 1.0; } // warn; @end. .. _osx-cocoa-Loops:. osx.cocoa.Loops; """"""""""""""""""""""""""""""; Improved modeling of loops using Cocoa collection types. .. _osx-cocoa-MissingSuperCall:. osx.cocoa.MissingSuperCall (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C methods that lack a necessary call to super. .. code-block:: objc. @interface Test : UIViewController; @end; @implementation test; - (void)viewDidLoad {} // warn; @end. .. _osx-cocoa-NSAutoreleasePool:. osx.cocoa.NSAutoreleasePool (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn for suboptimal uses of NSAutoreleasePool in Objective-C GC mode. .. code-block:: objc. void test() {; NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];; [pool release]; // warn; }. .. _osx-cocoa-NSError:. osx.cocoa.NSError (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""; Check usage of NSError parameters. .. code-block:: objc. @interface A : NSObject; - (void)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error;; @end. @implementation A; - (void)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error {; // warn: method accepting NSError"""""""""""""""""""""""""""""""""""""""""""""""" should have a non-void; // return value; }; @end. @interface A : NSObject; - (BOOL)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error;; @end. @implementation A; - (BOOL)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error {; *error = 0; // warn: potential null dereference; return 0;; }; @end. .. _osx-cocoa-NilArg:. osx.cocoa.NilArg (ObjC); """"""""""""""""""""""""""""""""""""""""""""""; Check for prohibited nil arguments to ObjC method calls. - caseInsensitiveCompare:; - compare:; - compare:options:; - compare:options:range:; - compare:options:range:locale:; - componentsSeparatedByCharactersInSet:; - initWithFormat:. .. code-block:: objc. NSComparisonResult test(NSString *s) {; NSString *aString = nil;; return [s caseInsensitiveCompare:aString];; // warn: argument to 'NSString' method; // 'caseInsensitiveCompare:' cannot be nil; }. .. _osx-cocoa-NonNil",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:38610,Integrability,interface,interface,38610,"ocoa.MissingSuperCall (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C methods that lack a necessary call to super. .. code-block:: objc. @interface Test : UIViewController; @end; @implementation test; - (void)viewDidLoad {} // warn; @end. .. _osx-cocoa-NSAutoreleasePool:. osx.cocoa.NSAutoreleasePool (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn for suboptimal uses of NSAutoreleasePool in Objective-C GC mode. .. code-block:: objc. void test() {; NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];; [pool release]; // warn; }. .. _osx-cocoa-NSError:. osx.cocoa.NSError (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""; Check usage of NSError parameters. .. code-block:: objc. @interface A : NSObject; - (void)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error;; @end. @implementation A; - (void)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error {; // warn: method accepting NSError"""""""""""""""""""""""""""""""""""""""""""""""" should have a non-void; // return value; }; @end. @interface A : NSObject; - (BOOL)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error;; @end. @implementation A; - (BOOL)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error {; *error = 0; // warn: potential null dereference; return 0;; }; @end. .. _osx-cocoa-NilArg:. osx.cocoa.NilArg (ObjC); """"""""""""""""""""""""""""""""""""""""""""""; Check for prohibited nil arguments to ObjC method calls. - caseInsensitiveCompare:; - compare:; - compare:options:; - compare:options:range:; - compare:options:range:locale:; - componentsSeparatedByCharactersInSet:; - initWithFormat:. .. code-block:: objc. NSComparisonResult test(NSString *s) {; NSString *aString = nil;; return [s caseInsensitiveCompare:aString];; // warn: argument to 'NSString' method; // 'caseInsensitiveCompare:' cannot be nil; }. .. _osx-cocoa-NonNilReturnValue:. osx.cocoa.NonNilReturnValue; """"""""""""""""""""""""""""""""""""""""""""""""""""""; Models the APIs that are guaranteed to return a non-nil value. .. _osx-cocoa-ObjCGenerics:. osx.cocoa.ObjCGenerics (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for type errors when using Objectiv",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:40618,Integrability,interface,interface,40618,"ective-C generics. .. code-block:: objc. NSMutableArray *names = [NSMutableArray array];; NSMutableArray *birthDates = names;. // Warning: Conversion from value of type 'NSDate *'; // to incompatible type 'NSString *'; [birthDates addObject: [NSDate date]];. .. _osx-cocoa-RetainCount:. osx.cocoa.RetainCount (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for leaks and improper reference count management. .. code-block:: objc. void test() {; NSString *s = [[NSString alloc] init]; // warn; }. CFStringRef test(char *bytes) {; return CFStringCreateWithCStringNoCopy(; 0, bytes, NSNEXTSTEPStringEncoding, 0); // warn; }. .. _osx-cocoa-RunLoopAutoreleaseLeak:. osx.cocoa.RunLoopAutoreleaseLeak; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for leaked memory in autorelease pools that will never be drained. .. _osx-cocoa-SelfInit:. osx.cocoa.SelfInit (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""; Check that 'self' is properly initialized inside an initializer method. .. code-block:: objc. @interface MyObj : NSObject {; id x;; }; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; x = 0; // warn: instance variable used while 'self' is not; // initialized; return 0;; }; @end. @interface MyObj : NSObject; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; return self; // warn: returning uninitialized 'self'; }; @end. .. _osx-cocoa-SuperDealloc:. osx.cocoa.SuperDealloc (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about improper use of '[super dealloc]' in Objective-C. .. code-block:: objc. @interface SuperDeallocThenReleaseIvarClass : NSObject {; NSObject *_ivar;; }; @end. @implementation SuperDeallocThenReleaseIvarClass; - (void)dealloc {; [super dealloc];; [_ivar release]; // warn; }; @end. .. _osx-cocoa-UnusedIvars:. osx.cocoa.UnusedIvars (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about private ivars that are never used. .. code-block:: objc. @interface MyObj : NSObject {; @private; id x; // warn; }; @end. @implementation MyObj; @end. .. _osx-cocoa-VariadicMetho",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:40826,Integrability,interface,interface,40826,"pe 'NSString *'; [birthDates addObject: [NSDate date]];. .. _osx-cocoa-RetainCount:. osx.cocoa.RetainCount (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for leaks and improper reference count management. .. code-block:: objc. void test() {; NSString *s = [[NSString alloc] init]; // warn; }. CFStringRef test(char *bytes) {; return CFStringCreateWithCStringNoCopy(; 0, bytes, NSNEXTSTEPStringEncoding, 0); // warn; }. .. _osx-cocoa-RunLoopAutoreleaseLeak:. osx.cocoa.RunLoopAutoreleaseLeak; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for leaked memory in autorelease pools that will never be drained. .. _osx-cocoa-SelfInit:. osx.cocoa.SelfInit (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""; Check that 'self' is properly initialized inside an initializer method. .. code-block:: objc. @interface MyObj : NSObject {; id x;; }; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; x = 0; // warn: instance variable used while 'self' is not; // initialized; return 0;; }; @end. @interface MyObj : NSObject; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; return self; // warn: returning uninitialized 'self'; }; @end. .. _osx-cocoa-SuperDealloc:. osx.cocoa.SuperDealloc (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about improper use of '[super dealloc]' in Objective-C. .. code-block:: objc. @interface SuperDeallocThenReleaseIvarClass : NSObject {; NSObject *_ivar;; }; @end. @implementation SuperDeallocThenReleaseIvarClass; - (void)dealloc {; [super dealloc];; [_ivar release]; // warn; }; @end. .. _osx-cocoa-UnusedIvars:. osx.cocoa.UnusedIvars (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about private ivars that are never used. .. code-block:: objc. @interface MyObj : NSObject {; @private; id x; // warn; }; @end. @implementation MyObj; @end. .. _osx-cocoa-VariadicMethodTypes:. osx.cocoa.VariadicMethodTypes (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for passing non-Objective-C types to variadic collection; initialization methods that expect only Objective-C t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:41163,Integrability,interface,interface,41163,"NoCopy(; 0, bytes, NSNEXTSTEPStringEncoding, 0); // warn; }. .. _osx-cocoa-RunLoopAutoreleaseLeak:. osx.cocoa.RunLoopAutoreleaseLeak; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for leaked memory in autorelease pools that will never be drained. .. _osx-cocoa-SelfInit:. osx.cocoa.SelfInit (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""; Check that 'self' is properly initialized inside an initializer method. .. code-block:: objc. @interface MyObj : NSObject {; id x;; }; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; x = 0; // warn: instance variable used while 'self' is not; // initialized; return 0;; }; @end. @interface MyObj : NSObject; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; return self; // warn: returning uninitialized 'self'; }; @end. .. _osx-cocoa-SuperDealloc:. osx.cocoa.SuperDealloc (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about improper use of '[super dealloc]' in Objective-C. .. code-block:: objc. @interface SuperDeallocThenReleaseIvarClass : NSObject {; NSObject *_ivar;; }; @end. @implementation SuperDeallocThenReleaseIvarClass; - (void)dealloc {; [super dealloc];; [_ivar release]; // warn; }; @end. .. _osx-cocoa-UnusedIvars:. osx.cocoa.UnusedIvars (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about private ivars that are never used. .. code-block:: objc. @interface MyObj : NSObject {; @private; id x; // warn; }; @end. @implementation MyObj; @end. .. _osx-cocoa-VariadicMethodTypes:. osx.cocoa.VariadicMethodTypes (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for passing non-Objective-C types to variadic collection; initialization methods that expect only Objective-C types. .. code-block:: objc. void test() {; [NSSet setWithObjects:@""Foo"", ""Bar"", nil];; // warn: argument should be an ObjC pointer type, not 'char *'; }. .. _osx-coreFoundation-CFError:. osx.coreFoundation.CFError (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check usage of CFErrorRef* parameters. .. code-block:: c. void test(CFErrorRef *error) {; // warn: functi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:41526,Integrability,interface,interface,41526,"tialized inside an initializer method. .. code-block:: objc. @interface MyObj : NSObject {; id x;; }; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; x = 0; // warn: instance variable used while 'self' is not; // initialized; return 0;; }; @end. @interface MyObj : NSObject; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; return self; // warn: returning uninitialized 'self'; }; @end. .. _osx-cocoa-SuperDealloc:. osx.cocoa.SuperDealloc (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about improper use of '[super dealloc]' in Objective-C. .. code-block:: objc. @interface SuperDeallocThenReleaseIvarClass : NSObject {; NSObject *_ivar;; }; @end. @implementation SuperDeallocThenReleaseIvarClass; - (void)dealloc {; [super dealloc];; [_ivar release]; // warn; }; @end. .. _osx-cocoa-UnusedIvars:. osx.cocoa.UnusedIvars (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about private ivars that are never used. .. code-block:: objc. @interface MyObj : NSObject {; @private; id x; // warn; }; @end. @implementation MyObj; @end. .. _osx-cocoa-VariadicMethodTypes:. osx.cocoa.VariadicMethodTypes (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for passing non-Objective-C types to variadic collection; initialization methods that expect only Objective-C types. .. code-block:: objc. void test() {; [NSSet setWithObjects:@""Foo"", ""Bar"", nil];; // warn: argument should be an ObjC pointer type, not 'char *'; }. .. _osx-coreFoundation-CFError:. osx.coreFoundation.CFError (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check usage of CFErrorRef* parameters. .. code-block:: c. void test(CFErrorRef *error) {; // warn: function accepting CFErrorRef* should have a; // non-void return; }. int foo(CFErrorRef *error) {; *error = 0; // warn: potential null dereference; return 0;; }. .. _osx-coreFoundation-CFNumber:. osx.coreFoundation.CFNumber (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for proper uses of CFNumber APIs. .. code-block:: c. CFNumberRef test(unsigned char x) {; r",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:47924,Integrability,message,message,47924,"); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Reports similar pieces of code. .. code-block:: c. void log();. int max(int a, int b) { // warn; log();; if (a > b); return a;; return b;; }. int maxClone(int x, int y) { // similar code here; log();; if (x > y); return x;; return y;; }. alpha.core; ^^^^^^^^^^. .. _alpha-core-BoolAssignment:. alpha.core.BoolAssignment (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about assigning non-{0,1} values to boolean variables. .. code-block:: objc. void test() {; BOOL b = -1; // warn; }. .. _alpha-core-C11Lock:. alpha.core.C11Lock; """"""""""""""""""""""""""""""""""""; Similarly to :ref:`alpha.unix.PthreadLock <alpha-unix-PthreadLock>`, checks for; the locking/unlocking of ``mtx_t`` mutexes. .. code-block:: cpp. mtx_t mtx1;. void bad1(void); {; mtx_lock(&mtx1);; mtx_lock(&mtx1); // warn: This lock has already been acquired; }. .. _alpha-core-CallAndMessageUnInitRefArg:. alpha.core.CallAndMessageUnInitRefArg (C,C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for logical errors for function calls and Objective-C; message expressions (e.g., uninitialized arguments, null function pointers, and pointer to undefined variables). .. code-block:: c. void test(void) {; int t;; int &p = t;; int &s = p;; int &q = s;; foo(q); // warn; }. void test(void) {; int x;; foo(&x); // warn; }. .. _alpha-core-CastSize:. alpha.core.CastSize (C); """"""""""""""""""""""""""""""""""""""""""""""; Check when casting a malloc'ed type ``T``, whether the size is a multiple of the size of ``T``. .. code-block:: c. void test() {; int *x = (int *) malloc(11); // warn; }. .. _alpha-core-CastToStruct:. alpha.core.CastToStruct (C, C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for cast from non-struct pointer to struct pointer. .. code-block:: cpp. // C; struct s {};. void test(int *p) {; struct s *ps = (struct s *) p; // warn; }. // C++; class c {};. void test(int *p) {; c *pc = (c *) p; // warn; }. .. _alpha-core-Conversion:. alpha.core.Conversion (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:57269,Integrability,interface,interface,57269,"est(id x) {; return;; [x retain]; // warn; }. alpha.fuchsia; ^^^^^^^^^^^^^. .. _alpha-fuchsia-lock:. alpha.fuchsia.Lock; """"""""""""""""""""""""""""""""""""; Similarly to :ref:`alpha.unix.PthreadLock <alpha-unix-PthreadLock>`, checks for; the locking/unlocking of fuchsia mutexes. .. code-block:: cpp. spin_lock_t mtx1;. void bad1(void); {; spin_lock(&mtx1);; spin_lock(&mtx1);	// warn: This lock has already been acquired; }. alpha.llvm; ^^^^^^^^^^. .. _alpha-llvm-Conventions:. alpha.llvm.Conventions; """""""""""""""""""""""""""""""""""""""""""". Check code for LLVM codebase conventions:. * A StringRef should not be bound to a temporary std::string whose lifetime is shorter than the StringRef's.; * Clang AST nodes should not have fields that can allocate memory. alpha.osx; ^^^^^^^^^. .. _alpha-osx-cocoa-DirectIvarAssignment:. alpha.osx.cocoa.DirectIvarAssignment (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for direct assignments to instance variables. .. code-block:: objc. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) foo;; @end. @implementation MyClass; - (void) foo {; _A = 0; // warn; }; @end. .. _alpha-osx-cocoa-DirectIvarAssignmentForAnnotatedFunctions:. alpha.osx.cocoa.DirectIvarAssignmentForAnnotatedFunctions (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for direct assignments to instance variables in; the methods annotated with ``objc_no_direct_instance_variable_assignment``. .. code-block:: objc. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) fAnnotated __attribute__((; annotate(""objc_no_direct_instance_variable_assignment"")));; - (void) fNotAnnotated;; @end. @implementation MyClass; - (void) fAnnotated {; _A = 0; // warn; }; - (void) fNotAnnotated {; _A = 0; // no warn; }; @end. .. _alpha-osx-cocoa-InstanceVariableInvalidation:. alpha.osx.cocoa.InstanceVariableInvalidation (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check that the invalidatable instance variables are; invalidated in the ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:57768,Integrability,interface,interface,57768," * A StringRef should not be bound to a temporary std::string whose lifetime is shorter than the StringRef's.; * Clang AST nodes should not have fields that can allocate memory. alpha.osx; ^^^^^^^^^. .. _alpha-osx-cocoa-DirectIvarAssignment:. alpha.osx.cocoa.DirectIvarAssignment (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for direct assignments to instance variables. .. code-block:: objc. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) foo;; @end. @implementation MyClass; - (void) foo {; _A = 0; // warn; }; @end. .. _alpha-osx-cocoa-DirectIvarAssignmentForAnnotatedFunctions:. alpha.osx.cocoa.DirectIvarAssignmentForAnnotatedFunctions (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for direct assignments to instance variables in; the methods annotated with ``objc_no_direct_instance_variable_assignment``. .. code-block:: objc. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) fAnnotated __attribute__((; annotate(""objc_no_direct_instance_variable_assignment"")));; - (void) fNotAnnotated;; @end. @implementation MyClass; - (void) fAnnotated {; _A = 0; // warn; }; - (void) fNotAnnotated {; _A = 0; // no warn; }; @end. .. _alpha-osx-cocoa-InstanceVariableInvalidation:. alpha.osx.cocoa.InstanceVariableInvalidation (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check that the invalidatable instance variables are; invalidated in the methods annotated with objc_instance_variable_invalidator. .. code-block:: objc. @protocol Invalidation <NSObject>; - (void) invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface InvalidationImpObj : NSObject <Invalidation>; @end. @interface SubclassInvalidationImpObj : InvalidationImpObj {; InvalidationImpObj *var;; }; - (void)invalidate;; @end. @implementation SubclassInvalidationImpObj; - (void) invalidate {}; @end; // warn: var needs to be invalidated or set to nil. .. _alpha-osx-cocoa-MissingInvalidat",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:58391,Integrability,protocol,protocol,58391,"nmentForAnnotatedFunctions:. alpha.osx.cocoa.DirectIvarAssignmentForAnnotatedFunctions (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for direct assignments to instance variables in; the methods annotated with ``objc_no_direct_instance_variable_assignment``. .. code-block:: objc. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) fAnnotated __attribute__((; annotate(""objc_no_direct_instance_variable_assignment"")));; - (void) fNotAnnotated;; @end. @implementation MyClass; - (void) fAnnotated {; _A = 0; // warn; }; - (void) fNotAnnotated {; _A = 0; // no warn; }; @end. .. _alpha-osx-cocoa-InstanceVariableInvalidation:. alpha.osx.cocoa.InstanceVariableInvalidation (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check that the invalidatable instance variables are; invalidated in the methods annotated with objc_instance_variable_invalidator. .. code-block:: objc. @protocol Invalidation <NSObject>; - (void) invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface InvalidationImpObj : NSObject <Invalidation>; @end. @interface SubclassInvalidationImpObj : InvalidationImpObj {; InvalidationImpObj *var;; }; - (void)invalidate;; @end. @implementation SubclassInvalidationImpObj; - (void) invalidate {}; @end; // warn: var needs to be invalidated or set to nil. .. _alpha-osx-cocoa-MissingInvalidationMethod:. alpha.osx.cocoa.MissingInvalidationMethod (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check that the invalidation methods are present in classes that contain invalidatable instance variables. .. code-block:: objc. @protocol Invalidation <NSObject>; - (void)invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface NeedInvalidation : NSObject <Invalidation>; @end. @interface MissingInvalidationMethodDecl : NSObject {; NeedInvalidation *Var; // warn; }; @end. @implementation MissingInvalidationMethodDecl; @end. .. _alpha-osx-c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:58519,Integrability,interface,interface,58519,"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for direct assignments to instance variables in; the methods annotated with ``objc_no_direct_instance_variable_assignment``. .. code-block:: objc. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) fAnnotated __attribute__((; annotate(""objc_no_direct_instance_variable_assignment"")));; - (void) fNotAnnotated;; @end. @implementation MyClass; - (void) fAnnotated {; _A = 0; // warn; }; - (void) fNotAnnotated {; _A = 0; // no warn; }; @end. .. _alpha-osx-cocoa-InstanceVariableInvalidation:. alpha.osx.cocoa.InstanceVariableInvalidation (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check that the invalidatable instance variables are; invalidated in the methods annotated with objc_instance_variable_invalidator. .. code-block:: objc. @protocol Invalidation <NSObject>; - (void) invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface InvalidationImpObj : NSObject <Invalidation>; @end. @interface SubclassInvalidationImpObj : InvalidationImpObj {; InvalidationImpObj *var;; }; - (void)invalidate;; @end. @implementation SubclassInvalidationImpObj; - (void) invalidate {}; @end; // warn: var needs to be invalidated or set to nil. .. _alpha-osx-cocoa-MissingInvalidationMethod:. alpha.osx.cocoa.MissingInvalidationMethod (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check that the invalidation methods are present in classes that contain invalidatable instance variables. .. code-block:: objc. @protocol Invalidation <NSObject>; - (void)invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface NeedInvalidation : NSObject <Invalidation>; @end. @interface MissingInvalidationMethodDecl : NSObject {; NeedInvalidation *Var; // warn; }; @end. @implementation MissingInvalidationMethodDecl; @end. .. _alpha-osx-cocoa-localizability-PluralMisuseChecker:. alpha.osx.cocoa.localizability.PluralMisuseChecker (Ob",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:58582,Integrability,interface,interface,58582,"nts to instance variables in; the methods annotated with ``objc_no_direct_instance_variable_assignment``. .. code-block:: objc. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) fAnnotated __attribute__((; annotate(""objc_no_direct_instance_variable_assignment"")));; - (void) fNotAnnotated;; @end. @implementation MyClass; - (void) fAnnotated {; _A = 0; // warn; }; - (void) fNotAnnotated {; _A = 0; // no warn; }; @end. .. _alpha-osx-cocoa-InstanceVariableInvalidation:. alpha.osx.cocoa.InstanceVariableInvalidation (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check that the invalidatable instance variables are; invalidated in the methods annotated with objc_instance_variable_invalidator. .. code-block:: objc. @protocol Invalidation <NSObject>; - (void) invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface InvalidationImpObj : NSObject <Invalidation>; @end. @interface SubclassInvalidationImpObj : InvalidationImpObj {; InvalidationImpObj *var;; }; - (void)invalidate;; @end. @implementation SubclassInvalidationImpObj; - (void) invalidate {}; @end; // warn: var needs to be invalidated or set to nil. .. _alpha-osx-cocoa-MissingInvalidationMethod:. alpha.osx.cocoa.MissingInvalidationMethod (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check that the invalidation methods are present in classes that contain invalidatable instance variables. .. code-block:: objc. @protocol Invalidation <NSObject>; - (void)invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface NeedInvalidation : NSObject <Invalidation>; @end. @interface MissingInvalidationMethodDecl : NSObject {; NeedInvalidation *Var; // warn; }; @end. @implementation MissingInvalidationMethodDecl; @end. .. _alpha-osx-cocoa-localizability-PluralMisuseChecker:. alpha.osx.cocoa.localizability.PluralMisuseChecker (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns against using one vs",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:59102,Integrability,protocol,protocol,59102,"Invalidation (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check that the invalidatable instance variables are; invalidated in the methods annotated with objc_instance_variable_invalidator. .. code-block:: objc. @protocol Invalidation <NSObject>; - (void) invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface InvalidationImpObj : NSObject <Invalidation>; @end. @interface SubclassInvalidationImpObj : InvalidationImpObj {; InvalidationImpObj *var;; }; - (void)invalidate;; @end. @implementation SubclassInvalidationImpObj; - (void) invalidate {}; @end; // warn: var needs to be invalidated or set to nil. .. _alpha-osx-cocoa-MissingInvalidationMethod:. alpha.osx.cocoa.MissingInvalidationMethod (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check that the invalidation methods are present in classes that contain invalidatable instance variables. .. code-block:: objc. @protocol Invalidation <NSObject>; - (void)invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface NeedInvalidation : NSObject <Invalidation>; @end. @interface MissingInvalidationMethodDecl : NSObject {; NeedInvalidation *Var; // warn; }; @end. @implementation MissingInvalidationMethodDecl; @end. .. _alpha-osx-cocoa-localizability-PluralMisuseChecker:. alpha.osx.cocoa.localizability.PluralMisuseChecker (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns against using one vs. many plural pattern in code when generating localized strings. .. code-block:: objc. NSString *reminderText =; NSLocalizedString(@""None"", @""Indicates no reminders"");; if (reminderCount == 1) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; NSLocalizedString(@""1 Reminder"", @""Indicates single reminder"");; } else if (reminderCount >= 2) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderTe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:59229,Integrability,interface,interface,59229,"idatable instance variables are; invalidated in the methods annotated with objc_instance_variable_invalidator. .. code-block:: objc. @protocol Invalidation <NSObject>; - (void) invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface InvalidationImpObj : NSObject <Invalidation>; @end. @interface SubclassInvalidationImpObj : InvalidationImpObj {; InvalidationImpObj *var;; }; - (void)invalidate;; @end. @implementation SubclassInvalidationImpObj; - (void) invalidate {}; @end; // warn: var needs to be invalidated or set to nil. .. _alpha-osx-cocoa-MissingInvalidationMethod:. alpha.osx.cocoa.MissingInvalidationMethod (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check that the invalidation methods are present in classes that contain invalidatable instance variables. .. code-block:: objc. @protocol Invalidation <NSObject>; - (void)invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface NeedInvalidation : NSObject <Invalidation>; @end. @interface MissingInvalidationMethodDecl : NSObject {; NeedInvalidation *Var; // warn; }; @end. @implementation MissingInvalidationMethodDecl; @end. .. _alpha-osx-cocoa-localizability-PluralMisuseChecker:. alpha.osx.cocoa.localizability.PluralMisuseChecker (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns against using one vs. many plural pattern in code when generating localized strings. .. code-block:: objc. NSString *reminderText =; NSLocalizedString(@""None"", @""Indicates no reminders"");; if (reminderCount == 1) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; NSLocalizedString(@""1 Reminder"", @""Indicates single reminder"");; } else if (reminderCount >= 2) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; [NSString stringWithFormat:; NSLocalizedString(@""%@ Reminders"", @""Indicates multiple rem",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:59290,Integrability,interface,interface,59290,"_instance_variable_invalidator. .. code-block:: objc. @protocol Invalidation <NSObject>; - (void) invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface InvalidationImpObj : NSObject <Invalidation>; @end. @interface SubclassInvalidationImpObj : InvalidationImpObj {; InvalidationImpObj *var;; }; - (void)invalidate;; @end. @implementation SubclassInvalidationImpObj; - (void) invalidate {}; @end; // warn: var needs to be invalidated or set to nil. .. _alpha-osx-cocoa-MissingInvalidationMethod:. alpha.osx.cocoa.MissingInvalidationMethod (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check that the invalidation methods are present in classes that contain invalidatable instance variables. .. code-block:: objc. @protocol Invalidation <NSObject>; - (void)invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface NeedInvalidation : NSObject <Invalidation>; @end. @interface MissingInvalidationMethodDecl : NSObject {; NeedInvalidation *Var; // warn; }; @end. @implementation MissingInvalidationMethodDecl; @end. .. _alpha-osx-cocoa-localizability-PluralMisuseChecker:. alpha.osx.cocoa.localizability.PluralMisuseChecker (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns against using one vs. many plural pattern in code when generating localized strings. .. code-block:: objc. NSString *reminderText =; NSLocalizedString(@""None"", @""Indicates no reminders"");; if (reminderCount == 1) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; NSLocalizedString(@""1 Reminder"", @""Indicates single reminder"");; } else if (reminderCount >= 2) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; [NSString stringWithFormat:; NSLocalizedString(@""%@ Reminders"", @""Indicates multiple reminders""),; reminderCount];; }. alpha.security; ^^^^^^^^^^^^^^. .. _alpha-secur",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:65699,Integrability,inject,inject,65699,"t overwritten; and when, it needs to be slightly more aggressive and warn for such; cases too, leading in some cases to false-positive reports like this:. .. code-block:: c. void baz() {; char env[] = ""NAME=value"";; putenv(env); // false-positive warning: putenv function should not be called...; // More code...; putenv((char *)""NAME=anothervalue"");; // This putenv call overwrites the previous entry, thus that can no longer dangle.; } // 'env' array becomes dead only here. alpha.security.cert.env; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `Environment C coding rules <https://wiki.sei.cmu.edu/confluence/x/JdcxBQ>`_. alpha.security.taint; ^^^^^^^^^^^^^^^^^^^^. Checkers implementing; `taint analysis <https://en.wikipedia.org/wiki/Taint_checking>`_. .. _alpha-security-taint-TaintPropagation:. alpha.security.taint.TaintPropagation (C, C++); """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Taint analysis identifies potential security vulnerabilities where the; attacker can inject malicious data to the program to execute an attack; (privilege escalation, command injection, SQL injection etc.). The malicious data is injected at the taint source (e.g. ``getenv()`` call); which is then propagated through function calls and being used as arguments of; sensitive operations, also called as taint sinks (e.g. ``system()`` call). One can defend against this type of vulnerability by always checking and; sanitizing the potentially malicious, untrusted user input. The goal of the checker is to discover and show to the user these potential; taint source-sink pairs and the propagation call chain. The most notable examples of taint sources are:. - data from network; - files or standard input; - environment variables; - data from databases. Let us examine a practical example of a Command Injection attack. .. code-block:: c. // Command Injection Vulnerability Example; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %10",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:65789,Integrability,inject,injection,65789,"t overwritten; and when, it needs to be slightly more aggressive and warn for such; cases too, leading in some cases to false-positive reports like this:. .. code-block:: c. void baz() {; char env[] = ""NAME=value"";; putenv(env); // false-positive warning: putenv function should not be called...; // More code...; putenv((char *)""NAME=anothervalue"");; // This putenv call overwrites the previous entry, thus that can no longer dangle.; } // 'env' array becomes dead only here. alpha.security.cert.env; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `Environment C coding rules <https://wiki.sei.cmu.edu/confluence/x/JdcxBQ>`_. alpha.security.taint; ^^^^^^^^^^^^^^^^^^^^. Checkers implementing; `taint analysis <https://en.wikipedia.org/wiki/Taint_checking>`_. .. _alpha-security-taint-TaintPropagation:. alpha.security.taint.TaintPropagation (C, C++); """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Taint analysis identifies potential security vulnerabilities where the; attacker can inject malicious data to the program to execute an attack; (privilege escalation, command injection, SQL injection etc.). The malicious data is injected at the taint source (e.g. ``getenv()`` call); which is then propagated through function calls and being used as arguments of; sensitive operations, also called as taint sinks (e.g. ``system()`` call). One can defend against this type of vulnerability by always checking and; sanitizing the potentially malicious, untrusted user input. The goal of the checker is to discover and show to the user these potential; taint source-sink pairs and the propagation call chain. The most notable examples of taint sources are:. - data from network; - files or standard input; - environment variables; - data from databases. Let us examine a practical example of a Command Injection attack. .. code-block:: c. // Command Injection Vulnerability Example; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %10",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:65804,Integrability,inject,injection,65804,"t overwritten; and when, it needs to be slightly more aggressive and warn for such; cases too, leading in some cases to false-positive reports like this:. .. code-block:: c. void baz() {; char env[] = ""NAME=value"";; putenv(env); // false-positive warning: putenv function should not be called...; // More code...; putenv((char *)""NAME=anothervalue"");; // This putenv call overwrites the previous entry, thus that can no longer dangle.; } // 'env' array becomes dead only here. alpha.security.cert.env; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `Environment C coding rules <https://wiki.sei.cmu.edu/confluence/x/JdcxBQ>`_. alpha.security.taint; ^^^^^^^^^^^^^^^^^^^^. Checkers implementing; `taint analysis <https://en.wikipedia.org/wiki/Taint_checking>`_. .. _alpha-security-taint-TaintPropagation:. alpha.security.taint.TaintPropagation (C, C++); """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Taint analysis identifies potential security vulnerabilities where the; attacker can inject malicious data to the program to execute an attack; (privilege escalation, command injection, SQL injection etc.). The malicious data is injected at the taint source (e.g. ``getenv()`` call); which is then propagated through function calls and being used as arguments of; sensitive operations, also called as taint sinks (e.g. ``system()`` call). One can defend against this type of vulnerability by always checking and; sanitizing the potentially malicious, untrusted user input. The goal of the checker is to discover and show to the user these potential; taint source-sink pairs and the propagation call chain. The most notable examples of taint sources are:. - data from network; - files or standard input; - environment variables; - data from databases. Let us examine a practical example of a Command Injection attack. .. code-block:: c. // Command Injection Vulnerability Example; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %10",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:65843,Integrability,inject,injected,65843,"ve reports like this:. .. code-block:: c. void baz() {; char env[] = ""NAME=value"";; putenv(env); // false-positive warning: putenv function should not be called...; // More code...; putenv((char *)""NAME=anothervalue"");; // This putenv call overwrites the previous entry, thus that can no longer dangle.; } // 'env' array becomes dead only here. alpha.security.cert.env; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `Environment C coding rules <https://wiki.sei.cmu.edu/confluence/x/JdcxBQ>`_. alpha.security.taint; ^^^^^^^^^^^^^^^^^^^^. Checkers implementing; `taint analysis <https://en.wikipedia.org/wiki/Taint_checking>`_. .. _alpha-security-taint-TaintPropagation:. alpha.security.taint.TaintPropagation (C, C++); """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Taint analysis identifies potential security vulnerabilities where the; attacker can inject malicious data to the program to execute an attack; (privilege escalation, command injection, SQL injection etc.). The malicious data is injected at the taint source (e.g. ``getenv()`` call); which is then propagated through function calls and being used as arguments of; sensitive operations, also called as taint sinks (e.g. ``system()`` call). One can defend against this type of vulnerability by always checking and; sanitizing the potentially malicious, untrusted user input. The goal of the checker is to discover and show to the user these potential; taint source-sink pairs and the propagation call chain. The most notable examples of taint sources are:. - data from network; - files or standard input; - environment variables; - data from databases. Let us examine a practical example of a Command Injection attack. .. code-block:: c. // Command Injection Vulnerability Example; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; strcat(cmd, filename);; system(cmd); // Warning: Untrusted data",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:66757,Integrability,inject,inject,66757,"s data to the program to execute an attack; (privilege escalation, command injection, SQL injection etc.). The malicious data is injected at the taint source (e.g. ``getenv()`` call); which is then propagated through function calls and being used as arguments of; sensitive operations, also called as taint sinks (e.g. ``system()`` call). One can defend against this type of vulnerability by always checking and; sanitizing the potentially malicious, untrusted user input. The goal of the checker is to discover and show to the user these potential; taint source-sink pairs and the propagation call chain. The most notable examples of taint sources are:. - data from network; - files or standard input; - environment variables; - data from databases. Let us examine a practical example of a Command Injection attack. .. code-block:: c. // Command Injection Vulnerability Example; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; strcat(cmd, filename);; system(cmd); // Warning: Untrusted data is passed to a system call; }. The program prints the content of any user specified file.; Unfortunately the attacker can execute arbitrary commands; with shell escapes. For example with the following input the `ls` command is also; executed after the contents of `/etc/shadow` is printed.; `Input: /etc/shadow ; ls /`. The analysis implemented in this checker points out this problem. One can protect against such attack by for example checking if the provided; input refers to a valid file and removing any invalid user input. .. code-block:: c. // No vulnerability anymore, but we still get the warning; void sanitizeFileName(char* filename){; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; filename[0]='\0';; }; }; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"")",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:67770,Integrability,inject,inject,67770,":"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; strcat(cmd, filename);; system(cmd); // Warning: Untrusted data is passed to a system call; }. The program prints the content of any user specified file.; Unfortunately the attacker can execute arbitrary commands; with shell escapes. For example with the following input the `ls` command is also; executed after the contents of `/etc/shadow` is printed.; `Input: /etc/shadow ; ls /`. The analysis implemented in this checker points out this problem. One can protect against such attack by for example checking if the provided; input refers to a valid file and removing any invalid user input. .. code-block:: c. // No vulnerability anymore, but we still get the warning; void sanitizeFileName(char* filename){; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; filename[0]='\0';; }; }; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; sanitizeFileName(filename);// filename is safe after this point; if (!filename[0]); return -1;; strcat(cmd, filename);; system(cmd); // Superfluous Warning: Untrusted data is passed to a system call; }. Unfortunately, the checker cannot discover automatically that the programmer; have performed data sanitation, so it still emits the warning. One can get rid of this superfluous warning by telling by specifying the; sanitation functions in the taint configuration file (see; :doc:`user-docs/TaintAnalysisConfiguration`). .. code-block:: YAML. Filters:; - Name: sanitizeFileName; Args: [0]. The clang invocation to pass the configuration file location:. .. code-block:: bash. clang --analyze -Xclang -analyzer-config -Xclang alpha.security.taint.TaintPropagation:Config=`pwd`/taint_config.yml ... If you are validating your inputs instead of sanitizing them, or don't want to; mention each sanitizin",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:70225,Integrability,inject,injection,70225,"[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename);; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; return -1;; }; #ifdef __clang_analyzer__; csa_mark_sanitized(filename); // Indicating to CSA that filename variable is safe to be used after this point; #endif; strcat(cmd, filename);; system(cmd); // No warning; }. Similarly to the previous example, you need to; define a `Filter` function in a `YAML` configuration file; and add the `csa_mark_sanitized` function. .. code-block:: YAML. Filters:; - Name: csa_mark_sanitized; Args: [0]. Then calling `csa_mark_sanitized(X)` will tell the analyzer that `X` is safe to; be used after this point, because its contents are verified. It is the; responsibility of the programmer to ensure that this verification was indeed; correct. Please note that `csa_mark_sanitized` function is only declared and; used during Clang Static Analysis and skipped in (production) builds. Further examples of injection vulnerabilities this checker can find. .. code-block:: c. void test() {; char x = getchar(); // 'x' marked as tainted; system(&x); // warn: untrusted data is passed to a system call; }. // note: compiler internally checks if the second param to; // sprintf is a string literal or not.; // Use -Wno-format-security to suppress compiler warning.; void test() {; char s[10], buf[10];; fscanf(stdin, ""%s"", s); // 's' marked as tainted. sprintf(buf, s); // warn: untrusted data used as a format string; }. void test() {; size_t ts;; scanf(""%zd"", &ts); // 'ts' marked as tainted; int *p = (int *)malloc(ts * sizeof(int));; // warn: untrusted data used as buffer size; }. There are built-in sources, propagations and sinks even if no external taint; configuration is provided. Default sources:; ``_IO_getc``, ``fdopen``, ``fopen``, ``freopen``, ``get_current_dir_name``,; ``getch``, ``getchar``, ``getchar_unlocked``, ``getwd``, ``getcwd``,; ``getgroups``, ``gethostname``, ``getlogin``, ``getlogin_r``, ``getna",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:1464,Modifiability,config,config,1464,"e checkers are under development and are switched off by default. They may crash or emit a higher number of false positives. The :ref:`debug-checkers` package contains checkers for analyzer developers for debugging purposes. .. contents:: Table of Contents; :depth: 4. .. _default-checkers:. Default Checkers; ----------------. .. _core-checkers:. core; ^^^^; Models core language features and contains general-purpose checkers such as division by zero,; null pointer dereference, usage of uninitialized values, etc.; *These checkers must be always switched on as other checker rely on them.*. .. _core-BitwiseShift:. core.BitwiseShift (C, C++); """""""""""""""""""""""""""""""""""""""""""""""""""". Finds undefined behavior caused by the bitwise left- and right-shift operator; operating on integer types. By default, this checker only reports situations when the right operand is; either negative or larger than the bit width of the type of the left operand;; these are logically unsound. Moreover, if the pedantic mode is activated by; ``-analyzer-config core.BitwiseShift:Pedantic=true``, then this checker also; reports situations where the _left_ operand of a shift operator is negative or; overflow occurs during the right shift of a signed value. (Most compilers; handle these predictably, but the C standard and the C++ standards before C++20; say that they're undefined behavior. In the C++20 standard these constructs are; well-defined, so activating pedantic mode in C++20 has no effect.). **Examples**. .. code-block:: cpp. static_assert(sizeof(int) == 4, ""assuming 32-bit int""). void basic_examples(int a, int b) {; if (b < 0) {; b = a << b; // warn: right operand is negative in left shift; } else if (b >= 32) {; b = a >> b; // warn: right shift overflows the capacity of 'int'; }; }. int pedantic_examples(int a, int b) {; if (a < 0) {; return a >> b; // warn: left operand is negative in right shift; }; a = 1000u << 31; // OK, overflow of unsigned value is well-defined, a == 0; if (b > 10) {; a = b << 31; /",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:4202,Modifiability,config,config,4202,"nguage: c. .. _core-NonNullParamChecker:. core.NonNullParamChecker (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for null pointers passed as arguments to a function whose arguments are references or marked with the 'nonnull' attribute. .. code-block:: cpp. int f(int *p) __attribute__((nonnull));. void test(int *p) {; if (!p); f(p); // warn; }. .. _core-NullDereference:. core.NullDereference (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for dereferences of null pointers. This checker specifically does; not report null pointer dereferences for x86 and x86-64 targets when the; address space is 256 (x86 GS Segment), 257 (x86 FS Segment), or 258 (x86 SS; segment). See `X86/X86-64 Language Extensions; <https://clang.llvm.org/docs/LanguageExtensions.html#memory-references-to-specified-segments>`__; for reference. The ``SuppressAddressSpaces`` option suppresses; warnings for null dereferences of all pointers with address spaces. You can; disable this behavior with the option; ``-analyzer-config core.NullDereference:SuppressAddressSpaces=false``.; *Defaults to true*. .. code-block:: objc. // C; void test(int *p) {; if (p); return;. int x = p[0]; // warn; }. // C; void test(int *p) {; if (!p); *p = 0; // warn; }. // C++; class C {; public:; int x;; };. void test() {; C *pc = 0;; int k = pc->x; // warn; }. // Objective-C; @interface MyClass {; @public; int x;; }; @end. void test() {; MyClass *obj = 0;; obj->x = 1; // warn; }. .. _core-StackAddressEscape:. core.StackAddressEscape (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""; Check that addresses to stack memory do not escape the function. .. code-block:: c. char const *p;. void test() {; char const str[] = ""string"";; p = str; // warn; }. void* test() {; return __builtin_alloca(12); // warn; }. void test() {; static int *x;; int y;; x = &y; // warn; }. .. _core-UndefinedBinaryOperatorResult:. core.UndefinedBinaryOperatorResult (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for undefined results of binary ope",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:10302,Modifiability,variab,variables,10302,"nment:. cplusplus.SelfAssignment (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Checks C++ copy and move assignment operators for self assignment. .. _cplusplus-StringChecker:. cplusplus.StringChecker (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Checks std::string operations. Checks if the cstring pointer from which the ``std::string`` object is; constructed is ``NULL`` or not.; If the checker cannot reason about the nullness of the pointer it will assume; that it was non-null to satisfy the precondition of the constructor. This checker is capable of checking the `SEI CERT C++ coding rule STR51-CPP.; Do not attempt to create a std::string from a null pointer; <https://wiki.sei.cmu.edu/confluence/x/E3s-BQ>`__. .. code-block:: cpp. #include <string>. void f(const char *p) {; if (!p) {; std::string msg(p); // warn: The parameter must not be null; }; }. .. _deadcode-checkers:. deadcode; ^^^^^^^^. Dead Code Checkers. .. _deadcode-DeadStores:. deadcode.DeadStores (C); """"""""""""""""""""""""""""""""""""""""""""""; Check for values stored to variables that are never read afterwards. .. code-block:: c. void test() {; int x;; x = 1; // warn; }. The ``WarnForDeadNestedAssignments`` option enables the checker to emit; warnings for nested dead assignments. You can disable with the; ``-analyzer-config deadcode.DeadStores:WarnForDeadNestedAssignments=false``.; *Defaults to true*. Would warn for this e.g.:; if ((y = make_int())) {; }. .. _nullability-checkers:. nullability; ^^^^^^^^^^^. Objective C checkers that warn for null pointer passing and dereferencing errors. .. _nullability-NullPassedToNonnull:. nullability.NullPassedToNonnull (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns when a null pointer is passed to a pointer which has a _Nonnull type. .. code-block:: objc. if (name != nil); return;; // Warning: nil passed to a callee that requires a non-null 1st parameter; NSString *greeting = [@""Hello "" stringByAppendingString:name];. .. _nullability-NullReturnedFromNonnull:. nullability.NullReturnedFromNonnull",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:10554,Modifiability,config,config,10554,"ations. Checks if the cstring pointer from which the ``std::string`` object is; constructed is ``NULL`` or not.; If the checker cannot reason about the nullness of the pointer it will assume; that it was non-null to satisfy the precondition of the constructor. This checker is capable of checking the `SEI CERT C++ coding rule STR51-CPP.; Do not attempt to create a std::string from a null pointer; <https://wiki.sei.cmu.edu/confluence/x/E3s-BQ>`__. .. code-block:: cpp. #include <string>. void f(const char *p) {; if (!p) {; std::string msg(p); // warn: The parameter must not be null; }; }. .. _deadcode-checkers:. deadcode; ^^^^^^^^. Dead Code Checkers. .. _deadcode-DeadStores:. deadcode.DeadStores (C); """"""""""""""""""""""""""""""""""""""""""""""; Check for values stored to variables that are never read afterwards. .. code-block:: c. void test() {; int x;; x = 1; // warn; }. The ``WarnForDeadNestedAssignments`` option enables the checker to emit; warnings for nested dead assignments. You can disable with the; ``-analyzer-config deadcode.DeadStores:WarnForDeadNestedAssignments=false``.; *Defaults to true*. Would warn for this e.g.:; if ((y = make_int())) {; }. .. _nullability-checkers:. nullability; ^^^^^^^^^^^. Objective C checkers that warn for null pointer passing and dereferencing errors. .. _nullability-NullPassedToNonnull:. nullability.NullPassedToNonnull (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns when a null pointer is passed to a pointer which has a _Nonnull type. .. code-block:: objc. if (name != nil); return;; // Warning: nil passed to a callee that requires a non-null 1st parameter; NSString *greeting = [@""Hello "" stringByAppendingString:name];. .. _nullability-NullReturnedFromNonnull:. nullability.NullReturnedFromNonnull (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns when a null pointer is returned from a function that has _Nonnull return type. .. code-block:: objc. - (nonnull id)firstChild {; id result = nil;; if ([_children count] > 0); result = _children[0",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:12839,Modifiability,portab,portability,12839,"t {; int data;; struct LinkedList *next;; };. struct LinkedList * _Nullable getNext(struct LinkedList *l);. void updateNextData(struct LinkedList *list, int newData) {; struct LinkedList *next = getNext(list);; // Warning: Nullable pointer is dereferenced; next->data = 7;; }. .. _nullability-NullablePassedToNonnull:. nullability.NullablePassedToNonnull (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns when a nullable pointer is passed to a pointer which has a _Nonnull type. .. code-block:: objc. typedef struct Dummy { int val; } Dummy;; Dummy *_Nullable returnsNullable();; void takesNonnull(Dummy *_Nonnull);. void test() {; Dummy *p = returnsNullable();; takesNonnull(p); // warn; }. .. _nullability-NullableReturnedFromNonnull:. nullability.NullableReturnedFromNonnull (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns when a nullable pointer is returned from a function that has _Nonnull return type. .. _optin-checkers:. optin; ^^^^^. Checkers for portability, performance or coding style specific rules. .. _optin-core-EnumCastOutOfRange:. optin.core.EnumCastOutOfRange (C, C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for integer to enumeration casts that would produce a value with no; corresponding enumerator. This is not necessarily undefined behavior, but can; lead to nasty surprises, so projects may decide to use a coding standard that; disallows these ""unusual"" conversions. Note that no warnings are produced when the enum type (e.g. `std::byte`) has no; enumerators at all. .. code-block:: cpp. enum WidgetKind { A=1, B, C, X=99 };. void foo() {; WidgetKind c = static_cast<WidgetKind>(3); // OK; WidgetKind x = static_cast<WidgetKind>(99); // OK; WidgetKind d = static_cast<WidgetKind>(4); // warn; }. **Limitations**. This checker does not accept the coding pattern where an enum type is used to; store combinations of flag values:. .. code-block:: cpp. enum AnimalFlags; {; HasClaws = 1,; CanFly = 2,; EatsFish = 4,; Endangered = 8; };. AnimalFla",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:14467,Modifiability,inherit,inherited,14467,"tKind x = static_cast<WidgetKind>(99); // OK; WidgetKind d = static_cast<WidgetKind>(4); // warn; }. **Limitations**. This checker does not accept the coding pattern where an enum type is used to; store combinations of flag values:. .. code-block:: cpp. enum AnimalFlags; {; HasClaws = 1,; CanFly = 2,; EatsFish = 4,; Endangered = 8; };. AnimalFlags operator|(AnimalFlags a, AnimalFlags b); {; return static_cast<AnimalFlags>(static_cast<int>(a) | static_cast<int>(b));; }. auto flags = HasClaws | CanFly;. Projects that use this pattern should not enable this optin checker. .. _optin-cplusplus-UninitializedObject:. optin.cplusplus.UninitializedObject (C++); """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". This checker reports uninitialized fields in objects created after a constructor; call. It doesn't only find direct uninitialized fields, but rather makes a deep; inspection of the object, analyzing all of its fields' subfields.; The checker regards inherited fields as direct fields, so one will receive; warnings for uninitialized inherited data members as well. .. code-block:: cpp. // With Pedantic and CheckPointeeInitialization set to true. struct A {; struct B {; int x; // note: uninitialized field 'this->b.x'; // note: uninitialized field 'this->bptr->x'; int y; // note: uninitialized field 'this->b.y'; // note: uninitialized field 'this->bptr->y'; };; int *iptr; // note: uninitialized pointer 'this->iptr'; B b;; B *bptr;; char *cptr; // note: uninitialized pointee 'this->cptr'. A (B *bptr, char *cptr) : bptr(bptr), cptr(cptr) {}; };. void f() {; A::B b;; char c;; A a(&b, &c); // warning: 6 uninitialized fields; // after the constructor call; }. // With Pedantic set to false and; // CheckPointeeInitialization set to true; // (every field is uninitialized). struct A {; struct B {; int x;; int y;; };; int *iptr;; B b;; B *bptr;; char *cptr;. A (B *bptr, char *cptr) : bptr(bptr), cptr(cptr) {}; };. void f() {; A::B b;; char c;; A a(&b, &c); // no warning; }. // With Pedantic",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:14550,Modifiability,inherit,inherited,14550,"tKind x = static_cast<WidgetKind>(99); // OK; WidgetKind d = static_cast<WidgetKind>(4); // warn; }. **Limitations**. This checker does not accept the coding pattern where an enum type is used to; store combinations of flag values:. .. code-block:: cpp. enum AnimalFlags; {; HasClaws = 1,; CanFly = 2,; EatsFish = 4,; Endangered = 8; };. AnimalFlags operator|(AnimalFlags a, AnimalFlags b); {; return static_cast<AnimalFlags>(static_cast<int>(a) | static_cast<int>(b));; }. auto flags = HasClaws | CanFly;. Projects that use this pattern should not enable this optin checker. .. _optin-cplusplus-UninitializedObject:. optin.cplusplus.UninitializedObject (C++); """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". This checker reports uninitialized fields in objects created after a constructor; call. It doesn't only find direct uninitialized fields, but rather makes a deep; inspection of the object, analyzing all of its fields' subfields.; The checker regards inherited fields as direct fields, so one will receive; warnings for uninitialized inherited data members as well. .. code-block:: cpp. // With Pedantic and CheckPointeeInitialization set to true. struct A {; struct B {; int x; // note: uninitialized field 'this->b.x'; // note: uninitialized field 'this->bptr->x'; int y; // note: uninitialized field 'this->b.y'; // note: uninitialized field 'this->bptr->y'; };; int *iptr; // note: uninitialized pointer 'this->iptr'; B b;; B *bptr;; char *cptr; // note: uninitialized pointee 'this->cptr'. A (B *bptr, char *cptr) : bptr(bptr), cptr(cptr) {}; };. void f() {; A::B b;; char c;; A a(&b, &c); // warning: 6 uninitialized fields; // after the constructor call; }. // With Pedantic set to false and; // CheckPointeeInitialization set to true; // (every field is uninitialized). struct A {; struct B {; int x;; int y;; };; int *iptr;; B b;; B *bptr;; char *cptr;. A (B *bptr, char *cptr) : bptr(bptr), cptr(cptr) {}; };. void f() {; A::B b;; char c;; A a(&b, &c); // no warning; }. // With Pedantic",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:16099,Modifiability,config,config,16099,"A a(&b, &c); // warning: 6 uninitialized fields; // after the constructor call; }. // With Pedantic set to false and; // CheckPointeeInitialization set to true; // (every field is uninitialized). struct A {; struct B {; int x;; int y;; };; int *iptr;; B b;; B *bptr;; char *cptr;. A (B *bptr, char *cptr) : bptr(bptr), cptr(cptr) {}; };. void f() {; A::B b;; char c;; A a(&b, &c); // no warning; }. // With Pedantic set to true and; // CheckPointeeInitialization set to false; // (pointees are regarded as initialized). struct A {; struct B {; int x; // note: uninitialized field 'this->b.x'; int y; // note: uninitialized field 'this->b.y'; };; int *iptr; // note: uninitialized pointer 'this->iptr'; B b;; B *bptr;; char *cptr;. A (B *bptr, char *cptr) : bptr(bptr), cptr(cptr) {}; };. void f() {; A::B b;; char c;; A a(&b, &c); // warning: 3 uninitialized fields; // after the constructor call; }. **Options**. This checker has several options which can be set from command line (e.g.; ``-analyzer-config optin.cplusplus.UninitializedObject:Pedantic=true``):. * ``Pedantic`` (boolean). If to false, the checker won't emit warnings for; objects that don't have at least one initialized field. Defaults to false. * ``NotesAsWarnings`` (boolean). If set to true, the checker will emit a; warning for each uninitialized field, as opposed to emitting one warning per; constructor call, and listing the uninitialized fields that belongs to it in; notes. *Defaults to false*. * ``CheckPointeeInitialization`` (boolean). If set to false, the checker will; not analyze the pointee of pointer/reference fields, and will only check; whether the object itself is initialized. *Defaults to false*. * ``IgnoreRecordsWithField`` (string). If supplied, the checker will not analyze; structures that have a field with a name or type name that matches the given; pattern. *Defaults to """"*. .. _optin-cplusplus-VirtualCall:. optin.cplusplus.VirtualCall (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check virtual function",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:19608,Modifiability,portab,portability-UnixAPI,19608,"tValue(; @""LocalizedString"", nil, [[NSBundle alloc] init], nil,@""""); // warn; }. .. _optin-osx-cocoa-localizability-NonLocalizedStringChecker:. optin.osx.cocoa.localizability.NonLocalizedStringChecker (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns about uses of non-localized NSStrings passed to UI methods expecting localized NSStrings. .. code-block:: objc. NSString *alarmText =; NSLocalizedString(@""Enabled"", @""Indicates alarm is turned on"");; if (!isEnabled) {; alarmText = @""Disabled"";; }; UILabel *alarmStateLabel = [[UILabel alloc] init];. // Warning: User-facing text should use localized string macro; [alarmStateLabel setText:alarmText];. .. _optin-performance-GCDAntipattern:. optin.performance.GCDAntipattern; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for performance anti-patterns when using Grand Central Dispatch. .. _optin-performance-Padding:. optin.performance.Padding; """"""""""""""""""""""""""""""""""""""""""""""""""; Check for excessively padded structs. .. _optin-portability-UnixAPI:. optin.portability.UnixAPI; """"""""""""""""""""""""""""""""""""""""""""""""""; Finds implementation-defined behavior in UNIX/Posix functions. .. _security-checkers:. security; ^^^^^^^^. Security related checkers. .. _security-cert-env-InvalidPtr:. security.cert.env.InvalidPtr; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Corresponds to SEI CERT Rules `ENV31-C <https://wiki.sei.cmu.edu/confluence/display/c/ENV31-C.+Do+not+rely+on+an+environment+pointer+following+an+operation+that+may+invalidate+it>`_ and `ENV34-C <https://wiki.sei.cmu.edu/confluence/display/c/ENV34-C.+Do+not+store+pointers+returned+by+certain+functions>`_. * **ENV31-C**:; Rule is about the possible problem with ``main`` function's third argument, environment pointer,; ""envp"". When environment array is modified using some modification function; such as ``putenv``, ``setenv`` or others, It may happen that memory is reallocated,; however ""envp"" is not updated to reflect the changes and points to old memory; region. * **ENV34-C**:; Some funct",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:19636,Modifiability,portab,portability,19636," nil, [[NSBundle alloc] init], nil,@""""); // warn; }. .. _optin-osx-cocoa-localizability-NonLocalizedStringChecker:. optin.osx.cocoa.localizability.NonLocalizedStringChecker (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns about uses of non-localized NSStrings passed to UI methods expecting localized NSStrings. .. code-block:: objc. NSString *alarmText =; NSLocalizedString(@""Enabled"", @""Indicates alarm is turned on"");; if (!isEnabled) {; alarmText = @""Disabled"";; }; UILabel *alarmStateLabel = [[UILabel alloc] init];. // Warning: User-facing text should use localized string macro; [alarmStateLabel setText:alarmText];. .. _optin-performance-GCDAntipattern:. optin.performance.GCDAntipattern; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for performance anti-patterns when using Grand Central Dispatch. .. _optin-performance-Padding:. optin.performance.Padding; """"""""""""""""""""""""""""""""""""""""""""""""""; Check for excessively padded structs. .. _optin-portability-UnixAPI:. optin.portability.UnixAPI; """"""""""""""""""""""""""""""""""""""""""""""""""; Finds implementation-defined behavior in UNIX/Posix functions. .. _security-checkers:. security; ^^^^^^^^. Security related checkers. .. _security-cert-env-InvalidPtr:. security.cert.env.InvalidPtr; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Corresponds to SEI CERT Rules `ENV31-C <https://wiki.sei.cmu.edu/confluence/display/c/ENV31-C.+Do+not+rely+on+an+environment+pointer+following+an+operation+that+may+invalidate+it>`_ and `ENV34-C <https://wiki.sei.cmu.edu/confluence/display/c/ENV34-C.+Do+not+store+pointers+returned+by+certain+functions>`_. * **ENV31-C**:; Rule is about the possible problem with ``main`` function's third argument, environment pointer,; ""envp"". When environment array is modified using some modification function; such as ``putenv``, ``setenv`` or others, It may happen that memory is reallocated,; however ""envp"" is not updated to reflect the changes and points to old memory; region. * **ENV34-C**:; Some functions return a pointer to a ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:21900,Modifiability,config,config,21900,", const char *argv[], const char *envp[]) {; if (setenv(""MY_NEW_VAR"", ""new_value"", 1) != 0) {; // setenv call may invalidate 'envp'; /* Handle error */; }; if (envp != NULL) {; for (size_t i = 0; envp[i] != NULL; ++i) {; puts(envp[i]);; // envp may no longer point to the current environment; // this program has unanticipated behavior, since envp; // does not reflect changes made by setenv function.; }; }; return 0;; }. void previous_call_invalidation() {; char *p, *pp;. p = getenv(""VAR"");; setenv(""SOMEVAR"", ""VALUE"", /*overwrite = */1);; // call to 'setenv' may invalidate p. *p;; // dereferencing invalid pointer; }. The ``InvalidatingGetEnv`` option is available for treating ``getenv`` calls as; invalidating. When enabled, the checker issues a warning if ``getenv`` is called; multiple times and their results are used without first creating a copy.; This level of strictness might be considered overly pedantic for the commonly; used ``getenv`` implementations. To enable this option, use:; ``-analyzer-config security.cert.env.InvalidPtr:InvalidatingGetEnv=true``. By default, this option is set to *false*. When this option is enabled, warnings will be generated for scenarios like the; following:. .. code-block:: c. char* p = getenv(""VAR"");; char* pp = getenv(""VAR2""); // assumes this call can invalidate `env`; strlen(p); // warns about accessing invalid ptr. .. _security-FloatLoopCounter:. security.FloatLoopCounter (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on using a floating point value as a loop counter (CERT: FLP30-C, FLP30-CPP). .. code-block:: c. void test() {; for (float x = 0.1f; x <= 1.0f; x += 0.1f) {} // warn; }. .. _security-insecureAPI-UncheckedReturn:. security.insecureAPI.UncheckedReturn (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of functions whose return values must be always checked. .. code-block:: c. void test() {; setuid(1); // warn; }. .. _security-insecureAPI-bcmp:. security.insecureAPI.bcmp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:27751,Modifiability,variab,variable,27751,"n values for the failure cases are documented in the standard Linux man; pages of the functions and in the `POSIX standard <https://pubs.opengroup.org/onlinepubs/9699919799/>`_. .. code-block:: c. int unsafe_errno_read(int sock, void *data, int data_size) {; if (send(sock, data, data_size, 0) != data_size) {; // 'send' can be successful even if not all data was sent; if (errno == 1) { // An undefined value may be read from 'errno'; return 0;; }; }; return 1;; }. The checker :ref:`unix-StdCLibraryFunctions` must be turned on to get the; warnings from this checker. The supported functions are the same as by; :ref:`unix-StdCLibraryFunctions`. The ``ModelPOSIX`` option of that; checker affects the set of checked functions. **Parameters**. The ``AllowErrnoReadOutsideConditionExpressions`` option allows read of the; errno value if the value is not used in a condition (in ``if`` statements,; loops, conditional expressions, ``switch`` statements). For example ``errno``; can be stored into a variable without getting a warning by the checker. .. code-block:: c. int unsafe_errno_read(int sock, void *data, int data_size) {; if (send(sock, data, data_size, 0) != data_size) {; int err = errno;; // warning if 'AllowErrnoReadOutsideConditionExpressions' is false; // no warning if 'AllowErrnoReadOutsideConditionExpressions' is true; }; return 1;; }. Default value of this option is ``true``. This allows save of the errno value; for possible later error handling. **Limitations**. - Only the very first usage of ``errno`` is checked after an affected function; call. Value of ``errno`` is not followed when it is stored into a variable; or returned from a function.; - Documentation of function ``lseek`` is not clear about what happens if the; function returns different value than the expected file position but not -1.; To avoid possible false-positives ``errno`` is allowed to be used in this; case. .. _unix-Malloc:. unix.Malloc (C); """"""""""""""""""""""""""""""; Check for memory leaks, double free, and",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:28385,Modifiability,variab,variable,28385,"unix-StdCLibraryFunctions`. The ``ModelPOSIX`` option of that; checker affects the set of checked functions. **Parameters**. The ``AllowErrnoReadOutsideConditionExpressions`` option allows read of the; errno value if the value is not used in a condition (in ``if`` statements,; loops, conditional expressions, ``switch`` statements). For example ``errno``; can be stored into a variable without getting a warning by the checker. .. code-block:: c. int unsafe_errno_read(int sock, void *data, int data_size) {; if (send(sock, data, data_size, 0) != data_size) {; int err = errno;; // warning if 'AllowErrnoReadOutsideConditionExpressions' is false; // no warning if 'AllowErrnoReadOutsideConditionExpressions' is true; }; return 1;; }. Default value of this option is ``true``. This allows save of the errno value; for possible later error handling. **Limitations**. - Only the very first usage of ``errno`` is checked after an affected function; call. Value of ``errno`` is not followed when it is stored into a variable; or returned from a function.; - Documentation of function ``lseek`` is not clear about what happens if the; function returns different value than the expected file position but not -1.; To avoid possible false-positives ``errno`` is allowed to be used in this; case. .. _unix-Malloc:. unix.Malloc (C); """"""""""""""""""""""""""""""; Check for memory leaks, double free, and use-after-free problems. Traces memory managed by malloc()/free(). .. literalinclude:: checkers/unix_malloc_example.c; :language: c. .. _unix-MallocSizeof:. unix.MallocSizeof (C); """"""""""""""""""""""""""""""""""""""""""; Check for dubious ``malloc`` arguments involving ``sizeof``. .. code-block:: c. void test() {; long *p = malloc(sizeof(short));; // warn: result is converted to 'long *', which is; // incompatible with operand type 'short'; free(p);; }. .. _unix-MismatchedDeallocator:. unix.MismatchedDeallocator (C, C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for mismatched deallocators. .. literalinclude:: checkers/mismatch",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:40754,Modifiability,variab,variable,40754," *birthDates = names;. // Warning: Conversion from value of type 'NSDate *'; // to incompatible type 'NSString *'; [birthDates addObject: [NSDate date]];. .. _osx-cocoa-RetainCount:. osx.cocoa.RetainCount (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for leaks and improper reference count management. .. code-block:: objc. void test() {; NSString *s = [[NSString alloc] init]; // warn; }. CFStringRef test(char *bytes) {; return CFStringCreateWithCStringNoCopy(; 0, bytes, NSNEXTSTEPStringEncoding, 0); // warn; }. .. _osx-cocoa-RunLoopAutoreleaseLeak:. osx.cocoa.RunLoopAutoreleaseLeak; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for leaked memory in autorelease pools that will never be drained. .. _osx-cocoa-SelfInit:. osx.cocoa.SelfInit (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""; Check that 'self' is properly initialized inside an initializer method. .. code-block:: objc. @interface MyObj : NSObject {; id x;; }; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; x = 0; // warn: instance variable used while 'self' is not; // initialized; return 0;; }; @end. @interface MyObj : NSObject; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; return self; // warn: returning uninitialized 'self'; }; @end. .. _osx-cocoa-SuperDealloc:. osx.cocoa.SuperDealloc (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about improper use of '[super dealloc]' in Objective-C. .. code-block:: objc. @interface SuperDeallocThenReleaseIvarClass : NSObject {; NSObject *_ivar;; }; @end. @implementation SuperDeallocThenReleaseIvarClass; - (void)dealloc {; [super dealloc];; [_ivar release]; // warn; }; @end. .. _osx-cocoa-UnusedIvars:. osx.cocoa.UnusedIvars (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about private ivars that are never used. .. code-block:: objc. @interface MyObj : NSObject {; @private; id x; // warn; }; @end. @implementation MyObj; @end. .. _osx-cocoa-VariadicMethodTypes:. osx.cocoa.VariadicMethodTypes (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for passing n",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:47312,Modifiability,variab,variables,47312,"e captured in lambdas. Only ref-counted types are allowed. .. code-block:: cpp. struct RefCntbl {; void ref() {}; void deref() {}; };. void foo(RefCntbl* a, RefCntbl& b) {; [&, a](){ // warn about 'a'; do_something(b); // warn about 'b'; };; };. .. _alpha-checkers:. Experimental Checkers; ---------------------. *These are checkers with known issues or limitations that keep them from being on by default. They are likely to have false positives. Bug reports and especially patches are welcome.*. alpha.clone; ^^^^^^^^^^^. .. _alpha-clone-CloneChecker:. alpha.clone.CloneChecker (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Reports similar pieces of code. .. code-block:: c. void log();. int max(int a, int b) { // warn; log();; if (a > b); return a;; return b;; }. int maxClone(int x, int y) { // similar code here; log();; if (x > y); return x;; return y;; }. alpha.core; ^^^^^^^^^^. .. _alpha-core-BoolAssignment:. alpha.core.BoolAssignment (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about assigning non-{0,1} values to boolean variables. .. code-block:: objc. void test() {; BOOL b = -1; // warn; }. .. _alpha-core-C11Lock:. alpha.core.C11Lock; """"""""""""""""""""""""""""""""""""; Similarly to :ref:`alpha.unix.PthreadLock <alpha-unix-PthreadLock>`, checks for; the locking/unlocking of ``mtx_t`` mutexes. .. code-block:: cpp. mtx_t mtx1;. void bad1(void); {; mtx_lock(&mtx1);; mtx_lock(&mtx1); // warn: This lock has already been acquired; }. .. _alpha-core-CallAndMessageUnInitRefArg:. alpha.core.CallAndMessageUnInitRefArg (C,C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for logical errors for function calls and Objective-C; message expressions (e.g., uninitialized arguments, null function pointers, and pointer to undefined variables). .. code-block:: c. void test(void) {; int t;; int &p = t;; int &s = p;; int &q = s;; foo(q); // warn; }. void test(void) {; int x;; foo(&x); // warn; }. .. _alpha-core-CastSize:. alpha.core.CastSize (C); """"""""""""""""""""""""""""""""""""""""""""""",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:48025,Modifiability,variab,variables,48025,"warn; log();; if (a > b); return a;; return b;; }. int maxClone(int x, int y) { // similar code here; log();; if (x > y); return x;; return y;; }. alpha.core; ^^^^^^^^^^. .. _alpha-core-BoolAssignment:. alpha.core.BoolAssignment (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about assigning non-{0,1} values to boolean variables. .. code-block:: objc. void test() {; BOOL b = -1; // warn; }. .. _alpha-core-C11Lock:. alpha.core.C11Lock; """"""""""""""""""""""""""""""""""""; Similarly to :ref:`alpha.unix.PthreadLock <alpha-unix-PthreadLock>`, checks for; the locking/unlocking of ``mtx_t`` mutexes. .. code-block:: cpp. mtx_t mtx1;. void bad1(void); {; mtx_lock(&mtx1);; mtx_lock(&mtx1); // warn: This lock has already been acquired; }. .. _alpha-core-CallAndMessageUnInitRefArg:. alpha.core.CallAndMessageUnInitRefArg (C,C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for logical errors for function calls and Objective-C; message expressions (e.g., uninitialized arguments, null function pointers, and pointer to undefined variables). .. code-block:: c. void test(void) {; int t;; int &p = t;; int &s = p;; int &q = s;; foo(q); // warn; }. void test(void) {; int x;; foo(&x); // warn; }. .. _alpha-core-CastSize:. alpha.core.CastSize (C); """"""""""""""""""""""""""""""""""""""""""""""; Check when casting a malloc'ed type ``T``, whether the size is a multiple of the size of ``T``. .. code-block:: c. void test() {; int *x = (int *) malloc(11); // warn; }. .. _alpha-core-CastToStruct:. alpha.core.CastToStruct (C, C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for cast from non-struct pointer to struct pointer. .. code-block:: cpp. // C; struct s {};. void test(int *p) {; struct s *ps = (struct s *) p; // warn; }. // C++; class c {};. void test(int *p) {; c *pc = (c *) p; // warn; }. .. _alpha-core-Conversion:. alpha.core.Conversion (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Loss of sign/precision in implicit conversions. .. code-block:: c. void test(unsigned U, signed S) {; if (S > 10) {; if ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:52285,Modifiability,variab,variable,52285,"sEscape``, but is temporarily disabled until some false positives are fixed. .. code-block:: c. dispatch_block_t test_block_inside_block_async_leak() {; int x = 123;; void (^inner)(void) = ^void(void) {; int y = x;; ++y;; };; void (^outer)(void) = ^void(void) {; int z = x;; ++z;; inner();; };; return outer; // warn: address of stack-allocated block is captured by a; // returned block; }. .. _alpha-core-StdVariant:. alpha.core.StdVariant (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""; Check if a value of active type is retrieved from an ``std::variant`` instance with ``std::get``.; In case of bad variant type access (the accessed type differs from the active type); a warning is emitted. Currently, this checker does not take exception handling into account. .. code-block:: cpp. void test() {; std::variant<int, char> v = 25;; char c = stg::get<char>(v); // warn: ""int"" is the active alternative; }. .. _alpha-core-TestAfterDivZero:. alpha.core.TestAfterDivZero (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for division by variable that is later compared against 0.; Either the comparison is useless or there is division by zero. .. code-block:: c. void test(int x) {; var = 77 / x;; if (x == 0) { } // warn; }. alpha.cplusplus; ^^^^^^^^^^^^^^^. .. _alpha-cplusplus-ArrayDelete:. alpha.cplusplus.ArrayDelete (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Reports destructions of arrays of polymorphic objects that are destructed as their base class.; This checker corresponds to the CERT rule `EXP51-CPP: Do not delete an array through a pointer of the incorrect type <https://wiki.sei.cmu.edu/confluence/display/cplusplus/EXP51-CPP.+Do+not+delete+an+array+through+a+pointer+of+the+incorrect+type>`_. .. code-block:: cpp. class Base {; virtual ~Base() {}; };; class Derived : public Base {}. Base *create() {; Base *x = new Derived[10]; // note: Casting from 'Derived' to 'Base' here; return x;; }. void foo() {; Base *x = create();; delete[] x; // warn: Deleting an array of 'Derived' objects as their base cla",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:52646,Modifiability,polymorphi,polymorphic,52646," a; // returned block; }. .. _alpha-core-StdVariant:. alpha.core.StdVariant (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""; Check if a value of active type is retrieved from an ``std::variant`` instance with ``std::get``.; In case of bad variant type access (the accessed type differs from the active type); a warning is emitted. Currently, this checker does not take exception handling into account. .. code-block:: cpp. void test() {; std::variant<int, char> v = 25;; char c = stg::get<char>(v); // warn: ""int"" is the active alternative; }. .. _alpha-core-TestAfterDivZero:. alpha.core.TestAfterDivZero (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for division by variable that is later compared against 0.; Either the comparison is useless or there is division by zero. .. code-block:: c. void test(int x) {; var = 77 / x;; if (x == 0) { } // warn; }. alpha.cplusplus; ^^^^^^^^^^^^^^^. .. _alpha-cplusplus-ArrayDelete:. alpha.cplusplus.ArrayDelete (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Reports destructions of arrays of polymorphic objects that are destructed as their base class.; This checker corresponds to the CERT rule `EXP51-CPP: Do not delete an array through a pointer of the incorrect type <https://wiki.sei.cmu.edu/confluence/display/cplusplus/EXP51-CPP.+Do+not+delete+an+array+through+a+pointer+of+the+incorrect+type>`_. .. code-block:: cpp. class Base {; virtual ~Base() {}; };; class Derived : public Base {}. Base *create() {; Base *x = new Derived[10]; // note: Casting from 'Derived' to 'Base' here; return x;; }. void foo() {; Base *x = create();; delete[] x; // warn: Deleting an array of 'Derived' objects as their base class 'Base' is undefined; }. .. _alpha-cplusplus-DeleteWithNonVirtualDtor:. alpha.cplusplus.DeleteWithNonVirtualDtor (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Reports destructions of polymorphic objects with a non-virtual destructor in their base class. .. code-block:: cpp. class NonVirtual {};; class NVDerived : public NonVirtual {};. NonVirtual *cre",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:53462,Modifiability,polymorphi,polymorphic,53462," if (x == 0) { } // warn; }. alpha.cplusplus; ^^^^^^^^^^^^^^^. .. _alpha-cplusplus-ArrayDelete:. alpha.cplusplus.ArrayDelete (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Reports destructions of arrays of polymorphic objects that are destructed as their base class.; This checker corresponds to the CERT rule `EXP51-CPP: Do not delete an array through a pointer of the incorrect type <https://wiki.sei.cmu.edu/confluence/display/cplusplus/EXP51-CPP.+Do+not+delete+an+array+through+a+pointer+of+the+incorrect+type>`_. .. code-block:: cpp. class Base {; virtual ~Base() {}; };; class Derived : public Base {}. Base *create() {; Base *x = new Derived[10]; // note: Casting from 'Derived' to 'Base' here; return x;; }. void foo() {; Base *x = create();; delete[] x; // warn: Deleting an array of 'Derived' objects as their base class 'Base' is undefined; }. .. _alpha-cplusplus-DeleteWithNonVirtualDtor:. alpha.cplusplus.DeleteWithNonVirtualDtor (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Reports destructions of polymorphic objects with a non-virtual destructor in their base class. .. code-block:: cpp. class NonVirtual {};; class NVDerived : public NonVirtual {};. NonVirtual *create() {; NonVirtual *x = new NVDerived(); // note: Casting from 'NVDerived' to; // 'NonVirtual' here; return x;; }. void foo() {; NonVirtual *x = create();; delete x; // warn: destruction of a polymorphic object with no virtual; // destructor; }. .. _alpha-cplusplus-InvalidatedIterator:. alpha.cplusplus.InvalidatedIterator (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for use of invalidated iterators. .. code-block:: cpp. void bad_copy_assign_operator_list1(std::list &L1,; const std::list &L2) {; auto i0 = L1.cbegin();; L1 = L2;; *i0; // warn: invalidated iterator accessed; }. .. _alpha-cplusplus-IteratorRange:. alpha.cplusplus.IteratorRange (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for iterators used outside their valid ranges. .. code-block:: cpp. void simple_bad_end(const std::vect",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:53825,Modifiability,polymorphi,polymorphic,53825,"correct type <https://wiki.sei.cmu.edu/confluence/display/cplusplus/EXP51-CPP.+Do+not+delete+an+array+through+a+pointer+of+the+incorrect+type>`_. .. code-block:: cpp. class Base {; virtual ~Base() {}; };; class Derived : public Base {}. Base *create() {; Base *x = new Derived[10]; // note: Casting from 'Derived' to 'Base' here; return x;; }. void foo() {; Base *x = create();; delete[] x; // warn: Deleting an array of 'Derived' objects as their base class 'Base' is undefined; }. .. _alpha-cplusplus-DeleteWithNonVirtualDtor:. alpha.cplusplus.DeleteWithNonVirtualDtor (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Reports destructions of polymorphic objects with a non-virtual destructor in their base class. .. code-block:: cpp. class NonVirtual {};; class NVDerived : public NonVirtual {};. NonVirtual *create() {; NonVirtual *x = new NVDerived(); // note: Casting from 'NVDerived' to; // 'NonVirtual' here; return x;; }. void foo() {; NonVirtual *x = create();; delete x; // warn: destruction of a polymorphic object with no virtual; // destructor; }. .. _alpha-cplusplus-InvalidatedIterator:. alpha.cplusplus.InvalidatedIterator (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for use of invalidated iterators. .. code-block:: cpp. void bad_copy_assign_operator_list1(std::list &L1,; const std::list &L2) {; auto i0 = L1.cbegin();; L1 = L2;; *i0; // warn: invalidated iterator accessed; }. .. _alpha-cplusplus-IteratorRange:. alpha.cplusplus.IteratorRange (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for iterators used outside their valid ranges. .. code-block:: cpp. void simple_bad_end(const std::vector &v) {; auto i = v.end();; *i; // warn: iterator accessed outside of its range; }. .. _alpha-cplusplus-MismatchedIterator:. alpha.cplusplus.MismatchedIterator (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for use of iterators of different containers where iterators of the same container are expected. .. code-block:: cpp. void bad_insert3(std::vector &v1, ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:57235,Modifiability,variab,variables,57235,"urn x; // warn; }. // C++; void test() {; int a = 2;. while (a > 1); a--;. if (a > 1); a++; // warn; }. // Objective-C; void test(id x) {; return;; [x retain]; // warn; }. alpha.fuchsia; ^^^^^^^^^^^^^. .. _alpha-fuchsia-lock:. alpha.fuchsia.Lock; """"""""""""""""""""""""""""""""""""; Similarly to :ref:`alpha.unix.PthreadLock <alpha-unix-PthreadLock>`, checks for; the locking/unlocking of fuchsia mutexes. .. code-block:: cpp. spin_lock_t mtx1;. void bad1(void); {; spin_lock(&mtx1);; spin_lock(&mtx1);	// warn: This lock has already been acquired; }. alpha.llvm; ^^^^^^^^^^. .. _alpha-llvm-Conventions:. alpha.llvm.Conventions; """""""""""""""""""""""""""""""""""""""""""". Check code for LLVM codebase conventions:. * A StringRef should not be bound to a temporary std::string whose lifetime is shorter than the StringRef's.; * Clang AST nodes should not have fields that can allocate memory. alpha.osx; ^^^^^^^^^. .. _alpha-osx-cocoa-DirectIvarAssignment:. alpha.osx.cocoa.DirectIvarAssignment (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for direct assignments to instance variables. .. code-block:: objc. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) foo;; @end. @implementation MyClass; - (void) foo {; _A = 0; // warn; }; @end. .. _alpha-osx-cocoa-DirectIvarAssignmentForAnnotatedFunctions:. alpha.osx.cocoa.DirectIvarAssignmentForAnnotatedFunctions (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for direct assignments to instance variables in; the methods annotated with ``objc_no_direct_instance_variable_assignment``. .. code-block:: objc. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) fAnnotated __attribute__((; annotate(""objc_no_direct_instance_variable_assignment"")));; - (void) fNotAnnotated;; @end. @implementation MyClass; - (void) fAnnotated {; _A = 0; // warn; }; - (void) fNotAnnotated {; _A = 0; // no warn; }; @end. .. _alpha-osx-cocoa-InstanceVariableInvalidation:. alpha.osx.cocoa.InstanceVariableInvalidation (ObjC);",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:57655,Modifiability,variab,variables,57655,"(void); {; spin_lock(&mtx1);; spin_lock(&mtx1);	// warn: This lock has already been acquired; }. alpha.llvm; ^^^^^^^^^^. .. _alpha-llvm-Conventions:. alpha.llvm.Conventions; """""""""""""""""""""""""""""""""""""""""""". Check code for LLVM codebase conventions:. * A StringRef should not be bound to a temporary std::string whose lifetime is shorter than the StringRef's.; * Clang AST nodes should not have fields that can allocate memory. alpha.osx; ^^^^^^^^^. .. _alpha-osx-cocoa-DirectIvarAssignment:. alpha.osx.cocoa.DirectIvarAssignment (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for direct assignments to instance variables. .. code-block:: objc. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) foo;; @end. @implementation MyClass; - (void) foo {; _A = 0; // warn; }; @end. .. _alpha-osx-cocoa-DirectIvarAssignmentForAnnotatedFunctions:. alpha.osx.cocoa.DirectIvarAssignmentForAnnotatedFunctions (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for direct assignments to instance variables in; the methods annotated with ``objc_no_direct_instance_variable_assignment``. .. code-block:: objc. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) fAnnotated __attribute__((; annotate(""objc_no_direct_instance_variable_assignment"")));; - (void) fNotAnnotated;; @end. @implementation MyClass; - (void) fAnnotated {; _A = 0; // warn; }; - (void) fNotAnnotated {; _A = 0; // no warn; }; @end. .. _alpha-osx-cocoa-InstanceVariableInvalidation:. alpha.osx.cocoa.InstanceVariableInvalidation (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check that the invalidatable instance variables are; invalidated in the methods annotated with objc_instance_variable_invalidator. .. code-block:: objc. @protocol Invalidation <NSObject>; - (void) invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface InvalidationImpObj : NSObject <Invalidation>; @end. @interface SubclassInvalidationImpObj : ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:58275,Modifiability,variab,variables,58275,"ck:: objc. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) foo;; @end. @implementation MyClass; - (void) foo {; _A = 0; // warn; }; @end. .. _alpha-osx-cocoa-DirectIvarAssignmentForAnnotatedFunctions:. alpha.osx.cocoa.DirectIvarAssignmentForAnnotatedFunctions (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for direct assignments to instance variables in; the methods annotated with ``objc_no_direct_instance_variable_assignment``. .. code-block:: objc. @interface MyClass : NSObject {}; @property (readonly) id A;; - (void) fAnnotated __attribute__((; annotate(""objc_no_direct_instance_variable_assignment"")));; - (void) fNotAnnotated;; @end. @implementation MyClass; - (void) fAnnotated {; _A = 0; // warn; }; - (void) fNotAnnotated {; _A = 0; // no warn; }; @end. .. _alpha-osx-cocoa-InstanceVariableInvalidation:. alpha.osx.cocoa.InstanceVariableInvalidation (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check that the invalidatable instance variables are; invalidated in the methods annotated with objc_instance_variable_invalidator. .. code-block:: objc. @protocol Invalidation <NSObject>; - (void) invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface InvalidationImpObj : NSObject <Invalidation>; @end. @interface SubclassInvalidationImpObj : InvalidationImpObj {; InvalidationImpObj *var;; }; - (void)invalidate;; @end. @implementation SubclassInvalidationImpObj; - (void) invalidate {}; @end; // warn: var needs to be invalidated or set to nil. .. _alpha-osx-cocoa-MissingInvalidationMethod:. alpha.osx.cocoa.MissingInvalidationMethod (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check that the invalidation methods are present in classes that contain invalidatable instance variables. .. code-block:: objc. @protocol Invalidation <NSObject>; - (void)invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface NeedInvalidation :",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:59068,Modifiability,variab,variables,59068," (void) fAnnotated {; _A = 0; // warn; }; - (void) fNotAnnotated {; _A = 0; // no warn; }; @end. .. _alpha-osx-cocoa-InstanceVariableInvalidation:. alpha.osx.cocoa.InstanceVariableInvalidation (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check that the invalidatable instance variables are; invalidated in the methods annotated with objc_instance_variable_invalidator. .. code-block:: objc. @protocol Invalidation <NSObject>; - (void) invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface InvalidationImpObj : NSObject <Invalidation>; @end. @interface SubclassInvalidationImpObj : InvalidationImpObj {; InvalidationImpObj *var;; }; - (void)invalidate;; @end. @implementation SubclassInvalidationImpObj; - (void) invalidate {}; @end; // warn: var needs to be invalidated or set to nil. .. _alpha-osx-cocoa-MissingInvalidationMethod:. alpha.osx.cocoa.MissingInvalidationMethod (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check that the invalidation methods are present in classes that contain invalidatable instance variables. .. code-block:: objc. @protocol Invalidation <NSObject>; - (void)invalidate; __attribute__((annotate(""objc_instance_variable_invalidator"")));; @end. @interface NeedInvalidation : NSObject <Invalidation>; @end. @interface MissingInvalidationMethodDecl : NSObject {; NeedInvalidation *Var; // warn; }; @end. @implementation MissingInvalidationMethodDecl; @end. .. _alpha-osx-cocoa-localizability-PluralMisuseChecker:. alpha.osx.cocoa.localizability.PluralMisuseChecker (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns against using one vs. many plural pattern in code when generating localized strings. .. code-block:: objc. NSString *reminderText =; NSLocalizedString(@""None"", @""Indicates no reminders"");; if (reminderCount == 1) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; NSLocalizedString(@""1 Reminder""",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:61732,Modifiability,variab,variable,61732,") {; int *p = malloc(12);; p[3] = 4; // warn; }. void test() {; char a[2];; int *b = (int*)a;; b[1] = 3; // warn; }. .. _alpha-security-ArrayBoundV2:. alpha.security.ArrayBoundV2 (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about buffer overflows (newer checker). .. code-block:: c. void test() {; char *s = """";; char c = s[1]; // warn; }. void test() {; int buf[100];; int *p = buf;; p = p + 99;; p[1] = 1; // warn; }. // note: compiler has internal check for this.; // Use -Wno-array-bounds to suppress compiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. .. _alpha-security-MallocOverflow:. alpha.security.MallocOverflow (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for overflows in the arguments to ``malloc()``.; It tries to catch ``malloc(n * c)`` patterns, where:. - ``n``: a variable or member access of an object; - ``c``: a constant foldable integral. This checker was designed for code audits, so expect false-positive reports.; One is supposed to silence this checker by ensuring proper bounds checking on; the variable in question using e.g. an ``assert()`` or a branch. .. code-block:: c. void test(int n) {; void *p = malloc(n * sizeof(int)); // warn; }. void test2(int n) {; if (n > 100) // gives an upper-bound; return;; void *p = malloc(n * sizeof(int)); // no warning; }. void test3(int n) {; assert(n <= 100 && ""Contract violated."");; void *p = malloc(n * sizeof(int)); // no warning; }. Limitations:. - The checker won't warn for variables involved in explicit casts,; since that might limit the variable's domain.; E.g.: ``(unsigned char)int x`` would limit the domain to ``[0,255]``.; The checker will miss the true-positive cases when the explicit cast would; not tighten the domain to prevent the overflow in the subsequent; multiplication operation. - It is an AST-based checker, thus it do",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:61972,Modifiability,variab,variable,61972,"(C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about buffer overflows (newer checker). .. code-block:: c. void test() {; char *s = """";; char c = s[1]; // warn; }. void test() {; int buf[100];; int *p = buf;; p = p + 99;; p[1] = 1; // warn; }. // note: compiler has internal check for this.; // Use -Wno-array-bounds to suppress compiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. .. _alpha-security-MallocOverflow:. alpha.security.MallocOverflow (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for overflows in the arguments to ``malloc()``.; It tries to catch ``malloc(n * c)`` patterns, where:. - ``n``: a variable or member access of an object; - ``c``: a constant foldable integral. This checker was designed for code audits, so expect false-positive reports.; One is supposed to silence this checker by ensuring proper bounds checking on; the variable in question using e.g. an ``assert()`` or a branch. .. code-block:: c. void test(int n) {; void *p = malloc(n * sizeof(int)); // warn; }. void test2(int n) {; if (n > 100) // gives an upper-bound; return;; void *p = malloc(n * sizeof(int)); // no warning; }. void test3(int n) {; assert(n <= 100 && ""Contract violated."");; void *p = malloc(n * sizeof(int)); // no warning; }. Limitations:. - The checker won't warn for variables involved in explicit casts,; since that might limit the variable's domain.; E.g.: ``(unsigned char)int x`` would limit the domain to ``[0,255]``.; The checker will miss the true-positive cases when the explicit cast would; not tighten the domain to prevent the overflow in the subsequent; multiplication operation. - It is an AST-based checker, thus it does not make use of the; path-sensitive taint-analysis. .. _alpha-security-MmapWriteExec:. alpha.security.MmapWriteExec (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on mmap() calls ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:62400,Modifiability,variab,variables,62400,"s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. .. _alpha-security-MallocOverflow:. alpha.security.MallocOverflow (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for overflows in the arguments to ``malloc()``.; It tries to catch ``malloc(n * c)`` patterns, where:. - ``n``: a variable or member access of an object; - ``c``: a constant foldable integral. This checker was designed for code audits, so expect false-positive reports.; One is supposed to silence this checker by ensuring proper bounds checking on; the variable in question using e.g. an ``assert()`` or a branch. .. code-block:: c. void test(int n) {; void *p = malloc(n * sizeof(int)); // warn; }. void test2(int n) {; if (n > 100) // gives an upper-bound; return;; void *p = malloc(n * sizeof(int)); // no warning; }. void test3(int n) {; assert(n <= 100 && ""Contract violated."");; void *p = malloc(n * sizeof(int)); // no warning; }. Limitations:. - The checker won't warn for variables involved in explicit casts,; since that might limit the variable's domain.; E.g.: ``(unsigned char)int x`` would limit the domain to ``[0,255]``.; The checker will miss the true-positive cases when the explicit cast would; not tighten the domain to prevent the overflow in the subsequent; multiplication operation. - It is an AST-based checker, thus it does not make use of the; path-sensitive taint-analysis. .. _alpha-security-MmapWriteExec:. alpha.security.MmapWriteExec (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on mmap() calls that are both writable and executable. .. code-block:: c. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. .. _alpha-security-ReturnPtrRange:. alpha.security.ReturnPtrRange (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for an out-of-bound pointer being return",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:62466,Modifiability,variab,variable,62466,"s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. .. _alpha-security-MallocOverflow:. alpha.security.MallocOverflow (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for overflows in the arguments to ``malloc()``.; It tries to catch ``malloc(n * c)`` patterns, where:. - ``n``: a variable or member access of an object; - ``c``: a constant foldable integral. This checker was designed for code audits, so expect false-positive reports.; One is supposed to silence this checker by ensuring proper bounds checking on; the variable in question using e.g. an ``assert()`` or a branch. .. code-block:: c. void test(int n) {; void *p = malloc(n * sizeof(int)); // warn; }. void test2(int n) {; if (n > 100) // gives an upper-bound; return;; void *p = malloc(n * sizeof(int)); // no warning; }. void test3(int n) {; assert(n <= 100 && ""Contract violated."");; void *p = malloc(n * sizeof(int)); // no warning; }. Limitations:. - The checker won't warn for variables involved in explicit casts,; since that might limit the variable's domain.; E.g.: ``(unsigned char)int x`` would limit the domain to ``[0,255]``.; The checker will miss the true-positive cases when the explicit cast would; not tighten the domain to prevent the overflow in the subsequent; multiplication operation. - It is an AST-based checker, thus it does not make use of the; path-sensitive taint-analysis. .. _alpha-security-MmapWriteExec:. alpha.security.MmapWriteExec (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on mmap() calls that are both writable and executable. .. code-block:: c. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. .. _alpha-security-ReturnPtrRange:. alpha.security.ReturnPtrRange (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for an out-of-bound pointer being return",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:64170,Modifiability,variab,variable,64170,"oth PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. .. _alpha-security-ReturnPtrRange:. alpha.security.ReturnPtrRange (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for an out-of-bound pointer being returned to callers. .. code-block:: c. static int A[10];. int *test() {; int *p = A + 10;; return p; // warn; }. int test(void) {; int x;; return x; // warn: undefined or garbage returned; }. alpha.security.cert; ^^^^^^^^^^^^^^^^^^^. SEI CERT checkers which tries to find errors based on their `C coding rules <https://wiki.sei.cmu.edu/confluence/display/c/2+Rules>`_. .. _alpha-security-cert-pos-checkers:. alpha.security.cert.pos; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `POSIX C coding rules <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152405>`_. .. _alpha-security-cert-pos-34c:. alpha.security.cert.pos.34c; """"""""""""""""""""""""""""""""""""""""""""""""""""""; Finds calls to the ``putenv`` function which pass a pointer to an automatic variable as the argument. .. code-block:: c. int func(const char *var) {; char env[1024];; int retval = snprintf(env, sizeof(env),""TEST=%s"", var);; if (retval < 0 || (size_t)retval >= sizeof(env)) {; /* Handle error */; }. return putenv(env); // putenv function should not be called with auto variables; }. Limitations:. - Technically, one can pass automatic variables to ``putenv``,; but one needs to ensure that the given environment key stays; alive until it's removed or overwritten.; Since the analyzer cannot keep track of which envvars get overwritten; and when, it needs to be slightly more aggressive and warn for such; cases too, leading in some cases to false-positive reports like this:. .. code-block:: c. void baz() {; char env[] = ""NAME=value"";; putenv(env); // false-positive warning: putenv function should not be called...; // More code...; putenv((char *)""NAME=anothervalue"");; // This putenv call overwrites the previous entry, thus that ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:64463,Modifiability,variab,variables,64463,"allers. .. code-block:: c. static int A[10];. int *test() {; int *p = A + 10;; return p; // warn; }. int test(void) {; int x;; return x; // warn: undefined or garbage returned; }. alpha.security.cert; ^^^^^^^^^^^^^^^^^^^. SEI CERT checkers which tries to find errors based on their `C coding rules <https://wiki.sei.cmu.edu/confluence/display/c/2+Rules>`_. .. _alpha-security-cert-pos-checkers:. alpha.security.cert.pos; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `POSIX C coding rules <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152405>`_. .. _alpha-security-cert-pos-34c:. alpha.security.cert.pos.34c; """"""""""""""""""""""""""""""""""""""""""""""""""""""; Finds calls to the ``putenv`` function which pass a pointer to an automatic variable as the argument. .. code-block:: c. int func(const char *var) {; char env[1024];; int retval = snprintf(env, sizeof(env),""TEST=%s"", var);; if (retval < 0 || (size_t)retval >= sizeof(env)) {; /* Handle error */; }. return putenv(env); // putenv function should not be called with auto variables; }. Limitations:. - Technically, one can pass automatic variables to ``putenv``,; but one needs to ensure that the given environment key stays; alive until it's removed or overwritten.; Since the analyzer cannot keep track of which envvars get overwritten; and when, it needs to be slightly more aggressive and warn for such; cases too, leading in some cases to false-positive reports like this:. .. code-block:: c. void baz() {; char env[] = ""NAME=value"";; putenv(env); // false-positive warning: putenv function should not be called...; // More code...; putenv((char *)""NAME=anothervalue"");; // This putenv call overwrites the previous entry, thus that can no longer dangle.; } // 'env' array becomes dead only here. alpha.security.cert.env; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `Environment C coding rules <https://wiki.sei.cmu.edu/confluence/x/JdcxBQ>`_. alpha.security.taint; ^^^^^^^^^^^^^^^^^^^^. Checkers implementing; `taint analysis <https://e",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:64529,Modifiability,variab,variables,64529," warn: undefined or garbage returned; }. alpha.security.cert; ^^^^^^^^^^^^^^^^^^^. SEI CERT checkers which tries to find errors based on their `C coding rules <https://wiki.sei.cmu.edu/confluence/display/c/2+Rules>`_. .. _alpha-security-cert-pos-checkers:. alpha.security.cert.pos; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `POSIX C coding rules <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152405>`_. .. _alpha-security-cert-pos-34c:. alpha.security.cert.pos.34c; """"""""""""""""""""""""""""""""""""""""""""""""""""""; Finds calls to the ``putenv`` function which pass a pointer to an automatic variable as the argument. .. code-block:: c. int func(const char *var) {; char env[1024];; int retval = snprintf(env, sizeof(env),""TEST=%s"", var);; if (retval < 0 || (size_t)retval >= sizeof(env)) {; /* Handle error */; }. return putenv(env); // putenv function should not be called with auto variables; }. Limitations:. - Technically, one can pass automatic variables to ``putenv``,; but one needs to ensure that the given environment key stays; alive until it's removed or overwritten.; Since the analyzer cannot keep track of which envvars get overwritten; and when, it needs to be slightly more aggressive and warn for such; cases too, leading in some cases to false-positive reports like this:. .. code-block:: c. void baz() {; char env[] = ""NAME=value"";; putenv(env); // false-positive warning: putenv function should not be called...; // More code...; putenv((char *)""NAME=anothervalue"");; // This putenv call overwrites the previous entry, thus that can no longer dangle.; } // 'env' array becomes dead only here. alpha.security.cert.env; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `Environment C coding rules <https://wiki.sei.cmu.edu/confluence/x/JdcxBQ>`_. alpha.security.taint; ^^^^^^^^^^^^^^^^^^^^. Checkers implementing; `taint analysis <https://en.wikipedia.org/wiki/Taint_checking>`_. .. _alpha-security-taint-TaintPropagation:. alpha.security.taint.TaintPropagation (C, C++); """"""""""""""""",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:66431,Modifiability,variab,variables,66431,"nalysis <https://en.wikipedia.org/wiki/Taint_checking>`_. .. _alpha-security-taint-TaintPropagation:. alpha.security.taint.TaintPropagation (C, C++); """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Taint analysis identifies potential security vulnerabilities where the; attacker can inject malicious data to the program to execute an attack; (privilege escalation, command injection, SQL injection etc.). The malicious data is injected at the taint source (e.g. ``getenv()`` call); which is then propagated through function calls and being used as arguments of; sensitive operations, also called as taint sinks (e.g. ``system()`` call). One can defend against this type of vulnerability by always checking and; sanitizing the potentially malicious, untrusted user input. The goal of the checker is to discover and show to the user these potential; taint source-sink pairs and the propagation call chain. The most notable examples of taint sources are:. - data from network; - files or standard input; - environment variables; - data from databases. Let us examine a practical example of a Command Injection attack. .. code-block:: c. // Command Injection Vulnerability Example; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; strcat(cmd, filename);; system(cmd); // Warning: Untrusted data is passed to a system call; }. The program prints the content of any user specified file.; Unfortunately the attacker can execute arbitrary commands; with shell escapes. For example with the following input the `ls` command is also; executed after the contents of `/etc/shadow` is printed.; `Input: /etc/shadow ; ls /`. The analysis implemented in this checker points out this problem. One can protect against such attack by for example checking if the provided; input refers to a valid file and removing any invalid user input. .. code-block:: c. // No vulnerability",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:68250,Modifiability,config,configuration,68250,"lem. One can protect against such attack by for example checking if the provided; input refers to a valid file and removing any invalid user input. .. code-block:: c. // No vulnerability anymore, but we still get the warning; void sanitizeFileName(char* filename){; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; filename[0]='\0';; }; }; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; sanitizeFileName(filename);// filename is safe after this point; if (!filename[0]); return -1;; strcat(cmd, filename);; system(cmd); // Superfluous Warning: Untrusted data is passed to a system call; }. Unfortunately, the checker cannot discover automatically that the programmer; have performed data sanitation, so it still emits the warning. One can get rid of this superfluous warning by telling by specifying the; sanitation functions in the taint configuration file (see; :doc:`user-docs/TaintAnalysisConfiguration`). .. code-block:: YAML. Filters:; - Name: sanitizeFileName; Args: [0]. The clang invocation to pass the configuration file location:. .. code-block:: bash. clang --analyze -Xclang -analyzer-config -Xclang alpha.security.taint.TaintPropagation:Config=`pwd`/taint_config.yml ... If you are validating your inputs instead of sanitizing them, or don't want to; mention each sanitizing function in our configuration,; you can use a more generic approach. Introduce a generic no-op `csa_mark_sanitized(..)` function to; tell the Clang Static Analyzer; that the variable is safe to be used on that analysis path. .. code-block:: c. // Marking sanitized variables safe.; // No vulnerability anymore, no warning. // User csa_mark_sanitize function is for the analyzer only; #ifdef __clang_analyzer__; void csa_mark_sanitized(const void *);; #endif. int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char f",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:68423,Modifiability,config,configuration,68423,"more, but we still get the warning; void sanitizeFileName(char* filename){; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; filename[0]='\0';; }; }; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; sanitizeFileName(filename);// filename is safe after this point; if (!filename[0]); return -1;; strcat(cmd, filename);; system(cmd); // Superfluous Warning: Untrusted data is passed to a system call; }. Unfortunately, the checker cannot discover automatically that the programmer; have performed data sanitation, so it still emits the warning. One can get rid of this superfluous warning by telling by specifying the; sanitation functions in the taint configuration file (see; :doc:`user-docs/TaintAnalysisConfiguration`). .. code-block:: YAML. Filters:; - Name: sanitizeFileName; Args: [0]. The clang invocation to pass the configuration file location:. .. code-block:: bash. clang --analyze -Xclang -analyzer-config -Xclang alpha.security.taint.TaintPropagation:Config=`pwd`/taint_config.yml ... If you are validating your inputs instead of sanitizing them, or don't want to; mention each sanitizing function in our configuration,; you can use a more generic approach. Introduce a generic no-op `csa_mark_sanitized(..)` function to; tell the Clang Static Analyzer; that the variable is safe to be used on that analysis path. .. code-block:: c. // Marking sanitized variables safe.; // No vulnerability anymore, no warning. // User csa_mark_sanitize function is for the analyzer only; #ifdef __clang_analyzer__; void csa_mark_sanitized(const void *);; #endif. int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename);; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; return -1;; }; #ifdef __clang_an",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:68509,Modifiability,config,config,68509,"cess(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; filename[0]='\0';; }; }; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; sanitizeFileName(filename);// filename is safe after this point; if (!filename[0]); return -1;; strcat(cmd, filename);; system(cmd); // Superfluous Warning: Untrusted data is passed to a system call; }. Unfortunately, the checker cannot discover automatically that the programmer; have performed data sanitation, so it still emits the warning. One can get rid of this superfluous warning by telling by specifying the; sanitation functions in the taint configuration file (see; :doc:`user-docs/TaintAnalysisConfiguration`). .. code-block:: YAML. Filters:; - Name: sanitizeFileName; Args: [0]. The clang invocation to pass the configuration file location:. .. code-block:: bash. clang --analyze -Xclang -analyzer-config -Xclang alpha.security.taint.TaintPropagation:Config=`pwd`/taint_config.yml ... If you are validating your inputs instead of sanitizing them, or don't want to; mention each sanitizing function in our configuration,; you can use a more generic approach. Introduce a generic no-op `csa_mark_sanitized(..)` function to; tell the Clang Static Analyzer; that the variable is safe to be used on that analysis path. .. code-block:: c. // Marking sanitized variables safe.; // No vulnerability anymore, no warning. // User csa_mark_sanitize function is for the analyzer only; #ifdef __clang_analyzer__; void csa_mark_sanitized(const void *);; #endif. int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename);; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; return -1;; }; #ifdef __clang_analyzer__; csa_mark_sanitized(filename); // Indicating to CSA that filename variab",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:68716,Modifiability,config,configuration,68716,"ename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; sanitizeFileName(filename);// filename is safe after this point; if (!filename[0]); return -1;; strcat(cmd, filename);; system(cmd); // Superfluous Warning: Untrusted data is passed to a system call; }. Unfortunately, the checker cannot discover automatically that the programmer; have performed data sanitation, so it still emits the warning. One can get rid of this superfluous warning by telling by specifying the; sanitation functions in the taint configuration file (see; :doc:`user-docs/TaintAnalysisConfiguration`). .. code-block:: YAML. Filters:; - Name: sanitizeFileName; Args: [0]. The clang invocation to pass the configuration file location:. .. code-block:: bash. clang --analyze -Xclang -analyzer-config -Xclang alpha.security.taint.TaintPropagation:Config=`pwd`/taint_config.yml ... If you are validating your inputs instead of sanitizing them, or don't want to; mention each sanitizing function in our configuration,; you can use a more generic approach. Introduce a generic no-op `csa_mark_sanitized(..)` function to; tell the Clang Static Analyzer; that the variable is safe to be used on that analysis path. .. code-block:: c. // Marking sanitized variables safe.; // No vulnerability anymore, no warning. // User csa_mark_sanitize function is for the analyzer only; #ifdef __clang_analyzer__; void csa_mark_sanitized(const void *);; #endif. int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename);; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; return -1;; }; #ifdef __clang_analyzer__; csa_mark_sanitized(filename); // Indicating to CSA that filename variable is safe to be used after this point; #endif; strcat(cmd, filename);; system(cmd); // No warning; }. Similarly to the previous example, you need to; define a `Filter` function in",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:68874,Modifiability,variab,variable,68874,"lename[0]); return -1;; strcat(cmd, filename);; system(cmd); // Superfluous Warning: Untrusted data is passed to a system call; }. Unfortunately, the checker cannot discover automatically that the programmer; have performed data sanitation, so it still emits the warning. One can get rid of this superfluous warning by telling by specifying the; sanitation functions in the taint configuration file (see; :doc:`user-docs/TaintAnalysisConfiguration`). .. code-block:: YAML. Filters:; - Name: sanitizeFileName; Args: [0]. The clang invocation to pass the configuration file location:. .. code-block:: bash. clang --analyze -Xclang -analyzer-config -Xclang alpha.security.taint.TaintPropagation:Config=`pwd`/taint_config.yml ... If you are validating your inputs instead of sanitizing them, or don't want to; mention each sanitizing function in our configuration,; you can use a more generic approach. Introduce a generic no-op `csa_mark_sanitized(..)` function to; tell the Clang Static Analyzer; that the variable is safe to be used on that analysis path. .. code-block:: c. // Marking sanitized variables safe.; // No vulnerability anymore, no warning. // User csa_mark_sanitize function is for the analyzer only; #ifdef __clang_analyzer__; void csa_mark_sanitized(const void *);; #endif. int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename);; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; return -1;; }; #ifdef __clang_analyzer__; csa_mark_sanitized(filename); // Indicating to CSA that filename variable is safe to be used after this point; #endif; strcat(cmd, filename);; system(cmd); // No warning; }. Similarly to the previous example, you need to; define a `Filter` function in a `YAML` configuration file; and add the `csa_mark_sanitized` function. .. code-block:: YAML. Filters:; - Name: csa_mark_sanitized; Args: [0]. Then calling `csa_mark_sanitized(X)` will tel",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:68965,Modifiability,variab,variables,68965,"ted data is passed to a system call; }. Unfortunately, the checker cannot discover automatically that the programmer; have performed data sanitation, so it still emits the warning. One can get rid of this superfluous warning by telling by specifying the; sanitation functions in the taint configuration file (see; :doc:`user-docs/TaintAnalysisConfiguration`). .. code-block:: YAML. Filters:; - Name: sanitizeFileName; Args: [0]. The clang invocation to pass the configuration file location:. .. code-block:: bash. clang --analyze -Xclang -analyzer-config -Xclang alpha.security.taint.TaintPropagation:Config=`pwd`/taint_config.yml ... If you are validating your inputs instead of sanitizing them, or don't want to; mention each sanitizing function in our configuration,; you can use a more generic approach. Introduce a generic no-op `csa_mark_sanitized(..)` function to; tell the Clang Static Analyzer; that the variable is safe to be used on that analysis path. .. code-block:: c. // Marking sanitized variables safe.; // No vulnerability anymore, no warning. // User csa_mark_sanitize function is for the analyzer only; #ifdef __clang_analyzer__; void csa_mark_sanitized(const void *);; #endif. int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename);; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; return -1;; }; #ifdef __clang_analyzer__; csa_mark_sanitized(filename); // Indicating to CSA that filename variable is safe to be used after this point; #endif; strcat(cmd, filename);; system(cmd); // No warning; }. Similarly to the previous example, you need to; define a `Filter` function in a `YAML` configuration file; and add the `csa_mark_sanitized` function. .. code-block:: YAML. Filters:; - Name: csa_mark_sanitized; Args: [0]. Then calling `csa_mark_sanitized(X)` will tell the analyzer that `X` is safe to; be used after this point, because its contents are veri",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:69496,Modifiability,variab,variable,69496,"gs: [0]. The clang invocation to pass the configuration file location:. .. code-block:: bash. clang --analyze -Xclang -analyzer-config -Xclang alpha.security.taint.TaintPropagation:Config=`pwd`/taint_config.yml ... If you are validating your inputs instead of sanitizing them, or don't want to; mention each sanitizing function in our configuration,; you can use a more generic approach. Introduce a generic no-op `csa_mark_sanitized(..)` function to; tell the Clang Static Analyzer; that the variable is safe to be used on that analysis path. .. code-block:: c. // Marking sanitized variables safe.; // No vulnerability anymore, no warning. // User csa_mark_sanitize function is for the analyzer only; #ifdef __clang_analyzer__; void csa_mark_sanitized(const void *);; #endif. int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename);; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; return -1;; }; #ifdef __clang_analyzer__; csa_mark_sanitized(filename); // Indicating to CSA that filename variable is safe to be used after this point; #endif; strcat(cmd, filename);; system(cmd); // No warning; }. Similarly to the previous example, you need to; define a `Filter` function in a `YAML` configuration file; and add the `csa_mark_sanitized` function. .. code-block:: YAML. Filters:; - Name: csa_mark_sanitized; Args: [0]. Then calling `csa_mark_sanitized(X)` will tell the analyzer that `X` is safe to; be used after this point, because its contents are verified. It is the; responsibility of the programmer to ensure that this verification was indeed; correct. Please note that `csa_mark_sanitized` function is only declared and; used during Clang Static Analysis and skipped in (production) builds. Further examples of injection vulnerabilities this checker can find. .. code-block:: c. void test() {; char x = getchar(); // 'x' marked as tainted; system(&x); // warn: untrus",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:69692,Modifiability,config,configuration,69692,"tion each sanitizing function in our configuration,; you can use a more generic approach. Introduce a generic no-op `csa_mark_sanitized(..)` function to; tell the Clang Static Analyzer; that the variable is safe to be used on that analysis path. .. code-block:: c. // Marking sanitized variables safe.; // No vulnerability anymore, no warning. // User csa_mark_sanitize function is for the analyzer only; #ifdef __clang_analyzer__; void csa_mark_sanitized(const void *);; #endif. int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename);; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; return -1;; }; #ifdef __clang_analyzer__; csa_mark_sanitized(filename); // Indicating to CSA that filename variable is safe to be used after this point; #endif; strcat(cmd, filename);; system(cmd); // No warning; }. Similarly to the previous example, you need to; define a `Filter` function in a `YAML` configuration file; and add the `csa_mark_sanitized` function. .. code-block:: YAML. Filters:; - Name: csa_mark_sanitized; Args: [0]. Then calling `csa_mark_sanitized(X)` will tell the analyzer that `X` is safe to; be used after this point, because its contents are verified. It is the; responsibility of the programmer to ensure that this verification was indeed; correct. Please note that `csa_mark_sanitized` function is only declared and; used during Clang Static Analysis and skipped in (production) builds. Further examples of injection vulnerabilities this checker can find. .. code-block:: c. void test() {; char x = getchar(); // 'x' marked as tainted; system(&x); // warn: untrusted data is passed to a system call; }. // note: compiler internally checks if the second param to; // sprintf is a string literal or not.; // Use -Wno-format-security to suppress compiler warning.; void test() {; char s[10], buf[10];; fscanf(stdin, ""%s"", s); // 's' marked as tainted. sprintf(buf,",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:70978,Modifiability,config,configuration,70978,"ts are verified. It is the; responsibility of the programmer to ensure that this verification was indeed; correct. Please note that `csa_mark_sanitized` function is only declared and; used during Clang Static Analysis and skipped in (production) builds. Further examples of injection vulnerabilities this checker can find. .. code-block:: c. void test() {; char x = getchar(); // 'x' marked as tainted; system(&x); // warn: untrusted data is passed to a system call; }. // note: compiler internally checks if the second param to; // sprintf is a string literal or not.; // Use -Wno-format-security to suppress compiler warning.; void test() {; char s[10], buf[10];; fscanf(stdin, ""%s"", s); // 's' marked as tainted. sprintf(buf, s); // warn: untrusted data used as a format string; }. void test() {; size_t ts;; scanf(""%zd"", &ts); // 'ts' marked as tainted; int *p = (int *)malloc(ts * sizeof(int));; // warn: untrusted data used as buffer size; }. There are built-in sources, propagations and sinks even if no external taint; configuration is provided. Default sources:; ``_IO_getc``, ``fdopen``, ``fopen``, ``freopen``, ``get_current_dir_name``,; ``getch``, ``getchar``, ``getchar_unlocked``, ``getwd``, ``getcwd``,; ``getgroups``, ``gethostname``, ``getlogin``, ``getlogin_r``, ``getnameinfo``,; ``gets``, ``gets_s``, ``getseuserbyname``, ``readlink``, ``readlinkat``,; ``scanf``, ``scanf_s``, ``socket``, ``wgetch``. Default propagations rules:; ``atoi``, ``atol``, ``atoll``, ``basename``, ``dirname``, ``fgetc``,; ``fgetln``, ``fgets``, ``fnmatch``, ``fread``, ``fscanf``, ``fscanf_s``,; ``index``, ``inflate``, ``isalnum``, ``isalpha``, ``isascii``, ``isblank``,; ``iscntrl``, ``isdigit``, ``isgraph``, ``islower``, ``isprint``, ``ispunct``,; ``isspace``, ``isupper``, ``isxdigit``, ``memchr``, ``memrchr``, ``sscanf``,; ``getc``, ``getc_unlocked``, ``getdelim``, ``getline``, ``getw``, ``memcmp``,; ``memcpy``, ``memmem``, ``memmove``, ``mbtowc``, ``pread``, ``qsort``,; ``qsort_r``, ``rawmemc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:72698,Modifiability,config,configure,72698,"mrchr``, ``sscanf``,; ``getc``, ``getc_unlocked``, ``getdelim``, ``getline``, ``getw``, ``memcmp``,; ``memcpy``, ``memmem``, ``memmove``, ``mbtowc``, ``pread``, ``qsort``,; ``qsort_r``, ``rawmemchr``, ``read``, ``recv``, ``recvfrom``, ``rindex``,; ``strcasestr``, ``strchr``, ``strchrnul``, ``strcasecmp``, ``strcmp``,; ``strcspn``, ``strncasecmp``, ``strncmp``, ``strndup``,; ``strndupa``, ``strpbrk``, ``strrchr``, ``strsep``, ``strspn``,; ``strstr``, ``strtol``, ``strtoll``, ``strtoul``, ``strtoull``, ``tolower``,; ``toupper``, ``ttyname``, ``ttyname_r``, ``wctomb``, ``wcwidth``. Default sinks:; ``printf``, ``setproctitle``, ``system``, ``popen``, ``execl``, ``execle``,; ``execlp``, ``execv``, ``execvp``, ``execvP``, ``execve``, ``dlopen``,; ``memcpy``, ``memmove``, ``strncpy``, ``strndup``, ``malloc``, ``calloc``,; ``alloca``, ``memccpy``, ``realloc``, ``bcopy``. Please note that there are no built-in filter functions. One can configure their own taint sources, sinks, and propagation rules by; providing a configuration file via checker option; ``alpha.security.taint.TaintPropagation:Config``. The configuration file is in; `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format. The; taint-related options defined in the config file extend but do not override the; built-in sources, rules, sinks. The format of the external taint configuration; file is not stable, and could change without any notice even in a non-backward; compatible way. For a more detailed description of configuration options, please see the; :doc:`user-docs/TaintAnalysisConfiguration`. For an example see; :ref:`clangsa-taint-configuration-example`. **Configuration**. * `Config` Specifies the name of the YAML configuration file. The user can; define their own taint sources and sinks. **Related Guidelines**. * `CWE Data Neutralization Issues; <https://cwe.mitre.org/data/definitions/137.html>`_; * `SEI Cert STR02-C. Sanitize data passed to complex subsystems; <https://wiki.sei.cmu.edu/con",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:72778,Modifiability,config,configuration,72778,"mrchr``, ``sscanf``,; ``getc``, ``getc_unlocked``, ``getdelim``, ``getline``, ``getw``, ``memcmp``,; ``memcpy``, ``memmem``, ``memmove``, ``mbtowc``, ``pread``, ``qsort``,; ``qsort_r``, ``rawmemchr``, ``read``, ``recv``, ``recvfrom``, ``rindex``,; ``strcasestr``, ``strchr``, ``strchrnul``, ``strcasecmp``, ``strcmp``,; ``strcspn``, ``strncasecmp``, ``strncmp``, ``strndup``,; ``strndupa``, ``strpbrk``, ``strrchr``, ``strsep``, ``strspn``,; ``strstr``, ``strtol``, ``strtoll``, ``strtoul``, ``strtoull``, ``tolower``,; ``toupper``, ``ttyname``, ``ttyname_r``, ``wctomb``, ``wcwidth``. Default sinks:; ``printf``, ``setproctitle``, ``system``, ``popen``, ``execl``, ``execle``,; ``execlp``, ``execv``, ``execvp``, ``execvP``, ``execve``, ``dlopen``,; ``memcpy``, ``memmove``, ``strncpy``, ``strndup``, ``malloc``, ``calloc``,; ``alloca``, ``memccpy``, ``realloc``, ``bcopy``. Please note that there are no built-in filter functions. One can configure their own taint sources, sinks, and propagation rules by; providing a configuration file via checker option; ``alpha.security.taint.TaintPropagation:Config``. The configuration file is in; `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format. The; taint-related options defined in the config file extend but do not override the; built-in sources, rules, sinks. The format of the external taint configuration; file is not stable, and could change without any notice even in a non-backward; compatible way. For a more detailed description of configuration options, please see the; :doc:`user-docs/TaintAnalysisConfiguration`. For an example see; :ref:`clangsa-taint-configuration-example`. **Configuration**. * `Config` Specifies the name of the YAML configuration file. The user can; define their own taint sources and sinks. **Related Guidelines**. * `CWE Data Neutralization Issues; <https://cwe.mitre.org/data/definitions/137.html>`_; * `SEI Cert STR02-C. Sanitize data passed to complex subsystems; <https://wiki.sei.cmu.edu/con",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:72871,Modifiability,config,configuration,72871,"``, ``mbtowc``, ``pread``, ``qsort``,; ``qsort_r``, ``rawmemchr``, ``read``, ``recv``, ``recvfrom``, ``rindex``,; ``strcasestr``, ``strchr``, ``strchrnul``, ``strcasecmp``, ``strcmp``,; ``strcspn``, ``strncasecmp``, ``strncmp``, ``strndup``,; ``strndupa``, ``strpbrk``, ``strrchr``, ``strsep``, ``strspn``,; ``strstr``, ``strtol``, ``strtoll``, ``strtoul``, ``strtoull``, ``tolower``,; ``toupper``, ``ttyname``, ``ttyname_r``, ``wctomb``, ``wcwidth``. Default sinks:; ``printf``, ``setproctitle``, ``system``, ``popen``, ``execl``, ``execle``,; ``execlp``, ``execv``, ``execvp``, ``execvP``, ``execve``, ``dlopen``,; ``memcpy``, ``memmove``, ``strncpy``, ``strndup``, ``malloc``, ``calloc``,; ``alloca``, ``memccpy``, ``realloc``, ``bcopy``. Please note that there are no built-in filter functions. One can configure their own taint sources, sinks, and propagation rules by; providing a configuration file via checker option; ``alpha.security.taint.TaintPropagation:Config``. The configuration file is in; `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format. The; taint-related options defined in the config file extend but do not override the; built-in sources, rules, sinks. The format of the external taint configuration; file is not stable, and could change without any notice even in a non-backward; compatible way. For a more detailed description of configuration options, please see the; :doc:`user-docs/TaintAnalysisConfiguration`. For an example see; :ref:`clangsa-taint-configuration-example`. **Configuration**. * `Config` Specifies the name of the YAML configuration file. The user can; define their own taint sources and sinks. **Related Guidelines**. * `CWE Data Neutralization Issues; <https://cwe.mitre.org/data/definitions/137.html>`_; * `SEI Cert STR02-C. Sanitize data passed to complex subsystems; <https://wiki.sei.cmu.edu/confluence/display/c/STR02-C.+Sanitize+data+passed+to+complex+subsystems>`_; * `SEI Cert ENV33-C. Do not call system(); <https://wiki.sei",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:73011,Modifiability,config,config,73011,"hr``, ``strchrnul``, ``strcasecmp``, ``strcmp``,; ``strcspn``, ``strncasecmp``, ``strncmp``, ``strndup``,; ``strndupa``, ``strpbrk``, ``strrchr``, ``strsep``, ``strspn``,; ``strstr``, ``strtol``, ``strtoll``, ``strtoul``, ``strtoull``, ``tolower``,; ``toupper``, ``ttyname``, ``ttyname_r``, ``wctomb``, ``wcwidth``. Default sinks:; ``printf``, ``setproctitle``, ``system``, ``popen``, ``execl``, ``execle``,; ``execlp``, ``execv``, ``execvp``, ``execvP``, ``execve``, ``dlopen``,; ``memcpy``, ``memmove``, ``strncpy``, ``strndup``, ``malloc``, ``calloc``,; ``alloca``, ``memccpy``, ``realloc``, ``bcopy``. Please note that there are no built-in filter functions. One can configure their own taint sources, sinks, and propagation rules by; providing a configuration file via checker option; ``alpha.security.taint.TaintPropagation:Config``. The configuration file is in; `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format. The; taint-related options defined in the config file extend but do not override the; built-in sources, rules, sinks. The format of the external taint configuration; file is not stable, and could change without any notice even in a non-backward; compatible way. For a more detailed description of configuration options, please see the; :doc:`user-docs/TaintAnalysisConfiguration`. For an example see; :ref:`clangsa-taint-configuration-example`. **Configuration**. * `Config` Specifies the name of the YAML configuration file. The user can; define their own taint sources and sinks. **Related Guidelines**. * `CWE Data Neutralization Issues; <https://cwe.mitre.org/data/definitions/137.html>`_; * `SEI Cert STR02-C. Sanitize data passed to complex subsystems; <https://wiki.sei.cmu.edu/confluence/display/c/STR02-C.+Sanitize+data+passed+to+complex+subsystems>`_; * `SEI Cert ENV33-C. Do not call system(); <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152177>`_; * `ENV03-C. Sanitize the environment when invoking external programs; <htt",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:73023,Modifiability,extend,extend,73023,"hr``, ``strchrnul``, ``strcasecmp``, ``strcmp``,; ``strcspn``, ``strncasecmp``, ``strncmp``, ``strndup``,; ``strndupa``, ``strpbrk``, ``strrchr``, ``strsep``, ``strspn``,; ``strstr``, ``strtol``, ``strtoll``, ``strtoul``, ``strtoull``, ``tolower``,; ``toupper``, ``ttyname``, ``ttyname_r``, ``wctomb``, ``wcwidth``. Default sinks:; ``printf``, ``setproctitle``, ``system``, ``popen``, ``execl``, ``execle``,; ``execlp``, ``execv``, ``execvp``, ``execvP``, ``execve``, ``dlopen``,; ``memcpy``, ``memmove``, ``strncpy``, ``strndup``, ``malloc``, ``calloc``,; ``alloca``, ``memccpy``, ``realloc``, ``bcopy``. Please note that there are no built-in filter functions. One can configure their own taint sources, sinks, and propagation rules by; providing a configuration file via checker option; ``alpha.security.taint.TaintPropagation:Config``. The configuration file is in; `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format. The; taint-related options defined in the config file extend but do not override the; built-in sources, rules, sinks. The format of the external taint configuration; file is not stable, and could change without any notice even in a non-backward; compatible way. For a more detailed description of configuration options, please see the; :doc:`user-docs/TaintAnalysisConfiguration`. For an example see; :ref:`clangsa-taint-configuration-example`. **Configuration**. * `Config` Specifies the name of the YAML configuration file. The user can; define their own taint sources and sinks. **Related Guidelines**. * `CWE Data Neutralization Issues; <https://cwe.mitre.org/data/definitions/137.html>`_; * `SEI Cert STR02-C. Sanitize data passed to complex subsystems; <https://wiki.sei.cmu.edu/confluence/display/c/STR02-C.+Sanitize+data+passed+to+complex+subsystems>`_; * `SEI Cert ENV33-C. Do not call system(); <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152177>`_; * `ENV03-C. Sanitize the environment when invoking external programs; <htt",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:73120,Modifiability,config,configuration,73120,"`, ``strrchr``, ``strsep``, ``strspn``,; ``strstr``, ``strtol``, ``strtoll``, ``strtoul``, ``strtoull``, ``tolower``,; ``toupper``, ``ttyname``, ``ttyname_r``, ``wctomb``, ``wcwidth``. Default sinks:; ``printf``, ``setproctitle``, ``system``, ``popen``, ``execl``, ``execle``,; ``execlp``, ``execv``, ``execvp``, ``execvP``, ``execve``, ``dlopen``,; ``memcpy``, ``memmove``, ``strncpy``, ``strndup``, ``malloc``, ``calloc``,; ``alloca``, ``memccpy``, ``realloc``, ``bcopy``. Please note that there are no built-in filter functions. One can configure their own taint sources, sinks, and propagation rules by; providing a configuration file via checker option; ``alpha.security.taint.TaintPropagation:Config``. The configuration file is in; `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format. The; taint-related options defined in the config file extend but do not override the; built-in sources, rules, sinks. The format of the external taint configuration; file is not stable, and could change without any notice even in a non-backward; compatible way. For a more detailed description of configuration options, please see the; :doc:`user-docs/TaintAnalysisConfiguration`. For an example see; :ref:`clangsa-taint-configuration-example`. **Configuration**. * `Config` Specifies the name of the YAML configuration file. The user can; define their own taint sources and sinks. **Related Guidelines**. * `CWE Data Neutralization Issues; <https://cwe.mitre.org/data/definitions/137.html>`_; * `SEI Cert STR02-C. Sanitize data passed to complex subsystems; <https://wiki.sei.cmu.edu/confluence/display/c/STR02-C.+Sanitize+data+passed+to+complex+subsystems>`_; * `SEI Cert ENV33-C. Do not call system(); <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152177>`_; * `ENV03-C. Sanitize the environment when invoking external programs; <https://wiki.sei.cmu.edu/confluence/display/c/ENV03-C.+Sanitize+the+environment+when+invoking+external+programs>`_. **Limitations**. *",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:73266,Modifiability,config,configuration,73266," ``ttyname``, ``ttyname_r``, ``wctomb``, ``wcwidth``. Default sinks:; ``printf``, ``setproctitle``, ``system``, ``popen``, ``execl``, ``execle``,; ``execlp``, ``execv``, ``execvp``, ``execvP``, ``execve``, ``dlopen``,; ``memcpy``, ``memmove``, ``strncpy``, ``strndup``, ``malloc``, ``calloc``,; ``alloca``, ``memccpy``, ``realloc``, ``bcopy``. Please note that there are no built-in filter functions. One can configure their own taint sources, sinks, and propagation rules by; providing a configuration file via checker option; ``alpha.security.taint.TaintPropagation:Config``. The configuration file is in; `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format. The; taint-related options defined in the config file extend but do not override the; built-in sources, rules, sinks. The format of the external taint configuration; file is not stable, and could change without any notice even in a non-backward; compatible way. For a more detailed description of configuration options, please see the; :doc:`user-docs/TaintAnalysisConfiguration`. For an example see; :ref:`clangsa-taint-configuration-example`. **Configuration**. * `Config` Specifies the name of the YAML configuration file. The user can; define their own taint sources and sinks. **Related Guidelines**. * `CWE Data Neutralization Issues; <https://cwe.mitre.org/data/definitions/137.html>`_; * `SEI Cert STR02-C. Sanitize data passed to complex subsystems; <https://wiki.sei.cmu.edu/confluence/display/c/STR02-C.+Sanitize+data+passed+to+complex+subsystems>`_; * `SEI Cert ENV33-C. Do not call system(); <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152177>`_; * `ENV03-C. Sanitize the environment when invoking external programs; <https://wiki.sei.cmu.edu/confluence/display/c/ENV03-C.+Sanitize+the+environment+when+invoking+external+programs>`_. **Limitations**. * The taintedness property is not propagated through function calls which are; unknown (or too complex) to the analyzer, unless there",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:73390,Modifiability,config,configuration-example,73390,"itle``, ``system``, ``popen``, ``execl``, ``execle``,; ``execlp``, ``execv``, ``execvp``, ``execvP``, ``execve``, ``dlopen``,; ``memcpy``, ``memmove``, ``strncpy``, ``strndup``, ``malloc``, ``calloc``,; ``alloca``, ``memccpy``, ``realloc``, ``bcopy``. Please note that there are no built-in filter functions. One can configure their own taint sources, sinks, and propagation rules by; providing a configuration file via checker option; ``alpha.security.taint.TaintPropagation:Config``. The configuration file is in; `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format. The; taint-related options defined in the config file extend but do not override the; built-in sources, rules, sinks. The format of the external taint configuration; file is not stable, and could change without any notice even in a non-backward; compatible way. For a more detailed description of configuration options, please see the; :doc:`user-docs/TaintAnalysisConfiguration`. For an example see; :ref:`clangsa-taint-configuration-example`. **Configuration**. * `Config` Specifies the name of the YAML configuration file. The user can; define their own taint sources and sinks. **Related Guidelines**. * `CWE Data Neutralization Issues; <https://cwe.mitre.org/data/definitions/137.html>`_; * `SEI Cert STR02-C. Sanitize data passed to complex subsystems; <https://wiki.sei.cmu.edu/confluence/display/c/STR02-C.+Sanitize+data+passed+to+complex+subsystems>`_; * `SEI Cert ENV33-C. Do not call system(); <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152177>`_; * `ENV03-C. Sanitize the environment when invoking external programs; <https://wiki.sei.cmu.edu/confluence/display/c/ENV03-C.+Sanitize+the+environment+when+invoking+external+programs>`_. **Limitations**. * The taintedness property is not propagated through function calls which are; unknown (or too complex) to the analyzer, unless there is a specific; propagation rule built-in to the checker or given in the YAML configuration",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:73475,Modifiability,config,configuration,73475,"ecvp``, ``execvP``, ``execve``, ``dlopen``,; ``memcpy``, ``memmove``, ``strncpy``, ``strndup``, ``malloc``, ``calloc``,; ``alloca``, ``memccpy``, ``realloc``, ``bcopy``. Please note that there are no built-in filter functions. One can configure their own taint sources, sinks, and propagation rules by; providing a configuration file via checker option; ``alpha.security.taint.TaintPropagation:Config``. The configuration file is in; `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format. The; taint-related options defined in the config file extend but do not override the; built-in sources, rules, sinks. The format of the external taint configuration; file is not stable, and could change without any notice even in a non-backward; compatible way. For a more detailed description of configuration options, please see the; :doc:`user-docs/TaintAnalysisConfiguration`. For an example see; :ref:`clangsa-taint-configuration-example`. **Configuration**. * `Config` Specifies the name of the YAML configuration file. The user can; define their own taint sources and sinks. **Related Guidelines**. * `CWE Data Neutralization Issues; <https://cwe.mitre.org/data/definitions/137.html>`_; * `SEI Cert STR02-C. Sanitize data passed to complex subsystems; <https://wiki.sei.cmu.edu/confluence/display/c/STR02-C.+Sanitize+data+passed+to+complex+subsystems>`_; * `SEI Cert ENV33-C. Do not call system(); <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152177>`_; * `ENV03-C. Sanitize the environment when invoking external programs; <https://wiki.sei.cmu.edu/confluence/display/c/ENV03-C.+Sanitize+the+environment+when+invoking+external+programs>`_. **Limitations**. * The taintedness property is not propagated through function calls which are; unknown (or too complex) to the analyzer, unless there is a specific; propagation rule built-in to the checker or given in the YAML configuration; file. This causes potential true positive findings to be lost. alpha.unix; ^^^^^",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:74368,Modifiability,config,configuration,74368,"uration options, please see the; :doc:`user-docs/TaintAnalysisConfiguration`. For an example see; :ref:`clangsa-taint-configuration-example`. **Configuration**. * `Config` Specifies the name of the YAML configuration file. The user can; define their own taint sources and sinks. **Related Guidelines**. * `CWE Data Neutralization Issues; <https://cwe.mitre.org/data/definitions/137.html>`_; * `SEI Cert STR02-C. Sanitize data passed to complex subsystems; <https://wiki.sei.cmu.edu/confluence/display/c/STR02-C.+Sanitize+data+passed+to+complex+subsystems>`_; * `SEI Cert ENV33-C. Do not call system(); <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152177>`_; * `ENV03-C. Sanitize the environment when invoking external programs; <https://wiki.sei.cmu.edu/confluence/display/c/ENV03-C.+Sanitize+the+environment+when+invoking+external+programs>`_. **Limitations**. * The taintedness property is not propagated through function calls which are; unknown (or too complex) to the analyzer, unless there is a specific; propagation rule built-in to the checker or given in the YAML configuration; file. This causes potential true positive findings to be lost. alpha.unix; ^^^^^^^^^^. .. _alpha-unix-BlockInCriticalSection:. alpha.unix.BlockInCriticalSection (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for calls to blocking functions inside a critical section.; Applies to: ``lock, unlock, sleep, getc, fgets, read, recv, pthread_mutex_lock,``; `` pthread_mutex_unlock, mtx_lock, mtx_timedlock, mtx_trylock, mtx_unlock, lock_guard, unique_lock``. .. code-block:: c. void test() {; std::mutex m;; m.lock();; sleep(3); // warn: a blocking function sleep is called inside a critical; // section; m.unlock();; }. .. _alpha-unix-Chroot:. alpha.unix.Chroot (C); """"""""""""""""""""""""""""""""""""""""""; Check improper use of chroot. .. code-block:: c. void f();. void test() {; chroot(""/usr/local"");; f(); // warn: no call of chdir(""/"") immediately after chroot; }. .. _alpha-unix-PthreadLock:. alpha.uni",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:82007,Modifiability,variab,variables,82007,"y dynamically allocated ref-countable object passed as a call argument spans past the end of the call. This applies to call to any function, method, lambda, function pointer or functor. Ref-countable types aren't supposed to be allocated on stack so we check arguments for parameters of raw pointers and references to uncounted types. Here are some examples of situations that we warn about as they *might* be potentially unsafe. The logic is that either we're able to guarantee that an argument is safe or it's considered if not a bug then bug-prone. .. code-block:: cpp. RefCountable* provide_uncounted();; void consume(RefCountable*);. // In these cases we can't make sure callee won't directly or indirectly call `deref()` on the argument which could make it unsafe from such point until the end of the call. void foo1() {; consume(provide_uncounted()); // warn; }. void foo2() {; RefCountable* uncounted = provide_uncounted();; consume(uncounted); // warn; }. Although we are enforcing member variables to be ref-counted by `webkit.NoUncountedMemberChecker` any method of the same class still has unrestricted access to these. Since from a caller's perspective we can't guarantee a particular member won't get modified by callee (directly or indirectly) we don't consider values obtained from members safe. Note: It's likely this heuristic could be made more precise with fewer false positives - for example calls to free functions that don't have any parameter other than the pointer should be safe as the callee won't be able to tamper with the member unless it's a global variable. .. code-block:: cpp. struct Foo {; RefPtr<RefCountable> member;; void consume(RefCountable*) { /* ... */ }; void bugprone() {; consume(member.get()); // warn; }; };. The implementation of this rule is a heuristic - we define a whitelist of kinds of values that are considered safe to be passed as arguments. If we can't prove an argument is safe it's considered an error. Allowed kinds of arguments:. - values o",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:82589,Modifiability,variab,variable,82589,ther we're able to guarantee that an argument is safe or it's considered if not a bug then bug-prone. .. code-block:: cpp. RefCountable* provide_uncounted();; void consume(RefCountable*);. // In these cases we can't make sure callee won't directly or indirectly call `deref()` on the argument which could make it unsafe from such point until the end of the call. void foo1() {; consume(provide_uncounted()); // warn; }. void foo2() {; RefCountable* uncounted = provide_uncounted();; consume(uncounted); // warn; }. Although we are enforcing member variables to be ref-counted by `webkit.NoUncountedMemberChecker` any method of the same class still has unrestricted access to these. Since from a caller's perspective we can't guarantee a particular member won't get modified by callee (directly or indirectly) we don't consider values obtained from members safe. Note: It's likely this heuristic could be made more precise with fewer false positives - for example calls to free functions that don't have any parameter other than the pointer should be safe as the callee won't be able to tamper with the member unless it's a global variable. .. code-block:: cpp. struct Foo {; RefPtr<RefCountable> member;; void consume(RefCountable*) { /* ... */ }; void bugprone() {; consume(member.get()); // warn; }; };. The implementation of this rule is a heuristic - we define a whitelist of kinds of values that are considered safe to be passed as arguments. If we can't prove an argument is safe it's considered an error. Allowed kinds of arguments:. - values obtained from ref-counted objects (including temporaries as those survive the call too). .. code-block:: cpp. RefCountable* provide_uncounted();; void consume(RefCountable*);. void foo() {; RefPtr<RefCountable> rc = makeRef(provide_uncounted());; consume(rc.get()); // ok; consume(makeRef(provide_uncounted()).get()); // ok; }. - forwarding uncounted arguments from caller to callee. .. code-block:: cpp. void foo(RefCountable& a) {; bar(a); // ok; },MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:84284,Modifiability,variab,variable,84284,"onsume(makeRef(provide_uncounted()).get()); // ok; }. - forwarding uncounted arguments from caller to callee. .. code-block:: cpp. void foo(RefCountable& a) {; bar(a); // ok; }. Caller of ``foo()`` is responsible for ``a``'s lifetime. - ``this`` pointer. .. code-block:: cpp. void Foo::foo() {; baz(this); // ok; }. Caller of ``foo()`` is responsible for keeping the memory pointed to by ``this`` pointer safe. - constants. .. code-block:: cpp. foo(nullptr, NULL, 0); // ok. We also define a set of safe transformations which if passed a safe value as an input provide (usually it's the return value) a safe value (or an object that provides safe values). This is also a heuristic. - constructors of ref-counted types (including factory methods); - getters of ref-counted types; - member overloaded operators; - casts; - unary operators like ``&`` or ``*``. alpha.webkit.UncountedLocalVarsChecker; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; The goal of this rule is to make sure that any uncounted local variable is backed by a ref-counted object with lifetime that is strictly larger than the scope of the uncounted local variable. To be on the safe side we require the scope of an uncounted variable to be embedded in the scope of ref-counted object that backs it. These are examples of cases that we consider safe:. .. code-block:: cpp. void foo1() {; RefPtr<RefCountable> counted;; // The scope of uncounted is EMBEDDED in the scope of counted.; {; RefCountable* uncounted = counted.get(); // ok; }; }. void foo2(RefPtr<RefCountable> counted_param) {; RefCountable* uncounted = counted_param.get(); // ok; }. void FooClass::foo_method() {; RefCountable* uncounted = this; // ok; }. Here are some examples of situations that we warn about as they *might* be potentially unsafe. The logic is that either we're able to guarantee that an argument is safe or it's considered if not a bug then bug-prone. .. code-block:: cpp. void foo1() {; RefCountable* uncounted = new RefCountable; // warn; }. RefCount",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:84403,Modifiability,variab,variable,84403,"onsume(makeRef(provide_uncounted()).get()); // ok; }. - forwarding uncounted arguments from caller to callee. .. code-block:: cpp. void foo(RefCountable& a) {; bar(a); // ok; }. Caller of ``foo()`` is responsible for ``a``'s lifetime. - ``this`` pointer. .. code-block:: cpp. void Foo::foo() {; baz(this); // ok; }. Caller of ``foo()`` is responsible for keeping the memory pointed to by ``this`` pointer safe. - constants. .. code-block:: cpp. foo(nullptr, NULL, 0); // ok. We also define a set of safe transformations which if passed a safe value as an input provide (usually it's the return value) a safe value (or an object that provides safe values). This is also a heuristic. - constructors of ref-counted types (including factory methods); - getters of ref-counted types; - member overloaded operators; - casts; - unary operators like ``&`` or ``*``. alpha.webkit.UncountedLocalVarsChecker; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; The goal of this rule is to make sure that any uncounted local variable is backed by a ref-counted object with lifetime that is strictly larger than the scope of the uncounted local variable. To be on the safe side we require the scope of an uncounted variable to be embedded in the scope of ref-counted object that backs it. These are examples of cases that we consider safe:. .. code-block:: cpp. void foo1() {; RefPtr<RefCountable> counted;; // The scope of uncounted is EMBEDDED in the scope of counted.; {; RefCountable* uncounted = counted.get(); // ok; }; }. void foo2(RefPtr<RefCountable> counted_param) {; RefCountable* uncounted = counted_param.get(); // ok; }. void FooClass::foo_method() {; RefCountable* uncounted = this; // ok; }. Here are some examples of situations that we warn about as they *might* be potentially unsafe. The logic is that either we're able to guarantee that an argument is safe or it's considered if not a bug then bug-prone. .. code-block:: cpp. void foo1() {; RefCountable* uncounted = new RefCountable; // warn; }. RefCount",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:84473,Modifiability,variab,variable,84473,"` is responsible for ``a``'s lifetime. - ``this`` pointer. .. code-block:: cpp. void Foo::foo() {; baz(this); // ok; }. Caller of ``foo()`` is responsible for keeping the memory pointed to by ``this`` pointer safe. - constants. .. code-block:: cpp. foo(nullptr, NULL, 0); // ok. We also define a set of safe transformations which if passed a safe value as an input provide (usually it's the return value) a safe value (or an object that provides safe values). This is also a heuristic. - constructors of ref-counted types (including factory methods); - getters of ref-counted types; - member overloaded operators; - casts; - unary operators like ``&`` or ``*``. alpha.webkit.UncountedLocalVarsChecker; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; The goal of this rule is to make sure that any uncounted local variable is backed by a ref-counted object with lifetime that is strictly larger than the scope of the uncounted local variable. To be on the safe side we require the scope of an uncounted variable to be embedded in the scope of ref-counted object that backs it. These are examples of cases that we consider safe:. .. code-block:: cpp. void foo1() {; RefPtr<RefCountable> counted;; // The scope of uncounted is EMBEDDED in the scope of counted.; {; RefCountable* uncounted = counted.get(); // ok; }; }. void foo2(RefPtr<RefCountable> counted_param) {; RefCountable* uncounted = counted_param.get(); // ok; }. void FooClass::foo_method() {; RefCountable* uncounted = this; // ok; }. Here are some examples of situations that we warn about as they *might* be potentially unsafe. The logic is that either we're able to guarantee that an argument is safe or it's considered if not a bug then bug-prone. .. code-block:: cpp. void foo1() {; RefCountable* uncounted = new RefCountable; // warn; }. RefCountable* global_uncounted;; void foo2() {; RefCountable* uncounted = global_uncounted; // warn; }. void foo3() {; RefPtr<RefCountable> counted;; // The scope of uncounted is not EMBEDDED in the scope",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:85722,Modifiability,variab,variable,85722,"DED in the scope of counted.; {; RefCountable* uncounted = counted.get(); // ok; }; }. void foo2(RefPtr<RefCountable> counted_param) {; RefCountable* uncounted = counted_param.get(); // ok; }. void FooClass::foo_method() {; RefCountable* uncounted = this; // ok; }. Here are some examples of situations that we warn about as they *might* be potentially unsafe. The logic is that either we're able to guarantee that an argument is safe or it's considered if not a bug then bug-prone. .. code-block:: cpp. void foo1() {; RefCountable* uncounted = new RefCountable; // warn; }. RefCountable* global_uncounted;; void foo2() {; RefCountable* uncounted = global_uncounted; // warn; }. void foo3() {; RefPtr<RefCountable> counted;; // The scope of uncounted is not EMBEDDED in the scope of counted.; RefCountable* uncounted = counted.get(); // warn; }. We don't warn about these cases - we don't consider them necessarily safe but since they are very common and usually safe we'd introduce a lot of false positives otherwise:; - variable defined in condition part of an ```if``` statement; - variable defined in init statement condition of a ```for``` statement. For the time being we also don't warn about uninitialized uncounted local variables. Debug Checkers; ---------------. .. _debug-checkers:. debug; ^^^^^. Checkers used for debugging the analyzer.; :doc:`developer-docs/DebugChecks` page contains a detailed description. .. _debug-AnalysisOrder:. debug.AnalysisOrder; """"""""""""""""""""""""""""""""""""""; Print callbacks that are called during analysis in order. .. _debug-ConfigDumper:. debug.ConfigDumper; """"""""""""""""""""""""""""""""""""; Dump config table. .. _debug-DumpCFG Display:. debug.DumpCFG Display; """"""""""""""""""""""""""""""""""""""""""; Control-Flow Graphs. .. _debug-DumpCallGraph:. debug.DumpCallGraph; """"""""""""""""""""""""""""""""""""""; Display Call Graph. .. _debug-DumpCalls:. debug.DumpCalls; """"""""""""""""""""""""""""""; Print calls as they are traversed by the engine. .. _debug-DumpDominators:. debug.DumpDominators; """"""""""""""""""""""""""""""""""""""""; Print t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:85785,Modifiability,variab,variable,85785,"DED in the scope of counted.; {; RefCountable* uncounted = counted.get(); // ok; }; }. void foo2(RefPtr<RefCountable> counted_param) {; RefCountable* uncounted = counted_param.get(); // ok; }. void FooClass::foo_method() {; RefCountable* uncounted = this; // ok; }. Here are some examples of situations that we warn about as they *might* be potentially unsafe. The logic is that either we're able to guarantee that an argument is safe or it's considered if not a bug then bug-prone. .. code-block:: cpp. void foo1() {; RefCountable* uncounted = new RefCountable; // warn; }. RefCountable* global_uncounted;; void foo2() {; RefCountable* uncounted = global_uncounted; // warn; }. void foo3() {; RefPtr<RefCountable> counted;; // The scope of uncounted is not EMBEDDED in the scope of counted.; RefCountable* uncounted = counted.get(); // warn; }. We don't warn about these cases - we don't consider them necessarily safe but since they are very common and usually safe we'd introduce a lot of false positives otherwise:; - variable defined in condition part of an ```if``` statement; - variable defined in init statement condition of a ```for``` statement. For the time being we also don't warn about uninitialized uncounted local variables. Debug Checkers; ---------------. .. _debug-checkers:. debug; ^^^^^. Checkers used for debugging the analyzer.; :doc:`developer-docs/DebugChecks` page contains a detailed description. .. _debug-AnalysisOrder:. debug.AnalysisOrder; """"""""""""""""""""""""""""""""""""""; Print callbacks that are called during analysis in order. .. _debug-ConfigDumper:. debug.ConfigDumper; """"""""""""""""""""""""""""""""""""; Dump config table. .. _debug-DumpCFG Display:. debug.DumpCFG Display; """"""""""""""""""""""""""""""""""""""""""; Control-Flow Graphs. .. _debug-DumpCallGraph:. debug.DumpCallGraph; """"""""""""""""""""""""""""""""""""""; Display Call Graph. .. _debug-DumpCalls:. debug.DumpCalls; """"""""""""""""""""""""""""""; Print calls as they are traversed by the engine. .. _debug-DumpDominators:. debug.DumpDominators; """"""""""""""""""""""""""""""""""""""""; Print t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:85930,Modifiability,variab,variables,85930," FooClass::foo_method() {; RefCountable* uncounted = this; // ok; }. Here are some examples of situations that we warn about as they *might* be potentially unsafe. The logic is that either we're able to guarantee that an argument is safe or it's considered if not a bug then bug-prone. .. code-block:: cpp. void foo1() {; RefCountable* uncounted = new RefCountable; // warn; }. RefCountable* global_uncounted;; void foo2() {; RefCountable* uncounted = global_uncounted; // warn; }. void foo3() {; RefPtr<RefCountable> counted;; // The scope of uncounted is not EMBEDDED in the scope of counted.; RefCountable* uncounted = counted.get(); // warn; }. We don't warn about these cases - we don't consider them necessarily safe but since they are very common and usually safe we'd introduce a lot of false positives otherwise:; - variable defined in condition part of an ```if``` statement; - variable defined in init statement condition of a ```for``` statement. For the time being we also don't warn about uninitialized uncounted local variables. Debug Checkers; ---------------. .. _debug-checkers:. debug; ^^^^^. Checkers used for debugging the analyzer.; :doc:`developer-docs/DebugChecks` page contains a detailed description. .. _debug-AnalysisOrder:. debug.AnalysisOrder; """"""""""""""""""""""""""""""""""""""; Print callbacks that are called during analysis in order. .. _debug-ConfigDumper:. debug.ConfigDumper; """"""""""""""""""""""""""""""""""""; Dump config table. .. _debug-DumpCFG Display:. debug.DumpCFG Display; """"""""""""""""""""""""""""""""""""""""""; Control-Flow Graphs. .. _debug-DumpCallGraph:. debug.DumpCallGraph; """"""""""""""""""""""""""""""""""""""; Display Call Graph. .. _debug-DumpCalls:. debug.DumpCalls; """"""""""""""""""""""""""""""; Print calls as they are traversed by the engine. .. _debug-DumpDominators:. debug.DumpDominators; """"""""""""""""""""""""""""""""""""""""; Print the dominance tree for a given CFG. .. _debug-DumpLiveVars:. debug.DumpLiveVars; """"""""""""""""""""""""""""""""""""; Print results of live variable analysis. .. _debug-DumpTraversal:. debug.DumpTraversal; """"""""""""""""""""",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:86320,Modifiability,config,config,86320," void foo2() {; RefCountable* uncounted = global_uncounted; // warn; }. void foo3() {; RefPtr<RefCountable> counted;; // The scope of uncounted is not EMBEDDED in the scope of counted.; RefCountable* uncounted = counted.get(); // warn; }. We don't warn about these cases - we don't consider them necessarily safe but since they are very common and usually safe we'd introduce a lot of false positives otherwise:; - variable defined in condition part of an ```if``` statement; - variable defined in init statement condition of a ```for``` statement. For the time being we also don't warn about uninitialized uncounted local variables. Debug Checkers; ---------------. .. _debug-checkers:. debug; ^^^^^. Checkers used for debugging the analyzer.; :doc:`developer-docs/DebugChecks` page contains a detailed description. .. _debug-AnalysisOrder:. debug.AnalysisOrder; """"""""""""""""""""""""""""""""""""""; Print callbacks that are called during analysis in order. .. _debug-ConfigDumper:. debug.ConfigDumper; """"""""""""""""""""""""""""""""""""; Dump config table. .. _debug-DumpCFG Display:. debug.DumpCFG Display; """"""""""""""""""""""""""""""""""""""""""; Control-Flow Graphs. .. _debug-DumpCallGraph:. debug.DumpCallGraph; """"""""""""""""""""""""""""""""""""""; Display Call Graph. .. _debug-DumpCalls:. debug.DumpCalls; """"""""""""""""""""""""""""""; Print calls as they are traversed by the engine. .. _debug-DumpDominators:. debug.DumpDominators; """"""""""""""""""""""""""""""""""""""""; Print the dominance tree for a given CFG. .. _debug-DumpLiveVars:. debug.DumpLiveVars; """"""""""""""""""""""""""""""""""""; Print results of live variable analysis. .. _debug-DumpTraversal:. debug.DumpTraversal; """"""""""""""""""""""""""""""""""""""; Print branch conditions as they are traversed by the engine. .. _debug-ExprInspection:. debug.ExprInspection; """"""""""""""""""""""""""""""""""""""""; Check the analyzer's understanding of expressions. .. _debug-Stats:. debug.Stats; """"""""""""""""""""""; Emit warnings with analyzer statistics. .. _debug-TaintTest:. debug.TaintTest; """"""""""""""""""""""""""""""; Mark tainted symbols as such. .. _debug-ViewCFG:. debug.ViewCFG; """"""""""""""""""""",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:86822,Modifiability,variab,variable,86822," cases - we don't consider them necessarily safe but since they are very common and usually safe we'd introduce a lot of false positives otherwise:; - variable defined in condition part of an ```if``` statement; - variable defined in init statement condition of a ```for``` statement. For the time being we also don't warn about uninitialized uncounted local variables. Debug Checkers; ---------------. .. _debug-checkers:. debug; ^^^^^. Checkers used for debugging the analyzer.; :doc:`developer-docs/DebugChecks` page contains a detailed description. .. _debug-AnalysisOrder:. debug.AnalysisOrder; """"""""""""""""""""""""""""""""""""""; Print callbacks that are called during analysis in order. .. _debug-ConfigDumper:. debug.ConfigDumper; """"""""""""""""""""""""""""""""""""; Dump config table. .. _debug-DumpCFG Display:. debug.DumpCFG Display; """"""""""""""""""""""""""""""""""""""""""; Control-Flow Graphs. .. _debug-DumpCallGraph:. debug.DumpCallGraph; """"""""""""""""""""""""""""""""""""""; Display Call Graph. .. _debug-DumpCalls:. debug.DumpCalls; """"""""""""""""""""""""""""""; Print calls as they are traversed by the engine. .. _debug-DumpDominators:. debug.DumpDominators; """"""""""""""""""""""""""""""""""""""""; Print the dominance tree for a given CFG. .. _debug-DumpLiveVars:. debug.DumpLiveVars; """"""""""""""""""""""""""""""""""""; Print results of live variable analysis. .. _debug-DumpTraversal:. debug.DumpTraversal; """"""""""""""""""""""""""""""""""""""; Print branch conditions as they are traversed by the engine. .. _debug-ExprInspection:. debug.ExprInspection; """"""""""""""""""""""""""""""""""""""""; Check the analyzer's understanding of expressions. .. _debug-Stats:. debug.Stats; """"""""""""""""""""""; Emit warnings with analyzer statistics. .. _debug-TaintTest:. debug.TaintTest; """"""""""""""""""""""""""""""; Mark tainted symbols as such. .. _debug-ViewCFG:. debug.ViewCFG; """"""""""""""""""""""""""; View Control-Flow Graphs using GraphViz. .. _debug-ViewCallGraph:. debug.ViewCallGraph; """"""""""""""""""""""""""""""""""""""; View Call Graph using GraphViz. .. _debug-ViewExplodedGraph:. debug.ViewExplodedGraph; """"""""""""""""""""""""""""""""""""""""""""""; View Exploded Graphs using GraphViz.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:73,Performance,perform,performs,73,"==================; Available Checkers; ==================. The analyzer performs checks that are categorized into families or ""checkers"". The default set of checkers covers a variety of checks targeted at finding security and API usage bugs,; dead code, and other logic errors. See the :ref:`default-checkers` checkers list below. In addition to these, the analyzer contains a number of :ref:`alpha-checkers` (aka *alpha* checkers).; These checkers are under development and are switched off by default. They may crash or emit a higher number of false positives. The :ref:`debug-checkers` package contains checkers for analyzer developers for debugging purposes. .. contents:: Table of Contents; :depth: 4. .. _default-checkers:. Default Checkers; ----------------. .. _core-checkers:. core; ^^^^; Models core language features and contains general-purpose checkers such as division by zero,; null pointer dereference, usage of uninitialized values, etc.; *These checkers must be always switched on as other checker rely on them.*. .. _core-BitwiseShift:. core.BitwiseShift (C, C++); """""""""""""""""""""""""""""""""""""""""""""""""""". Finds undefined behavior caused by the bitwise left- and right-shift operator; operating on integer types. By default, this checker only reports situations when the right operand is; either negative or larger than the bit width of the type of the left operand;; these are logically unsound. Moreover, if the pedantic mode is activated by; ``-analyzer-config core.BitwiseShift:Pedantic=true``, then this checker also; reports situations where the _left_ operand of a shift operator is negative or; overflow occurs during the right shift of a signed value. (Most compilers; handle these predictably, but the C standard and the C++ standards before C++20; say that they're undefined behavior. In the C++20 standard these constructs are; well-defined, so activating pedantic mode in C++20 has no effect.). **Examples**. .. code-block:: cpp. static_assert(sizeof(int) == 4, ""assuming 32-bit in",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:12852,Performance,perform,performance,12852,"t {; int data;; struct LinkedList *next;; };. struct LinkedList * _Nullable getNext(struct LinkedList *l);. void updateNextData(struct LinkedList *list, int newData) {; struct LinkedList *next = getNext(list);; // Warning: Nullable pointer is dereferenced; next->data = 7;; }. .. _nullability-NullablePassedToNonnull:. nullability.NullablePassedToNonnull (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns when a nullable pointer is passed to a pointer which has a _Nonnull type. .. code-block:: objc. typedef struct Dummy { int val; } Dummy;; Dummy *_Nullable returnsNullable();; void takesNonnull(Dummy *_Nonnull);. void test() {; Dummy *p = returnsNullable();; takesNonnull(p); // warn; }. .. _nullability-NullableReturnedFromNonnull:. nullability.NullableReturnedFromNonnull (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns when a nullable pointer is returned from a function that has _Nonnull return type. .. _optin-checkers:. optin; ^^^^^. Checkers for portability, performance or coding style specific rules. .. _optin-core-EnumCastOutOfRange:. optin.core.EnumCastOutOfRange (C, C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for integer to enumeration casts that would produce a value with no; corresponding enumerator. This is not necessarily undefined behavior, but can; lead to nasty surprises, so projects may decide to use a coding standard that; disallows these ""unusual"" conversions. Note that no warnings are produced when the enum type (e.g. `std::byte`) has no; enumerators at all. .. code-block:: cpp. enum WidgetKind { A=1, B, C, X=99 };. void foo() {; WidgetKind c = static_cast<WidgetKind>(3); // OK; WidgetKind x = static_cast<WidgetKind>(99); // OK; WidgetKind d = static_cast<WidgetKind>(4); // warn; }. **Limitations**. This checker does not accept the coding pattern where an enum type is used to; store combinations of flag values:. .. code-block:: cpp. enum AnimalFlags; {; HasClaws = 1,; CanFly = 2,; EatsFish = 4,; Endangered = 8; };. AnimalFla",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:19306,Performance,perform,performance-GCDAntipattern,19306,"Check that NSLocalizedString macros include a comment for context. .. code-block:: objc. - (void)test {; NSString *string = NSLocalizedString(@""LocalizedString"", nil); // warn; NSString *string2 = NSLocalizedString(@""LocalizedString"", @"" ""); // warn; NSString *string3 = NSLocalizedStringWithDefaultValue(; @""LocalizedString"", nil, [[NSBundle alloc] init], nil,@""""); // warn; }. .. _optin-osx-cocoa-localizability-NonLocalizedStringChecker:. optin.osx.cocoa.localizability.NonLocalizedStringChecker (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns about uses of non-localized NSStrings passed to UI methods expecting localized NSStrings. .. code-block:: objc. NSString *alarmText =; NSLocalizedString(@""Enabled"", @""Indicates alarm is turned on"");; if (!isEnabled) {; alarmText = @""Disabled"";; }; UILabel *alarmStateLabel = [[UILabel alloc] init];. // Warning: User-facing text should use localized string macro; [alarmStateLabel setText:alarmText];. .. _optin-performance-GCDAntipattern:. optin.performance.GCDAntipattern; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for performance anti-patterns when using Grand Central Dispatch. .. _optin-performance-Padding:. optin.performance.Padding; """"""""""""""""""""""""""""""""""""""""""""""""""; Check for excessively padded structs. .. _optin-portability-UnixAPI:. optin.portability.UnixAPI; """"""""""""""""""""""""""""""""""""""""""""""""""; Finds implementation-defined behavior in UNIX/Posix functions. .. _security-checkers:. security; ^^^^^^^^. Security related checkers. .. _security-cert-env-InvalidPtr:. security.cert.env.InvalidPtr; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Corresponds to SEI CERT Rules `ENV31-C <https://wiki.sei.cmu.edu/confluence/display/c/ENV31-C.+Do+not+rely+on+an+environment+pointer+following+an+operation+that+may+invalidate+it>`_ and `ENV34-C <https://wiki.sei.cmu.edu/confluence/display/c/ENV34-C.+Do+not+store+pointers+returned+by+certain+functions>`_. * **ENV31-C**:; Rule is about the possible problem with ``main`` function's third argument",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:19341,Performance,perform,performance,19341,"cros include a comment for context. .. code-block:: objc. - (void)test {; NSString *string = NSLocalizedString(@""LocalizedString"", nil); // warn; NSString *string2 = NSLocalizedString(@""LocalizedString"", @"" ""); // warn; NSString *string3 = NSLocalizedStringWithDefaultValue(; @""LocalizedString"", nil, [[NSBundle alloc] init], nil,@""""); // warn; }. .. _optin-osx-cocoa-localizability-NonLocalizedStringChecker:. optin.osx.cocoa.localizability.NonLocalizedStringChecker (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns about uses of non-localized NSStrings passed to UI methods expecting localized NSStrings. .. code-block:: objc. NSString *alarmText =; NSLocalizedString(@""Enabled"", @""Indicates alarm is turned on"");; if (!isEnabled) {; alarmText = @""Disabled"";; }; UILabel *alarmStateLabel = [[UILabel alloc] init];. // Warning: User-facing text should use localized string macro; [alarmStateLabel setText:alarmText];. .. _optin-performance-GCDAntipattern:. optin.performance.GCDAntipattern; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for performance anti-patterns when using Grand Central Dispatch. .. _optin-performance-Padding:. optin.performance.Padding; """"""""""""""""""""""""""""""""""""""""""""""""""; Check for excessively padded structs. .. _optin-portability-UnixAPI:. optin.portability.UnixAPI; """"""""""""""""""""""""""""""""""""""""""""""""""; Finds implementation-defined behavior in UNIX/Posix functions. .. _security-checkers:. security; ^^^^^^^^. Security related checkers. .. _security-cert-env-InvalidPtr:. security.cert.env.InvalidPtr; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Corresponds to SEI CERT Rules `ENV31-C <https://wiki.sei.cmu.edu/confluence/display/c/ENV31-C.+Do+not+rely+on+an+environment+pointer+following+an+operation+that+may+invalidate+it>`_ and `ENV34-C <https://wiki.sei.cmu.edu/confluence/display/c/ENV34-C.+Do+not+store+pointers+returned+by+certain+functions>`_. * **ENV31-C**:; Rule is about the possible problem with ``main`` function's third argument, environment pointer,; ""envp"".",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:19413,Performance,perform,performance,19413,"test {; NSString *string = NSLocalizedString(@""LocalizedString"", nil); // warn; NSString *string2 = NSLocalizedString(@""LocalizedString"", @"" ""); // warn; NSString *string3 = NSLocalizedStringWithDefaultValue(; @""LocalizedString"", nil, [[NSBundle alloc] init], nil,@""""); // warn; }. .. _optin-osx-cocoa-localizability-NonLocalizedStringChecker:. optin.osx.cocoa.localizability.NonLocalizedStringChecker (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns about uses of non-localized NSStrings passed to UI methods expecting localized NSStrings. .. code-block:: objc. NSString *alarmText =; NSLocalizedString(@""Enabled"", @""Indicates alarm is turned on"");; if (!isEnabled) {; alarmText = @""Disabled"";; }; UILabel *alarmStateLabel = [[UILabel alloc] init];. // Warning: User-facing text should use localized string macro; [alarmStateLabel setText:alarmText];. .. _optin-performance-GCDAntipattern:. optin.performance.GCDAntipattern; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for performance anti-patterns when using Grand Central Dispatch. .. _optin-performance-Padding:. optin.performance.Padding; """"""""""""""""""""""""""""""""""""""""""""""""""; Check for excessively padded structs. .. _optin-portability-UnixAPI:. optin.portability.UnixAPI; """"""""""""""""""""""""""""""""""""""""""""""""""; Finds implementation-defined behavior in UNIX/Posix functions. .. _security-checkers:. security; ^^^^^^^^. Security related checkers. .. _security-cert-env-InvalidPtr:. security.cert.env.InvalidPtr; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Corresponds to SEI CERT Rules `ENV31-C <https://wiki.sei.cmu.edu/confluence/display/c/ENV31-C.+Do+not+rely+on+an+environment+pointer+following+an+operation+that+may+invalidate+it>`_ and `ENV34-C <https://wiki.sei.cmu.edu/confluence/display/c/ENV34-C.+Do+not+store+pointers+returned+by+certain+functions>`_. * **ENV31-C**:; Rule is about the possible problem with ``main`` function's third argument, environment pointer,; ""envp"". When environment array is modified using some modification functi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:19484,Performance,perform,performance-Padding,19484,"n; NSString *string2 = NSLocalizedString(@""LocalizedString"", @"" ""); // warn; NSString *string3 = NSLocalizedStringWithDefaultValue(; @""LocalizedString"", nil, [[NSBundle alloc] init], nil,@""""); // warn; }. .. _optin-osx-cocoa-localizability-NonLocalizedStringChecker:. optin.osx.cocoa.localizability.NonLocalizedStringChecker (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns about uses of non-localized NSStrings passed to UI methods expecting localized NSStrings. .. code-block:: objc. NSString *alarmText =; NSLocalizedString(@""Enabled"", @""Indicates alarm is turned on"");; if (!isEnabled) {; alarmText = @""Disabled"";; }; UILabel *alarmStateLabel = [[UILabel alloc] init];. // Warning: User-facing text should use localized string macro; [alarmStateLabel setText:alarmText];. .. _optin-performance-GCDAntipattern:. optin.performance.GCDAntipattern; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for performance anti-patterns when using Grand Central Dispatch. .. _optin-performance-Padding:. optin.performance.Padding; """"""""""""""""""""""""""""""""""""""""""""""""""; Check for excessively padded structs. .. _optin-portability-UnixAPI:. optin.portability.UnixAPI; """"""""""""""""""""""""""""""""""""""""""""""""""; Finds implementation-defined behavior in UNIX/Posix functions. .. _security-checkers:. security; ^^^^^^^^. Security related checkers. .. _security-cert-env-InvalidPtr:. security.cert.env.InvalidPtr; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Corresponds to SEI CERT Rules `ENV31-C <https://wiki.sei.cmu.edu/confluence/display/c/ENV31-C.+Do+not+rely+on+an+environment+pointer+following+an+operation+that+may+invalidate+it>`_ and `ENV34-C <https://wiki.sei.cmu.edu/confluence/display/c/ENV34-C.+Do+not+store+pointers+returned+by+certain+functions>`_. * **ENV31-C**:; Rule is about the possible problem with ``main`` function's third argument, environment pointer,; ""envp"". When environment array is modified using some modification function; such as ``putenv``, ``setenv`` or others, It may happen that memory is rea",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:19512,Performance,perform,performance,19512,"alizedString(@""LocalizedString"", @"" ""); // warn; NSString *string3 = NSLocalizedStringWithDefaultValue(; @""LocalizedString"", nil, [[NSBundle alloc] init], nil,@""""); // warn; }. .. _optin-osx-cocoa-localizability-NonLocalizedStringChecker:. optin.osx.cocoa.localizability.NonLocalizedStringChecker (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns about uses of non-localized NSStrings passed to UI methods expecting localized NSStrings. .. code-block:: objc. NSString *alarmText =; NSLocalizedString(@""Enabled"", @""Indicates alarm is turned on"");; if (!isEnabled) {; alarmText = @""Disabled"";; }; UILabel *alarmStateLabel = [[UILabel alloc] init];. // Warning: User-facing text should use localized string macro; [alarmStateLabel setText:alarmText];. .. _optin-performance-GCDAntipattern:. optin.performance.GCDAntipattern; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for performance anti-patterns when using Grand Central Dispatch. .. _optin-performance-Padding:. optin.performance.Padding; """"""""""""""""""""""""""""""""""""""""""""""""""; Check for excessively padded structs. .. _optin-portability-UnixAPI:. optin.portability.UnixAPI; """"""""""""""""""""""""""""""""""""""""""""""""""; Finds implementation-defined behavior in UNIX/Posix functions. .. _security-checkers:. security; ^^^^^^^^. Security related checkers. .. _security-cert-env-InvalidPtr:. security.cert.env.InvalidPtr; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Corresponds to SEI CERT Rules `ENV31-C <https://wiki.sei.cmu.edu/confluence/display/c/ENV31-C.+Do+not+rely+on+an+environment+pointer+following+an+operation+that+may+invalidate+it>`_ and `ENV34-C <https://wiki.sei.cmu.edu/confluence/display/c/ENV34-C.+Do+not+store+pointers+returned+by+certain+functions>`_. * **ENV31-C**:; Rule is about the possible problem with ``main`` function's third argument, environment pointer,; ""envp"". When environment array is modified using some modification function; such as ``putenv``, ``setenv`` or others, It may happen that memory is reallocated,; however ""envp"" i",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:68084,Performance,perform,performed,68084,"nd is also; executed after the contents of `/etc/shadow` is printed.; `Input: /etc/shadow ; ls /`. The analysis implemented in this checker points out this problem. One can protect against such attack by for example checking if the provided; input refers to a valid file and removing any invalid user input. .. code-block:: c. // No vulnerability anymore, but we still get the warning; void sanitizeFileName(char* filename){; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; filename[0]='\0';; }; }; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; sanitizeFileName(filename);// filename is safe after this point; if (!filename[0]); return -1;; strcat(cmd, filename);; system(cmd); // Superfluous Warning: Untrusted data is passed to a system call; }. Unfortunately, the checker cannot discover automatically that the programmer; have performed data sanitation, so it still emits the warning. One can get rid of this superfluous warning by telling by specifying the; sanitation functions in the taint configuration file (see; :doc:`user-docs/TaintAnalysisConfiguration`). .. code-block:: YAML. Filters:; - Name: sanitizeFileName; Args: [0]. The clang invocation to pass the configuration file location:. .. code-block:: bash. clang --analyze -Xclang -analyzer-config -Xclang alpha.security.taint.TaintPropagation:Config=`pwd`/taint_config.yml ... If you are validating your inputs instead of sanitizing them, or don't want to; mention each sanitizing function in our configuration,; you can use a more generic approach. Introduce a generic no-op `csa_mark_sanitized(..)` function to; tell the Clang Static Analyzer; that the variable is safe to be used on that analysis path. .. code-block:: c. // Marking sanitized variables safe.; // No vulnerability anymore, no warning. // User csa_mark_sanitize function is for the an",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:1698,Safety,predict,predictably,1698,"ault Checkers; ----------------. .. _core-checkers:. core; ^^^^; Models core language features and contains general-purpose checkers such as division by zero,; null pointer dereference, usage of uninitialized values, etc.; *These checkers must be always switched on as other checker rely on them.*. .. _core-BitwiseShift:. core.BitwiseShift (C, C++); """""""""""""""""""""""""""""""""""""""""""""""""""". Finds undefined behavior caused by the bitwise left- and right-shift operator; operating on integer types. By default, this checker only reports situations when the right operand is; either negative or larger than the bit width of the type of the left operand;; these are logically unsound. Moreover, if the pedantic mode is activated by; ``-analyzer-config core.BitwiseShift:Pedantic=true``, then this checker also; reports situations where the _left_ operand of a shift operator is negative or; overflow occurs during the right shift of a signed value. (Most compilers; handle these predictably, but the C standard and the C++ standards before C++20; say that they're undefined behavior. In the C++20 standard these constructs are; well-defined, so activating pedantic mode in C++20 has no effect.). **Examples**. .. code-block:: cpp. static_assert(sizeof(int) == 4, ""assuming 32-bit int""). void basic_examples(int a, int b) {; if (b < 0) {; b = a << b; // warn: right operand is negative in left shift; } else if (b >= 32) {; b = a >> b; // warn: right shift overflows the capacity of 'int'; }; }. int pedantic_examples(int a, int b) {; if (a < 0) {; return a >> b; // warn: left operand is negative in right shift; }; a = 1000u << 31; // OK, overflow of unsigned value is well-defined, a == 0; if (b > 10) {; a = b << 31; // this is undefined before C++20, but the checker doesn't; // warn because it doesn't know the exact value of b; }; return 1000 << 31; // warn: this overflows the capacity of 'int'; }. **Solution**. Ensure the shift operands are in proper range before shifting. .. _core-CallAndMessage:. core.Ca",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:25253,Safety,unsafe,unsafe,25253,"""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of inferior random number generating functions (only if arc4random function is available):; ``drand48, erand48, jrand48, lcong48, lrand48, mrand48, nrand48, random, rand_r``. .. code-block:: c. void test() {; random(); // warn; }. .. _security-insecureAPI-strcpy:. security.insecureAPI.strcpy (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the ``strcpy`` and ``strcat`` functions. .. code-block:: c. void test() {; char x[4];; char *y = ""abcd"";. strcpy(x, y); // warn; }. .. _security-insecureAPI-vfork:. security.insecureAPI.vfork (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'vfork' function. .. code-block:: c. void test() {; vfork(); // warn; }. .. _security-insecureAPI-DeprecatedOrUnsafeBufferHandling:. security.insecureAPI.DeprecatedOrUnsafeBufferHandling (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on occurrences of unsafe or deprecated buffer handling functions, which now have a secure variant: ``sprintf, fprintf, vsprintf, scanf, wscanf, fscanf, fwscanf, vscanf, vwscanf, vfscanf, vfwscanf, sscanf, swscanf, vsscanf, vswscanf, swprintf, snprintf, vswprintf, vsnprintf, memcpy, memmove, strncpy, strncat, memset``. .. code-block:: c. void test() {; char buf [5];; strncpy(buf, ""a"", 1); // warn; }. .. _unix-checkers:. unix; ^^^^; POSIX/Unix checkers. .. _unix-API:. unix.API (C); """"""""""""""""""""""""; Check calls to various UNIX/Posix functions: ``open, pthread_once, calloc, malloc, realloc, alloca``. .. literalinclude:: checkers/unix_api_example.c; :language: c. .. _unix-Errno:. unix.Errno (C); """""""""""""""""""""""""""". Check for improper use of ``errno``.; This checker implements partially CERT rule; `ERR30-C. Set errno to zero before calling a library function known to set errno,; and check errno only after the function returns a value indicating failure; <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152351>`_.; The checker can find the first read of ``errno`` after successful standard",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:28584,Safety,avoid,avoid,28584,"dition (in ``if`` statements,; loops, conditional expressions, ``switch`` statements). For example ``errno``; can be stored into a variable without getting a warning by the checker. .. code-block:: c. int unsafe_errno_read(int sock, void *data, int data_size) {; if (send(sock, data, data_size, 0) != data_size) {; int err = errno;; // warning if 'AllowErrnoReadOutsideConditionExpressions' is false; // no warning if 'AllowErrnoReadOutsideConditionExpressions' is true; }; return 1;; }. Default value of this option is ``true``. This allows save of the errno value; for possible later error handling. **Limitations**. - Only the very first usage of ``errno`` is checked after an affected function; call. Value of ``errno`` is not followed when it is stored into a variable; or returned from a function.; - Documentation of function ``lseek`` is not clear about what happens if the; function returns different value than the expected file position but not -1.; To avoid possible false-positives ``errno`` is allowed to be used in this; case. .. _unix-Malloc:. unix.Malloc (C); """"""""""""""""""""""""""""""; Check for memory leaks, double free, and use-after-free problems. Traces memory managed by malloc()/free(). .. literalinclude:: checkers/unix_malloc_example.c; :language: c. .. _unix-MallocSizeof:. unix.MallocSizeof (C); """"""""""""""""""""""""""""""""""""""""""; Check for dubious ``malloc`` arguments involving ``sizeof``. .. code-block:: c. void test() {; long *p = malloc(sizeof(short));; // warn: result is converted to 'long *', which is; // incompatible with operand type 'short'; free(p);; }. .. _unix-MismatchedDeallocator:. unix.MismatchedDeallocator (C, C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for mismatched deallocators. .. literalinclude:: checkers/mismatched_deallocator_example.cpp; :language: c. .. _unix-Vfork:. unix.Vfork (C); """"""""""""""""""""""""""""; Check for proper usage of ``vfork``. .. code-block:: c. int test(int x) {; pid_t pid = vfork(); // warn; if (pid != 0); return 0;. switch (x) {; case 0:; p",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:31895,Safety,detect,detect,31895,"epresentable; as ``unsigned char`` and is not equal to ``EOF``. You can think of this checker as defining restrictions (pre- and postconditions); on standard library functions. Preconditions are checked, and when they are; violated, a warning is emitted. Postconditions are added to the analysis, e.g.; that the return value of a function is not greater than 255. Preconditions are; added to the analysis too, in the case when the affected values are not known; before the call. For example, if an argument to a function must be in between 0 and 255, but the; value of the argument is unknown, the analyzer will assume that it is in this; interval. Similarly, if a function mustn't be called with a null pointer and the; analyzer cannot prove that it is null, then it will assume that it is non-null. These are the possible checks on the values passed as function arguments:; - The argument has an allowed range (or multiple ranges) of values. The checker; can detect if a passed value is outside of the allowed range and show the; actual and allowed values.; - The argument has pointer type and is not allowed to be null pointer. Many; (but not all) standard functions can produce undefined behavior if a null; pointer is passed, these cases can be detected by the checker.; - The argument is a pointer to a memory block and the minimal size of this; buffer is determined by another argument to the function, or by; multiplication of two arguments (like at function ``fread``), or is a fixed; value (for example ``asctime_r`` requires at least a buffer of size 26). The; checker can detect if the buffer size is too small and in optimal case show; the size of the buffer and the values of the corresponding arguments. .. code-block:: c. #define EOF -1; void test_alnum_concrete(int v) {; int ret = isalnum(256); // \; // warning: Function argument outside of allowed range; (void)ret;; }. void buffer_size_violation(FILE *file) {; enum { BUFFER_SIZE = 1024 };; wchar_t wbuf[BUFFER_SIZE];. const size_",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:32184,Safety,detect,detected,32184,", and when they are; violated, a warning is emitted. Postconditions are added to the analysis, e.g.; that the return value of a function is not greater than 255. Preconditions are; added to the analysis too, in the case when the affected values are not known; before the call. For example, if an argument to a function must be in between 0 and 255, but the; value of the argument is unknown, the analyzer will assume that it is in this; interval. Similarly, if a function mustn't be called with a null pointer and the; analyzer cannot prove that it is null, then it will assume that it is non-null. These are the possible checks on the values passed as function arguments:; - The argument has an allowed range (or multiple ranges) of values. The checker; can detect if a passed value is outside of the allowed range and show the; actual and allowed values.; - The argument has pointer type and is not allowed to be null pointer. Many; (but not all) standard functions can produce undefined behavior if a null; pointer is passed, these cases can be detected by the checker.; - The argument is a pointer to a memory block and the minimal size of this; buffer is determined by another argument to the function, or by; multiplication of two arguments (like at function ``fread``), or is a fixed; value (for example ``asctime_r`` requires at least a buffer of size 26). The; checker can detect if the buffer size is too small and in optimal case show; the size of the buffer and the values of the corresponding arguments. .. code-block:: c. #define EOF -1; void test_alnum_concrete(int v) {; int ret = isalnum(256); // \; // warning: Function argument outside of allowed range; (void)ret;; }. void buffer_size_violation(FILE *file) {; enum { BUFFER_SIZE = 1024 };; wchar_t wbuf[BUFFER_SIZE];. const size_t size = sizeof(*wbuf); // 4; const size_t nitems = sizeof(wbuf); // 4096. // Below we receive a warning because the 3rd parameter should be the; // number of elements to read, not the size in bytes. T",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:32518,Safety,detect,detect,32518,"erval. Similarly, if a function mustn't be called with a null pointer and the; analyzer cannot prove that it is null, then it will assume that it is non-null. These are the possible checks on the values passed as function arguments:; - The argument has an allowed range (or multiple ranges) of values. The checker; can detect if a passed value is outside of the allowed range and show the; actual and allowed values.; - The argument has pointer type and is not allowed to be null pointer. Many; (but not all) standard functions can produce undefined behavior if a null; pointer is passed, these cases can be detected by the checker.; - The argument is a pointer to a memory block and the minimal size of this; buffer is determined by another argument to the function, or by; multiplication of two arguments (like at function ``fread``), or is a fixed; value (for example ``asctime_r`` requires at least a buffer of size 26). The; checker can detect if the buffer size is too small and in optimal case show; the size of the buffer and the values of the corresponding arguments. .. code-block:: c. #define EOF -1; void test_alnum_concrete(int v) {; int ret = isalnum(256); // \; // warning: Function argument outside of allowed range; (void)ret;; }. void buffer_size_violation(FILE *file) {; enum { BUFFER_SIZE = 1024 };; wchar_t wbuf[BUFFER_SIZE];. const size_t size = sizeof(*wbuf); // 4; const size_t nitems = sizeof(wbuf); // 4096. // Below we receive a warning because the 3rd parameter should be the; // number of elements to read, not the size in bytes. This case is a known; // vulnerability described by the ARR38-C SEI-CERT rule.; fread(wbuf, size, nitems, file);; }. int test_alnum_symbolic(int x) {; int ret = isalnum(x);; // after the call, ret is assumed to be in the range [-1, 255]. if (ret > 255) // impossible (infeasible branch); if (x == 0); return ret / x; // division by zero is not reported; return ret;; }. Additionally to the argument and return value conditions, this checker ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:34479,Safety,detect,detect,34479,"reported; return ret;; }. Additionally to the argument and return value conditions, this checker also adds; state of the value ``errno`` if applicable to the analysis. Many system; functions set the ``errno`` value only if an error occurs (together with a; specific return value of the function), otherwise it becomes undefined. This; checker changes the analysis state to contain such information. This data is; used by other checkers, for example :ref:`unix-Errno`. **Limitations**. The checker can not always provide notes about the values of the arguments.; Without this information it is hard to confirm if the constraint is indeed; violated. The argument values are shown if they are known constants or the value; is determined by previous (not too complicated) assumptions. The checker can produce false positives in cases such as if the program has; invariants not known to the analyzer engine or the bug report path contains; calls to unknown functions. In these cases the analyzer fails to detect the real; range of the argument. **Parameters**. The checker models functions (and emits diagnostics) from the C standard by; default. The ``ModelPOSIX`` option enables modeling (and emit diagnostics) of; additional functions that are defined in the POSIX standard. This option is; disabled by default. .. _osx-checkers:. osx; ^^^; macOS checkers. .. _osx-API:. osx.API (C); """"""""""""""""""""""; Check for proper uses of various Apple APIs. .. code-block:: objc. void test() {; dispatch_once_t pred = 0;; dispatch_once(&pred, ^(){}); // warn: dispatch_once uses local; }. .. _osx-NumberObjectConversion:. osx.NumberObjectConversion (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for erroneous conversions of objects representing numbers into numbers. .. code-block:: objc. NSNumber *photoCount = [albumDescriptor objectForKey:@""PhotoCount""];; // Warning: Comparing a pointer value of type 'NSNumber *'; // to a scalar integer value; if (photoCount > 0) {; [self displayPhotos];; }. ..",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:67840,Safety,safe,safe,67840,":"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; strcat(cmd, filename);; system(cmd); // Warning: Untrusted data is passed to a system call; }. The program prints the content of any user specified file.; Unfortunately the attacker can execute arbitrary commands; with shell escapes. For example with the following input the `ls` command is also; executed after the contents of `/etc/shadow` is printed.; `Input: /etc/shadow ; ls /`. The analysis implemented in this checker points out this problem. One can protect against such attack by for example checking if the provided; input refers to a valid file and removing any invalid user input. .. code-block:: c. // No vulnerability anymore, but we still get the warning; void sanitizeFileName(char* filename){; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; filename[0]='\0';; }; }; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; sanitizeFileName(filename);// filename is safe after this point; if (!filename[0]); return -1;; strcat(cmd, filename);; system(cmd); // Superfluous Warning: Untrusted data is passed to a system call; }. Unfortunately, the checker cannot discover automatically that the programmer; have performed data sanitation, so it still emits the warning. One can get rid of this superfluous warning by telling by specifying the; sanitation functions in the taint configuration file (see; :doc:`user-docs/TaintAnalysisConfiguration`). .. code-block:: YAML. Filters:; - Name: sanitizeFileName; Args: [0]. The clang invocation to pass the configuration file location:. .. code-block:: bash. clang --analyze -Xclang -analyzer-config -Xclang alpha.security.taint.TaintPropagation:Config=`pwd`/taint_config.yml ... If you are validating your inputs instead of sanitizing them, or don't want to; mention each sanitizin",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:68886,Safety,safe,safe,68886,"lename[0]); return -1;; strcat(cmd, filename);; system(cmd); // Superfluous Warning: Untrusted data is passed to a system call; }. Unfortunately, the checker cannot discover automatically that the programmer; have performed data sanitation, so it still emits the warning. One can get rid of this superfluous warning by telling by specifying the; sanitation functions in the taint configuration file (see; :doc:`user-docs/TaintAnalysisConfiguration`). .. code-block:: YAML. Filters:; - Name: sanitizeFileName; Args: [0]. The clang invocation to pass the configuration file location:. .. code-block:: bash. clang --analyze -Xclang -analyzer-config -Xclang alpha.security.taint.TaintPropagation:Config=`pwd`/taint_config.yml ... If you are validating your inputs instead of sanitizing them, or don't want to; mention each sanitizing function in our configuration,; you can use a more generic approach. Introduce a generic no-op `csa_mark_sanitized(..)` function to; tell the Clang Static Analyzer; that the variable is safe to be used on that analysis path. .. code-block:: c. // Marking sanitized variables safe.; // No vulnerability anymore, no warning. // User csa_mark_sanitize function is for the analyzer only; #ifdef __clang_analyzer__; void csa_mark_sanitized(const void *);; #endif. int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename);; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; return -1;; }; #ifdef __clang_analyzer__; csa_mark_sanitized(filename); // Indicating to CSA that filename variable is safe to be used after this point; #endif; strcat(cmd, filename);; system(cmd); // No warning; }. Similarly to the previous example, you need to; define a `Filter` function in a `YAML` configuration file; and add the `csa_mark_sanitized` function. .. code-block:: YAML. Filters:; - Name: csa_mark_sanitized; Args: [0]. Then calling `csa_mark_sanitized(X)` will tel",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:68975,Safety,safe,safe,68975,"ted data is passed to a system call; }. Unfortunately, the checker cannot discover automatically that the programmer; have performed data sanitation, so it still emits the warning. One can get rid of this superfluous warning by telling by specifying the; sanitation functions in the taint configuration file (see; :doc:`user-docs/TaintAnalysisConfiguration`). .. code-block:: YAML. Filters:; - Name: sanitizeFileName; Args: [0]. The clang invocation to pass the configuration file location:. .. code-block:: bash. clang --analyze -Xclang -analyzer-config -Xclang alpha.security.taint.TaintPropagation:Config=`pwd`/taint_config.yml ... If you are validating your inputs instead of sanitizing them, or don't want to; mention each sanitizing function in our configuration,; you can use a more generic approach. Introduce a generic no-op `csa_mark_sanitized(..)` function to; tell the Clang Static Analyzer; that the variable is safe to be used on that analysis path. .. code-block:: c. // Marking sanitized variables safe.; // No vulnerability anymore, no warning. // User csa_mark_sanitize function is for the analyzer only; #ifdef __clang_analyzer__; void csa_mark_sanitized(const void *);; #endif. int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename);; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; return -1;; }; #ifdef __clang_analyzer__; csa_mark_sanitized(filename); // Indicating to CSA that filename variable is safe to be used after this point; #endif; strcat(cmd, filename);; system(cmd); // No warning; }. Similarly to the previous example, you need to; define a `Filter` function in a `YAML` configuration file; and add the `csa_mark_sanitized` function. .. code-block:: YAML. Filters:; - Name: csa_mark_sanitized; Args: [0]. Then calling `csa_mark_sanitized(X)` will tell the analyzer that `X` is safe to; be used after this point, because its contents are veri",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:69508,Safety,safe,safe,69508,"gs: [0]. The clang invocation to pass the configuration file location:. .. code-block:: bash. clang --analyze -Xclang -analyzer-config -Xclang alpha.security.taint.TaintPropagation:Config=`pwd`/taint_config.yml ... If you are validating your inputs instead of sanitizing them, or don't want to; mention each sanitizing function in our configuration,; you can use a more generic approach. Introduce a generic no-op `csa_mark_sanitized(..)` function to; tell the Clang Static Analyzer; that the variable is safe to be used on that analysis path. .. code-block:: c. // Marking sanitized variables safe.; // No vulnerability anymore, no warning. // User csa_mark_sanitize function is for the analyzer only; #ifdef __clang_analyzer__; void csa_mark_sanitized(const void *);; #endif. int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename);; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; return -1;; }; #ifdef __clang_analyzer__; csa_mark_sanitized(filename); // Indicating to CSA that filename variable is safe to be used after this point; #endif; strcat(cmd, filename);; system(cmd); // No warning; }. Similarly to the previous example, you need to; define a `Filter` function in a `YAML` configuration file; and add the `csa_mark_sanitized` function. .. code-block:: YAML. Filters:; - Name: csa_mark_sanitized; Args: [0]. Then calling `csa_mark_sanitized(X)` will tell the analyzer that `X` is safe to; be used after this point, because its contents are verified. It is the; responsibility of the programmer to ensure that this verification was indeed; correct. Please note that `csa_mark_sanitized` function is only declared and; used during Clang Static Analysis and skipped in (production) builds. Further examples of injection vulnerabilities this checker can find. .. code-block:: c. void test() {; char x = getchar(); // 'x' marked as tainted; system(&x); // warn: untrus",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:69898,Safety,safe,safe,69898," used on that analysis path. .. code-block:: c. // Marking sanitized variables safe.; // No vulnerability anymore, no warning. // User csa_mark_sanitize function is for the analyzer only; #ifdef __clang_analyzer__; void csa_mark_sanitized(const void *);; #endif. int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename);; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; return -1;; }; #ifdef __clang_analyzer__; csa_mark_sanitized(filename); // Indicating to CSA that filename variable is safe to be used after this point; #endif; strcat(cmd, filename);; system(cmd); // No warning; }. Similarly to the previous example, you need to; define a `Filter` function in a `YAML` configuration file; and add the `csa_mark_sanitized` function. .. code-block:: YAML. Filters:; - Name: csa_mark_sanitized; Args: [0]. Then calling `csa_mark_sanitized(X)` will tell the analyzer that `X` is safe to; be used after this point, because its contents are verified. It is the; responsibility of the programmer to ensure that this verification was indeed; correct. Please note that `csa_mark_sanitized` function is only declared and; used during Clang Static Analysis and skipped in (production) builds. Further examples of injection vulnerabilities this checker can find. .. code-block:: c. void test() {; char x = getchar(); // 'x' marked as tainted; system(&x); // warn: untrusted data is passed to a system call; }. // note: compiler internally checks if the second param to; // sprintf is a string literal or not.; // Use -Wno-format-security to suppress compiler warning.; void test() {; char s[10], buf[10];; fscanf(stdin, ""%s"", s); // 's' marked as tainted. sprintf(buf, s); // warn: untrusted data used as a format string; }. void test() {; size_t ts;; scanf(""%zd"", &ts); // 'ts' marked as tainted; int *p = (int *)malloc(ts * sizeof(int));; // warn: untrusted data used as buffer size;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:78716,Safety,detect,detect,78716,"lose(p);; }. .. _alpha-unix-cstring-BufferOverlap:. alpha.unix.cstring.BufferOverlap (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Checks for overlap in two buffer arguments. Applies to: ``memcpy, mempcpy, wmemcpy, wmempcpy``. .. code-block:: c. void test() {; int a[4] = {0};; memcpy(a + 2, a + 1, 8); // warn; }. .. _alpha-unix-cstring-NotNullTerminated:. alpha.unix.cstring.NotNullTerminated (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for arguments which are not null-terminated strings; applies to: ``strlen, strnlen, strcpy, strncpy, strcat, strncat, wcslen, wcsnlen``. .. code-block:: c. void test() {; int y = strlen((char *)&test); // warn; }. .. _alpha-unix-cstring-OutOfBounds:. alpha.unix.cstring.OutOfBounds (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for out-of-bounds access in string functions, such as:; ``memcpy, bcopy, strcpy, strncpy, strcat, strncat, memmove, memcmp, memset`` and more. This check also works with string literals, except there is a known bug in that; the analyzer cannot detect embedded NULL characters when determining the string length. .. code-block:: c. void test1() {; const char str[] = ""Hello world"";; char buffer[] = ""Hello world"";; memcpy(buffer, str, sizeof(str) + 1); // warn; }. void test2() {; const char str[] = ""Hello world"";; char buffer[] = ""Helloworld"";; memcpy(buffer, str, sizeof(str)); // warn; }. .. _alpha-unix-cstring-UninitializedRead:. alpha.unix.cstring.UninitializedRead (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for uninitialized reads from common memory copy/manipulation functions such as:; ``memcpy, mempcpy, memmove, memcmp, strcmp, strncmp, strcpy, strlen, strsep`` and many more. .. code-block:: c. void test() {; char src[10];; char dst[5];; memcpy(dst,src,sizeof(dst)); // warn: Bytes string function accesses uninitialized/garbage values; }. Limitations:. - Due to limitations of the memory modeling in the analyzer, one can likely; observe a lot of false-positive reports like this:. .. code-block:: c. v",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:81431,Safety,unsafe,unsafe,81431,"rdered_set<int *> UnorderedPtrSet = {&a, &b};. for (auto i : UnorderedPtrSet) // warn; f(i);; }. .. _alpha-nondeterminism-PointerSorting:. alpha.nondeterminism.PointerSorting (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for non-determinism caused by sorting of pointers. .. code-block:: c. void test() {; int a = 1, b = 2;; std::vector<int *> V = {&a, &b};; std::sort(V.begin(), V.end()); // warn; }. alpha.WebKit; ^^^^^^^^^^^^. .. _alpha-webkit-UncountedCallArgsChecker:. alpha.webkit.UncountedCallArgsChecker; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; The goal of this rule is to make sure that lifetime of any dynamically allocated ref-countable object passed as a call argument spans past the end of the call. This applies to call to any function, method, lambda, function pointer or functor. Ref-countable types aren't supposed to be allocated on stack so we check arguments for parameters of raw pointers and references to uncounted types. Here are some examples of situations that we warn about as they *might* be potentially unsafe. The logic is that either we're able to guarantee that an argument is safe or it's considered if not a bug then bug-prone. .. code-block:: cpp. RefCountable* provide_uncounted();; void consume(RefCountable*);. // In these cases we can't make sure callee won't directly or indirectly call `deref()` on the argument which could make it unsafe from such point until the end of the call. void foo1() {; consume(provide_uncounted()); // warn; }. void foo2() {; RefCountable* uncounted = provide_uncounted();; consume(uncounted); // warn; }. Although we are enforcing member variables to be ref-counted by `webkit.NoUncountedMemberChecker` any method of the same class still has unrestricted access to these. Since from a caller's perspective we can't guarantee a particular member won't get modified by callee (directly or indirectly) we don't consider values obtained from members safe. Note: It's likely this heuristic could be made more precise with fewer",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:81508,Safety,safe,safe,81508,"ndeterminism-PointerSorting:. alpha.nondeterminism.PointerSorting (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for non-determinism caused by sorting of pointers. .. code-block:: c. void test() {; int a = 1, b = 2;; std::vector<int *> V = {&a, &b};; std::sort(V.begin(), V.end()); // warn; }. alpha.WebKit; ^^^^^^^^^^^^. .. _alpha-webkit-UncountedCallArgsChecker:. alpha.webkit.UncountedCallArgsChecker; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; The goal of this rule is to make sure that lifetime of any dynamically allocated ref-countable object passed as a call argument spans past the end of the call. This applies to call to any function, method, lambda, function pointer or functor. Ref-countable types aren't supposed to be allocated on stack so we check arguments for parameters of raw pointers and references to uncounted types. Here are some examples of situations that we warn about as they *might* be potentially unsafe. The logic is that either we're able to guarantee that an argument is safe or it's considered if not a bug then bug-prone. .. code-block:: cpp. RefCountable* provide_uncounted();; void consume(RefCountable*);. // In these cases we can't make sure callee won't directly or indirectly call `deref()` on the argument which could make it unsafe from such point until the end of the call. void foo1() {; consume(provide_uncounted()); // warn; }. void foo2() {; RefCountable* uncounted = provide_uncounted();; consume(uncounted); // warn; }. Although we are enforcing member variables to be ref-counted by `webkit.NoUncountedMemberChecker` any method of the same class still has unrestricted access to these. Since from a caller's perspective we can't guarantee a particular member won't get modified by callee (directly or indirectly) we don't consider values obtained from members safe. Note: It's likely this heuristic could be made more precise with fewer false positives - for example calls to free functions that don't have any parameter other than the pointer ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:81772,Safety,unsafe,unsafe,81772,"or<int *> V = {&a, &b};; std::sort(V.begin(), V.end()); // warn; }. alpha.WebKit; ^^^^^^^^^^^^. .. _alpha-webkit-UncountedCallArgsChecker:. alpha.webkit.UncountedCallArgsChecker; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; The goal of this rule is to make sure that lifetime of any dynamically allocated ref-countable object passed as a call argument spans past the end of the call. This applies to call to any function, method, lambda, function pointer or functor. Ref-countable types aren't supposed to be allocated on stack so we check arguments for parameters of raw pointers and references to uncounted types. Here are some examples of situations that we warn about as they *might* be potentially unsafe. The logic is that either we're able to guarantee that an argument is safe or it's considered if not a bug then bug-prone. .. code-block:: cpp. RefCountable* provide_uncounted();; void consume(RefCountable*);. // In these cases we can't make sure callee won't directly or indirectly call `deref()` on the argument which could make it unsafe from such point until the end of the call. void foo1() {; consume(provide_uncounted()); // warn; }. void foo2() {; RefCountable* uncounted = provide_uncounted();; consume(uncounted); // warn; }. Although we are enforcing member variables to be ref-counted by `webkit.NoUncountedMemberChecker` any method of the same class still has unrestricted access to these. Since from a caller's perspective we can't guarantee a particular member won't get modified by callee (directly or indirectly) we don't consider values obtained from members safe. Note: It's likely this heuristic could be made more precise with fewer false positives - for example calls to free functions that don't have any parameter other than the pointer should be safe as the callee won't be able to tamper with the member unless it's a global variable. .. code-block:: cpp. struct Foo {; RefPtr<RefCountable> member;; void consume(RefCountable*) { /* ... */ }; void bugprone() {; consume(",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:82315,Safety,safe,safe,82315, to be allocated on stack so we check arguments for parameters of raw pointers and references to uncounted types. Here are some examples of situations that we warn about as they *might* be potentially unsafe. The logic is that either we're able to guarantee that an argument is safe or it's considered if not a bug then bug-prone. .. code-block:: cpp. RefCountable* provide_uncounted();; void consume(RefCountable*);. // In these cases we can't make sure callee won't directly or indirectly call `deref()` on the argument which could make it unsafe from such point until the end of the call. void foo1() {; consume(provide_uncounted()); // warn; }. void foo2() {; RefCountable* uncounted = provide_uncounted();; consume(uncounted); // warn; }. Although we are enforcing member variables to be ref-counted by `webkit.NoUncountedMemberChecker` any method of the same class still has unrestricted access to these. Since from a caller's perspective we can't guarantee a particular member won't get modified by callee (directly or indirectly) we don't consider values obtained from members safe. Note: It's likely this heuristic could be made more precise with fewer false positives - for example calls to free functions that don't have any parameter other than the pointer should be safe as the callee won't be able to tamper with the member unless it's a global variable. .. code-block:: cpp. struct Foo {; RefPtr<RefCountable> member;; void consume(RefCountable*) { /* ... */ }; void bugprone() {; consume(member.get()); // warn; }; };. The implementation of this rule is a heuristic - we define a whitelist of kinds of values that are considered safe to be passed as arguments. If we can't prove an argument is safe it's considered an error. Allowed kinds of arguments:. - values obtained from ref-counted objects (including temporaries as those survive the call too). .. code-block:: cpp. RefCountable* provide_uncounted();; void consume(RefCountable*);. void foo() {; RefPtr<RefCountable> rc = makeR,MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:82509,Safety,safe,safe,82509,ther we're able to guarantee that an argument is safe or it's considered if not a bug then bug-prone. .. code-block:: cpp. RefCountable* provide_uncounted();; void consume(RefCountable*);. // In these cases we can't make sure callee won't directly or indirectly call `deref()` on the argument which could make it unsafe from such point until the end of the call. void foo1() {; consume(provide_uncounted()); // warn; }. void foo2() {; RefCountable* uncounted = provide_uncounted();; consume(uncounted); // warn; }. Although we are enforcing member variables to be ref-counted by `webkit.NoUncountedMemberChecker` any method of the same class still has unrestricted access to these. Since from a caller's perspective we can't guarantee a particular member won't get modified by callee (directly or indirectly) we don't consider values obtained from members safe. Note: It's likely this heuristic could be made more precise with fewer false positives - for example calls to free functions that don't have any parameter other than the pointer should be safe as the callee won't be able to tamper with the member unless it's a global variable. .. code-block:: cpp. struct Foo {; RefPtr<RefCountable> member;; void consume(RefCountable*) { /* ... */ }; void bugprone() {; consume(member.get()); // warn; }; };. The implementation of this rule is a heuristic - we define a whitelist of kinds of values that are considered safe to be passed as arguments. If we can't prove an argument is safe it's considered an error. Allowed kinds of arguments:. - values obtained from ref-counted objects (including temporaries as those survive the call too). .. code-block:: cpp. RefCountable* provide_uncounted();; void consume(RefCountable*);. void foo() {; RefPtr<RefCountable> rc = makeRef(provide_uncounted());; consume(rc.get()); // ok; consume(makeRef(provide_uncounted()).get()); // ok; }. - forwarding uncounted arguments from caller to callee. .. code-block:: cpp. void foo(RefCountable& a) {; bar(a); // ok; },MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:82875,Safety,safe,safe,82875,"; consume(provide_uncounted()); // warn; }. void foo2() {; RefCountable* uncounted = provide_uncounted();; consume(uncounted); // warn; }. Although we are enforcing member variables to be ref-counted by `webkit.NoUncountedMemberChecker` any method of the same class still has unrestricted access to these. Since from a caller's perspective we can't guarantee a particular member won't get modified by callee (directly or indirectly) we don't consider values obtained from members safe. Note: It's likely this heuristic could be made more precise with fewer false positives - for example calls to free functions that don't have any parameter other than the pointer should be safe as the callee won't be able to tamper with the member unless it's a global variable. .. code-block:: cpp. struct Foo {; RefPtr<RefCountable> member;; void consume(RefCountable*) { /* ... */ }; void bugprone() {; consume(member.get()); // warn; }; };. The implementation of this rule is a heuristic - we define a whitelist of kinds of values that are considered safe to be passed as arguments. If we can't prove an argument is safe it's considered an error. Allowed kinds of arguments:. - values obtained from ref-counted objects (including temporaries as those survive the call too). .. code-block:: cpp. RefCountable* provide_uncounted();; void consume(RefCountable*);. void foo() {; RefPtr<RefCountable> rc = makeRef(provide_uncounted());; consume(rc.get()); // ok; consume(makeRef(provide_uncounted()).get()); // ok; }. - forwarding uncounted arguments from caller to callee. .. code-block:: cpp. void foo(RefCountable& a) {; bar(a); // ok; }. Caller of ``foo()`` is responsible for ``a``'s lifetime. - ``this`` pointer. .. code-block:: cpp. void Foo::foo() {; baz(this); // ok; }. Caller of ``foo()`` is responsible for keeping the memory pointed to by ``this`` pointer safe. - constants. .. code-block:: cpp. foo(nullptr, NULL, 0); // ok. We also define a set of safe transformations which if passed a safe value as ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:82940,Safety,safe,safe,82940,");; consume(uncounted); // warn; }. Although we are enforcing member variables to be ref-counted by `webkit.NoUncountedMemberChecker` any method of the same class still has unrestricted access to these. Since from a caller's perspective we can't guarantee a particular member won't get modified by callee (directly or indirectly) we don't consider values obtained from members safe. Note: It's likely this heuristic could be made more precise with fewer false positives - for example calls to free functions that don't have any parameter other than the pointer should be safe as the callee won't be able to tamper with the member unless it's a global variable. .. code-block:: cpp. struct Foo {; RefPtr<RefCountable> member;; void consume(RefCountable*) { /* ... */ }; void bugprone() {; consume(member.get()); // warn; }; };. The implementation of this rule is a heuristic - we define a whitelist of kinds of values that are considered safe to be passed as arguments. If we can't prove an argument is safe it's considered an error. Allowed kinds of arguments:. - values obtained from ref-counted objects (including temporaries as those survive the call too). .. code-block:: cpp. RefCountable* provide_uncounted();; void consume(RefCountable*);. void foo() {; RefPtr<RefCountable> rc = makeRef(provide_uncounted());; consume(rc.get()); // ok; consume(makeRef(provide_uncounted()).get()); // ok; }. - forwarding uncounted arguments from caller to callee. .. code-block:: cpp. void foo(RefCountable& a) {; bar(a); // ok; }. Caller of ``foo()`` is responsible for ``a``'s lifetime. - ``this`` pointer. .. code-block:: cpp. void Foo::foo() {; baz(this); // ok; }. Caller of ``foo()`` is responsible for keeping the memory pointed to by ``this`` pointer safe. - constants. .. code-block:: cpp. foo(nullptr, NULL, 0); // ok. We also define a set of safe transformations which if passed a safe value as an input provide (usually it's the return value) a safe value (or an object that provides safe values).",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:83688,Safety,safe,safe,83688,"ountable> member;; void consume(RefCountable*) { /* ... */ }; void bugprone() {; consume(member.get()); // warn; }; };. The implementation of this rule is a heuristic - we define a whitelist of kinds of values that are considered safe to be passed as arguments. If we can't prove an argument is safe it's considered an error. Allowed kinds of arguments:. - values obtained from ref-counted objects (including temporaries as those survive the call too). .. code-block:: cpp. RefCountable* provide_uncounted();; void consume(RefCountable*);. void foo() {; RefPtr<RefCountable> rc = makeRef(provide_uncounted());; consume(rc.get()); // ok; consume(makeRef(provide_uncounted()).get()); // ok; }. - forwarding uncounted arguments from caller to callee. .. code-block:: cpp. void foo(RefCountable& a) {; bar(a); // ok; }. Caller of ``foo()`` is responsible for ``a``'s lifetime. - ``this`` pointer. .. code-block:: cpp. void Foo::foo() {; baz(this); // ok; }. Caller of ``foo()`` is responsible for keeping the memory pointed to by ``this`` pointer safe. - constants. .. code-block:: cpp. foo(nullptr, NULL, 0); // ok. We also define a set of safe transformations which if passed a safe value as an input provide (usually it's the return value) a safe value (or an object that provides safe values). This is also a heuristic. - constructors of ref-counted types (including factory methods); - getters of ref-counted types; - member overloaded operators; - casts; - unary operators like ``&`` or ``*``. alpha.webkit.UncountedLocalVarsChecker; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; The goal of this rule is to make sure that any uncounted local variable is backed by a ref-counted object with lifetime that is strictly larger than the scope of the uncounted local variable. To be on the safe side we require the scope of an uncounted variable to be embedded in the scope of ref-counted object that backs it. These are examples of cases that we consider safe:. .. code-block:: cpp. void foo1() {; RefPtr<RefC",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:83782,Safety,safe,safe,83782," values that are considered safe to be passed as arguments. If we can't prove an argument is safe it's considered an error. Allowed kinds of arguments:. - values obtained from ref-counted objects (including temporaries as those survive the call too). .. code-block:: cpp. RefCountable* provide_uncounted();; void consume(RefCountable*);. void foo() {; RefPtr<RefCountable> rc = makeRef(provide_uncounted());; consume(rc.get()); // ok; consume(makeRef(provide_uncounted()).get()); // ok; }. - forwarding uncounted arguments from caller to callee. .. code-block:: cpp. void foo(RefCountable& a) {; bar(a); // ok; }. Caller of ``foo()`` is responsible for ``a``'s lifetime. - ``this`` pointer. .. code-block:: cpp. void Foo::foo() {; baz(this); // ok; }. Caller of ``foo()`` is responsible for keeping the memory pointed to by ``this`` pointer safe. - constants. .. code-block:: cpp. foo(nullptr, NULL, 0); // ok. We also define a set of safe transformations which if passed a safe value as an input provide (usually it's the return value) a safe value (or an object that provides safe values). This is also a heuristic. - constructors of ref-counted types (including factory methods); - getters of ref-counted types; - member overloaded operators; - casts; - unary operators like ``&`` or ``*``. alpha.webkit.UncountedLocalVarsChecker; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; The goal of this rule is to make sure that any uncounted local variable is backed by a ref-counted object with lifetime that is strictly larger than the scope of the uncounted local variable. To be on the safe side we require the scope of an uncounted variable to be embedded in the scope of ref-counted object that backs it. These are examples of cases that we consider safe:. .. code-block:: cpp. void foo1() {; RefPtr<RefCountable> counted;; // The scope of uncounted is EMBEDDED in the scope of counted.; {; RefCountable* uncounted = counted.get(); // ok; }; }. void foo2(RefPtr<RefCountable> counted_param) {; RefCountable",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:83821,Safety,safe,safe,83821," values that are considered safe to be passed as arguments. If we can't prove an argument is safe it's considered an error. Allowed kinds of arguments:. - values obtained from ref-counted objects (including temporaries as those survive the call too). .. code-block:: cpp. RefCountable* provide_uncounted();; void consume(RefCountable*);. void foo() {; RefPtr<RefCountable> rc = makeRef(provide_uncounted());; consume(rc.get()); // ok; consume(makeRef(provide_uncounted()).get()); // ok; }. - forwarding uncounted arguments from caller to callee. .. code-block:: cpp. void foo(RefCountable& a) {; bar(a); // ok; }. Caller of ``foo()`` is responsible for ``a``'s lifetime. - ``this`` pointer. .. code-block:: cpp. void Foo::foo() {; baz(this); // ok; }. Caller of ``foo()`` is responsible for keeping the memory pointed to by ``this`` pointer safe. - constants. .. code-block:: cpp. foo(nullptr, NULL, 0); // ok. We also define a set of safe transformations which if passed a safe value as an input provide (usually it's the return value) a safe value (or an object that provides safe values). This is also a heuristic. - constructors of ref-counted types (including factory methods); - getters of ref-counted types; - member overloaded operators; - casts; - unary operators like ``&`` or ``*``. alpha.webkit.UncountedLocalVarsChecker; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; The goal of this rule is to make sure that any uncounted local variable is backed by a ref-counted object with lifetime that is strictly larger than the scope of the uncounted local variable. To be on the safe side we require the scope of an uncounted variable to be embedded in the scope of ref-counted object that backs it. These are examples of cases that we consider safe:. .. code-block:: cpp. void foo1() {; RefPtr<RefCountable> counted;; // The scope of uncounted is EMBEDDED in the scope of counted.; {; RefCountable* uncounted = counted.get(); // ok; }; }. void foo2(RefPtr<RefCountable> counted_param) {; RefCountable",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:83886,Safety,safe,safe,83886," values that are considered safe to be passed as arguments. If we can't prove an argument is safe it's considered an error. Allowed kinds of arguments:. - values obtained from ref-counted objects (including temporaries as those survive the call too). .. code-block:: cpp. RefCountable* provide_uncounted();; void consume(RefCountable*);. void foo() {; RefPtr<RefCountable> rc = makeRef(provide_uncounted());; consume(rc.get()); // ok; consume(makeRef(provide_uncounted()).get()); // ok; }. - forwarding uncounted arguments from caller to callee. .. code-block:: cpp. void foo(RefCountable& a) {; bar(a); // ok; }. Caller of ``foo()`` is responsible for ``a``'s lifetime. - ``this`` pointer. .. code-block:: cpp. void Foo::foo() {; baz(this); // ok; }. Caller of ``foo()`` is responsible for keeping the memory pointed to by ``this`` pointer safe. - constants. .. code-block:: cpp. foo(nullptr, NULL, 0); // ok. We also define a set of safe transformations which if passed a safe value as an input provide (usually it's the return value) a safe value (or an object that provides safe values). This is also a heuristic. - constructors of ref-counted types (including factory methods); - getters of ref-counted types; - member overloaded operators; - casts; - unary operators like ``&`` or ``*``. alpha.webkit.UncountedLocalVarsChecker; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; The goal of this rule is to make sure that any uncounted local variable is backed by a ref-counted object with lifetime that is strictly larger than the scope of the uncounted local variable. To be on the safe side we require the scope of an uncounted variable to be embedded in the scope of ref-counted object that backs it. These are examples of cases that we consider safe:. .. code-block:: cpp. void foo1() {; RefPtr<RefCountable> counted;; // The scope of uncounted is EMBEDDED in the scope of counted.; {; RefCountable* uncounted = counted.get(); // ok; }; }. void foo2(RefPtr<RefCountable> counted_param) {; RefCountable",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:83925,Safety,safe,safe,83925," values that are considered safe to be passed as arguments. If we can't prove an argument is safe it's considered an error. Allowed kinds of arguments:. - values obtained from ref-counted objects (including temporaries as those survive the call too). .. code-block:: cpp. RefCountable* provide_uncounted();; void consume(RefCountable*);. void foo() {; RefPtr<RefCountable> rc = makeRef(provide_uncounted());; consume(rc.get()); // ok; consume(makeRef(provide_uncounted()).get()); // ok; }. - forwarding uncounted arguments from caller to callee. .. code-block:: cpp. void foo(RefCountable& a) {; bar(a); // ok; }. Caller of ``foo()`` is responsible for ``a``'s lifetime. - ``this`` pointer. .. code-block:: cpp. void Foo::foo() {; baz(this); // ok; }. Caller of ``foo()`` is responsible for keeping the memory pointed to by ``this`` pointer safe. - constants. .. code-block:: cpp. foo(nullptr, NULL, 0); // ok. We also define a set of safe transformations which if passed a safe value as an input provide (usually it's the return value) a safe value (or an object that provides safe values). This is also a heuristic. - constructors of ref-counted types (including factory methods); - getters of ref-counted types; - member overloaded operators; - casts; - unary operators like ``&`` or ``*``. alpha.webkit.UncountedLocalVarsChecker; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; The goal of this rule is to make sure that any uncounted local variable is backed by a ref-counted object with lifetime that is strictly larger than the scope of the uncounted local variable. To be on the safe side we require the scope of an uncounted variable to be embedded in the scope of ref-counted object that backs it. These are examples of cases that we consider safe:. .. code-block:: cpp. void foo1() {; RefPtr<RefCountable> counted;; // The scope of uncounted is EMBEDDED in the scope of counted.; {; RefCountable* uncounted = counted.get(); // ok; }; }. void foo2(RefPtr<RefCountable> counted_param) {; RefCountable",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:84426,Safety,safe,safe,84426,"` is responsible for ``a``'s lifetime. - ``this`` pointer. .. code-block:: cpp. void Foo::foo() {; baz(this); // ok; }. Caller of ``foo()`` is responsible for keeping the memory pointed to by ``this`` pointer safe. - constants. .. code-block:: cpp. foo(nullptr, NULL, 0); // ok. We also define a set of safe transformations which if passed a safe value as an input provide (usually it's the return value) a safe value (or an object that provides safe values). This is also a heuristic. - constructors of ref-counted types (including factory methods); - getters of ref-counted types; - member overloaded operators; - casts; - unary operators like ``&`` or ``*``. alpha.webkit.UncountedLocalVarsChecker; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; The goal of this rule is to make sure that any uncounted local variable is backed by a ref-counted object with lifetime that is strictly larger than the scope of the uncounted local variable. To be on the safe side we require the scope of an uncounted variable to be embedded in the scope of ref-counted object that backs it. These are examples of cases that we consider safe:. .. code-block:: cpp. void foo1() {; RefPtr<RefCountable> counted;; // The scope of uncounted is EMBEDDED in the scope of counted.; {; RefCountable* uncounted = counted.get(); // ok; }; }. void foo2(RefPtr<RefCountable> counted_param) {; RefCountable* uncounted = counted_param.get(); // ok; }. void FooClass::foo_method() {; RefCountable* uncounted = this; // ok; }. Here are some examples of situations that we warn about as they *might* be potentially unsafe. The logic is that either we're able to guarantee that an argument is safe or it's considered if not a bug then bug-prone. .. code-block:: cpp. void foo1() {; RefCountable* uncounted = new RefCountable; // warn; }. RefCountable* global_uncounted;; void foo2() {; RefCountable* uncounted = global_uncounted; // warn; }. void foo3() {; RefPtr<RefCountable> counted;; // The scope of uncounted is not EMBEDDED in the scope",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:84592,Safety,safe,safe,84592,"() {; baz(this); // ok; }. Caller of ``foo()`` is responsible for keeping the memory pointed to by ``this`` pointer safe. - constants. .. code-block:: cpp. foo(nullptr, NULL, 0); // ok. We also define a set of safe transformations which if passed a safe value as an input provide (usually it's the return value) a safe value (or an object that provides safe values). This is also a heuristic. - constructors of ref-counted types (including factory methods); - getters of ref-counted types; - member overloaded operators; - casts; - unary operators like ``&`` or ``*``. alpha.webkit.UncountedLocalVarsChecker; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; The goal of this rule is to make sure that any uncounted local variable is backed by a ref-counted object with lifetime that is strictly larger than the scope of the uncounted local variable. To be on the safe side we require the scope of an uncounted variable to be embedded in the scope of ref-counted object that backs it. These are examples of cases that we consider safe:. .. code-block:: cpp. void foo1() {; RefPtr<RefCountable> counted;; // The scope of uncounted is EMBEDDED in the scope of counted.; {; RefCountable* uncounted = counted.get(); // ok; }; }. void foo2(RefPtr<RefCountable> counted_param) {; RefCountable* uncounted = counted_param.get(); // ok; }. void FooClass::foo_method() {; RefCountable* uncounted = this; // ok; }. Here are some examples of situations that we warn about as they *might* be potentially unsafe. The logic is that either we're able to guarantee that an argument is safe or it's considered if not a bug then bug-prone. .. code-block:: cpp. void foo1() {; RefCountable* uncounted = new RefCountable; // warn; }. RefCountable* global_uncounted;; void foo2() {; RefCountable* uncounted = global_uncounted; // warn; }. void foo3() {; RefPtr<RefCountable> counted;; // The scope of uncounted is not EMBEDDED in the scope of counted.; RefCountable* uncounted = counted.get(); // warn; }. We don't warn about these ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:85053,Safety,unsafe,unsafe,85053,"factory methods); - getters of ref-counted types; - member overloaded operators; - casts; - unary operators like ``&`` or ``*``. alpha.webkit.UncountedLocalVarsChecker; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; The goal of this rule is to make sure that any uncounted local variable is backed by a ref-counted object with lifetime that is strictly larger than the scope of the uncounted local variable. To be on the safe side we require the scope of an uncounted variable to be embedded in the scope of ref-counted object that backs it. These are examples of cases that we consider safe:. .. code-block:: cpp. void foo1() {; RefPtr<RefCountable> counted;; // The scope of uncounted is EMBEDDED in the scope of counted.; {; RefCountable* uncounted = counted.get(); // ok; }; }. void foo2(RefPtr<RefCountable> counted_param) {; RefCountable* uncounted = counted_param.get(); // ok; }. void FooClass::foo_method() {; RefCountable* uncounted = this; // ok; }. Here are some examples of situations that we warn about as they *might* be potentially unsafe. The logic is that either we're able to guarantee that an argument is safe or it's considered if not a bug then bug-prone. .. code-block:: cpp. void foo1() {; RefCountable* uncounted = new RefCountable; // warn; }. RefCountable* global_uncounted;; void foo2() {; RefCountable* uncounted = global_uncounted; // warn; }. void foo3() {; RefPtr<RefCountable> counted;; // The scope of uncounted is not EMBEDDED in the scope of counted.; RefCountable* uncounted = counted.get(); // warn; }. We don't warn about these cases - we don't consider them necessarily safe but since they are very common and usually safe we'd introduce a lot of false positives otherwise:; - variable defined in condition part of an ```if``` statement; - variable defined in init statement condition of a ```for``` statement. For the time being we also don't warn about uninitialized uncounted local variables. Debug Checkers; ---------------. .. _debug-checkers:. debug; ^^^^^. Chec",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:85130,Safety,safe,safe,85130,"ike ``&`` or ``*``. alpha.webkit.UncountedLocalVarsChecker; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; The goal of this rule is to make sure that any uncounted local variable is backed by a ref-counted object with lifetime that is strictly larger than the scope of the uncounted local variable. To be on the safe side we require the scope of an uncounted variable to be embedded in the scope of ref-counted object that backs it. These are examples of cases that we consider safe:. .. code-block:: cpp. void foo1() {; RefPtr<RefCountable> counted;; // The scope of uncounted is EMBEDDED in the scope of counted.; {; RefCountable* uncounted = counted.get(); // ok; }; }. void foo2(RefPtr<RefCountable> counted_param) {; RefCountable* uncounted = counted_param.get(); // ok; }. void FooClass::foo_method() {; RefCountable* uncounted = this; // ok; }. Here are some examples of situations that we warn about as they *might* be potentially unsafe. The logic is that either we're able to guarantee that an argument is safe or it's considered if not a bug then bug-prone. .. code-block:: cpp. void foo1() {; RefCountable* uncounted = new RefCountable; // warn; }. RefCountable* global_uncounted;; void foo2() {; RefCountable* uncounted = global_uncounted; // warn; }. void foo3() {; RefPtr<RefCountable> counted;; // The scope of uncounted is not EMBEDDED in the scope of counted.; RefCountable* uncounted = counted.get(); // warn; }. We don't warn about these cases - we don't consider them necessarily safe but since they are very common and usually safe we'd introduce a lot of false positives otherwise:; - variable defined in condition part of an ```if``` statement; - variable defined in init statement condition of a ```for``` statement. For the time being we also don't warn about uninitialized uncounted local variables. Debug Checkers; ---------------. .. _debug-checkers:. debug; ^^^^^. Checkers used for debugging the analyzer.; :doc:`developer-docs/DebugChecks` page contains a detailed descriptio",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:85615,Safety,safe,safe,85615,"DED in the scope of counted.; {; RefCountable* uncounted = counted.get(); // ok; }; }. void foo2(RefPtr<RefCountable> counted_param) {; RefCountable* uncounted = counted_param.get(); // ok; }. void FooClass::foo_method() {; RefCountable* uncounted = this; // ok; }. Here are some examples of situations that we warn about as they *might* be potentially unsafe. The logic is that either we're able to guarantee that an argument is safe or it's considered if not a bug then bug-prone. .. code-block:: cpp. void foo1() {; RefCountable* uncounted = new RefCountable; // warn; }. RefCountable* global_uncounted;; void foo2() {; RefCountable* uncounted = global_uncounted; // warn; }. void foo3() {; RefPtr<RefCountable> counted;; // The scope of uncounted is not EMBEDDED in the scope of counted.; RefCountable* uncounted = counted.get(); // warn; }. We don't warn about these cases - we don't consider them necessarily safe but since they are very common and usually safe we'd introduce a lot of false positives otherwise:; - variable defined in condition part of an ```if``` statement; - variable defined in init statement condition of a ```for``` statement. For the time being we also don't warn about uninitialized uncounted local variables. Debug Checkers; ---------------. .. _debug-checkers:. debug; ^^^^^. Checkers used for debugging the analyzer.; :doc:`developer-docs/DebugChecks` page contains a detailed description. .. _debug-AnalysisOrder:. debug.AnalysisOrder; """"""""""""""""""""""""""""""""""""""; Print callbacks that are called during analysis in order. .. _debug-ConfigDumper:. debug.ConfigDumper; """"""""""""""""""""""""""""""""""""; Dump config table. .. _debug-DumpCFG Display:. debug.DumpCFG Display; """"""""""""""""""""""""""""""""""""""""""; Control-Flow Graphs. .. _debug-DumpCallGraph:. debug.DumpCallGraph; """"""""""""""""""""""""""""""""""""""; Display Call Graph. .. _debug-DumpCalls:. debug.DumpCalls; """"""""""""""""""""""""""""""; Print calls as they are traversed by the engine. .. _debug-DumpDominators:. debug.DumpDominators; """"""""""""""""""""""""""""""""""""""""; Print t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:85663,Safety,safe,safe,85663,"DED in the scope of counted.; {; RefCountable* uncounted = counted.get(); // ok; }; }. void foo2(RefPtr<RefCountable> counted_param) {; RefCountable* uncounted = counted_param.get(); // ok; }. void FooClass::foo_method() {; RefCountable* uncounted = this; // ok; }. Here are some examples of situations that we warn about as they *might* be potentially unsafe. The logic is that either we're able to guarantee that an argument is safe or it's considered if not a bug then bug-prone. .. code-block:: cpp. void foo1() {; RefCountable* uncounted = new RefCountable; // warn; }. RefCountable* global_uncounted;; void foo2() {; RefCountable* uncounted = global_uncounted; // warn; }. void foo3() {; RefPtr<RefCountable> counted;; // The scope of uncounted is not EMBEDDED in the scope of counted.; RefCountable* uncounted = counted.get(); // warn; }. We don't warn about these cases - we don't consider them necessarily safe but since they are very common and usually safe we'd introduce a lot of false positives otherwise:; - variable defined in condition part of an ```if``` statement; - variable defined in init statement condition of a ```for``` statement. For the time being we also don't warn about uninitialized uncounted local variables. Debug Checkers; ---------------. .. _debug-checkers:. debug; ^^^^^. Checkers used for debugging the analyzer.; :doc:`developer-docs/DebugChecks` page contains a detailed description. .. _debug-AnalysisOrder:. debug.AnalysisOrder; """"""""""""""""""""""""""""""""""""""; Print callbacks that are called during analysis in order. .. _debug-ConfigDumper:. debug.ConfigDumper; """"""""""""""""""""""""""""""""""""; Dump config table. .. _debug-DumpCFG Display:. debug.DumpCFG Display; """"""""""""""""""""""""""""""""""""""""""; Control-Flow Graphs. .. _debug-DumpCallGraph:. debug.DumpCallGraph; """"""""""""""""""""""""""""""""""""""; Display Call Graph. .. _debug-DumpCalls:. debug.DumpCalls; """"""""""""""""""""""""""""""; Print calls as they are traversed by the engine. .. _debug-DumpDominators:. debug.DumpDominators; """"""""""""""""""""""""""""""""""""""""; Print t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:214,Security,secur,security,214,"==================; Available Checkers; ==================. The analyzer performs checks that are categorized into families or ""checkers"". The default set of checkers covers a variety of checks targeted at finding security and API usage bugs,; dead code, and other logic errors. See the :ref:`default-checkers` checkers list below. In addition to these, the analyzer contains a number of :ref:`alpha-checkers` (aka *alpha* checkers).; These checkers are under development and are switched off by default. They may crash or emit a higher number of false positives. The :ref:`debug-checkers` package contains checkers for analyzer developers for debugging purposes. .. contents:: Table of Contents; :depth: 4. .. _default-checkers:. Default Checkers; ----------------. .. _core-checkers:. core; ^^^^; Models core language features and contains general-purpose checkers such as division by zero,; null pointer dereference, usage of uninitialized values, etc.; *These checkers must be always switched on as other checker rely on them.*. .. _core-BitwiseShift:. core.BitwiseShift (C, C++); """""""""""""""""""""""""""""""""""""""""""""""""""". Finds undefined behavior caused by the bitwise left- and right-shift operator; operating on integer types. By default, this checker only reports situations when the right operand is; either negative or larger than the bit width of the type of the left operand;; these are logically unsound. Moreover, if the pedantic mode is activated by; ``-analyzer-config core.BitwiseShift:Pedantic=true``, then this checker also; reports situations where the _left_ operand of a shift operator is negative or; overflow occurs during the right shift of a signed value. (Most compilers; handle these predictably, but the C standard and the C++ standards before C++20; say that they're undefined behavior. In the C++20 standard these constructs are; well-defined, so activating pedantic mode in C++20 has no effect.). **Examples**. .. code-block:: cpp. static_assert(sizeof(int) == 4, ""assuming 32-bit in",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:19771,Security,secur,security,19771,"zability.NonLocalizedStringChecker (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns about uses of non-localized NSStrings passed to UI methods expecting localized NSStrings. .. code-block:: objc. NSString *alarmText =; NSLocalizedString(@""Enabled"", @""Indicates alarm is turned on"");; if (!isEnabled) {; alarmText = @""Disabled"";; }; UILabel *alarmStateLabel = [[UILabel alloc] init];. // Warning: User-facing text should use localized string macro; [alarmStateLabel setText:alarmText];. .. _optin-performance-GCDAntipattern:. optin.performance.GCDAntipattern; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for performance anti-patterns when using Grand Central Dispatch. .. _optin-performance-Padding:. optin.performance.Padding; """"""""""""""""""""""""""""""""""""""""""""""""""; Check for excessively padded structs. .. _optin-portability-UnixAPI:. optin.portability.UnixAPI; """"""""""""""""""""""""""""""""""""""""""""""""""; Finds implementation-defined behavior in UNIX/Posix functions. .. _security-checkers:. security; ^^^^^^^^. Security related checkers. .. _security-cert-env-InvalidPtr:. security.cert.env.InvalidPtr; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Corresponds to SEI CERT Rules `ENV31-C <https://wiki.sei.cmu.edu/confluence/display/c/ENV31-C.+Do+not+rely+on+an+environment+pointer+following+an+operation+that+may+invalidate+it>`_ and `ENV34-C <https://wiki.sei.cmu.edu/confluence/display/c/ENV34-C.+Do+not+store+pointers+returned+by+certain+functions>`_. * **ENV31-C**:; Rule is about the possible problem with ``main`` function's third argument, environment pointer,; ""envp"". When environment array is modified using some modification function; such as ``putenv``, ``setenv`` or others, It may happen that memory is reallocated,; however ""envp"" is not updated to reflect the changes and points to old memory; region. * **ENV34-C**:; Some functions return a pointer to a statically allocated buffer.; Consequently, subsequent call of these functions will invalidate previous; pointer. These functions include:",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:19853,Security,secur,security,19853,"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns about uses of non-localized NSStrings passed to UI methods expecting localized NSStrings. .. code-block:: objc. NSString *alarmText =; NSLocalizedString(@""Enabled"", @""Indicates alarm is turned on"");; if (!isEnabled) {; alarmText = @""Disabled"";; }; UILabel *alarmStateLabel = [[UILabel alloc] init];. // Warning: User-facing text should use localized string macro; [alarmStateLabel setText:alarmText];. .. _optin-performance-GCDAntipattern:. optin.performance.GCDAntipattern; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for performance anti-patterns when using Grand Central Dispatch. .. _optin-performance-Padding:. optin.performance.Padding; """"""""""""""""""""""""""""""""""""""""""""""""""; Check for excessively padded structs. .. _optin-portability-UnixAPI:. optin.portability.UnixAPI; """"""""""""""""""""""""""""""""""""""""""""""""""; Finds implementation-defined behavior in UNIX/Posix functions. .. _security-checkers:. security; ^^^^^^^^. Security related checkers. .. _security-cert-env-InvalidPtr:. security.cert.env.InvalidPtr; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Corresponds to SEI CERT Rules `ENV31-C <https://wiki.sei.cmu.edu/confluence/display/c/ENV31-C.+Do+not+rely+on+an+environment+pointer+following+an+operation+that+may+invalidate+it>`_ and `ENV34-C <https://wiki.sei.cmu.edu/confluence/display/c/ENV34-C.+Do+not+store+pointers+returned+by+certain+functions>`_. * **ENV31-C**:; Rule is about the possible problem with ``main`` function's third argument, environment pointer,; ""envp"". When environment array is modified using some modification function; such as ``putenv``, ``setenv`` or others, It may happen that memory is reallocated,; however ""envp"" is not updated to reflect the changes and points to old memory; region. * **ENV34-C**:; Some functions return a pointer to a statically allocated buffer.; Consequently, subsequent call of these functions will invalidate previous; pointer. These functions include: ``getenv``, ``localeconv``, ``asctime``, ``setlocale``, ``strerror``. .. cod",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:21907,Security,secur,security,21907,", const char *argv[], const char *envp[]) {; if (setenv(""MY_NEW_VAR"", ""new_value"", 1) != 0) {; // setenv call may invalidate 'envp'; /* Handle error */; }; if (envp != NULL) {; for (size_t i = 0; envp[i] != NULL; ++i) {; puts(envp[i]);; // envp may no longer point to the current environment; // this program has unanticipated behavior, since envp; // does not reflect changes made by setenv function.; }; }; return 0;; }. void previous_call_invalidation() {; char *p, *pp;. p = getenv(""VAR"");; setenv(""SOMEVAR"", ""VALUE"", /*overwrite = */1);; // call to 'setenv' may invalidate p. *p;; // dereferencing invalid pointer; }. The ``InvalidatingGetEnv`` option is available for treating ``getenv`` calls as; invalidating. When enabled, the checker issues a warning if ``getenv`` is called; multiple times and their results are used without first creating a copy.; This level of strictness might be considered overly pedantic for the commonly; used ``getenv`` implementations. To enable this option, use:; ``-analyzer-config security.cert.env.InvalidPtr:InvalidatingGetEnv=true``. By default, this option is set to *false*. When this option is enabled, warnings will be generated for scenarios like the; following:. .. code-block:: c. char* p = getenv(""VAR"");; char* pp = getenv(""VAR2""); // assumes this call can invalidate `env`; strlen(p); // warns about accessing invalid ptr. .. _security-FloatLoopCounter:. security.FloatLoopCounter (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on using a floating point value as a loop counter (CERT: FLP30-C, FLP30-CPP). .. code-block:: c. void test() {; for (float x = 0.1f; x <= 1.0f; x += 0.1f) {} // warn; }. .. _security-insecureAPI-UncheckedReturn:. security.insecureAPI.UncheckedReturn (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of functions whose return values must be always checked. .. code-block:: c. void test() {; setuid(1); // warn; }. .. _security-insecureAPI-bcmp:. security.insecureAPI.bcmp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:22239,Security,access,accessing,22239,"program has unanticipated behavior, since envp; // does not reflect changes made by setenv function.; }; }; return 0;; }. void previous_call_invalidation() {; char *p, *pp;. p = getenv(""VAR"");; setenv(""SOMEVAR"", ""VALUE"", /*overwrite = */1);; // call to 'setenv' may invalidate p. *p;; // dereferencing invalid pointer; }. The ``InvalidatingGetEnv`` option is available for treating ``getenv`` calls as; invalidating. When enabled, the checker issues a warning if ``getenv`` is called; multiple times and their results are used without first creating a copy.; This level of strictness might be considered overly pedantic for the commonly; used ``getenv`` implementations. To enable this option, use:; ``-analyzer-config security.cert.env.InvalidPtr:InvalidatingGetEnv=true``. By default, this option is set to *false*. When this option is enabled, warnings will be generated for scenarios like the; following:. .. code-block:: c. char* p = getenv(""VAR"");; char* pp = getenv(""VAR2""); // assumes this call can invalidate `env`; strlen(p); // warns about accessing invalid ptr. .. _security-FloatLoopCounter:. security.FloatLoopCounter (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on using a floating point value as a loop counter (CERT: FLP30-C, FLP30-CPP). .. code-block:: c. void test() {; for (float x = 0.1f; x <= 1.0f; x += 0.1f) {} // warn; }. .. _security-insecureAPI-UncheckedReturn:. security.insecureAPI.UncheckedReturn (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of functions whose return values must be always checked. .. code-block:: c. void test() {; setuid(1); // warn; }. .. _security-insecureAPI-bcmp:. security.insecureAPI.bcmp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcmp' function. .. code-block:: c. void test() {; bcmp(ptr0, ptr1, n); // warn; }. .. _security-insecureAPI-bcopy:. security.insecureAPI.bcopy (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcopy' function. .. code-block:: c. void test() {; bcopy(src, dst, n); // warn; }. .. _s",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:22294,Security,secur,security,22294,"turn 0;; }. void previous_call_invalidation() {; char *p, *pp;. p = getenv(""VAR"");; setenv(""SOMEVAR"", ""VALUE"", /*overwrite = */1);; // call to 'setenv' may invalidate p. *p;; // dereferencing invalid pointer; }. The ``InvalidatingGetEnv`` option is available for treating ``getenv`` calls as; invalidating. When enabled, the checker issues a warning if ``getenv`` is called; multiple times and their results are used without first creating a copy.; This level of strictness might be considered overly pedantic for the commonly; used ``getenv`` implementations. To enable this option, use:; ``-analyzer-config security.cert.env.InvalidPtr:InvalidatingGetEnv=true``. By default, this option is set to *false*. When this option is enabled, warnings will be generated for scenarios like the; following:. .. code-block:: c. char* p = getenv(""VAR"");; char* pp = getenv(""VAR2""); // assumes this call can invalidate `env`; strlen(p); // warns about accessing invalid ptr. .. _security-FloatLoopCounter:. security.FloatLoopCounter (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on using a floating point value as a loop counter (CERT: FLP30-C, FLP30-CPP). .. code-block:: c. void test() {; for (float x = 0.1f; x <= 1.0f; x += 0.1f) {} // warn; }. .. _security-insecureAPI-UncheckedReturn:. security.insecureAPI.UncheckedReturn (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of functions whose return values must be always checked. .. code-block:: c. void test() {; setuid(1); // warn; }. .. _security-insecureAPI-bcmp:. security.insecureAPI.bcmp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcmp' function. .. code-block:: c. void test() {; bcmp(ptr0, ptr1, n); // warn; }. .. _security-insecureAPI-bcopy:. security.insecureAPI.bcopy (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcopy' function. .. code-block:: c. void test() {; bcopy(src, dst, n); // warn; }. .. _security-insecureAPI-bzero:. security.insecureAPI.bzero (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:22574,Security,secur,security,22574,"`` calls as; invalidating. When enabled, the checker issues a warning if ``getenv`` is called; multiple times and their results are used without first creating a copy.; This level of strictness might be considered overly pedantic for the commonly; used ``getenv`` implementations. To enable this option, use:; ``-analyzer-config security.cert.env.InvalidPtr:InvalidatingGetEnv=true``. By default, this option is set to *false*. When this option is enabled, warnings will be generated for scenarios like the; following:. .. code-block:: c. char* p = getenv(""VAR"");; char* pp = getenv(""VAR2""); // assumes this call can invalidate `env`; strlen(p); // warns about accessing invalid ptr. .. _security-FloatLoopCounter:. security.FloatLoopCounter (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on using a floating point value as a loop counter (CERT: FLP30-C, FLP30-CPP). .. code-block:: c. void test() {; for (float x = 0.1f; x <= 1.0f; x += 0.1f) {} // warn; }. .. _security-insecureAPI-UncheckedReturn:. security.insecureAPI.UncheckedReturn (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of functions whose return values must be always checked. .. code-block:: c. void test() {; setuid(1); // warn; }. .. _security-insecureAPI-bcmp:. security.insecureAPI.bcmp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcmp' function. .. code-block:: c. void test() {; bcmp(ptr0, ptr1, n); // warn; }. .. _security-insecureAPI-bcopy:. security.insecureAPI.bcopy (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcopy' function. .. code-block:: c. void test() {; bcopy(src, dst, n); // warn; }. .. _security-insecureAPI-bzero:. security.insecureAPI.bzero (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bzero' function. .. code-block:: c. void test() {; bzero(ptr, n); // warn; }. .. _security-insecureAPI-getpw:. security.insecureAPI.getpw (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'getpw' function. .. code-block:: c. void test() {; char buff[1024];; getpw(2, bu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:22817,Security,secur,security,22817,"nly; used ``getenv`` implementations. To enable this option, use:; ``-analyzer-config security.cert.env.InvalidPtr:InvalidatingGetEnv=true``. By default, this option is set to *false*. When this option is enabled, warnings will be generated for scenarios like the; following:. .. code-block:: c. char* p = getenv(""VAR"");; char* pp = getenv(""VAR2""); // assumes this call can invalidate `env`; strlen(p); // warns about accessing invalid ptr. .. _security-FloatLoopCounter:. security.FloatLoopCounter (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on using a floating point value as a loop counter (CERT: FLP30-C, FLP30-CPP). .. code-block:: c. void test() {; for (float x = 0.1f; x <= 1.0f; x += 0.1f) {} // warn; }. .. _security-insecureAPI-UncheckedReturn:. security.insecureAPI.UncheckedReturn (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of functions whose return values must be always checked. .. code-block:: c. void test() {; setuid(1); // warn; }. .. _security-insecureAPI-bcmp:. security.insecureAPI.bcmp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcmp' function. .. code-block:: c. void test() {; bcmp(ptr0, ptr1, n); // warn; }. .. _security-insecureAPI-bcopy:. security.insecureAPI.bcopy (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcopy' function. .. code-block:: c. void test() {; bcopy(src, dst, n); // warn; }. .. _security-insecureAPI-bzero:. security.insecureAPI.bzero (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bzero' function. .. code-block:: c. void test() {; bzero(ptr, n); // warn; }. .. _security-insecureAPI-getpw:. security.insecureAPI.getpw (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'getpw' function. .. code-block:: c. void test() {; char buff[1024];; getpw(2, buff); // warn; }. .. _security-insecureAPI-gets:. security.insecureAPI.gets (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'gets' function. .. code-block:: c. void test() {; char buff[1024];; gets(buff); // warn; }. .. _security-insecu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:23016,Security,secur,security,23016,"on is enabled, warnings will be generated for scenarios like the; following:. .. code-block:: c. char* p = getenv(""VAR"");; char* pp = getenv(""VAR2""); // assumes this call can invalidate `env`; strlen(p); // warns about accessing invalid ptr. .. _security-FloatLoopCounter:. security.FloatLoopCounter (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on using a floating point value as a loop counter (CERT: FLP30-C, FLP30-CPP). .. code-block:: c. void test() {; for (float x = 0.1f; x <= 1.0f; x += 0.1f) {} // warn; }. .. _security-insecureAPI-UncheckedReturn:. security.insecureAPI.UncheckedReturn (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of functions whose return values must be always checked. .. code-block:: c. void test() {; setuid(1); // warn; }. .. _security-insecureAPI-bcmp:. security.insecureAPI.bcmp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcmp' function. .. code-block:: c. void test() {; bcmp(ptr0, ptr1, n); // warn; }. .. _security-insecureAPI-bcopy:. security.insecureAPI.bcopy (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcopy' function. .. code-block:: c. void test() {; bcopy(src, dst, n); // warn; }. .. _security-insecureAPI-bzero:. security.insecureAPI.bzero (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bzero' function. .. code-block:: c. void test() {; bzero(ptr, n); // warn; }. .. _security-insecureAPI-getpw:. security.insecureAPI.getpw (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'getpw' function. .. code-block:: c. void test() {; char buff[1024];; getpw(2, buff); // warn; }. .. _security-insecureAPI-gets:. security.insecureAPI.gets (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'gets' function. .. code-block:: c. void test() {; char buff[1024];; gets(buff); // warn; }. .. _security-insecureAPI-mkstemp:. security.insecureAPI.mkstemp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn when 'mkstemp' is passed fewer than 6 X's in the format string. .. code-block:: c. void test() {; mkstemp(""XX""",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:23217,Security,secur,security,23217,"); // warns about accessing invalid ptr. .. _security-FloatLoopCounter:. security.FloatLoopCounter (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on using a floating point value as a loop counter (CERT: FLP30-C, FLP30-CPP). .. code-block:: c. void test() {; for (float x = 0.1f; x <= 1.0f; x += 0.1f) {} // warn; }. .. _security-insecureAPI-UncheckedReturn:. security.insecureAPI.UncheckedReturn (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of functions whose return values must be always checked. .. code-block:: c. void test() {; setuid(1); // warn; }. .. _security-insecureAPI-bcmp:. security.insecureAPI.bcmp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcmp' function. .. code-block:: c. void test() {; bcmp(ptr0, ptr1, n); // warn; }. .. _security-insecureAPI-bcopy:. security.insecureAPI.bcopy (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcopy' function. .. code-block:: c. void test() {; bcopy(src, dst, n); // warn; }. .. _security-insecureAPI-bzero:. security.insecureAPI.bzero (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bzero' function. .. code-block:: c. void test() {; bzero(ptr, n); // warn; }. .. _security-insecureAPI-getpw:. security.insecureAPI.getpw (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'getpw' function. .. code-block:: c. void test() {; char buff[1024];; getpw(2, buff); // warn; }. .. _security-insecureAPI-gets:. security.insecureAPI.gets (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'gets' function. .. code-block:: c. void test() {; char buff[1024];; gets(buff); // warn; }. .. _security-insecureAPI-mkstemp:. security.insecureAPI.mkstemp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn when 'mkstemp' is passed fewer than 6 X's in the format string. .. code-block:: c. void test() {; mkstemp(""XX""); // warn; }. .. _security-insecureAPI-mktemp:. security.insecureAPI.mktemp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the ``mktemp`` function. .. code-block:: c. void test() {; char *x = m",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:23413,Security,secur,security,23413," FLP30-C, FLP30-CPP). .. code-block:: c. void test() {; for (float x = 0.1f; x <= 1.0f; x += 0.1f) {} // warn; }. .. _security-insecureAPI-UncheckedReturn:. security.insecureAPI.UncheckedReturn (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of functions whose return values must be always checked. .. code-block:: c. void test() {; setuid(1); // warn; }. .. _security-insecureAPI-bcmp:. security.insecureAPI.bcmp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcmp' function. .. code-block:: c. void test() {; bcmp(ptr0, ptr1, n); // warn; }. .. _security-insecureAPI-bcopy:. security.insecureAPI.bcopy (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcopy' function. .. code-block:: c. void test() {; bcopy(src, dst, n); // warn; }. .. _security-insecureAPI-bzero:. security.insecureAPI.bzero (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bzero' function. .. code-block:: c. void test() {; bzero(ptr, n); // warn; }. .. _security-insecureAPI-getpw:. security.insecureAPI.getpw (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'getpw' function. .. code-block:: c. void test() {; char buff[1024];; getpw(2, buff); // warn; }. .. _security-insecureAPI-gets:. security.insecureAPI.gets (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'gets' function. .. code-block:: c. void test() {; char buff[1024];; gets(buff); // warn; }. .. _security-insecureAPI-mkstemp:. security.insecureAPI.mkstemp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn when 'mkstemp' is passed fewer than 6 X's in the format string. .. code-block:: c. void test() {; mkstemp(""XX""); // warn; }. .. _security-insecureAPI-mktemp:. security.insecureAPI.mktemp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the ``mktemp`` function. .. code-block:: c. void test() {; char *x = mktemp(""/tmp/zxcv""); // warn: insecure, use mkstemp; }. .. _security-insecureAPI-rand:. security.insecureAPI.rand (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of inferior random number generati",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:23627,Security,secur,security,23627,"""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of functions whose return values must be always checked. .. code-block:: c. void test() {; setuid(1); // warn; }. .. _security-insecureAPI-bcmp:. security.insecureAPI.bcmp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcmp' function. .. code-block:: c. void test() {; bcmp(ptr0, ptr1, n); // warn; }. .. _security-insecureAPI-bcopy:. security.insecureAPI.bcopy (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcopy' function. .. code-block:: c. void test() {; bcopy(src, dst, n); // warn; }. .. _security-insecureAPI-bzero:. security.insecureAPI.bzero (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bzero' function. .. code-block:: c. void test() {; bzero(ptr, n); // warn; }. .. _security-insecureAPI-getpw:. security.insecureAPI.getpw (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'getpw' function. .. code-block:: c. void test() {; char buff[1024];; getpw(2, buff); // warn; }. .. _security-insecureAPI-gets:. security.insecureAPI.gets (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'gets' function. .. code-block:: c. void test() {; char buff[1024];; gets(buff); // warn; }. .. _security-insecureAPI-mkstemp:. security.insecureAPI.mkstemp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn when 'mkstemp' is passed fewer than 6 X's in the format string. .. code-block:: c. void test() {; mkstemp(""XX""); // warn; }. .. _security-insecureAPI-mktemp:. security.insecureAPI.mktemp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the ``mktemp`` function. .. code-block:: c. void test() {; char *x = mktemp(""/tmp/zxcv""); // warn: insecure, use mkstemp; }. .. _security-insecureAPI-rand:. security.insecureAPI.rand (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of inferior random number generating functions (only if arc4random function is available):; ``drand48, erand48, jrand48, lcong48, lrand48, mrand48, nrand48, random, rand_r``. .. code-block:: c. void test() {; random(); // warn; }. .. _security-inse",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:23837,Security,secur,security,23837,"p (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcmp' function. .. code-block:: c. void test() {; bcmp(ptr0, ptr1, n); // warn; }. .. _security-insecureAPI-bcopy:. security.insecureAPI.bcopy (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcopy' function. .. code-block:: c. void test() {; bcopy(src, dst, n); // warn; }. .. _security-insecureAPI-bzero:. security.insecureAPI.bzero (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bzero' function. .. code-block:: c. void test() {; bzero(ptr, n); // warn; }. .. _security-insecureAPI-getpw:. security.insecureAPI.getpw (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'getpw' function. .. code-block:: c. void test() {; char buff[1024];; getpw(2, buff); // warn; }. .. _security-insecureAPI-gets:. security.insecureAPI.gets (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'gets' function. .. code-block:: c. void test() {; char buff[1024];; gets(buff); // warn; }. .. _security-insecureAPI-mkstemp:. security.insecureAPI.mkstemp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn when 'mkstemp' is passed fewer than 6 X's in the format string. .. code-block:: c. void test() {; mkstemp(""XX""); // warn; }. .. _security-insecureAPI-mktemp:. security.insecureAPI.mktemp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the ``mktemp`` function. .. code-block:: c. void test() {; char *x = mktemp(""/tmp/zxcv""); // warn: insecure, use mkstemp; }. .. _security-insecureAPI-rand:. security.insecureAPI.rand (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of inferior random number generating functions (only if arc4random function is available):; ``drand48, erand48, jrand48, lcong48, lrand48, mrand48, nrand48, random, rand_r``. .. code-block:: c. void test() {; random(); // warn; }. .. _security-insecureAPI-strcpy:. security.insecureAPI.strcpy (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the ``strcpy`` and ``strcat`` functions. .. code-block:: c. void test() {; char x[4];; char *y = ""abcd"";. strcp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:24069,Security,secur,security,24069,"""""""""""; Warn on uses of the 'bcopy' function. .. code-block:: c. void test() {; bcopy(src, dst, n); // warn; }. .. _security-insecureAPI-bzero:. security.insecureAPI.bzero (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bzero' function. .. code-block:: c. void test() {; bzero(ptr, n); // warn; }. .. _security-insecureAPI-getpw:. security.insecureAPI.getpw (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'getpw' function. .. code-block:: c. void test() {; char buff[1024];; getpw(2, buff); // warn; }. .. _security-insecureAPI-gets:. security.insecureAPI.gets (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'gets' function. .. code-block:: c. void test() {; char buff[1024];; gets(buff); // warn; }. .. _security-insecureAPI-mkstemp:. security.insecureAPI.mkstemp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn when 'mkstemp' is passed fewer than 6 X's in the format string. .. code-block:: c. void test() {; mkstemp(""XX""); // warn; }. .. _security-insecureAPI-mktemp:. security.insecureAPI.mktemp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the ``mktemp`` function. .. code-block:: c. void test() {; char *x = mktemp(""/tmp/zxcv""); // warn: insecure, use mkstemp; }. .. _security-insecureAPI-rand:. security.insecureAPI.rand (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of inferior random number generating functions (only if arc4random function is available):; ``drand48, erand48, jrand48, lcong48, lrand48, mrand48, nrand48, random, rand_r``. .. code-block:: c. void test() {; random(); // warn; }. .. _security-insecureAPI-strcpy:. security.insecureAPI.strcpy (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the ``strcpy`` and ``strcat`` functions. .. code-block:: c. void test() {; char x[4];; char *y = ""abcd"";. strcpy(x, y); // warn; }. .. _security-insecureAPI-vfork:. security.insecureAPI.vfork (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'vfork' function. .. code-block:: c. void test() {; vfork(); // warn; }. .. _security-insecure",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:24308,Security,secur,security,24308,"ction. .. code-block:: c. void test() {; bzero(ptr, n); // warn; }. .. _security-insecureAPI-getpw:. security.insecureAPI.getpw (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'getpw' function. .. code-block:: c. void test() {; char buff[1024];; getpw(2, buff); // warn; }. .. _security-insecureAPI-gets:. security.insecureAPI.gets (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'gets' function. .. code-block:: c. void test() {; char buff[1024];; gets(buff); // warn; }. .. _security-insecureAPI-mkstemp:. security.insecureAPI.mkstemp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn when 'mkstemp' is passed fewer than 6 X's in the format string. .. code-block:: c. void test() {; mkstemp(""XX""); // warn; }. .. _security-insecureAPI-mktemp:. security.insecureAPI.mktemp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the ``mktemp`` function. .. code-block:: c. void test() {; char *x = mktemp(""/tmp/zxcv""); // warn: insecure, use mkstemp; }. .. _security-insecureAPI-rand:. security.insecureAPI.rand (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of inferior random number generating functions (only if arc4random function is available):; ``drand48, erand48, jrand48, lcong48, lrand48, mrand48, nrand48, random, rand_r``. .. code-block:: c. void test() {; random(); // warn; }. .. _security-insecureAPI-strcpy:. security.insecureAPI.strcpy (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the ``strcpy`` and ``strcat`` functions. .. code-block:: c. void test() {; char x[4];; char *y = ""abcd"";. strcpy(x, y); // warn; }. .. _security-insecureAPI-vfork:. security.insecureAPI.vfork (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'vfork' function. .. code-block:: c. void test() {; vfork(); // warn; }. .. _security-insecureAPI-DeprecatedOrUnsafeBufferHandling:. security.insecureAPI.DeprecatedOrUnsafeBufferHandling (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on occurrences of unsafe or deprecated buffer handling functions, which now h",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:24648,Security,secur,security,24648," (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'gets' function. .. code-block:: c. void test() {; char buff[1024];; gets(buff); // warn; }. .. _security-insecureAPI-mkstemp:. security.insecureAPI.mkstemp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn when 'mkstemp' is passed fewer than 6 X's in the format string. .. code-block:: c. void test() {; mkstemp(""XX""); // warn; }. .. _security-insecureAPI-mktemp:. security.insecureAPI.mktemp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the ``mktemp`` function. .. code-block:: c. void test() {; char *x = mktemp(""/tmp/zxcv""); // warn: insecure, use mkstemp; }. .. _security-insecureAPI-rand:. security.insecureAPI.rand (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of inferior random number generating functions (only if arc4random function is available):; ``drand48, erand48, jrand48, lcong48, lrand48, mrand48, nrand48, random, rand_r``. .. code-block:: c. void test() {; random(); // warn; }. .. _security-insecureAPI-strcpy:. security.insecureAPI.strcpy (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the ``strcpy`` and ``strcat`` functions. .. code-block:: c. void test() {; char x[4];; char *y = ""abcd"";. strcpy(x, y); // warn; }. .. _security-insecureAPI-vfork:. security.insecureAPI.vfork (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'vfork' function. .. code-block:: c. void test() {; vfork(); // warn; }. .. _security-insecureAPI-DeprecatedOrUnsafeBufferHandling:. security.insecureAPI.DeprecatedOrUnsafeBufferHandling (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on occurrences of unsafe or deprecated buffer handling functions, which now have a secure variant: ``sprintf, fprintf, vsprintf, scanf, wscanf, fscanf, fwscanf, vscanf, vwscanf, vfscanf, vfwscanf, sscanf, swscanf, vsscanf, vswscanf, swprintf, snprintf, vswprintf, vsnprintf, memcpy, memmove, strncpy, strncat, memset``. .. code-block:: c. void test() {; char buf [5];; strncpy(buf, ""a"", 1); // warn; }. .. _unix-check",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:24895,Security,secur,security,24895,"""""""""; Warn when 'mkstemp' is passed fewer than 6 X's in the format string. .. code-block:: c. void test() {; mkstemp(""XX""); // warn; }. .. _security-insecureAPI-mktemp:. security.insecureAPI.mktemp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the ``mktemp`` function. .. code-block:: c. void test() {; char *x = mktemp(""/tmp/zxcv""); // warn: insecure, use mkstemp; }. .. _security-insecureAPI-rand:. security.insecureAPI.rand (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of inferior random number generating functions (only if arc4random function is available):; ``drand48, erand48, jrand48, lcong48, lrand48, mrand48, nrand48, random, rand_r``. .. code-block:: c. void test() {; random(); // warn; }. .. _security-insecureAPI-strcpy:. security.insecureAPI.strcpy (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the ``strcpy`` and ``strcat`` functions. .. code-block:: c. void test() {; char x[4];; char *y = ""abcd"";. strcpy(x, y); // warn; }. .. _security-insecureAPI-vfork:. security.insecureAPI.vfork (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'vfork' function. .. code-block:: c. void test() {; vfork(); // warn; }. .. _security-insecureAPI-DeprecatedOrUnsafeBufferHandling:. security.insecureAPI.DeprecatedOrUnsafeBufferHandling (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on occurrences of unsafe or deprecated buffer handling functions, which now have a secure variant: ``sprintf, fprintf, vsprintf, scanf, wscanf, fscanf, fwscanf, vscanf, vwscanf, vfscanf, vfwscanf, sscanf, swscanf, vsscanf, vswscanf, swprintf, snprintf, vswprintf, vsnprintf, memcpy, memmove, strncpy, strncat, memset``. .. code-block:: c. void test() {; char buf [5];; strncpy(buf, ""a"", 1); // warn; }. .. _unix-checkers:. unix; ^^^^; POSIX/Unix checkers. .. _unix-API:. unix.API (C); """"""""""""""""""""""""; Check calls to various UNIX/Posix functions: ``open, pthread_once, calloc, malloc, realloc, alloca``. .. literalinclude:: checkers/unix_api_example.c; :language: c. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:25112,Security,secur,security,25112,"""""""""""""""""""""""""""""""""""; Warn on uses of the ``mktemp`` function. .. code-block:: c. void test() {; char *x = mktemp(""/tmp/zxcv""); // warn: insecure, use mkstemp; }. .. _security-insecureAPI-rand:. security.insecureAPI.rand (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of inferior random number generating functions (only if arc4random function is available):; ``drand48, erand48, jrand48, lcong48, lrand48, mrand48, nrand48, random, rand_r``. .. code-block:: c. void test() {; random(); // warn; }. .. _security-insecureAPI-strcpy:. security.insecureAPI.strcpy (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the ``strcpy`` and ``strcat`` functions. .. code-block:: c. void test() {; char x[4];; char *y = ""abcd"";. strcpy(x, y); // warn; }. .. _security-insecureAPI-vfork:. security.insecureAPI.vfork (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'vfork' function. .. code-block:: c. void test() {; vfork(); // warn; }. .. _security-insecureAPI-DeprecatedOrUnsafeBufferHandling:. security.insecureAPI.DeprecatedOrUnsafeBufferHandling (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on occurrences of unsafe or deprecated buffer handling functions, which now have a secure variant: ``sprintf, fprintf, vsprintf, scanf, wscanf, fscanf, fwscanf, vscanf, vwscanf, vfscanf, vfwscanf, sscanf, swscanf, vsscanf, vswscanf, swprintf, snprintf, vswprintf, vsnprintf, memcpy, memmove, strncpy, strncat, memset``. .. code-block:: c. void test() {; char buf [5];; strncpy(buf, ""a"", 1); // warn; }. .. _unix-checkers:. unix; ^^^^; POSIX/Unix checkers. .. _unix-API:. unix.API (C); """"""""""""""""""""""""; Check calls to various UNIX/Posix functions: ``open, pthread_once, calloc, malloc, realloc, alloca``. .. literalinclude:: checkers/unix_api_example.c; :language: c. .. _unix-Errno:. unix.Errno (C); """""""""""""""""""""""""""". Check for improper use of ``errno``.; This checker implements partially CERT rule; `ERR30-C. Set errno to zero before calling a library function known to set errno,; an",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:25318,Security,secur,secure,25318,"""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of inferior random number generating functions (only if arc4random function is available):; ``drand48, erand48, jrand48, lcong48, lrand48, mrand48, nrand48, random, rand_r``. .. code-block:: c. void test() {; random(); // warn; }. .. _security-insecureAPI-strcpy:. security.insecureAPI.strcpy (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the ``strcpy`` and ``strcat`` functions. .. code-block:: c. void test() {; char x[4];; char *y = ""abcd"";. strcpy(x, y); // warn; }. .. _security-insecureAPI-vfork:. security.insecureAPI.vfork (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'vfork' function. .. code-block:: c. void test() {; vfork(); // warn; }. .. _security-insecureAPI-DeprecatedOrUnsafeBufferHandling:. security.insecureAPI.DeprecatedOrUnsafeBufferHandling (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on occurrences of unsafe or deprecated buffer handling functions, which now have a secure variant: ``sprintf, fprintf, vsprintf, scanf, wscanf, fscanf, fwscanf, vscanf, vwscanf, vfscanf, vfwscanf, sscanf, swscanf, vsscanf, vswscanf, swprintf, snprintf, vswprintf, vsnprintf, memcpy, memmove, strncpy, strncat, memset``. .. code-block:: c. void test() {; char buf [5];; strncpy(buf, ""a"", 1); // warn; }. .. _unix-checkers:. unix; ^^^^; POSIX/Unix checkers. .. _unix-API:. unix.API (C); """"""""""""""""""""""""; Check calls to various UNIX/Posix functions: ``open, pthread_once, calloc, malloc, realloc, alloca``. .. literalinclude:: checkers/unix_api_example.c; :language: c. .. _unix-Errno:. unix.Errno (C); """""""""""""""""""""""""""". Check for improper use of ``errno``.; This checker implements partially CERT rule; `ERR30-C. Set errno to zero before calling a library function known to set errno,; and check errno only after the function returns a value indicating failure; <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152351>`_.; The checker can find the first read of ``errno`` after successful standard",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:51871,Security,access,access,51871,"(struct s *p) {; return sizeof(p);; // warn: sizeof(ptr) can produce an unexpected result; }. .. _alpha-core-StackAddressAsyncEscape:. alpha.core.StackAddressAsyncEscape (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check that addresses to stack memory do not escape the function that involves dispatch_after or dispatch_async.; This checker is a part of ``core.StackAddressEscape``, but is temporarily disabled until some false positives are fixed. .. code-block:: c. dispatch_block_t test_block_inside_block_async_leak() {; int x = 123;; void (^inner)(void) = ^void(void) {; int y = x;; ++y;; };; void (^outer)(void) = ^void(void) {; int z = x;; ++z;; inner();; };; return outer; // warn: address of stack-allocated block is captured by a; // returned block; }. .. _alpha-core-StdVariant:. alpha.core.StdVariant (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""; Check if a value of active type is retrieved from an ``std::variant`` instance with ``std::get``.; In case of bad variant type access (the accessed type differs from the active type); a warning is emitted. Currently, this checker does not take exception handling into account. .. code-block:: cpp. void test() {; std::variant<int, char> v = 25;; char c = stg::get<char>(v); // warn: ""int"" is the active alternative; }. .. _alpha-core-TestAfterDivZero:. alpha.core.TestAfterDivZero (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for division by variable that is later compared against 0.; Either the comparison is useless or there is division by zero. .. code-block:: c. void test(int x) {; var = 77 / x;; if (x == 0) { } // warn; }. alpha.cplusplus; ^^^^^^^^^^^^^^^. .. _alpha-cplusplus-ArrayDelete:. alpha.cplusplus.ArrayDelete (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Reports destructions of arrays of polymorphic objects that are destructed as their base class.; This checker corresponds to the CERT rule `EXP51-CPP: Do not delete an array through a pointer of the incorrect type <https://wiki.sei.cmu.edu/confluence/display/cplusplus/EXP51-CPP.+Do+n",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:51883,Security,access,accessed,51883,"(struct s *p) {; return sizeof(p);; // warn: sizeof(ptr) can produce an unexpected result; }. .. _alpha-core-StackAddressAsyncEscape:. alpha.core.StackAddressAsyncEscape (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check that addresses to stack memory do not escape the function that involves dispatch_after or dispatch_async.; This checker is a part of ``core.StackAddressEscape``, but is temporarily disabled until some false positives are fixed. .. code-block:: c. dispatch_block_t test_block_inside_block_async_leak() {; int x = 123;; void (^inner)(void) = ^void(void) {; int y = x;; ++y;; };; void (^outer)(void) = ^void(void) {; int z = x;; ++z;; inner();; };; return outer; // warn: address of stack-allocated block is captured by a; // returned block; }. .. _alpha-core-StdVariant:. alpha.core.StdVariant (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""; Check if a value of active type is retrieved from an ``std::variant`` instance with ``std::get``.; In case of bad variant type access (the accessed type differs from the active type); a warning is emitted. Currently, this checker does not take exception handling into account. .. code-block:: cpp. void test() {; std::variant<int, char> v = 25;; char c = stg::get<char>(v); // warn: ""int"" is the active alternative; }. .. _alpha-core-TestAfterDivZero:. alpha.core.TestAfterDivZero (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for division by variable that is later compared against 0.; Either the comparison is useless or there is division by zero. .. code-block:: c. void test(int x) {; var = 77 / x;; if (x == 0) { } // warn; }. alpha.cplusplus; ^^^^^^^^^^^^^^^. .. _alpha-cplusplus-ArrayDelete:. alpha.cplusplus.ArrayDelete (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Reports destructions of arrays of polymorphic objects that are destructed as their base class.; This checker corresponds to the CERT rule `EXP51-CPP: Do not delete an array through a pointer of the incorrect type <https://wiki.sei.cmu.edu/confluence/display/cplusplus/EXP51-CPP.+Do+n",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:54213,Security,access,accessed,54213,"delete[] x; // warn: Deleting an array of 'Derived' objects as their base class 'Base' is undefined; }. .. _alpha-cplusplus-DeleteWithNonVirtualDtor:. alpha.cplusplus.DeleteWithNonVirtualDtor (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Reports destructions of polymorphic objects with a non-virtual destructor in their base class. .. code-block:: cpp. class NonVirtual {};; class NVDerived : public NonVirtual {};. NonVirtual *create() {; NonVirtual *x = new NVDerived(); // note: Casting from 'NVDerived' to; // 'NonVirtual' here; return x;; }. void foo() {; NonVirtual *x = create();; delete x; // warn: destruction of a polymorphic object with no virtual; // destructor; }. .. _alpha-cplusplus-InvalidatedIterator:. alpha.cplusplus.InvalidatedIterator (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for use of invalidated iterators. .. code-block:: cpp. void bad_copy_assign_operator_list1(std::list &L1,; const std::list &L2) {; auto i0 = L1.cbegin();; L1 = L2;; *i0; // warn: invalidated iterator accessed; }. .. _alpha-cplusplus-IteratorRange:. alpha.cplusplus.IteratorRange (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for iterators used outside their valid ranges. .. code-block:: cpp. void simple_bad_end(const std::vector &v) {; auto i = v.end();; *i; // warn: iterator accessed outside of its range; }. .. _alpha-cplusplus-MismatchedIterator:. alpha.cplusplus.MismatchedIterator (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for use of iterators of different containers where iterators of the same container are expected. .. code-block:: cpp. void bad_insert3(std::vector &v1, std::vector &v2) {; v2.insert(v1.cbegin(), v2.cbegin(), v2.cend()); // warn: container accessed; // using foreign; // iterator argument; v1.insert(v1.cbegin(), v1.cbegin(), v2.cend()); // warn: iterators of; // different containers; // used where the same; // container is; // expected; v1.insert(v1.cbegin(), v2.cbegin(), v1.cend()); // warn: iterators of; // different contain",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:54496,Security,access,accessed,54496,"ual destructor in their base class. .. code-block:: cpp. class NonVirtual {};; class NVDerived : public NonVirtual {};. NonVirtual *create() {; NonVirtual *x = new NVDerived(); // note: Casting from 'NVDerived' to; // 'NonVirtual' here; return x;; }. void foo() {; NonVirtual *x = create();; delete x; // warn: destruction of a polymorphic object with no virtual; // destructor; }. .. _alpha-cplusplus-InvalidatedIterator:. alpha.cplusplus.InvalidatedIterator (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for use of invalidated iterators. .. code-block:: cpp. void bad_copy_assign_operator_list1(std::list &L1,; const std::list &L2) {; auto i0 = L1.cbegin();; L1 = L2;; *i0; // warn: invalidated iterator accessed; }. .. _alpha-cplusplus-IteratorRange:. alpha.cplusplus.IteratorRange (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for iterators used outside their valid ranges. .. code-block:: cpp. void simple_bad_end(const std::vector &v) {; auto i = v.end();; *i; // warn: iterator accessed outside of its range; }. .. _alpha-cplusplus-MismatchedIterator:. alpha.cplusplus.MismatchedIterator (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for use of iterators of different containers where iterators of the same container are expected. .. code-block:: cpp. void bad_insert3(std::vector &v1, std::vector &v2) {; v2.insert(v1.cbegin(), v2.cbegin(), v2.cend()); // warn: container accessed; // using foreign; // iterator argument; v1.insert(v1.cbegin(), v1.cbegin(), v2.cend()); // warn: iterators of; // different containers; // used where the same; // container is; // expected; v1.insert(v1.cbegin(), v2.cbegin(), v1.cend()); // warn: iterators of; // different containers; // used where the same; // container is; // expected; }. .. _alpha-cplusplus-MisusedMovedObject:. alpha.cplusplus.MisusedMovedObject (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Method calls on a moved-from object and copying a moved-from object will be reported. .. code-block:: cpp. struct A {; v",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:54900,Security,access,accessed,54900,"erator:. alpha.cplusplus.InvalidatedIterator (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for use of invalidated iterators. .. code-block:: cpp. void bad_copy_assign_operator_list1(std::list &L1,; const std::list &L2) {; auto i0 = L1.cbegin();; L1 = L2;; *i0; // warn: invalidated iterator accessed; }. .. _alpha-cplusplus-IteratorRange:. alpha.cplusplus.IteratorRange (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for iterators used outside their valid ranges. .. code-block:: cpp. void simple_bad_end(const std::vector &v) {; auto i = v.end();; *i; // warn: iterator accessed outside of its range; }. .. _alpha-cplusplus-MismatchedIterator:. alpha.cplusplus.MismatchedIterator (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for use of iterators of different containers where iterators of the same container are expected. .. code-block:: cpp. void bad_insert3(std::vector &v1, std::vector &v2) {; v2.insert(v1.cbegin(), v2.cbegin(), v2.cend()); // warn: container accessed; // using foreign; // iterator argument; v1.insert(v1.cbegin(), v1.cbegin(), v2.cend()); // warn: iterators of; // different containers; // used where the same; // container is; // expected; v1.insert(v1.cbegin(), v2.cbegin(), v1.cend()); // warn: iterators of; // different containers; // used where the same; // container is; // expected; }. .. _alpha-cplusplus-MisusedMovedObject:. alpha.cplusplus.MisusedMovedObject (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Method calls on a moved-from object and copying a moved-from object will be reported. .. code-block:: cpp. struct A {; void foo() {}; };. void f() {; A a;; A b = std::move(a); // note: 'a' became 'moved-from' here; a.foo(); // warn: method call on a 'moved-from' object 'a'; }. .. _alpha-cplusplus-SmartPtr:. alpha.cplusplus.SmartPtr (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for dereference of null smart pointers. .. code-block:: cpp. void deref_smart_ptr() {; std::unique_ptr<int> P;; *P; // warn: dereference of a default constr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:60295,Security,secur,security,60295,"InvalidationMethodDecl : NSObject {; NeedInvalidation *Var; // warn; }; @end. @implementation MissingInvalidationMethodDecl; @end. .. _alpha-osx-cocoa-localizability-PluralMisuseChecker:. alpha.osx.cocoa.localizability.PluralMisuseChecker (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns against using one vs. many plural pattern in code when generating localized strings. .. code-block:: objc. NSString *reminderText =; NSLocalizedString(@""None"", @""Indicates no reminders"");; if (reminderCount == 1) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; NSLocalizedString(@""1 Reminder"", @""Indicates single reminder"");; } else if (reminderCount >= 2) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; [NSString stringWithFormat:; NSLocalizedString(@""%@ Reminders"", @""Indicates multiple reminders""),; reminderCount];; }. alpha.security; ^^^^^^^^^^^^^^. .. _alpha-security-ArrayBound:. alpha.security.ArrayBound (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about buffer overflows (older checker). .. code-block:: c. void test() {; char *s = """";; char c = s[1]; // warn; }. struct seven_words {; int c[7];; };. void test() {; struct seven_words a, *p;; p = &a;; p[0] = a;; p[1] = a;; p[2] = a; // warn; }. // note: requires unix.Malloc or; // alpha.unix.MallocWithAnnotations checks enabled.; void test() {; int *p = malloc(12);; p[3] = 4; // warn; }. void test() {; char a[2];; int *b = (int*)a;; b[1] = 3; // warn; }. .. _alpha-security-ArrayBoundV2:. alpha.security.ArrayBoundV2 (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about buffer overflows (newer checker). .. code-block:: c. void test() {; char *s = """";; char c = s[1]; // warn; }. void test() {; int buf[100];; int *p = buf;; p = p + 99;; p[1] = 1; // warn; }. // note: compiler has internal check for this.; // Use -Wno-array-bounds to suppress compiler warning.; void test() {; int bu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:60331,Security,secur,security-ArrayBound,60331,"ect {; NeedInvalidation *Var; // warn; }; @end. @implementation MissingInvalidationMethodDecl; @end. .. _alpha-osx-cocoa-localizability-PluralMisuseChecker:. alpha.osx.cocoa.localizability.PluralMisuseChecker (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns against using one vs. many plural pattern in code when generating localized strings. .. code-block:: objc. NSString *reminderText =; NSLocalizedString(@""None"", @""Indicates no reminders"");; if (reminderCount == 1) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; NSLocalizedString(@""1 Reminder"", @""Indicates single reminder"");; } else if (reminderCount >= 2) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; [NSString stringWithFormat:; NSLocalizedString(@""%@ Reminders"", @""Indicates multiple reminders""),; reminderCount];; }. alpha.security; ^^^^^^^^^^^^^^. .. _alpha-security-ArrayBound:. alpha.security.ArrayBound (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about buffer overflows (older checker). .. code-block:: c. void test() {; char *s = """";; char c = s[1]; // warn; }. struct seven_words {; int c[7];; };. void test() {; struct seven_words a, *p;; p = &a;; p[0] = a;; p[1] = a;; p[2] = a; // warn; }. // note: requires unix.Malloc or; // alpha.unix.MallocWithAnnotations checks enabled.; void test() {; int *p = malloc(12);; p[3] = 4; // warn; }. void test() {; char a[2];; int *b = (int*)a;; b[1] = 3; // warn; }. .. _alpha-security-ArrayBoundV2:. alpha.security.ArrayBoundV2 (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about buffer overflows (newer checker). .. code-block:: c. void test() {; char *s = """";; char c = s[1]; // warn; }. void test() {; int buf[100];; int *p = buf;; p = p + 99;; p[1] = 1; // warn; }. // note: compiler has internal check for this.; // Use -Wno-array-bounds to suppress compiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:60359,Security,secur,security,60359,"ar; // warn; }; @end. @implementation MissingInvalidationMethodDecl; @end. .. _alpha-osx-cocoa-localizability-PluralMisuseChecker:. alpha.osx.cocoa.localizability.PluralMisuseChecker (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns against using one vs. many plural pattern in code when generating localized strings. .. code-block:: objc. NSString *reminderText =; NSLocalizedString(@""None"", @""Indicates no reminders"");; if (reminderCount == 1) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; NSLocalizedString(@""1 Reminder"", @""Indicates single reminder"");; } else if (reminderCount >= 2) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; [NSString stringWithFormat:; NSLocalizedString(@""%@ Reminders"", @""Indicates multiple reminders""),; reminderCount];; }. alpha.security; ^^^^^^^^^^^^^^. .. _alpha-security-ArrayBound:. alpha.security.ArrayBound (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about buffer overflows (older checker). .. code-block:: c. void test() {; char *s = """";; char c = s[1]; // warn; }. struct seven_words {; int c[7];; };. void test() {; struct seven_words a, *p;; p = &a;; p[0] = a;; p[1] = a;; p[2] = a; // warn; }. // note: requires unix.Malloc or; // alpha.unix.MallocWithAnnotations checks enabled.; void test() {; int *p = malloc(12);; p[3] = 4; // warn; }. void test() {; char a[2];; int *b = (int*)a;; b[1] = 3; // warn; }. .. _alpha-security-ArrayBoundV2:. alpha.security.ArrayBoundV2 (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about buffer overflows (newer checker). .. code-block:: c. void test() {; char *s = """";; char c = s[1]; // warn; }. void test() {; int buf[100];; int *p = buf;; p = p + 99;; p[1] = 1; // warn; }. // note: compiler has internal check for this.; // Use -Wno-array-bounds to suppress compiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:60892,Security,secur,security-,60892,"; // Use a .stringsdict file instead; reminderText =; NSLocalizedString(@""1 Reminder"", @""Indicates single reminder"");; } else if (reminderCount >= 2) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; [NSString stringWithFormat:; NSLocalizedString(@""%@ Reminders"", @""Indicates multiple reminders""),; reminderCount];; }. alpha.security; ^^^^^^^^^^^^^^. .. _alpha-security-ArrayBound:. alpha.security.ArrayBound (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about buffer overflows (older checker). .. code-block:: c. void test() {; char *s = """";; char c = s[1]; // warn; }. struct seven_words {; int c[7];; };. void test() {; struct seven_words a, *p;; p = &a;; p[0] = a;; p[1] = a;; p[2] = a; // warn; }. // note: requires unix.Malloc or; // alpha.unix.MallocWithAnnotations checks enabled.; void test() {; int *p = malloc(12);; p[3] = 4; // warn; }. void test() {; char a[2];; int *b = (int*)a;; b[1] = 3; // warn; }. .. _alpha-security-ArrayBoundV2:. alpha.security.ArrayBoundV2 (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about buffer overflows (newer checker). .. code-block:: c. void test() {; char *s = """";; char c = s[1]; // warn; }. void test() {; int buf[100];; int *p = buf;; p = p + 99;; p[1] = 1; // warn; }. // note: compiler has internal check for this.; // Use -Wno-array-bounds to suppress compiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. .. _alpha-security-MallocOverflow:. alpha.security.MallocOverflow (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for overflows in the arguments to ``malloc()``.; It tries to catch ``malloc(n * c)`` patterns, where:. - ``n``: a variable or member access of an object; - ``c``: a constant foldable integral. This checker was designed for code audits, so expect false-positive reports.; One is supp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:60922,Security,secur,security,60922,"e instead; reminderText =; NSLocalizedString(@""1 Reminder"", @""Indicates single reminder"");; } else if (reminderCount >= 2) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; [NSString stringWithFormat:; NSLocalizedString(@""%@ Reminders"", @""Indicates multiple reminders""),; reminderCount];; }. alpha.security; ^^^^^^^^^^^^^^. .. _alpha-security-ArrayBound:. alpha.security.ArrayBound (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about buffer overflows (older checker). .. code-block:: c. void test() {; char *s = """";; char c = s[1]; // warn; }. struct seven_words {; int c[7];; };. void test() {; struct seven_words a, *p;; p = &a;; p[0] = a;; p[1] = a;; p[2] = a; // warn; }. // note: requires unix.Malloc or; // alpha.unix.MallocWithAnnotations checks enabled.; void test() {; int *p = malloc(12);; p[3] = 4; // warn; }. void test() {; char a[2];; int *b = (int*)a;; b[1] = 3; // warn; }. .. _alpha-security-ArrayBoundV2:. alpha.security.ArrayBoundV2 (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about buffer overflows (newer checker). .. code-block:: c. void test() {; char *s = """";; char c = s[1]; // warn; }. void test() {; int buf[100];; int *p = buf;; p = p + 99;; p[1] = 1; // warn; }. // note: compiler has internal check for this.; // Use -Wno-array-bounds to suppress compiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. .. _alpha-security-MallocOverflow:. alpha.security.MallocOverflow (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for overflows in the arguments to ``malloc()``.; It tries to catch ``malloc(n * c)`` patterns, where:. - ``n``: a variable or member access of an object; - ``c``: a constant foldable integral. This checker was designed for code audits, so expect false-positive reports.; One is supposed to silence this checke",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:61374,Security,secur,security,61374," (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about buffer overflows (older checker). .. code-block:: c. void test() {; char *s = """";; char c = s[1]; // warn; }. struct seven_words {; int c[7];; };. void test() {; struct seven_words a, *p;; p = &a;; p[0] = a;; p[1] = a;; p[2] = a; // warn; }. // note: requires unix.Malloc or; // alpha.unix.MallocWithAnnotations checks enabled.; void test() {; int *p = malloc(12);; p[3] = 4; // warn; }. void test() {; char a[2];; int *b = (int*)a;; b[1] = 3; // warn; }. .. _alpha-security-ArrayBoundV2:. alpha.security.ArrayBoundV2 (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about buffer overflows (newer checker). .. code-block:: c. void test() {; char *s = """";; char c = s[1]; // warn; }. void test() {; int buf[100];; int *p = buf;; p = p + 99;; p[1] = 1; // warn; }. // note: compiler has internal check for this.; // Use -Wno-array-bounds to suppress compiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. .. _alpha-security-MallocOverflow:. alpha.security.MallocOverflow (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for overflows in the arguments to ``malloc()``.; It tries to catch ``malloc(n * c)`` patterns, where:. - ``n``: a variable or member access of an object; - ``c``: a constant foldable integral. This checker was designed for code audits, so expect false-positive reports.; One is supposed to silence this checker by ensuring proper bounds checking on; the variable in question using e.g. an ``assert()`` or a branch. .. code-block:: c. void test(int n) {; void *p = malloc(n * sizeof(int)); // warn; }. void test2(int n) {; if (n > 100) // gives an upper-bound; return;; void *p = malloc(n * sizeof(int)); // no warning; }. void test3(int n) {; assert(n <= 100 && ""Contract violated."");; void *p = malloc(n * sizeof(int)); // no warning; }. Limitations:. - The ch",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:61516,Security,secur,security-MallocOverflow,61516,"// warn; }. struct seven_words {; int c[7];; };. void test() {; struct seven_words a, *p;; p = &a;; p[0] = a;; p[1] = a;; p[2] = a; // warn; }. // note: requires unix.Malloc or; // alpha.unix.MallocWithAnnotations checks enabled.; void test() {; int *p = malloc(12);; p[3] = 4; // warn; }. void test() {; char a[2];; int *b = (int*)a;; b[1] = 3; // warn; }. .. _alpha-security-ArrayBoundV2:. alpha.security.ArrayBoundV2 (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about buffer overflows (newer checker). .. code-block:: c. void test() {; char *s = """";; char c = s[1]; // warn; }. void test() {; int buf[100];; int *p = buf;; p = p + 99;; p[1] = 1; // warn; }. // note: compiler has internal check for this.; // Use -Wno-array-bounds to suppress compiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. .. _alpha-security-MallocOverflow:. alpha.security.MallocOverflow (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for overflows in the arguments to ``malloc()``.; It tries to catch ``malloc(n * c)`` patterns, where:. - ``n``: a variable or member access of an object; - ``c``: a constant foldable integral. This checker was designed for code audits, so expect false-positive reports.; One is supposed to silence this checker by ensuring proper bounds checking on; the variable in question using e.g. an ``assert()`` or a branch. .. code-block:: c. void test(int n) {; void *p = malloc(n * sizeof(int)); // warn; }. void test2(int n) {; if (n > 100) // gives an upper-bound; return;; void *p = malloc(n * sizeof(int)); // no warning; }. void test3(int n) {; assert(n <= 100 && ""Contract violated."");; void *p = malloc(n * sizeof(int)); // no warning; }. Limitations:. - The checker won't warn for variables involved in explicit casts,; since that might limit the variable's domain.; E.g.: ``(unsigned char)int x`` would li",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:61548,Security,secur,security,61548,"ds {; int c[7];; };. void test() {; struct seven_words a, *p;; p = &a;; p[0] = a;; p[1] = a;; p[2] = a; // warn; }. // note: requires unix.Malloc or; // alpha.unix.MallocWithAnnotations checks enabled.; void test() {; int *p = malloc(12);; p[3] = 4; // warn; }. void test() {; char a[2];; int *b = (int*)a;; b[1] = 3; // warn; }. .. _alpha-security-ArrayBoundV2:. alpha.security.ArrayBoundV2 (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about buffer overflows (newer checker). .. code-block:: c. void test() {; char *s = """";; char c = s[1]; // warn; }. void test() {; int buf[100];; int *p = buf;; p = p + 99;; p[1] = 1; // warn; }. // note: compiler has internal check for this.; // Use -Wno-array-bounds to suppress compiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. .. _alpha-security-MallocOverflow:. alpha.security.MallocOverflow (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for overflows in the arguments to ``malloc()``.; It tries to catch ``malloc(n * c)`` patterns, where:. - ``n``: a variable or member access of an object; - ``c``: a constant foldable integral. This checker was designed for code audits, so expect false-positive reports.; One is supposed to silence this checker by ensuring proper bounds checking on; the variable in question using e.g. an ``assert()`` or a branch. .. code-block:: c. void test(int n) {; void *p = malloc(n * sizeof(int)); // warn; }. void test2(int n) {; if (n > 100) // gives an upper-bound; return;; void *p = malloc(n * sizeof(int)); // no warning; }. void test3(int n) {; assert(n <= 100 && ""Contract violated."");; void *p = malloc(n * sizeof(int)); // no warning; }. Limitations:. - The checker won't warn for variables involved in explicit casts,; since that might limit the variable's domain.; E.g.: ``(unsigned char)int x`` would limit the domain to ``[0,255]`",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:61751,Security,access,access,61751,") {; int *p = malloc(12);; p[3] = 4; // warn; }. void test() {; char a[2];; int *b = (int*)a;; b[1] = 3; // warn; }. .. _alpha-security-ArrayBoundV2:. alpha.security.ArrayBoundV2 (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about buffer overflows (newer checker). .. code-block:: c. void test() {; char *s = """";; char c = s[1]; // warn; }. void test() {; int buf[100];; int *p = buf;; p = p + 99;; p[1] = 1; // warn; }. // note: compiler has internal check for this.; // Use -Wno-array-bounds to suppress compiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. .. _alpha-security-MallocOverflow:. alpha.security.MallocOverflow (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for overflows in the arguments to ``malloc()``.; It tries to catch ``malloc(n * c)`` patterns, where:. - ``n``: a variable or member access of an object; - ``c``: a constant foldable integral. This checker was designed for code audits, so expect false-positive reports.; One is supposed to silence this checker by ensuring proper bounds checking on; the variable in question using e.g. an ``assert()`` or a branch. .. code-block:: c. void test(int n) {; void *p = malloc(n * sizeof(int)); // warn; }. void test2(int n) {; if (n > 100) // gives an upper-bound; return;; void *p = malloc(n * sizeof(int)); // no warning; }. void test3(int n) {; assert(n <= 100 && ""Contract violated."");; void *p = malloc(n * sizeof(int)); // no warning; }. Limitations:. - The checker won't warn for variables involved in explicit casts,; since that might limit the variable's domain.; E.g.: ``(unsigned char)int x`` would limit the domain to ``[0,255]``.; The checker will miss the true-positive cases when the explicit cast would; not tighten the domain to prevent the overflow in the subsequent; multiplication operation. - It is an AST-based checker, thus it do",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:61846,Security,audit,audits,61846,"= (int*)a;; b[1] = 3; // warn; }. .. _alpha-security-ArrayBoundV2:. alpha.security.ArrayBoundV2 (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about buffer overflows (newer checker). .. code-block:: c. void test() {; char *s = """";; char c = s[1]; // warn; }. void test() {; int buf[100];; int *p = buf;; p = p + 99;; p[1] = 1; // warn; }. // note: compiler has internal check for this.; // Use -Wno-array-bounds to suppress compiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. .. _alpha-security-MallocOverflow:. alpha.security.MallocOverflow (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for overflows in the arguments to ``malloc()``.; It tries to catch ``malloc(n * c)`` patterns, where:. - ``n``: a variable or member access of an object; - ``c``: a constant foldable integral. This checker was designed for code audits, so expect false-positive reports.; One is supposed to silence this checker by ensuring proper bounds checking on; the variable in question using e.g. an ``assert()`` or a branch. .. code-block:: c. void test(int n) {; void *p = malloc(n * sizeof(int)); // warn; }. void test2(int n) {; if (n > 100) // gives an upper-bound; return;; void *p = malloc(n * sizeof(int)); // no warning; }. void test3(int n) {; assert(n <= 100 && ""Contract violated."");; void *p = malloc(n * sizeof(int)); // no warning; }. Limitations:. - The checker won't warn for variables involved in explicit casts,; since that might limit the variable's domain.; E.g.: ``(unsigned char)int x`` would limit the domain to ``[0,255]``.; The checker will miss the true-positive cases when the explicit cast would; not tighten the domain to prevent the overflow in the subsequent; multiplication operation. - It is an AST-based checker, thus it does not make use of the; path-sensitive taint-analysis. .. _alpha-security-MmapWriteE",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:62830,Security,secur,security-MmapWriteExec,62830,"or code audits, so expect false-positive reports.; One is supposed to silence this checker by ensuring proper bounds checking on; the variable in question using e.g. an ``assert()`` or a branch. .. code-block:: c. void test(int n) {; void *p = malloc(n * sizeof(int)); // warn; }. void test2(int n) {; if (n > 100) // gives an upper-bound; return;; void *p = malloc(n * sizeof(int)); // no warning; }. void test3(int n) {; assert(n <= 100 && ""Contract violated."");; void *p = malloc(n * sizeof(int)); // no warning; }. Limitations:. - The checker won't warn for variables involved in explicit casts,; since that might limit the variable's domain.; E.g.: ``(unsigned char)int x`` would limit the domain to ``[0,255]``.; The checker will miss the true-positive cases when the explicit cast would; not tighten the domain to prevent the overflow in the subsequent; multiplication operation. - It is an AST-based checker, thus it does not make use of the; path-sensitive taint-analysis. .. _alpha-security-MmapWriteExec:. alpha.security.MmapWriteExec (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on mmap() calls that are both writable and executable. .. code-block:: c. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. .. _alpha-security-ReturnPtrRange:. alpha.security.ReturnPtrRange (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for an out-of-bound pointer being returned to callers. .. code-block:: c. static int A[10];. int *test() {; int *p = A + 10;; return p; // warn; }. int test(void) {; int x;; return x; // warn: undefined or garbage returned; }. alpha.security.cert; ^^^^^^^^^^^^^^^^^^^. SEI CERT checkers which tries to find errors based on their `C coding rules <https://wiki.sei.cmu.edu/confluence/display/c/2+Rules>`_. .. _alpha-security-cert-pos-checkers:. alpha.se",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:62861,Security,secur,security,62861,"alse-positive reports.; One is supposed to silence this checker by ensuring proper bounds checking on; the variable in question using e.g. an ``assert()`` or a branch. .. code-block:: c. void test(int n) {; void *p = malloc(n * sizeof(int)); // warn; }. void test2(int n) {; if (n > 100) // gives an upper-bound; return;; void *p = malloc(n * sizeof(int)); // no warning; }. void test3(int n) {; assert(n <= 100 && ""Contract violated."");; void *p = malloc(n * sizeof(int)); // no warning; }. Limitations:. - The checker won't warn for variables involved in explicit casts,; since that might limit the variable's domain.; E.g.: ``(unsigned char)int x`` would limit the domain to ``[0,255]``.; The checker will miss the true-positive cases when the explicit cast would; not tighten the domain to prevent the overflow in the subsequent; multiplication operation. - It is an AST-based checker, thus it does not make use of the; path-sensitive taint-analysis. .. _alpha-security-MmapWriteExec:. alpha.security.MmapWriteExec (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on mmap() calls that are both writable and executable. .. code-block:: c. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. .. _alpha-security-ReturnPtrRange:. alpha.security.ReturnPtrRange (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for an out-of-bound pointer being returned to callers. .. code-block:: c. static int A[10];. int *test() {; int *p = A + 10;; return p; // warn; }. int test(void) {; int x;; return x; // warn: undefined or garbage returned; }. alpha.security.cert; ^^^^^^^^^^^^^^^^^^^. SEI CERT checkers which tries to find errors based on their `C coding rules <https://wiki.sei.cmu.edu/confluence/display/c/2+Rules>`_. .. _alpha-security-cert-pos-checkers:. alpha.security.cert.pos; ^^^^^^^^^^^",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:63285,Security,secur,security-ReturnPtrRange,63285,"lated."");; void *p = malloc(n * sizeof(int)); // no warning; }. Limitations:. - The checker won't warn for variables involved in explicit casts,; since that might limit the variable's domain.; E.g.: ``(unsigned char)int x`` would limit the domain to ``[0,255]``.; The checker will miss the true-positive cases when the explicit cast would; not tighten the domain to prevent the overflow in the subsequent; multiplication operation. - It is an AST-based checker, thus it does not make use of the; path-sensitive taint-analysis. .. _alpha-security-MmapWriteExec:. alpha.security.MmapWriteExec (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on mmap() calls that are both writable and executable. .. code-block:: c. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. .. _alpha-security-ReturnPtrRange:. alpha.security.ReturnPtrRange (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for an out-of-bound pointer being returned to callers. .. code-block:: c. static int A[10];. int *test() {; int *p = A + 10;; return p; // warn; }. int test(void) {; int x;; return x; // warn: undefined or garbage returned; }. alpha.security.cert; ^^^^^^^^^^^^^^^^^^^. SEI CERT checkers which tries to find errors based on their `C coding rules <https://wiki.sei.cmu.edu/confluence/display/c/2+Rules>`_. .. _alpha-security-cert-pos-checkers:. alpha.security.cert.pos; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `POSIX C coding rules <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152405>`_. .. _alpha-security-cert-pos-34c:. alpha.security.cert.pos.34c; """"""""""""""""""""""""""""""""""""""""""""""""""""""; Finds calls to the ``putenv`` function which pass a pointer to an automatic variable as the argument. .. code-block:: c. int func(const char *var) {; char env[1024];; int retval = snprintf(env, sizeof",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:63317,Security,secur,security,63317,"n * sizeof(int)); // no warning; }. Limitations:. - The checker won't warn for variables involved in explicit casts,; since that might limit the variable's domain.; E.g.: ``(unsigned char)int x`` would limit the domain to ``[0,255]``.; The checker will miss the true-positive cases when the explicit cast would; not tighten the domain to prevent the overflow in the subsequent; multiplication operation. - It is an AST-based checker, thus it does not make use of the; path-sensitive taint-analysis. .. _alpha-security-MmapWriteExec:. alpha.security.MmapWriteExec (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on mmap() calls that are both writable and executable. .. code-block:: c. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. .. _alpha-security-ReturnPtrRange:. alpha.security.ReturnPtrRange (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for an out-of-bound pointer being returned to callers. .. code-block:: c. static int A[10];. int *test() {; int *p = A + 10;; return p; // warn; }. int test(void) {; int x;; return x; // warn: undefined or garbage returned; }. alpha.security.cert; ^^^^^^^^^^^^^^^^^^^. SEI CERT checkers which tries to find errors based on their `C coding rules <https://wiki.sei.cmu.edu/confluence/display/c/2+Rules>`_. .. _alpha-security-cert-pos-checkers:. alpha.security.cert.pos; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `POSIX C coding rules <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152405>`_. .. _alpha-security-cert-pos-34c:. alpha.security.cert.pos.34c; """"""""""""""""""""""""""""""""""""""""""""""""""""""; Finds calls to the ``putenv`` function which pass a pointer to an automatic variable as the argument. .. code-block:: c. int func(const char *var) {; char env[1024];; int retval = snprintf(env, sizeof(env),""TEST=%s"", var);; if (",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:63620,Security,secur,security,63620,"t would; not tighten the domain to prevent the overflow in the subsequent; multiplication operation. - It is an AST-based checker, thus it does not make use of the; path-sensitive taint-analysis. .. _alpha-security-MmapWriteExec:. alpha.security.MmapWriteExec (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on mmap() calls that are both writable and executable. .. code-block:: c. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. .. _alpha-security-ReturnPtrRange:. alpha.security.ReturnPtrRange (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for an out-of-bound pointer being returned to callers. .. code-block:: c. static int A[10];. int *test() {; int *p = A + 10;; return p; // warn; }. int test(void) {; int x;; return x; // warn: undefined or garbage returned; }. alpha.security.cert; ^^^^^^^^^^^^^^^^^^^. SEI CERT checkers which tries to find errors based on their `C coding rules <https://wiki.sei.cmu.edu/confluence/display/c/2+Rules>`_. .. _alpha-security-cert-pos-checkers:. alpha.security.cert.pos; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `POSIX C coding rules <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152405>`_. .. _alpha-security-cert-pos-34c:. alpha.security.cert.pos.34c; """"""""""""""""""""""""""""""""""""""""""""""""""""""; Finds calls to the ``putenv`` function which pass a pointer to an automatic variable as the argument. .. code-block:: c. int func(const char *var) {; char env[1024];; int retval = snprintf(env, sizeof(env),""TEST=%s"", var);; if (retval < 0 || (size_t)retval >= sizeof(env)) {; /* Handle error */; }. return putenv(env); // putenv function should not be called with auto variables; }. Limitations:. - Technically, one can pass automatic variables to ``putenv``,; but one needs to ensure that the given environment key stays; alive un",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:63801,Security,secur,security-cert-pos-checkers,63801,"nalysis. .. _alpha-security-MmapWriteExec:. alpha.security.MmapWriteExec (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on mmap() calls that are both writable and executable. .. code-block:: c. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. .. _alpha-security-ReturnPtrRange:. alpha.security.ReturnPtrRange (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for an out-of-bound pointer being returned to callers. .. code-block:: c. static int A[10];. int *test() {; int *p = A + 10;; return p; // warn; }. int test(void) {; int x;; return x; // warn: undefined or garbage returned; }. alpha.security.cert; ^^^^^^^^^^^^^^^^^^^. SEI CERT checkers which tries to find errors based on their `C coding rules <https://wiki.sei.cmu.edu/confluence/display/c/2+Rules>`_. .. _alpha-security-cert-pos-checkers:. alpha.security.cert.pos; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `POSIX C coding rules <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152405>`_. .. _alpha-security-cert-pos-34c:. alpha.security.cert.pos.34c; """"""""""""""""""""""""""""""""""""""""""""""""""""""; Finds calls to the ``putenv`` function which pass a pointer to an automatic variable as the argument. .. code-block:: c. int func(const char *var) {; char env[1024];; int retval = snprintf(env, sizeof(env),""TEST=%s"", var);; if (retval < 0 || (size_t)retval >= sizeof(env)) {; /* Handle error */; }. return putenv(env); // putenv function should not be called with auto variables; }. Limitations:. - Technically, one can pass automatic variables to ``putenv``,; but one needs to ensure that the given environment key stays; alive until it's removed or overwritten.; Since the analyzer cannot keep track of which envvars get overwritten; and when, it needs to be slightly more aggressive and warn for such; cases too, l",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:63836,Security,secur,security,63836,"mapWriteExec:. alpha.security.MmapWriteExec (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on mmap() calls that are both writable and executable. .. code-block:: c. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. .. _alpha-security-ReturnPtrRange:. alpha.security.ReturnPtrRange (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for an out-of-bound pointer being returned to callers. .. code-block:: c. static int A[10];. int *test() {; int *p = A + 10;; return p; // warn; }. int test(void) {; int x;; return x; // warn: undefined or garbage returned; }. alpha.security.cert; ^^^^^^^^^^^^^^^^^^^. SEI CERT checkers which tries to find errors based on their `C coding rules <https://wiki.sei.cmu.edu/confluence/display/c/2+Rules>`_. .. _alpha-security-cert-pos-checkers:. alpha.security.cert.pos; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `POSIX C coding rules <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152405>`_. .. _alpha-security-cert-pos-34c:. alpha.security.cert.pos.34c; """"""""""""""""""""""""""""""""""""""""""""""""""""""; Finds calls to the ``putenv`` function which pass a pointer to an automatic variable as the argument. .. code-block:: c. int func(const char *var) {; char env[1024];; int retval = snprintf(env, sizeof(env),""TEST=%s"", var);; if (retval < 0 || (size_t)retval >= sizeof(env)) {; /* Handle error */; }. return putenv(env); // putenv function should not be called with auto variables; }. Limitations:. - Technically, one can pass automatic variables to ``putenv``,; but one needs to ensure that the given environment key stays; alive until it's removed or overwritten.; Since the analyzer cannot keep track of which envvars get overwritten; and when, it needs to be slightly more aggressive and warn for such; cases too, leading in some cases to false-",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:64012,Security,secur,security-cert-pos-,64012,"{; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. .. _alpha-security-ReturnPtrRange:. alpha.security.ReturnPtrRange (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for an out-of-bound pointer being returned to callers. .. code-block:: c. static int A[10];. int *test() {; int *p = A + 10;; return p; // warn; }. int test(void) {; int x;; return x; // warn: undefined or garbage returned; }. alpha.security.cert; ^^^^^^^^^^^^^^^^^^^. SEI CERT checkers which tries to find errors based on their `C coding rules <https://wiki.sei.cmu.edu/confluence/display/c/2+Rules>`_. .. _alpha-security-cert-pos-checkers:. alpha.security.cert.pos; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `POSIX C coding rules <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152405>`_. .. _alpha-security-cert-pos-34c:. alpha.security.cert.pos.34c; """"""""""""""""""""""""""""""""""""""""""""""""""""""; Finds calls to the ``putenv`` function which pass a pointer to an automatic variable as the argument. .. code-block:: c. int func(const char *var) {; char env[1024];; int retval = snprintf(env, sizeof(env),""TEST=%s"", var);; if (retval < 0 || (size_t)retval >= sizeof(env)) {; /* Handle error */; }. return putenv(env); // putenv function should not be called with auto variables; }. Limitations:. - Technically, one can pass automatic variables to ``putenv``,; but one needs to ensure that the given environment key stays; alive until it's removed or overwritten.; Since the analyzer cannot keep track of which envvars get overwritten; and when, it needs to be slightly more aggressive and warn for such; cases too, leading in some cases to false-positive reports like this:. .. code-block:: c. void baz() {; char env[] = ""NAME=value"";; putenv(env); // false-positive warning: putenv function should not be called...; // More ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:64042,Security,secur,security,64042," PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. .. _alpha-security-ReturnPtrRange:. alpha.security.ReturnPtrRange (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for an out-of-bound pointer being returned to callers. .. code-block:: c. static int A[10];. int *test() {; int *p = A + 10;; return p; // warn; }. int test(void) {; int x;; return x; // warn: undefined or garbage returned; }. alpha.security.cert; ^^^^^^^^^^^^^^^^^^^. SEI CERT checkers which tries to find errors based on their `C coding rules <https://wiki.sei.cmu.edu/confluence/display/c/2+Rules>`_. .. _alpha-security-cert-pos-checkers:. alpha.security.cert.pos; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `POSIX C coding rules <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152405>`_. .. _alpha-security-cert-pos-34c:. alpha.security.cert.pos.34c; """"""""""""""""""""""""""""""""""""""""""""""""""""""; Finds calls to the ``putenv`` function which pass a pointer to an automatic variable as the argument. .. code-block:: c. int func(const char *var) {; char env[1024];; int retval = snprintf(env, sizeof(env),""TEST=%s"", var);; if (retval < 0 || (size_t)retval >= sizeof(env)) {; /* Handle error */; }. return putenv(env); // putenv function should not be called with auto variables; }. Limitations:. - Technically, one can pass automatic variables to ``putenv``,; but one needs to ensure that the given environment key stays; alive until it's removed or overwritten.; Since the analyzer cannot keep track of which envvars get overwritten; and when, it needs to be slightly more aggressive and warn for such; cases too, leading in some cases to false-positive reports like this:. .. code-block:: c. void baz() {; char env[] = ""NAME=value"";; putenv(env); // false-positive warning: putenv function should not be called...; // More code...; putenv((char *)""NA",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:65198,Security,secur,security,65198,"e-block:: c. int func(const char *var) {; char env[1024];; int retval = snprintf(env, sizeof(env),""TEST=%s"", var);; if (retval < 0 || (size_t)retval >= sizeof(env)) {; /* Handle error */; }. return putenv(env); // putenv function should not be called with auto variables; }. Limitations:. - Technically, one can pass automatic variables to ``putenv``,; but one needs to ensure that the given environment key stays; alive until it's removed or overwritten.; Since the analyzer cannot keep track of which envvars get overwritten; and when, it needs to be slightly more aggressive and warn for such; cases too, leading in some cases to false-positive reports like this:. .. code-block:: c. void baz() {; char env[] = ""NAME=value"";; putenv(env); // false-positive warning: putenv function should not be called...; // More code...; putenv((char *)""NAME=anothervalue"");; // This putenv call overwrites the previous entry, thus that can no longer dangle.; } // 'env' array becomes dead only here. alpha.security.cert.env; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `Environment C coding rules <https://wiki.sei.cmu.edu/confluence/x/JdcxBQ>`_. alpha.security.taint; ^^^^^^^^^^^^^^^^^^^^. Checkers implementing; `taint analysis <https://en.wikipedia.org/wiki/Taint_checking>`_. .. _alpha-security-taint-TaintPropagation:. alpha.security.taint.TaintPropagation (C, C++); """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Taint analysis identifies potential security vulnerabilities where the; attacker can inject malicious data to the program to execute an attack; (privilege escalation, command injection, SQL injection etc.). The malicious data is injected at the taint source (e.g. ``getenv()`` call); which is then propagated through function calls and being used as arguments of; sensitive operations, also called as taint sinks (e.g. ``system()`` call). One can defend against this type of vulnerability by always checking and; sanitizing the potentially malicious, untrusted user input. The goal of the ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:65347,Security,secur,security,65347,">= sizeof(env)) {; /* Handle error */; }. return putenv(env); // putenv function should not be called with auto variables; }. Limitations:. - Technically, one can pass automatic variables to ``putenv``,; but one needs to ensure that the given environment key stays; alive until it's removed or overwritten.; Since the analyzer cannot keep track of which envvars get overwritten; and when, it needs to be slightly more aggressive and warn for such; cases too, leading in some cases to false-positive reports like this:. .. code-block:: c. void baz() {; char env[] = ""NAME=value"";; putenv(env); // false-positive warning: putenv function should not be called...; // More code...; putenv((char *)""NAME=anothervalue"");; // This putenv call overwrites the previous entry, thus that can no longer dangle.; } // 'env' array becomes dead only here. alpha.security.cert.env; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `Environment C coding rules <https://wiki.sei.cmu.edu/confluence/x/JdcxBQ>`_. alpha.security.taint; ^^^^^^^^^^^^^^^^^^^^. Checkers implementing; `taint analysis <https://en.wikipedia.org/wiki/Taint_checking>`_. .. _alpha-security-taint-TaintPropagation:. alpha.security.taint.TaintPropagation (C, C++); """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Taint analysis identifies potential security vulnerabilities where the; attacker can inject malicious data to the program to execute an attack; (privilege escalation, command injection, SQL injection etc.). The malicious data is injected at the taint source (e.g. ``getenv()`` call); which is then propagated through function calls and being used as arguments of; sensitive operations, also called as taint sinks (e.g. ``system()`` call). One can defend against this type of vulnerability by always checking and; sanitizing the potentially malicious, untrusted user input. The goal of the checker is to discover and show to the user these potential; taint source-sink pairs and the propagation call chain. The most notable examples of tai",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:65484,Security,secur,security-taint-TaintPropagation,65484,"hnically, one can pass automatic variables to ``putenv``,; but one needs to ensure that the given environment key stays; alive until it's removed or overwritten.; Since the analyzer cannot keep track of which envvars get overwritten; and when, it needs to be slightly more aggressive and warn for such; cases too, leading in some cases to false-positive reports like this:. .. code-block:: c. void baz() {; char env[] = ""NAME=value"";; putenv(env); // false-positive warning: putenv function should not be called...; // More code...; putenv((char *)""NAME=anothervalue"");; // This putenv call overwrites the previous entry, thus that can no longer dangle.; } // 'env' array becomes dead only here. alpha.security.cert.env; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `Environment C coding rules <https://wiki.sei.cmu.edu/confluence/x/JdcxBQ>`_. alpha.security.taint; ^^^^^^^^^^^^^^^^^^^^. Checkers implementing; `taint analysis <https://en.wikipedia.org/wiki/Taint_checking>`_. .. _alpha-security-taint-TaintPropagation:. alpha.security.taint.TaintPropagation (C, C++); """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Taint analysis identifies potential security vulnerabilities where the; attacker can inject malicious data to the program to execute an attack; (privilege escalation, command injection, SQL injection etc.). The malicious data is injected at the taint source (e.g. ``getenv()`` call); which is then propagated through function calls and being used as arguments of; sensitive operations, also called as taint sinks (e.g. ``system()`` call). One can defend against this type of vulnerability by always checking and; sanitizing the potentially malicious, untrusted user input. The goal of the checker is to discover and show to the user these potential; taint source-sink pairs and the propagation call chain. The most notable examples of taint sources are:. - data from network; - files or standard input; - environment variables; - data from databases. Let us examine a practical examp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:65524,Security,secur,security,65524," variables to ``putenv``,; but one needs to ensure that the given environment key stays; alive until it's removed or overwritten.; Since the analyzer cannot keep track of which envvars get overwritten; and when, it needs to be slightly more aggressive and warn for such; cases too, leading in some cases to false-positive reports like this:. .. code-block:: c. void baz() {; char env[] = ""NAME=value"";; putenv(env); // false-positive warning: putenv function should not be called...; // More code...; putenv((char *)""NAME=anothervalue"");; // This putenv call overwrites the previous entry, thus that can no longer dangle.; } // 'env' array becomes dead only here. alpha.security.cert.env; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `Environment C coding rules <https://wiki.sei.cmu.edu/confluence/x/JdcxBQ>`_. alpha.security.taint; ^^^^^^^^^^^^^^^^^^^^. Checkers implementing; `taint analysis <https://en.wikipedia.org/wiki/Taint_checking>`_. .. _alpha-security-taint-TaintPropagation:. alpha.security.taint.TaintPropagation (C, C++); """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Taint analysis identifies potential security vulnerabilities where the; attacker can inject malicious data to the program to execute an attack; (privilege escalation, command injection, SQL injection etc.). The malicious data is injected at the taint source (e.g. ``getenv()`` call); which is then propagated through function calls and being used as arguments of; sensitive operations, also called as taint sinks (e.g. ``system()`` call). One can defend against this type of vulnerability by always checking and; sanitizing the potentially malicious, untrusted user input. The goal of the checker is to discover and show to the user these potential; taint source-sink pairs and the propagation call chain. The most notable examples of taint sources are:. - data from network; - files or standard input; - environment variables; - data from databases. Let us examine a practical example of a Command Injection attack",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:65650,Security,secur,security,65650,"t overwritten; and when, it needs to be slightly more aggressive and warn for such; cases too, leading in some cases to false-positive reports like this:. .. code-block:: c. void baz() {; char env[] = ""NAME=value"";; putenv(env); // false-positive warning: putenv function should not be called...; // More code...; putenv((char *)""NAME=anothervalue"");; // This putenv call overwrites the previous entry, thus that can no longer dangle.; } // 'env' array becomes dead only here. alpha.security.cert.env; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `Environment C coding rules <https://wiki.sei.cmu.edu/confluence/x/JdcxBQ>`_. alpha.security.taint; ^^^^^^^^^^^^^^^^^^^^. Checkers implementing; `taint analysis <https://en.wikipedia.org/wiki/Taint_checking>`_. .. _alpha-security-taint-TaintPropagation:. alpha.security.taint.TaintPropagation (C, C++); """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Taint analysis identifies potential security vulnerabilities where the; attacker can inject malicious data to the program to execute an attack; (privilege escalation, command injection, SQL injection etc.). The malicious data is injected at the taint source (e.g. ``getenv()`` call); which is then propagated through function calls and being used as arguments of; sensitive operations, also called as taint sinks (e.g. ``system()`` call). One can defend against this type of vulnerability by always checking and; sanitizing the potentially malicious, untrusted user input. The goal of the checker is to discover and show to the user these potential; taint source-sink pairs and the propagation call chain. The most notable examples of taint sources are:. - data from network; - files or standard input; - environment variables; - data from databases. Let us examine a practical example of a Command Injection attack. .. code-block:: c. // Command Injection Vulnerability Example; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %10",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:65686,Security,attack,attacker,65686,"t overwritten; and when, it needs to be slightly more aggressive and warn for such; cases too, leading in some cases to false-positive reports like this:. .. code-block:: c. void baz() {; char env[] = ""NAME=value"";; putenv(env); // false-positive warning: putenv function should not be called...; // More code...; putenv((char *)""NAME=anothervalue"");; // This putenv call overwrites the previous entry, thus that can no longer dangle.; } // 'env' array becomes dead only here. alpha.security.cert.env; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `Environment C coding rules <https://wiki.sei.cmu.edu/confluence/x/JdcxBQ>`_. alpha.security.taint; ^^^^^^^^^^^^^^^^^^^^. Checkers implementing; `taint analysis <https://en.wikipedia.org/wiki/Taint_checking>`_. .. _alpha-security-taint-TaintPropagation:. alpha.security.taint.TaintPropagation (C, C++); """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Taint analysis identifies potential security vulnerabilities where the; attacker can inject malicious data to the program to execute an attack; (privilege escalation, command injection, SQL injection etc.). The malicious data is injected at the taint source (e.g. ``getenv()`` call); which is then propagated through function calls and being used as arguments of; sensitive operations, also called as taint sinks (e.g. ``system()`` call). One can defend against this type of vulnerability by always checking and; sanitizing the potentially malicious, untrusted user input. The goal of the checker is to discover and show to the user these potential; taint source-sink pairs and the propagation call chain. The most notable examples of taint sources are:. - data from network; - files or standard input; - environment variables; - data from databases. Let us examine a practical example of a Command Injection attack. .. code-block:: c. // Command Injection Vulnerability Example; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %10",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:65699,Security,inject,inject,65699,"t overwritten; and when, it needs to be slightly more aggressive and warn for such; cases too, leading in some cases to false-positive reports like this:. .. code-block:: c. void baz() {; char env[] = ""NAME=value"";; putenv(env); // false-positive warning: putenv function should not be called...; // More code...; putenv((char *)""NAME=anothervalue"");; // This putenv call overwrites the previous entry, thus that can no longer dangle.; } // 'env' array becomes dead only here. alpha.security.cert.env; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `Environment C coding rules <https://wiki.sei.cmu.edu/confluence/x/JdcxBQ>`_. alpha.security.taint; ^^^^^^^^^^^^^^^^^^^^. Checkers implementing; `taint analysis <https://en.wikipedia.org/wiki/Taint_checking>`_. .. _alpha-security-taint-TaintPropagation:. alpha.security.taint.TaintPropagation (C, C++); """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Taint analysis identifies potential security vulnerabilities where the; attacker can inject malicious data to the program to execute an attack; (privilege escalation, command injection, SQL injection etc.). The malicious data is injected at the taint source (e.g. ``getenv()`` call); which is then propagated through function calls and being used as arguments of; sensitive operations, also called as taint sinks (e.g. ``system()`` call). One can defend against this type of vulnerability by always checking and; sanitizing the potentially malicious, untrusted user input. The goal of the checker is to discover and show to the user these potential; taint source-sink pairs and the propagation call chain. The most notable examples of taint sources are:. - data from network; - files or standard input; - environment variables; - data from databases. Let us examine a practical example of a Command Injection attack. .. code-block:: c. // Command Injection Vulnerability Example; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %10",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:65750,Security,attack,attack,65750,"t overwritten; and when, it needs to be slightly more aggressive and warn for such; cases too, leading in some cases to false-positive reports like this:. .. code-block:: c. void baz() {; char env[] = ""NAME=value"";; putenv(env); // false-positive warning: putenv function should not be called...; // More code...; putenv((char *)""NAME=anothervalue"");; // This putenv call overwrites the previous entry, thus that can no longer dangle.; } // 'env' array becomes dead only here. alpha.security.cert.env; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `Environment C coding rules <https://wiki.sei.cmu.edu/confluence/x/JdcxBQ>`_. alpha.security.taint; ^^^^^^^^^^^^^^^^^^^^. Checkers implementing; `taint analysis <https://en.wikipedia.org/wiki/Taint_checking>`_. .. _alpha-security-taint-TaintPropagation:. alpha.security.taint.TaintPropagation (C, C++); """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Taint analysis identifies potential security vulnerabilities where the; attacker can inject malicious data to the program to execute an attack; (privilege escalation, command injection, SQL injection etc.). The malicious data is injected at the taint source (e.g. ``getenv()`` call); which is then propagated through function calls and being used as arguments of; sensitive operations, also called as taint sinks (e.g. ``system()`` call). One can defend against this type of vulnerability by always checking and; sanitizing the potentially malicious, untrusted user input. The goal of the checker is to discover and show to the user these potential; taint source-sink pairs and the propagation call chain. The most notable examples of taint sources are:. - data from network; - files or standard input; - environment variables; - data from databases. Let us examine a practical example of a Command Injection attack. .. code-block:: c. // Command Injection Vulnerability Example; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %10",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:65789,Security,inject,injection,65789,"t overwritten; and when, it needs to be slightly more aggressive and warn for such; cases too, leading in some cases to false-positive reports like this:. .. code-block:: c. void baz() {; char env[] = ""NAME=value"";; putenv(env); // false-positive warning: putenv function should not be called...; // More code...; putenv((char *)""NAME=anothervalue"");; // This putenv call overwrites the previous entry, thus that can no longer dangle.; } // 'env' array becomes dead only here. alpha.security.cert.env; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `Environment C coding rules <https://wiki.sei.cmu.edu/confluence/x/JdcxBQ>`_. alpha.security.taint; ^^^^^^^^^^^^^^^^^^^^. Checkers implementing; `taint analysis <https://en.wikipedia.org/wiki/Taint_checking>`_. .. _alpha-security-taint-TaintPropagation:. alpha.security.taint.TaintPropagation (C, C++); """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Taint analysis identifies potential security vulnerabilities where the; attacker can inject malicious data to the program to execute an attack; (privilege escalation, command injection, SQL injection etc.). The malicious data is injected at the taint source (e.g. ``getenv()`` call); which is then propagated through function calls and being used as arguments of; sensitive operations, also called as taint sinks (e.g. ``system()`` call). One can defend against this type of vulnerability by always checking and; sanitizing the potentially malicious, untrusted user input. The goal of the checker is to discover and show to the user these potential; taint source-sink pairs and the propagation call chain. The most notable examples of taint sources are:. - data from network; - files or standard input; - environment variables; - data from databases. Let us examine a practical example of a Command Injection attack. .. code-block:: c. // Command Injection Vulnerability Example; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %10",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:65804,Security,inject,injection,65804,"t overwritten; and when, it needs to be slightly more aggressive and warn for such; cases too, leading in some cases to false-positive reports like this:. .. code-block:: c. void baz() {; char env[] = ""NAME=value"";; putenv(env); // false-positive warning: putenv function should not be called...; // More code...; putenv((char *)""NAME=anothervalue"");; // This putenv call overwrites the previous entry, thus that can no longer dangle.; } // 'env' array becomes dead only here. alpha.security.cert.env; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `Environment C coding rules <https://wiki.sei.cmu.edu/confluence/x/JdcxBQ>`_. alpha.security.taint; ^^^^^^^^^^^^^^^^^^^^. Checkers implementing; `taint analysis <https://en.wikipedia.org/wiki/Taint_checking>`_. .. _alpha-security-taint-TaintPropagation:. alpha.security.taint.TaintPropagation (C, C++); """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Taint analysis identifies potential security vulnerabilities where the; attacker can inject malicious data to the program to execute an attack; (privilege escalation, command injection, SQL injection etc.). The malicious data is injected at the taint source (e.g. ``getenv()`` call); which is then propagated through function calls and being used as arguments of; sensitive operations, also called as taint sinks (e.g. ``system()`` call). One can defend against this type of vulnerability by always checking and; sanitizing the potentially malicious, untrusted user input. The goal of the checker is to discover and show to the user these potential; taint source-sink pairs and the propagation call chain. The most notable examples of taint sources are:. - data from network; - files or standard input; - environment variables; - data from databases. Let us examine a practical example of a Command Injection attack. .. code-block:: c. // Command Injection Vulnerability Example; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %10",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:65843,Security,inject,injected,65843,"ve reports like this:. .. code-block:: c. void baz() {; char env[] = ""NAME=value"";; putenv(env); // false-positive warning: putenv function should not be called...; // More code...; putenv((char *)""NAME=anothervalue"");; // This putenv call overwrites the previous entry, thus that can no longer dangle.; } // 'env' array becomes dead only here. alpha.security.cert.env; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `Environment C coding rules <https://wiki.sei.cmu.edu/confluence/x/JdcxBQ>`_. alpha.security.taint; ^^^^^^^^^^^^^^^^^^^^. Checkers implementing; `taint analysis <https://en.wikipedia.org/wiki/Taint_checking>`_. .. _alpha-security-taint-TaintPropagation:. alpha.security.taint.TaintPropagation (C, C++); """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Taint analysis identifies potential security vulnerabilities where the; attacker can inject malicious data to the program to execute an attack; (privilege escalation, command injection, SQL injection etc.). The malicious data is injected at the taint source (e.g. ``getenv()`` call); which is then propagated through function calls and being used as arguments of; sensitive operations, also called as taint sinks (e.g. ``system()`` call). One can defend against this type of vulnerability by always checking and; sanitizing the potentially malicious, untrusted user input. The goal of the checker is to discover and show to the user these potential; taint source-sink pairs and the propagation call chain. The most notable examples of taint sources are:. - data from network; - files or standard input; - environment variables; - data from databases. Let us examine a practical example of a Command Injection attack. .. code-block:: c. // Command Injection Vulnerability Example; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; strcat(cmd, filename);; system(cmd); // Warning: Untrusted data",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:66127,Security,sanitiz,sanitizing,66127,"hus that can no longer dangle.; } // 'env' array becomes dead only here. alpha.security.cert.env; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `Environment C coding rules <https://wiki.sei.cmu.edu/confluence/x/JdcxBQ>`_. alpha.security.taint; ^^^^^^^^^^^^^^^^^^^^. Checkers implementing; `taint analysis <https://en.wikipedia.org/wiki/Taint_checking>`_. .. _alpha-security-taint-TaintPropagation:. alpha.security.taint.TaintPropagation (C, C++); """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Taint analysis identifies potential security vulnerabilities where the; attacker can inject malicious data to the program to execute an attack; (privilege escalation, command injection, SQL injection etc.). The malicious data is injected at the taint source (e.g. ``getenv()`` call); which is then propagated through function calls and being used as arguments of; sensitive operations, also called as taint sinks (e.g. ``system()`` call). One can defend against this type of vulnerability by always checking and; sanitizing the potentially malicious, untrusted user input. The goal of the checker is to discover and show to the user these potential; taint source-sink pairs and the propagation call chain. The most notable examples of taint sources are:. - data from network; - files or standard input; - environment variables; - data from databases. Let us examine a practical example of a Command Injection attack. .. code-block:: c. // Command Injection Vulnerability Example; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; strcat(cmd, filename);; system(cmd); // Warning: Untrusted data is passed to a system call; }. The program prints the content of any user specified file.; Unfortunately the attacker can execute arbitrary commands; with shell escapes. For example with the following input the `ls` command is also; executed after the contents of `/etc/",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:66523,Security,attack,attack,66523,"t-TaintPropagation:. alpha.security.taint.TaintPropagation (C, C++); """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Taint analysis identifies potential security vulnerabilities where the; attacker can inject malicious data to the program to execute an attack; (privilege escalation, command injection, SQL injection etc.). The malicious data is injected at the taint source (e.g. ``getenv()`` call); which is then propagated through function calls and being used as arguments of; sensitive operations, also called as taint sinks (e.g. ``system()`` call). One can defend against this type of vulnerability by always checking and; sanitizing the potentially malicious, untrusted user input. The goal of the checker is to discover and show to the user these potential; taint source-sink pairs and the propagation call chain. The most notable examples of taint sources are:. - data from network; - files or standard input; - environment variables; - data from databases. Let us examine a practical example of a Command Injection attack. .. code-block:: c. // Command Injection Vulnerability Example; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; strcat(cmd, filename);; system(cmd); // Warning: Untrusted data is passed to a system call; }. The program prints the content of any user specified file.; Unfortunately the attacker can execute arbitrary commands; with shell escapes. For example with the following input the `ls` command is also; executed after the contents of `/etc/shadow` is printed.; `Input: /etc/shadow ; ls /`. The analysis implemented in this checker points out this problem. One can protect against such attack by for example checking if the provided; input refers to a valid file and removing any invalid user input. .. code-block:: c. // No vulnerability anymore, but we still get the warning; void sanitizeFileName(char* filename){; i",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:66744,Security,attack,attacker,66744,"s data to the program to execute an attack; (privilege escalation, command injection, SQL injection etc.). The malicious data is injected at the taint source (e.g. ``getenv()`` call); which is then propagated through function calls and being used as arguments of; sensitive operations, also called as taint sinks (e.g. ``system()`` call). One can defend against this type of vulnerability by always checking and; sanitizing the potentially malicious, untrusted user input. The goal of the checker is to discover and show to the user these potential; taint source-sink pairs and the propagation call chain. The most notable examples of taint sources are:. - data from network; - files or standard input; - environment variables; - data from databases. Let us examine a practical example of a Command Injection attack. .. code-block:: c. // Command Injection Vulnerability Example; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; strcat(cmd, filename);; system(cmd); // Warning: Untrusted data is passed to a system call; }. The program prints the content of any user specified file.; Unfortunately the attacker can execute arbitrary commands; with shell escapes. For example with the following input the `ls` command is also; executed after the contents of `/etc/shadow` is printed.; `Input: /etc/shadow ; ls /`. The analysis implemented in this checker points out this problem. One can protect against such attack by for example checking if the provided; input refers to a valid file and removing any invalid user input. .. code-block:: c. // No vulnerability anymore, but we still get the warning; void sanitizeFileName(char* filename){; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; filename[0]='\0';; }; }; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"")",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:66757,Security,inject,inject,66757,"s data to the program to execute an attack; (privilege escalation, command injection, SQL injection etc.). The malicious data is injected at the taint source (e.g. ``getenv()`` call); which is then propagated through function calls and being used as arguments of; sensitive operations, also called as taint sinks (e.g. ``system()`` call). One can defend against this type of vulnerability by always checking and; sanitizing the potentially malicious, untrusted user input. The goal of the checker is to discover and show to the user these potential; taint source-sink pairs and the propagation call chain. The most notable examples of taint sources are:. - data from network; - files or standard input; - environment variables; - data from databases. Let us examine a practical example of a Command Injection attack. .. code-block:: c. // Command Injection Vulnerability Example; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; strcat(cmd, filename);; system(cmd); // Warning: Untrusted data is passed to a system call; }. The program prints the content of any user specified file.; Unfortunately the attacker can execute arbitrary commands; with shell escapes. For example with the following input the `ls` command is also; executed after the contents of `/etc/shadow` is printed.; `Input: /etc/shadow ; ls /`. The analysis implemented in this checker points out this problem. One can protect against such attack by for example checking if the provided; input refers to a valid file and removing any invalid user input. .. code-block:: c. // No vulnerability anymore, but we still get the warning; void sanitizeFileName(char* filename){; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; filename[0]='\0';; }; }; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"")",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:66958,Security,attack,attacker,66958,"sensitive operations, also called as taint sinks (e.g. ``system()`` call). One can defend against this type of vulnerability by always checking and; sanitizing the potentially malicious, untrusted user input. The goal of the checker is to discover and show to the user these potential; taint source-sink pairs and the propagation call chain. The most notable examples of taint sources are:. - data from network; - files or standard input; - environment variables; - data from databases. Let us examine a practical example of a Command Injection attack. .. code-block:: c. // Command Injection Vulnerability Example; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; strcat(cmd, filename);; system(cmd); // Warning: Untrusted data is passed to a system call; }. The program prints the content of any user specified file.; Unfortunately the attacker can execute arbitrary commands; with shell escapes. For example with the following input the `ls` command is also; executed after the contents of `/etc/shadow` is printed.; `Input: /etc/shadow ; ls /`. The analysis implemented in this checker points out this problem. One can protect against such attack by for example checking if the provided; input refers to a valid file and removing any invalid user input. .. code-block:: c. // No vulnerability anymore, but we still get the warning; void sanitizeFileName(char* filename){; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; filename[0]='\0';; }; }; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; sanitizeFileName(filename);// filename is safe after this point; if (!filename[0]); return -1;; strcat(cmd, filename);; system(cmd); // Superfluous Warning: Untrusted data is passe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:67264,Security,attack,attack,67264,"on call chain. The most notable examples of taint sources are:. - data from network; - files or standard input; - environment variables; - data from databases. Let us examine a practical example of a Command Injection attack. .. code-block:: c. // Command Injection Vulnerability Example; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; strcat(cmd, filename);; system(cmd); // Warning: Untrusted data is passed to a system call; }. The program prints the content of any user specified file.; Unfortunately the attacker can execute arbitrary commands; with shell escapes. For example with the following input the `ls` command is also; executed after the contents of `/etc/shadow` is printed.; `Input: /etc/shadow ; ls /`. The analysis implemented in this checker points out this problem. One can protect against such attack by for example checking if the provided; input refers to a valid file and removing any invalid user input. .. code-block:: c. // No vulnerability anymore, but we still get the warning; void sanitizeFileName(char* filename){; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; filename[0]='\0';; }; }; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; sanitizeFileName(filename);// filename is safe after this point; if (!filename[0]); return -1;; strcat(cmd, filename);; system(cmd); // Superfluous Warning: Untrusted data is passed to a system call; }. Unfortunately, the checker cannot discover automatically that the programmer; have performed data sanitation, so it still emits the warning. One can get rid of this superfluous warning by telling by specifying the; sanitation functions in the taint configuration file (see; :doc:`user-docs/TaintAnalysisCo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:67461,Security,sanitiz,sanitizeFileName,67461,":"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; strcat(cmd, filename);; system(cmd); // Warning: Untrusted data is passed to a system call; }. The program prints the content of any user specified file.; Unfortunately the attacker can execute arbitrary commands; with shell escapes. For example with the following input the `ls` command is also; executed after the contents of `/etc/shadow` is printed.; `Input: /etc/shadow ; ls /`. The analysis implemented in this checker points out this problem. One can protect against such attack by for example checking if the provided; input refers to a valid file and removing any invalid user input. .. code-block:: c. // No vulnerability anymore, but we still get the warning; void sanitizeFileName(char* filename){; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; filename[0]='\0';; }; }; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; sanitizeFileName(filename);// filename is safe after this point; if (!filename[0]); return -1;; strcat(cmd, filename);; system(cmd); // Superfluous Warning: Untrusted data is passed to a system call; }. Unfortunately, the checker cannot discover automatically that the programmer; have performed data sanitation, so it still emits the warning. One can get rid of this superfluous warning by telling by specifying the; sanitation functions in the taint configuration file (see; :doc:`user-docs/TaintAnalysisConfiguration`). .. code-block:: YAML. Filters:; - Name: sanitizeFileName; Args: [0]. The clang invocation to pass the configuration file location:. .. code-block:: bash. clang --analyze -Xclang -analyzer-config -Xclang alpha.security.taint.TaintPropagation:Config=`pwd`/taint_config.yml ... If you are validating your inputs instead of sanitizing them, or don't want to; mention each sanitizin",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:67500,Security,access,access,67500,":"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; strcat(cmd, filename);; system(cmd); // Warning: Untrusted data is passed to a system call; }. The program prints the content of any user specified file.; Unfortunately the attacker can execute arbitrary commands; with shell escapes. For example with the following input the `ls` command is also; executed after the contents of `/etc/shadow` is printed.; `Input: /etc/shadow ; ls /`. The analysis implemented in this checker points out this problem. One can protect against such attack by for example checking if the provided; input refers to a valid file and removing any invalid user input. .. code-block:: c. // No vulnerability anymore, but we still get the warning; void sanitizeFileName(char* filename){; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; filename[0]='\0';; }; }; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; sanitizeFileName(filename);// filename is safe after this point; if (!filename[0]); return -1;; strcat(cmd, filename);; system(cmd); // Superfluous Warning: Untrusted data is passed to a system call; }. Unfortunately, the checker cannot discover automatically that the programmer; have performed data sanitation, so it still emits the warning. One can get rid of this superfluous warning by telling by specifying the; sanitation functions in the taint configuration file (see; :doc:`user-docs/TaintAnalysisConfiguration`). .. code-block:: YAML. Filters:; - Name: sanitizeFileName; Args: [0]. The clang invocation to pass the configuration file location:. .. code-block:: bash. clang --analyze -Xclang -analyzer-config -Xclang alpha.security.taint.TaintPropagation:Config=`pwd`/taint_config.yml ... If you are validating your inputs instead of sanitizing them, or don't want to; mention each sanitizin",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:67757,Security,attack,attacker,67757,":"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; strcat(cmd, filename);; system(cmd); // Warning: Untrusted data is passed to a system call; }. The program prints the content of any user specified file.; Unfortunately the attacker can execute arbitrary commands; with shell escapes. For example with the following input the `ls` command is also; executed after the contents of `/etc/shadow` is printed.; `Input: /etc/shadow ; ls /`. The analysis implemented in this checker points out this problem. One can protect against such attack by for example checking if the provided; input refers to a valid file and removing any invalid user input. .. code-block:: c. // No vulnerability anymore, but we still get the warning; void sanitizeFileName(char* filename){; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; filename[0]='\0';; }; }; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; sanitizeFileName(filename);// filename is safe after this point; if (!filename[0]); return -1;; strcat(cmd, filename);; system(cmd); // Superfluous Warning: Untrusted data is passed to a system call; }. Unfortunately, the checker cannot discover automatically that the programmer; have performed data sanitation, so it still emits the warning. One can get rid of this superfluous warning by telling by specifying the; sanitation functions in the taint configuration file (see; :doc:`user-docs/TaintAnalysisConfiguration`). .. code-block:: YAML. Filters:; - Name: sanitizeFileName; Args: [0]. The clang invocation to pass the configuration file location:. .. code-block:: bash. clang --analyze -Xclang -analyzer-config -Xclang alpha.security.taint.TaintPropagation:Config=`pwd`/taint_config.yml ... If you are validating your inputs instead of sanitizing them, or don't want to; mention each sanitizin",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:67770,Security,inject,inject,67770,":"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; strcat(cmd, filename);; system(cmd); // Warning: Untrusted data is passed to a system call; }. The program prints the content of any user specified file.; Unfortunately the attacker can execute arbitrary commands; with shell escapes. For example with the following input the `ls` command is also; executed after the contents of `/etc/shadow` is printed.; `Input: /etc/shadow ; ls /`. The analysis implemented in this checker points out this problem. One can protect against such attack by for example checking if the provided; input refers to a valid file and removing any invalid user input. .. code-block:: c. // No vulnerability anymore, but we still get the warning; void sanitizeFileName(char* filename){; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; filename[0]='\0';; }; }; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; sanitizeFileName(filename);// filename is safe after this point; if (!filename[0]); return -1;; strcat(cmd, filename);; system(cmd); // Superfluous Warning: Untrusted data is passed to a system call; }. Unfortunately, the checker cannot discover automatically that the programmer; have performed data sanitation, so it still emits the warning. One can get rid of this superfluous warning by telling by specifying the; sanitation functions in the taint configuration file (see; :doc:`user-docs/TaintAnalysisConfiguration`). .. code-block:: YAML. Filters:; - Name: sanitizeFileName; Args: [0]. The clang invocation to pass the configuration file location:. .. code-block:: bash. clang --analyze -Xclang -analyzer-config -Xclang alpha.security.taint.TaintPropagation:Config=`pwd`/taint_config.yml ... If you are validating your inputs instead of sanitizing them, or don't want to; mention each sanitizin",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:67798,Security,sanitiz,sanitizeFileName,67798,":"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; strcat(cmd, filename);; system(cmd); // Warning: Untrusted data is passed to a system call; }. The program prints the content of any user specified file.; Unfortunately the attacker can execute arbitrary commands; with shell escapes. For example with the following input the `ls` command is also; executed after the contents of `/etc/shadow` is printed.; `Input: /etc/shadow ; ls /`. The analysis implemented in this checker points out this problem. One can protect against such attack by for example checking if the provided; input refers to a valid file and removing any invalid user input. .. code-block:: c. // No vulnerability anymore, but we still get the warning; void sanitizeFileName(char* filename){; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; filename[0]='\0';; }; }; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; sanitizeFileName(filename);// filename is safe after this point; if (!filename[0]); return -1;; strcat(cmd, filename);; system(cmd); // Superfluous Warning: Untrusted data is passed to a system call; }. Unfortunately, the checker cannot discover automatically that the programmer; have performed data sanitation, so it still emits the warning. One can get rid of this superfluous warning by telling by specifying the; sanitation functions in the taint configuration file (see; :doc:`user-docs/TaintAnalysisConfiguration`). .. code-block:: YAML. Filters:; - Name: sanitizeFileName; Args: [0]. The clang invocation to pass the configuration file location:. .. code-block:: bash. clang --analyze -Xclang -analyzer-config -Xclang alpha.security.taint.TaintPropagation:Config=`pwd`/taint_config.yml ... If you are validating your inputs instead of sanitizing them, or don't want to; mention each sanitizin",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:68361,Security,sanitiz,sanitizeFileName,68361," user input. .. code-block:: c. // No vulnerability anymore, but we still get the warning; void sanitizeFileName(char* filename){; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; filename[0]='\0';; }; }; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; sanitizeFileName(filename);// filename is safe after this point; if (!filename[0]); return -1;; strcat(cmd, filename);; system(cmd); // Superfluous Warning: Untrusted data is passed to a system call; }. Unfortunately, the checker cannot discover automatically that the programmer; have performed data sanitation, so it still emits the warning. One can get rid of this superfluous warning by telling by specifying the; sanitation functions in the taint configuration file (see; :doc:`user-docs/TaintAnalysisConfiguration`). .. code-block:: YAML. Filters:; - Name: sanitizeFileName; Args: [0]. The clang invocation to pass the configuration file location:. .. code-block:: bash. clang --analyze -Xclang -analyzer-config -Xclang alpha.security.taint.TaintPropagation:Config=`pwd`/taint_config.yml ... If you are validating your inputs instead of sanitizing them, or don't want to; mention each sanitizing function in our configuration,; you can use a more generic approach. Introduce a generic no-op `csa_mark_sanitized(..)` function to; tell the Clang Static Analyzer; that the variable is safe to be used on that analysis path. .. code-block:: c. // Marking sanitized variables safe.; // No vulnerability anymore, no warning. // User csa_mark_sanitize function is for the analyzer only; #ifdef __clang_analyzer__; void csa_mark_sanitized(const void *);; #endif. int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename);; if (access(filename,F_OK)){// Verifying user input; printf(""Fil",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:68530,Security,secur,security,68530,"g user input; printf(""File does not exist\n"");; filename[0]='\0';; }; }; int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; sanitizeFileName(filename);// filename is safe after this point; if (!filename[0]); return -1;; strcat(cmd, filename);; system(cmd); // Superfluous Warning: Untrusted data is passed to a system call; }. Unfortunately, the checker cannot discover automatically that the programmer; have performed data sanitation, so it still emits the warning. One can get rid of this superfluous warning by telling by specifying the; sanitation functions in the taint configuration file (see; :doc:`user-docs/TaintAnalysisConfiguration`). .. code-block:: YAML. Filters:; - Name: sanitizeFileName; Args: [0]. The clang invocation to pass the configuration file location:. .. code-block:: bash. clang --analyze -Xclang -analyzer-config -Xclang alpha.security.taint.TaintPropagation:Config=`pwd`/taint_config.yml ... If you are validating your inputs instead of sanitizing them, or don't want to; mention each sanitizing function in our configuration,; you can use a more generic approach. Introduce a generic no-op `csa_mark_sanitized(..)` function to; tell the Clang Static Analyzer; that the variable is safe to be used on that analysis path. .. code-block:: c. // Marking sanitized variables safe.; // No vulnerability anymore, no warning. // User csa_mark_sanitize function is for the analyzer only; #ifdef __clang_analyzer__; void csa_mark_sanitized(const void *);; #endif. int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename);; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; return -1;; }; #ifdef __clang_analyzer__; csa_mark_sanitized(filename); // Indicating to CSA that filename variable is safe to be used after this ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:68607,Security,validat,validating,68607,"ename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; sanitizeFileName(filename);// filename is safe after this point; if (!filename[0]); return -1;; strcat(cmd, filename);; system(cmd); // Superfluous Warning: Untrusted data is passed to a system call; }. Unfortunately, the checker cannot discover automatically that the programmer; have performed data sanitation, so it still emits the warning. One can get rid of this superfluous warning by telling by specifying the; sanitation functions in the taint configuration file (see; :doc:`user-docs/TaintAnalysisConfiguration`). .. code-block:: YAML. Filters:; - Name: sanitizeFileName; Args: [0]. The clang invocation to pass the configuration file location:. .. code-block:: bash. clang --analyze -Xclang -analyzer-config -Xclang alpha.security.taint.TaintPropagation:Config=`pwd`/taint_config.yml ... If you are validating your inputs instead of sanitizing them, or don't want to; mention each sanitizing function in our configuration,; you can use a more generic approach. Introduce a generic no-op `csa_mark_sanitized(..)` function to; tell the Clang Static Analyzer; that the variable is safe to be used on that analysis path. .. code-block:: c. // Marking sanitized variables safe.; // No vulnerability anymore, no warning. // User csa_mark_sanitize function is for the analyzer only; #ifdef __clang_analyzer__; void csa_mark_sanitized(const void *);; #endif. int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename);; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; return -1;; }; #ifdef __clang_analyzer__; csa_mark_sanitized(filename); // Indicating to CSA that filename variable is safe to be used after this point; #endif; strcat(cmd, filename);; system(cmd); // No warning; }. Similarly to the previous example, you need to; define a `Filter` function in",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:68641,Security,sanitiz,sanitizing,68641,"ename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; sanitizeFileName(filename);// filename is safe after this point; if (!filename[0]); return -1;; strcat(cmd, filename);; system(cmd); // Superfluous Warning: Untrusted data is passed to a system call; }. Unfortunately, the checker cannot discover automatically that the programmer; have performed data sanitation, so it still emits the warning. One can get rid of this superfluous warning by telling by specifying the; sanitation functions in the taint configuration file (see; :doc:`user-docs/TaintAnalysisConfiguration`). .. code-block:: YAML. Filters:; - Name: sanitizeFileName; Args: [0]. The clang invocation to pass the configuration file location:. .. code-block:: bash. clang --analyze -Xclang -analyzer-config -Xclang alpha.security.taint.TaintPropagation:Config=`pwd`/taint_config.yml ... If you are validating your inputs instead of sanitizing them, or don't want to; mention each sanitizing function in our configuration,; you can use a more generic approach. Introduce a generic no-op `csa_mark_sanitized(..)` function to; tell the Clang Static Analyzer; that the variable is safe to be used on that analysis path. .. code-block:: c. // Marking sanitized variables safe.; // No vulnerability anymore, no warning. // User csa_mark_sanitize function is for the analyzer only; #ifdef __clang_analyzer__; void csa_mark_sanitized(const void *);; #endif. int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename);; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; return -1;; }; #ifdef __clang_analyzer__; csa_mark_sanitized(filename); // Indicating to CSA that filename variable is safe to be used after this point; #endif; strcat(cmd, filename);; system(cmd); // No warning; }. Similarly to the previous example, you need to; define a `Filter` function in",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:68689,Security,sanitiz,sanitizing,68689,"ename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename); // The attacker can inject a shell escape here; sanitizeFileName(filename);// filename is safe after this point; if (!filename[0]); return -1;; strcat(cmd, filename);; system(cmd); // Superfluous Warning: Untrusted data is passed to a system call; }. Unfortunately, the checker cannot discover automatically that the programmer; have performed data sanitation, so it still emits the warning. One can get rid of this superfluous warning by telling by specifying the; sanitation functions in the taint configuration file (see; :doc:`user-docs/TaintAnalysisConfiguration`). .. code-block:: YAML. Filters:; - Name: sanitizeFileName; Args: [0]. The clang invocation to pass the configuration file location:. .. code-block:: bash. clang --analyze -Xclang -analyzer-config -Xclang alpha.security.taint.TaintPropagation:Config=`pwd`/taint_config.yml ... If you are validating your inputs instead of sanitizing them, or don't want to; mention each sanitizing function in our configuration,; you can use a more generic approach. Introduce a generic no-op `csa_mark_sanitized(..)` function to; tell the Clang Static Analyzer; that the variable is safe to be used on that analysis path. .. code-block:: c. // Marking sanitized variables safe.; // No vulnerability anymore, no warning. // User csa_mark_sanitize function is for the analyzer only; #ifdef __clang_analyzer__; void csa_mark_sanitized(const void *);; #endif. int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename);; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; return -1;; }; #ifdef __clang_analyzer__; csa_mark_sanitized(filename); // Indicating to CSA that filename variable is safe to be used after this point; #endif; strcat(cmd, filename);; system(cmd); // No warning; }. Similarly to the previous example, you need to; define a `Filter` function in",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:68955,Security,sanitiz,sanitized,68955,"ted data is passed to a system call; }. Unfortunately, the checker cannot discover automatically that the programmer; have performed data sanitation, so it still emits the warning. One can get rid of this superfluous warning by telling by specifying the; sanitation functions in the taint configuration file (see; :doc:`user-docs/TaintAnalysisConfiguration`). .. code-block:: YAML. Filters:; - Name: sanitizeFileName; Args: [0]. The clang invocation to pass the configuration file location:. .. code-block:: bash. clang --analyze -Xclang -analyzer-config -Xclang alpha.security.taint.TaintPropagation:Config=`pwd`/taint_config.yml ... If you are validating your inputs instead of sanitizing them, or don't want to; mention each sanitizing function in our configuration,; you can use a more generic approach. Introduce a generic no-op `csa_mark_sanitized(..)` function to; tell the Clang Static Analyzer; that the variable is safe to be used on that analysis path. .. code-block:: c. // Marking sanitized variables safe.; // No vulnerability anymore, no warning. // User csa_mark_sanitize function is for the analyzer only; #ifdef __clang_analyzer__; void csa_mark_sanitized(const void *);; #endif. int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename);; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; return -1;; }; #ifdef __clang_analyzer__; csa_mark_sanitized(filename); // Indicating to CSA that filename variable is safe to be used after this point; #endif; strcat(cmd, filename);; system(cmd); // No warning; }. Similarly to the previous example, you need to; define a `Filter` function in a `YAML` configuration file; and add the `csa_mark_sanitized` function. .. code-block:: YAML. Filters:; - Name: csa_mark_sanitized; Args: [0]. Then calling `csa_mark_sanitized(X)` will tell the analyzer that `X` is safe to; be used after this point, because its contents are veri",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:69307,Security,access,access,69307,"gs: [0]. The clang invocation to pass the configuration file location:. .. code-block:: bash. clang --analyze -Xclang -analyzer-config -Xclang alpha.security.taint.TaintPropagation:Config=`pwd`/taint_config.yml ... If you are validating your inputs instead of sanitizing them, or don't want to; mention each sanitizing function in our configuration,; you can use a more generic approach. Introduce a generic no-op `csa_mark_sanitized(..)` function to; tell the Clang Static Analyzer; that the variable is safe to be used on that analysis path. .. code-block:: c. // Marking sanitized variables safe.; // No vulnerability anymore, no warning. // User csa_mark_sanitize function is for the analyzer only; #ifdef __clang_analyzer__; void csa_mark_sanitized(const void *);; #endif. int main(int argc, char** argv) {; char cmd[2048] = ""/bin/cat "";; char filename[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename);; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; return -1;; }; #ifdef __clang_analyzer__; csa_mark_sanitized(filename); // Indicating to CSA that filename variable is safe to be used after this point; #endif; strcat(cmd, filename);; system(cmd); // No warning; }. Similarly to the previous example, you need to; define a `Filter` function in a `YAML` configuration file; and add the `csa_mark_sanitized` function. .. code-block:: YAML. Filters:; - Name: csa_mark_sanitized; Args: [0]. Then calling `csa_mark_sanitized(X)` will tell the analyzer that `X` is safe to; be used after this point, because its contents are verified. It is the; responsibility of the programmer to ensure that this verification was indeed; correct. Please note that `csa_mark_sanitized` function is only declared and; used during Clang Static Analysis and skipped in (production) builds. Further examples of injection vulnerabilities this checker can find. .. code-block:: c. void test() {; char x = getchar(); // 'x' marked as tainted; system(&x); // warn: untrus",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:70225,Security,inject,injection,70225,"[1024];; printf(""Filename:"");; scanf ("" %1023[^\n]"", filename);; if (access(filename,F_OK)){// Verifying user input; printf(""File does not exist\n"");; return -1;; }; #ifdef __clang_analyzer__; csa_mark_sanitized(filename); // Indicating to CSA that filename variable is safe to be used after this point; #endif; strcat(cmd, filename);; system(cmd); // No warning; }. Similarly to the previous example, you need to; define a `Filter` function in a `YAML` configuration file; and add the `csa_mark_sanitized` function. .. code-block:: YAML. Filters:; - Name: csa_mark_sanitized; Args: [0]. Then calling `csa_mark_sanitized(X)` will tell the analyzer that `X` is safe to; be used after this point, because its contents are verified. It is the; responsibility of the programmer to ensure that this verification was indeed; correct. Please note that `csa_mark_sanitized` function is only declared and; used during Clang Static Analysis and skipped in (production) builds. Further examples of injection vulnerabilities this checker can find. .. code-block:: c. void test() {; char x = getchar(); // 'x' marked as tainted; system(&x); // warn: untrusted data is passed to a system call; }. // note: compiler internally checks if the second param to; // sprintf is a string literal or not.; // Use -Wno-format-security to suppress compiler warning.; void test() {; char s[10], buf[10];; fscanf(stdin, ""%s"", s); // 's' marked as tainted. sprintf(buf, s); // warn: untrusted data used as a format string; }. void test() {; size_t ts;; scanf(""%zd"", &ts); // 'ts' marked as tainted; int *p = (int *)malloc(ts * sizeof(int));; // warn: untrusted data used as buffer size; }. There are built-in sources, propagations and sinks even if no external taint; configuration is provided. Default sources:; ``_IO_getc``, ``fdopen``, ``fopen``, ``freopen``, ``get_current_dir_name``,; ``getch``, ``getchar``, ``getchar_unlocked``, ``getwd``, ``getcwd``,; ``getgroups``, ``gethostname``, ``getlogin``, ``getlogin_r``, ``getna",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:70540,Security,secur,security,70540,"; strcat(cmd, filename);; system(cmd); // No warning; }. Similarly to the previous example, you need to; define a `Filter` function in a `YAML` configuration file; and add the `csa_mark_sanitized` function. .. code-block:: YAML. Filters:; - Name: csa_mark_sanitized; Args: [0]. Then calling `csa_mark_sanitized(X)` will tell the analyzer that `X` is safe to; be used after this point, because its contents are verified. It is the; responsibility of the programmer to ensure that this verification was indeed; correct. Please note that `csa_mark_sanitized` function is only declared and; used during Clang Static Analysis and skipped in (production) builds. Further examples of injection vulnerabilities this checker can find. .. code-block:: c. void test() {; char x = getchar(); // 'x' marked as tainted; system(&x); // warn: untrusted data is passed to a system call; }. // note: compiler internally checks if the second param to; // sprintf is a string literal or not.; // Use -Wno-format-security to suppress compiler warning.; void test() {; char s[10], buf[10];; fscanf(stdin, ""%s"", s); // 's' marked as tainted. sprintf(buf, s); // warn: untrusted data used as a format string; }. void test() {; size_t ts;; scanf(""%zd"", &ts); // 'ts' marked as tainted; int *p = (int *)malloc(ts * sizeof(int));; // warn: untrusted data used as buffer size; }. There are built-in sources, propagations and sinks even if no external taint; configuration is provided. Default sources:; ``_IO_getc``, ``fdopen``, ``fopen``, ``freopen``, ``get_current_dir_name``,; ``getch``, ``getchar``, ``getchar_unlocked``, ``getwd``, ``getcwd``,; ``getgroups``, ``gethostname``, ``getlogin``, ``getlogin_r``, ``getnameinfo``,; ``gets``, ``gets_s``, ``getseuserbyname``, ``readlink``, ``readlinkat``,; ``scanf``, ``scanf_s``, ``socket``, ``wgetch``. Default propagations rules:; ``atoi``, ``atol``, ``atoll``, ``basename``, ``dirname``, ``fgetc``,; ``fgetln``, ``fgets``, ``fnmatch``, ``fread``, ``fscanf``, ``fscanf_s``,; ``in",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:72825,Security,secur,security,72825,"ne``, ``getw``, ``memcmp``,; ``memcpy``, ``memmem``, ``memmove``, ``mbtowc``, ``pread``, ``qsort``,; ``qsort_r``, ``rawmemchr``, ``read``, ``recv``, ``recvfrom``, ``rindex``,; ``strcasestr``, ``strchr``, ``strchrnul``, ``strcasecmp``, ``strcmp``,; ``strcspn``, ``strncasecmp``, ``strncmp``, ``strndup``,; ``strndupa``, ``strpbrk``, ``strrchr``, ``strsep``, ``strspn``,; ``strstr``, ``strtol``, ``strtoll``, ``strtoul``, ``strtoull``, ``tolower``,; ``toupper``, ``ttyname``, ``ttyname_r``, ``wctomb``, ``wcwidth``. Default sinks:; ``printf``, ``setproctitle``, ``system``, ``popen``, ``execl``, ``execle``,; ``execlp``, ``execv``, ``execvp``, ``execvP``, ``execve``, ``dlopen``,; ``memcpy``, ``memmove``, ``strncpy``, ``strndup``, ``malloc``, ``calloc``,; ``alloca``, ``memccpy``, ``realloc``, ``bcopy``. Please note that there are no built-in filter functions. One can configure their own taint sources, sinks, and propagation rules by; providing a configuration file via checker option; ``alpha.security.taint.TaintPropagation:Config``. The configuration file is in; `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format. The; taint-related options defined in the config file extend but do not override the; built-in sources, rules, sinks. The format of the external taint configuration; file is not stable, and could change without any notice even in a non-backward; compatible way. For a more detailed description of configuration options, please see the; :doc:`user-docs/TaintAnalysisConfiguration`. For an example see; :ref:`clangsa-taint-configuration-example`. **Configuration**. * `Config` Specifies the name of the YAML configuration file. The user can; define their own taint sources and sinks. **Related Guidelines**. * `CWE Data Neutralization Issues; <https://cwe.mitre.org/data/definitions/137.html>`_; * `SEI Cert STR02-C. Sanitize data passed to complex subsystems; <https://wiki.sei.cmu.edu/confluence/display/c/STR02-C.+Sanitize+data+passed+to+complex+subsystems>`_;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:78490,Security,access,access,78490," void test() {; FILE *p = fopen(""foo"", ""r"");; fclose(p);; fclose(p); // warn: already closed; }. void test() {; FILE *p = tmpfile();; ftell(p); // warn: stream pointer might be NULL; fclose(p);; }. .. _alpha-unix-cstring-BufferOverlap:. alpha.unix.cstring.BufferOverlap (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Checks for overlap in two buffer arguments. Applies to: ``memcpy, mempcpy, wmemcpy, wmempcpy``. .. code-block:: c. void test() {; int a[4] = {0};; memcpy(a + 2, a + 1, 8); // warn; }. .. _alpha-unix-cstring-NotNullTerminated:. alpha.unix.cstring.NotNullTerminated (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for arguments which are not null-terminated strings; applies to: ``strlen, strnlen, strcpy, strncpy, strcat, strncat, wcslen, wcsnlen``. .. code-block:: c. void test() {; int y = strlen((char *)&test); // warn; }. .. _alpha-unix-cstring-OutOfBounds:. alpha.unix.cstring.OutOfBounds (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for out-of-bounds access in string functions, such as:; ``memcpy, bcopy, strcpy, strncpy, strcat, strncat, memmove, memcmp, memset`` and more. This check also works with string literals, except there is a known bug in that; the analyzer cannot detect embedded NULL characters when determining the string length. .. code-block:: c. void test1() {; const char str[] = ""Hello world"";; char buffer[] = ""Hello world"";; memcpy(buffer, str, sizeof(str) + 1); // warn; }. void test2() {; const char str[] = ""Hello world"";; char buffer[] = ""Helloworld"";; memcpy(buffer, str, sizeof(str)); // warn; }. .. _alpha-unix-cstring-UninitializedRead:. alpha.unix.cstring.UninitializedRead (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for uninitialized reads from common memory copy/manipulation functions such as:; ``memcpy, mempcpy, memmove, memcmp, strcmp, strncmp, strcpy, strlen, strsep`` and many more. .. code-block:: c. void test() {; char src[10];; char dst[5];; memcpy(dst,src,sizeof(dst)); // warn: Bytes string function accesses uninitializ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:79494,Security,access,accesses,79494,"""""; Check for out-of-bounds access in string functions, such as:; ``memcpy, bcopy, strcpy, strncpy, strcat, strncat, memmove, memcmp, memset`` and more. This check also works with string literals, except there is a known bug in that; the analyzer cannot detect embedded NULL characters when determining the string length. .. code-block:: c. void test1() {; const char str[] = ""Hello world"";; char buffer[] = ""Hello world"";; memcpy(buffer, str, sizeof(str) + 1); // warn; }. void test2() {; const char str[] = ""Hello world"";; char buffer[] = ""Helloworld"";; memcpy(buffer, str, sizeof(str)); // warn; }. .. _alpha-unix-cstring-UninitializedRead:. alpha.unix.cstring.UninitializedRead (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for uninitialized reads from common memory copy/manipulation functions such as:; ``memcpy, mempcpy, memmove, memcmp, strcmp, strncmp, strcpy, strlen, strsep`` and many more. .. code-block:: c. void test() {; char src[10];; char dst[5];; memcpy(dst,src,sizeof(dst)); // warn: Bytes string function accesses uninitialized/garbage values; }. Limitations:. - Due to limitations of the memory modeling in the analyzer, one can likely; observe a lot of false-positive reports like this:. .. code-block:: c. void false_positive() {; int src[] = {1, 2, 3, 4};; int dst[5] = {0};; memcpy(dst, src, 4 * sizeof(int)); // false-positive:; // The 'src' buffer was correctly initialized, yet we cannot conclude; // that since the analyzer could not see a direct initialization of the; // very last byte of the source buffer.; }. More details at the corresponding `GitHub issue <https://github.com/llvm/llvm-project/issues/43459>`_. .. _alpha-nondeterminism-PointerIteration:. alpha.nondeterminism.PointerIteration (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for non-determinism caused by iterating unordered containers of pointers. .. code-block:: c. void test() {; int a = 1, b = 2;; std::unordered_set<int *> UnorderedPtrSet = {&a, &b};. for (auto i : UnorderedPt",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:82124,Security,access,access,82124,"e end of the call. This applies to call to any function, method, lambda, function pointer or functor. Ref-countable types aren't supposed to be allocated on stack so we check arguments for parameters of raw pointers and references to uncounted types. Here are some examples of situations that we warn about as they *might* be potentially unsafe. The logic is that either we're able to guarantee that an argument is safe or it's considered if not a bug then bug-prone. .. code-block:: cpp. RefCountable* provide_uncounted();; void consume(RefCountable*);. // In these cases we can't make sure callee won't directly or indirectly call `deref()` on the argument which could make it unsafe from such point until the end of the call. void foo1() {; consume(provide_uncounted()); // warn; }. void foo2() {; RefCountable* uncounted = provide_uncounted();; consume(uncounted); // warn; }. Although we are enforcing member variables to be ref-counted by `webkit.NoUncountedMemberChecker` any method of the same class still has unrestricted access to these. Since from a caller's perspective we can't guarantee a particular member won't get modified by callee (directly or indirectly) we don't consider values obtained from members safe. Note: It's likely this heuristic could be made more precise with fewer false positives - for example calls to free functions that don't have any parameter other than the pointer should be safe as the callee won't be able to tamper with the member unless it's a global variable. .. code-block:: cpp. struct Foo {; RefPtr<RefCountable> member;; void consume(RefCountable*) { /* ... */ }; void bugprone() {; consume(member.get()); // warn; }; };. The implementation of this rule is a heuristic - we define a whitelist of kinds of values that are considered safe to be passed as arguments. If we can't prove an argument is safe it's considered an error. Allowed kinds of arguments:. - values obtained from ref-counted objects (including temporaries as those survive the call t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:265,Testability,log,logic,265,"==================; Available Checkers; ==================. The analyzer performs checks that are categorized into families or ""checkers"". The default set of checkers covers a variety of checks targeted at finding security and API usage bugs,; dead code, and other logic errors. See the :ref:`default-checkers` checkers list below. In addition to these, the analyzer contains a number of :ref:`alpha-checkers` (aka *alpha* checkers).; These checkers are under development and are switched off by default. They may crash or emit a higher number of false positives. The :ref:`debug-checkers` package contains checkers for analyzer developers for debugging purposes. .. contents:: Table of Contents; :depth: 4. .. _default-checkers:. Default Checkers; ----------------. .. _core-checkers:. core; ^^^^; Models core language features and contains general-purpose checkers such as division by zero,; null pointer dereference, usage of uninitialized values, etc.; *These checkers must be always switched on as other checker rely on them.*. .. _core-BitwiseShift:. core.BitwiseShift (C, C++); """""""""""""""""""""""""""""""""""""""""""""""""""". Finds undefined behavior caused by the bitwise left- and right-shift operator; operating on integer types. By default, this checker only reports situations when the right operand is; either negative or larger than the bit width of the type of the left operand;; these are logically unsound. Moreover, if the pedantic mode is activated by; ``-analyzer-config core.BitwiseShift:Pedantic=true``, then this checker also; reports situations where the _left_ operand of a shift operator is negative or; overflow occurs during the right shift of a signed value. (Most compilers; handle these predictably, but the C standard and the C++ standards before C++20; say that they're undefined behavior. In the C++20 standard these constructs are; well-defined, so activating pedantic mode in C++20 has no effect.). **Examples**. .. code-block:: cpp. static_assert(sizeof(int) == 4, ""assuming 32-bit in",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:1385,Testability,log,logically,1385,"checkers list below. In addition to these, the analyzer contains a number of :ref:`alpha-checkers` (aka *alpha* checkers).; These checkers are under development and are switched off by default. They may crash or emit a higher number of false positives. The :ref:`debug-checkers` package contains checkers for analyzer developers for debugging purposes. .. contents:: Table of Contents; :depth: 4. .. _default-checkers:. Default Checkers; ----------------. .. _core-checkers:. core; ^^^^; Models core language features and contains general-purpose checkers such as division by zero,; null pointer dereference, usage of uninitialized values, etc.; *These checkers must be always switched on as other checker rely on them.*. .. _core-BitwiseShift:. core.BitwiseShift (C, C++); """""""""""""""""""""""""""""""""""""""""""""""""""". Finds undefined behavior caused by the bitwise left- and right-shift operator; operating on integer types. By default, this checker only reports situations when the right operand is; either negative or larger than the bit width of the type of the left operand;; these are logically unsound. Moreover, if the pedantic mode is activated by; ``-analyzer-config core.BitwiseShift:Pedantic=true``, then this checker also; reports situations where the _left_ operand of a shift operator is negative or; overflow occurs during the right shift of a signed value. (Most compilers; handle these predictably, but the C standard and the C++ standards before C++20; say that they're undefined behavior. In the C++20 standard these constructs are; well-defined, so activating pedantic mode in C++20 has no effect.). **Examples**. .. code-block:: cpp. static_assert(sizeof(int) == 4, ""assuming 32-bit int""). void basic_examples(int a, int b) {; if (b < 0) {; b = a << b; // warn: right operand is negative in left shift; } else if (b >= 32) {; b = a >> b; // warn: right shift overflows the capacity of 'int'; }; }. int pedantic_examples(int a, int b) {; if (a < 0) {; return a >> b; // warn: left operand is nega",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:2810,Testability,log,logical,2810,"e C++20 standard these constructs are; well-defined, so activating pedantic mode in C++20 has no effect.). **Examples**. .. code-block:: cpp. static_assert(sizeof(int) == 4, ""assuming 32-bit int""). void basic_examples(int a, int b) {; if (b < 0) {; b = a << b; // warn: right operand is negative in left shift; } else if (b >= 32) {; b = a >> b; // warn: right shift overflows the capacity of 'int'; }; }. int pedantic_examples(int a, int b) {; if (a < 0) {; return a >> b; // warn: left operand is negative in right shift; }; a = 1000u << 31; // OK, overflow of unsigned value is well-defined, a == 0; if (b > 10) {; a = b << 31; // this is undefined before C++20, but the checker doesn't; // warn because it doesn't know the exact value of b; }; return 1000 << 31; // warn: this overflows the capacity of 'int'; }. **Solution**. Ensure the shift operands are in proper range before shifting. .. _core-CallAndMessage:. core.CallAndMessage (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for logical errors for function calls and Objective-C message expressions (e.g., uninitialized arguments, null function pointers). .. literalinclude:: checkers/callandmessage_example.c; :language: objc. .. _core-DivideZero:. core.DivideZero (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for division by zero. .. literalinclude:: checkers/dividezero_example.c; :language: c. .. _core-NonNullParamChecker:. core.NonNullParamChecker (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for null pointers passed as arguments to a function whose arguments are references or marked with the 'nonnull' attribute. .. code-block:: cpp. int f(int *p) __attribute__((nonnull));. void test(int *p) {; if (!p); f(p); // warn; }. .. _core-NullDereference:. core.NullDereference (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for dereferences of null pointers. This checker specifically does; not report null pointer dereferences for x86 and x86-64 targets when the; address space is 256",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:3497,Testability,test,test,3497,"it doesn't know the exact value of b; }; return 1000 << 31; // warn: this overflows the capacity of 'int'; }. **Solution**. Ensure the shift operands are in proper range before shifting. .. _core-CallAndMessage:. core.CallAndMessage (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for logical errors for function calls and Objective-C message expressions (e.g., uninitialized arguments, null function pointers). .. literalinclude:: checkers/callandmessage_example.c; :language: objc. .. _core-DivideZero:. core.DivideZero (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for division by zero. .. literalinclude:: checkers/dividezero_example.c; :language: c. .. _core-NonNullParamChecker:. core.NonNullParamChecker (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for null pointers passed as arguments to a function whose arguments are references or marked with the 'nonnull' attribute. .. code-block:: cpp. int f(int *p) __attribute__((nonnull));. void test(int *p) {; if (!p); f(p); // warn; }. .. _core-NullDereference:. core.NullDereference (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for dereferences of null pointers. This checker specifically does; not report null pointer dereferences for x86 and x86-64 targets when the; address space is 256 (x86 GS Segment), 257 (x86 FS Segment), or 258 (x86 SS; segment). See `X86/X86-64 Language Extensions; <https://clang.llvm.org/docs/LanguageExtensions.html#memory-references-to-specified-segments>`__; for reference. The ``SuppressAddressSpaces`` option suppresses; warnings for null dereferences of all pointers with address spaces. You can; disable this behavior with the option; ``-analyzer-config core.NullDereference:SuppressAddressSpaces=false``.; *Defaults to true*. .. code-block:: objc. // C; void test(int *p) {; if (p); return;. int x = p[0]; // warn; }. // C; void test(int *p) {; if (!p); *p = 0; // warn; }. // C++; class C {; public:; int x;; };. void test() {; C *pc = 0;; int k = pc->x; // ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:4315,Testability,test,test,4315,"passed as arguments to a function whose arguments are references or marked with the 'nonnull' attribute. .. code-block:: cpp. int f(int *p) __attribute__((nonnull));. void test(int *p) {; if (!p); f(p); // warn; }. .. _core-NullDereference:. core.NullDereference (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for dereferences of null pointers. This checker specifically does; not report null pointer dereferences for x86 and x86-64 targets when the; address space is 256 (x86 GS Segment), 257 (x86 FS Segment), or 258 (x86 SS; segment). See `X86/X86-64 Language Extensions; <https://clang.llvm.org/docs/LanguageExtensions.html#memory-references-to-specified-segments>`__; for reference. The ``SuppressAddressSpaces`` option suppresses; warnings for null dereferences of all pointers with address spaces. You can; disable this behavior with the option; ``-analyzer-config core.NullDereference:SuppressAddressSpaces=false``.; *Defaults to true*. .. code-block:: objc. // C; void test(int *p) {; if (p); return;. int x = p[0]; // warn; }. // C; void test(int *p) {; if (!p); *p = 0; // warn; }. // C++; class C {; public:; int x;; };. void test() {; C *pc = 0;; int k = pc->x; // warn; }. // Objective-C; @interface MyClass {; @public; int x;; }; @end. void test() {; MyClass *obj = 0;; obj->x = 1; // warn; }. .. _core-StackAddressEscape:. core.StackAddressEscape (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""; Check that addresses to stack memory do not escape the function. .. code-block:: c. char const *p;. void test() {; char const str[] = ""string"";; p = str; // warn; }. void* test() {; return __builtin_alloca(12); // warn; }. void test() {; static int *x;; int y;; x = &y; // warn; }. .. _core-UndefinedBinaryOperatorResult:. core.UndefinedBinaryOperatorResult (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for undefined results of binary operators. .. code-block:: c. void test() {; int x;; int y = x + 1; // warn: left operand is garbage; }. .. _core-VLASize:. core.VLASize (C); """"""""""""""""",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:4385,Testability,test,test,4385,"ith the 'nonnull' attribute. .. code-block:: cpp. int f(int *p) __attribute__((nonnull));. void test(int *p) {; if (!p); f(p); // warn; }. .. _core-NullDereference:. core.NullDereference (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for dereferences of null pointers. This checker specifically does; not report null pointer dereferences for x86 and x86-64 targets when the; address space is 256 (x86 GS Segment), 257 (x86 FS Segment), or 258 (x86 SS; segment). See `X86/X86-64 Language Extensions; <https://clang.llvm.org/docs/LanguageExtensions.html#memory-references-to-specified-segments>`__; for reference. The ``SuppressAddressSpaces`` option suppresses; warnings for null dereferences of all pointers with address spaces. You can; disable this behavior with the option; ``-analyzer-config core.NullDereference:SuppressAddressSpaces=false``.; *Defaults to true*. .. code-block:: objc. // C; void test(int *p) {; if (p); return;. int x = p[0]; // warn; }. // C; void test(int *p) {; if (!p); *p = 0; // warn; }. // C++; class C {; public:; int x;; };. void test() {; C *pc = 0;; int k = pc->x; // warn; }. // Objective-C; @interface MyClass {; @public; int x;; }; @end. void test() {; MyClass *obj = 0;; obj->x = 1; // warn; }. .. _core-StackAddressEscape:. core.StackAddressEscape (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""; Check that addresses to stack memory do not escape the function. .. code-block:: c. char const *p;. void test() {; char const str[] = ""string"";; p = str; // warn; }. void* test() {; return __builtin_alloca(12); // warn; }. void test() {; static int *x;; int y;; x = &y; // warn; }. .. _core-UndefinedBinaryOperatorResult:. core.UndefinedBinaryOperatorResult (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for undefined results of binary operators. .. code-block:: c. void test() {; int x;; int y = x + 1; // warn: left operand is garbage; }. .. _core-VLASize:. core.VLASize (C); """"""""""""""""""""""""""""""""; Check for declarations of Variable Length Arrays of undefined or z",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:4475,Testability,test,test,4475," test(int *p) {; if (!p); f(p); // warn; }. .. _core-NullDereference:. core.NullDereference (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for dereferences of null pointers. This checker specifically does; not report null pointer dereferences for x86 and x86-64 targets when the; address space is 256 (x86 GS Segment), 257 (x86 FS Segment), or 258 (x86 SS; segment). See `X86/X86-64 Language Extensions; <https://clang.llvm.org/docs/LanguageExtensions.html#memory-references-to-specified-segments>`__; for reference. The ``SuppressAddressSpaces`` option suppresses; warnings for null dereferences of all pointers with address spaces. You can; disable this behavior with the option; ``-analyzer-config core.NullDereference:SuppressAddressSpaces=false``.; *Defaults to true*. .. code-block:: objc. // C; void test(int *p) {; if (p); return;. int x = p[0]; // warn; }. // C; void test(int *p) {; if (!p); *p = 0; // warn; }. // C++; class C {; public:; int x;; };. void test() {; C *pc = 0;; int k = pc->x; // warn; }. // Objective-C; @interface MyClass {; @public; int x;; }; @end. void test() {; MyClass *obj = 0;; obj->x = 1; // warn; }. .. _core-StackAddressEscape:. core.StackAddressEscape (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""; Check that addresses to stack memory do not escape the function. .. code-block:: c. char const *p;. void test() {; char const str[] = ""string"";; p = str; // warn; }. void* test() {; return __builtin_alloca(12); // warn; }. void test() {; static int *x;; int y;; x = &y; // warn; }. .. _core-UndefinedBinaryOperatorResult:. core.UndefinedBinaryOperatorResult (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for undefined results of binary operators. .. code-block:: c. void test() {; int x;; int y = x + 1; // warn: left operand is garbage; }. .. _core-VLASize:. core.VLASize (C); """"""""""""""""""""""""""""""""; Check for declarations of Variable Length Arrays of undefined or zero size. Check for declarations of VLA of undefined or zero size. .. code-block:: c. void test",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:4593,Testability,test,test,4593,"""""""""""""""""""""""""""""""""""""""""""""""; Check for dereferences of null pointers. This checker specifically does; not report null pointer dereferences for x86 and x86-64 targets when the; address space is 256 (x86 GS Segment), 257 (x86 FS Segment), or 258 (x86 SS; segment). See `X86/X86-64 Language Extensions; <https://clang.llvm.org/docs/LanguageExtensions.html#memory-references-to-specified-segments>`__; for reference. The ``SuppressAddressSpaces`` option suppresses; warnings for null dereferences of all pointers with address spaces. You can; disable this behavior with the option; ``-analyzer-config core.NullDereference:SuppressAddressSpaces=false``.; *Defaults to true*. .. code-block:: objc. // C; void test(int *p) {; if (p); return;. int x = p[0]; // warn; }. // C; void test(int *p) {; if (!p); *p = 0; // warn; }. // C++; class C {; public:; int x;; };. void test() {; C *pc = 0;; int k = pc->x; // warn; }. // Objective-C; @interface MyClass {; @public; int x;; }; @end. void test() {; MyClass *obj = 0;; obj->x = 1; // warn; }. .. _core-StackAddressEscape:. core.StackAddressEscape (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""; Check that addresses to stack memory do not escape the function. .. code-block:: c. char const *p;. void test() {; char const str[] = ""string"";; p = str; // warn; }. void* test() {; return __builtin_alloca(12); // warn; }. void test() {; static int *x;; int y;; x = &y; // warn; }. .. _core-UndefinedBinaryOperatorResult:. core.UndefinedBinaryOperatorResult (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for undefined results of binary operators. .. code-block:: c. void test() {; int x;; int y = x + 1; // warn: left operand is garbage; }. .. _core-VLASize:. core.VLASize (C); """"""""""""""""""""""""""""""""; Check for declarations of Variable Length Arrays of undefined or zero size. Check for declarations of VLA of undefined or zero size. .. code-block:: c. void test() {; int x;; int vla1[x]; // warn: garbage as size; }. void test() {; int x = 0;; int vla2[x]; // warn: zero size; }. .",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:4839,Testability,test,test,4839,"egment). See `X86/X86-64 Language Extensions; <https://clang.llvm.org/docs/LanguageExtensions.html#memory-references-to-specified-segments>`__; for reference. The ``SuppressAddressSpaces`` option suppresses; warnings for null dereferences of all pointers with address spaces. You can; disable this behavior with the option; ``-analyzer-config core.NullDereference:SuppressAddressSpaces=false``.; *Defaults to true*. .. code-block:: objc. // C; void test(int *p) {; if (p); return;. int x = p[0]; // warn; }. // C; void test(int *p) {; if (!p); *p = 0; // warn; }. // C++; class C {; public:; int x;; };. void test() {; C *pc = 0;; int k = pc->x; // warn; }. // Objective-C; @interface MyClass {; @public; int x;; }; @end. void test() {; MyClass *obj = 0;; obj->x = 1; // warn; }. .. _core-StackAddressEscape:. core.StackAddressEscape (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""; Check that addresses to stack memory do not escape the function. .. code-block:: c. char const *p;. void test() {; char const str[] = ""string"";; p = str; // warn; }. void* test() {; return __builtin_alloca(12); // warn; }. void test() {; static int *x;; int y;; x = &y; // warn; }. .. _core-UndefinedBinaryOperatorResult:. core.UndefinedBinaryOperatorResult (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for undefined results of binary operators. .. code-block:: c. void test() {; int x;; int y = x + 1; // warn: left operand is garbage; }. .. _core-VLASize:. core.VLASize (C); """"""""""""""""""""""""""""""""; Check for declarations of Variable Length Arrays of undefined or zero size. Check for declarations of VLA of undefined or zero size. .. code-block:: c. void test() {; int x;; int vla1[x]; // warn: garbage as size; }. void test() {; int x = 0;; int vla2[x]; // warn: zero size; }. .. _core-uninitialized-ArraySubscript:. core.uninitialized.ArraySubscript (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for uninitialized values used as array subscripts. .. code-block:: c. void test() {; int i, a[10];; int x = a[i]; // warn: arra",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:4906,Testability,test,test,4906,"llvm.org/docs/LanguageExtensions.html#memory-references-to-specified-segments>`__; for reference. The ``SuppressAddressSpaces`` option suppresses; warnings for null dereferences of all pointers with address spaces. You can; disable this behavior with the option; ``-analyzer-config core.NullDereference:SuppressAddressSpaces=false``.; *Defaults to true*. .. code-block:: objc. // C; void test(int *p) {; if (p); return;. int x = p[0]; // warn; }. // C; void test(int *p) {; if (!p); *p = 0; // warn; }. // C++; class C {; public:; int x;; };. void test() {; C *pc = 0;; int k = pc->x; // warn; }. // Objective-C; @interface MyClass {; @public; int x;; }; @end. void test() {; MyClass *obj = 0;; obj->x = 1; // warn; }. .. _core-StackAddressEscape:. core.StackAddressEscape (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""; Check that addresses to stack memory do not escape the function. .. code-block:: c. char const *p;. void test() {; char const str[] = ""string"";; p = str; // warn; }. void* test() {; return __builtin_alloca(12); // warn; }. void test() {; static int *x;; int y;; x = &y; // warn; }. .. _core-UndefinedBinaryOperatorResult:. core.UndefinedBinaryOperatorResult (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for undefined results of binary operators. .. code-block:: c. void test() {; int x;; int y = x + 1; // warn: left operand is garbage; }. .. _core-VLASize:. core.VLASize (C); """"""""""""""""""""""""""""""""; Check for declarations of Variable Length Arrays of undefined or zero size. Check for declarations of VLA of undefined or zero size. .. code-block:: c. void test() {; int x;; int vla1[x]; // warn: garbage as size; }. void test() {; int x = 0;; int vla2[x]; // warn: zero size; }. .. _core-uninitialized-ArraySubscript:. core.uninitialized.ArraySubscript (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for uninitialized values used as array subscripts. .. code-block:: c. void test() {; int i, a[10];; int x = a[i]; // warn: array subscript is undefined; }. .. _core-uninitialized-Assign:. c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:4962,Testability,test,test,4962,"-specified-segments>`__; for reference. The ``SuppressAddressSpaces`` option suppresses; warnings for null dereferences of all pointers with address spaces. You can; disable this behavior with the option; ``-analyzer-config core.NullDereference:SuppressAddressSpaces=false``.; *Defaults to true*. .. code-block:: objc. // C; void test(int *p) {; if (p); return;. int x = p[0]; // warn; }. // C; void test(int *p) {; if (!p); *p = 0; // warn; }. // C++; class C {; public:; int x;; };. void test() {; C *pc = 0;; int k = pc->x; // warn; }. // Objective-C; @interface MyClass {; @public; int x;; }; @end. void test() {; MyClass *obj = 0;; obj->x = 1; // warn; }. .. _core-StackAddressEscape:. core.StackAddressEscape (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""; Check that addresses to stack memory do not escape the function. .. code-block:: c. char const *p;. void test() {; char const str[] = ""string"";; p = str; // warn; }. void* test() {; return __builtin_alloca(12); // warn; }. void test() {; static int *x;; int y;; x = &y; // warn; }. .. _core-UndefinedBinaryOperatorResult:. core.UndefinedBinaryOperatorResult (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for undefined results of binary operators. .. code-block:: c. void test() {; int x;; int y = x + 1; // warn: left operand is garbage; }. .. _core-VLASize:. core.VLASize (C); """"""""""""""""""""""""""""""""; Check for declarations of Variable Length Arrays of undefined or zero size. Check for declarations of VLA of undefined or zero size. .. code-block:: c. void test() {; int x;; int vla1[x]; // warn: garbage as size; }. void test() {; int x = 0;; int vla2[x]; // warn: zero size; }. .. _core-uninitialized-ArraySubscript:. core.uninitialized.ArraySubscript (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for uninitialized values used as array subscripts. .. code-block:: c. void test() {; int i, a[10];; int x = a[i]; // warn: array subscript is undefined; }. .. _core-uninitialized-Assign:. core.uninitialized.Assign (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:5210,Testability,test,test,5210,"ressSpaces=false``.; *Defaults to true*. .. code-block:: objc. // C; void test(int *p) {; if (p); return;. int x = p[0]; // warn; }. // C; void test(int *p) {; if (!p); *p = 0; // warn; }. // C++; class C {; public:; int x;; };. void test() {; C *pc = 0;; int k = pc->x; // warn; }. // Objective-C; @interface MyClass {; @public; int x;; }; @end. void test() {; MyClass *obj = 0;; obj->x = 1; // warn; }. .. _core-StackAddressEscape:. core.StackAddressEscape (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""; Check that addresses to stack memory do not escape the function. .. code-block:: c. char const *p;. void test() {; char const str[] = ""string"";; p = str; // warn; }. void* test() {; return __builtin_alloca(12); // warn; }. void test() {; static int *x;; int y;; x = &y; // warn; }. .. _core-UndefinedBinaryOperatorResult:. core.UndefinedBinaryOperatorResult (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for undefined results of binary operators. .. code-block:: c. void test() {; int x;; int y = x + 1; // warn: left operand is garbage; }. .. _core-VLASize:. core.VLASize (C); """"""""""""""""""""""""""""""""; Check for declarations of Variable Length Arrays of undefined or zero size. Check for declarations of VLA of undefined or zero size. .. code-block:: c. void test() {; int x;; int vla1[x]; // warn: garbage as size; }. void test() {; int x = 0;; int vla2[x]; // warn: zero size; }. .. _core-uninitialized-ArraySubscript:. core.uninitialized.ArraySubscript (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for uninitialized values used as array subscripts. .. code-block:: c. void test() {; int i, a[10];; int x = a[i]; // warn: array subscript is undefined; }. .. _core-uninitialized-Assign:. core.uninitialized.Assign (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for assigning uninitialized values. .. code-block:: c. void test() {; int x;; x |= 1; // warn: left expression is uninitialized; }. .. _core-uninitialized-Branch:. core.uninitialized.Branch (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for uninitializ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:5492,Testability,test,test,5492,"n; }. // Objective-C; @interface MyClass {; @public; int x;; }; @end. void test() {; MyClass *obj = 0;; obj->x = 1; // warn; }. .. _core-StackAddressEscape:. core.StackAddressEscape (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""; Check that addresses to stack memory do not escape the function. .. code-block:: c. char const *p;. void test() {; char const str[] = ""string"";; p = str; // warn; }. void* test() {; return __builtin_alloca(12); // warn; }. void test() {; static int *x;; int y;; x = &y; // warn; }. .. _core-UndefinedBinaryOperatorResult:. core.UndefinedBinaryOperatorResult (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for undefined results of binary operators. .. code-block:: c. void test() {; int x;; int y = x + 1; // warn: left operand is garbage; }. .. _core-VLASize:. core.VLASize (C); """"""""""""""""""""""""""""""""; Check for declarations of Variable Length Arrays of undefined or zero size. Check for declarations of VLA of undefined or zero size. .. code-block:: c. void test() {; int x;; int vla1[x]; // warn: garbage as size; }. void test() {; int x = 0;; int vla2[x]; // warn: zero size; }. .. _core-uninitialized-ArraySubscript:. core.uninitialized.ArraySubscript (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for uninitialized values used as array subscripts. .. code-block:: c. void test() {; int i, a[10];; int x = a[i]; // warn: array subscript is undefined; }. .. _core-uninitialized-Assign:. core.uninitialized.Assign (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for assigning uninitialized values. .. code-block:: c. void test() {; int x;; x |= 1; // warn: left expression is uninitialized; }. .. _core-uninitialized-Branch:. core.uninitialized.Branch (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for uninitialized values used as branch conditions. .. code-block:: c. void test() {; int x;; if (x) // warn; return;; }. .. _core-uninitialized-CapturedBlockVariable:. core.uninitialized.CapturedBlockVariable (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for blocks that capture u",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:5557,Testability,test,test,5557,"@end. void test() {; MyClass *obj = 0;; obj->x = 1; // warn; }. .. _core-StackAddressEscape:. core.StackAddressEscape (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""; Check that addresses to stack memory do not escape the function. .. code-block:: c. char const *p;. void test() {; char const str[] = ""string"";; p = str; // warn; }. void* test() {; return __builtin_alloca(12); // warn; }. void test() {; static int *x;; int y;; x = &y; // warn; }. .. _core-UndefinedBinaryOperatorResult:. core.UndefinedBinaryOperatorResult (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for undefined results of binary operators. .. code-block:: c. void test() {; int x;; int y = x + 1; // warn: left operand is garbage; }. .. _core-VLASize:. core.VLASize (C); """"""""""""""""""""""""""""""""; Check for declarations of Variable Length Arrays of undefined or zero size. Check for declarations of VLA of undefined or zero size. .. code-block:: c. void test() {; int x;; int vla1[x]; // warn: garbage as size; }. void test() {; int x = 0;; int vla2[x]; // warn: zero size; }. .. _core-uninitialized-ArraySubscript:. core.uninitialized.ArraySubscript (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for uninitialized values used as array subscripts. .. code-block:: c. void test() {; int i, a[10];; int x = a[i]; // warn: array subscript is undefined; }. .. _core-uninitialized-Assign:. core.uninitialized.Assign (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for assigning uninitialized values. .. code-block:: c. void test() {; int x;; x |= 1; // warn: left expression is uninitialized; }. .. _core-uninitialized-Branch:. core.uninitialized.Branch (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for uninitialized values used as branch conditions. .. code-block:: c. void test() {; int x;; if (x) // warn; return;; }. .. _core-uninitialized-CapturedBlockVariable:. core.uninitialized.CapturedBlockVariable (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for blocks that capture uninitialized values. .. code-block:: c. void test() {; int x;; ^",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:5814,Testability,test,test,5814,"ar const str[] = ""string"";; p = str; // warn; }. void* test() {; return __builtin_alloca(12); // warn; }. void test() {; static int *x;; int y;; x = &y; // warn; }. .. _core-UndefinedBinaryOperatorResult:. core.UndefinedBinaryOperatorResult (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for undefined results of binary operators. .. code-block:: c. void test() {; int x;; int y = x + 1; // warn: left operand is garbage; }. .. _core-VLASize:. core.VLASize (C); """"""""""""""""""""""""""""""""; Check for declarations of Variable Length Arrays of undefined or zero size. Check for declarations of VLA of undefined or zero size. .. code-block:: c. void test() {; int x;; int vla1[x]; // warn: garbage as size; }. void test() {; int x = 0;; int vla2[x]; // warn: zero size; }. .. _core-uninitialized-ArraySubscript:. core.uninitialized.ArraySubscript (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for uninitialized values used as array subscripts. .. code-block:: c. void test() {; int i, a[10];; int x = a[i]; // warn: array subscript is undefined; }. .. _core-uninitialized-Assign:. core.uninitialized.Assign (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for assigning uninitialized values. .. code-block:: c. void test() {; int x;; x |= 1; // warn: left expression is uninitialized; }. .. _core-uninitialized-Branch:. core.uninitialized.Branch (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for uninitialized values used as branch conditions. .. code-block:: c. void test() {; int x;; if (x) // warn; return;; }. .. _core-uninitialized-CapturedBlockVariable:. core.uninitialized.CapturedBlockVariable (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for blocks that capture uninitialized values. .. code-block:: c. void test() {; int x;; ^{ int y = x; }(); // warn; }. .. _core-uninitialized-UndefReturn:. core.uninitialized.UndefReturn (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for uninitialized values being returned to the caller. .. code-block:: c. int test() {; int x;; return x; // warn; }. .. _c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:6055,Testability,test,test,6055,"sult (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for undefined results of binary operators. .. code-block:: c. void test() {; int x;; int y = x + 1; // warn: left operand is garbage; }. .. _core-VLASize:. core.VLASize (C); """"""""""""""""""""""""""""""""; Check for declarations of Variable Length Arrays of undefined or zero size. Check for declarations of VLA of undefined or zero size. .. code-block:: c. void test() {; int x;; int vla1[x]; // warn: garbage as size; }. void test() {; int x = 0;; int vla2[x]; // warn: zero size; }. .. _core-uninitialized-ArraySubscript:. core.uninitialized.ArraySubscript (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for uninitialized values used as array subscripts. .. code-block:: c. void test() {; int i, a[10];; int x = a[i]; // warn: array subscript is undefined; }. .. _core-uninitialized-Assign:. core.uninitialized.Assign (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for assigning uninitialized values. .. code-block:: c. void test() {; int x;; x |= 1; // warn: left expression is uninitialized; }. .. _core-uninitialized-Branch:. core.uninitialized.Branch (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for uninitialized values used as branch conditions. .. code-block:: c. void test() {; int x;; if (x) // warn; return;; }. .. _core-uninitialized-CapturedBlockVariable:. core.uninitialized.CapturedBlockVariable (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for blocks that capture uninitialized values. .. code-block:: c. void test() {; int x;; ^{ int y = x; }(); // warn; }. .. _core-uninitialized-UndefReturn:. core.uninitialized.UndefReturn (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for uninitialized values being returned to the caller. .. code-block:: c. int test() {; int x;; return x; // warn; }. .. _core-uninitialized-NewArraySize:. core.uninitialized.NewArraySize (C++); """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Check if the element count in new[] is garbage or undefined. .. code-block:: cpp. void test() {; int n;; int *arr = new int[n]",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:6303,Testability,test,test,6303,"""""""""""""""""""""""; Check for declarations of Variable Length Arrays of undefined or zero size. Check for declarations of VLA of undefined or zero size. .. code-block:: c. void test() {; int x;; int vla1[x]; // warn: garbage as size; }. void test() {; int x = 0;; int vla2[x]; // warn: zero size; }. .. _core-uninitialized-ArraySubscript:. core.uninitialized.ArraySubscript (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for uninitialized values used as array subscripts. .. code-block:: c. void test() {; int i, a[10];; int x = a[i]; // warn: array subscript is undefined; }. .. _core-uninitialized-Assign:. core.uninitialized.Assign (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for assigning uninitialized values. .. code-block:: c. void test() {; int x;; x |= 1; // warn: left expression is uninitialized; }. .. _core-uninitialized-Branch:. core.uninitialized.Branch (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for uninitialized values used as branch conditions. .. code-block:: c. void test() {; int x;; if (x) // warn; return;; }. .. _core-uninitialized-CapturedBlockVariable:. core.uninitialized.CapturedBlockVariable (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for blocks that capture uninitialized values. .. code-block:: c. void test() {; int x;; ^{ int y = x; }(); // warn; }. .. _core-uninitialized-UndefReturn:. core.uninitialized.UndefReturn (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for uninitialized values being returned to the caller. .. code-block:: c. int test() {; int x;; return x; // warn; }. .. _core-uninitialized-NewArraySize:. core.uninitialized.NewArraySize (C++); """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Check if the element count in new[] is garbage or undefined. .. code-block:: cpp. void test() {; int n;; int *arr = new int[n]; // warn: Element count in new[] is a garbage value; delete[] arr;; }. .. _cplusplus-checkers:. cplusplus; ^^^^^^^^^. C++ Checkers. .. _cplusplus-InnerPointer:. cplusplus.InnerPointer (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for inn",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:6564,Testability,test,test,6564,"a2[x]; // warn: zero size; }. .. _core-uninitialized-ArraySubscript:. core.uninitialized.ArraySubscript (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for uninitialized values used as array subscripts. .. code-block:: c. void test() {; int i, a[10];; int x = a[i]; // warn: array subscript is undefined; }. .. _core-uninitialized-Assign:. core.uninitialized.Assign (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for assigning uninitialized values. .. code-block:: c. void test() {; int x;; x |= 1; // warn: left expression is uninitialized; }. .. _core-uninitialized-Branch:. core.uninitialized.Branch (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for uninitialized values used as branch conditions. .. code-block:: c. void test() {; int x;; if (x) // warn; return;; }. .. _core-uninitialized-CapturedBlockVariable:. core.uninitialized.CapturedBlockVariable (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for blocks that capture uninitialized values. .. code-block:: c. void test() {; int x;; ^{ int y = x; }(); // warn; }. .. _core-uninitialized-UndefReturn:. core.uninitialized.UndefReturn (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for uninitialized values being returned to the caller. .. code-block:: c. int test() {; int x;; return x; // warn; }. .. _core-uninitialized-NewArraySize:. core.uninitialized.NewArraySize (C++); """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Check if the element count in new[] is garbage or undefined. .. code-block:: cpp. void test() {; int n;; int *arr = new int[n]; // warn: Element count in new[] is a garbage value; delete[] arr;; }. .. _cplusplus-checkers:. cplusplus; ^^^^^^^^^. C++ Checkers. .. _cplusplus-InnerPointer:. cplusplus.InnerPointer (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for inner pointers of C++ containers used after re/deallocation. Many container methods in the C++ standard library are known to invalidate; ""references"" (including actual references, iterators and raw pointers) to; elements of the container. Using such references afte",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:6806,Testability,test,test,6806," int i, a[10];; int x = a[i]; // warn: array subscript is undefined; }. .. _core-uninitialized-Assign:. core.uninitialized.Assign (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for assigning uninitialized values. .. code-block:: c. void test() {; int x;; x |= 1; // warn: left expression is uninitialized; }. .. _core-uninitialized-Branch:. core.uninitialized.Branch (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for uninitialized values used as branch conditions. .. code-block:: c. void test() {; int x;; if (x) // warn; return;; }. .. _core-uninitialized-CapturedBlockVariable:. core.uninitialized.CapturedBlockVariable (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for blocks that capture uninitialized values. .. code-block:: c. void test() {; int x;; ^{ int y = x; }(); // warn; }. .. _core-uninitialized-UndefReturn:. core.uninitialized.UndefReturn (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for uninitialized values being returned to the caller. .. code-block:: c. int test() {; int x;; return x; // warn; }. .. _core-uninitialized-NewArraySize:. core.uninitialized.NewArraySize (C++); """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Check if the element count in new[] is garbage or undefined. .. code-block:: cpp. void test() {; int n;; int *arr = new int[n]; // warn: Element count in new[] is a garbage value; delete[] arr;; }. .. _cplusplus-checkers:. cplusplus; ^^^^^^^^^. C++ Checkers. .. _cplusplus-InnerPointer:. cplusplus.InnerPointer (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for inner pointers of C++ containers used after re/deallocation. Many container methods in the C++ standard library are known to invalidate; ""references"" (including actual references, iterators and raw pointers) to; elements of the container. Using such references after they are invalidated; causes undefined behavior, which is a common source of memory errors in C++ that; this checker is capable of finding. The checker is currently limited to ``std::string`` objects and doesn't; recognize some of the m",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:7049,Testability,test,test,7049,"sion is uninitialized; }. .. _core-uninitialized-Branch:. core.uninitialized.Branch (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for uninitialized values used as branch conditions. .. code-block:: c. void test() {; int x;; if (x) // warn; return;; }. .. _core-uninitialized-CapturedBlockVariable:. core.uninitialized.CapturedBlockVariable (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for blocks that capture uninitialized values. .. code-block:: c. void test() {; int x;; ^{ int y = x; }(); // warn; }. .. _core-uninitialized-UndefReturn:. core.uninitialized.UndefReturn (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for uninitialized values being returned to the caller. .. code-block:: c. int test() {; int x;; return x; // warn; }. .. _core-uninitialized-NewArraySize:. core.uninitialized.NewArraySize (C++); """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". Check if the element count in new[] is garbage or undefined. .. code-block:: cpp. void test() {; int n;; int *arr = new int[n]; // warn: Element count in new[] is a garbage value; delete[] arr;; }. .. _cplusplus-checkers:. cplusplus; ^^^^^^^^^. C++ Checkers. .. _cplusplus-InnerPointer:. cplusplus.InnerPointer (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for inner pointers of C++ containers used after re/deallocation. Many container methods in the C++ standard library are known to invalidate; ""references"" (including actual references, iterators and raw pointers) to; elements of the container. Using such references after they are invalidated; causes undefined behavior, which is a common source of memory errors in C++ that; this checker is capable of finding. The checker is currently limited to ``std::string`` objects and doesn't; recognize some of the more sophisticated approaches to passing unowned pointers; around, such as ``std::string_view``. .. code-block:: cpp. void deref_after_assignment() {; std::string s = ""llvm"";; const char *c = s.data(); // note: pointer to inner buffer of 'std::string' obtained here; s = ""clang"";",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:8948,Testability,test,test,8948,"ent() {; std::string s = ""llvm"";; const char *c = s.data(); // note: pointer to inner buffer of 'std::string' obtained here; s = ""clang""; // note: inner buffer of 'std::string' reallocated by call to 'operator='; consume(c); // warn: inner pointer of container used after re/deallocation; }. const char *return_temp(int x) {; return std::to_string(x).c_str(); // warn: inner pointer of container used after re/deallocation; // note: pointer to inner buffer of 'std::string' obtained here; // note: inner buffer of 'std::string' deallocated by call to destructor; }. .. _cplusplus-NewDelete:. cplusplus.NewDelete (C++); """"""""""""""""""""""""""""""""""""""""""""""""""; Check for double-free and use-after-free problems. Traces memory managed by new/delete. .. literalinclude:: checkers/newdelete_example.cpp; :language: cpp. .. _cplusplus-NewDeleteLeaks:. cplusplus.NewDeleteLeaks (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for memory leaks. Traces memory managed by new/delete. .. code-block:: cpp. void test() {; int *p = new int;; } // warn. .. _cplusplus-PlacementNew:. cplusplus.PlacementNew (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""; Check if default placement new is provided with pointers to sufficient storage capacity. .. code-block:: cpp. #include <new>. void f() {; short s;; long *lp = ::new (&s) long; // warn; }. .. _cplusplus-SelfAssignment:. cplusplus.SelfAssignment (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Checks C++ copy and move assignment operators for self assignment. .. _cplusplus-StringChecker:. cplusplus.StringChecker (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Checks std::string operations. Checks if the cstring pointer from which the ``std::string`` object is; constructed is ``NULL`` or not.; If the checker cannot reason about the nullness of the pointer it will assume; that it was non-null to satisfy the precondition of the constructor. This checker is capable of checking the `SEI CERT C++ coding rule STR51-CPP.; Do not attempt to create a std::string from a null pointer; <https://wiki.sei.cmu.ed",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:10368,Testability,test,test,10368,"e assignment operators for self assignment. .. _cplusplus-StringChecker:. cplusplus.StringChecker (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Checks std::string operations. Checks if the cstring pointer from which the ``std::string`` object is; constructed is ``NULL`` or not.; If the checker cannot reason about the nullness of the pointer it will assume; that it was non-null to satisfy the precondition of the constructor. This checker is capable of checking the `SEI CERT C++ coding rule STR51-CPP.; Do not attempt to create a std::string from a null pointer; <https://wiki.sei.cmu.edu/confluence/x/E3s-BQ>`__. .. code-block:: cpp. #include <string>. void f(const char *p) {; if (!p) {; std::string msg(p); // warn: The parameter must not be null; }; }. .. _deadcode-checkers:. deadcode; ^^^^^^^^. Dead Code Checkers. .. _deadcode-DeadStores:. deadcode.DeadStores (C); """"""""""""""""""""""""""""""""""""""""""""""; Check for values stored to variables that are never read afterwards. .. code-block:: c. void test() {; int x;; x = 1; // warn; }. The ``WarnForDeadNestedAssignments`` option enables the checker to emit; warnings for nested dead assignments. You can disable with the; ``-analyzer-config deadcode.DeadStores:WarnForDeadNestedAssignments=false``.; *Defaults to true*. Would warn for this e.g.:; if ((y = make_int())) {; }. .. _nullability-checkers:. nullability; ^^^^^^^^^^^. Objective C checkers that warn for null pointer passing and dereferencing errors. .. _nullability-NullPassedToNonnull:. nullability.NullPassedToNonnull (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns when a null pointer is passed to a pointer which has a _Nonnull type. .. code-block:: objc. if (name != nil); return;; // Warning: nil passed to a callee that requires a non-null 1st parameter; NSString *greeting = [@""Hello "" stringByAppendingString:name];. .. _nullability-NullReturnedFromNonnull:. nullability.NullReturnedFromNonnull (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns when a null pointer is returned fro",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:12490,Testability,test,test,12490,"; result = _children[0];. // Warning: nil returned from a method that is expected; // to return a non-null value; return result;; }. .. _nullability-NullableDereferenced:. nullability.NullableDereferenced (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns when a nullable pointer is dereferenced. .. code-block:: objc. struct LinkedList {; int data;; struct LinkedList *next;; };. struct LinkedList * _Nullable getNext(struct LinkedList *l);. void updateNextData(struct LinkedList *list, int newData) {; struct LinkedList *next = getNext(list);; // Warning: Nullable pointer is dereferenced; next->data = 7;; }. .. _nullability-NullablePassedToNonnull:. nullability.NullablePassedToNonnull (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns when a nullable pointer is passed to a pointer which has a _Nonnull type. .. code-block:: objc. typedef struct Dummy { int val; } Dummy;; Dummy *_Nullable returnsNullable();; void takesNonnull(Dummy *_Nonnull);. void test() {; Dummy *p = returnsNullable();; takesNonnull(p); // warn; }. .. _nullability-NullableReturnedFromNonnull:. nullability.NullableReturnedFromNonnull (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns when a nullable pointer is returned from a function that has _Nonnull return type. .. _optin-checkers:. optin; ^^^^^. Checkers for portability, performance or coding style specific rules. .. _optin-core-EnumCastOutOfRange:. optin.core.EnumCastOutOfRange (C, C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for integer to enumeration casts that would produce a value with no; corresponding enumerator. This is not necessarily undefined behavior, but can; lead to nasty surprises, so projects may decide to use a coding standard that; disallows these ""unusual"" conversions. Note that no warnings are produced when the enum type (e.g. `std::byte`) has no; enumerators at all. .. code-block:: cpp. enum WidgetKind { A=1, B, C, X=99 };. void foo() {; WidgetKind c = static_cast<WidgetKind>(3); // OK; WidgetKind x =",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:17427,Testability,test,test,17427,"that belongs to it in; notes. *Defaults to false*. * ``CheckPointeeInitialization`` (boolean). If set to false, the checker will; not analyze the pointee of pointer/reference fields, and will only check; whether the object itself is initialized. *Defaults to false*. * ``IgnoreRecordsWithField`` (string). If supplied, the checker will not analyze; structures that have a field with a name or type name that matches the given; pattern. *Defaults to """"*. .. _optin-cplusplus-VirtualCall:. optin.cplusplus.VirtualCall (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check virtual function calls during construction or destruction. .. code-block:: cpp. class A {; public:; A() {; f(); // warn; }; virtual void f();; };. class A {; public:; ~A() {; this->f(); // warn; }; virtual void f();; };. .. _optin-mpi-MPI-Checker:. optin.mpi.MPI-Checker (C); """"""""""""""""""""""""""""""""""""""""""""""""""; Checks MPI code. .. code-block:: c. void test() {; double buf = 0;; MPI_Request sendReq1;; MPI_Ireduce(MPI_IN_PLACE, &buf, 1, MPI_DOUBLE, MPI_SUM,; 0, MPI_COMM_WORLD, &sendReq1);; } // warn: request 'sendReq1' has no matching wait. void test() {; double buf = 0;; MPI_Request sendReq;; MPI_Isend(&buf, 1, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD, &sendReq);; MPI_Irecv(&buf, 1, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD, &sendReq); // warn; MPI_Isend(&buf, 1, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD, &sendReq); // warn; MPI_Wait(&sendReq, MPI_STATUS_IGNORE);; }. void missingNonBlocking() {; int rank = 0;; MPI_Comm_rank(MPI_COMM_WORLD, &rank);; MPI_Request sendReq1[10][10][10];; MPI_Wait(&sendReq1[1][7][9], MPI_STATUS_IGNORE); // warn; }. .. _optin-osx-cocoa-localizability-EmptyLocalizationContextChecker:. optin.osx.cocoa.localizability.EmptyLocalizationContextChecker (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check that NSLocalizedString macros include a comment for context. .. code-block:: objc. - (void)test {; NSString *string = NSLocalizedString(@""LocalizedString"", nil); // warn; NSString *string2 = NSLoca",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:17623,Testability,test,test,17623,"lts to false*. * ``IgnoreRecordsWithField`` (string). If supplied, the checker will not analyze; structures that have a field with a name or type name that matches the given; pattern. *Defaults to """"*. .. _optin-cplusplus-VirtualCall:. optin.cplusplus.VirtualCall (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check virtual function calls during construction or destruction. .. code-block:: cpp. class A {; public:; A() {; f(); // warn; }; virtual void f();; };. class A {; public:; ~A() {; this->f(); // warn; }; virtual void f();; };. .. _optin-mpi-MPI-Checker:. optin.mpi.MPI-Checker (C); """"""""""""""""""""""""""""""""""""""""""""""""""; Checks MPI code. .. code-block:: c. void test() {; double buf = 0;; MPI_Request sendReq1;; MPI_Ireduce(MPI_IN_PLACE, &buf, 1, MPI_DOUBLE, MPI_SUM,; 0, MPI_COMM_WORLD, &sendReq1);; } // warn: request 'sendReq1' has no matching wait. void test() {; double buf = 0;; MPI_Request sendReq;; MPI_Isend(&buf, 1, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD, &sendReq);; MPI_Irecv(&buf, 1, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD, &sendReq); // warn; MPI_Isend(&buf, 1, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD, &sendReq); // warn; MPI_Wait(&sendReq, MPI_STATUS_IGNORE);; }. void missingNonBlocking() {; int rank = 0;; MPI_Comm_rank(MPI_COMM_WORLD, &rank);; MPI_Request sendReq1[10][10][10];; MPI_Wait(&sendReq1[1][7][9], MPI_STATUS_IGNORE); // warn; }. .. _optin-osx-cocoa-localizability-EmptyLocalizationContextChecker:. optin.osx.cocoa.localizability.EmptyLocalizationContextChecker (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check that NSLocalizedString macros include a comment for context. .. code-block:: objc. - (void)test {; NSString *string = NSLocalizedString(@""LocalizedString"", nil); // warn; NSString *string2 = NSLocalizedString(@""LocalizedString"", @"" ""); // warn; NSString *string3 = NSLocalizedStringWithDefaultValue(; @""LocalizedString"", nil, [[NSBundle alloc] init], nil,@""""); // warn; }. .. _optin-osx-cocoa-localizability-NonLocalizedStringChecker:. optin.osx.coc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:18413,Testability,test,test,18413,"LD, &sendReq1);; } // warn: request 'sendReq1' has no matching wait. void test() {; double buf = 0;; MPI_Request sendReq;; MPI_Isend(&buf, 1, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD, &sendReq);; MPI_Irecv(&buf, 1, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD, &sendReq); // warn; MPI_Isend(&buf, 1, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD, &sendReq); // warn; MPI_Wait(&sendReq, MPI_STATUS_IGNORE);; }. void missingNonBlocking() {; int rank = 0;; MPI_Comm_rank(MPI_COMM_WORLD, &rank);; MPI_Request sendReq1[10][10][10];; MPI_Wait(&sendReq1[1][7][9], MPI_STATUS_IGNORE); // warn; }. .. _optin-osx-cocoa-localizability-EmptyLocalizationContextChecker:. optin.osx.cocoa.localizability.EmptyLocalizationContextChecker (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check that NSLocalizedString macros include a comment for context. .. code-block:: objc. - (void)test {; NSString *string = NSLocalizedString(@""LocalizedString"", nil); // warn; NSString *string2 = NSLocalizedString(@""LocalizedString"", @"" ""); // warn; NSString *string3 = NSLocalizedStringWithDefaultValue(; @""LocalizedString"", nil, [[NSBundle alloc] init], nil,@""""); // warn; }. .. _optin-osx-cocoa-localizability-NonLocalizedStringChecker:. optin.osx.cocoa.localizability.NonLocalizedStringChecker (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns about uses of non-localized NSStrings passed to UI methods expecting localized NSStrings. .. code-block:: objc. NSString *alarmText =; NSLocalizedString(@""Enabled"", @""Indicates alarm is turned on"");; if (!isEnabled) {; alarmText = @""Disabled"";; }; UILabel *alarmStateLabel = [[UILabel alloc] init];. // Warning: User-facing text should use localized string macro; [alarmStateLabel setText:alarmText];. .. _optin-performance-GCDAntipattern:. optin.performance.GCDAntipattern; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for performance anti-patterns when using Grand Central Dispatch. .. _optin-performance-Padding:. optin.performance.Padding; """"""""""""""""""""""""""""""""",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:22463,Testability,test,test,22463,"// dereferencing invalid pointer; }. The ``InvalidatingGetEnv`` option is available for treating ``getenv`` calls as; invalidating. When enabled, the checker issues a warning if ``getenv`` is called; multiple times and their results are used without first creating a copy.; This level of strictness might be considered overly pedantic for the commonly; used ``getenv`` implementations. To enable this option, use:; ``-analyzer-config security.cert.env.InvalidPtr:InvalidatingGetEnv=true``. By default, this option is set to *false*. When this option is enabled, warnings will be generated for scenarios like the; following:. .. code-block:: c. char* p = getenv(""VAR"");; char* pp = getenv(""VAR2""); // assumes this call can invalidate `env`; strlen(p); // warns about accessing invalid ptr. .. _security-FloatLoopCounter:. security.FloatLoopCounter (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on using a floating point value as a loop counter (CERT: FLP30-C, FLP30-CPP). .. code-block:: c. void test() {; for (float x = 0.1f; x <= 1.0f; x += 0.1f) {} // warn; }. .. _security-insecureAPI-UncheckedReturn:. security.insecureAPI.UncheckedReturn (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of functions whose return values must be always checked. .. code-block:: c. void test() {; setuid(1); // warn; }. .. _security-insecureAPI-bcmp:. security.insecureAPI.bcmp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcmp' function. .. code-block:: c. void test() {; bcmp(ptr0, ptr1, n); // warn; }. .. _security-insecureAPI-bcopy:. security.insecureAPI.bcopy (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcopy' function. .. code-block:: c. void test() {; bcopy(src, dst, n); // warn; }. .. _security-insecureAPI-bzero:. security.insecureAPI.bzero (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bzero' function. .. code-block:: c. void test() {; bzero(ptr, n); // warn; }. .. _security-insecureAPI-getpw:. security.insecureAPI.getpw (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:22752,Testability,test,test,22752,"ctness might be considered overly pedantic for the commonly; used ``getenv`` implementations. To enable this option, use:; ``-analyzer-config security.cert.env.InvalidPtr:InvalidatingGetEnv=true``. By default, this option is set to *false*. When this option is enabled, warnings will be generated for scenarios like the; following:. .. code-block:: c. char* p = getenv(""VAR"");; char* pp = getenv(""VAR2""); // assumes this call can invalidate `env`; strlen(p); // warns about accessing invalid ptr. .. _security-FloatLoopCounter:. security.FloatLoopCounter (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on using a floating point value as a loop counter (CERT: FLP30-C, FLP30-CPP). .. code-block:: c. void test() {; for (float x = 0.1f; x <= 1.0f; x += 0.1f) {} // warn; }. .. _security-insecureAPI-UncheckedReturn:. security.insecureAPI.UncheckedReturn (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of functions whose return values must be always checked. .. code-block:: c. void test() {; setuid(1); // warn; }. .. _security-insecureAPI-bcmp:. security.insecureAPI.bcmp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcmp' function. .. code-block:: c. void test() {; bcmp(ptr0, ptr1, n); // warn; }. .. _security-insecureAPI-bcopy:. security.insecureAPI.bcopy (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcopy' function. .. code-block:: c. void test() {; bcopy(src, dst, n); // warn; }. .. _security-insecureAPI-bzero:. security.insecureAPI.bzero (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bzero' function. .. code-block:: c. void test() {; bzero(ptr, n); // warn; }. .. _security-insecureAPI-getpw:. security.insecureAPI.getpw (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'getpw' function. .. code-block:: c. void test() {; char buff[1024];; getpw(2, buff); // warn; }. .. _security-insecureAPI-gets:. security.insecureAPI.gets (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'gets' function. .. code-block:: c. void test() {; char ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:22940,Testability,test,test,22940,"e``. By default, this option is set to *false*. When this option is enabled, warnings will be generated for scenarios like the; following:. .. code-block:: c. char* p = getenv(""VAR"");; char* pp = getenv(""VAR2""); // assumes this call can invalidate `env`; strlen(p); // warns about accessing invalid ptr. .. _security-FloatLoopCounter:. security.FloatLoopCounter (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on using a floating point value as a loop counter (CERT: FLP30-C, FLP30-CPP). .. code-block:: c. void test() {; for (float x = 0.1f; x <= 1.0f; x += 0.1f) {} // warn; }. .. _security-insecureAPI-UncheckedReturn:. security.insecureAPI.UncheckedReturn (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of functions whose return values must be always checked. .. code-block:: c. void test() {; setuid(1); // warn; }. .. _security-insecureAPI-bcmp:. security.insecureAPI.bcmp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcmp' function. .. code-block:: c. void test() {; bcmp(ptr0, ptr1, n); // warn; }. .. _security-insecureAPI-bcopy:. security.insecureAPI.bcopy (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcopy' function. .. code-block:: c. void test() {; bcopy(src, dst, n); // warn; }. .. _security-insecureAPI-bzero:. security.insecureAPI.bzero (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bzero' function. .. code-block:: c. void test() {; bzero(ptr, n); // warn; }. .. _security-insecureAPI-getpw:. security.insecureAPI.getpw (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'getpw' function. .. code-block:: c. void test() {; char buff[1024];; getpw(2, buff); // warn; }. .. _security-insecureAPI-gets:. security.insecureAPI.gets (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'gets' function. .. code-block:: c. void test() {; char buff[1024];; gets(buff); // warn; }. .. _security-insecureAPI-mkstemp:. security.insecureAPI.mkstemp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn when 'mkstemp' is passed fewer than 6 X's in the",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:23142,Testability,test,test,23142,"v(""VAR2""); // assumes this call can invalidate `env`; strlen(p); // warns about accessing invalid ptr. .. _security-FloatLoopCounter:. security.FloatLoopCounter (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on using a floating point value as a loop counter (CERT: FLP30-C, FLP30-CPP). .. code-block:: c. void test() {; for (float x = 0.1f; x <= 1.0f; x += 0.1f) {} // warn; }. .. _security-insecureAPI-UncheckedReturn:. security.insecureAPI.UncheckedReturn (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of functions whose return values must be always checked. .. code-block:: c. void test() {; setuid(1); // warn; }. .. _security-insecureAPI-bcmp:. security.insecureAPI.bcmp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcmp' function. .. code-block:: c. void test() {; bcmp(ptr0, ptr1, n); // warn; }. .. _security-insecureAPI-bcopy:. security.insecureAPI.bcopy (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcopy' function. .. code-block:: c. void test() {; bcopy(src, dst, n); // warn; }. .. _security-insecureAPI-bzero:. security.insecureAPI.bzero (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bzero' function. .. code-block:: c. void test() {; bzero(ptr, n); // warn; }. .. _security-insecureAPI-getpw:. security.insecureAPI.getpw (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'getpw' function. .. code-block:: c. void test() {; char buff[1024];; getpw(2, buff); // warn; }. .. _security-insecureAPI-gets:. security.insecureAPI.gets (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'gets' function. .. code-block:: c. void test() {; char buff[1024];; gets(buff); // warn; }. .. _security-insecureAPI-mkstemp:. security.insecureAPI.mkstemp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn when 'mkstemp' is passed fewer than 6 X's in the format string. .. code-block:: c. void test() {; mkstemp(""XX""); // warn; }. .. _security-insecureAPI-mktemp:. security.insecureAPI.mktemp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the ``mkt",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:23343,Testability,test,test,23343,"rn on using a floating point value as a loop counter (CERT: FLP30-C, FLP30-CPP). .. code-block:: c. void test() {; for (float x = 0.1f; x <= 1.0f; x += 0.1f) {} // warn; }. .. _security-insecureAPI-UncheckedReturn:. security.insecureAPI.UncheckedReturn (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of functions whose return values must be always checked. .. code-block:: c. void test() {; setuid(1); // warn; }. .. _security-insecureAPI-bcmp:. security.insecureAPI.bcmp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcmp' function. .. code-block:: c. void test() {; bcmp(ptr0, ptr1, n); // warn; }. .. _security-insecureAPI-bcopy:. security.insecureAPI.bcopy (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcopy' function. .. code-block:: c. void test() {; bcopy(src, dst, n); // warn; }. .. _security-insecureAPI-bzero:. security.insecureAPI.bzero (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bzero' function. .. code-block:: c. void test() {; bzero(ptr, n); // warn; }. .. _security-insecureAPI-getpw:. security.insecureAPI.getpw (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'getpw' function. .. code-block:: c. void test() {; char buff[1024];; getpw(2, buff); // warn; }. .. _security-insecureAPI-gets:. security.insecureAPI.gets (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'gets' function. .. code-block:: c. void test() {; char buff[1024];; gets(buff); // warn; }. .. _security-insecureAPI-mkstemp:. security.insecureAPI.mkstemp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn when 'mkstemp' is passed fewer than 6 X's in the format string. .. code-block:: c. void test() {; mkstemp(""XX""); // warn; }. .. _security-insecureAPI-mktemp:. security.insecureAPI.mktemp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the ``mktemp`` function. .. code-block:: c. void test() {; char *x = mktemp(""/tmp/zxcv""); // warn: insecure, use mkstemp; }. .. _security-insecureAPI-rand:. security.insecureAPI.rand (C); """"""""""""""""""""""""""""""""""""""",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:23539,Testability,test,test,23539,"edReturn:. security.insecureAPI.UncheckedReturn (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of functions whose return values must be always checked. .. code-block:: c. void test() {; setuid(1); // warn; }. .. _security-insecureAPI-bcmp:. security.insecureAPI.bcmp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcmp' function. .. code-block:: c. void test() {; bcmp(ptr0, ptr1, n); // warn; }. .. _security-insecureAPI-bcopy:. security.insecureAPI.bcopy (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcopy' function. .. code-block:: c. void test() {; bcopy(src, dst, n); // warn; }. .. _security-insecureAPI-bzero:. security.insecureAPI.bzero (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bzero' function. .. code-block:: c. void test() {; bzero(ptr, n); // warn; }. .. _security-insecureAPI-getpw:. security.insecureAPI.getpw (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'getpw' function. .. code-block:: c. void test() {; char buff[1024];; getpw(2, buff); // warn; }. .. _security-insecureAPI-gets:. security.insecureAPI.gets (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'gets' function. .. code-block:: c. void test() {; char buff[1024];; gets(buff); // warn; }. .. _security-insecureAPI-mkstemp:. security.insecureAPI.mkstemp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn when 'mkstemp' is passed fewer than 6 X's in the format string. .. code-block:: c. void test() {; mkstemp(""XX""); // warn; }. .. _security-insecureAPI-mktemp:. security.insecureAPI.mktemp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the ``mktemp`` function. .. code-block:: c. void test() {; char *x = mktemp(""/tmp/zxcv""); // warn: insecure, use mkstemp; }. .. _security-insecureAPI-rand:. security.insecureAPI.rand (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of inferior random number generating functions (only if arc4random function is available):; ``drand48, erand48, jrand48, lcong48, lrand48, mrand48, nrand48, random, rand_r``. .. cod",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:23750,Testability,test,test,23750," // warn; }. .. _security-insecureAPI-bcmp:. security.insecureAPI.bcmp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcmp' function. .. code-block:: c. void test() {; bcmp(ptr0, ptr1, n); // warn; }. .. _security-insecureAPI-bcopy:. security.insecureAPI.bcopy (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcopy' function. .. code-block:: c. void test() {; bcopy(src, dst, n); // warn; }. .. _security-insecureAPI-bzero:. security.insecureAPI.bzero (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bzero' function. .. code-block:: c. void test() {; bzero(ptr, n); // warn; }. .. _security-insecureAPI-getpw:. security.insecureAPI.getpw (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'getpw' function. .. code-block:: c. void test() {; char buff[1024];; getpw(2, buff); // warn; }. .. _security-insecureAPI-gets:. security.insecureAPI.gets (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'gets' function. .. code-block:: c. void test() {; char buff[1024];; gets(buff); // warn; }. .. _security-insecureAPI-mkstemp:. security.insecureAPI.mkstemp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn when 'mkstemp' is passed fewer than 6 X's in the format string. .. code-block:: c. void test() {; mkstemp(""XX""); // warn; }. .. _security-insecureAPI-mktemp:. security.insecureAPI.mktemp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the ``mktemp`` function. .. code-block:: c. void test() {; char *x = mktemp(""/tmp/zxcv""); // warn: insecure, use mkstemp; }. .. _security-insecureAPI-rand:. security.insecureAPI.rand (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of inferior random number generating functions (only if arc4random function is available):; ``drand48, erand48, jrand48, lcong48, lrand48, mrand48, nrand48, random, rand_r``. .. code-block:: c. void test() {; random(); // warn; }. .. _security-insecureAPI-strcpy:. security.insecureAPI.strcpy (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the ``strcpy`` and ``strcat`` functions. ..",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:23998,Testability,test,test,23998,":. security.insecureAPI.bcopy (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bcopy' function. .. code-block:: c. void test() {; bcopy(src, dst, n); // warn; }. .. _security-insecureAPI-bzero:. security.insecureAPI.bzero (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bzero' function. .. code-block:: c. void test() {; bzero(ptr, n); // warn; }. .. _security-insecureAPI-getpw:. security.insecureAPI.getpw (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'getpw' function. .. code-block:: c. void test() {; char buff[1024];; getpw(2, buff); // warn; }. .. _security-insecureAPI-gets:. security.insecureAPI.gets (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'gets' function. .. code-block:: c. void test() {; char buff[1024];; gets(buff); // warn; }. .. _security-insecureAPI-mkstemp:. security.insecureAPI.mkstemp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn when 'mkstemp' is passed fewer than 6 X's in the format string. .. code-block:: c. void test() {; mkstemp(""XX""); // warn; }. .. _security-insecureAPI-mktemp:. security.insecureAPI.mktemp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the ``mktemp`` function. .. code-block:: c. void test() {; char *x = mktemp(""/tmp/zxcv""); // warn: insecure, use mkstemp; }. .. _security-insecureAPI-rand:. security.insecureAPI.rand (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of inferior random number generating functions (only if arc4random function is available):; ``drand48, erand48, jrand48, lcong48, lrand48, mrand48, nrand48, random, rand_r``. .. code-block:: c. void test() {; random(); // warn; }. .. _security-insecureAPI-strcpy:. security.insecureAPI.strcpy (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the ``strcpy`` and ``strcat`` functions. .. code-block:: c. void test() {; char x[4];; char *y = ""abcd"";. strcpy(x, y); // warn; }. .. _security-insecureAPI-vfork:. security.insecureAPI.vfork (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'vfork' function. .. code-block:: ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:24200,Testability,test,test,24200,"API.bzero (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'bzero' function. .. code-block:: c. void test() {; bzero(ptr, n); // warn; }. .. _security-insecureAPI-getpw:. security.insecureAPI.getpw (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'getpw' function. .. code-block:: c. void test() {; char buff[1024];; getpw(2, buff); // warn; }. .. _security-insecureAPI-gets:. security.insecureAPI.gets (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'gets' function. .. code-block:: c. void test() {; char buff[1024];; gets(buff); // warn; }. .. _security-insecureAPI-mkstemp:. security.insecureAPI.mkstemp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn when 'mkstemp' is passed fewer than 6 X's in the format string. .. code-block:: c. void test() {; mkstemp(""XX""); // warn; }. .. _security-insecureAPI-mktemp:. security.insecureAPI.mktemp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the ``mktemp`` function. .. code-block:: c. void test() {; char *x = mktemp(""/tmp/zxcv""); // warn: insecure, use mkstemp; }. .. _security-insecureAPI-rand:. security.insecureAPI.rand (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of inferior random number generating functions (only if arc4random function is available):; ``drand48, erand48, jrand48, lcong48, lrand48, mrand48, nrand48, random, rand_r``. .. code-block:: c. void test() {; random(); // warn; }. .. _security-insecureAPI-strcpy:. security.insecureAPI.strcpy (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the ``strcpy`` and ``strcat`` functions. .. code-block:: c. void test() {; char x[4];; char *y = ""abcd"";. strcpy(x, y); // warn; }. .. _security-insecureAPI-vfork:. security.insecureAPI.vfork (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'vfork' function. .. code-block:: c. void test() {; vfork(); // warn; }. .. _security-insecureAPI-DeprecatedOrUnsafeBufferHandling:. security.insecureAPI.DeprecatedOrUnsafeBufferHandling (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:24582,Testability,test,test,24582," .. _security-insecureAPI-gets:. security.insecureAPI.gets (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'gets' function. .. code-block:: c. void test() {; char buff[1024];; gets(buff); // warn; }. .. _security-insecureAPI-mkstemp:. security.insecureAPI.mkstemp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn when 'mkstemp' is passed fewer than 6 X's in the format string. .. code-block:: c. void test() {; mkstemp(""XX""); // warn; }. .. _security-insecureAPI-mktemp:. security.insecureAPI.mktemp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the ``mktemp`` function. .. code-block:: c. void test() {; char *x = mktemp(""/tmp/zxcv""); // warn: insecure, use mkstemp; }. .. _security-insecureAPI-rand:. security.insecureAPI.rand (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of inferior random number generating functions (only if arc4random function is available):; ``drand48, erand48, jrand48, lcong48, lrand48, mrand48, nrand48, random, rand_r``. .. code-block:: c. void test() {; random(); // warn; }. .. _security-insecureAPI-strcpy:. security.insecureAPI.strcpy (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the ``strcpy`` and ``strcat`` functions. .. code-block:: c. void test() {; char x[4];; char *y = ""abcd"";. strcpy(x, y); // warn; }. .. _security-insecureAPI-vfork:. security.insecureAPI.vfork (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'vfork' function. .. code-block:: c. void test() {; vfork(); // warn; }. .. _security-insecureAPI-DeprecatedOrUnsafeBufferHandling:. security.insecureAPI.DeprecatedOrUnsafeBufferHandling (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on occurrences of unsafe or deprecated buffer handling functions, which now have a secure variant: ``sprintf, fprintf, vsprintf, scanf, wscanf, fscanf, fwscanf, vscanf, vwscanf, vfscanf, vfwscanf, sscanf, swscanf, vsscanf, vswscanf, swprintf, snprintf, vswprintf, vsnprintf, memcpy, memmove, strncpy, strncat, memset``. .. code-block:: c. void test() {; char b",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:24795,Testability,test,test,24795,"ty-insecureAPI-mkstemp:. security.insecureAPI.mkstemp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn when 'mkstemp' is passed fewer than 6 X's in the format string. .. code-block:: c. void test() {; mkstemp(""XX""); // warn; }. .. _security-insecureAPI-mktemp:. security.insecureAPI.mktemp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the ``mktemp`` function. .. code-block:: c. void test() {; char *x = mktemp(""/tmp/zxcv""); // warn: insecure, use mkstemp; }. .. _security-insecureAPI-rand:. security.insecureAPI.rand (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of inferior random number generating functions (only if arc4random function is available):; ``drand48, erand48, jrand48, lcong48, lrand48, mrand48, nrand48, random, rand_r``. .. code-block:: c. void test() {; random(); // warn; }. .. _security-insecureAPI-strcpy:. security.insecureAPI.strcpy (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the ``strcpy`` and ``strcat`` functions. .. code-block:: c. void test() {; char x[4];; char *y = ""abcd"";. strcpy(x, y); // warn; }. .. _security-insecureAPI-vfork:. security.insecureAPI.vfork (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'vfork' function. .. code-block:: c. void test() {; vfork(); // warn; }. .. _security-insecureAPI-DeprecatedOrUnsafeBufferHandling:. security.insecureAPI.DeprecatedOrUnsafeBufferHandling (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on occurrences of unsafe or deprecated buffer handling functions, which now have a secure variant: ``sprintf, fprintf, vsprintf, scanf, wscanf, fscanf, fwscanf, vscanf, vwscanf, vfscanf, vfwscanf, sscanf, swscanf, vsscanf, vswscanf, swprintf, snprintf, vswprintf, vsnprintf, memcpy, memmove, strncpy, strncat, memset``. .. code-block:: c. void test() {; char buf [5];; strncpy(buf, ""a"", 1); // warn; }. .. _unix-checkers:. unix; ^^^^; POSIX/Unix checkers. .. _unix-API:. unix.API (C); """"""""""""""""""""""""; Check calls to various UNIX/Posix functions: ``open, pthread_once, calloc, mal",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:25021,Testability,test,test,25021,". .. _security-insecureAPI-mktemp:. security.insecureAPI.mktemp (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the ``mktemp`` function. .. code-block:: c. void test() {; char *x = mktemp(""/tmp/zxcv""); // warn: insecure, use mkstemp; }. .. _security-insecureAPI-rand:. security.insecureAPI.rand (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of inferior random number generating functions (only if arc4random function is available):; ``drand48, erand48, jrand48, lcong48, lrand48, mrand48, nrand48, random, rand_r``. .. code-block:: c. void test() {; random(); // warn; }. .. _security-insecureAPI-strcpy:. security.insecureAPI.strcpy (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the ``strcpy`` and ``strcat`` functions. .. code-block:: c. void test() {; char x[4];; char *y = ""abcd"";. strcpy(x, y); // warn; }. .. _security-insecureAPI-vfork:. security.insecureAPI.vfork (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'vfork' function. .. code-block:: c. void test() {; vfork(); // warn; }. .. _security-insecureAPI-DeprecatedOrUnsafeBufferHandling:. security.insecureAPI.DeprecatedOrUnsafeBufferHandling (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on occurrences of unsafe or deprecated buffer handling functions, which now have a secure variant: ``sprintf, fprintf, vsprintf, scanf, wscanf, fscanf, fwscanf, vscanf, vwscanf, vfscanf, vfwscanf, sscanf, swscanf, vsscanf, vswscanf, swprintf, snprintf, vswprintf, vsnprintf, memcpy, memmove, strncpy, strncat, memset``. .. code-block:: c. void test() {; char buf [5];; strncpy(buf, ""a"", 1); // warn; }. .. _unix-checkers:. unix; ^^^^; POSIX/Unix checkers. .. _unix-API:. unix.API (C); """"""""""""""""""""""""; Check calls to various UNIX/Posix functions: ``open, pthread_once, calloc, malloc, realloc, alloca``. .. literalinclude:: checkers/unix_api_example.c; :language: c. .. _unix-Errno:. unix.Errno (C); """""""""""""""""""""""""""". Check for improper use of ``errno``.; This checker implements partially CERT rule; `E",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:25579,Testability,test,test,25579,"warn; }. .. _security-insecureAPI-strcpy:. security.insecureAPI.strcpy (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the ``strcpy`` and ``strcat`` functions. .. code-block:: c. void test() {; char x[4];; char *y = ""abcd"";. strcpy(x, y); // warn; }. .. _security-insecureAPI-vfork:. security.insecureAPI.vfork (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on uses of the 'vfork' function. .. code-block:: c. void test() {; vfork(); // warn; }. .. _security-insecureAPI-DeprecatedOrUnsafeBufferHandling:. security.insecureAPI.DeprecatedOrUnsafeBufferHandling (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on occurrences of unsafe or deprecated buffer handling functions, which now have a secure variant: ``sprintf, fprintf, vsprintf, scanf, wscanf, fscanf, fwscanf, vscanf, vwscanf, vfscanf, vfwscanf, sscanf, swscanf, vsscanf, vswscanf, swprintf, snprintf, vswprintf, vsnprintf, memcpy, memmove, strncpy, strncat, memset``. .. code-block:: c. void test() {; char buf [5];; strncpy(buf, ""a"", 1); // warn; }. .. _unix-checkers:. unix; ^^^^; POSIX/Unix checkers. .. _unix-API:. unix.API (C); """"""""""""""""""""""""; Check calls to various UNIX/Posix functions: ``open, pthread_once, calloc, malloc, realloc, alloca``. .. literalinclude:: checkers/unix_api_example.c; :language: c. .. _unix-Errno:. unix.Errno (C); """""""""""""""""""""""""""". Check for improper use of ``errno``.; This checker implements partially CERT rule; `ERR30-C. Set errno to zero before calling a library function known to set errno,; and check errno only after the function returns a value indicating failure; <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152351>`_.; The checker can find the first read of ``errno`` after successful standard; function calls. The C and POSIX standards often do not define if a standard library function; may change value of ``errno`` if the call does not fail.; Therefore, ``errno`` should only be used if it is known from the return value; of a function that the call ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:29043,Testability,test,test,29043," value of this option is ``true``. This allows save of the errno value; for possible later error handling. **Limitations**. - Only the very first usage of ``errno`` is checked after an affected function; call. Value of ``errno`` is not followed when it is stored into a variable; or returned from a function.; - Documentation of function ``lseek`` is not clear about what happens if the; function returns different value than the expected file position but not -1.; To avoid possible false-positives ``errno`` is allowed to be used in this; case. .. _unix-Malloc:. unix.Malloc (C); """"""""""""""""""""""""""""""; Check for memory leaks, double free, and use-after-free problems. Traces memory managed by malloc()/free(). .. literalinclude:: checkers/unix_malloc_example.c; :language: c. .. _unix-MallocSizeof:. unix.MallocSizeof (C); """"""""""""""""""""""""""""""""""""""""""; Check for dubious ``malloc`` arguments involving ``sizeof``. .. code-block:: c. void test() {; long *p = malloc(sizeof(short));; // warn: result is converted to 'long *', which is; // incompatible with operand type 'short'; free(p);; }. .. _unix-MismatchedDeallocator:. unix.MismatchedDeallocator (C, C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for mismatched deallocators. .. literalinclude:: checkers/mismatched_deallocator_example.cpp; :language: c. .. _unix-Vfork:. unix.Vfork (C); """"""""""""""""""""""""""""; Check for proper usage of ``vfork``. .. code-block:: c. int test(int x) {; pid_t pid = vfork(); // warn; if (pid != 0); return 0;. switch (x) {; case 0:; pid = 1;; execl("""", """", 0);; _exit(1);; break;; case 1:; x = 0; // warn: this assignment is prohibited; break;; case 2:; foo(); // warn: this function call is prohibited; break;; default:; return 0; // warn: return is prohibited; }. while(1);; }. .. _unix-cstring-BadSizeArg:. unix.cstring.BadSizeArg (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""; Check the size argument passed into C string functions for common erroneous patterns. Use ``-Wno-strncat-size`` compiler option to mute other ``strncat``-related ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:29525,Testability,test,test,29525,"e position but not -1.; To avoid possible false-positives ``errno`` is allowed to be used in this; case. .. _unix-Malloc:. unix.Malloc (C); """"""""""""""""""""""""""""""; Check for memory leaks, double free, and use-after-free problems. Traces memory managed by malloc()/free(). .. literalinclude:: checkers/unix_malloc_example.c; :language: c. .. _unix-MallocSizeof:. unix.MallocSizeof (C); """"""""""""""""""""""""""""""""""""""""""; Check for dubious ``malloc`` arguments involving ``sizeof``. .. code-block:: c. void test() {; long *p = malloc(sizeof(short));; // warn: result is converted to 'long *', which is; // incompatible with operand type 'short'; free(p);; }. .. _unix-MismatchedDeallocator:. unix.MismatchedDeallocator (C, C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for mismatched deallocators. .. literalinclude:: checkers/mismatched_deallocator_example.cpp; :language: c. .. _unix-Vfork:. unix.Vfork (C); """"""""""""""""""""""""""""; Check for proper usage of ``vfork``. .. code-block:: c. int test(int x) {; pid_t pid = vfork(); // warn; if (pid != 0); return 0;. switch (x) {; case 0:; pid = 1;; execl("""", """", 0);; _exit(1);; break;; case 1:; x = 0; // warn: this assignment is prohibited; break;; case 2:; foo(); // warn: this function call is prohibited; break;; default:; return 0; // warn: return is prohibited; }. while(1);; }. .. _unix-cstring-BadSizeArg:. unix.cstring.BadSizeArg (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""; Check the size argument passed into C string functions for common erroneous patterns. Use ``-Wno-strncat-size`` compiler option to mute other ``strncat``-related compiler warnings. .. code-block:: c. void test() {; char dest[3];; strncat(dest, """"""""""""""""""""""""""""""""""""""""""""""""""*"", sizeof(dest));; // warn: potential buffer overflow; }. .. _unix-cstring-NullArg:. unix.cstring.NullArg (C); """"""""""""""""""""""""""""""""""""""""""""""""; Check for null pointers being passed as arguments to C string functions:; ``strlen, strnlen, strcpy, strncpy, strcat, strncat, strcmp, strncmp, strcasecmp, strncasecmp, wcslen, wcsnlen``. .. code-b",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:30159,Testability,test,test,30159,"llocator:. unix.MismatchedDeallocator (C, C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for mismatched deallocators. .. literalinclude:: checkers/mismatched_deallocator_example.cpp; :language: c. .. _unix-Vfork:. unix.Vfork (C); """"""""""""""""""""""""""""; Check for proper usage of ``vfork``. .. code-block:: c. int test(int x) {; pid_t pid = vfork(); // warn; if (pid != 0); return 0;. switch (x) {; case 0:; pid = 1;; execl("""", """", 0);; _exit(1);; break;; case 1:; x = 0; // warn: this assignment is prohibited; break;; case 2:; foo(); // warn: this function call is prohibited; break;; default:; return 0; // warn: return is prohibited; }. while(1);; }. .. _unix-cstring-BadSizeArg:. unix.cstring.BadSizeArg (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""; Check the size argument passed into C string functions for common erroneous patterns. Use ``-Wno-strncat-size`` compiler option to mute other ``strncat``-related compiler warnings. .. code-block:: c. void test() {; char dest[3];; strncat(dest, """"""""""""""""""""""""""""""""""""""""""""""""""*"", sizeof(dest));; // warn: potential buffer overflow; }. .. _unix-cstring-NullArg:. unix.cstring.NullArg (C); """"""""""""""""""""""""""""""""""""""""""""""""; Check for null pointers being passed as arguments to C string functions:; ``strlen, strnlen, strcpy, strncpy, strcat, strncat, strcmp, strncmp, strcasecmp, strncasecmp, wcslen, wcsnlen``. .. code-block:: c. int test() {; return strlen(0); // warn; }. .. _unix-StdCLibraryFunctions:. unix.StdCLibraryFunctions (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for calls of standard library functions that violate predefined argument; constraints. For example, according to the C standard the behavior of function; ``int isalnum(int ch)`` is undefined if the value of ``ch`` is not representable; as ``unsigned char`` and is not equal to ``EOF``. You can think of this checker as defining restrictions (pre- and postconditions); on standard library functions. Preconditions are checked, and when they are; violated, a warning is emitted. Postconditions are added to ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:30572,Testability,test,test,30572,"rn 0;. switch (x) {; case 0:; pid = 1;; execl("""", """", 0);; _exit(1);; break;; case 1:; x = 0; // warn: this assignment is prohibited; break;; case 2:; foo(); // warn: this function call is prohibited; break;; default:; return 0; // warn: return is prohibited; }. while(1);; }. .. _unix-cstring-BadSizeArg:. unix.cstring.BadSizeArg (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""; Check the size argument passed into C string functions for common erroneous patterns. Use ``-Wno-strncat-size`` compiler option to mute other ``strncat``-related compiler warnings. .. code-block:: c. void test() {; char dest[3];; strncat(dest, """"""""""""""""""""""""""""""""""""""""""""""""""*"", sizeof(dest));; // warn: potential buffer overflow; }. .. _unix-cstring-NullArg:. unix.cstring.NullArg (C); """"""""""""""""""""""""""""""""""""""""""""""""; Check for null pointers being passed as arguments to C string functions:; ``strlen, strnlen, strcpy, strncpy, strcat, strncat, strcmp, strncmp, strcasecmp, strncasecmp, wcslen, wcsnlen``. .. code-block:: c. int test() {; return strlen(0); // warn; }. .. _unix-StdCLibraryFunctions:. unix.StdCLibraryFunctions (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for calls of standard library functions that violate predefined argument; constraints. For example, according to the C standard the behavior of function; ``int isalnum(int ch)`` is undefined if the value of ``ch`` is not representable; as ``unsigned char`` and is not equal to ``EOF``. You can think of this checker as defining restrictions (pre- and postconditions); on standard library functions. Preconditions are checked, and when they are; violated, a warning is emitted. Postconditions are added to the analysis, e.g.; that the return value of a function is not greater than 255. Preconditions are; added to the analysis too, in the case when the affected values are not known; before the call. For example, if an argument to a function must be in between 0 and 255, but the; value of the argument is unknown, the analyzer will assume that it is in this; interval. Simila",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:34946,Testability,test,test,34946,"vide notes about the values of the arguments.; Without this information it is hard to confirm if the constraint is indeed; violated. The argument values are shown if they are known constants or the value; is determined by previous (not too complicated) assumptions. The checker can produce false positives in cases such as if the program has; invariants not known to the analyzer engine or the bug report path contains; calls to unknown functions. In these cases the analyzer fails to detect the real; range of the argument. **Parameters**. The checker models functions (and emits diagnostics) from the C standard by; default. The ``ModelPOSIX`` option enables modeling (and emit diagnostics) of; additional functions that are defined in the POSIX standard. This option is; disabled by default. .. _osx-checkers:. osx; ^^^; macOS checkers. .. _osx-API:. osx.API (C); """"""""""""""""""""""; Check for proper uses of various Apple APIs. .. code-block:: objc. void test() {; dispatch_once_t pred = 0;; dispatch_once(&pred, ^(){}); // warn: dispatch_once uses local; }. .. _osx-NumberObjectConversion:. osx.NumberObjectConversion (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for erroneous conversions of objects representing numbers into numbers. .. code-block:: objc. NSNumber *photoCount = [albumDescriptor objectForKey:@""PhotoCount""];; // Warning: Comparing a pointer value of type 'NSNumber *'; // to a scalar integer value; if (photoCount > 0) {; [self displayPhotos];; }. .. _osx-ObjCProperty:. osx.ObjCProperty (ObjC); """"""""""""""""""""""""""""""""""""""""""""""; Check for proper uses of Objective-C properties. .. code-block:: objc. NSNumber *photoCount = [albumDescriptor objectForKey:@""PhotoCount""];; // Warning: Comparing a pointer value of type 'NSNumber *'; // to a scalar integer value; if (photoCount > 0) {; [self displayPhotos];; }. .. _osx-SecKeychainAPI:. osx.SecKeychainAPI (C); """"""""""""""""""""""""""""""""""""""""""""; Check for proper uses of Secure Keychain APIs. .. literalinclude:: checkers/seckeychainapi_",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:36181,Testability,test,test,36181,"senting numbers into numbers. .. code-block:: objc. NSNumber *photoCount = [albumDescriptor objectForKey:@""PhotoCount""];; // Warning: Comparing a pointer value of type 'NSNumber *'; // to a scalar integer value; if (photoCount > 0) {; [self displayPhotos];; }. .. _osx-ObjCProperty:. osx.ObjCProperty (ObjC); """"""""""""""""""""""""""""""""""""""""""""""; Check for proper uses of Objective-C properties. .. code-block:: objc. NSNumber *photoCount = [albumDescriptor objectForKey:@""PhotoCount""];; // Warning: Comparing a pointer value of type 'NSNumber *'; // to a scalar integer value; if (photoCount > 0) {; [self displayPhotos];; }. .. _osx-SecKeychainAPI:. osx.SecKeychainAPI (C); """"""""""""""""""""""""""""""""""""""""""""; Check for proper uses of Secure Keychain APIs. .. literalinclude:: checkers/seckeychainapi_example.m; :language: objc. .. _osx-cocoa-AtSync:. osx.cocoa.AtSync (ObjC); """"""""""""""""""""""""""""""""""""""""""""""; Check for nil pointers used as mutexes for @synchronized. .. code-block:: objc. void test(id x) {; if (!x); @synchronized(x) {} // warn: nil value used as mutex; }. void test() {; id y;; @synchronized(y) {} // warn: uninitialized value used as mutex; }. .. _osx-cocoa-AutoreleaseWrite:. osx.cocoa.AutoreleaseWrite; """"""""""""""""""""""""""""""""""""""""""""""""""""; Warn about potentially crashing writes to autoreleasing objects from different autoreleasing pools in Objective-C. .. _osx-cocoa-ClassRelease:. osx.cocoa.ClassRelease (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for sending 'retain', 'release', or 'autorelease' directly to a Class. .. code-block:: objc. @interface MyClass : NSObject; @end. void test(void) {; [MyClass release]; // warn; }. .. _osx-cocoa-Dealloc:. osx.cocoa.Dealloc (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C classes that lack a correct implementation of -dealloc. .. literalinclude:: checkers/dealloc_example.m; :language: objc. .. _osx-cocoa-IncompatibleMethodTypes:. osx.cocoa.IncompatibleMethodTypes (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C method signatures wi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:36266,Testability,test,test,36266,"ptor objectForKey:@""PhotoCount""];; // Warning: Comparing a pointer value of type 'NSNumber *'; // to a scalar integer value; if (photoCount > 0) {; [self displayPhotos];; }. .. _osx-ObjCProperty:. osx.ObjCProperty (ObjC); """"""""""""""""""""""""""""""""""""""""""""""; Check for proper uses of Objective-C properties. .. code-block:: objc. NSNumber *photoCount = [albumDescriptor objectForKey:@""PhotoCount""];; // Warning: Comparing a pointer value of type 'NSNumber *'; // to a scalar integer value; if (photoCount > 0) {; [self displayPhotos];; }. .. _osx-SecKeychainAPI:. osx.SecKeychainAPI (C); """"""""""""""""""""""""""""""""""""""""""""; Check for proper uses of Secure Keychain APIs. .. literalinclude:: checkers/seckeychainapi_example.m; :language: objc. .. _osx-cocoa-AtSync:. osx.cocoa.AtSync (ObjC); """"""""""""""""""""""""""""""""""""""""""""""; Check for nil pointers used as mutexes for @synchronized. .. code-block:: objc. void test(id x) {; if (!x); @synchronized(x) {} // warn: nil value used as mutex; }. void test() {; id y;; @synchronized(y) {} // warn: uninitialized value used as mutex; }. .. _osx-cocoa-AutoreleaseWrite:. osx.cocoa.AutoreleaseWrite; """"""""""""""""""""""""""""""""""""""""""""""""""""; Warn about potentially crashing writes to autoreleasing objects from different autoreleasing pools in Objective-C. .. _osx-cocoa-ClassRelease:. osx.cocoa.ClassRelease (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for sending 'retain', 'release', or 'autorelease' directly to a Class. .. code-block:: objc. @interface MyClass : NSObject; @end. void test(void) {; [MyClass release]; // warn; }. .. _osx-cocoa-Dealloc:. osx.cocoa.Dealloc (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C classes that lack a correct implementation of -dealloc. .. literalinclude:: checkers/dealloc_example.m; :language: objc. .. _osx-cocoa-IncompatibleMethodTypes:. osx.cocoa.IncompatibleMethodTypes (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C method signatures with type incompatibilities. .. code-block:: objc. @interface MyClass1 : NSObject; - (int",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:36786,Testability,test,test,36786,"[self displayPhotos];; }. .. _osx-SecKeychainAPI:. osx.SecKeychainAPI (C); """"""""""""""""""""""""""""""""""""""""""""; Check for proper uses of Secure Keychain APIs. .. literalinclude:: checkers/seckeychainapi_example.m; :language: objc. .. _osx-cocoa-AtSync:. osx.cocoa.AtSync (ObjC); """"""""""""""""""""""""""""""""""""""""""""""; Check for nil pointers used as mutexes for @synchronized. .. code-block:: objc. void test(id x) {; if (!x); @synchronized(x) {} // warn: nil value used as mutex; }. void test() {; id y;; @synchronized(y) {} // warn: uninitialized value used as mutex; }. .. _osx-cocoa-AutoreleaseWrite:. osx.cocoa.AutoreleaseWrite; """"""""""""""""""""""""""""""""""""""""""""""""""""; Warn about potentially crashing writes to autoreleasing objects from different autoreleasing pools in Objective-C. .. _osx-cocoa-ClassRelease:. osx.cocoa.ClassRelease (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for sending 'retain', 'release', or 'autorelease' directly to a Class. .. code-block:: objc. @interface MyClass : NSObject; @end. void test(void) {; [MyClass release]; // warn; }. .. _osx-cocoa-Dealloc:. osx.cocoa.Dealloc (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C classes that lack a correct implementation of -dealloc. .. literalinclude:: checkers/dealloc_example.m; :language: objc. .. _osx-cocoa-IncompatibleMethodTypes:. osx.cocoa.IncompatibleMethodTypes (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C method signatures with type incompatibilities. .. code-block:: objc. @interface MyClass1 : NSObject; - (int)foo;; @end. @implementation MyClass1; - (int)foo { return 1; }; @end. @interface MyClass2 : MyClass1; - (float)foo;; @end. @implementation MyClass2; - (float)foo { return 1.0; } // warn; @end. .. _osx-cocoa-Loops:. osx.cocoa.Loops; """"""""""""""""""""""""""""""; Improved modeling of loops using Cocoa collection types. .. _osx-cocoa-MissingSuperCall:. osx.cocoa.MissingSuperCall (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C methods that lack a necessary call to super. .. code-block:: objc. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:37863,Testability,test,test,37863,"osx.cocoa.Dealloc (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C classes that lack a correct implementation of -dealloc. .. literalinclude:: checkers/dealloc_example.m; :language: objc. .. _osx-cocoa-IncompatibleMethodTypes:. osx.cocoa.IncompatibleMethodTypes (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C method signatures with type incompatibilities. .. code-block:: objc. @interface MyClass1 : NSObject; - (int)foo;; @end. @implementation MyClass1; - (int)foo { return 1; }; @end. @interface MyClass2 : MyClass1; - (float)foo;; @end. @implementation MyClass2; - (float)foo { return 1.0; } // warn; @end. .. _osx-cocoa-Loops:. osx.cocoa.Loops; """"""""""""""""""""""""""""""; Improved modeling of loops using Cocoa collection types. .. _osx-cocoa-MissingSuperCall:. osx.cocoa.MissingSuperCall (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C methods that lack a necessary call to super. .. code-block:: objc. @interface Test : UIViewController; @end; @implementation test; - (void)viewDidLoad {} // warn; @end. .. _osx-cocoa-NSAutoreleasePool:. osx.cocoa.NSAutoreleasePool (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn for suboptimal uses of NSAutoreleasePool in Objective-C GC mode. .. code-block:: objc. void test() {; NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];; [pool release]; // warn; }. .. _osx-cocoa-NSError:. osx.cocoa.NSError (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""; Check usage of NSError parameters. .. code-block:: objc. @interface A : NSObject; - (void)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error;; @end. @implementation A; - (void)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error {; // warn: method accepting NSError"""""""""""""""""""""""""""""""""""""""""""""""" should have a non-void; // return value; }; @end. @interface A : NSObject; - (BOOL)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error;; @end. @implementation A; - (BOOL)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error {; *error = 0; // warn: potential null dereference; return 0;; }; @end. .. _osx-cocoa-NilA",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:38110,Testability,test,test,38110,"""""""""""""""""""""""""""""""""""; Warn about Objective-C method signatures with type incompatibilities. .. code-block:: objc. @interface MyClass1 : NSObject; - (int)foo;; @end. @implementation MyClass1; - (int)foo { return 1; }; @end. @interface MyClass2 : MyClass1; - (float)foo;; @end. @implementation MyClass2; - (float)foo { return 1.0; } // warn; @end. .. _osx-cocoa-Loops:. osx.cocoa.Loops; """"""""""""""""""""""""""""""; Improved modeling of loops using Cocoa collection types. .. _osx-cocoa-MissingSuperCall:. osx.cocoa.MissingSuperCall (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about Objective-C methods that lack a necessary call to super. .. code-block:: objc. @interface Test : UIViewController; @end; @implementation test; - (void)viewDidLoad {} // warn; @end. .. _osx-cocoa-NSAutoreleasePool:. osx.cocoa.NSAutoreleasePool (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn for suboptimal uses of NSAutoreleasePool in Objective-C GC mode. .. code-block:: objc. void test() {; NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];; [pool release]; // warn; }. .. _osx-cocoa-NSError:. osx.cocoa.NSError (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""; Check usage of NSError parameters. .. code-block:: objc. @interface A : NSObject; - (void)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error;; @end. @implementation A; - (void)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error {; // warn: method accepting NSError"""""""""""""""""""""""""""""""""""""""""""""""" should have a non-void; // return value; }; @end. @interface A : NSObject; - (BOOL)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error;; @end. @implementation A; - (BOOL)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error {; *error = 0; // warn: potential null dereference; return 0;; }; @end. .. _osx-cocoa-NilArg:. osx.cocoa.NilArg (ObjC); """"""""""""""""""""""""""""""""""""""""""""""; Check for prohibited nil arguments to ObjC method calls. - caseInsensitiveCompare:; - compare:; - compare:options:; - compare:options:range:; - compare:options:range:locale:; - componentsSeparatedByCharactersInSet:; - initWithFormat:. .. code-blo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:39186,Testability,test,test,39186,"""""""""""""""""""""""""""""""""""""""; Check usage of NSError parameters. .. code-block:: objc. @interface A : NSObject; - (void)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error;; @end. @implementation A; - (void)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error {; // warn: method accepting NSError"""""""""""""""""""""""""""""""""""""""""""""""" should have a non-void; // return value; }; @end. @interface A : NSObject; - (BOOL)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error;; @end. @implementation A; - (BOOL)foo:(NSError """""""""""""""""""""""""""""""""""""""""""""""")error {; *error = 0; // warn: potential null dereference; return 0;; }; @end. .. _osx-cocoa-NilArg:. osx.cocoa.NilArg (ObjC); """"""""""""""""""""""""""""""""""""""""""""""; Check for prohibited nil arguments to ObjC method calls. - caseInsensitiveCompare:; - compare:; - compare:options:; - compare:options:range:; - compare:options:range:locale:; - componentsSeparatedByCharactersInSet:; - initWithFormat:. .. code-block:: objc. NSComparisonResult test(NSString *s) {; NSString *aString = nil;; return [s caseInsensitiveCompare:aString];; // warn: argument to 'NSString' method; // 'caseInsensitiveCompare:' cannot be nil; }. .. _osx-cocoa-NonNilReturnValue:. osx.cocoa.NonNilReturnValue; """"""""""""""""""""""""""""""""""""""""""""""""""""""; Models the APIs that are guaranteed to return a non-nil value. .. _osx-cocoa-ObjCGenerics:. osx.cocoa.ObjCGenerics (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for type errors when using Objective-C generics. .. code-block:: objc. NSMutableArray *names = [NSMutableArray array];; NSMutableArray *birthDates = names;. // Warning: Conversion from value of type 'NSDate *'; // to incompatible type 'NSString *'; [birthDates addObject: [NSDate date]];. .. _osx-cocoa-RetainCount:. osx.cocoa.RetainCount (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for leaks and improper reference count management. .. code-block:: objc. void test() {; NSString *s = [[NSString alloc] init]; // warn; }. CFStringRef test(char *bytes) {; return CFStringCreateWithCStringNoCopy(; 0, bytes, NSNEXTSTEPStringEncoding, 0); // warn; }. .",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:40077,Testability,test,test,40077,"edByCharactersInSet:; - initWithFormat:. .. code-block:: objc. NSComparisonResult test(NSString *s) {; NSString *aString = nil;; return [s caseInsensitiveCompare:aString];; // warn: argument to 'NSString' method; // 'caseInsensitiveCompare:' cannot be nil; }. .. _osx-cocoa-NonNilReturnValue:. osx.cocoa.NonNilReturnValue; """"""""""""""""""""""""""""""""""""""""""""""""""""""; Models the APIs that are guaranteed to return a non-nil value. .. _osx-cocoa-ObjCGenerics:. osx.cocoa.ObjCGenerics (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for type errors when using Objective-C generics. .. code-block:: objc. NSMutableArray *names = [NSMutableArray array];; NSMutableArray *birthDates = names;. // Warning: Conversion from value of type 'NSDate *'; // to incompatible type 'NSString *'; [birthDates addObject: [NSDate date]];. .. _osx-cocoa-RetainCount:. osx.cocoa.RetainCount (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for leaks and improper reference count management. .. code-block:: objc. void test() {; NSString *s = [[NSString alloc] init]; // warn; }. CFStringRef test(char *bytes) {; return CFStringCreateWithCStringNoCopy(; 0, bytes, NSNEXTSTEPStringEncoding, 0); // warn; }. .. _osx-cocoa-RunLoopAutoreleaseLeak:. osx.cocoa.RunLoopAutoreleaseLeak; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for leaked memory in autorelease pools that will never be drained. .. _osx-cocoa-SelfInit:. osx.cocoa.SelfInit (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""; Check that 'self' is properly initialized inside an initializer method. .. code-block:: objc. @interface MyObj : NSObject {; id x;; }; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; x = 0; // warn: instance variable used while 'self' is not; // initialized; return 0;; }; @end. @interface MyObj : NSObject; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; return self; // warn: returning uninitialized 'self'; }; @end. .. _osx-cocoa-SuperDealloc:. osx.cocoa.SuperDealloc (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about improper use o",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:40150,Testability,test,test,40150,"*s) {; NSString *aString = nil;; return [s caseInsensitiveCompare:aString];; // warn: argument to 'NSString' method; // 'caseInsensitiveCompare:' cannot be nil; }. .. _osx-cocoa-NonNilReturnValue:. osx.cocoa.NonNilReturnValue; """"""""""""""""""""""""""""""""""""""""""""""""""""""; Models the APIs that are guaranteed to return a non-nil value. .. _osx-cocoa-ObjCGenerics:. osx.cocoa.ObjCGenerics (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for type errors when using Objective-C generics. .. code-block:: objc. NSMutableArray *names = [NSMutableArray array];; NSMutableArray *birthDates = names;. // Warning: Conversion from value of type 'NSDate *'; // to incompatible type 'NSString *'; [birthDates addObject: [NSDate date]];. .. _osx-cocoa-RetainCount:. osx.cocoa.RetainCount (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for leaks and improper reference count management. .. code-block:: objc. void test() {; NSString *s = [[NSString alloc] init]; // warn; }. CFStringRef test(char *bytes) {; return CFStringCreateWithCStringNoCopy(; 0, bytes, NSNEXTSTEPStringEncoding, 0); // warn; }. .. _osx-cocoa-RunLoopAutoreleaseLeak:. osx.cocoa.RunLoopAutoreleaseLeak; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for leaked memory in autorelease pools that will never be drained. .. _osx-cocoa-SelfInit:. osx.cocoa.SelfInit (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""; Check that 'self' is properly initialized inside an initializer method. .. code-block:: objc. @interface MyObj : NSObject {; id x;; }; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; x = 0; // warn: instance variable used while 'self' is not; // initialized; return 0;; }; @end. @interface MyObj : NSObject; - (id)init;; @end. @implementation MyObj; - (id)init {; [super init];; return self; // warn: returning uninitialized 'self'; }; @end. .. _osx-cocoa-SuperDealloc:. osx.cocoa.SuperDealloc (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about improper use of '[super dealloc]' in Objective-C. .. code-block:: objc. @interface SuperDeallocThenReleaseIvar",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:41881,Testability,test,test,41881,"// warn: returning uninitialized 'self'; }; @end. .. _osx-cocoa-SuperDealloc:. osx.cocoa.SuperDealloc (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about improper use of '[super dealloc]' in Objective-C. .. code-block:: objc. @interface SuperDeallocThenReleaseIvarClass : NSObject {; NSObject *_ivar;; }; @end. @implementation SuperDeallocThenReleaseIvarClass; - (void)dealloc {; [super dealloc];; [_ivar release]; // warn; }; @end. .. _osx-cocoa-UnusedIvars:. osx.cocoa.UnusedIvars (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about private ivars that are never used. .. code-block:: objc. @interface MyObj : NSObject {; @private; id x; // warn; }; @end. @implementation MyObj; @end. .. _osx-cocoa-VariadicMethodTypes:. osx.cocoa.VariadicMethodTypes (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for passing non-Objective-C types to variadic collection; initialization methods that expect only Objective-C types. .. code-block:: objc. void test() {; [NSSet setWithObjects:@""Foo"", ""Bar"", nil];; // warn: argument should be an ObjC pointer type, not 'char *'; }. .. _osx-coreFoundation-CFError:. osx.coreFoundation.CFError (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check usage of CFErrorRef* parameters. .. code-block:: c. void test(CFErrorRef *error) {; // warn: function accepting CFErrorRef* should have a; // non-void return; }. int foo(CFErrorRef *error) {; *error = 0; // warn: potential null dereference; return 0;; }. .. _osx-coreFoundation-CFNumber:. osx.coreFoundation.CFNumber (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for proper uses of CFNumber APIs. .. code-block:: c. CFNumberRef test(unsigned char x) {; return CFNumberCreate(0, kCFNumberSInt16Type, &x);; // warn: 8 bit integer is used to initialize a 16 bit integer; }. .. _osx-coreFoundation-CFRetainRelease:. osx.coreFoundation.CFRetainRelease (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for null arguments to CFRetain/CFRelease/CFMakeCollectable. .. code-block:: c. void test(CFTypeRef p) {; if (!p); CFRetain(p); // warn; }",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:42162,Testability,test,test,42162,"bject {; NSObject *_ivar;; }; @end. @implementation SuperDeallocThenReleaseIvarClass; - (void)dealloc {; [super dealloc];; [_ivar release]; // warn; }; @end. .. _osx-cocoa-UnusedIvars:. osx.cocoa.UnusedIvars (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about private ivars that are never used. .. code-block:: objc. @interface MyObj : NSObject {; @private; id x; // warn; }; @end. @implementation MyObj; @end. .. _osx-cocoa-VariadicMethodTypes:. osx.cocoa.VariadicMethodTypes (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for passing non-Objective-C types to variadic collection; initialization methods that expect only Objective-C types. .. code-block:: objc. void test() {; [NSSet setWithObjects:@""Foo"", ""Bar"", nil];; // warn: argument should be an ObjC pointer type, not 'char *'; }. .. _osx-coreFoundation-CFError:. osx.coreFoundation.CFError (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check usage of CFErrorRef* parameters. .. code-block:: c. void test(CFErrorRef *error) {; // warn: function accepting CFErrorRef* should have a; // non-void return; }. int foo(CFErrorRef *error) {; *error = 0; // warn: potential null dereference; return 0;; }. .. _osx-coreFoundation-CFNumber:. osx.coreFoundation.CFNumber (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for proper uses of CFNumber APIs. .. code-block:: c. CFNumberRef test(unsigned char x) {; return CFNumberCreate(0, kCFNumberSInt16Type, &x);; // warn: 8 bit integer is used to initialize a 16 bit integer; }. .. _osx-coreFoundation-CFRetainRelease:. osx.coreFoundation.CFRetainRelease (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for null arguments to CFRetain/CFRelease/CFMakeCollectable. .. code-block:: c. void test(CFTypeRef p) {; if (!p); CFRetain(p); // warn; }. void test(int x, CFTypeRef p) {; if (p); return;. CFRelease(p); // warn; }. .. _osx-coreFoundation-containers-OutOfBounds:. osx.coreFoundation.containers.OutOfBounds (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Checks for index out-of-bounds when using 'CFArray' A",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:42531,Testability,test,test,42531,"ementation MyObj; @end. .. _osx-cocoa-VariadicMethodTypes:. osx.cocoa.VariadicMethodTypes (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for passing non-Objective-C types to variadic collection; initialization methods that expect only Objective-C types. .. code-block:: objc. void test() {; [NSSet setWithObjects:@""Foo"", ""Bar"", nil];; // warn: argument should be an ObjC pointer type, not 'char *'; }. .. _osx-coreFoundation-CFError:. osx.coreFoundation.CFError (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check usage of CFErrorRef* parameters. .. code-block:: c. void test(CFErrorRef *error) {; // warn: function accepting CFErrorRef* should have a; // non-void return; }. int foo(CFErrorRef *error) {; *error = 0; // warn: potential null dereference; return 0;; }. .. _osx-coreFoundation-CFNumber:. osx.coreFoundation.CFNumber (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for proper uses of CFNumber APIs. .. code-block:: c. CFNumberRef test(unsigned char x) {; return CFNumberCreate(0, kCFNumberSInt16Type, &x);; // warn: 8 bit integer is used to initialize a 16 bit integer; }. .. _osx-coreFoundation-CFRetainRelease:. osx.coreFoundation.CFRetainRelease (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for null arguments to CFRetain/CFRelease/CFMakeCollectable. .. code-block:: c. void test(CFTypeRef p) {; if (!p); CFRetain(p); // warn; }. void test(int x, CFTypeRef p) {; if (p); return;. CFRelease(p); // warn; }. .. _osx-coreFoundation-containers-OutOfBounds:. osx.coreFoundation.containers.OutOfBounds (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Checks for index out-of-bounds when using 'CFArray' API. .. code-block:: c. void test() {; CFArrayRef A = CFArrayCreate(0, 0, 0, &kCFTypeArrayCallBacks);; CFArrayGetValueAtIndex(A, 0); // warn; }. .. _osx-coreFoundation-containers-PointerSizedValues:. osx.coreFoundation.containers.PointerSizedValues (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns if 'CFArray', 'CFDictionary', 'CFSet' are created with non-pointer-size ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:42885,Testability,test,test,42885,"cts:@""Foo"", ""Bar"", nil];; // warn: argument should be an ObjC pointer type, not 'char *'; }. .. _osx-coreFoundation-CFError:. osx.coreFoundation.CFError (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check usage of CFErrorRef* parameters. .. code-block:: c. void test(CFErrorRef *error) {; // warn: function accepting CFErrorRef* should have a; // non-void return; }. int foo(CFErrorRef *error) {; *error = 0; // warn: potential null dereference; return 0;; }. .. _osx-coreFoundation-CFNumber:. osx.coreFoundation.CFNumber (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for proper uses of CFNumber APIs. .. code-block:: c. CFNumberRef test(unsigned char x) {; return CFNumberCreate(0, kCFNumberSInt16Type, &x);; // warn: 8 bit integer is used to initialize a 16 bit integer; }. .. _osx-coreFoundation-CFRetainRelease:. osx.coreFoundation.CFRetainRelease (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for null arguments to CFRetain/CFRelease/CFMakeCollectable. .. code-block:: c. void test(CFTypeRef p) {; if (!p); CFRetain(p); // warn; }. void test(int x, CFTypeRef p) {; if (p); return;. CFRelease(p); // warn; }. .. _osx-coreFoundation-containers-OutOfBounds:. osx.coreFoundation.containers.OutOfBounds (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Checks for index out-of-bounds when using 'CFArray' API. .. code-block:: c. void test() {; CFArrayRef A = CFArrayCreate(0, 0, 0, &kCFTypeArrayCallBacks);; CFArrayGetValueAtIndex(A, 0); // warn; }. .. _osx-coreFoundation-containers-PointerSizedValues:. osx.coreFoundation.containers.PointerSizedValues (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns if 'CFArray', 'CFDictionary', 'CFSet' are created with non-pointer-size values. .. code-block:: c. void test() {; int x[] = { 1 };; CFArrayRef A = CFArrayCreate(0, (const void """""""""""""""""""""""""""""""""""""""""""""""")x, 1,; &kCFTypeArrayCallBacks); // warn; }. Fuchsia; ^^^^^^^. Fuchsia is an open source capability-based operating system currently being; developed by Google. This section describes c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:42945,Testability,test,test,42945,"n ObjC pointer type, not 'char *'; }. .. _osx-coreFoundation-CFError:. osx.coreFoundation.CFError (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check usage of CFErrorRef* parameters. .. code-block:: c. void test(CFErrorRef *error) {; // warn: function accepting CFErrorRef* should have a; // non-void return; }. int foo(CFErrorRef *error) {; *error = 0; // warn: potential null dereference; return 0;; }. .. _osx-coreFoundation-CFNumber:. osx.coreFoundation.CFNumber (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for proper uses of CFNumber APIs. .. code-block:: c. CFNumberRef test(unsigned char x) {; return CFNumberCreate(0, kCFNumberSInt16Type, &x);; // warn: 8 bit integer is used to initialize a 16 bit integer; }. .. _osx-coreFoundation-CFRetainRelease:. osx.coreFoundation.CFRetainRelease (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for null arguments to CFRetain/CFRelease/CFMakeCollectable. .. code-block:: c. void test(CFTypeRef p) {; if (!p); CFRetain(p); // warn; }. void test(int x, CFTypeRef p) {; if (p); return;. CFRelease(p); // warn; }. .. _osx-coreFoundation-containers-OutOfBounds:. osx.coreFoundation.containers.OutOfBounds (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Checks for index out-of-bounds when using 'CFArray' API. .. code-block:: c. void test() {; CFArrayRef A = CFArrayCreate(0, 0, 0, &kCFTypeArrayCallBacks);; CFArrayGetValueAtIndex(A, 0); // warn; }. .. _osx-coreFoundation-containers-PointerSizedValues:. osx.coreFoundation.containers.PointerSizedValues (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns if 'CFArray', 'CFDictionary', 'CFSet' are created with non-pointer-size values. .. code-block:: c. void test() {; int x[] = { 1 };; CFArrayRef A = CFArrayCreate(0, (const void """""""""""""""""""""""""""""""""""""""""""""""")x, 1,; &kCFTypeArrayCallBacks); // warn; }. Fuchsia; ^^^^^^^. Fuchsia is an open source capability-based operating system currently being; developed by Google. This section describes checkers that can find various; misuses of Fuchsia APIs.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:43239,Testability,test,test,43239," {; *error = 0; // warn: potential null dereference; return 0;; }. .. _osx-coreFoundation-CFNumber:. osx.coreFoundation.CFNumber (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for proper uses of CFNumber APIs. .. code-block:: c. CFNumberRef test(unsigned char x) {; return CFNumberCreate(0, kCFNumberSInt16Type, &x);; // warn: 8 bit integer is used to initialize a 16 bit integer; }. .. _osx-coreFoundation-CFRetainRelease:. osx.coreFoundation.CFRetainRelease (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for null arguments to CFRetain/CFRelease/CFMakeCollectable. .. code-block:: c. void test(CFTypeRef p) {; if (!p); CFRetain(p); // warn; }. void test(int x, CFTypeRef p) {; if (p); return;. CFRelease(p); // warn; }. .. _osx-coreFoundation-containers-OutOfBounds:. osx.coreFoundation.containers.OutOfBounds (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Checks for index out-of-bounds when using 'CFArray' API. .. code-block:: c. void test() {; CFArrayRef A = CFArrayCreate(0, 0, 0, &kCFTypeArrayCallBacks);; CFArrayGetValueAtIndex(A, 0); // warn; }. .. _osx-coreFoundation-containers-PointerSizedValues:. osx.coreFoundation.containers.PointerSizedValues (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns if 'CFArray', 'CFDictionary', 'CFSet' are created with non-pointer-size values. .. code-block:: c. void test() {; int x[] = { 1 };; CFArrayRef A = CFArrayCreate(0, (const void """""""""""""""""""""""""""""""""""""""""""""""")x, 1,; &kCFTypeArrayCallBacks); // warn; }. Fuchsia; ^^^^^^^. Fuchsia is an open source capability-based operating system currently being; developed by Google. This section describes checkers that can find various; misuses of Fuchsia APIs. .. _fuchsia-HandleChecker:. fuchsia.HandleChecker; """"""""""""""""""""""""""""""""""""""""""""""""""""""""; Handles identify resources. Similar to pointers they can be leaked,; double freed, or use after freed. This check attempts to find such problems. .. code-block:: cpp. void checkLeak08(int tag) {; zx_handle_t sa, sb;; zx_channel_create(0, &sa, &sb);",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:43628,Testability,test,test,43628,"n-CFRetainRelease:. osx.coreFoundation.CFRetainRelease (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for null arguments to CFRetain/CFRelease/CFMakeCollectable. .. code-block:: c. void test(CFTypeRef p) {; if (!p); CFRetain(p); // warn; }. void test(int x, CFTypeRef p) {; if (p); return;. CFRelease(p); // warn; }. .. _osx-coreFoundation-containers-OutOfBounds:. osx.coreFoundation.containers.OutOfBounds (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Checks for index out-of-bounds when using 'CFArray' API. .. code-block:: c. void test() {; CFArrayRef A = CFArrayCreate(0, 0, 0, &kCFTypeArrayCallBacks);; CFArrayGetValueAtIndex(A, 0); // warn; }. .. _osx-coreFoundation-containers-PointerSizedValues:. osx.coreFoundation.containers.PointerSizedValues (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns if 'CFArray', 'CFDictionary', 'CFSet' are created with non-pointer-size values. .. code-block:: c. void test() {; int x[] = { 1 };; CFArrayRef A = CFArrayCreate(0, (const void """""""""""""""""""""""""""""""""""""""""""""""")x, 1,; &kCFTypeArrayCallBacks); // warn; }. Fuchsia; ^^^^^^^. Fuchsia is an open source capability-based operating system currently being; developed by Google. This section describes checkers that can find various; misuses of Fuchsia APIs. .. _fuchsia-HandleChecker:. fuchsia.HandleChecker; """"""""""""""""""""""""""""""""""""""""""""""""""""""""; Handles identify resources. Similar to pointers they can be leaked,; double freed, or use after freed. This check attempts to find such problems. .. code-block:: cpp. void checkLeak08(int tag) {; zx_handle_t sa, sb;; zx_channel_create(0, &sa, &sb);; if (tag); zx_handle_close(sa);; use(sb); // Warn: Potential leak of handle; zx_handle_close(sb);; }. WebKit; ^^^^^^. WebKit is an open-source web browser engine available for macOS, iOS and Linux.; This section describes checkers that can find issues in WebKit codebase. Most of the checkers focus on memory management for which WebKit uses custom implementation of reference counted smartpointers. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:46957,Testability,log,log,46957,"struct RefCntbl {; void ref() {}; void deref() {}; };. struct Foo {; RefCntbl * ptr; // warn; RefCntbl & ptr; // warn; // ...; };. .. _webkit-UncountedLambdaCapturesChecker:. webkit.UncountedLambdaCapturesChecker; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Raw pointers and references to uncounted types can't be captured in lambdas. Only ref-counted types are allowed. .. code-block:: cpp. struct RefCntbl {; void ref() {}; void deref() {}; };. void foo(RefCntbl* a, RefCntbl& b) {; [&, a](){ // warn about 'a'; do_something(b); // warn about 'b'; };; };. .. _alpha-checkers:. Experimental Checkers; ---------------------. *These are checkers with known issues or limitations that keep them from being on by default. They are likely to have false positives. Bug reports and especially patches are welcome.*. alpha.clone; ^^^^^^^^^^^. .. _alpha-clone-CloneChecker:. alpha.clone.CloneChecker (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Reports similar pieces of code. .. code-block:: c. void log();. int max(int a, int b) { // warn; log();; if (a > b); return a;; return b;; }. int maxClone(int x, int y) { // similar code here; log();; if (x > y); return x;; return y;; }. alpha.core; ^^^^^^^^^^. .. _alpha-core-BoolAssignment:. alpha.core.BoolAssignment (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about assigning non-{0,1} values to boolean variables. .. code-block:: objc. void test() {; BOOL b = -1; // warn; }. .. _alpha-core-C11Lock:. alpha.core.C11Lock; """"""""""""""""""""""""""""""""""""; Similarly to :ref:`alpha.unix.PthreadLock <alpha-unix-PthreadLock>`, checks for; the locking/unlocking of ``mtx_t`` mutexes. .. code-block:: cpp. mtx_t mtx1;. void bad1(void); {; mtx_lock(&mtx1);; mtx_lock(&mtx1); // warn: This lock has already been acquired; }. .. _alpha-core-CallAndMessageUnInitRefArg:. alpha.core.CallAndMessageUnInitRefArg (C,C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for logical errors for function calls and Objective-C; message expressions (e.g., uniniti",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:46998,Testability,log,log,46998," {}; };. struct Foo {; RefCntbl * ptr; // warn; RefCntbl & ptr; // warn; // ...; };. .. _webkit-UncountedLambdaCapturesChecker:. webkit.UncountedLambdaCapturesChecker; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Raw pointers and references to uncounted types can't be captured in lambdas. Only ref-counted types are allowed. .. code-block:: cpp. struct RefCntbl {; void ref() {}; void deref() {}; };. void foo(RefCntbl* a, RefCntbl& b) {; [&, a](){ // warn about 'a'; do_something(b); // warn about 'b'; };; };. .. _alpha-checkers:. Experimental Checkers; ---------------------. *These are checkers with known issues or limitations that keep them from being on by default. They are likely to have false positives. Bug reports and especially patches are welcome.*. alpha.clone; ^^^^^^^^^^^. .. _alpha-clone-CloneChecker:. alpha.clone.CloneChecker (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Reports similar pieces of code. .. code-block:: c. void log();. int max(int a, int b) { // warn; log();; if (a > b); return a;; return b;; }. int maxClone(int x, int y) { // similar code here; log();; if (x > y); return x;; return y;; }. alpha.core; ^^^^^^^^^^. .. _alpha-core-BoolAssignment:. alpha.core.BoolAssignment (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about assigning non-{0,1} values to boolean variables. .. code-block:: objc. void test() {; BOOL b = -1; // warn; }. .. _alpha-core-C11Lock:. alpha.core.C11Lock; """"""""""""""""""""""""""""""""""""; Similarly to :ref:`alpha.unix.PthreadLock <alpha-unix-PthreadLock>`, checks for; the locking/unlocking of ``mtx_t`` mutexes. .. code-block:: cpp. mtx_t mtx1;. void bad1(void); {; mtx_lock(&mtx1);; mtx_lock(&mtx1); // warn: This lock has already been acquired; }. .. _alpha-core-CallAndMessageUnInitRefArg:. alpha.core.CallAndMessageUnInitRefArg (C,C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for logical errors for function calls and Objective-C; message expressions (e.g., uninitialized arguments, null function pointers, and",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:47094,Testability,log,log,47094," _webkit-UncountedLambdaCapturesChecker:. webkit.UncountedLambdaCapturesChecker; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Raw pointers and references to uncounted types can't be captured in lambdas. Only ref-counted types are allowed. .. code-block:: cpp. struct RefCntbl {; void ref() {}; void deref() {}; };. void foo(RefCntbl* a, RefCntbl& b) {; [&, a](){ // warn about 'a'; do_something(b); // warn about 'b'; };; };. .. _alpha-checkers:. Experimental Checkers; ---------------------. *These are checkers with known issues or limitations that keep them from being on by default. They are likely to have false positives. Bug reports and especially patches are welcome.*. alpha.clone; ^^^^^^^^^^^. .. _alpha-clone-CloneChecker:. alpha.clone.CloneChecker (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Reports similar pieces of code. .. code-block:: c. void log();. int max(int a, int b) { // warn; log();; if (a > b); return a;; return b;; }. int maxClone(int x, int y) { // similar code here; log();; if (x > y); return x;; return y;; }. alpha.core; ^^^^^^^^^^. .. _alpha-core-BoolAssignment:. alpha.core.BoolAssignment (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about assigning non-{0,1} values to boolean variables. .. code-block:: objc. void test() {; BOOL b = -1; // warn; }. .. _alpha-core-C11Lock:. alpha.core.C11Lock; """"""""""""""""""""""""""""""""""""; Similarly to :ref:`alpha.unix.PthreadLock <alpha-unix-PthreadLock>`, checks for; the locking/unlocking of ``mtx_t`` mutexes. .. code-block:: cpp. mtx_t mtx1;. void bad1(void); {; mtx_lock(&mtx1);; mtx_lock(&mtx1); // warn: This lock has already been acquired; }. .. _alpha-core-CallAndMessageUnInitRefArg:. alpha.core.CallAndMessageUnInitRefArg (C,C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for logical errors for function calls and Objective-C; message expressions (e.g., uninitialized arguments, null function pointers, and pointer to undefined variables). .. code-block:: c. void test(void) {; int t;; int &p ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:47350,Testability,test,test,47350,"oid ref() {}; void deref() {}; };. void foo(RefCntbl* a, RefCntbl& b) {; [&, a](){ // warn about 'a'; do_something(b); // warn about 'b'; };; };. .. _alpha-checkers:. Experimental Checkers; ---------------------. *These are checkers with known issues or limitations that keep them from being on by default. They are likely to have false positives. Bug reports and especially patches are welcome.*. alpha.clone; ^^^^^^^^^^^. .. _alpha-clone-CloneChecker:. alpha.clone.CloneChecker (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Reports similar pieces of code. .. code-block:: c. void log();. int max(int a, int b) { // warn; log();; if (a > b); return a;; return b;; }. int maxClone(int x, int y) { // similar code here; log();; if (x > y); return x;; return y;; }. alpha.core; ^^^^^^^^^^. .. _alpha-core-BoolAssignment:. alpha.core.BoolAssignment (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about assigning non-{0,1} values to boolean variables. .. code-block:: objc. void test() {; BOOL b = -1; // warn; }. .. _alpha-core-C11Lock:. alpha.core.C11Lock; """"""""""""""""""""""""""""""""""""; Similarly to :ref:`alpha.unix.PthreadLock <alpha-unix-PthreadLock>`, checks for; the locking/unlocking of ``mtx_t`` mutexes. .. code-block:: cpp. mtx_t mtx1;. void bad1(void); {; mtx_lock(&mtx1);; mtx_lock(&mtx1); // warn: This lock has already been acquired; }. .. _alpha-core-CallAndMessageUnInitRefArg:. alpha.core.CallAndMessageUnInitRefArg (C,C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for logical errors for function calls and Objective-C; message expressions (e.g., uninitialized arguments, null function pointers, and pointer to undefined variables). .. code-block:: c. void test(void) {; int t;; int &p = t;; int &s = p;; int &q = s;; foo(q); // warn; }. void test(void) {; int x;; foo(&x); // warn; }. .. _alpha-core-CastSize:. alpha.core.CastSize (C); """"""""""""""""""""""""""""""""""""""""""""""; Check when casting a malloc'ed type ``T``, whether the size is a multiple of the size of ``T``. ..",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:47873,Testability,log,logical,47873,"); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Reports similar pieces of code. .. code-block:: c. void log();. int max(int a, int b) { // warn; log();; if (a > b); return a;; return b;; }. int maxClone(int x, int y) { // similar code here; log();; if (x > y); return x;; return y;; }. alpha.core; ^^^^^^^^^^. .. _alpha-core-BoolAssignment:. alpha.core.BoolAssignment (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about assigning non-{0,1} values to boolean variables. .. code-block:: objc. void test() {; BOOL b = -1; // warn; }. .. _alpha-core-C11Lock:. alpha.core.C11Lock; """"""""""""""""""""""""""""""""""""; Similarly to :ref:`alpha.unix.PthreadLock <alpha-unix-PthreadLock>`, checks for; the locking/unlocking of ``mtx_t`` mutexes. .. code-block:: cpp. mtx_t mtx1;. void bad1(void); {; mtx_lock(&mtx1);; mtx_lock(&mtx1); // warn: This lock has already been acquired; }. .. _alpha-core-CallAndMessageUnInitRefArg:. alpha.core.CallAndMessageUnInitRefArg (C,C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for logical errors for function calls and Objective-C; message expressions (e.g., uninitialized arguments, null function pointers, and pointer to undefined variables). .. code-block:: c. void test(void) {; int t;; int &p = t;; int &s = p;; int &q = s;; foo(q); // warn; }. void test(void) {; int x;; foo(&x); // warn; }. .. _alpha-core-CastSize:. alpha.core.CastSize (C); """"""""""""""""""""""""""""""""""""""""""""""; Check when casting a malloc'ed type ``T``, whether the size is a multiple of the size of ``T``. .. code-block:: c. void test() {; int *x = (int *) malloc(11); // warn; }. .. _alpha-core-CastToStruct:. alpha.core.CastToStruct (C, C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for cast from non-struct pointer to struct pointer. .. code-block:: cpp. // C; struct s {};. void test(int *p) {; struct s *ps = (struct s *) p; // warn; }. // C++; class c {};. void test(int *p) {; c *pc = (c *) p; // warn; }. .. _alpha-core-Conversion:. alpha.core.Conversion (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:48061,Testability,test,test,48061,");; if (x > y); return x;; return y;; }. alpha.core; ^^^^^^^^^^. .. _alpha-core-BoolAssignment:. alpha.core.BoolAssignment (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about assigning non-{0,1} values to boolean variables. .. code-block:: objc. void test() {; BOOL b = -1; // warn; }. .. _alpha-core-C11Lock:. alpha.core.C11Lock; """"""""""""""""""""""""""""""""""""; Similarly to :ref:`alpha.unix.PthreadLock <alpha-unix-PthreadLock>`, checks for; the locking/unlocking of ``mtx_t`` mutexes. .. code-block:: cpp. mtx_t mtx1;. void bad1(void); {; mtx_lock(&mtx1);; mtx_lock(&mtx1); // warn: This lock has already been acquired; }. .. _alpha-core-CallAndMessageUnInitRefArg:. alpha.core.CallAndMessageUnInitRefArg (C,C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for logical errors for function calls and Objective-C; message expressions (e.g., uninitialized arguments, null function pointers, and pointer to undefined variables). .. code-block:: c. void test(void) {; int t;; int &p = t;; int &s = p;; int &q = s;; foo(q); // warn; }. void test(void) {; int x;; foo(&x); // warn; }. .. _alpha-core-CastSize:. alpha.core.CastSize (C); """"""""""""""""""""""""""""""""""""""""""""""; Check when casting a malloc'ed type ``T``, whether the size is a multiple of the size of ``T``. .. code-block:: c. void test() {; int *x = (int *) malloc(11); // warn; }. .. _alpha-core-CastToStruct:. alpha.core.CastToStruct (C, C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for cast from non-struct pointer to struct pointer. .. code-block:: cpp. // C; struct s {};. void test(int *p) {; struct s *ps = (struct s *) p; // warn; }. // C++; class c {};. void test(int *p) {; c *pc = (c *) p; // warn; }. .. _alpha-core-Conversion:. alpha.core.Conversion (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Loss of sign/precision in implicit conversions. .. code-block:: c. void test(unsigned U, signed S) {; if (S > 10) {; if (U < S) {; }; }; if (S < -10) {; if (U < S) { // warn (loss of sign); }; }; }. void test() {; long long A",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:48147,Testability,test,test,48147," _alpha-core-BoolAssignment:. alpha.core.BoolAssignment (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about assigning non-{0,1} values to boolean variables. .. code-block:: objc. void test() {; BOOL b = -1; // warn; }. .. _alpha-core-C11Lock:. alpha.core.C11Lock; """"""""""""""""""""""""""""""""""""; Similarly to :ref:`alpha.unix.PthreadLock <alpha-unix-PthreadLock>`, checks for; the locking/unlocking of ``mtx_t`` mutexes. .. code-block:: cpp. mtx_t mtx1;. void bad1(void); {; mtx_lock(&mtx1);; mtx_lock(&mtx1); // warn: This lock has already been acquired; }. .. _alpha-core-CallAndMessageUnInitRefArg:. alpha.core.CallAndMessageUnInitRefArg (C,C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for logical errors for function calls and Objective-C; message expressions (e.g., uninitialized arguments, null function pointers, and pointer to undefined variables). .. code-block:: c. void test(void) {; int t;; int &p = t;; int &s = p;; int &q = s;; foo(q); // warn; }. void test(void) {; int x;; foo(&x); // warn; }. .. _alpha-core-CastSize:. alpha.core.CastSize (C); """"""""""""""""""""""""""""""""""""""""""""""; Check when casting a malloc'ed type ``T``, whether the size is a multiple of the size of ``T``. .. code-block:: c. void test() {; int *x = (int *) malloc(11); // warn; }. .. _alpha-core-CastToStruct:. alpha.core.CastToStruct (C, C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for cast from non-struct pointer to struct pointer. .. code-block:: cpp. // C; struct s {};. void test(int *p) {; struct s *ps = (struct s *) p; // warn; }. // C++; class c {};. void test(int *p) {; c *pc = (c *) p; // warn; }. .. _alpha-core-Conversion:. alpha.core.Conversion (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Loss of sign/precision in implicit conversions. .. code-block:: c. void test(unsigned U, signed S) {; if (S > 10) {; if (U < S) {; }; }; if (S < -10) {; if (U < S) { // warn (loss of sign); }; }; }. void test() {; long long A = 1LL << 60;; short X = A; // warn (loss of precision); }. .. _alp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:48386,Testability,test,test,48386,". alpha.core.C11Lock; """"""""""""""""""""""""""""""""""""; Similarly to :ref:`alpha.unix.PthreadLock <alpha-unix-PthreadLock>`, checks for; the locking/unlocking of ``mtx_t`` mutexes. .. code-block:: cpp. mtx_t mtx1;. void bad1(void); {; mtx_lock(&mtx1);; mtx_lock(&mtx1); // warn: This lock has already been acquired; }. .. _alpha-core-CallAndMessageUnInitRefArg:. alpha.core.CallAndMessageUnInitRefArg (C,C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for logical errors for function calls and Objective-C; message expressions (e.g., uninitialized arguments, null function pointers, and pointer to undefined variables). .. code-block:: c. void test(void) {; int t;; int &p = t;; int &s = p;; int &q = s;; foo(q); // warn; }. void test(void) {; int x;; foo(&x); // warn; }. .. _alpha-core-CastSize:. alpha.core.CastSize (C); """"""""""""""""""""""""""""""""""""""""""""""; Check when casting a malloc'ed type ``T``, whether the size is a multiple of the size of ``T``. .. code-block:: c. void test() {; int *x = (int *) malloc(11); // warn; }. .. _alpha-core-CastToStruct:. alpha.core.CastToStruct (C, C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for cast from non-struct pointer to struct pointer. .. code-block:: cpp. // C; struct s {};. void test(int *p) {; struct s *ps = (struct s *) p; // warn; }. // C++; class c {};. void test(int *p) {; c *pc = (c *) p; // warn; }. .. _alpha-core-Conversion:. alpha.core.Conversion (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Loss of sign/precision in implicit conversions. .. code-block:: c. void test(unsigned U, signed S) {; if (S > 10) {; if (U < S) {; }; }; if (S < -10) {; if (U < S) { // warn (loss of sign); }; }; }. void test() {; long long A = 1LL << 60;; short X = A; // warn (loss of precision); }. .. _alpha-core-DynamicTypeChecker:. alpha.core.DynamicTypeChecker (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for cases where the dynamic and the static type of an object are unrelated. .. code-block:: objc. id date = [NSDate date];. // Warni",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:48639,Testability,test,test,48639,"/ warn: This lock has already been acquired; }. .. _alpha-core-CallAndMessageUnInitRefArg:. alpha.core.CallAndMessageUnInitRefArg (C,C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for logical errors for function calls and Objective-C; message expressions (e.g., uninitialized arguments, null function pointers, and pointer to undefined variables). .. code-block:: c. void test(void) {; int t;; int &p = t;; int &s = p;; int &q = s;; foo(q); // warn; }. void test(void) {; int x;; foo(&x); // warn; }. .. _alpha-core-CastSize:. alpha.core.CastSize (C); """"""""""""""""""""""""""""""""""""""""""""""; Check when casting a malloc'ed type ``T``, whether the size is a multiple of the size of ``T``. .. code-block:: c. void test() {; int *x = (int *) malloc(11); // warn; }. .. _alpha-core-CastToStruct:. alpha.core.CastToStruct (C, C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for cast from non-struct pointer to struct pointer. .. code-block:: cpp. // C; struct s {};. void test(int *p) {; struct s *ps = (struct s *) p; // warn; }. // C++; class c {};. void test(int *p) {; c *pc = (c *) p; // warn; }. .. _alpha-core-Conversion:. alpha.core.Conversion (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Loss of sign/precision in implicit conversions. .. code-block:: c. void test(unsigned U, signed S) {; if (S > 10) {; if (U < S) {; }; }; if (S < -10) {; if (U < S) { // warn (loss of sign); }; }; }. void test() {; long long A = 1LL << 60;; short X = A; // warn (loss of precision); }. .. _alpha-core-DynamicTypeChecker:. alpha.core.DynamicTypeChecker (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for cases where the dynamic and the static type of an object are unrelated. .. code-block:: objc. id date = [NSDate date];. // Warning: Object has a dynamic type 'NSDate *' which is; // incompatible with static type 'NSNumber *'""; NSNumber *number = date;; [number doubleValue];. .. _alpha-core-FixedAddr:. alpha.core.FixedAddr (C); """"""""""""""""""""""""""""""""""""""""""""""""; Check for assignment of a fixe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:48724,Testability,test,test,48724,"nInitRefArg:. alpha.core.CallAndMessageUnInitRefArg (C,C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for logical errors for function calls and Objective-C; message expressions (e.g., uninitialized arguments, null function pointers, and pointer to undefined variables). .. code-block:: c. void test(void) {; int t;; int &p = t;; int &s = p;; int &q = s;; foo(q); // warn; }. void test(void) {; int x;; foo(&x); // warn; }. .. _alpha-core-CastSize:. alpha.core.CastSize (C); """"""""""""""""""""""""""""""""""""""""""""""; Check when casting a malloc'ed type ``T``, whether the size is a multiple of the size of ``T``. .. code-block:: c. void test() {; int *x = (int *) malloc(11); // warn; }. .. _alpha-core-CastToStruct:. alpha.core.CastToStruct (C, C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for cast from non-struct pointer to struct pointer. .. code-block:: cpp. // C; struct s {};. void test(int *p) {; struct s *ps = (struct s *) p; // warn; }. // C++; class c {};. void test(int *p) {; c *pc = (c *) p; // warn; }. .. _alpha-core-Conversion:. alpha.core.Conversion (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Loss of sign/precision in implicit conversions. .. code-block:: c. void test(unsigned U, signed S) {; if (S > 10) {; if (U < S) {; }; }; if (S < -10) {; if (U < S) { // warn (loss of sign); }; }; }. void test() {; long long A = 1LL << 60;; short X = A; // warn (loss of precision); }. .. _alpha-core-DynamicTypeChecker:. alpha.core.DynamicTypeChecker (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for cases where the dynamic and the static type of an object are unrelated. .. code-block:: objc. id date = [NSDate date];. // Warning: Object has a dynamic type 'NSDate *' which is; // incompatible with static type 'NSNumber *'""; NSNumber *number = date;; [number doubleValue];. .. _alpha-core-FixedAddr:. alpha.core.FixedAddr (C); """"""""""""""""""""""""""""""""""""""""""""""""; Check for assignment of a fixed address to a pointer. .. code-block:: c. void test() {; int *p;; p = (int *)",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:48945,Testability,test,test,48945,"ointer to undefined variables). .. code-block:: c. void test(void) {; int t;; int &p = t;; int &s = p;; int &q = s;; foo(q); // warn; }. void test(void) {; int x;; foo(&x); // warn; }. .. _alpha-core-CastSize:. alpha.core.CastSize (C); """"""""""""""""""""""""""""""""""""""""""""""; Check when casting a malloc'ed type ``T``, whether the size is a multiple of the size of ``T``. .. code-block:: c. void test() {; int *x = (int *) malloc(11); // warn; }. .. _alpha-core-CastToStruct:. alpha.core.CastToStruct (C, C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for cast from non-struct pointer to struct pointer. .. code-block:: cpp. // C; struct s {};. void test(int *p) {; struct s *ps = (struct s *) p; // warn; }. // C++; class c {};. void test(int *p) {; c *pc = (c *) p; // warn; }. .. _alpha-core-Conversion:. alpha.core.Conversion (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Loss of sign/precision in implicit conversions. .. code-block:: c. void test(unsigned U, signed S) {; if (S > 10) {; if (U < S) {; }; }; if (S < -10) {; if (U < S) { // warn (loss of sign); }; }; }. void test() {; long long A = 1LL << 60;; short X = A; // warn (loss of precision); }. .. _alpha-core-DynamicTypeChecker:. alpha.core.DynamicTypeChecker (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for cases where the dynamic and the static type of an object are unrelated. .. code-block:: objc. id date = [NSDate date];. // Warning: Object has a dynamic type 'NSDate *' which is; // incompatible with static type 'NSNumber *'""; NSNumber *number = date;; [number doubleValue];. .. _alpha-core-FixedAddr:. alpha.core.FixedAddr (C); """"""""""""""""""""""""""""""""""""""""""""""""; Check for assignment of a fixed address to a pointer. .. code-block:: c. void test() {; int *p;; p = (int *) 0x10000; // warn; }. .. _alpha-core-IdenticalExpr:. alpha.core.IdenticalExpr (C, C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about unintended use of identical expressions in operators. .. code-block:: cpp. // C; void test() {; int a = 5;; int b = a | 4 | a; /",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:49077,Testability,test,test,49077,"q = s;; foo(q); // warn; }. void test(void) {; int x;; foo(&x); // warn; }. .. _alpha-core-CastSize:. alpha.core.CastSize (C); """"""""""""""""""""""""""""""""""""""""""""""; Check when casting a malloc'ed type ``T``, whether the size is a multiple of the size of ``T``. .. code-block:: c. void test() {; int *x = (int *) malloc(11); // warn; }. .. _alpha-core-CastToStruct:. alpha.core.CastToStruct (C, C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for cast from non-struct pointer to struct pointer. .. code-block:: cpp. // C; struct s {};. void test(int *p) {; struct s *ps = (struct s *) p; // warn; }. // C++; class c {};. void test(int *p) {; c *pc = (c *) p; // warn; }. .. _alpha-core-Conversion:. alpha.core.Conversion (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Loss of sign/precision in implicit conversions. .. code-block:: c. void test(unsigned U, signed S) {; if (S > 10) {; if (U < S) {; }; }; if (S < -10) {; if (U < S) { // warn (loss of sign); }; }; }. void test() {; long long A = 1LL << 60;; short X = A; // warn (loss of precision); }. .. _alpha-core-DynamicTypeChecker:. alpha.core.DynamicTypeChecker (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for cases where the dynamic and the static type of an object are unrelated. .. code-block:: objc. id date = [NSDate date];. // Warning: Object has a dynamic type 'NSDate *' which is; // incompatible with static type 'NSNumber *'""; NSNumber *number = date;; [number doubleValue];. .. _alpha-core-FixedAddr:. alpha.core.FixedAddr (C); """"""""""""""""""""""""""""""""""""""""""""""""; Check for assignment of a fixed address to a pointer. .. code-block:: c. void test() {; int *p;; p = (int *) 0x10000; // warn; }. .. _alpha-core-IdenticalExpr:. alpha.core.IdenticalExpr (C, C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about unintended use of identical expressions in operators. .. code-block:: cpp. // C; void test() {; int a = 5;; int b = a | 4 | a; // warn: identical expr on both sides; }. // C++; bool f(void);. void test(bool b) {; int i = 10;; if (f()) { ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:49713,Testability,test,test,49713,") {; c *pc = (c *) p; // warn; }. .. _alpha-core-Conversion:. alpha.core.Conversion (C, C++, ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Loss of sign/precision in implicit conversions. .. code-block:: c. void test(unsigned U, signed S) {; if (S > 10) {; if (U < S) {; }; }; if (S < -10) {; if (U < S) { // warn (loss of sign); }; }; }. void test() {; long long A = 1LL << 60;; short X = A; // warn (loss of precision); }. .. _alpha-core-DynamicTypeChecker:. alpha.core.DynamicTypeChecker (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for cases where the dynamic and the static type of an object are unrelated. .. code-block:: objc. id date = [NSDate date];. // Warning: Object has a dynamic type 'NSDate *' which is; // incompatible with static type 'NSNumber *'""; NSNumber *number = date;; [number doubleValue];. .. _alpha-core-FixedAddr:. alpha.core.FixedAddr (C); """"""""""""""""""""""""""""""""""""""""""""""""; Check for assignment of a fixed address to a pointer. .. code-block:: c. void test() {; int *p;; p = (int *) 0x10000; // warn; }. .. _alpha-core-IdenticalExpr:. alpha.core.IdenticalExpr (C, C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about unintended use of identical expressions in operators. .. code-block:: cpp. // C; void test() {; int a = 5;; int b = a | 4 | a; // warn: identical expr on both sides; }. // C++; bool f(void);. void test(bool b) {; int i = 10;; if (f()) { // warn: true and false branches are identical; do {; i--;; } while (f());; } else {; do {; i--;; } while (f());; }; }. .. _alpha-core-PointerArithm:. alpha.core.PointerArithm (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for pointer arithmetic on locations other than array elements. .. code-block:: c. void test() {; int x;; int *p;; p = &x + 1; // warn; }. .. _alpha-core-PointerSub:. alpha.core.PointerSub (C); """"""""""""""""""""""""""""""""""""""""""""""""""; Check for pointer subtractions on two pointers pointing to different memory chunks. .. code-block:: c. void test() {; int x, y;; int d = &y - &x; // warn; }. .. _alpha-core-SizeofPtr:. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:49963,Testability,test,test,49963,"S) {; }; }; if (S < -10) {; if (U < S) { // warn (loss of sign); }; }; }. void test() {; long long A = 1LL << 60;; short X = A; // warn (loss of precision); }. .. _alpha-core-DynamicTypeChecker:. alpha.core.DynamicTypeChecker (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for cases where the dynamic and the static type of an object are unrelated. .. code-block:: objc. id date = [NSDate date];. // Warning: Object has a dynamic type 'NSDate *' which is; // incompatible with static type 'NSNumber *'""; NSNumber *number = date;; [number doubleValue];. .. _alpha-core-FixedAddr:. alpha.core.FixedAddr (C); """"""""""""""""""""""""""""""""""""""""""""""""; Check for assignment of a fixed address to a pointer. .. code-block:: c. void test() {; int *p;; p = (int *) 0x10000; // warn; }. .. _alpha-core-IdenticalExpr:. alpha.core.IdenticalExpr (C, C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about unintended use of identical expressions in operators. .. code-block:: cpp. // C; void test() {; int a = 5;; int b = a | 4 | a; // warn: identical expr on both sides; }. // C++; bool f(void);. void test(bool b) {; int i = 10;; if (f()) { // warn: true and false branches are identical; do {; i--;; } while (f());; } else {; do {; i--;; } while (f());; }; }. .. _alpha-core-PointerArithm:. alpha.core.PointerArithm (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for pointer arithmetic on locations other than array elements. .. code-block:: c. void test() {; int x;; int *p;; p = &x + 1; // warn; }. .. _alpha-core-PointerSub:. alpha.core.PointerSub (C); """"""""""""""""""""""""""""""""""""""""""""""""""; Check for pointer subtractions on two pointers pointing to different memory chunks. .. code-block:: c. void test() {; int x, y;; int d = &y - &x; // warn; }. .. _alpha-core-SizeofPtr:. alpha.core.SizeofPtr (C); """"""""""""""""""""""""""""""""""""""""""""""""; Warn about unintended use of ``sizeof()`` on pointer expressions. .. code-block:: c. struct s {};. int test(struct s *p) {; return sizeof(p);; // warn: sizeof(ptr) can produce an unexpected result; }. .. _alpha",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:50074,Testability,test,test,50074,"on); }. .. _alpha-core-DynamicTypeChecker:. alpha.core.DynamicTypeChecker (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for cases where the dynamic and the static type of an object are unrelated. .. code-block:: objc. id date = [NSDate date];. // Warning: Object has a dynamic type 'NSDate *' which is; // incompatible with static type 'NSNumber *'""; NSNumber *number = date;; [number doubleValue];. .. _alpha-core-FixedAddr:. alpha.core.FixedAddr (C); """"""""""""""""""""""""""""""""""""""""""""""""; Check for assignment of a fixed address to a pointer. .. code-block:: c. void test() {; int *p;; p = (int *) 0x10000; // warn; }. .. _alpha-core-IdenticalExpr:. alpha.core.IdenticalExpr (C, C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about unintended use of identical expressions in operators. .. code-block:: cpp. // C; void test() {; int a = 5;; int b = a | 4 | a; // warn: identical expr on both sides; }. // C++; bool f(void);. void test(bool b) {; int i = 10;; if (f()) { // warn: true and false branches are identical; do {; i--;; } while (f());; } else {; do {; i--;; } while (f());; }; }. .. _alpha-core-PointerArithm:. alpha.core.PointerArithm (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for pointer arithmetic on locations other than array elements. .. code-block:: c. void test() {; int x;; int *p;; p = &x + 1; // warn; }. .. _alpha-core-PointerSub:. alpha.core.PointerSub (C); """"""""""""""""""""""""""""""""""""""""""""""""""; Check for pointer subtractions on two pointers pointing to different memory chunks. .. code-block:: c. void test() {; int x, y;; int d = &y - &x; // warn; }. .. _alpha-core-SizeofPtr:. alpha.core.SizeofPtr (C); """"""""""""""""""""""""""""""""""""""""""""""""; Warn about unintended use of ``sizeof()`` on pointer expressions. .. code-block:: c. struct s {};. int test(struct s *p) {; return sizeof(p);; // warn: sizeof(ptr) can produce an unexpected result; }. .. _alpha-core-StackAddressAsyncEscape:. alpha.core.StackAddressAsyncEscape (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check that addresses to stack memory do n",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:50418,Testability,test,test,50418,"SDate *' which is; // incompatible with static type 'NSNumber *'""; NSNumber *number = date;; [number doubleValue];. .. _alpha-core-FixedAddr:. alpha.core.FixedAddr (C); """"""""""""""""""""""""""""""""""""""""""""""""; Check for assignment of a fixed address to a pointer. .. code-block:: c. void test() {; int *p;; p = (int *) 0x10000; // warn; }. .. _alpha-core-IdenticalExpr:. alpha.core.IdenticalExpr (C, C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about unintended use of identical expressions in operators. .. code-block:: cpp. // C; void test() {; int a = 5;; int b = a | 4 | a; // warn: identical expr on both sides; }. // C++; bool f(void);. void test(bool b) {; int i = 10;; if (f()) { // warn: true and false branches are identical; do {; i--;; } while (f());; } else {; do {; i--;; } while (f());; }; }. .. _alpha-core-PointerArithm:. alpha.core.PointerArithm (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for pointer arithmetic on locations other than array elements. .. code-block:: c. void test() {; int x;; int *p;; p = &x + 1; // warn; }. .. _alpha-core-PointerSub:. alpha.core.PointerSub (C); """"""""""""""""""""""""""""""""""""""""""""""""""; Check for pointer subtractions on two pointers pointing to different memory chunks. .. code-block:: c. void test() {; int x, y;; int d = &y - &x; // warn; }. .. _alpha-core-SizeofPtr:. alpha.core.SizeofPtr (C); """"""""""""""""""""""""""""""""""""""""""""""""; Warn about unintended use of ``sizeof()`` on pointer expressions. .. code-block:: c. struct s {};. int test(struct s *p) {; return sizeof(p);; // warn: sizeof(ptr) can produce an unexpected result; }. .. _alpha-core-StackAddressAsyncEscape:. alpha.core.StackAddressAsyncEscape (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check that addresses to stack memory do not escape the function that involves dispatch_after or dispatch_async.; This checker is a part of ``core.StackAddressEscape``, but is temporarily disabled until some false positives are fixed. .. code-block:: c. dispatch_block_t test_block_inside_block_async_leak() {; int x = 123;; void (",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:50659,Testability,test,test,50659,"pointer. .. code-block:: c. void test() {; int *p;; p = (int *) 0x10000; // warn; }. .. _alpha-core-IdenticalExpr:. alpha.core.IdenticalExpr (C, C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about unintended use of identical expressions in operators. .. code-block:: cpp. // C; void test() {; int a = 5;; int b = a | 4 | a; // warn: identical expr on both sides; }. // C++; bool f(void);. void test(bool b) {; int i = 10;; if (f()) { // warn: true and false branches are identical; do {; i--;; } while (f());; } else {; do {; i--;; } while (f());; }; }. .. _alpha-core-PointerArithm:. alpha.core.PointerArithm (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for pointer arithmetic on locations other than array elements. .. code-block:: c. void test() {; int x;; int *p;; p = &x + 1; // warn; }. .. _alpha-core-PointerSub:. alpha.core.PointerSub (C); """"""""""""""""""""""""""""""""""""""""""""""""""; Check for pointer subtractions on two pointers pointing to different memory chunks. .. code-block:: c. void test() {; int x, y;; int d = &y - &x; // warn; }. .. _alpha-core-SizeofPtr:. alpha.core.SizeofPtr (C); """"""""""""""""""""""""""""""""""""""""""""""""; Warn about unintended use of ``sizeof()`` on pointer expressions. .. code-block:: c. struct s {};. int test(struct s *p) {; return sizeof(p);; // warn: sizeof(ptr) can produce an unexpected result; }. .. _alpha-core-StackAddressAsyncEscape:. alpha.core.StackAddressAsyncEscape (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check that addresses to stack memory do not escape the function that involves dispatch_after or dispatch_async.; This checker is a part of ``core.StackAddressEscape``, but is temporarily disabled until some false positives are fixed. .. code-block:: c. dispatch_block_t test_block_inside_block_async_leak() {; int x = 123;; void (^inner)(void) = ^void(void) {; int y = x;; ++y;; };; void (^outer)(void) = ^void(void) {; int z = x;; ++z;; inner();; };; return outer; // warn: address of stack-allocated block is captured by a; // returned block; }. .. _alpha-core-StdVaria",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:50891,Testability,test,test,50891,"e-block:: cpp. // C; void test() {; int a = 5;; int b = a | 4 | a; // warn: identical expr on both sides; }. // C++; bool f(void);. void test(bool b) {; int i = 10;; if (f()) { // warn: true and false branches are identical; do {; i--;; } while (f());; } else {; do {; i--;; } while (f());; }; }. .. _alpha-core-PointerArithm:. alpha.core.PointerArithm (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for pointer arithmetic on locations other than array elements. .. code-block:: c. void test() {; int x;; int *p;; p = &x + 1; // warn; }. .. _alpha-core-PointerSub:. alpha.core.PointerSub (C); """"""""""""""""""""""""""""""""""""""""""""""""""; Check for pointer subtractions on two pointers pointing to different memory chunks. .. code-block:: c. void test() {; int x, y;; int d = &y - &x; // warn; }. .. _alpha-core-SizeofPtr:. alpha.core.SizeofPtr (C); """"""""""""""""""""""""""""""""""""""""""""""""; Warn about unintended use of ``sizeof()`` on pointer expressions. .. code-block:: c. struct s {};. int test(struct s *p) {; return sizeof(p);; // warn: sizeof(ptr) can produce an unexpected result; }. .. _alpha-core-StackAddressAsyncEscape:. alpha.core.StackAddressAsyncEscape (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check that addresses to stack memory do not escape the function that involves dispatch_after or dispatch_async.; This checker is a part of ``core.StackAddressEscape``, but is temporarily disabled until some false positives are fixed. .. code-block:: c. dispatch_block_t test_block_inside_block_async_leak() {; int x = 123;; void (^inner)(void) = ^void(void) {; int y = x;; ++y;; };; void (^outer)(void) = ^void(void) {; int z = x;; ++z;; inner();; };; return outer; // warn: address of stack-allocated block is captured by a; // returned block; }. .. _alpha-core-StdVariant:. alpha.core.StdVariant (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""; Check if a value of active type is retrieved from an ``std::variant`` instance with ``std::get``.; In case of bad variant type access (the accessed type differs from the active type); a warning",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:52047,Testability,test,test,52047,"""""""""""""""; Check that addresses to stack memory do not escape the function that involves dispatch_after or dispatch_async.; This checker is a part of ``core.StackAddressEscape``, but is temporarily disabled until some false positives are fixed. .. code-block:: c. dispatch_block_t test_block_inside_block_async_leak() {; int x = 123;; void (^inner)(void) = ^void(void) {; int y = x;; ++y;; };; void (^outer)(void) = ^void(void) {; int z = x;; ++z;; inner();; };; return outer; // warn: address of stack-allocated block is captured by a; // returned block; }. .. _alpha-core-StdVariant:. alpha.core.StdVariant (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""; Check if a value of active type is retrieved from an ``std::variant`` instance with ``std::get``.; In case of bad variant type access (the accessed type differs from the active type); a warning is emitted. Currently, this checker does not take exception handling into account. .. code-block:: cpp. void test() {; std::variant<int, char> v = 25;; char c = stg::get<char>(v); // warn: ""int"" is the active alternative; }. .. _alpha-core-TestAfterDivZero:. alpha.core.TestAfterDivZero (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for division by variable that is later compared against 0.; Either the comparison is useless or there is division by zero. .. code-block:: c. void test(int x) {; var = 77 / x;; if (x == 0) { } // warn; }. alpha.cplusplus; ^^^^^^^^^^^^^^^. .. _alpha-cplusplus-ArrayDelete:. alpha.cplusplus.ArrayDelete (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Reports destructions of arrays of polymorphic objects that are destructed as their base class.; This checker corresponds to the CERT rule `EXP51-CPP: Do not delete an array through a pointer of the incorrect type <https://wiki.sei.cmu.edu/confluence/display/cplusplus/EXP51-CPP.+Do+not+delete+an+array+through+a+pointer+of+the+incorrect+type>`_. .. code-block:: cpp. class Base {; virtual ~Base() {}; };; class Derived : public Base {}. Base *create() {; Base *x = new Derived[10]; // note:",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:52416,Testability,test,test,52416,"inner)(void) = ^void(void) {; int y = x;; ++y;; };; void (^outer)(void) = ^void(void) {; int z = x;; ++z;; inner();; };; return outer; // warn: address of stack-allocated block is captured by a; // returned block; }. .. _alpha-core-StdVariant:. alpha.core.StdVariant (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""; Check if a value of active type is retrieved from an ``std::variant`` instance with ``std::get``.; In case of bad variant type access (the accessed type differs from the active type); a warning is emitted. Currently, this checker does not take exception handling into account. .. code-block:: cpp. void test() {; std::variant<int, char> v = 25;; char c = stg::get<char>(v); // warn: ""int"" is the active alternative; }. .. _alpha-core-TestAfterDivZero:. alpha.core.TestAfterDivZero (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for division by variable that is later compared against 0.; Either the comparison is useless or there is division by zero. .. code-block:: c. void test(int x) {; var = 77 / x;; if (x == 0) { } // warn; }. alpha.cplusplus; ^^^^^^^^^^^^^^^. .. _alpha-cplusplus-ArrayDelete:. alpha.cplusplus.ArrayDelete (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Reports destructions of arrays of polymorphic objects that are destructed as their base class.; This checker corresponds to the CERT rule `EXP51-CPP: Do not delete an array through a pointer of the incorrect type <https://wiki.sei.cmu.edu/confluence/display/cplusplus/EXP51-CPP.+Do+not+delete+an+array+through+a+pointer+of+the+incorrect+type>`_. .. code-block:: cpp. class Base {; virtual ~Base() {}; };; class Derived : public Base {}. Base *create() {; Base *x = new Derived[10]; // note: Casting from 'Derived' to 'Base' here; return x;; }. void foo() {; Base *x = create();; delete[] x; // warn: Deleting an array of 'Derived' objects as their base class 'Base' is undefined; }. .. _alpha-cplusplus-DeleteWithNonVirtualDtor:. alpha.cplusplus.DeleteWithNonVirtualDtor (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Repo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:56146,Testability,test,test,56146,"of; // different containers; // used where the same; // container is; // expected; }. .. _alpha-cplusplus-MisusedMovedObject:. alpha.cplusplus.MisusedMovedObject (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Method calls on a moved-from object and copying a moved-from object will be reported. .. code-block:: cpp. struct A {; void foo() {}; };. void f() {; A a;; A b = std::move(a); // note: 'a' became 'moved-from' here; a.foo(); // warn: method call on a 'moved-from' object 'a'; }. .. _alpha-cplusplus-SmartPtr:. alpha.cplusplus.SmartPtr (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for dereference of null smart pointers. .. code-block:: cpp. void deref_smart_ptr() {; std::unique_ptr<int> P;; *P; // warn: dereference of a default constructed smart unique_ptr; }. alpha.deadcode; ^^^^^^^^^^^^^^; .. _alpha-deadcode-UnreachableCode:. alpha.deadcode.UnreachableCode (C, C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check unreachable code. .. code-block:: cpp. // C; int test() {; int x = 1;; while(x);; return x; // warn; }. // C++; void test() {; int a = 2;. while (a > 1); a--;. if (a > 1); a++; // warn; }. // Objective-C; void test(id x) {; return;; [x retain]; // warn; }. alpha.fuchsia; ^^^^^^^^^^^^^. .. _alpha-fuchsia-lock:. alpha.fuchsia.Lock; """"""""""""""""""""""""""""""""""""; Similarly to :ref:`alpha.unix.PthreadLock <alpha-unix-PthreadLock>`, checks for; the locking/unlocking of fuchsia mutexes. .. code-block:: cpp. spin_lock_t mtx1;. void bad1(void); {; spin_lock(&mtx1);; spin_lock(&mtx1);	// warn: This lock has already been acquired; }. alpha.llvm; ^^^^^^^^^^. .. _alpha-llvm-Conventions:. alpha.llvm.Conventions; """""""""""""""""""""""""""""""""""""""""""". Check code for LLVM codebase conventions:. * A StringRef should not be bound to a temporary std::string whose lifetime is shorter than the StringRef's.; * Clang AST nodes should not have fields that can allocate memory. alpha.osx; ^^^^^^^^^. .. _alpha-osx-cocoa-DirectIvarAssignment:. alpha.osx.cocoa.DirectIvarAssignment (ObjC); """"""""""""""""""""""""""""""""""""""",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:56214,Testability,test,test,56214,"e; // container is; // expected; }. .. _alpha-cplusplus-MisusedMovedObject:. alpha.cplusplus.MisusedMovedObject (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Method calls on a moved-from object and copying a moved-from object will be reported. .. code-block:: cpp. struct A {; void foo() {}; };. void f() {; A a;; A b = std::move(a); // note: 'a' became 'moved-from' here; a.foo(); // warn: method call on a 'moved-from' object 'a'; }. .. _alpha-cplusplus-SmartPtr:. alpha.cplusplus.SmartPtr (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for dereference of null smart pointers. .. code-block:: cpp. void deref_smart_ptr() {; std::unique_ptr<int> P;; *P; // warn: dereference of a default constructed smart unique_ptr; }. alpha.deadcode; ^^^^^^^^^^^^^^; .. _alpha-deadcode-UnreachableCode:. alpha.deadcode.UnreachableCode (C, C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check unreachable code. .. code-block:: cpp. // C; int test() {; int x = 1;; while(x);; return x; // warn; }. // C++; void test() {; int a = 2;. while (a > 1); a--;. if (a > 1); a++; // warn; }. // Objective-C; void test(id x) {; return;; [x retain]; // warn; }. alpha.fuchsia; ^^^^^^^^^^^^^. .. _alpha-fuchsia-lock:. alpha.fuchsia.Lock; """"""""""""""""""""""""""""""""""""; Similarly to :ref:`alpha.unix.PthreadLock <alpha-unix-PthreadLock>`, checks for; the locking/unlocking of fuchsia mutexes. .. code-block:: cpp. spin_lock_t mtx1;. void bad1(void); {; spin_lock(&mtx1);; spin_lock(&mtx1);	// warn: This lock has already been acquired; }. alpha.llvm; ^^^^^^^^^^. .. _alpha-llvm-Conventions:. alpha.llvm.Conventions; """""""""""""""""""""""""""""""""""""""""""". Check code for LLVM codebase conventions:. * A StringRef should not be bound to a temporary std::string whose lifetime is shorter than the StringRef's.; * Clang AST nodes should not have fields that can allocate memory. alpha.osx; ^^^^^^^^^. .. _alpha-osx-cocoa-DirectIvarAssignment:. alpha.osx.cocoa.DirectIvarAssignment (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for direct assignm",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:56307,Testability,test,test,56307,"vedObject (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Method calls on a moved-from object and copying a moved-from object will be reported. .. code-block:: cpp. struct A {; void foo() {}; };. void f() {; A a;; A b = std::move(a); // note: 'a' became 'moved-from' here; a.foo(); // warn: method call on a 'moved-from' object 'a'; }. .. _alpha-cplusplus-SmartPtr:. alpha.cplusplus.SmartPtr (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for dereference of null smart pointers. .. code-block:: cpp. void deref_smart_ptr() {; std::unique_ptr<int> P;; *P; // warn: dereference of a default constructed smart unique_ptr; }. alpha.deadcode; ^^^^^^^^^^^^^^; .. _alpha-deadcode-UnreachableCode:. alpha.deadcode.UnreachableCode (C, C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check unreachable code. .. code-block:: cpp. // C; int test() {; int x = 1;; while(x);; return x; // warn; }. // C++; void test() {; int a = 2;. while (a > 1); a--;. if (a > 1); a++; // warn; }. // Objective-C; void test(id x) {; return;; [x retain]; // warn; }. alpha.fuchsia; ^^^^^^^^^^^^^. .. _alpha-fuchsia-lock:. alpha.fuchsia.Lock; """"""""""""""""""""""""""""""""""""; Similarly to :ref:`alpha.unix.PthreadLock <alpha-unix-PthreadLock>`, checks for; the locking/unlocking of fuchsia mutexes. .. code-block:: cpp. spin_lock_t mtx1;. void bad1(void); {; spin_lock(&mtx1);; spin_lock(&mtx1);	// warn: This lock has already been acquired; }. alpha.llvm; ^^^^^^^^^^. .. _alpha-llvm-Conventions:. alpha.llvm.Conventions; """""""""""""""""""""""""""""""""""""""""""". Check code for LLVM codebase conventions:. * A StringRef should not be bound to a temporary std::string whose lifetime is shorter than the StringRef's.; * Clang AST nodes should not have fields that can allocate memory. alpha.osx; ^^^^^^^^^. .. _alpha-osx-cocoa-DirectIvarAssignment:. alpha.osx.cocoa.DirectIvarAssignment (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for direct assignments to instance variables. .. code-block:: objc. @interface MyClass : NSObject {}; @property (readon",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:60484,Testability,test,test,60484,"ocoa.localizability.PluralMisuseChecker (ObjC); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warns against using one vs. many plural pattern in code when generating localized strings. .. code-block:: objc. NSString *reminderText =; NSLocalizedString(@""None"", @""Indicates no reminders"");; if (reminderCount == 1) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; NSLocalizedString(@""1 Reminder"", @""Indicates single reminder"");; } else if (reminderCount >= 2) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; [NSString stringWithFormat:; NSLocalizedString(@""%@ Reminders"", @""Indicates multiple reminders""),; reminderCount];; }. alpha.security; ^^^^^^^^^^^^^^. .. _alpha-security-ArrayBound:. alpha.security.ArrayBound (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about buffer overflows (older checker). .. code-block:: c. void test() {; char *s = """";; char c = s[1]; // warn; }. struct seven_words {; int c[7];; };. void test() {; struct seven_words a, *p;; p = &a;; p[0] = a;; p[1] = a;; p[2] = a; // warn; }. // note: requires unix.Malloc or; // alpha.unix.MallocWithAnnotations checks enabled.; void test() {; int *p = malloc(12);; p[3] = 4; // warn; }. void test() {; char a[2];; int *b = (int*)a;; b[1] = 3; // warn; }. .. _alpha-security-ArrayBoundV2:. alpha.security.ArrayBoundV2 (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about buffer overflows (newer checker). .. code-block:: c. void test() {; char *s = """";; char c = s[1]; // warn; }. void test() {; int buf[100];; int *p = buf;; p = p + 99;; p[1] = 1; // warn; }. // note: compiler has internal check for this.; // Use -Wno-array-bounds to suppress compiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. .",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:60578,Testability,test,test,60578,"against using one vs. many plural pattern in code when generating localized strings. .. code-block:: objc. NSString *reminderText =; NSLocalizedString(@""None"", @""Indicates no reminders"");; if (reminderCount == 1) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; NSLocalizedString(@""1 Reminder"", @""Indicates single reminder"");; } else if (reminderCount >= 2) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; [NSString stringWithFormat:; NSLocalizedString(@""%@ Reminders"", @""Indicates multiple reminders""),; reminderCount];; }. alpha.security; ^^^^^^^^^^^^^^. .. _alpha-security-ArrayBound:. alpha.security.ArrayBound (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about buffer overflows (older checker). .. code-block:: c. void test() {; char *s = """";; char c = s[1]; // warn; }. struct seven_words {; int c[7];; };. void test() {; struct seven_words a, *p;; p = &a;; p[0] = a;; p[1] = a;; p[2] = a; // warn; }. // note: requires unix.Malloc or; // alpha.unix.MallocWithAnnotations checks enabled.; void test() {; int *p = malloc(12);; p[3] = 4; // warn; }. void test() {; char a[2];; int *b = (int*)a;; b[1] = 3; // warn; }. .. _alpha-security-ArrayBoundV2:. alpha.security.ArrayBoundV2 (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about buffer overflows (newer checker). .. code-block:: c. void test() {; char *s = """";; char c = s[1]; // warn; }. void test() {; int buf[100];; int *p = buf;; p = p + 99;; p[1] = 1; // warn; }. // note: compiler has internal check for this.; // Use -Wno-array-bounds to suppress compiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. .. _alpha-security-MallocOverflow:. alpha.security.MallocOverflow (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check fo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:60760,Testability,test,test,60760,"dicates no reminders"");; if (reminderCount == 1) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; NSLocalizedString(@""1 Reminder"", @""Indicates single reminder"");; } else if (reminderCount >= 2) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; [NSString stringWithFormat:; NSLocalizedString(@""%@ Reminders"", @""Indicates multiple reminders""),; reminderCount];; }. alpha.security; ^^^^^^^^^^^^^^. .. _alpha-security-ArrayBound:. alpha.security.ArrayBound (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about buffer overflows (older checker). .. code-block:: c. void test() {; char *s = """";; char c = s[1]; // warn; }. struct seven_words {; int c[7];; };. void test() {; struct seven_words a, *p;; p = &a;; p[0] = a;; p[1] = a;; p[2] = a; // warn; }. // note: requires unix.Malloc or; // alpha.unix.MallocWithAnnotations checks enabled.; void test() {; int *p = malloc(12);; p[3] = 4; // warn; }. void test() {; char a[2];; int *b = (int*)a;; b[1] = 3; // warn; }. .. _alpha-security-ArrayBoundV2:. alpha.security.ArrayBoundV2 (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about buffer overflows (newer checker). .. code-block:: c. void test() {; char *s = """";; char c = s[1]; // warn; }. void test() {; int buf[100];; int *p = buf;; p = p + 99;; p[1] = 1; // warn; }. // note: compiler has internal check for this.; // Use -Wno-array-bounds to suppress compiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. .. _alpha-security-MallocOverflow:. alpha.security.MallocOverflow (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for overflows in the arguments to ``malloc()``.; It tries to catch ``malloc(n * c)`` patterns, where:. - ``n``: a variable or member access of an object; - ``c``: a ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:60819,Testability,test,test,60819,"Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; NSLocalizedString(@""1 Reminder"", @""Indicates single reminder"");; } else if (reminderCount >= 2) {; // Warning: Plural cases are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; [NSString stringWithFormat:; NSLocalizedString(@""%@ Reminders"", @""Indicates multiple reminders""),; reminderCount];; }. alpha.security; ^^^^^^^^^^^^^^. .. _alpha-security-ArrayBound:. alpha.security.ArrayBound (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about buffer overflows (older checker). .. code-block:: c. void test() {; char *s = """";; char c = s[1]; // warn; }. struct seven_words {; int c[7];; };. void test() {; struct seven_words a, *p;; p = &a;; p[0] = a;; p[1] = a;; p[2] = a; // warn; }. // note: requires unix.Malloc or; // alpha.unix.MallocWithAnnotations checks enabled.; void test() {; int *p = malloc(12);; p[3] = 4; // warn; }. void test() {; char a[2];; int *b = (int*)a;; b[1] = 3; // warn; }. .. _alpha-security-ArrayBoundV2:. alpha.security.ArrayBoundV2 (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about buffer overflows (newer checker). .. code-block:: c. void test() {; char *s = """";; char c = s[1]; // warn; }. void test() {; int buf[100];; int *p = buf;; p = p + 99;; p[1] = 1; // warn; }. // note: compiler has internal check for this.; // Use -Wno-array-bounds to suppress compiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. .. _alpha-security-MallocOverflow:. alpha.security.MallocOverflow (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for overflows in the arguments to ``malloc()``.; It tries to catch ``malloc(n * c)`` patterns, where:. - ``n``: a variable or member access of an object; - ``c``: a constant foldable integral. This checker was designed for code a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:61051,Testability,test,test,61051,"ses are not supported across all languages.; // Use a .stringsdict file instead; reminderText =; [NSString stringWithFormat:; NSLocalizedString(@""%@ Reminders"", @""Indicates multiple reminders""),; reminderCount];; }. alpha.security; ^^^^^^^^^^^^^^. .. _alpha-security-ArrayBound:. alpha.security.ArrayBound (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about buffer overflows (older checker). .. code-block:: c. void test() {; char *s = """";; char c = s[1]; // warn; }. struct seven_words {; int c[7];; };. void test() {; struct seven_words a, *p;; p = &a;; p[0] = a;; p[1] = a;; p[2] = a; // warn; }. // note: requires unix.Malloc or; // alpha.unix.MallocWithAnnotations checks enabled.; void test() {; int *p = malloc(12);; p[3] = 4; // warn; }. void test() {; char a[2];; int *b = (int*)a;; b[1] = 3; // warn; }. .. _alpha-security-ArrayBoundV2:. alpha.security.ArrayBoundV2 (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about buffer overflows (newer checker). .. code-block:: c. void test() {; char *s = """";; char c = s[1]; // warn; }. void test() {; int buf[100];; int *p = buf;; p = p + 99;; p[1] = 1; // warn; }. // note: compiler has internal check for this.; // Use -Wno-array-bounds to suppress compiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. .. _alpha-security-MallocOverflow:. alpha.security.MallocOverflow (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for overflows in the arguments to ``malloc()``.; It tries to catch ``malloc(n * c)`` patterns, where:. - ``n``: a variable or member access of an object; - ``c``: a constant foldable integral. This checker was designed for code audits, so expect false-positive reports.; One is supposed to silence this checker by ensuring proper bounds checking on; the variable in question using e.g. an ``assert()`` or a branch. .. code-block:: c. void test(int n) {; vo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:61108,Testability,test,test,61108,"le instead; reminderText =; [NSString stringWithFormat:; NSLocalizedString(@""%@ Reminders"", @""Indicates multiple reminders""),; reminderCount];; }. alpha.security; ^^^^^^^^^^^^^^. .. _alpha-security-ArrayBound:. alpha.security.ArrayBound (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about buffer overflows (older checker). .. code-block:: c. void test() {; char *s = """";; char c = s[1]; // warn; }. struct seven_words {; int c[7];; };. void test() {; struct seven_words a, *p;; p = &a;; p[0] = a;; p[1] = a;; p[2] = a; // warn; }. // note: requires unix.Malloc or; // alpha.unix.MallocWithAnnotations checks enabled.; void test() {; int *p = malloc(12);; p[3] = 4; // warn; }. void test() {; char a[2];; int *b = (int*)a;; b[1] = 3; // warn; }. .. _alpha-security-ArrayBoundV2:. alpha.security.ArrayBoundV2 (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about buffer overflows (newer checker). .. code-block:: c. void test() {; char *s = """";; char c = s[1]; // warn; }. void test() {; int buf[100];; int *p = buf;; p = p + 99;; p[1] = 1; // warn; }. // note: compiler has internal check for this.; // Use -Wno-array-bounds to suppress compiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. .. _alpha-security-MallocOverflow:. alpha.security.MallocOverflow (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for overflows in the arguments to ``malloc()``.; It tries to catch ``malloc(n * c)`` patterns, where:. - ``n``: a variable or member access of an object; - ``c``: a constant foldable integral. This checker was designed for code audits, so expect false-positive reports.; One is supposed to silence this checker by ensuring proper bounds checking on; the variable in question using e.g. an ``assert()`` or a branch. .. code-block:: c. void test(int n) {; void *p = malloc(n * sizeof(int)); // warn; }. void test2(int n) {; if",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:61292,Testability,test,test,61292,"^^. .. _alpha-security-ArrayBound:. alpha.security.ArrayBound (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about buffer overflows (older checker). .. code-block:: c. void test() {; char *s = """";; char c = s[1]; // warn; }. struct seven_words {; int c[7];; };. void test() {; struct seven_words a, *p;; p = &a;; p[0] = a;; p[1] = a;; p[2] = a; // warn; }. // note: requires unix.Malloc or; // alpha.unix.MallocWithAnnotations checks enabled.; void test() {; int *p = malloc(12);; p[3] = 4; // warn; }. void test() {; char a[2];; int *b = (int*)a;; b[1] = 3; // warn; }. .. _alpha-security-ArrayBoundV2:. alpha.security.ArrayBoundV2 (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about buffer overflows (newer checker). .. code-block:: c. void test() {; char *s = """";; char c = s[1]; // warn; }. void test() {; int buf[100];; int *p = buf;; p = p + 99;; p[1] = 1; // warn; }. // note: compiler has internal check for this.; // Use -Wno-array-bounds to suppress compiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. .. _alpha-security-MallocOverflow:. alpha.security.MallocOverflow (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for overflows in the arguments to ``malloc()``.; It tries to catch ``malloc(n * c)`` patterns, where:. - ``n``: a variable or member access of an object; - ``c``: a constant foldable integral. This checker was designed for code audits, so expect false-positive reports.; One is supposed to silence this checker by ensuring proper bounds checking on; the variable in question using e.g. an ``assert()`` or a branch. .. code-block:: c. void test(int n) {; void *p = malloc(n * sizeof(int)); // warn; }. void test2(int n) {; if (n > 100) // gives an upper-bound; return;; void *p = malloc(n * sizeof(int)); // no warning; }. void test3(int n) {; assert(n <= 100 && ""Contract violated."");; void *p = mal",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:61412,Testability,test,test,61412,"er). .. code-block:: c. void test() {; char *s = """";; char c = s[1]; // warn; }. struct seven_words {; int c[7];; };. void test() {; struct seven_words a, *p;; p = &a;; p[0] = a;; p[1] = a;; p[2] = a; // warn; }. // note: requires unix.Malloc or; // alpha.unix.MallocWithAnnotations checks enabled.; void test() {; int *p = malloc(12);; p[3] = 4; // warn; }. void test() {; char a[2];; int *b = (int*)a;; b[1] = 3; // warn; }. .. _alpha-security-ArrayBoundV2:. alpha.security.ArrayBoundV2 (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn about buffer overflows (newer checker). .. code-block:: c. void test() {; char *s = """";; char c = s[1]; // warn; }. void test() {; int buf[100];; int *p = buf;; p = p + 99;; p[1] = 1; // warn; }. // note: compiler has internal check for this.; // Use -Wno-array-bounds to suppress compiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. .. _alpha-security-MallocOverflow:. alpha.security.MallocOverflow (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for overflows in the arguments to ``malloc()``.; It tries to catch ``malloc(n * c)`` patterns, where:. - ``n``: a variable or member access of an object; - ``c``: a constant foldable integral. This checker was designed for code audits, so expect false-positive reports.; One is supposed to silence this checker by ensuring proper bounds checking on; the variable in question using e.g. an ``assert()`` or a branch. .. code-block:: c. void test(int n) {; void *p = malloc(n * sizeof(int)); // warn; }. void test2(int n) {; if (n > 100) // gives an upper-bound; return;; void *p = malloc(n * sizeof(int)); // no warning; }. void test3(int n) {; assert(n <= 100 && ""Contract violated."");; void *p = malloc(n * sizeof(int)); // no warning; }. Limitations:. - The checker won't warn for variables involved in explicit casts,; since that might",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:62009,Testability,assert,assert,62009,"checker). .. code-block:: c. void test() {; char *s = """";; char c = s[1]; // warn; }. void test() {; int buf[100];; int *p = buf;; p = p + 99;; p[1] = 1; // warn; }. // note: compiler has internal check for this.; // Use -Wno-array-bounds to suppress compiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. .. _alpha-security-MallocOverflow:. alpha.security.MallocOverflow (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for overflows in the arguments to ``malloc()``.; It tries to catch ``malloc(n * c)`` patterns, where:. - ``n``: a variable or member access of an object; - ``c``: a constant foldable integral. This checker was designed for code audits, so expect false-positive reports.; One is supposed to silence this checker by ensuring proper bounds checking on; the variable in question using e.g. an ``assert()`` or a branch. .. code-block:: c. void test(int n) {; void *p = malloc(n * sizeof(int)); // warn; }. void test2(int n) {; if (n > 100) // gives an upper-bound; return;; void *p = malloc(n * sizeof(int)); // no warning; }. void test3(int n) {; assert(n <= 100 && ""Contract violated."");; void *p = malloc(n * sizeof(int)); // no warning; }. Limitations:. - The checker won't warn for variables involved in explicit casts,; since that might limit the variable's domain.; E.g.: ``(unsigned char)int x`` would limit the domain to ``[0,255]``.; The checker will miss the true-positive cases when the explicit cast would; not tighten the domain to prevent the overflow in the subsequent; multiplication operation. - It is an AST-based checker, thus it does not make use of the; path-sensitive taint-analysis. .. _alpha-security-MmapWriteExec:. alpha.security.MmapWriteExec (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on mmap() calls that are both writable and executable. .. code-block:: c. void test(int n)",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:62057,Testability,test,test,62057," s[1]; // warn; }. void test() {; int buf[100];; int *p = buf;; p = p + 99;; p[1] = 1; // warn; }. // note: compiler has internal check for this.; // Use -Wno-array-bounds to suppress compiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. .. _alpha-security-MallocOverflow:. alpha.security.MallocOverflow (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for overflows in the arguments to ``malloc()``.; It tries to catch ``malloc(n * c)`` patterns, where:. - ``n``: a variable or member access of an object; - ``c``: a constant foldable integral. This checker was designed for code audits, so expect false-positive reports.; One is supposed to silence this checker by ensuring proper bounds checking on; the variable in question using e.g. an ``assert()`` or a branch. .. code-block:: c. void test(int n) {; void *p = malloc(n * sizeof(int)); // warn; }. void test2(int n) {; if (n > 100) // gives an upper-bound; return;; void *p = malloc(n * sizeof(int)); // no warning; }. void test3(int n) {; assert(n <= 100 && ""Contract violated."");; void *p = malloc(n * sizeof(int)); // no warning; }. Limitations:. - The checker won't warn for variables involved in explicit casts,; since that might limit the variable's domain.; E.g.: ``(unsigned char)int x`` would limit the domain to ``[0,255]``.; The checker will miss the true-positive cases when the explicit cast would; not tighten the domain to prevent the overflow in the subsequent; multiplication operation. - It is an AST-based checker, thus it does not make use of the; path-sensitive taint-analysis. .. _alpha-security-MmapWriteExec:. alpha.security.MmapWriteExec (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on mmap() calls that are both writable and executable. .. code-block:: c. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; M",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:62261,Testability,assert,assert,62261,"ompiler warning.; void test() {; int buf[100][100];; buf[0][-1] = 1; // warn; }. // note: requires alpha.security.taint check turned on.; void test() {; char s[] = ""abc"";; int x = getchar();; char c = s[x]; // warn: index is tainted; }. .. _alpha-security-MallocOverflow:. alpha.security.MallocOverflow (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for overflows in the arguments to ``malloc()``.; It tries to catch ``malloc(n * c)`` patterns, where:. - ``n``: a variable or member access of an object; - ``c``: a constant foldable integral. This checker was designed for code audits, so expect false-positive reports.; One is supposed to silence this checker by ensuring proper bounds checking on; the variable in question using e.g. an ``assert()`` or a branch. .. code-block:: c. void test(int n) {; void *p = malloc(n * sizeof(int)); // warn; }. void test2(int n) {; if (n > 100) // gives an upper-bound; return;; void *p = malloc(n * sizeof(int)); // no warning; }. void test3(int n) {; assert(n <= 100 && ""Contract violated."");; void *p = malloc(n * sizeof(int)); // no warning; }. Limitations:. - The checker won't warn for variables involved in explicit casts,; since that might limit the variable's domain.; E.g.: ``(unsigned char)int x`` would limit the domain to ``[0,255]``.; The checker will miss the true-positive cases when the explicit cast would; not tighten the domain to prevent the overflow in the subsequent; multiplication operation. - It is an AST-based checker, thus it does not make use of the; path-sensitive taint-analysis. .. _alpha-security-MmapWriteExec:. alpha.security.MmapWriteExec (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on mmap() calls that are both writable and executable. .. code-block:: c. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // cod",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:63007,Testability,test,test,63007,"loc(n * sizeof(int)); // warn; }. void test2(int n) {; if (n > 100) // gives an upper-bound; return;; void *p = malloc(n * sizeof(int)); // no warning; }. void test3(int n) {; assert(n <= 100 && ""Contract violated."");; void *p = malloc(n * sizeof(int)); // no warning; }. Limitations:. - The checker won't warn for variables involved in explicit casts,; since that might limit the variable's domain.; E.g.: ``(unsigned char)int x`` would limit the domain to ``[0,255]``.; The checker will miss the true-positive cases when the explicit cast would; not tighten the domain to prevent the overflow in the subsequent; multiplication operation. - It is an AST-based checker, thus it does not make use of the; path-sensitive taint-analysis. .. _alpha-security-MmapWriteExec:. alpha.security.MmapWriteExec (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on mmap() calls that are both writable and executable. .. code-block:: c. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. .. _alpha-security-ReturnPtrRange:. alpha.security.ReturnPtrRange (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for an out-of-bound pointer being returned to callers. .. code-block:: c. static int A[10];. int *test() {; int *p = A + 10;; return p; // warn; }. int test(void) {; int x;; return x; // warn: undefined or garbage returned; }. alpha.security.cert; ^^^^^^^^^^^^^^^^^^^. SEI CERT checkers which tries to find errors based on their `C coding rules <https://wiki.sei.cmu.edu/confluence/display/c/2+Rules>`_. .. _alpha-security-cert-pos-checkers:. alpha.security.cert.pos; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `POSIX C coding rules <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152405>`_. .. _alpha-security-cert-pos-34c:. alpha.security.cert.pos.34c; """"""""""""""""""""""""""""""""""""""""""",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:63485,Testability,test,test,63485,"ar)int x`` would limit the domain to ``[0,255]``.; The checker will miss the true-positive cases when the explicit cast would; not tighten the domain to prevent the overflow in the subsequent; multiplication operation. - It is an AST-based checker, thus it does not make use of the; path-sensitive taint-analysis. .. _alpha-security-MmapWriteExec:. alpha.security.MmapWriteExec (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on mmap() calls that are both writable and executable. .. code-block:: c. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. .. _alpha-security-ReturnPtrRange:. alpha.security.ReturnPtrRange (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for an out-of-bound pointer being returned to callers. .. code-block:: c. static int A[10];. int *test() {; int *p = A + 10;; return p; // warn; }. int test(void) {; int x;; return x; // warn: undefined or garbage returned; }. alpha.security.cert; ^^^^^^^^^^^^^^^^^^^. SEI CERT checkers which tries to find errors based on their `C coding rules <https://wiki.sei.cmu.edu/confluence/display/c/2+Rules>`_. .. _alpha-security-cert-pos-checkers:. alpha.security.cert.pos; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `POSIX C coding rules <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152405>`_. .. _alpha-security-cert-pos-34c:. alpha.security.cert.pos.34c; """"""""""""""""""""""""""""""""""""""""""""""""""""""; Finds calls to the ``putenv`` function which pass a pointer to an automatic variable as the argument. .. code-block:: c. int func(const char *var) {; char env[1024];; int retval = snprintf(env, sizeof(env),""TEST=%s"", var);; if (retval < 0 || (size_t)retval >= sizeof(env)) {; /* Handle error */; }. return putenv(env); // putenv function should not be called with auto variables; }. Limitations:. - Technically, o",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:63539,Testability,test,test,63539," miss the true-positive cases when the explicit cast would; not tighten the domain to prevent the overflow in the subsequent; multiplication operation. - It is an AST-based checker, thus it does not make use of the; path-sensitive taint-analysis. .. _alpha-security-MmapWriteExec:. alpha.security.MmapWriteExec (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Warn on mmap() calls that are both writable and executable. .. code-block:: c. void test(int n) {; void *c = mmap(NULL, 32, PROT_READ | PROT_WRITE | PROT_EXEC,; MAP_PRIVATE | MAP_ANON, -1, 0);; // warn: Both PROT_WRITE and PROT_EXEC flags are set. This can lead to; // exploitable memory regions, which could be overwritten with malicious; // code; }. .. _alpha-security-ReturnPtrRange:. alpha.security.ReturnPtrRange (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for an out-of-bound pointer being returned to callers. .. code-block:: c. static int A[10];. int *test() {; int *p = A + 10;; return p; // warn; }. int test(void) {; int x;; return x; // warn: undefined or garbage returned; }. alpha.security.cert; ^^^^^^^^^^^^^^^^^^^. SEI CERT checkers which tries to find errors based on their `C coding rules <https://wiki.sei.cmu.edu/confluence/display/c/2+Rules>`_. .. _alpha-security-cert-pos-checkers:. alpha.security.cert.pos; ^^^^^^^^^^^^^^^^^^^^^^^. SEI CERT checkers of `POSIX C coding rules <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152405>`_. .. _alpha-security-cert-pos-34c:. alpha.security.cert.pos.34c; """"""""""""""""""""""""""""""""""""""""""""""""""""""; Finds calls to the ``putenv`` function which pass a pointer to an automatic variable as the argument. .. code-block:: c. int func(const char *var) {; char env[1024];; int retval = snprintf(env, sizeof(env),""TEST=%s"", var);; if (retval < 0 || (size_t)retval >= sizeof(env)) {; /* Handle error */; }. return putenv(env); // putenv function should not be called with auto variables; }. Limitations:. - Technically, one can pass automatic variables to ``putenv``,; but one needs to en",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:70298,Testability,test,test,70298,"rintf(""File does not exist\n"");; return -1;; }; #ifdef __clang_analyzer__; csa_mark_sanitized(filename); // Indicating to CSA that filename variable is safe to be used after this point; #endif; strcat(cmd, filename);; system(cmd); // No warning; }. Similarly to the previous example, you need to; define a `Filter` function in a `YAML` configuration file; and add the `csa_mark_sanitized` function. .. code-block:: YAML. Filters:; - Name: csa_mark_sanitized; Args: [0]. Then calling `csa_mark_sanitized(X)` will tell the analyzer that `X` is safe to; be used after this point, because its contents are verified. It is the; responsibility of the programmer to ensure that this verification was indeed; correct. Please note that `csa_mark_sanitized` function is only declared and; used during Clang Static Analysis and skipped in (production) builds. Further examples of injection vulnerabilities this checker can find. .. code-block:: c. void test() {; char x = getchar(); // 'x' marked as tainted; system(&x); // warn: untrusted data is passed to a system call; }. // note: compiler internally checks if the second param to; // sprintf is a string literal or not.; // Use -Wno-format-security to suppress compiler warning.; void test() {; char s[10], buf[10];; fscanf(stdin, ""%s"", s); // 's' marked as tainted. sprintf(buf, s); // warn: untrusted data used as a format string; }. void test() {; size_t ts;; scanf(""%zd"", &ts); // 'ts' marked as tainted; int *p = (int *)malloc(ts * sizeof(int));; // warn: untrusted data used as buffer size; }. There are built-in sources, propagations and sinks even if no external taint; configuration is provided. Default sources:; ``_IO_getc``, ``fdopen``, ``fopen``, ``freopen``, ``get_current_dir_name``,; ``getch``, ``getchar``, ``getchar_unlocked``, ``getwd``, ``getcwd``,; ``getgroups``, ``gethostname``, ``getlogin``, ``getlogin_r``, ``getnameinfo``,; ``gets``, ``gets_s``, ``getseuserbyname``, ``readlink``, ``readlinkat``,; ``scanf``, ``scanf_s``, ``socket",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:70585,Testability,test,test,70585,"previous example, you need to; define a `Filter` function in a `YAML` configuration file; and add the `csa_mark_sanitized` function. .. code-block:: YAML. Filters:; - Name: csa_mark_sanitized; Args: [0]. Then calling `csa_mark_sanitized(X)` will tell the analyzer that `X` is safe to; be used after this point, because its contents are verified. It is the; responsibility of the programmer to ensure that this verification was indeed; correct. Please note that `csa_mark_sanitized` function is only declared and; used during Clang Static Analysis and skipped in (production) builds. Further examples of injection vulnerabilities this checker can find. .. code-block:: c. void test() {; char x = getchar(); // 'x' marked as tainted; system(&x); // warn: untrusted data is passed to a system call; }. // note: compiler internally checks if the second param to; // sprintf is a string literal or not.; // Use -Wno-format-security to suppress compiler warning.; void test() {; char s[10], buf[10];; fscanf(stdin, ""%s"", s); // 's' marked as tainted. sprintf(buf, s); // warn: untrusted data used as a format string; }. void test() {; size_t ts;; scanf(""%zd"", &ts); // 'ts' marked as tainted; int *p = (int *)malloc(ts * sizeof(int));; // warn: untrusted data used as buffer size; }. There are built-in sources, propagations and sinks even if no external taint; configuration is provided. Default sources:; ``_IO_getc``, ``fdopen``, ``fopen``, ``freopen``, ``get_current_dir_name``,; ``getch``, ``getchar``, ``getchar_unlocked``, ``getwd``, ``getcwd``,; ``getgroups``, ``gethostname``, ``getlogin``, ``getlogin_r``, ``getnameinfo``,; ``gets``, ``gets_s``, ``getseuserbyname``, ``readlink``, ``readlinkat``,; ``scanf``, ``scanf_s``, ``socket``, ``wgetch``. Default propagations rules:; ``atoi``, ``atol``, ``atoll``, ``basename``, ``dirname``, ``fgetc``,; ``fgetln``, ``fgets``, ``fnmatch``, ``fread``, ``fscanf``, ``fscanf_s``,; ``index``, ``inflate``, ``isalnum``, ``isalpha``, ``isascii``, ``isblank``,; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:70741,Testability,test,test,70741,"gs: [0]. Then calling `csa_mark_sanitized(X)` will tell the analyzer that `X` is safe to; be used after this point, because its contents are verified. It is the; responsibility of the programmer to ensure that this verification was indeed; correct. Please note that `csa_mark_sanitized` function is only declared and; used during Clang Static Analysis and skipped in (production) builds. Further examples of injection vulnerabilities this checker can find. .. code-block:: c. void test() {; char x = getchar(); // 'x' marked as tainted; system(&x); // warn: untrusted data is passed to a system call; }. // note: compiler internally checks if the second param to; // sprintf is a string literal or not.; // Use -Wno-format-security to suppress compiler warning.; void test() {; char s[10], buf[10];; fscanf(stdin, ""%s"", s); // 's' marked as tainted. sprintf(buf, s); // warn: untrusted data used as a format string; }. void test() {; size_t ts;; scanf(""%zd"", &ts); // 'ts' marked as tainted; int *p = (int *)malloc(ts * sizeof(int));; // warn: untrusted data used as buffer size; }. There are built-in sources, propagations and sinks even if no external taint; configuration is provided. Default sources:; ``_IO_getc``, ``fdopen``, ``fopen``, ``freopen``, ``get_current_dir_name``,; ``getch``, ``getchar``, ``getchar_unlocked``, ``getwd``, ``getcwd``,; ``getgroups``, ``gethostname``, ``getlogin``, ``getlogin_r``, ``getnameinfo``,; ``gets``, ``gets_s``, ``getseuserbyname``, ``readlink``, ``readlinkat``,; ``scanf``, ``scanf_s``, ``socket``, ``wgetch``. Default propagations rules:; ``atoi``, ``atol``, ``atoll``, ``basename``, ``dirname``, ``fgetc``,; ``fgetln``, ``fgets``, ``fnmatch``, ``fread``, ``fscanf``, ``fscanf_s``,; ``index``, ``inflate``, ``isalnum``, ``isalpha``, ``isascii``, ``isblank``,; ``iscntrl``, ``isdigit``, ``isgraph``, ``islower``, ``isprint``, ``ispunct``,; ``isspace``, ``isupper``, ``isxdigit``, ``memchr``, ``memrchr``, ``sscanf``,; ``getc``, ``getc_unlocked``, ``getdeli",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:74863,Testability,test,test,74863," <https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=87152177>`_; * `ENV03-C. Sanitize the environment when invoking external programs; <https://wiki.sei.cmu.edu/confluence/display/c/ENV03-C.+Sanitize+the+environment+when+invoking+external+programs>`_. **Limitations**. * The taintedness property is not propagated through function calls which are; unknown (or too complex) to the analyzer, unless there is a specific; propagation rule built-in to the checker or given in the YAML configuration; file. This causes potential true positive findings to be lost. alpha.unix; ^^^^^^^^^^. .. _alpha-unix-BlockInCriticalSection:. alpha.unix.BlockInCriticalSection (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for calls to blocking functions inside a critical section.; Applies to: ``lock, unlock, sleep, getc, fgets, read, recv, pthread_mutex_lock,``; `` pthread_mutex_unlock, mtx_lock, mtx_timedlock, mtx_trylock, mtx_unlock, lock_guard, unique_lock``. .. code-block:: c. void test() {; std::mutex m;; m.lock();; sleep(3); // warn: a blocking function sleep is called inside a critical; // section; m.unlock();; }. .. _alpha-unix-Chroot:. alpha.unix.Chroot (C); """"""""""""""""""""""""""""""""""""""""""; Check improper use of chroot. .. code-block:: c. void f();. void test() {; chroot(""/usr/local"");; f(); // warn: no call of chdir(""/"") immediately after chroot; }. .. _alpha-unix-PthreadLock:. alpha.unix.PthreadLock (C); """"""""""""""""""""""""""""""""""""""""""""""""""""; Simple lock -> unlock checker.; Applies to: ``pthread_mutex_lock, pthread_rwlock_rdlock, pthread_rwlock_wrlock, lck_mtx_lock, lck_rw_lock_exclusive``; ``lck_rw_lock_shared, pthread_mutex_trylock, pthread_rwlock_tryrdlock, pthread_rwlock_tryrwlock, lck_mtx_try_lock,; lck_rw_try_lock_exclusive, lck_rw_try_lock_shared, pthread_mutex_unlock, pthread_rwlock_unlock, lck_mtx_unlock, lck_rw_done``. .. code-block:: c. pthread_mutex_t mtx;. void test() {; pthread_mutex_lock(&mtx);; pthread_mutex_lock(&mtx);; // warn: this lock has already been acquired; }. lc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:75136,Testability,test,test,75136,"ty is not propagated through function calls which are; unknown (or too complex) to the analyzer, unless there is a specific; propagation rule built-in to the checker or given in the YAML configuration; file. This causes potential true positive findings to be lost. alpha.unix; ^^^^^^^^^^. .. _alpha-unix-BlockInCriticalSection:. alpha.unix.BlockInCriticalSection (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for calls to blocking functions inside a critical section.; Applies to: ``lock, unlock, sleep, getc, fgets, read, recv, pthread_mutex_lock,``; `` pthread_mutex_unlock, mtx_lock, mtx_timedlock, mtx_trylock, mtx_unlock, lock_guard, unique_lock``. .. code-block:: c. void test() {; std::mutex m;; m.lock();; sleep(3); // warn: a blocking function sleep is called inside a critical; // section; m.unlock();; }. .. _alpha-unix-Chroot:. alpha.unix.Chroot (C); """"""""""""""""""""""""""""""""""""""""""; Check improper use of chroot. .. code-block:: c. void f();. void test() {; chroot(""/usr/local"");; f(); // warn: no call of chdir(""/"") immediately after chroot; }. .. _alpha-unix-PthreadLock:. alpha.unix.PthreadLock (C); """"""""""""""""""""""""""""""""""""""""""""""""""""; Simple lock -> unlock checker.; Applies to: ``pthread_mutex_lock, pthread_rwlock_rdlock, pthread_rwlock_wrlock, lck_mtx_lock, lck_rw_lock_exclusive``; ``lck_rw_lock_shared, pthread_mutex_trylock, pthread_rwlock_tryrdlock, pthread_rwlock_tryrwlock, lck_mtx_try_lock,; lck_rw_try_lock_exclusive, lck_rw_try_lock_shared, pthread_mutex_unlock, pthread_rwlock_unlock, lck_mtx_unlock, lck_rw_done``. .. code-block:: c. pthread_mutex_t mtx;. void test() {; pthread_mutex_lock(&mtx);; pthread_mutex_lock(&mtx);; // warn: this lock has already been acquired; }. lck_mtx_t lck1, lck2;. void test() {; lck_mtx_lock(&lck1);; lck_mtx_lock(&lck2);; lck_mtx_unlock(&lck1);; // warn: this was not the most recently acquired lock; }. lck_mtx_t lck1, lck2;. void test() {; if (lck_mtx_try_lock(&lck1) == 0); return;. lck_mtx_lock(&lck2);; lck_mtx_unlock(&lck1);; // warn: this was ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:75759,Testability,test,test,75759,"lock_guard, unique_lock``. .. code-block:: c. void test() {; std::mutex m;; m.lock();; sleep(3); // warn: a blocking function sleep is called inside a critical; // section; m.unlock();; }. .. _alpha-unix-Chroot:. alpha.unix.Chroot (C); """"""""""""""""""""""""""""""""""""""""""; Check improper use of chroot. .. code-block:: c. void f();. void test() {; chroot(""/usr/local"");; f(); // warn: no call of chdir(""/"") immediately after chroot; }. .. _alpha-unix-PthreadLock:. alpha.unix.PthreadLock (C); """"""""""""""""""""""""""""""""""""""""""""""""""""; Simple lock -> unlock checker.; Applies to: ``pthread_mutex_lock, pthread_rwlock_rdlock, pthread_rwlock_wrlock, lck_mtx_lock, lck_rw_lock_exclusive``; ``lck_rw_lock_shared, pthread_mutex_trylock, pthread_rwlock_tryrdlock, pthread_rwlock_tryrwlock, lck_mtx_try_lock,; lck_rw_try_lock_exclusive, lck_rw_try_lock_shared, pthread_mutex_unlock, pthread_rwlock_unlock, lck_mtx_unlock, lck_rw_done``. .. code-block:: c. pthread_mutex_t mtx;. void test() {; pthread_mutex_lock(&mtx);; pthread_mutex_lock(&mtx);; // warn: this lock has already been acquired; }. lck_mtx_t lck1, lck2;. void test() {; lck_mtx_lock(&lck1);; lck_mtx_lock(&lck2);; lck_mtx_unlock(&lck1);; // warn: this was not the most recently acquired lock; }. lck_mtx_t lck1, lck2;. void test() {; if (lck_mtx_try_lock(&lck1) == 0); return;. lck_mtx_lock(&lck2);; lck_mtx_unlock(&lck1);; // warn: this was not the most recently acquired lock; }. .. _alpha-unix-SimpleStream:. alpha.unix.SimpleStream (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""; Check for misuses of stream APIs. Check for misuses of stream APIs: ``fopen, fclose``; (demo checker, the subject of the demo (`Slides <https://llvm.org/devmtg/2012-11/Zaks-Rose-Checker24Hours.pdf>`_ ,; `Video <https://youtu.be/kdxlsP5QVPw>`_) by Anna Zaks and Jordan Rose presented at the; `2012 LLVM Developers' Meeting <https://llvm.org/devmtg/2012-11/>`_). .. code-block:: c. void test() {; FILE *F = fopen(""myfile.txt"", ""w"");; } // warn: opened file is never closed. void test() {; FILE *F = fopen",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:75900,Testability,test,test,75900,"ritical; // section; m.unlock();; }. .. _alpha-unix-Chroot:. alpha.unix.Chroot (C); """"""""""""""""""""""""""""""""""""""""""; Check improper use of chroot. .. code-block:: c. void f();. void test() {; chroot(""/usr/local"");; f(); // warn: no call of chdir(""/"") immediately after chroot; }. .. _alpha-unix-PthreadLock:. alpha.unix.PthreadLock (C); """"""""""""""""""""""""""""""""""""""""""""""""""""; Simple lock -> unlock checker.; Applies to: ``pthread_mutex_lock, pthread_rwlock_rdlock, pthread_rwlock_wrlock, lck_mtx_lock, lck_rw_lock_exclusive``; ``lck_rw_lock_shared, pthread_mutex_trylock, pthread_rwlock_tryrdlock, pthread_rwlock_tryrwlock, lck_mtx_try_lock,; lck_rw_try_lock_exclusive, lck_rw_try_lock_shared, pthread_mutex_unlock, pthread_rwlock_unlock, lck_mtx_unlock, lck_rw_done``. .. code-block:: c. pthread_mutex_t mtx;. void test() {; pthread_mutex_lock(&mtx);; pthread_mutex_lock(&mtx);; // warn: this lock has already been acquired; }. lck_mtx_t lck1, lck2;. void test() {; lck_mtx_lock(&lck1);; lck_mtx_lock(&lck2);; lck_mtx_unlock(&lck1);; // warn: this was not the most recently acquired lock; }. lck_mtx_t lck1, lck2;. void test() {; if (lck_mtx_try_lock(&lck1) == 0); return;. lck_mtx_lock(&lck2);; lck_mtx_unlock(&lck1);; // warn: this was not the most recently acquired lock; }. .. _alpha-unix-SimpleStream:. alpha.unix.SimpleStream (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""; Check for misuses of stream APIs. Check for misuses of stream APIs: ``fopen, fclose``; (demo checker, the subject of the demo (`Slides <https://llvm.org/devmtg/2012-11/Zaks-Rose-Checker24Hours.pdf>`_ ,; `Video <https://youtu.be/kdxlsP5QVPw>`_) by Anna Zaks and Jordan Rose presented at the; `2012 LLVM Developers' Meeting <https://llvm.org/devmtg/2012-11/>`_). .. code-block:: c. void test() {; FILE *F = fopen(""myfile.txt"", ""w"");; } // warn: opened file is never closed. void test() {; FILE *F = fopen(""myfile.txt"", ""w"");. if (F); fclose(F);. fclose(F); // warn: closing a previously closed file stream; }. .. _alpha-unix-Stream:. alpha.unix.Stream (C); ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:76064,Testability,test,test,76064,"se of chroot. .. code-block:: c. void f();. void test() {; chroot(""/usr/local"");; f(); // warn: no call of chdir(""/"") immediately after chroot; }. .. _alpha-unix-PthreadLock:. alpha.unix.PthreadLock (C); """"""""""""""""""""""""""""""""""""""""""""""""""""; Simple lock -> unlock checker.; Applies to: ``pthread_mutex_lock, pthread_rwlock_rdlock, pthread_rwlock_wrlock, lck_mtx_lock, lck_rw_lock_exclusive``; ``lck_rw_lock_shared, pthread_mutex_trylock, pthread_rwlock_tryrdlock, pthread_rwlock_tryrwlock, lck_mtx_try_lock,; lck_rw_try_lock_exclusive, lck_rw_try_lock_shared, pthread_mutex_unlock, pthread_rwlock_unlock, lck_mtx_unlock, lck_rw_done``. .. code-block:: c. pthread_mutex_t mtx;. void test() {; pthread_mutex_lock(&mtx);; pthread_mutex_lock(&mtx);; // warn: this lock has already been acquired; }. lck_mtx_t lck1, lck2;. void test() {; lck_mtx_lock(&lck1);; lck_mtx_lock(&lck2);; lck_mtx_unlock(&lck1);; // warn: this was not the most recently acquired lock; }. lck_mtx_t lck1, lck2;. void test() {; if (lck_mtx_try_lock(&lck1) == 0); return;. lck_mtx_lock(&lck2);; lck_mtx_unlock(&lck1);; // warn: this was not the most recently acquired lock; }. .. _alpha-unix-SimpleStream:. alpha.unix.SimpleStream (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""; Check for misuses of stream APIs. Check for misuses of stream APIs: ``fopen, fclose``; (demo checker, the subject of the demo (`Slides <https://llvm.org/devmtg/2012-11/Zaks-Rose-Checker24Hours.pdf>`_ ,; `Video <https://youtu.be/kdxlsP5QVPw>`_) by Anna Zaks and Jordan Rose presented at the; `2012 LLVM Developers' Meeting <https://llvm.org/devmtg/2012-11/>`_). .. code-block:: c. void test() {; FILE *F = fopen(""myfile.txt"", ""w"");; } // warn: opened file is never closed. void test() {; FILE *F = fopen(""myfile.txt"", ""w"");. if (F); fclose(F);. fclose(F); // warn: closing a previously closed file stream; }. .. _alpha-unix-Stream:. alpha.unix.Stream (C); """"""""""""""""""""""""""""""""""""""""""; Check stream handling functions: ``fopen, tmpfile, fclose, fread, fwrite, fseek, ftell, rewind, fget",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:76695,Testability,test,test,76695,"``. .. code-block:: c. pthread_mutex_t mtx;. void test() {; pthread_mutex_lock(&mtx);; pthread_mutex_lock(&mtx);; // warn: this lock has already been acquired; }. lck_mtx_t lck1, lck2;. void test() {; lck_mtx_lock(&lck1);; lck_mtx_lock(&lck2);; lck_mtx_unlock(&lck1);; // warn: this was not the most recently acquired lock; }. lck_mtx_t lck1, lck2;. void test() {; if (lck_mtx_try_lock(&lck1) == 0); return;. lck_mtx_lock(&lck2);; lck_mtx_unlock(&lck1);; // warn: this was not the most recently acquired lock; }. .. _alpha-unix-SimpleStream:. alpha.unix.SimpleStream (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""; Check for misuses of stream APIs. Check for misuses of stream APIs: ``fopen, fclose``; (demo checker, the subject of the demo (`Slides <https://llvm.org/devmtg/2012-11/Zaks-Rose-Checker24Hours.pdf>`_ ,; `Video <https://youtu.be/kdxlsP5QVPw>`_) by Anna Zaks and Jordan Rose presented at the; `2012 LLVM Developers' Meeting <https://llvm.org/devmtg/2012-11/>`_). .. code-block:: c. void test() {; FILE *F = fopen(""myfile.txt"", ""w"");; } // warn: opened file is never closed. void test() {; FILE *F = fopen(""myfile.txt"", ""w"");. if (F); fclose(F);. fclose(F); // warn: closing a previously closed file stream; }. .. _alpha-unix-Stream:. alpha.unix.Stream (C); """"""""""""""""""""""""""""""""""""""""""; Check stream handling functions: ``fopen, tmpfile, fclose, fread, fwrite, fseek, ftell, rewind, fgetpos,``; ``fsetpos, clearerr, feof, ferror, fileno``. .. code-block:: c. void test() {; FILE *p = fopen(""foo"", ""r"");; } // warn: opened file is never closed. void test() {; FILE *p = fopen(""foo"", ""r"");; fseek(p, 1, SEEK_SET); // warn: stream pointer might be NULL; fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");. if (p); fseek(p, 1, 3);; // warn: third arg should be SEEK_SET, SEEK_END, or SEEK_CUR. fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");; fclose(p);; fclose(p); // warn: already closed; }. void test() {; FILE *p = tmpfile();; ftell(p); // warn: stream pointer might be NULL; fclose(p);; }",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:76787,Testability,test,test,76787,"ad_mutex_lock(&mtx);; // warn: this lock has already been acquired; }. lck_mtx_t lck1, lck2;. void test() {; lck_mtx_lock(&lck1);; lck_mtx_lock(&lck2);; lck_mtx_unlock(&lck1);; // warn: this was not the most recently acquired lock; }. lck_mtx_t lck1, lck2;. void test() {; if (lck_mtx_try_lock(&lck1) == 0); return;. lck_mtx_lock(&lck2);; lck_mtx_unlock(&lck1);; // warn: this was not the most recently acquired lock; }. .. _alpha-unix-SimpleStream:. alpha.unix.SimpleStream (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""; Check for misuses of stream APIs. Check for misuses of stream APIs: ``fopen, fclose``; (demo checker, the subject of the demo (`Slides <https://llvm.org/devmtg/2012-11/Zaks-Rose-Checker24Hours.pdf>`_ ,; `Video <https://youtu.be/kdxlsP5QVPw>`_) by Anna Zaks and Jordan Rose presented at the; `2012 LLVM Developers' Meeting <https://llvm.org/devmtg/2012-11/>`_). .. code-block:: c. void test() {; FILE *F = fopen(""myfile.txt"", ""w"");; } // warn: opened file is never closed. void test() {; FILE *F = fopen(""myfile.txt"", ""w"");. if (F); fclose(F);. fclose(F); // warn: closing a previously closed file stream; }. .. _alpha-unix-Stream:. alpha.unix.Stream (C); """"""""""""""""""""""""""""""""""""""""""; Check stream handling functions: ``fopen, tmpfile, fclose, fread, fwrite, fseek, ftell, rewind, fgetpos,``; ``fsetpos, clearerr, feof, ferror, fileno``. .. code-block:: c. void test() {; FILE *p = fopen(""foo"", ""r"");; } // warn: opened file is never closed. void test() {; FILE *p = fopen(""foo"", ""r"");; fseek(p, 1, SEEK_SET); // warn: stream pointer might be NULL; fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");. if (p); fseek(p, 1, 3);; // warn: third arg should be SEEK_SET, SEEK_END, or SEEK_CUR. fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");; fclose(p);; fclose(p); // warn: already closed; }. void test() {; FILE *p = tmpfile();; ftell(p); // warn: stream pointer might be NULL; fclose(p);; }. .. _alpha-unix-cstring-BufferOverlap:. alpha.unix.cstring.BufferOverlap (C); """"""""""""""""""""""""""",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:77165,Testability,test,test,77165,"ly acquired lock; }. .. _alpha-unix-SimpleStream:. alpha.unix.SimpleStream (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""; Check for misuses of stream APIs. Check for misuses of stream APIs: ``fopen, fclose``; (demo checker, the subject of the demo (`Slides <https://llvm.org/devmtg/2012-11/Zaks-Rose-Checker24Hours.pdf>`_ ,; `Video <https://youtu.be/kdxlsP5QVPw>`_) by Anna Zaks and Jordan Rose presented at the; `2012 LLVM Developers' Meeting <https://llvm.org/devmtg/2012-11/>`_). .. code-block:: c. void test() {; FILE *F = fopen(""myfile.txt"", ""w"");; } // warn: opened file is never closed. void test() {; FILE *F = fopen(""myfile.txt"", ""w"");. if (F); fclose(F);. fclose(F); // warn: closing a previously closed file stream; }. .. _alpha-unix-Stream:. alpha.unix.Stream (C); """"""""""""""""""""""""""""""""""""""""""; Check stream handling functions: ``fopen, tmpfile, fclose, fread, fwrite, fseek, ftell, rewind, fgetpos,``; ``fsetpos, clearerr, feof, ferror, fileno``. .. code-block:: c. void test() {; FILE *p = fopen(""foo"", ""r"");; } // warn: opened file is never closed. void test() {; FILE *p = fopen(""foo"", ""r"");; fseek(p, 1, SEEK_SET); // warn: stream pointer might be NULL; fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");. if (p); fseek(p, 1, 3);; // warn: third arg should be SEEK_SET, SEEK_END, or SEEK_CUR. fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");; fclose(p);; fclose(p); // warn: already closed; }. void test() {; FILE *p = tmpfile();; ftell(p); // warn: stream pointer might be NULL; fclose(p);; }. .. _alpha-unix-cstring-BufferOverlap:. alpha.unix.cstring.BufferOverlap (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Checks for overlap in two buffer arguments. Applies to: ``memcpy, mempcpy, wmemcpy, wmempcpy``. .. code-block:: c. void test() {; int a[4] = {0};; memcpy(a + 2, a + 1, 8); // warn; }. .. _alpha-unix-cstring-NotNullTerminated:. alpha.unix.cstring.NotNullTerminated (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for arguments which are not null-terminated strings; applie",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:77250,Testability,test,test,77250,"""""""; Check for misuses of stream APIs. Check for misuses of stream APIs: ``fopen, fclose``; (demo checker, the subject of the demo (`Slides <https://llvm.org/devmtg/2012-11/Zaks-Rose-Checker24Hours.pdf>`_ ,; `Video <https://youtu.be/kdxlsP5QVPw>`_) by Anna Zaks and Jordan Rose presented at the; `2012 LLVM Developers' Meeting <https://llvm.org/devmtg/2012-11/>`_). .. code-block:: c. void test() {; FILE *F = fopen(""myfile.txt"", ""w"");; } // warn: opened file is never closed. void test() {; FILE *F = fopen(""myfile.txt"", ""w"");. if (F); fclose(F);. fclose(F); // warn: closing a previously closed file stream; }. .. _alpha-unix-Stream:. alpha.unix.Stream (C); """"""""""""""""""""""""""""""""""""""""""; Check stream handling functions: ``fopen, tmpfile, fclose, fread, fwrite, fseek, ftell, rewind, fgetpos,``; ``fsetpos, clearerr, feof, ferror, fileno``. .. code-block:: c. void test() {; FILE *p = fopen(""foo"", ""r"");; } // warn: opened file is never closed. void test() {; FILE *p = fopen(""foo"", ""r"");; fseek(p, 1, SEEK_SET); // warn: stream pointer might be NULL; fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");. if (p); fseek(p, 1, 3);; // warn: third arg should be SEEK_SET, SEEK_END, or SEEK_CUR. fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");; fclose(p);; fclose(p); // warn: already closed; }. void test() {; FILE *p = tmpfile();; ftell(p); // warn: stream pointer might be NULL; fclose(p);; }. .. _alpha-unix-cstring-BufferOverlap:. alpha.unix.cstring.BufferOverlap (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Checks for overlap in two buffer arguments. Applies to: ``memcpy, mempcpy, wmemcpy, wmempcpy``. .. code-block:: c. void test() {; int a[4] = {0};; memcpy(a + 2, a + 1, 8); // warn; }. .. _alpha-unix-cstring-NotNullTerminated:. alpha.unix.cstring.NotNullTerminated (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for arguments which are not null-terminated strings; applies to: ``strlen, strnlen, strcpy, strncpy, strcat, strncat, wcslen, wcsnlen``. .. code-block:: c. void t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:77372,Testability,test,test,77372,"close``; (demo checker, the subject of the demo (`Slides <https://llvm.org/devmtg/2012-11/Zaks-Rose-Checker24Hours.pdf>`_ ,; `Video <https://youtu.be/kdxlsP5QVPw>`_) by Anna Zaks and Jordan Rose presented at the; `2012 LLVM Developers' Meeting <https://llvm.org/devmtg/2012-11/>`_). .. code-block:: c. void test() {; FILE *F = fopen(""myfile.txt"", ""w"");; } // warn: opened file is never closed. void test() {; FILE *F = fopen(""myfile.txt"", ""w"");. if (F); fclose(F);. fclose(F); // warn: closing a previously closed file stream; }. .. _alpha-unix-Stream:. alpha.unix.Stream (C); """"""""""""""""""""""""""""""""""""""""""; Check stream handling functions: ``fopen, tmpfile, fclose, fread, fwrite, fseek, ftell, rewind, fgetpos,``; ``fsetpos, clearerr, feof, ferror, fileno``. .. code-block:: c. void test() {; FILE *p = fopen(""foo"", ""r"");; } // warn: opened file is never closed. void test() {; FILE *p = fopen(""foo"", ""r"");; fseek(p, 1, SEEK_SET); // warn: stream pointer might be NULL; fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");. if (p); fseek(p, 1, 3);; // warn: third arg should be SEEK_SET, SEEK_END, or SEEK_CUR. fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");; fclose(p);; fclose(p); // warn: already closed; }. void test() {; FILE *p = tmpfile();; ftell(p); // warn: stream pointer might be NULL; fclose(p);; }. .. _alpha-unix-cstring-BufferOverlap:. alpha.unix.cstring.BufferOverlap (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Checks for overlap in two buffer arguments. Applies to: ``memcpy, mempcpy, wmemcpy, wmempcpy``. .. code-block:: c. void test() {; int a[4] = {0};; memcpy(a + 2, a + 1, 8); // warn; }. .. _alpha-unix-cstring-NotNullTerminated:. alpha.unix.cstring.NotNullTerminated (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for arguments which are not null-terminated strings; applies to: ``strlen, strnlen, strcpy, strncpy, strcat, strncat, wcslen, wcsnlen``. .. code-block:: c. void test() {; int y = strlen((char *)&test); // warn; }. .. _alpha-unix-cstring-OutOfBoun",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:77519,Testability,test,test,77519," Zaks and Jordan Rose presented at the; `2012 LLVM Developers' Meeting <https://llvm.org/devmtg/2012-11/>`_). .. code-block:: c. void test() {; FILE *F = fopen(""myfile.txt"", ""w"");; } // warn: opened file is never closed. void test() {; FILE *F = fopen(""myfile.txt"", ""w"");. if (F); fclose(F);. fclose(F); // warn: closing a previously closed file stream; }. .. _alpha-unix-Stream:. alpha.unix.Stream (C); """"""""""""""""""""""""""""""""""""""""""; Check stream handling functions: ``fopen, tmpfile, fclose, fread, fwrite, fseek, ftell, rewind, fgetpos,``; ``fsetpos, clearerr, feof, ferror, fileno``. .. code-block:: c. void test() {; FILE *p = fopen(""foo"", ""r"");; } // warn: opened file is never closed. void test() {; FILE *p = fopen(""foo"", ""r"");; fseek(p, 1, SEEK_SET); // warn: stream pointer might be NULL; fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");. if (p); fseek(p, 1, 3);; // warn: third arg should be SEEK_SET, SEEK_END, or SEEK_CUR. fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");; fclose(p);; fclose(p); // warn: already closed; }. void test() {; FILE *p = tmpfile();; ftell(p); // warn: stream pointer might be NULL; fclose(p);; }. .. _alpha-unix-cstring-BufferOverlap:. alpha.unix.cstring.BufferOverlap (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Checks for overlap in two buffer arguments. Applies to: ``memcpy, mempcpy, wmemcpy, wmempcpy``. .. code-block:: c. void test() {; int a[4] = {0};; memcpy(a + 2, a + 1, 8); // warn; }. .. _alpha-unix-cstring-NotNullTerminated:. alpha.unix.cstring.NotNullTerminated (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for arguments which are not null-terminated strings; applies to: ``strlen, strnlen, strcpy, strncpy, strcat, strncat, wcslen, wcsnlen``. .. code-block:: c. void test() {; int y = strlen((char *)&test); // warn; }. .. _alpha-unix-cstring-OutOfBounds:. alpha.unix.cstring.OutOfBounds (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for out-of-bounds access in string functions, such as:; ``memcpy, bcopy, strcpy, strncpy,",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:77615,Testability,test,test,77615,"12-11/>`_). .. code-block:: c. void test() {; FILE *F = fopen(""myfile.txt"", ""w"");; } // warn: opened file is never closed. void test() {; FILE *F = fopen(""myfile.txt"", ""w"");. if (F); fclose(F);. fclose(F); // warn: closing a previously closed file stream; }. .. _alpha-unix-Stream:. alpha.unix.Stream (C); """"""""""""""""""""""""""""""""""""""""""; Check stream handling functions: ``fopen, tmpfile, fclose, fread, fwrite, fseek, ftell, rewind, fgetpos,``; ``fsetpos, clearerr, feof, ferror, fileno``. .. code-block:: c. void test() {; FILE *p = fopen(""foo"", ""r"");; } // warn: opened file is never closed. void test() {; FILE *p = fopen(""foo"", ""r"");; fseek(p, 1, SEEK_SET); // warn: stream pointer might be NULL; fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");. if (p); fseek(p, 1, 3);; // warn: third arg should be SEEK_SET, SEEK_END, or SEEK_CUR. fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");; fclose(p);; fclose(p); // warn: already closed; }. void test() {; FILE *p = tmpfile();; ftell(p); // warn: stream pointer might be NULL; fclose(p);; }. .. _alpha-unix-cstring-BufferOverlap:. alpha.unix.cstring.BufferOverlap (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Checks for overlap in two buffer arguments. Applies to: ``memcpy, mempcpy, wmemcpy, wmempcpy``. .. code-block:: c. void test() {; int a[4] = {0};; memcpy(a + 2, a + 1, 8); // warn; }. .. _alpha-unix-cstring-NotNullTerminated:. alpha.unix.cstring.NotNullTerminated (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for arguments which are not null-terminated strings; applies to: ``strlen, strnlen, strcpy, strncpy, strcat, strncat, wcslen, wcsnlen``. .. code-block:: c. void test() {; int y = strlen((char *)&test); // warn; }. .. _alpha-unix-cstring-OutOfBounds:. alpha.unix.cstring.OutOfBounds (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for out-of-bounds access in string functions, such as:; ``memcpy, bcopy, strcpy, strncpy, strcat, strncat, memmove, memcmp, memset`` and more. This check also works with string literals, e",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:77946,Testability,test,test,77946,"""""""""""""""""""""""""; Check stream handling functions: ``fopen, tmpfile, fclose, fread, fwrite, fseek, ftell, rewind, fgetpos,``; ``fsetpos, clearerr, feof, ferror, fileno``. .. code-block:: c. void test() {; FILE *p = fopen(""foo"", ""r"");; } // warn: opened file is never closed. void test() {; FILE *p = fopen(""foo"", ""r"");; fseek(p, 1, SEEK_SET); // warn: stream pointer might be NULL; fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");. if (p); fseek(p, 1, 3);; // warn: third arg should be SEEK_SET, SEEK_END, or SEEK_CUR. fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");; fclose(p);; fclose(p); // warn: already closed; }. void test() {; FILE *p = tmpfile();; ftell(p); // warn: stream pointer might be NULL; fclose(p);; }. .. _alpha-unix-cstring-BufferOverlap:. alpha.unix.cstring.BufferOverlap (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Checks for overlap in two buffer arguments. Applies to: ``memcpy, mempcpy, wmemcpy, wmempcpy``. .. code-block:: c. void test() {; int a[4] = {0};; memcpy(a + 2, a + 1, 8); // warn; }. .. _alpha-unix-cstring-NotNullTerminated:. alpha.unix.cstring.NotNullTerminated (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for arguments which are not null-terminated strings; applies to: ``strlen, strnlen, strcpy, strncpy, strcat, strncat, wcslen, wcsnlen``. .. code-block:: c. void test() {; int y = strlen((char *)&test); // warn; }. .. _alpha-unix-cstring-OutOfBounds:. alpha.unix.cstring.OutOfBounds (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for out-of-bounds access in string functions, such as:; ``memcpy, bcopy, strcpy, strncpy, strcat, strncat, memmove, memcmp, memset`` and more. This check also works with string literals, except there is a known bug in that; the analyzer cannot detect embedded NULL characters when determining the string length. .. code-block:: c. void test1() {; const char str[] = ""Hello world"";; char buffer[] = ""Hello world"";; memcpy(buffer, str, sizeof(str) + 1); // warn; }. void test2() {; const char str[] = ""Hel",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:78304,Testability,test,test,78304,"m pointer might be NULL; fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");. if (p); fseek(p, 1, 3);; // warn: third arg should be SEEK_SET, SEEK_END, or SEEK_CUR. fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");; fclose(p);; fclose(p); // warn: already closed; }. void test() {; FILE *p = tmpfile();; ftell(p); // warn: stream pointer might be NULL; fclose(p);; }. .. _alpha-unix-cstring-BufferOverlap:. alpha.unix.cstring.BufferOverlap (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Checks for overlap in two buffer arguments. Applies to: ``memcpy, mempcpy, wmemcpy, wmempcpy``. .. code-block:: c. void test() {; int a[4] = {0};; memcpy(a + 2, a + 1, 8); // warn; }. .. _alpha-unix-cstring-NotNullTerminated:. alpha.unix.cstring.NotNullTerminated (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for arguments which are not null-terminated strings; applies to: ``strlen, strnlen, strcpy, strncpy, strcat, strncat, wcslen, wcsnlen``. .. code-block:: c. void test() {; int y = strlen((char *)&test); // warn; }. .. _alpha-unix-cstring-OutOfBounds:. alpha.unix.cstring.OutOfBounds (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for out-of-bounds access in string functions, such as:; ``memcpy, bcopy, strcpy, strncpy, strcat, strncat, memmove, memcmp, memset`` and more. This check also works with string literals, except there is a known bug in that; the analyzer cannot detect embedded NULL characters when determining the string length. .. code-block:: c. void test1() {; const char str[] = ""Hello world"";; char buffer[] = ""Hello world"";; memcpy(buffer, str, sizeof(str) + 1); // warn; }. void test2() {; const char str[] = ""Hello world"";; char buffer[] = ""Helloworld"";; memcpy(buffer, str, sizeof(str)); // warn; }. .. _alpha-unix-cstring-UninitializedRead:. alpha.unix.cstring.UninitializedRead (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for uninitialized reads from common memory copy/manipulation functions such as:; ``memcpy, mempcpy, memmove, memcmp, strcmp, strnc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:78338,Testability,test,test,78338,"m pointer might be NULL; fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");. if (p); fseek(p, 1, 3);; // warn: third arg should be SEEK_SET, SEEK_END, or SEEK_CUR. fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");; fclose(p);; fclose(p); // warn: already closed; }. void test() {; FILE *p = tmpfile();; ftell(p); // warn: stream pointer might be NULL; fclose(p);; }. .. _alpha-unix-cstring-BufferOverlap:. alpha.unix.cstring.BufferOverlap (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Checks for overlap in two buffer arguments. Applies to: ``memcpy, mempcpy, wmemcpy, wmempcpy``. .. code-block:: c. void test() {; int a[4] = {0};; memcpy(a + 2, a + 1, 8); // warn; }. .. _alpha-unix-cstring-NotNullTerminated:. alpha.unix.cstring.NotNullTerminated (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for arguments which are not null-terminated strings; applies to: ``strlen, strnlen, strcpy, strncpy, strcat, strncat, wcslen, wcsnlen``. .. code-block:: c. void test() {; int y = strlen((char *)&test); // warn; }. .. _alpha-unix-cstring-OutOfBounds:. alpha.unix.cstring.OutOfBounds (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for out-of-bounds access in string functions, such as:; ``memcpy, bcopy, strcpy, strncpy, strcat, strncat, memmove, memcmp, memset`` and more. This check also works with string literals, except there is a known bug in that; the analyzer cannot detect embedded NULL characters when determining the string length. .. code-block:: c. void test1() {; const char str[] = ""Hello world"";; char buffer[] = ""Hello world"";; memcpy(buffer, str, sizeof(str) + 1); // warn; }. void test2() {; const char str[] = ""Hello world"";; char buffer[] = ""Helloworld"";; memcpy(buffer, str, sizeof(str)); // warn; }. .. _alpha-unix-cstring-UninitializedRead:. alpha.unix.cstring.UninitializedRead (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for uninitialized reads from common memory copy/manipulation functions such as:; ``memcpy, mempcpy, memmove, memcmp, strcmp, strnc",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:79395,Testability,test,test,79395,"""""; Check for out-of-bounds access in string functions, such as:; ``memcpy, bcopy, strcpy, strncpy, strcat, strncat, memmove, memcmp, memset`` and more. This check also works with string literals, except there is a known bug in that; the analyzer cannot detect embedded NULL characters when determining the string length. .. code-block:: c. void test1() {; const char str[] = ""Hello world"";; char buffer[] = ""Hello world"";; memcpy(buffer, str, sizeof(str) + 1); // warn; }. void test2() {; const char str[] = ""Hello world"";; char buffer[] = ""Helloworld"";; memcpy(buffer, str, sizeof(str)); // warn; }. .. _alpha-unix-cstring-UninitializedRead:. alpha.unix.cstring.UninitializedRead (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for uninitialized reads from common memory copy/manipulation functions such as:; ``memcpy, mempcpy, memmove, memcmp, strcmp, strncmp, strcpy, strlen, strsep`` and many more. .. code-block:: c. void test() {; char src[10];; char dst[5];; memcpy(dst,src,sizeof(dst)); // warn: Bytes string function accesses uninitialized/garbage values; }. Limitations:. - Due to limitations of the memory modeling in the analyzer, one can likely; observe a lot of false-positive reports like this:. .. code-block:: c. void false_positive() {; int src[] = {1, 2, 3, 4};; int dst[5] = {0};; memcpy(dst, src, 4 * sizeof(int)); // false-positive:; // The 'src' buffer was correctly initialized, yet we cannot conclude; // that since the analyzer could not see a direct initialization of the; // very last byte of the source buffer.; }. More details at the corresponding `GitHub issue <https://github.com/llvm/llvm-project/issues/43459>`_. .. _alpha-nondeterminism-PointerIteration:. alpha.nondeterminism.PointerIteration (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for non-determinism caused by iterating unordered containers of pointers. .. code-block:: c. void test() {; int a = 1, b = 2;; std::unordered_set<int *> UnorderedPtrSet = {&a, &b};. for (auto i : UnorderedPt",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:80353,Testability,test,test,80353,"oid test() {; char src[10];; char dst[5];; memcpy(dst,src,sizeof(dst)); // warn: Bytes string function accesses uninitialized/garbage values; }. Limitations:. - Due to limitations of the memory modeling in the analyzer, one can likely; observe a lot of false-positive reports like this:. .. code-block:: c. void false_positive() {; int src[] = {1, 2, 3, 4};; int dst[5] = {0};; memcpy(dst, src, 4 * sizeof(int)); // false-positive:; // The 'src' buffer was correctly initialized, yet we cannot conclude; // that since the analyzer could not see a direct initialization of the; // very last byte of the source buffer.; }. More details at the corresponding `GitHub issue <https://github.com/llvm/llvm-project/issues/43459>`_. .. _alpha-nondeterminism-PointerIteration:. alpha.nondeterminism.PointerIteration (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for non-determinism caused by iterating unordered containers of pointers. .. code-block:: c. void test() {; int a = 1, b = 2;; std::unordered_set<int *> UnorderedPtrSet = {&a, &b};. for (auto i : UnorderedPtrSet) // warn; f(i);; }. .. _alpha-nondeterminism-PointerSorting:. alpha.nondeterminism.PointerSorting (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for non-determinism caused by sorting of pointers. .. code-block:: c. void test() {; int a = 1, b = 2;; std::vector<int *> V = {&a, &b};; std::sort(V.begin(), V.end()); // warn; }. alpha.WebKit; ^^^^^^^^^^^^. .. _alpha-webkit-UncountedCallArgsChecker:. alpha.webkit.UncountedCallArgsChecker; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; The goal of this rule is to make sure that lifetime of any dynamically allocated ref-countable object passed as a call argument spans past the end of the call. This applies to call to any function, method, lambda, function pointer or functor. Ref-countable types aren't supposed to be allocated on stack so we check arguments for parameters of raw pointers and references to uncounted types. Here are some examples of situations that we war",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:80696,Testability,test,test,80696,"[] = {1, 2, 3, 4};; int dst[5] = {0};; memcpy(dst, src, 4 * sizeof(int)); // false-positive:; // The 'src' buffer was correctly initialized, yet we cannot conclude; // that since the analyzer could not see a direct initialization of the; // very last byte of the source buffer.; }. More details at the corresponding `GitHub issue <https://github.com/llvm/llvm-project/issues/43459>`_. .. _alpha-nondeterminism-PointerIteration:. alpha.nondeterminism.PointerIteration (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for non-determinism caused by iterating unordered containers of pointers. .. code-block:: c. void test() {; int a = 1, b = 2;; std::unordered_set<int *> UnorderedPtrSet = {&a, &b};. for (auto i : UnorderedPtrSet) // warn; f(i);; }. .. _alpha-nondeterminism-PointerSorting:. alpha.nondeterminism.PointerSorting (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for non-determinism caused by sorting of pointers. .. code-block:: c. void test() {; int a = 1, b = 2;; std::vector<int *> V = {&a, &b};; std::sort(V.begin(), V.end()); // warn; }. alpha.WebKit; ^^^^^^^^^^^^. .. _alpha-webkit-UncountedCallArgsChecker:. alpha.webkit.UncountedCallArgsChecker; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; The goal of this rule is to make sure that lifetime of any dynamically allocated ref-countable object passed as a call argument spans past the end of the call. This applies to call to any function, method, lambda, function pointer or functor. Ref-countable types aren't supposed to be allocated on stack so we check arguments for parameters of raw pointers and references to uncounted types. Here are some examples of situations that we warn about as they *might* be potentially unsafe. The logic is that either we're able to guarantee that an argument is safe or it's considered if not a bug then bug-prone. .. code-block:: cpp. RefCountable* provide_uncounted();; void consume(RefCountable*);. // In these cases we can't make sure callee won't directly or indirectly call `dere",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:81443,Testability,log,logic,81443,"ndeterminism-PointerSorting:. alpha.nondeterminism.PointerSorting (C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for non-determinism caused by sorting of pointers. .. code-block:: c. void test() {; int a = 1, b = 2;; std::vector<int *> V = {&a, &b};; std::sort(V.begin(), V.end()); // warn; }. alpha.WebKit; ^^^^^^^^^^^^. .. _alpha-webkit-UncountedCallArgsChecker:. alpha.webkit.UncountedCallArgsChecker; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; The goal of this rule is to make sure that lifetime of any dynamically allocated ref-countable object passed as a call argument spans past the end of the call. This applies to call to any function, method, lambda, function pointer or functor. Ref-countable types aren't supposed to be allocated on stack so we check arguments for parameters of raw pointers and references to uncounted types. Here are some examples of situations that we warn about as they *might* be potentially unsafe. The logic is that either we're able to guarantee that an argument is safe or it's considered if not a bug then bug-prone. .. code-block:: cpp. RefCountable* provide_uncounted();; void consume(RefCountable*);. // In these cases we can't make sure callee won't directly or indirectly call `deref()` on the argument which could make it unsafe from such point until the end of the call. void foo1() {; consume(provide_uncounted()); // warn; }. void foo2() {; RefCountable* uncounted = provide_uncounted();; consume(uncounted); // warn; }. Although we are enforcing member variables to be ref-counted by `webkit.NoUncountedMemberChecker` any method of the same class still has unrestricted access to these. Since from a caller's perspective we can't guarantee a particular member won't get modified by callee (directly or indirectly) we don't consider values obtained from members safe. Note: It's likely this heuristic could be made more precise with fewer false positives - for example calls to free functions that don't have any parameter other than the pointer ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:85065,Testability,log,logic,85065,"ike ``&`` or ``*``. alpha.webkit.UncountedLocalVarsChecker; """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; The goal of this rule is to make sure that any uncounted local variable is backed by a ref-counted object with lifetime that is strictly larger than the scope of the uncounted local variable. To be on the safe side we require the scope of an uncounted variable to be embedded in the scope of ref-counted object that backs it. These are examples of cases that we consider safe:. .. code-block:: cpp. void foo1() {; RefPtr<RefCountable> counted;; // The scope of uncounted is EMBEDDED in the scope of counted.; {; RefCountable* uncounted = counted.get(); // ok; }; }. void foo2(RefPtr<RefCountable> counted_param) {; RefCountable* uncounted = counted_param.get(); // ok; }. void FooClass::foo_method() {; RefCountable* uncounted = this; // ok; }. Here are some examples of situations that we warn about as they *might* be potentially unsafe. The logic is that either we're able to guarantee that an argument is safe or it's considered if not a bug then bug-prone. .. code-block:: cpp. void foo1() {; RefCountable* uncounted = new RefCountable; // warn; }. RefCountable* global_uncounted;; void foo2() {; RefCountable* uncounted = global_uncounted; // warn; }. void foo3() {; RefPtr<RefCountable> counted;; // The scope of uncounted is not EMBEDDED in the scope of counted.; RefCountable* uncounted = counted.get(); // warn; }. We don't warn about these cases - we don't consider them necessarily safe but since they are very common and usually safe we'd introduce a lot of false positives otherwise:; - variable defined in condition part of an ```if``` statement; - variable defined in init statement condition of a ```for``` statement. For the time being we also don't warn about uninitialized uncounted local variables. Debug Checkers; ---------------. .. _debug-checkers:. debug; ^^^^^. Checkers used for debugging the analyzer.; :doc:`developer-docs/DebugChecks` page contains a detailed descriptio",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:28470,Usability,clear,clear,28470," ``AllowErrnoReadOutsideConditionExpressions`` option allows read of the; errno value if the value is not used in a condition (in ``if`` statements,; loops, conditional expressions, ``switch`` statements). For example ``errno``; can be stored into a variable without getting a warning by the checker. .. code-block:: c. int unsafe_errno_read(int sock, void *data, int data_size) {; if (send(sock, data, data_size, 0) != data_size) {; int err = errno;; // warning if 'AllowErrnoReadOutsideConditionExpressions' is false; // no warning if 'AllowErrnoReadOutsideConditionExpressions' is true; }; return 1;; }. Default value of this option is ``true``. This allows save of the errno value; for possible later error handling. **Limitations**. - Only the very first usage of ``errno`` is checked after an affected function; call. Value of ``errno`` is not followed when it is stored into a variable; or returned from a function.; - Documentation of function ``lseek`` is not clear about what happens if the; function returns different value than the expected file position but not -1.; To avoid possible false-positives ``errno`` is allowed to be used in this; case. .. _unix-Malloc:. unix.Malloc (C); """"""""""""""""""""""""""""""; Check for memory leaks, double free, and use-after-free problems. Traces memory managed by malloc()/free(). .. literalinclude:: checkers/unix_malloc_example.c; :language: c. .. _unix-MallocSizeof:. unix.MallocSizeof (C); """"""""""""""""""""""""""""""""""""""""""; Check for dubious ``malloc`` arguments involving ``sizeof``. .. code-block:: c. void test() {; long *p = malloc(sizeof(short));; // warn: result is converted to 'long *', which is; // incompatible with operand type 'short'; free(p);; }. .. _unix-MismatchedDeallocator:. unix.MismatchedDeallocator (C, C++); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Check for mismatched deallocators. .. literalinclude:: checkers/mismatched_deallocator_example.cpp; :language: c. .. _unix-Vfork:. unix.Vfork (C); """"""""""""""""""""""""""""; Check for proper usage of ``vfork``.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst:77107,Usability,clear,clearerr,77107,"lck1, lck2;. void test() {; if (lck_mtx_try_lock(&lck1) == 0); return;. lck_mtx_lock(&lck2);; lck_mtx_unlock(&lck1);; // warn: this was not the most recently acquired lock; }. .. _alpha-unix-SimpleStream:. alpha.unix.SimpleStream (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""; Check for misuses of stream APIs. Check for misuses of stream APIs: ``fopen, fclose``; (demo checker, the subject of the demo (`Slides <https://llvm.org/devmtg/2012-11/Zaks-Rose-Checker24Hours.pdf>`_ ,; `Video <https://youtu.be/kdxlsP5QVPw>`_) by Anna Zaks and Jordan Rose presented at the; `2012 LLVM Developers' Meeting <https://llvm.org/devmtg/2012-11/>`_). .. code-block:: c. void test() {; FILE *F = fopen(""myfile.txt"", ""w"");; } // warn: opened file is never closed. void test() {; FILE *F = fopen(""myfile.txt"", ""w"");. if (F); fclose(F);. fclose(F); // warn: closing a previously closed file stream; }. .. _alpha-unix-Stream:. alpha.unix.Stream (C); """"""""""""""""""""""""""""""""""""""""""; Check stream handling functions: ``fopen, tmpfile, fclose, fread, fwrite, fseek, ftell, rewind, fgetpos,``; ``fsetpos, clearerr, feof, ferror, fileno``. .. code-block:: c. void test() {; FILE *p = fopen(""foo"", ""r"");; } // warn: opened file is never closed. void test() {; FILE *p = fopen(""foo"", ""r"");; fseek(p, 1, SEEK_SET); // warn: stream pointer might be NULL; fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");. if (p); fseek(p, 1, 3);; // warn: third arg should be SEEK_SET, SEEK_END, or SEEK_CUR. fclose(p);; }. void test() {; FILE *p = fopen(""foo"", ""r"");; fclose(p);; fclose(p); // warn: already closed; }. void test() {; FILE *p = tmpfile();; ftell(p); // warn: stream pointer might be NULL; fclose(p);; }. .. _alpha-unix-cstring-BufferOverlap:. alpha.unix.cstring.BufferOverlap (C); """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Checks for overlap in two buffer arguments. Applies to: ``memcpy, mempcpy, wmemcpy, wmempcpy``. .. code-block:: c. void test() {; int a[4] = {0};; memcpy(a + 2, a + 1, 8); // warn; }. .. _alpha-unix-cstring-NotNullTermina",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/checkers.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/checkers.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:1509,Availability,error,errors,1509,"integrated, it is important to; understand the stages of compilation, to understand how to invoke it. These; stages are:. Driver; The clang executable is actually a small driver which controls the overall; execution of other tools such as the compiler, assembler and linker.; Typically you do not need to interact with the driver, but you; transparently use it to run the other tools. Preprocessing; This stage handles tokenization of the input source file, macro expansion,; #include expansion and handling of other preprocessor directives. The; output of this stage is typically called a "".i"" (for C), "".ii"" (for C++),; "".mi"" (for Objective-C), or "".mii"" (for Objective-C++) file. Parsing and Semantic Analysis; This stage parses the input file, translating preprocessor tokens into a; parse tree. Once in the form of a parse tree, it applies semantic; analysis to compute types for expressions as well and determine whether; the code is well formed. This stage is responsible for generating most of; the compiler warnings as well as parse errors. The output of this stage is; an ""Abstract Syntax Tree"" (AST). Code Generation and Optimization; This stage translates an AST into low-level intermediate code (known as; ""LLVM IR"") and ultimately to machine code. This phase is responsible for; optimizing the generated code and handling target-specific code generation.; The output of this stage is typically called a "".s"" file or ""assembly"" file. Clang also supports the use of an integrated assembler, in which the code; generator produces object files directly. This avoids the overhead of; generating the "".s"" file and of calling the target assembler. Assembler; This stage runs the target assembler to translate the output of the; compiler into a target object file. The output of this stage is typically; called a "".o"" file or ""object"" file. Linker; This stage runs the target linker to merge multiple object files into an; executable or dynamic library. The output of this stage is typically cal",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:12185,Availability,redundant,redundant,12185," Like :option:`-O2` with extra optimizations to reduce code; size. :option:`-Oz` Like :option:`-Os` (and thus :option:`-O2`), but reduces code; size further. :option:`-Og` Like :option:`-O1`. In future versions, this option might; disable different optimizations in order to improve debuggability. :option:`-O` Equivalent to :option:`-O1`. :option:`-O4` and higher. Currently equivalent to :option:`-O3`. .. option:: -g, -gline-tables-only, -gmodules. Control debug information output. Note that Clang debug information works; best at :option:`-O0`. When more than one option starting with `-g` is; specified, the last one wins:. :option:`-g` Generate debug information. :option:`-gline-tables-only` Generate only line table debug information. This; allows for symbolicated backtraces with inlining information, but does not; include any information about variables, their locations or types. :option:`-gmodules` Generate debug information that contains external; references to types defined in Clang modules or precompiled headers instead; of emitting redundant debug type information into every object file. This; option transparently switches the Clang module format to object file; containers that hold the Clang module together with the debug information.; When compiling a program that uses Clang modules or precompiled headers,; this option produces complete debug information with faster compile; times and much smaller object files. This option should not be used when building static libraries for; distribution to other machines because the debug info will contain; references to the module cache on the machine the object files in the; library were built on. .. option:: -fstandalone-debug -fno-standalone-debug. Clang supports a number of optimizations to reduce the size of debug; information in the binary. They work based on the assumption that the; debug type information can be spread out over multiple compilation units.; For instance, Clang will not emit type definitions for types",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:14233,Availability,error,errors,14233,"; Further, Clang will only emit type info for a dynamic C++ class in the; module that contains the vtable for the class. The :option:`-fstandalone-debug` option turns off these optimizations.; This is useful when working with 3rd-party libraries that don't come with; debug information. This is the default on Darwin. Note that Clang will; never emit type information for types that are not referenced at all by the; program. .. option:: -feliminate-unused-debug-types. By default, Clang does not emit type information for types that are defined; but not used in a program. To retain the debug info for these unused types,; the negation **-fno-eliminate-unused-debug-types** can be used. .. option:: -fexceptions. Allow exceptions to be thrown through Clang compiled stack frames (on many; targets, this will enable unwind information for functions that might have; an exception thrown through them). For most targets, this is enabled by; default for C++. .. option:: -ftrapv. Generate code to catch integer overflow errors. Signed integer overflow is; undefined in C. With this flag, extra code is generated to detect this and; abort when it happens. .. option:: -fvisibility. This flag sets the default visibility level. .. option:: -fcommon, -fno-common. This flag specifies that variables without initializers get common linkage.; It can be disabled with :option:`-fno-common`. .. option:: -ftls-model=<model>. Set the default thread-local storage (TLS) model to use for thread-local; variables. Valid values are: ""global-dynamic"", ""local-dynamic"",; ""initial-exec"" and ""local-exec"". The default is ""global-dynamic"". The default; model can be overridden with the tls_model attribute. The compiler will try; to choose a more efficient model if possible. .. option:: -flto, -flto=full, -flto=thin, -emit-llvm. Generate output files in LLVM formats, suitable for link time optimization.; When used with :option:`-S` this generates LLVM intermediate language; assembly files, otherwise this generates ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:16302,Availability,avail,available,16302,"e selection options). The default for :option:`-flto` is ""full"", in which the; LLVM bitcode is suitable for monolithic Link Time Optimization (LTO), where; the linker merges all such modules into a single combined module for; optimization. With ""thin"", :doc:`ThinLTO <../ThinLTO>`; compilation is invoked instead. .. note::. On Darwin, when using :option:`-flto` along with :option:`-g` and; compiling and linking in separate steps, you also need to pass; ``-Wl,-object_path_lto,<lto-filename>.o`` at the linking step to instruct the; ld64 linker not to delete the temporary object file generated during Link; Time Optimization (this flag is automatically passed to the linker by Clang; if compilation and linking are done in a single step). This allows debugging; the executable as well as generating the ``.dSYM`` bundle using :manpage:`dsymutil(1)`. Driver Options; ~~~~~~~~~~~~~~. .. option:: -###. Print (but do not run) the commands to run for this compilation. .. option:: --help. Display available options. .. option:: -Qunused-arguments. Do not emit any warnings for unused driver arguments. .. option:: -Wa,<args>. Pass the comma separated arguments in args to the assembler. .. option:: -Wl,<args>. Pass the comma separated arguments in args to the linker. .. option:: -Wp,<args>. Pass the comma separated arguments in args to the preprocessor. .. option:: -Xanalyzer <arg>. Pass arg to the static analyzer. .. option:: -Xassembler <arg>. Pass arg to the assembler. .. option:: -Xlinker <arg>. Pass arg to the linker. .. option:: -Xpreprocessor <arg>. Pass arg to the preprocessor. .. option:: -o <file>. Write output to file. .. option:: -print-file-name=<file>. Print the full library path of file. .. option:: -print-libgcc-file-name. Print the library path for the currently used compiler runtime library; (""libgcc.a"" or ""libclang_rt.builtins.*.a""). .. option:: -print-prog-name=<name>. Print the full program path of name. .. option:: -print-search-dirs. Print the paths used for findi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:18800,Availability,error,errors,18800,"e feature, the report; goes to stdout in JSON format. Setting ``CC_PRINT_INTERNAL_STAT_FILE`` to a file path makes it report; statistics to the given file in the JSON format. Note that ``-save-stats`` take precedence over ``CC_PRINT_INTERNAL_STAT``; and ``CC_PRINT_INTERNAL_STAT_FILE``. .. option:: -integrated-as, -no-integrated-as. Used to enable and disable, respectively, the use of the integrated; assembler. Whether the integrated assembler is on by default is target; dependent. .. option:: -time. Time individual commands. .. option:: -ftime-report. Print timing summary of each stage of compilation. .. option:: -v. Show commands to run and use verbose output. Diagnostics Options; ~~~~~~~~~~~~~~~~~~~. .. option:: -fshow-column, -fshow-source-location, -fcaret-diagnostics, -fdiagnostics-fixit-info, -fdiagnostics-parseable-fixits, -fdiagnostics-print-source-range-info, -fprint-source-range-info, -fdiagnostics-show-option, -fmessage-length. These options control how Clang prints out information about diagnostics; (errors and warnings). Please see the Clang User's Manual for more information. Preprocessor Options; ~~~~~~~~~~~~~~~~~~~~. .. option:: -D<macroname>=<value>. Adds an implicit #define into the predefines buffer which is read before the; source file is preprocessed. .. option:: -U<macroname>. Adds an implicit #undef into the predefines buffer which is read before the; source file is preprocessed. .. option:: -include <filename>. Adds an implicit #include into the predefines buffer which is read before the; source file is preprocessed. .. option:: -I<directory>. Add the specified directory to the search path for include files. .. option:: -F<directory>. Add the specified directory to the search path for framework include files. .. option:: -nostdinc. Do not search the standard system directories or compiler builtin directories; for include files. .. option:: -nostdlibinc. Do not search the standard system directories for include files, but do; search compiler bu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:467,Deployability,integrat,integrated,467,"clang - the Clang C, C++, and Objective-C compiler; ==================================================. SYNOPSIS; --------. :program:`clang` [*options*] *filename ...*. DESCRIPTION; -----------. :program:`clang` is a C, C++, and Objective-C compiler which encompasses; preprocessing, parsing, optimization, code generation, assembly, and linking.; Depending on which high-level mode setting is passed, Clang will stop before; doing a full link. While Clang is highly integrated, it is important to; understand the stages of compilation, to understand how to invoke it. These; stages are:. Driver; The clang executable is actually a small driver which controls the overall; execution of other tools such as the compiler, assembler and linker.; Typically you do not need to interact with the driver, but you; transparently use it to run the other tools. Preprocessing; This stage handles tokenization of the input source file, macro expansion,; #include expansion and handling of other preprocessor directives. The; output of this stage is typically called a "".i"" (for C), "".ii"" (for C++),; "".mi"" (for Objective-C), or "".mii"" (for Objective-C++) file. Parsing and Semantic Analysis; This stage parses the input file, translating preprocessor tokens into a; parse tree. Once in the form of a parse tree, it applies semantic; analysis to compute types for expressions as well and determine whether; the code is well formed. This stage is responsible for generating most of; the compiler warnings as well as parse errors. The output of this stage is; an ""Abstract Syntax Tree"" (AST). Code Generation and Optimization; This stage translates an AST into low-level intermediate code (known as; ""LLVM IR"") and ultimately to machine code. This phase is responsible for; optimizing the generated code and handling target-specific code generation.; The output of this stage is typically called a "".s"" file or ""assembly"" file. Clang also supports the use of an integrated assembler, in which the code; generator pr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:1948,Deployability,integrat,integrated,1948,"ing of other preprocessor directives. The; output of this stage is typically called a "".i"" (for C), "".ii"" (for C++),; "".mi"" (for Objective-C), or "".mii"" (for Objective-C++) file. Parsing and Semantic Analysis; This stage parses the input file, translating preprocessor tokens into a; parse tree. Once in the form of a parse tree, it applies semantic; analysis to compute types for expressions as well and determine whether; the code is well formed. This stage is responsible for generating most of; the compiler warnings as well as parse errors. The output of this stage is; an ""Abstract Syntax Tree"" (AST). Code Generation and Optimization; This stage translates an AST into low-level intermediate code (known as; ""LLVM IR"") and ultimately to machine code. This phase is responsible for; optimizing the generated code and handling target-specific code generation.; The output of this stage is typically called a "".s"" file or ""assembly"" file. Clang also supports the use of an integrated assembler, in which the code; generator produces object files directly. This avoids the overhead of; generating the "".s"" file and of calling the target assembler. Assembler; This stage runs the target assembler to translate the output of the; compiler into a target object file. The output of this stage is typically; called a "".o"" file or ""object"" file. Linker; This stage runs the target linker to merge multiple object files into an; executable or dynamic library. The output of this stage is typically called; an ""a.out"", "".dylib"" or "".so"" file. :program:`Clang Static Analyzer`. The Clang Static Analyzer is a tool that scans source code to try to find bugs; through code analysis. This tool uses many parts of Clang and is built into; the same driver. Please see <https://clang-analyzer.llvm.org> for more details; on how to use the static analyzer. OPTIONS; -------. Stage Selection Options; ~~~~~~~~~~~~~~~~~~~~~~~. .. option:: -E. Run the preprocessor stage. .. option:: -fsyntax-only. Run the preprocess",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:7414,Deployability,install,installed,7414,"in-<function>. Disable special handling and optimizations for the specific library function.; For example, ``-fno-builtin-strlen`` removes any special handling for the; :c:func:`strlen` library function. .. option:: -fno-builtin-std-<function>. Disable special handling and optimizations for the specific C++ standard; library function in namespace ``std``. For example,; ``-fno-builtin-std-move_if_noexcept`` removes any special handling for the; :cpp:func:`std::move_if_noexcept` library function. For C standard library functions that the C++ standard library also provides; in namespace ``std``, use :option:`-fno-builtin-\<function\>` instead. .. option:: -fmath-errno. Indicate that math functions should be treated as updating :c:data:`errno`. .. option:: -fpascal-strings. Enable support for Pascal-style strings with ""\\pfoo"". .. option:: -fms-extensions. Enable support for Microsoft extensions. .. option:: -fmsc-version=. Set ``_MSC_VER``. When on Windows, this defaults to either the same value as; the currently installed version of cl.exe, or ``1933``. Not set otherwise. .. option:: -fborland-extensions. Enable support for Borland extensions. .. option:: -fwritable-strings. Make all string literals default to writable. This disables uniquing of; strings and other optimizations. .. option:: -flax-vector-conversions, -flax-vector-conversions=<kind>, -fno-lax-vector-conversions. Allow loose type checking rules for implicit vector conversions.; Possible values of <kind>:. - ``none``: allow no implicit conversions between vectors; - ``integer``: allow implicit bitcasts between integer vectors of the same; overall bit-width; - ``all``: allow implicit bitcasts between any vectors of the same; overall bit-width. <kind> defaults to ``integer`` if unspecified. .. option:: -fblocks. Enable the ""Blocks"" language feature. .. option:: -fobjc-abi-version=version. Select the Objective-C ABI version to use. Available versions are 1 (legacy; ""fragile"" ABI), 2 (non-fragile ABI 1), and 3",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:18072,Deployability,integrat,integrated-as,18072,"he currently used compiler runtime library; (""libgcc.a"" or ""libclang_rt.builtins.*.a""). .. option:: -print-prog-name=<name>. Print the full program path of name. .. option:: -print-search-dirs. Print the paths used for finding libraries and programs. .. option:: -save-temps. Save intermediate compilation results. .. option:: -save-stats, -save-stats=cwd, -save-stats=obj. Save internal code generation (LLVM) statistics to a file in the current; directory (:option:`-save-stats`/""-save-stats=cwd"") or the directory; of the output file (""-save-state=obj""). You can also use environment variables to control the statistics reporting.; Setting ``CC_PRINT_INTERNAL_STAT`` to ``1`` enables the feature, the report; goes to stdout in JSON format. Setting ``CC_PRINT_INTERNAL_STAT_FILE`` to a file path makes it report; statistics to the given file in the JSON format. Note that ``-save-stats`` take precedence over ``CC_PRINT_INTERNAL_STAT``; and ``CC_PRINT_INTERNAL_STAT_FILE``. .. option:: -integrated-as, -no-integrated-as. Used to enable and disable, respectively, the use of the integrated; assembler. Whether the integrated assembler is on by default is target; dependent. .. option:: -time. Time individual commands. .. option:: -ftime-report. Print timing summary of each stage of compilation. .. option:: -v. Show commands to run and use verbose output. Diagnostics Options; ~~~~~~~~~~~~~~~~~~~. .. option:: -fshow-column, -fshow-source-location, -fcaret-diagnostics, -fdiagnostics-fixit-info, -fdiagnostics-parseable-fixits, -fdiagnostics-print-source-range-info, -fprint-source-range-info, -fdiagnostics-show-option, -fmessage-length. These options control how Clang prints out information about diagnostics; (errors and warnings). Please see the Clang User's Manual for more information. Preprocessor Options; ~~~~~~~~~~~~~~~~~~~~. .. option:: -D<macroname>=<value>. Adds an implicit #define into the predefines buffer which is read before the; source file is preprocessed. .. option:: -U<mac",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:18091,Deployability,integrat,integrated-as,18091,"he currently used compiler runtime library; (""libgcc.a"" or ""libclang_rt.builtins.*.a""). .. option:: -print-prog-name=<name>. Print the full program path of name. .. option:: -print-search-dirs. Print the paths used for finding libraries and programs. .. option:: -save-temps. Save intermediate compilation results. .. option:: -save-stats, -save-stats=cwd, -save-stats=obj. Save internal code generation (LLVM) statistics to a file in the current; directory (:option:`-save-stats`/""-save-stats=cwd"") or the directory; of the output file (""-save-state=obj""). You can also use environment variables to control the statistics reporting.; Setting ``CC_PRINT_INTERNAL_STAT`` to ``1`` enables the feature, the report; goes to stdout in JSON format. Setting ``CC_PRINT_INTERNAL_STAT_FILE`` to a file path makes it report; statistics to the given file in the JSON format. Note that ``-save-stats`` take precedence over ``CC_PRINT_INTERNAL_STAT``; and ``CC_PRINT_INTERNAL_STAT_FILE``. .. option:: -integrated-as, -no-integrated-as. Used to enable and disable, respectively, the use of the integrated; assembler. Whether the integrated assembler is on by default is target; dependent. .. option:: -time. Time individual commands. .. option:: -ftime-report. Print timing summary of each stage of compilation. .. option:: -v. Show commands to run and use verbose output. Diagnostics Options; ~~~~~~~~~~~~~~~~~~~. .. option:: -fshow-column, -fshow-source-location, -fcaret-diagnostics, -fdiagnostics-fixit-info, -fdiagnostics-parseable-fixits, -fdiagnostics-print-source-range-info, -fprint-source-range-info, -fdiagnostics-show-option, -fmessage-length. These options control how Clang prints out information about diagnostics; (errors and warnings). Please see the Clang User's Manual for more information. Preprocessor Options; ~~~~~~~~~~~~~~~~~~~~. .. option:: -D<macroname>=<value>. Adds an implicit #define into the predefines buffer which is read before the; source file is preprocessed. .. option:: -U<mac",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:18163,Deployability,integrat,integrated,18163,"bclang_rt.builtins.*.a""). .. option:: -print-prog-name=<name>. Print the full program path of name. .. option:: -print-search-dirs. Print the paths used for finding libraries and programs. .. option:: -save-temps. Save intermediate compilation results. .. option:: -save-stats, -save-stats=cwd, -save-stats=obj. Save internal code generation (LLVM) statistics to a file in the current; directory (:option:`-save-stats`/""-save-stats=cwd"") or the directory; of the output file (""-save-state=obj""). You can also use environment variables to control the statistics reporting.; Setting ``CC_PRINT_INTERNAL_STAT`` to ``1`` enables the feature, the report; goes to stdout in JSON format. Setting ``CC_PRINT_INTERNAL_STAT_FILE`` to a file path makes it report; statistics to the given file in the JSON format. Note that ``-save-stats`` take precedence over ``CC_PRINT_INTERNAL_STAT``; and ``CC_PRINT_INTERNAL_STAT_FILE``. .. option:: -integrated-as, -no-integrated-as. Used to enable and disable, respectively, the use of the integrated; assembler. Whether the integrated assembler is on by default is target; dependent. .. option:: -time. Time individual commands. .. option:: -ftime-report. Print timing summary of each stage of compilation. .. option:: -v. Show commands to run and use verbose output. Diagnostics Options; ~~~~~~~~~~~~~~~~~~~. .. option:: -fshow-column, -fshow-source-location, -fcaret-diagnostics, -fdiagnostics-fixit-info, -fdiagnostics-parseable-fixits, -fdiagnostics-print-source-range-info, -fprint-source-range-info, -fdiagnostics-show-option, -fmessage-length. These options control how Clang prints out information about diagnostics; (errors and warnings). Please see the Clang User's Manual for more information. Preprocessor Options; ~~~~~~~~~~~~~~~~~~~~. .. option:: -D<macroname>=<value>. Adds an implicit #define into the predefines buffer which is read before the; source file is preprocessed. .. option:: -U<macroname>. Adds an implicit #undef into the predefines buffer wh",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:18198,Deployability,integrat,integrated,18198,"l program path of name. .. option:: -print-search-dirs. Print the paths used for finding libraries and programs. .. option:: -save-temps. Save intermediate compilation results. .. option:: -save-stats, -save-stats=cwd, -save-stats=obj. Save internal code generation (LLVM) statistics to a file in the current; directory (:option:`-save-stats`/""-save-stats=cwd"") or the directory; of the output file (""-save-state=obj""). You can also use environment variables to control the statistics reporting.; Setting ``CC_PRINT_INTERNAL_STAT`` to ``1`` enables the feature, the report; goes to stdout in JSON format. Setting ``CC_PRINT_INTERNAL_STAT_FILE`` to a file path makes it report; statistics to the given file in the JSON format. Note that ``-save-stats`` take precedence over ``CC_PRINT_INTERNAL_STAT``; and ``CC_PRINT_INTERNAL_STAT_FILE``. .. option:: -integrated-as, -no-integrated-as. Used to enable and disable, respectively, the use of the integrated; assembler. Whether the integrated assembler is on by default is target; dependent. .. option:: -time. Time individual commands. .. option:: -ftime-report. Print timing summary of each stage of compilation. .. option:: -v. Show commands to run and use verbose output. Diagnostics Options; ~~~~~~~~~~~~~~~~~~~. .. option:: -fshow-column, -fshow-source-location, -fcaret-diagnostics, -fdiagnostics-fixit-info, -fdiagnostics-parseable-fixits, -fdiagnostics-print-source-range-info, -fprint-source-range-info, -fdiagnostics-show-option, -fmessage-length. These options control how Clang prints out information about diagnostics; (errors and warnings). Please see the Clang User's Manual for more information. Preprocessor Options; ~~~~~~~~~~~~~~~~~~~~. .. option:: -D<macroname>=<value>. Adds an implicit #define into the predefines buffer which is read before the; source file is preprocessed. .. option:: -U<macroname>. Adds an implicit #undef into the predefines buffer which is read before the; source file is preprocessed. .. option:: -include <f",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:21553,Deployability,deploy,deployment,21553,"y the preprocessed content of; ""system"" headers to the output; instead, preserve the #include directive.; This can greatly reduce the volume of text produced by :option:`-E` which; can be helpful when trying to produce a ""small"" reproduceable test case. This option does not guarantee reproduceability, however. If the including; source defines preprocessor symbols that influence the behavior of system; headers (for example, ``_XOPEN_SOURCE``) the operation of :option:`-E` will; remove that definition and thus can change the semantics of the included; header. Also, using a different version of the system headers (especially a; different version of the STL) may result in different behavior. Always verify; the preprocessed file by compiling it separately. ENVIRONMENT; -----------. .. envvar:: TMPDIR, TEMP, TMP. These environment variables are checked, in order, for the location to write; temporary files used during the compilation process. .. envvar:: CPATH. If this environment variable is present, it is treated as a delimited list of; paths to be added to the default system include path list. The delimiter is; the platform dependent delimiter, as used in the PATH environment variable. Empty components in the environment variable are ignored. .. envvar:: C_INCLUDE_PATH, OBJC_INCLUDE_PATH, CPLUS_INCLUDE_PATH, OBJCPLUS_INCLUDE_PATH. These environment variables specify additional paths, as for :envvar:`CPATH`, which are; only used when processing the appropriate language. .. envvar:: MACOSX_DEPLOYMENT_TARGET. If :option:`-mmacosx-version-min` is unspecified, the default deployment; target is read from this environment variable. This option only affects; Darwin targets. BUGS; ----. To report bugs, please visit <https://github.com/llvm/llvm-project/issues/>. Most bug reports should; include preprocessed source files (use the :option:`-E` option) and the full; output of the compiler, along with information to reproduce. SEE ALSO; --------. :manpage:`as(1)`, :manpage:`ld(1)`; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:6182,Energy Efficiency,efficient,efficient,6182,"alues for the OpenCL language are:. | ``cl1.0``. OpenCL 1.0. | ``cl1.1``. OpenCL 1.1. | ``cl1.2``. OpenCL 1.2. | ``cl2.0``. OpenCL 2.0. The default OpenCL language standard is ``cl1.0``. Supported values for the CUDA language are:. | ``cuda``. NVIDIA CUDA(tm). .. option:: -stdlib=<library>. Specify the C++ standard library to use; supported options are libstdc++ and; libc++. If not specified, platform default will be used. .. option:: -rtlib=<library>. Specify the compiler runtime library to use; supported options are libgcc and; compiler-rt. If not specified, platform default will be used. .. option:: -ansi. Same as -std=c89. .. option:: -ObjC, -ObjC++. Treat source input files as Objective-C and Object-C++ inputs respectively. .. option:: -trigraphs. Enable trigraphs. .. option:: -ffreestanding. Indicate that the file should be compiled for a freestanding, not a hosted,; environment. Note that it is assumed that a freestanding environment will; additionally provide `memcpy`, `memmove`, `memset` and `memcmp`; implementations, as these are needed for efficient codegen for many programs. .. option:: -fno-builtin. Disable special handling and optimizations of well-known library functions,; like :c:func:`strlen` and :c:func:`malloc`. .. option:: -fno-builtin-<function>. Disable special handling and optimizations for the specific library function.; For example, ``-fno-builtin-strlen`` removes any special handling for the; :c:func:`strlen` library function. .. option:: -fno-builtin-std-<function>. Disable special handling and optimizations for the specific C++ standard; library function in namespace ``std``. For example,; ``-fno-builtin-std-move_if_noexcept`` removes any special handling for the; :cpp:func:`std::move_if_noexcept` library function. For C standard library functions that the C++ standard library also provides; in namespace ``std``, use :option:`-fno-builtin-\<function\>` instead. .. option:: -fmath-errno. Indicate that math functions should be treated as upd",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:11180,Energy Efficiency,reduce,reduce,11180,"member and later. For example, if you specify -march=i486, the compiler is; allowed to generate instructions that are valid on i486 and later processors,; but which may not exist on earlier ones. Code Generation Options; ~~~~~~~~~~~~~~~~~~~~~~~. .. option:: -O0, -O1, -O2, -O3, -Ofast, -Os, -Oz, -Og, -O, -O4. Specify which optimization level to use:. :option:`-O0` Means ""no optimization"": this level compiles the fastest and; generates the most debuggable code. :option:`-O1` Somewhere between :option:`-O0` and :option:`-O2`. :option:`-O2` Moderate level of optimization which enables most; optimizations. :option:`-O3` Like :option:`-O2`, except that it enables optimizations that; take longer to perform or that may generate larger code (in an attempt to; make the program run faster). :option:`-Ofast` Enables all the optimizations from :option:`-O3` along; with other aggressive optimizations that may violate strict compliance with; language standards. :option:`-Os` Like :option:`-O2` with extra optimizations to reduce code; size. :option:`-Oz` Like :option:`-Os` (and thus :option:`-O2`), but reduces code; size further. :option:`-Og` Like :option:`-O1`. In future versions, this option might; disable different optimizations in order to improve debuggability. :option:`-O` Equivalent to :option:`-O1`. :option:`-O4` and higher. Currently equivalent to :option:`-O3`. .. option:: -g, -gline-tables-only, -gmodules. Control debug information output. Note that Clang debug information works; best at :option:`-O0`. When more than one option starting with `-g` is; specified, the last one wins:. :option:`-g` Generate debug information. :option:`-gline-tables-only` Generate only line table debug information. This; allows for symbolicated backtraces with inlining information, but does not; include any information about variables, their locations or types. :option:`-gmodules` Generate debug information that contains external; references to types defined in Clang modules or precompiled he",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:11262,Energy Efficiency,reduce,reduces,11262,"o generate instructions that are valid on i486 and later processors,; but which may not exist on earlier ones. Code Generation Options; ~~~~~~~~~~~~~~~~~~~~~~~. .. option:: -O0, -O1, -O2, -O3, -Ofast, -Os, -Oz, -Og, -O, -O4. Specify which optimization level to use:. :option:`-O0` Means ""no optimization"": this level compiles the fastest and; generates the most debuggable code. :option:`-O1` Somewhere between :option:`-O0` and :option:`-O2`. :option:`-O2` Moderate level of optimization which enables most; optimizations. :option:`-O3` Like :option:`-O2`, except that it enables optimizations that; take longer to perform or that may generate larger code (in an attempt to; make the program run faster). :option:`-Ofast` Enables all the optimizations from :option:`-O3` along; with other aggressive optimizations that may violate strict compliance with; language standards. :option:`-Os` Like :option:`-O2` with extra optimizations to reduce code; size. :option:`-Oz` Like :option:`-Os` (and thus :option:`-O2`), but reduces code; size further. :option:`-Og` Like :option:`-O1`. In future versions, this option might; disable different optimizations in order to improve debuggability. :option:`-O` Equivalent to :option:`-O1`. :option:`-O4` and higher. Currently equivalent to :option:`-O3`. .. option:: -g, -gline-tables-only, -gmodules. Control debug information output. Note that Clang debug information works; best at :option:`-O0`. When more than one option starting with `-g` is; specified, the last one wins:. :option:`-g` Generate debug information. :option:`-gline-tables-only` Generate only line table debug information. This; allows for symbolicated backtraces with inlining information, but does not; include any information about variables, their locations or types. :option:`-gmodules` Generate debug information that contains external; references to types defined in Clang modules or precompiled headers instead; of emitting redundant debug type information into every object file. Th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:12901,Energy Efficiency,reduce,reduce,12901,"d backtraces with inlining information, but does not; include any information about variables, their locations or types. :option:`-gmodules` Generate debug information that contains external; references to types defined in Clang modules or precompiled headers instead; of emitting redundant debug type information into every object file. This; option transparently switches the Clang module format to object file; containers that hold the Clang module together with the debug information.; When compiling a program that uses Clang modules or precompiled headers,; this option produces complete debug information with faster compile; times and much smaller object files. This option should not be used when building static libraries for; distribution to other machines because the debug info will contain; references to the module cache on the machine the object files in the; library were built on. .. option:: -fstandalone-debug -fno-standalone-debug. Clang supports a number of optimizations to reduce the size of debug; information in the binary. They work based on the assumption that the; debug type information can be spread out over multiple compilation units.; For instance, Clang will not emit type definitions for types that are not; needed by a module and could be replaced with a forward declaration.; Further, Clang will only emit type info for a dynamic C++ class in the; module that contains the vtable for the class. The :option:`-fstandalone-debug` option turns off these optimizations.; This is useful when working with 3rd-party libraries that don't come with; debug information. This is the default on Darwin. Note that Clang will; never emit type information for types that are not referenced at all by the; program. .. option:: -feliminate-unused-debug-types. By default, Clang does not emit type information for types that are defined; but not used in a program. To retain the debug info for these unused types,; the negation **-fno-eliminate-unused-debug-types** can be used. .",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:14943,Energy Efficiency,efficient,efficient,14943,"exceptions to be thrown through Clang compiled stack frames (on many; targets, this will enable unwind information for functions that might have; an exception thrown through them). For most targets, this is enabled by; default for C++. .. option:: -ftrapv. Generate code to catch integer overflow errors. Signed integer overflow is; undefined in C. With this flag, extra code is generated to detect this and; abort when it happens. .. option:: -fvisibility. This flag sets the default visibility level. .. option:: -fcommon, -fno-common. This flag specifies that variables without initializers get common linkage.; It can be disabled with :option:`-fno-common`. .. option:: -ftls-model=<model>. Set the default thread-local storage (TLS) model to use for thread-local; variables. Valid values are: ""global-dynamic"", ""local-dynamic"",; ""initial-exec"" and ""local-exec"". The default is ""global-dynamic"". The default; model can be overridden with the tls_model attribute. The compiler will try; to choose a more efficient model if possible. .. option:: -flto, -flto=full, -flto=thin, -emit-llvm. Generate output files in LLVM formats, suitable for link time optimization.; When used with :option:`-S` this generates LLVM intermediate language; assembly files, otherwise this generates LLVM bitcode format object files; (which may be passed to the linker depending on the stage selection options). The default for :option:`-flto` is ""full"", in which the; LLVM bitcode is suitable for monolithic Link Time Optimization (LTO), where; the linker merges all such modules into a single combined module for; optimization. With ""thin"", :doc:`ThinLTO <../ThinLTO>`; compilation is invoked instead. .. note::. On Darwin, when using :option:`-flto` along with :option:`-g` and; compiling and linking in separate steps, you also need to pass; ``-Wl,-object_path_lto,<lto-filename>.o`` at the linking step to instruct the; ld64 linker not to delete the temporary object file generated during Link; Time Optimization (th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:20086,Energy Efficiency,reduce,reduce,20086,"r which is read before the; source file is preprocessed. .. option:: -include <filename>. Adds an implicit #include into the predefines buffer which is read before the; source file is preprocessed. .. option:: -I<directory>. Add the specified directory to the search path for include files. .. option:: -F<directory>. Add the specified directory to the search path for framework include files. .. option:: -nostdinc. Do not search the standard system directories or compiler builtin directories; for include files. .. option:: -nostdlibinc. Do not search the standard system directories for include files, but do; search compiler builtin include directories. .. option:: -nobuiltininc. Do not search clang's builtin directory for include files. .. option:: -fkeep-system-includes. Usable only with :option:`-E`. Do not copy the preprocessed content of; ""system"" headers to the output; instead, preserve the #include directive.; This can greatly reduce the volume of text produced by :option:`-E` which; can be helpful when trying to produce a ""small"" reproduceable test case. This option does not guarantee reproduceability, however. If the including; source defines preprocessor symbols that influence the behavior of system; headers (for example, ``_XOPEN_SOURCE``) the operation of :option:`-E` will; remove that definition and thus can change the semantics of the included; header. Also, using a different version of the system headers (especially a; different version of the STL) may result in different behavior. Always verify; the preprocessed file by compiling it separately. ENVIRONMENT; -----------. .. envvar:: TMPDIR, TEMP, TMP. These environment variables are checked, in order, for the location to write; temporary files used during the compilation process. .. envvar:: CPATH. If this environment variable is present, it is treated as a delimited list of; paths to be added to the default system include path list. The delimiter is; the platform dependent delimiter, as used in the PATH ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:467,Integrability,integrat,integrated,467,"clang - the Clang C, C++, and Objective-C compiler; ==================================================. SYNOPSIS; --------. :program:`clang` [*options*] *filename ...*. DESCRIPTION; -----------. :program:`clang` is a C, C++, and Objective-C compiler which encompasses; preprocessing, parsing, optimization, code generation, assembly, and linking.; Depending on which high-level mode setting is passed, Clang will stop before; doing a full link. While Clang is highly integrated, it is important to; understand the stages of compilation, to understand how to invoke it. These; stages are:. Driver; The clang executable is actually a small driver which controls the overall; execution of other tools such as the compiler, assembler and linker.; Typically you do not need to interact with the driver, but you; transparently use it to run the other tools. Preprocessing; This stage handles tokenization of the input source file, macro expansion,; #include expansion and handling of other preprocessor directives. The; output of this stage is typically called a "".i"" (for C), "".ii"" (for C++),; "".mi"" (for Objective-C), or "".mii"" (for Objective-C++) file. Parsing and Semantic Analysis; This stage parses the input file, translating preprocessor tokens into a; parse tree. Once in the form of a parse tree, it applies semantic; analysis to compute types for expressions as well and determine whether; the code is well formed. This stage is responsible for generating most of; the compiler warnings as well as parse errors. The output of this stage is; an ""Abstract Syntax Tree"" (AST). Code Generation and Optimization; This stage translates an AST into low-level intermediate code (known as; ""LLVM IR"") and ultimately to machine code. This phase is responsible for; optimizing the generated code and handling target-specific code generation.; The output of this stage is typically called a "".s"" file or ""assembly"" file. Clang also supports the use of an integrated assembler, in which the code; generator pr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:1948,Integrability,integrat,integrated,1948,"ing of other preprocessor directives. The; output of this stage is typically called a "".i"" (for C), "".ii"" (for C++),; "".mi"" (for Objective-C), or "".mii"" (for Objective-C++) file. Parsing and Semantic Analysis; This stage parses the input file, translating preprocessor tokens into a; parse tree. Once in the form of a parse tree, it applies semantic; analysis to compute types for expressions as well and determine whether; the code is well formed. This stage is responsible for generating most of; the compiler warnings as well as parse errors. The output of this stage is; an ""Abstract Syntax Tree"" (AST). Code Generation and Optimization; This stage translates an AST into low-level intermediate code (known as; ""LLVM IR"") and ultimately to machine code. This phase is responsible for; optimizing the generated code and handling target-specific code generation.; The output of this stage is typically called a "".s"" file or ""assembly"" file. Clang also supports the use of an integrated assembler, in which the code; generator produces object files directly. This avoids the overhead of; generating the "".s"" file and of calling the target assembler. Assembler; This stage runs the target assembler to translate the output of the; compiler into a target object file. The output of this stage is typically; called a "".o"" file or ""object"" file. Linker; This stage runs the target linker to merge multiple object files into an; executable or dynamic library. The output of this stage is typically called; an ""a.out"", "".dylib"" or "".so"" file. :program:`Clang Static Analyzer`. The Clang Static Analyzer is a tool that scans source code to try to find bugs; through code analysis. This tool uses many parts of Clang and is built into; the same driver. Please see <https://clang-analyzer.llvm.org> for more details; on how to use the static analyzer. OPTIONS; -------. Stage Selection Options; ~~~~~~~~~~~~~~~~~~~~~~~. .. option:: -E. Run the preprocessor stage. .. option:: -fsyntax-only. Run the preprocess",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:15285,Integrability,depend,depending,15285,"h integer overflow errors. Signed integer overflow is; undefined in C. With this flag, extra code is generated to detect this and; abort when it happens. .. option:: -fvisibility. This flag sets the default visibility level. .. option:: -fcommon, -fno-common. This flag specifies that variables without initializers get common linkage.; It can be disabled with :option:`-fno-common`. .. option:: -ftls-model=<model>. Set the default thread-local storage (TLS) model to use for thread-local; variables. Valid values are: ""global-dynamic"", ""local-dynamic"",; ""initial-exec"" and ""local-exec"". The default is ""global-dynamic"". The default; model can be overridden with the tls_model attribute. The compiler will try; to choose a more efficient model if possible. .. option:: -flto, -flto=full, -flto=thin, -emit-llvm. Generate output files in LLVM formats, suitable for link time optimization.; When used with :option:`-S` this generates LLVM intermediate language; assembly files, otherwise this generates LLVM bitcode format object files; (which may be passed to the linker depending on the stage selection options). The default for :option:`-flto` is ""full"", in which the; LLVM bitcode is suitable for monolithic Link Time Optimization (LTO), where; the linker merges all such modules into a single combined module for; optimization. With ""thin"", :doc:`ThinLTO <../ThinLTO>`; compilation is invoked instead. .. note::. On Darwin, when using :option:`-flto` along with :option:`-g` and; compiling and linking in separate steps, you also need to pass; ``-Wl,-object_path_lto,<lto-filename>.o`` at the linking step to instruct the; ld64 linker not to delete the temporary object file generated during Link; Time Optimization (this flag is automatically passed to the linker by Clang; if compilation and linking are done in a single step). This allows debugging; the executable as well as generating the ``.dSYM`` bundle using :manpage:`dsymutil(1)`. Driver Options; ~~~~~~~~~~~~~~. .. option:: -###. Print ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:18072,Integrability,integrat,integrated-as,18072,"he currently used compiler runtime library; (""libgcc.a"" or ""libclang_rt.builtins.*.a""). .. option:: -print-prog-name=<name>. Print the full program path of name. .. option:: -print-search-dirs. Print the paths used for finding libraries and programs. .. option:: -save-temps. Save intermediate compilation results. .. option:: -save-stats, -save-stats=cwd, -save-stats=obj. Save internal code generation (LLVM) statistics to a file in the current; directory (:option:`-save-stats`/""-save-stats=cwd"") or the directory; of the output file (""-save-state=obj""). You can also use environment variables to control the statistics reporting.; Setting ``CC_PRINT_INTERNAL_STAT`` to ``1`` enables the feature, the report; goes to stdout in JSON format. Setting ``CC_PRINT_INTERNAL_STAT_FILE`` to a file path makes it report; statistics to the given file in the JSON format. Note that ``-save-stats`` take precedence over ``CC_PRINT_INTERNAL_STAT``; and ``CC_PRINT_INTERNAL_STAT_FILE``. .. option:: -integrated-as, -no-integrated-as. Used to enable and disable, respectively, the use of the integrated; assembler. Whether the integrated assembler is on by default is target; dependent. .. option:: -time. Time individual commands. .. option:: -ftime-report. Print timing summary of each stage of compilation. .. option:: -v. Show commands to run and use verbose output. Diagnostics Options; ~~~~~~~~~~~~~~~~~~~. .. option:: -fshow-column, -fshow-source-location, -fcaret-diagnostics, -fdiagnostics-fixit-info, -fdiagnostics-parseable-fixits, -fdiagnostics-print-source-range-info, -fprint-source-range-info, -fdiagnostics-show-option, -fmessage-length. These options control how Clang prints out information about diagnostics; (errors and warnings). Please see the Clang User's Manual for more information. Preprocessor Options; ~~~~~~~~~~~~~~~~~~~~. .. option:: -D<macroname>=<value>. Adds an implicit #define into the predefines buffer which is read before the; source file is preprocessed. .. option:: -U<mac",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:18091,Integrability,integrat,integrated-as,18091,"he currently used compiler runtime library; (""libgcc.a"" or ""libclang_rt.builtins.*.a""). .. option:: -print-prog-name=<name>. Print the full program path of name. .. option:: -print-search-dirs. Print the paths used for finding libraries and programs. .. option:: -save-temps. Save intermediate compilation results. .. option:: -save-stats, -save-stats=cwd, -save-stats=obj. Save internal code generation (LLVM) statistics to a file in the current; directory (:option:`-save-stats`/""-save-stats=cwd"") or the directory; of the output file (""-save-state=obj""). You can also use environment variables to control the statistics reporting.; Setting ``CC_PRINT_INTERNAL_STAT`` to ``1`` enables the feature, the report; goes to stdout in JSON format. Setting ``CC_PRINT_INTERNAL_STAT_FILE`` to a file path makes it report; statistics to the given file in the JSON format. Note that ``-save-stats`` take precedence over ``CC_PRINT_INTERNAL_STAT``; and ``CC_PRINT_INTERNAL_STAT_FILE``. .. option:: -integrated-as, -no-integrated-as. Used to enable and disable, respectively, the use of the integrated; assembler. Whether the integrated assembler is on by default is target; dependent. .. option:: -time. Time individual commands. .. option:: -ftime-report. Print timing summary of each stage of compilation. .. option:: -v. Show commands to run and use verbose output. Diagnostics Options; ~~~~~~~~~~~~~~~~~~~. .. option:: -fshow-column, -fshow-source-location, -fcaret-diagnostics, -fdiagnostics-fixit-info, -fdiagnostics-parseable-fixits, -fdiagnostics-print-source-range-info, -fprint-source-range-info, -fdiagnostics-show-option, -fmessage-length. These options control how Clang prints out information about diagnostics; (errors and warnings). Please see the Clang User's Manual for more information. Preprocessor Options; ~~~~~~~~~~~~~~~~~~~~. .. option:: -D<macroname>=<value>. Adds an implicit #define into the predefines buffer which is read before the; source file is preprocessed. .. option:: -U<mac",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:18163,Integrability,integrat,integrated,18163,"bclang_rt.builtins.*.a""). .. option:: -print-prog-name=<name>. Print the full program path of name. .. option:: -print-search-dirs. Print the paths used for finding libraries and programs. .. option:: -save-temps. Save intermediate compilation results. .. option:: -save-stats, -save-stats=cwd, -save-stats=obj. Save internal code generation (LLVM) statistics to a file in the current; directory (:option:`-save-stats`/""-save-stats=cwd"") or the directory; of the output file (""-save-state=obj""). You can also use environment variables to control the statistics reporting.; Setting ``CC_PRINT_INTERNAL_STAT`` to ``1`` enables the feature, the report; goes to stdout in JSON format. Setting ``CC_PRINT_INTERNAL_STAT_FILE`` to a file path makes it report; statistics to the given file in the JSON format. Note that ``-save-stats`` take precedence over ``CC_PRINT_INTERNAL_STAT``; and ``CC_PRINT_INTERNAL_STAT_FILE``. .. option:: -integrated-as, -no-integrated-as. Used to enable and disable, respectively, the use of the integrated; assembler. Whether the integrated assembler is on by default is target; dependent. .. option:: -time. Time individual commands. .. option:: -ftime-report. Print timing summary of each stage of compilation. .. option:: -v. Show commands to run and use verbose output. Diagnostics Options; ~~~~~~~~~~~~~~~~~~~. .. option:: -fshow-column, -fshow-source-location, -fcaret-diagnostics, -fdiagnostics-fixit-info, -fdiagnostics-parseable-fixits, -fdiagnostics-print-source-range-info, -fprint-source-range-info, -fdiagnostics-show-option, -fmessage-length. These options control how Clang prints out information about diagnostics; (errors and warnings). Please see the Clang User's Manual for more information. Preprocessor Options; ~~~~~~~~~~~~~~~~~~~~. .. option:: -D<macroname>=<value>. Adds an implicit #define into the predefines buffer which is read before the; source file is preprocessed. .. option:: -U<macroname>. Adds an implicit #undef into the predefines buffer wh",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:18198,Integrability,integrat,integrated,18198,"l program path of name. .. option:: -print-search-dirs. Print the paths used for finding libraries and programs. .. option:: -save-temps. Save intermediate compilation results. .. option:: -save-stats, -save-stats=cwd, -save-stats=obj. Save internal code generation (LLVM) statistics to a file in the current; directory (:option:`-save-stats`/""-save-stats=cwd"") or the directory; of the output file (""-save-state=obj""). You can also use environment variables to control the statistics reporting.; Setting ``CC_PRINT_INTERNAL_STAT`` to ``1`` enables the feature, the report; goes to stdout in JSON format. Setting ``CC_PRINT_INTERNAL_STAT_FILE`` to a file path makes it report; statistics to the given file in the JSON format. Note that ``-save-stats`` take precedence over ``CC_PRINT_INTERNAL_STAT``; and ``CC_PRINT_INTERNAL_STAT_FILE``. .. option:: -integrated-as, -no-integrated-as. Used to enable and disable, respectively, the use of the integrated; assembler. Whether the integrated assembler is on by default is target; dependent. .. option:: -time. Time individual commands. .. option:: -ftime-report. Print timing summary of each stage of compilation. .. option:: -v. Show commands to run and use verbose output. Diagnostics Options; ~~~~~~~~~~~~~~~~~~~. .. option:: -fshow-column, -fshow-source-location, -fcaret-diagnostics, -fdiagnostics-fixit-info, -fdiagnostics-parseable-fixits, -fdiagnostics-print-source-range-info, -fprint-source-range-info, -fdiagnostics-show-option, -fmessage-length. These options control how Clang prints out information about diagnostics; (errors and warnings). Please see the Clang User's Manual for more information. Preprocessor Options; ~~~~~~~~~~~~~~~~~~~~. .. option:: -D<macroname>=<value>. Adds an implicit #define into the predefines buffer which is read before the; source file is preprocessed. .. option:: -U<macroname>. Adds an implicit #undef into the predefines buffer which is read before the; source file is preprocessed. .. option:: -include <f",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:18247,Integrability,depend,dependent,18247,"l program path of name. .. option:: -print-search-dirs. Print the paths used for finding libraries and programs. .. option:: -save-temps. Save intermediate compilation results. .. option:: -save-stats, -save-stats=cwd, -save-stats=obj. Save internal code generation (LLVM) statistics to a file in the current; directory (:option:`-save-stats`/""-save-stats=cwd"") or the directory; of the output file (""-save-state=obj""). You can also use environment variables to control the statistics reporting.; Setting ``CC_PRINT_INTERNAL_STAT`` to ``1`` enables the feature, the report; goes to stdout in JSON format. Setting ``CC_PRINT_INTERNAL_STAT_FILE`` to a file path makes it report; statistics to the given file in the JSON format. Note that ``-save-stats`` take precedence over ``CC_PRINT_INTERNAL_STAT``; and ``CC_PRINT_INTERNAL_STAT_FILE``. .. option:: -integrated-as, -no-integrated-as. Used to enable and disable, respectively, the use of the integrated; assembler. Whether the integrated assembler is on by default is target; dependent. .. option:: -time. Time individual commands. .. option:: -ftime-report. Print timing summary of each stage of compilation. .. option:: -v. Show commands to run and use verbose output. Diagnostics Options; ~~~~~~~~~~~~~~~~~~~. .. option:: -fshow-column, -fshow-source-location, -fcaret-diagnostics, -fdiagnostics-fixit-info, -fdiagnostics-parseable-fixits, -fdiagnostics-print-source-range-info, -fprint-source-range-info, -fdiagnostics-show-option, -fmessage-length. These options control how Clang prints out information about diagnostics; (errors and warnings). Please see the Clang User's Manual for more information. Preprocessor Options; ~~~~~~~~~~~~~~~~~~~~. .. option:: -D<macroname>=<value>. Adds an implicit #define into the predefines buffer which is read before the; source file is preprocessed. .. option:: -U<macroname>. Adds an implicit #undef into the predefines buffer which is read before the; source file is preprocessed. .. option:: -include <f",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:21101,Integrability,depend,dependent,21101,"y the preprocessed content of; ""system"" headers to the output; instead, preserve the #include directive.; This can greatly reduce the volume of text produced by :option:`-E` which; can be helpful when trying to produce a ""small"" reproduceable test case. This option does not guarantee reproduceability, however. If the including; source defines preprocessor symbols that influence the behavior of system; headers (for example, ``_XOPEN_SOURCE``) the operation of :option:`-E` will; remove that definition and thus can change the semantics of the included; header. Also, using a different version of the system headers (especially a; different version of the STL) may result in different behavior. Always verify; the preprocessed file by compiling it separately. ENVIRONMENT; -----------. .. envvar:: TMPDIR, TEMP, TMP. These environment variables are checked, in order, for the location to write; temporary files used during the compilation process. .. envvar:: CPATH. If this environment variable is present, it is treated as a delimited list of; paths to be added to the default system include path list. The delimiter is; the platform dependent delimiter, as used in the PATH environment variable. Empty components in the environment variable are ignored. .. envvar:: C_INCLUDE_PATH, OBJC_INCLUDE_PATH, CPLUS_INCLUDE_PATH, OBJCPLUS_INCLUDE_PATH. These environment variables specify additional paths, as for :envvar:`CPATH`, which are; only used when processing the appropriate language. .. envvar:: MACOSX_DEPLOYMENT_TARGET. If :option:`-mmacosx-version-min` is unspecified, the default deployment; target is read from this environment variable. This option only affects; Darwin targets. BUGS; ----. To report bugs, please visit <https://github.com/llvm/llvm-project/issues/>. Most bug reports should; include preprocessed source files (use the :option:`-E` option) and the full; output of the compiler, along with information to reproduce. SEE ALSO; --------. :manpage:`as(1)`, :manpage:`ld(1)`; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:9086,Modifiability,config,configured,9086,"idth. <kind> defaults to ``integer`` if unspecified. .. option:: -fblocks. Enable the ""Blocks"" language feature. .. option:: -fobjc-abi-version=version. Select the Objective-C ABI version to use. Available versions are 1 (legacy; ""fragile"" ABI), 2 (non-fragile ABI 1), and 3 (non-fragile ABI 2). .. option:: -fobjc-nonfragile-abi-version=<version>. Select the Objective-C non-fragile ABI version to use by default. This will; only be used as the Objective-C ABI when the non-fragile ABI is enabled; (either via :option:`-fobjc-nonfragile-abi`, or because it is the platform; default). .. option:: -fobjc-nonfragile-abi, -fno-objc-nonfragile-abi. Enable use of the Objective-C non-fragile ABI. On platforms for which this is; the default ABI, it can be disabled with :option:`-fno-objc-nonfragile-abi`. Target Selection Options; ~~~~~~~~~~~~~~~~~~~~~~~~. Clang fully supports cross compilation as an inherent part of its design.; Depending on how your version of Clang is configured, it may have support for a; number of cross compilers, or may only support a native target. .. option:: -arch <architecture>. Specify the architecture to build for (Mac OS X specific). .. option:: -target <architecture>. Specify the architecture to build for (all platforms). .. option:: -mmacosx-version-min=<version>. When building for macOS, specify the minimum version supported by your; application. .. option:: -miphoneos-version-min. When building for iPhone OS, specify the minimum version supported by your; application. .. option:: --print-supported-cpus. Print out a list of supported processors for the given target (specified; through ``--target=<architecture>`` or :option:`-arch` ``<architecture>``). If no; target is specified, the system default target will be used. .. option:: -mcpu=?, -mtune=?. Acts as an alias for :option:`--print-supported-cpus`. .. option:: -mcpu=help, -mtune=help. Acts as an alias for :option:`--print-supported-cpus`. .. option:: -march=<cpu>. Specify that Clang should gene",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:11988,Modifiability,variab,variables,11988,":option:`-Ofast` Enables all the optimizations from :option:`-O3` along; with other aggressive optimizations that may violate strict compliance with; language standards. :option:`-Os` Like :option:`-O2` with extra optimizations to reduce code; size. :option:`-Oz` Like :option:`-Os` (and thus :option:`-O2`), but reduces code; size further. :option:`-Og` Like :option:`-O1`. In future versions, this option might; disable different optimizations in order to improve debuggability. :option:`-O` Equivalent to :option:`-O1`. :option:`-O4` and higher. Currently equivalent to :option:`-O3`. .. option:: -g, -gline-tables-only, -gmodules. Control debug information output. Note that Clang debug information works; best at :option:`-O0`. When more than one option starting with `-g` is; specified, the last one wins:. :option:`-g` Generate debug information. :option:`-gline-tables-only` Generate only line table debug information. This; allows for symbolicated backtraces with inlining information, but does not; include any information about variables, their locations or types. :option:`-gmodules` Generate debug information that contains external; references to types defined in Clang modules or precompiled headers instead; of emitting redundant debug type information into every object file. This; option transparently switches the Clang module format to object file; containers that hold the Clang module together with the debug information.; When compiling a program that uses Clang modules or precompiled headers,; this option produces complete debug information with faster compile; times and much smaller object files. This option should not be used when building static libraries for; distribution to other machines because the debug info will contain; references to the module cache on the machine the object files in the; library were built on. .. option:: -fstandalone-debug -fno-standalone-debug. Clang supports a number of optimizations to reduce the size of debug; information in the bina",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:14499,Modifiability,variab,variables,14499,"the default on Darwin. Note that Clang will; never emit type information for types that are not referenced at all by the; program. .. option:: -feliminate-unused-debug-types. By default, Clang does not emit type information for types that are defined; but not used in a program. To retain the debug info for these unused types,; the negation **-fno-eliminate-unused-debug-types** can be used. .. option:: -fexceptions. Allow exceptions to be thrown through Clang compiled stack frames (on many; targets, this will enable unwind information for functions that might have; an exception thrown through them). For most targets, this is enabled by; default for C++. .. option:: -ftrapv. Generate code to catch integer overflow errors. Signed integer overflow is; undefined in C. With this flag, extra code is generated to detect this and; abort when it happens. .. option:: -fvisibility. This flag sets the default visibility level. .. option:: -fcommon, -fno-common. This flag specifies that variables without initializers get common linkage.; It can be disabled with :option:`-fno-common`. .. option:: -ftls-model=<model>. Set the default thread-local storage (TLS) model to use for thread-local; variables. Valid values are: ""global-dynamic"", ""local-dynamic"",; ""initial-exec"" and ""local-exec"". The default is ""global-dynamic"". The default; model can be overridden with the tls_model attribute. The compiler will try; to choose a more efficient model if possible. .. option:: -flto, -flto=full, -flto=thin, -emit-llvm. Generate output files in LLVM formats, suitable for link time optimization.; When used with :option:`-S` this generates LLVM intermediate language; assembly files, otherwise this generates LLVM bitcode format object files; (which may be passed to the linker depending on the stage selection options). The default for :option:`-flto` is ""full"", in which the; LLVM bitcode is suitable for monolithic Link Time Optimization (LTO), where; the linker merges all such modules into a single ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:14705,Modifiability,variab,variables,14705,"-debug-types. By default, Clang does not emit type information for types that are defined; but not used in a program. To retain the debug info for these unused types,; the negation **-fno-eliminate-unused-debug-types** can be used. .. option:: -fexceptions. Allow exceptions to be thrown through Clang compiled stack frames (on many; targets, this will enable unwind information for functions that might have; an exception thrown through them). For most targets, this is enabled by; default for C++. .. option:: -ftrapv. Generate code to catch integer overflow errors. Signed integer overflow is; undefined in C. With this flag, extra code is generated to detect this and; abort when it happens. .. option:: -fvisibility. This flag sets the default visibility level. .. option:: -fcommon, -fno-common. This flag specifies that variables without initializers get common linkage.; It can be disabled with :option:`-fno-common`. .. option:: -ftls-model=<model>. Set the default thread-local storage (TLS) model to use for thread-local; variables. Valid values are: ""global-dynamic"", ""local-dynamic"",; ""initial-exec"" and ""local-exec"". The default is ""global-dynamic"". The default; model can be overridden with the tls_model attribute. The compiler will try; to choose a more efficient model if possible. .. option:: -flto, -flto=full, -flto=thin, -emit-llvm. Generate output files in LLVM formats, suitable for link time optimization.; When used with :option:`-S` this generates LLVM intermediate language; assembly files, otherwise this generates LLVM bitcode format object files; (which may be passed to the linker depending on the stage selection options). The default for :option:`-flto` is ""full"", in which the; LLVM bitcode is suitable for monolithic Link Time Optimization (LTO), where; the linker merges all such modules into a single combined module for; optimization. With ""thin"", :doc:`ThinLTO <../ThinLTO>`; compilation is invoked instead. .. note::. On Darwin, when using :option:`-flto` alon",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:17670,Modifiability,variab,variables,17670,"alyzer <arg>. Pass arg to the static analyzer. .. option:: -Xassembler <arg>. Pass arg to the assembler. .. option:: -Xlinker <arg>. Pass arg to the linker. .. option:: -Xpreprocessor <arg>. Pass arg to the preprocessor. .. option:: -o <file>. Write output to file. .. option:: -print-file-name=<file>. Print the full library path of file. .. option:: -print-libgcc-file-name. Print the library path for the currently used compiler runtime library; (""libgcc.a"" or ""libclang_rt.builtins.*.a""). .. option:: -print-prog-name=<name>. Print the full program path of name. .. option:: -print-search-dirs. Print the paths used for finding libraries and programs. .. option:: -save-temps. Save intermediate compilation results. .. option:: -save-stats, -save-stats=cwd, -save-stats=obj. Save internal code generation (LLVM) statistics to a file in the current; directory (:option:`-save-stats`/""-save-stats=cwd"") or the directory; of the output file (""-save-state=obj""). You can also use environment variables to control the statistics reporting.; Setting ``CC_PRINT_INTERNAL_STAT`` to ``1`` enables the feature, the report; goes to stdout in JSON format. Setting ``CC_PRINT_INTERNAL_STAT_FILE`` to a file path makes it report; statistics to the given file in the JSON format. Note that ``-save-stats`` take precedence over ``CC_PRINT_INTERNAL_STAT``; and ``CC_PRINT_INTERNAL_STAT_FILE``. .. option:: -integrated-as, -no-integrated-as. Used to enable and disable, respectively, the use of the integrated; assembler. Whether the integrated assembler is on by default is target; dependent. .. option:: -time. Time individual commands. .. option:: -ftime-report. Print timing summary of each stage of compilation. .. option:: -v. Show commands to run and use verbose output. Diagnostics Options; ~~~~~~~~~~~~~~~~~~~. .. option:: -fshow-column, -fshow-source-location, -fcaret-diagnostics, -fdiagnostics-fixit-info, -fdiagnostics-parseable-fixits, -fdiagnostics-print-source-range-info, -fprint-source-range-info",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:20800,Modifiability,variab,variables,20800,"'s builtin directory for include files. .. option:: -fkeep-system-includes. Usable only with :option:`-E`. Do not copy the preprocessed content of; ""system"" headers to the output; instead, preserve the #include directive.; This can greatly reduce the volume of text produced by :option:`-E` which; can be helpful when trying to produce a ""small"" reproduceable test case. This option does not guarantee reproduceability, however. If the including; source defines preprocessor symbols that influence the behavior of system; headers (for example, ``_XOPEN_SOURCE``) the operation of :option:`-E` will; remove that definition and thus can change the semantics of the included; header. Also, using a different version of the system headers (especially a; different version of the STL) may result in different behavior. Always verify; the preprocessed file by compiling it separately. ENVIRONMENT; -----------. .. envvar:: TMPDIR, TEMP, TMP. These environment variables are checked, in order, for the location to write; temporary files used during the compilation process. .. envvar:: CPATH. If this environment variable is present, it is treated as a delimited list of; paths to be added to the default system include path list. The delimiter is; the platform dependent delimiter, as used in the PATH environment variable. Empty components in the environment variable are ignored. .. envvar:: C_INCLUDE_PATH, OBJC_INCLUDE_PATH, CPLUS_INCLUDE_PATH, OBJCPLUS_INCLUDE_PATH. These environment variables specify additional paths, as for :envvar:`CPATH`, which are; only used when processing the appropriate language. .. envvar:: MACOSX_DEPLOYMENT_TARGET. If :option:`-mmacosx-version-min` is unspecified, the default deployment; target is read from this environment variable. This option only affects; Darwin targets. BUGS; ----. To report bugs, please visit <https://github.com/llvm/llvm-project/issues/>. Most bug reports should; include preprocessed source files (use the :option:`-E` option) and the full; o",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:20952,Modifiability,variab,variable,20952,"y the preprocessed content of; ""system"" headers to the output; instead, preserve the #include directive.; This can greatly reduce the volume of text produced by :option:`-E` which; can be helpful when trying to produce a ""small"" reproduceable test case. This option does not guarantee reproduceability, however. If the including; source defines preprocessor symbols that influence the behavior of system; headers (for example, ``_XOPEN_SOURCE``) the operation of :option:`-E` will; remove that definition and thus can change the semantics of the included; header. Also, using a different version of the system headers (especially a; different version of the STL) may result in different behavior. Always verify; the preprocessed file by compiling it separately. ENVIRONMENT; -----------. .. envvar:: TMPDIR, TEMP, TMP. These environment variables are checked, in order, for the location to write; temporary files used during the compilation process. .. envvar:: CPATH. If this environment variable is present, it is treated as a delimited list of; paths to be added to the default system include path list. The delimiter is; the platform dependent delimiter, as used in the PATH environment variable. Empty components in the environment variable are ignored. .. envvar:: C_INCLUDE_PATH, OBJC_INCLUDE_PATH, CPLUS_INCLUDE_PATH, OBJCPLUS_INCLUDE_PATH. These environment variables specify additional paths, as for :envvar:`CPATH`, which are; only used when processing the appropriate language. .. envvar:: MACOSX_DEPLOYMENT_TARGET. If :option:`-mmacosx-version-min` is unspecified, the default deployment; target is read from this environment variable. This option only affects; Darwin targets. BUGS; ----. To report bugs, please visit <https://github.com/llvm/llvm-project/issues/>. Most bug reports should; include preprocessed source files (use the :option:`-E` option) and the full; output of the compiler, along with information to reproduce. SEE ALSO; --------. :manpage:`as(1)`, :manpage:`ld(1)`; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:21154,Modifiability,variab,variable,21154,"y the preprocessed content of; ""system"" headers to the output; instead, preserve the #include directive.; This can greatly reduce the volume of text produced by :option:`-E` which; can be helpful when trying to produce a ""small"" reproduceable test case. This option does not guarantee reproduceability, however. If the including; source defines preprocessor symbols that influence the behavior of system; headers (for example, ``_XOPEN_SOURCE``) the operation of :option:`-E` will; remove that definition and thus can change the semantics of the included; header. Also, using a different version of the system headers (especially a; different version of the STL) may result in different behavior. Always verify; the preprocessed file by compiling it separately. ENVIRONMENT; -----------. .. envvar:: TMPDIR, TEMP, TMP. These environment variables are checked, in order, for the location to write; temporary files used during the compilation process. .. envvar:: CPATH. If this environment variable is present, it is treated as a delimited list of; paths to be added to the default system include path list. The delimiter is; the platform dependent delimiter, as used in the PATH environment variable. Empty components in the environment variable are ignored. .. envvar:: C_INCLUDE_PATH, OBJC_INCLUDE_PATH, CPLUS_INCLUDE_PATH, OBJCPLUS_INCLUDE_PATH. These environment variables specify additional paths, as for :envvar:`CPATH`, which are; only used when processing the appropriate language. .. envvar:: MACOSX_DEPLOYMENT_TARGET. If :option:`-mmacosx-version-min` is unspecified, the default deployment; target is read from this environment variable. This option only affects; Darwin targets. BUGS; ----. To report bugs, please visit <https://github.com/llvm/llvm-project/issues/>. Most bug reports should; include preprocessed source files (use the :option:`-E` option) and the full; output of the compiler, along with information to reproduce. SEE ALSO; --------. :manpage:`as(1)`, :manpage:`ld(1)`; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:21200,Modifiability,variab,variable,21200,"y the preprocessed content of; ""system"" headers to the output; instead, preserve the #include directive.; This can greatly reduce the volume of text produced by :option:`-E` which; can be helpful when trying to produce a ""small"" reproduceable test case. This option does not guarantee reproduceability, however. If the including; source defines preprocessor symbols that influence the behavior of system; headers (for example, ``_XOPEN_SOURCE``) the operation of :option:`-E` will; remove that definition and thus can change the semantics of the included; header. Also, using a different version of the system headers (especially a; different version of the STL) may result in different behavior. Always verify; the preprocessed file by compiling it separately. ENVIRONMENT; -----------. .. envvar:: TMPDIR, TEMP, TMP. These environment variables are checked, in order, for the location to write; temporary files used during the compilation process. .. envvar:: CPATH. If this environment variable is present, it is treated as a delimited list of; paths to be added to the default system include path list. The delimiter is; the platform dependent delimiter, as used in the PATH environment variable. Empty components in the environment variable are ignored. .. envvar:: C_INCLUDE_PATH, OBJC_INCLUDE_PATH, CPLUS_INCLUDE_PATH, OBJCPLUS_INCLUDE_PATH. These environment variables specify additional paths, as for :envvar:`CPATH`, which are; only used when processing the appropriate language. .. envvar:: MACOSX_DEPLOYMENT_TARGET. If :option:`-mmacosx-version-min` is unspecified, the default deployment; target is read from this environment variable. This option only affects; Darwin targets. BUGS; ----. To report bugs, please visit <https://github.com/llvm/llvm-project/issues/>. Most bug reports should; include preprocessed source files (use the :option:`-E` option) and the full; output of the compiler, along with information to reproduce. SEE ALSO; --------. :manpage:`as(1)`, :manpage:`ld(1)`; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:21330,Modifiability,variab,variables,21330,"y the preprocessed content of; ""system"" headers to the output; instead, preserve the #include directive.; This can greatly reduce the volume of text produced by :option:`-E` which; can be helpful when trying to produce a ""small"" reproduceable test case. This option does not guarantee reproduceability, however. If the including; source defines preprocessor symbols that influence the behavior of system; headers (for example, ``_XOPEN_SOURCE``) the operation of :option:`-E` will; remove that definition and thus can change the semantics of the included; header. Also, using a different version of the system headers (especially a; different version of the STL) may result in different behavior. Always verify; the preprocessed file by compiling it separately. ENVIRONMENT; -----------. .. envvar:: TMPDIR, TEMP, TMP. These environment variables are checked, in order, for the location to write; temporary files used during the compilation process. .. envvar:: CPATH. If this environment variable is present, it is treated as a delimited list of; paths to be added to the default system include path list. The delimiter is; the platform dependent delimiter, as used in the PATH environment variable. Empty components in the environment variable are ignored. .. envvar:: C_INCLUDE_PATH, OBJC_INCLUDE_PATH, CPLUS_INCLUDE_PATH, OBJCPLUS_INCLUDE_PATH. These environment variables specify additional paths, as for :envvar:`CPATH`, which are; only used when processing the appropriate language. .. envvar:: MACOSX_DEPLOYMENT_TARGET. If :option:`-mmacosx-version-min` is unspecified, the default deployment; target is read from this environment variable. This option only affects; Darwin targets. BUGS; ----. To report bugs, please visit <https://github.com/llvm/llvm-project/issues/>. Most bug reports should; include preprocessed source files (use the :option:`-E` option) and the full; output of the compiler, along with information to reproduce. SEE ALSO; --------. :manpage:`as(1)`, :manpage:`ld(1)`; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:21602,Modifiability,variab,variable,21602,"y the preprocessed content of; ""system"" headers to the output; instead, preserve the #include directive.; This can greatly reduce the volume of text produced by :option:`-E` which; can be helpful when trying to produce a ""small"" reproduceable test case. This option does not guarantee reproduceability, however. If the including; source defines preprocessor symbols that influence the behavior of system; headers (for example, ``_XOPEN_SOURCE``) the operation of :option:`-E` will; remove that definition and thus can change the semantics of the included; header. Also, using a different version of the system headers (especially a; different version of the STL) may result in different behavior. Always verify; the preprocessed file by compiling it separately. ENVIRONMENT; -----------. .. envvar:: TMPDIR, TEMP, TMP. These environment variables are checked, in order, for the location to write; temporary files used during the compilation process. .. envvar:: CPATH. If this environment variable is present, it is treated as a delimited list of; paths to be added to the default system include path list. The delimiter is; the platform dependent delimiter, as used in the PATH environment variable. Empty components in the environment variable are ignored. .. envvar:: C_INCLUDE_PATH, OBJC_INCLUDE_PATH, CPLUS_INCLUDE_PATH, OBJCPLUS_INCLUDE_PATH. These environment variables specify additional paths, as for :envvar:`CPATH`, which are; only used when processing the appropriate language. .. envvar:: MACOSX_DEPLOYMENT_TARGET. If :option:`-mmacosx-version-min` is unspecified, the default deployment; target is read from this environment variable. This option only affects; Darwin targets. BUGS; ----. To report bugs, please visit <https://github.com/llvm/llvm-project/issues/>. Most bug reports should; include preprocessed source files (use the :option:`-E` option) and the full; output of the compiler, along with information to reproduce. SEE ALSO; --------. :manpage:`as(1)`, :manpage:`ld(1)`; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:293,Performance,optimiz,optimization,293,"clang - the Clang C, C++, and Objective-C compiler; ==================================================. SYNOPSIS; --------. :program:`clang` [*options*] *filename ...*. DESCRIPTION; -----------. :program:`clang` is a C, C++, and Objective-C compiler which encompasses; preprocessing, parsing, optimization, code generation, assembly, and linking.; Depending on which high-level mode setting is passed, Clang will stop before; doing a full link. While Clang is highly integrated, it is important to; understand the stages of compilation, to understand how to invoke it. These; stages are:. Driver; The clang executable is actually a small driver which controls the overall; execution of other tools such as the compiler, assembler and linker.; Typically you do not need to interact with the driver, but you; transparently use it to run the other tools. Preprocessing; This stage handles tokenization of the input source file, macro expansion,; #include expansion and handling of other preprocessor directives. The; output of this stage is typically called a "".i"" (for C), "".ii"" (for C++),; "".mi"" (for Objective-C), or "".mii"" (for Objective-C++) file. Parsing and Semantic Analysis; This stage parses the input file, translating preprocessor tokens into a; parse tree. Once in the form of a parse tree, it applies semantic; analysis to compute types for expressions as well and determine whether; the code is well formed. This stage is responsible for generating most of; the compiler warnings as well as parse errors. The output of this stage is; an ""Abstract Syntax Tree"" (AST). Code Generation and Optimization; This stage translates an AST into low-level intermediate code (known as; ""LLVM IR"") and ultimately to machine code. This phase is responsible for; optimizing the generated code and handling target-specific code generation.; The output of this stage is typically called a "".s"" file or ""assembly"" file. Clang also supports the use of an integrated assembler, in which the code; generator pr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:1760,Performance,optimiz,optimizing,1760,"with the driver, but you; transparently use it to run the other tools. Preprocessing; This stage handles tokenization of the input source file, macro expansion,; #include expansion and handling of other preprocessor directives. The; output of this stage is typically called a "".i"" (for C), "".ii"" (for C++),; "".mi"" (for Objective-C), or "".mii"" (for Objective-C++) file. Parsing and Semantic Analysis; This stage parses the input file, translating preprocessor tokens into a; parse tree. Once in the form of a parse tree, it applies semantic; analysis to compute types for expressions as well and determine whether; the code is well formed. This stage is responsible for generating most of; the compiler warnings as well as parse errors. The output of this stage is; an ""Abstract Syntax Tree"" (AST). Code Generation and Optimization; This stage translates an AST into low-level intermediate code (known as; ""LLVM IR"") and ultimately to machine code. This phase is responsible for; optimizing the generated code and handling target-specific code generation.; The output of this stage is typically called a "".s"" file or ""assembly"" file. Clang also supports the use of an integrated assembler, in which the code; generator produces object files directly. This avoids the overhead of; generating the "".s"" file and of calling the target assembler. Assembler; This stage runs the target assembler to translate the output of the; compiler into a target object file. The output of this stage is typically; called a "".o"" file or ""object"" file. Linker; This stage runs the target linker to merge multiple object files into an; executable or dynamic library. The output of this stage is typically called; an ""a.out"", "".dylib"" or "".so"" file. :program:`Clang Static Analyzer`. The Clang Static Analyzer is a tool that scans source code to try to find bugs; through code analysis. This tool uses many parts of Clang and is built into; the same driver. Please see <https://clang-analyzer.llvm.org> for more details; on",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:3084,Performance,optimiz,optimization,3084,"g the target assembler. Assembler; This stage runs the target assembler to translate the output of the; compiler into a target object file. The output of this stage is typically; called a "".o"" file or ""object"" file. Linker; This stage runs the target linker to merge multiple object files into an; executable or dynamic library. The output of this stage is typically called; an ""a.out"", "".dylib"" or "".so"" file. :program:`Clang Static Analyzer`. The Clang Static Analyzer is a tool that scans source code to try to find bugs; through code analysis. This tool uses many parts of Clang and is built into; the same driver. Please see <https://clang-analyzer.llvm.org> for more details; on how to use the static analyzer. OPTIONS; -------. Stage Selection Options; ~~~~~~~~~~~~~~~~~~~~~~~. .. option:: -E. Run the preprocessor stage. .. option:: -fsyntax-only. Run the preprocessor, parser and semantic analysis stages. .. option:: -S. Run the previous stages as well as LLVM generation and optimization stages; and target-specific code generation, producing an assembly file. .. option:: -c. Run all of the above, plus the assembler, generating a target "".o"" object file. .. option:: no stage selection option. If no stage selection option is specified, all stages above are run, and the; linker is run to combine the results into an executable or shared library. Language Selection and Mode Options; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. option:: -x <language>. Treat subsequent input files as having type language. .. option:: -std=<standard>. Specify the language standard to compile for. Supported values for the C language are:. | ``c89``; | ``c90``; | ``iso9899:1990``. ISO C 1990. | ``iso9899:199409``. ISO C 1990 with amendment 1. | ``gnu89``; | ``gnu90``. ISO C 1990 with GNU extensions. | ``c99``; | ``iso9899:1999``. ISO C 1999. | ``gnu99``. ISO C 1999 with GNU extensions. | ``c11``; | ``iso9899:2011``. ISO C 2011. | ``gnu11``. ISO C 2011 with GNU extensions. | ``c17``; | ``iso9899:2017``.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:6274,Performance,optimiz,optimizations,6274,"pported values for the CUDA language are:. | ``cuda``. NVIDIA CUDA(tm). .. option:: -stdlib=<library>. Specify the C++ standard library to use; supported options are libstdc++ and; libc++. If not specified, platform default will be used. .. option:: -rtlib=<library>. Specify the compiler runtime library to use; supported options are libgcc and; compiler-rt. If not specified, platform default will be used. .. option:: -ansi. Same as -std=c89. .. option:: -ObjC, -ObjC++. Treat source input files as Objective-C and Object-C++ inputs respectively. .. option:: -trigraphs. Enable trigraphs. .. option:: -ffreestanding. Indicate that the file should be compiled for a freestanding, not a hosted,; environment. Note that it is assumed that a freestanding environment will; additionally provide `memcpy`, `memmove`, `memset` and `memcmp`; implementations, as these are needed for efficient codegen for many programs. .. option:: -fno-builtin. Disable special handling and optimizations of well-known library functions,; like :c:func:`strlen` and :c:func:`malloc`. .. option:: -fno-builtin-<function>. Disable special handling and optimizations for the specific library function.; For example, ``-fno-builtin-strlen`` removes any special handling for the; :c:func:`strlen` library function. .. option:: -fno-builtin-std-<function>. Disable special handling and optimizations for the specific C++ standard; library function in namespace ``std``. For example,; ``-fno-builtin-std-move_if_noexcept`` removes any special handling for the; :cpp:func:`std::move_if_noexcept` library function. For C standard library functions that the C++ standard library also provides; in namespace ``std``, use :option:`-fno-builtin-\<function\>` instead. .. option:: -fmath-errno. Indicate that math functions should be treated as updating :c:data:`errno`. .. option:: -fpascal-strings. Enable support for Pascal-style strings with ""\\pfoo"". .. option:: -fms-extensions. Enable support for Microsoft extensions. .. option::",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:6432,Performance,optimiz,optimizations,6432,"o use; supported options are libstdc++ and; libc++. If not specified, platform default will be used. .. option:: -rtlib=<library>. Specify the compiler runtime library to use; supported options are libgcc and; compiler-rt. If not specified, platform default will be used. .. option:: -ansi. Same as -std=c89. .. option:: -ObjC, -ObjC++. Treat source input files as Objective-C and Object-C++ inputs respectively. .. option:: -trigraphs. Enable trigraphs. .. option:: -ffreestanding. Indicate that the file should be compiled for a freestanding, not a hosted,; environment. Note that it is assumed that a freestanding environment will; additionally provide `memcpy`, `memmove`, `memset` and `memcmp`; implementations, as these are needed for efficient codegen for many programs. .. option:: -fno-builtin. Disable special handling and optimizations of well-known library functions,; like :c:func:`strlen` and :c:func:`malloc`. .. option:: -fno-builtin-<function>. Disable special handling and optimizations for the specific library function.; For example, ``-fno-builtin-strlen`` removes any special handling for the; :c:func:`strlen` library function. .. option:: -fno-builtin-std-<function>. Disable special handling and optimizations for the specific C++ standard; library function in namespace ``std``. For example,; ``-fno-builtin-std-move_if_noexcept`` removes any special handling for the; :cpp:func:`std::move_if_noexcept` library function. For C standard library functions that the C++ standard library also provides; in namespace ``std``, use :option:`-fno-builtin-\<function\>` instead. .. option:: -fmath-errno. Indicate that math functions should be treated as updating :c:data:`errno`. .. option:: -fpascal-strings. Enable support for Pascal-style strings with ""\\pfoo"". .. option:: -fms-extensions. Enable support for Microsoft extensions. .. option:: -fmsc-version=. Set ``_MSC_VER``. When on Windows, this defaults to either the same value as; the currently installed version of cl.exe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:6662,Performance,optimiz,optimizations,6662,"rm default will be used. .. option:: -ansi. Same as -std=c89. .. option:: -ObjC, -ObjC++. Treat source input files as Objective-C and Object-C++ inputs respectively. .. option:: -trigraphs. Enable trigraphs. .. option:: -ffreestanding. Indicate that the file should be compiled for a freestanding, not a hosted,; environment. Note that it is assumed that a freestanding environment will; additionally provide `memcpy`, `memmove`, `memset` and `memcmp`; implementations, as these are needed for efficient codegen for many programs. .. option:: -fno-builtin. Disable special handling and optimizations of well-known library functions,; like :c:func:`strlen` and :c:func:`malloc`. .. option:: -fno-builtin-<function>. Disable special handling and optimizations for the specific library function.; For example, ``-fno-builtin-strlen`` removes any special handling for the; :c:func:`strlen` library function. .. option:: -fno-builtin-std-<function>. Disable special handling and optimizations for the specific C++ standard; library function in namespace ``std``. For example,; ``-fno-builtin-std-move_if_noexcept`` removes any special handling for the; :cpp:func:`std::move_if_noexcept` library function. For C standard library functions that the C++ standard library also provides; in namespace ``std``, use :option:`-fno-builtin-\<function\>` instead. .. option:: -fmath-errno. Indicate that math functions should be treated as updating :c:data:`errno`. .. option:: -fpascal-strings. Enable support for Pascal-style strings with ""\\pfoo"". .. option:: -fms-extensions. Enable support for Microsoft extensions. .. option:: -fmsc-version=. Set ``_MSC_VER``. When on Windows, this defaults to either the same value as; the currently installed version of cl.exe, or ``1933``. Not set otherwise. .. option:: -fborland-extensions. Enable support for Borland extensions. .. option:: -fwritable-strings. Make all string literals default to writable. This disables uniquing of; strings and other optimizations. .. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:7671,Performance,optimiz,optimizations,7671,"ng and optimizations for the specific C++ standard; library function in namespace ``std``. For example,; ``-fno-builtin-std-move_if_noexcept`` removes any special handling for the; :cpp:func:`std::move_if_noexcept` library function. For C standard library functions that the C++ standard library also provides; in namespace ``std``, use :option:`-fno-builtin-\<function\>` instead. .. option:: -fmath-errno. Indicate that math functions should be treated as updating :c:data:`errno`. .. option:: -fpascal-strings. Enable support for Pascal-style strings with ""\\pfoo"". .. option:: -fms-extensions. Enable support for Microsoft extensions. .. option:: -fmsc-version=. Set ``_MSC_VER``. When on Windows, this defaults to either the same value as; the currently installed version of cl.exe, or ``1933``. Not set otherwise. .. option:: -fborland-extensions. Enable support for Borland extensions. .. option:: -fwritable-strings. Make all string literals default to writable. This disables uniquing of; strings and other optimizations. .. option:: -flax-vector-conversions, -flax-vector-conversions=<kind>, -fno-lax-vector-conversions. Allow loose type checking rules for implicit vector conversions.; Possible values of <kind>:. - ``none``: allow no implicit conversions between vectors; - ``integer``: allow implicit bitcasts between integer vectors of the same; overall bit-width; - ``all``: allow implicit bitcasts between any vectors of the same; overall bit-width. <kind> defaults to ``integer`` if unspecified. .. option:: -fblocks. Enable the ""Blocks"" language feature. .. option:: -fobjc-abi-version=version. Select the Objective-C ABI version to use. Available versions are 1 (legacy; ""fragile"" ABI), 2 (non-fragile ABI 1), and 3 (non-fragile ABI 2). .. option:: -fobjc-nonfragile-abi-version=<version>. Select the Objective-C non-fragile ABI version to use by default. This will; only be used as the Objective-C ABI when the non-fragile ABI is enabled; (either via :option:`-fobjc-nonfragile-ab",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:10482,Performance,optimiz,optimization,10482," application. .. option:: -miphoneos-version-min. When building for iPhone OS, specify the minimum version supported by your; application. .. option:: --print-supported-cpus. Print out a list of supported processors for the given target (specified; through ``--target=<architecture>`` or :option:`-arch` ``<architecture>``). If no; target is specified, the system default target will be used. .. option:: -mcpu=?, -mtune=?. Acts as an alias for :option:`--print-supported-cpus`. .. option:: -mcpu=help, -mtune=help. Acts as an alias for :option:`--print-supported-cpus`. .. option:: -march=<cpu>. Specify that Clang should generate code for a specific processor family; member and later. For example, if you specify -march=i486, the compiler is; allowed to generate instructions that are valid on i486 and later processors,; but which may not exist on earlier ones. Code Generation Options; ~~~~~~~~~~~~~~~~~~~~~~~. .. option:: -O0, -O1, -O2, -O3, -Ofast, -Os, -Oz, -Og, -O, -O4. Specify which optimization level to use:. :option:`-O0` Means ""no optimization"": this level compiles the fastest and; generates the most debuggable code. :option:`-O1` Somewhere between :option:`-O0` and :option:`-O2`. :option:`-O2` Moderate level of optimization which enables most; optimizations. :option:`-O3` Like :option:`-O2`, except that it enables optimizations that; take longer to perform or that may generate larger code (in an attempt to; make the program run faster). :option:`-Ofast` Enables all the optimizations from :option:`-O3` along; with other aggressive optimizations that may violate strict compliance with; language standards. :option:`-Os` Like :option:`-O2` with extra optimizations to reduce code; size. :option:`-Oz` Like :option:`-Os` (and thus :option:`-O2`), but reduces code; size further. :option:`-Og` Like :option:`-O1`. In future versions, this option might; disable different optimizations in order to improve debuggability. :option:`-O` Equivalent to :option:`-O1`. :option:`-O4` an",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:10534,Performance,optimiz,optimization,10534,", specify the minimum version supported by your; application. .. option:: --print-supported-cpus. Print out a list of supported processors for the given target (specified; through ``--target=<architecture>`` or :option:`-arch` ``<architecture>``). If no; target is specified, the system default target will be used. .. option:: -mcpu=?, -mtune=?. Acts as an alias for :option:`--print-supported-cpus`. .. option:: -mcpu=help, -mtune=help. Acts as an alias for :option:`--print-supported-cpus`. .. option:: -march=<cpu>. Specify that Clang should generate code for a specific processor family; member and later. For example, if you specify -march=i486, the compiler is; allowed to generate instructions that are valid on i486 and later processors,; but which may not exist on earlier ones. Code Generation Options; ~~~~~~~~~~~~~~~~~~~~~~~. .. option:: -O0, -O1, -O2, -O3, -Ofast, -Os, -Oz, -Og, -O, -O4. Specify which optimization level to use:. :option:`-O0` Means ""no optimization"": this level compiles the fastest and; generates the most debuggable code. :option:`-O1` Somewhere between :option:`-O0` and :option:`-O2`. :option:`-O2` Moderate level of optimization which enables most; optimizations. :option:`-O3` Like :option:`-O2`, except that it enables optimizations that; take longer to perform or that may generate larger code (in an attempt to; make the program run faster). :option:`-Ofast` Enables all the optimizations from :option:`-O3` along; with other aggressive optimizations that may violate strict compliance with; language standards. :option:`-Os` Like :option:`-O2` with extra optimizations to reduce code; size. :option:`-Oz` Like :option:`-Os` (and thus :option:`-O2`), but reduces code; size further. :option:`-Og` Like :option:`-O1`. In future versions, this option might; disable different optimizations in order to improve debuggability. :option:`-O` Equivalent to :option:`-O1`. :option:`-O4` and higher. Currently equivalent to :option:`-O3`. .. option:: -g, -gline-table",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:10719,Performance,optimiz,optimization,10719,"specified; through ``--target=<architecture>`` or :option:`-arch` ``<architecture>``). If no; target is specified, the system default target will be used. .. option:: -mcpu=?, -mtune=?. Acts as an alias for :option:`--print-supported-cpus`. .. option:: -mcpu=help, -mtune=help. Acts as an alias for :option:`--print-supported-cpus`. .. option:: -march=<cpu>. Specify that Clang should generate code for a specific processor family; member and later. For example, if you specify -march=i486, the compiler is; allowed to generate instructions that are valid on i486 and later processors,; but which may not exist on earlier ones. Code Generation Options; ~~~~~~~~~~~~~~~~~~~~~~~. .. option:: -O0, -O1, -O2, -O3, -Ofast, -Os, -Oz, -Og, -O, -O4. Specify which optimization level to use:. :option:`-O0` Means ""no optimization"": this level compiles the fastest and; generates the most debuggable code. :option:`-O1` Somewhere between :option:`-O0` and :option:`-O2`. :option:`-O2` Moderate level of optimization which enables most; optimizations. :option:`-O3` Like :option:`-O2`, except that it enables optimizations that; take longer to perform or that may generate larger code (in an attempt to; make the program run faster). :option:`-Ofast` Enables all the optimizations from :option:`-O3` along; with other aggressive optimizations that may violate strict compliance with; language standards. :option:`-Os` Like :option:`-O2` with extra optimizations to reduce code; size. :option:`-Oz` Like :option:`-Os` (and thus :option:`-O2`), but reduces code; size further. :option:`-Og` Like :option:`-O1`. In future versions, this option might; disable different optimizations in order to improve debuggability. :option:`-O` Equivalent to :option:`-O1`. :option:`-O4` and higher. Currently equivalent to :option:`-O3`. .. option:: -g, -gline-tables-only, -gmodules. Control debug information output. Note that Clang debug information works; best at :option:`-O0`. When more than one option starting with `-g`",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:10752,Performance,optimiz,optimizations,10752,"specified; through ``--target=<architecture>`` or :option:`-arch` ``<architecture>``). If no; target is specified, the system default target will be used. .. option:: -mcpu=?, -mtune=?. Acts as an alias for :option:`--print-supported-cpus`. .. option:: -mcpu=help, -mtune=help. Acts as an alias for :option:`--print-supported-cpus`. .. option:: -march=<cpu>. Specify that Clang should generate code for a specific processor family; member and later. For example, if you specify -march=i486, the compiler is; allowed to generate instructions that are valid on i486 and later processors,; but which may not exist on earlier ones. Code Generation Options; ~~~~~~~~~~~~~~~~~~~~~~~. .. option:: -O0, -O1, -O2, -O3, -Ofast, -Os, -Oz, -Og, -O, -O4. Specify which optimization level to use:. :option:`-O0` Means ""no optimization"": this level compiles the fastest and; generates the most debuggable code. :option:`-O1` Somewhere between :option:`-O0` and :option:`-O2`. :option:`-O2` Moderate level of optimization which enables most; optimizations. :option:`-O3` Like :option:`-O2`, except that it enables optimizations that; take longer to perform or that may generate larger code (in an attempt to; make the program run faster). :option:`-Ofast` Enables all the optimizations from :option:`-O3` along; with other aggressive optimizations that may violate strict compliance with; language standards. :option:`-Os` Like :option:`-O2` with extra optimizations to reduce code; size. :option:`-Oz` Like :option:`-Os` (and thus :option:`-O2`), but reduces code; size further. :option:`-Og` Like :option:`-O1`. In future versions, this option might; disable different optimizations in order to improve debuggability. :option:`-O` Equivalent to :option:`-O1`. :option:`-O4` and higher. Currently equivalent to :option:`-O3`. .. option:: -g, -gline-tables-only, -gmodules. Control debug information output. Note that Clang debug information works; best at :option:`-O0`. When more than one option starting with `-g`",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:10824,Performance,optimiz,optimizations,10824,"lt target will be used. .. option:: -mcpu=?, -mtune=?. Acts as an alias for :option:`--print-supported-cpus`. .. option:: -mcpu=help, -mtune=help. Acts as an alias for :option:`--print-supported-cpus`. .. option:: -march=<cpu>. Specify that Clang should generate code for a specific processor family; member and later. For example, if you specify -march=i486, the compiler is; allowed to generate instructions that are valid on i486 and later processors,; but which may not exist on earlier ones. Code Generation Options; ~~~~~~~~~~~~~~~~~~~~~~~. .. option:: -O0, -O1, -O2, -O3, -Ofast, -Os, -Oz, -Og, -O, -O4. Specify which optimization level to use:. :option:`-O0` Means ""no optimization"": this level compiles the fastest and; generates the most debuggable code. :option:`-O1` Somewhere between :option:`-O0` and :option:`-O2`. :option:`-O2` Moderate level of optimization which enables most; optimizations. :option:`-O3` Like :option:`-O2`, except that it enables optimizations that; take longer to perform or that may generate larger code (in an attempt to; make the program run faster). :option:`-Ofast` Enables all the optimizations from :option:`-O3` along; with other aggressive optimizations that may violate strict compliance with; language standards. :option:`-Os` Like :option:`-O2` with extra optimizations to reduce code; size. :option:`-Oz` Like :option:`-Os` (and thus :option:`-O2`), but reduces code; size further. :option:`-Og` Like :option:`-O1`. In future versions, this option might; disable different optimizations in order to improve debuggability. :option:`-O` Equivalent to :option:`-O1`. :option:`-O4` and higher. Currently equivalent to :option:`-O3`. .. option:: -g, -gline-tables-only, -gmodules. Control debug information output. Note that Clang debug information works; best at :option:`-O0`. When more than one option starting with `-g` is; specified, the last one wins:. :option:`-g` Generate debug information. :option:`-gline-tables-only` Generate only line table ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:10859,Performance,perform,perform,10859,"lt target will be used. .. option:: -mcpu=?, -mtune=?. Acts as an alias for :option:`--print-supported-cpus`. .. option:: -mcpu=help, -mtune=help. Acts as an alias for :option:`--print-supported-cpus`. .. option:: -march=<cpu>. Specify that Clang should generate code for a specific processor family; member and later. For example, if you specify -march=i486, the compiler is; allowed to generate instructions that are valid on i486 and later processors,; but which may not exist on earlier ones. Code Generation Options; ~~~~~~~~~~~~~~~~~~~~~~~. .. option:: -O0, -O1, -O2, -O3, -Ofast, -Os, -Oz, -Og, -O, -O4. Specify which optimization level to use:. :option:`-O0` Means ""no optimization"": this level compiles the fastest and; generates the most debuggable code. :option:`-O1` Somewhere between :option:`-O0` and :option:`-O2`. :option:`-O2` Moderate level of optimization which enables most; optimizations. :option:`-O3` Like :option:`-O2`, except that it enables optimizations that; take longer to perform or that may generate larger code (in an attempt to; make the program run faster). :option:`-Ofast` Enables all the optimizations from :option:`-O3` along; with other aggressive optimizations that may violate strict compliance with; language standards. :option:`-Os` Like :option:`-O2` with extra optimizations to reduce code; size. :option:`-Oz` Like :option:`-Os` (and thus :option:`-O2`), but reduces code; size further. :option:`-Og` Like :option:`-O1`. In future versions, this option might; disable different optimizations in order to improve debuggability. :option:`-O` Equivalent to :option:`-O1`. :option:`-O4` and higher. Currently equivalent to :option:`-O3`. .. option:: -g, -gline-tables-only, -gmodules. Control debug information output. Note that Clang debug information works; best at :option:`-O0`. When more than one option starting with `-g` is; specified, the last one wins:. :option:`-g` Generate debug information. :option:`-gline-tables-only` Generate only line table ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:10982,Performance,optimiz,optimizations,10982,"`--print-supported-cpus`. .. option:: -march=<cpu>. Specify that Clang should generate code for a specific processor family; member and later. For example, if you specify -march=i486, the compiler is; allowed to generate instructions that are valid on i486 and later processors,; but which may not exist on earlier ones. Code Generation Options; ~~~~~~~~~~~~~~~~~~~~~~~. .. option:: -O0, -O1, -O2, -O3, -Ofast, -Os, -Oz, -Og, -O, -O4. Specify which optimization level to use:. :option:`-O0` Means ""no optimization"": this level compiles the fastest and; generates the most debuggable code. :option:`-O1` Somewhere between :option:`-O0` and :option:`-O2`. :option:`-O2` Moderate level of optimization which enables most; optimizations. :option:`-O3` Like :option:`-O2`, except that it enables optimizations that; take longer to perform or that may generate larger code (in an attempt to; make the program run faster). :option:`-Ofast` Enables all the optimizations from :option:`-O3` along; with other aggressive optimizations that may violate strict compliance with; language standards. :option:`-Os` Like :option:`-O2` with extra optimizations to reduce code; size. :option:`-Oz` Like :option:`-Os` (and thus :option:`-O2`), but reduces code; size further. :option:`-Og` Like :option:`-O1`. In future versions, this option might; disable different optimizations in order to improve debuggability. :option:`-O` Equivalent to :option:`-O1`. :option:`-O4` and higher. Currently equivalent to :option:`-O3`. .. option:: -g, -gline-tables-only, -gmodules. Control debug information output. Note that Clang debug information works; best at :option:`-O0`. When more than one option starting with `-g` is; specified, the last one wins:. :option:`-g` Generate debug information. :option:`-gline-tables-only` Generate only line table debug information. This; allows for symbolicated backtraces with inlining information, but does not; include any information about variables, their locations or types. :option:",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:11044,Performance,optimiz,optimizations,11044,"`--print-supported-cpus`. .. option:: -march=<cpu>. Specify that Clang should generate code for a specific processor family; member and later. For example, if you specify -march=i486, the compiler is; allowed to generate instructions that are valid on i486 and later processors,; but which may not exist on earlier ones. Code Generation Options; ~~~~~~~~~~~~~~~~~~~~~~~. .. option:: -O0, -O1, -O2, -O3, -Ofast, -Os, -Oz, -Og, -O, -O4. Specify which optimization level to use:. :option:`-O0` Means ""no optimization"": this level compiles the fastest and; generates the most debuggable code. :option:`-O1` Somewhere between :option:`-O0` and :option:`-O2`. :option:`-O2` Moderate level of optimization which enables most; optimizations. :option:`-O3` Like :option:`-O2`, except that it enables optimizations that; take longer to perform or that may generate larger code (in an attempt to; make the program run faster). :option:`-Ofast` Enables all the optimizations from :option:`-O3` along; with other aggressive optimizations that may violate strict compliance with; language standards. :option:`-Os` Like :option:`-O2` with extra optimizations to reduce code; size. :option:`-Oz` Like :option:`-Os` (and thus :option:`-O2`), but reduces code; size further. :option:`-Og` Like :option:`-O1`. In future versions, this option might; disable different optimizations in order to improve debuggability. :option:`-O` Equivalent to :option:`-O1`. :option:`-O4` and higher. Currently equivalent to :option:`-O3`. .. option:: -g, -gline-tables-only, -gmodules. Control debug information output. Note that Clang debug information works; best at :option:`-O0`. When more than one option starting with `-g` is; specified, the last one wins:. :option:`-g` Generate debug information. :option:`-gline-tables-only` Generate only line table debug information. This; allows for symbolicated backtraces with inlining information, but does not; include any information about variables, their locations or types. :option:",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:11163,Performance,optimiz,optimizations,11163,"member and later. For example, if you specify -march=i486, the compiler is; allowed to generate instructions that are valid on i486 and later processors,; but which may not exist on earlier ones. Code Generation Options; ~~~~~~~~~~~~~~~~~~~~~~~. .. option:: -O0, -O1, -O2, -O3, -Ofast, -Os, -Oz, -Og, -O, -O4. Specify which optimization level to use:. :option:`-O0` Means ""no optimization"": this level compiles the fastest and; generates the most debuggable code. :option:`-O1` Somewhere between :option:`-O0` and :option:`-O2`. :option:`-O2` Moderate level of optimization which enables most; optimizations. :option:`-O3` Like :option:`-O2`, except that it enables optimizations that; take longer to perform or that may generate larger code (in an attempt to; make the program run faster). :option:`-Ofast` Enables all the optimizations from :option:`-O3` along; with other aggressive optimizations that may violate strict compliance with; language standards. :option:`-Os` Like :option:`-O2` with extra optimizations to reduce code; size. :option:`-Oz` Like :option:`-Os` (and thus :option:`-O2`), but reduces code; size further. :option:`-Og` Like :option:`-O1`. In future versions, this option might; disable different optimizations in order to improve debuggability. :option:`-O` Equivalent to :option:`-O1`. :option:`-O4` and higher. Currently equivalent to :option:`-O3`. .. option:: -g, -gline-tables-only, -gmodules. Control debug information output. Note that Clang debug information works; best at :option:`-O0`. When more than one option starting with `-g` is; specified, the last one wins:. :option:`-g` Generate debug information. :option:`-gline-tables-only` Generate only line table debug information. This; allows for symbolicated backtraces with inlining information, but does not; include any information about variables, their locations or types. :option:`-gmodules` Generate debug information that contains external; references to types defined in Clang modules or precompiled he",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:11381,Performance,optimiz,optimizations,11381,"s; ~~~~~~~~~~~~~~~~~~~~~~~. .. option:: -O0, -O1, -O2, -O3, -Ofast, -Os, -Oz, -Og, -O, -O4. Specify which optimization level to use:. :option:`-O0` Means ""no optimization"": this level compiles the fastest and; generates the most debuggable code. :option:`-O1` Somewhere between :option:`-O0` and :option:`-O2`. :option:`-O2` Moderate level of optimization which enables most; optimizations. :option:`-O3` Like :option:`-O2`, except that it enables optimizations that; take longer to perform or that may generate larger code (in an attempt to; make the program run faster). :option:`-Ofast` Enables all the optimizations from :option:`-O3` along; with other aggressive optimizations that may violate strict compliance with; language standards. :option:`-Os` Like :option:`-O2` with extra optimizations to reduce code; size. :option:`-Oz` Like :option:`-Os` (and thus :option:`-O2`), but reduces code; size further. :option:`-Og` Like :option:`-O1`. In future versions, this option might; disable different optimizations in order to improve debuggability. :option:`-O` Equivalent to :option:`-O1`. :option:`-O4` and higher. Currently equivalent to :option:`-O3`. .. option:: -g, -gline-tables-only, -gmodules. Control debug information output. Note that Clang debug information works; best at :option:`-O0`. When more than one option starting with `-g` is; specified, the last one wins:. :option:`-g` Generate debug information. :option:`-gline-tables-only` Generate only line table debug information. This; allows for symbolicated backtraces with inlining information, but does not; include any information about variables, their locations or types. :option:`-gmodules` Generate debug information that contains external; references to types defined in Clang modules or precompiled headers instead; of emitting redundant debug type information into every object file. This; option transparently switches the Clang module format to object file; containers that hold the Clang module together with the de",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:12734,Performance,cache,cache,12734,"more than one option starting with `-g` is; specified, the last one wins:. :option:`-g` Generate debug information. :option:`-gline-tables-only` Generate only line table debug information. This; allows for symbolicated backtraces with inlining information, but does not; include any information about variables, their locations or types. :option:`-gmodules` Generate debug information that contains external; references to types defined in Clang modules or precompiled headers instead; of emitting redundant debug type information into every object file. This; option transparently switches the Clang module format to object file; containers that hold the Clang module together with the debug information.; When compiling a program that uses Clang modules or precompiled headers,; this option produces complete debug information with faster compile; times and much smaller object files. This option should not be used when building static libraries for; distribution to other machines because the debug info will contain; references to the module cache on the machine the object files in the; library were built on. .. option:: -fstandalone-debug -fno-standalone-debug. Clang supports a number of optimizations to reduce the size of debug; information in the binary. They work based on the assumption that the; debug type information can be spread out over multiple compilation units.; For instance, Clang will not emit type definitions for types that are not; needed by a module and could be replaced with a forward declaration.; Further, Clang will only emit type info for a dynamic C++ class in the; module that contains the vtable for the class. The :option:`-fstandalone-debug` option turns off these optimizations.; This is useful when working with 3rd-party libraries that don't come with; debug information. This is the default on Darwin. Note that Clang will; never emit type information for types that are not referenced at all by the; program. .. option:: -feliminate-unused-debug-types. By",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:12884,Performance,optimiz,optimizations,12884,"d backtraces with inlining information, but does not; include any information about variables, their locations or types. :option:`-gmodules` Generate debug information that contains external; references to types defined in Clang modules or precompiled headers instead; of emitting redundant debug type information into every object file. This; option transparently switches the Clang module format to object file; containers that hold the Clang module together with the debug information.; When compiling a program that uses Clang modules or precompiled headers,; this option produces complete debug information with faster compile; times and much smaller object files. This option should not be used when building static libraries for; distribution to other machines because the debug info will contain; references to the module cache on the machine the object files in the; library were built on. .. option:: -fstandalone-debug -fno-standalone-debug. Clang supports a number of optimizations to reduce the size of debug; information in the binary. They work based on the assumption that the; debug type information can be spread out over multiple compilation units.; For instance, Clang will not emit type definitions for types that are not; needed by a module and could be replaced with a forward declaration.; Further, Clang will only emit type info for a dynamic C++ class in the; module that contains the vtable for the class. The :option:`-fstandalone-debug` option turns off these optimizations.; This is useful when working with 3rd-party libraries that don't come with; debug information. This is the default on Darwin. Note that Clang will; never emit type information for types that are not referenced at all by the; program. .. option:: -feliminate-unused-debug-types. By default, Clang does not emit type information for types that are defined; but not used in a program. To retain the debug info for these unused types,; the negation **-fno-eliminate-unused-debug-types** can be used. .",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:13393,Performance,optimiz,optimizations,13393,"he debug information.; When compiling a program that uses Clang modules or precompiled headers,; this option produces complete debug information with faster compile; times and much smaller object files. This option should not be used when building static libraries for; distribution to other machines because the debug info will contain; references to the module cache on the machine the object files in the; library were built on. .. option:: -fstandalone-debug -fno-standalone-debug. Clang supports a number of optimizations to reduce the size of debug; information in the binary. They work based on the assumption that the; debug type information can be spread out over multiple compilation units.; For instance, Clang will not emit type definitions for types that are not; needed by a module and could be replaced with a forward declaration.; Further, Clang will only emit type info for a dynamic C++ class in the; module that contains the vtable for the class. The :option:`-fstandalone-debug` option turns off these optimizations.; This is useful when working with 3rd-party libraries that don't come with; debug information. This is the default on Darwin. Note that Clang will; never emit type information for types that are not referenced at all by the; program. .. option:: -feliminate-unused-debug-types. By default, Clang does not emit type information for types that are defined; but not used in a program. To retain the debug info for these unused types,; the negation **-fno-eliminate-unused-debug-types** can be used. .. option:: -fexceptions. Allow exceptions to be thrown through Clang compiled stack frames (on many; targets, this will enable unwind information for functions that might have; an exception thrown through them). For most targets, this is enabled by; default for C++. .. option:: -ftrapv. Generate code to catch integer overflow errors. Signed integer overflow is; undefined in C. With this flag, extra code is generated to detect this and; abort when it happens. .. o",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:15089,Performance,optimiz,optimization,15089," that might have; an exception thrown through them). For most targets, this is enabled by; default for C++. .. option:: -ftrapv. Generate code to catch integer overflow errors. Signed integer overflow is; undefined in C. With this flag, extra code is generated to detect this and; abort when it happens. .. option:: -fvisibility. This flag sets the default visibility level. .. option:: -fcommon, -fno-common. This flag specifies that variables without initializers get common linkage.; It can be disabled with :option:`-fno-common`. .. option:: -ftls-model=<model>. Set the default thread-local storage (TLS) model to use for thread-local; variables. Valid values are: ""global-dynamic"", ""local-dynamic"",; ""initial-exec"" and ""local-exec"". The default is ""global-dynamic"". The default; model can be overridden with the tls_model attribute. The compiler will try; to choose a more efficient model if possible. .. option:: -flto, -flto=full, -flto=thin, -emit-llvm. Generate output files in LLVM formats, suitable for link time optimization.; When used with :option:`-S` this generates LLVM intermediate language; assembly files, otherwise this generates LLVM bitcode format object files; (which may be passed to the linker depending on the stage selection options). The default for :option:`-flto` is ""full"", in which the; LLVM bitcode is suitable for monolithic Link Time Optimization (LTO), where; the linker merges all such modules into a single combined module for; optimization. With ""thin"", :doc:`ThinLTO <../ThinLTO>`; compilation is invoked instead. .. note::. On Darwin, when using :option:`-flto` along with :option:`-g` and; compiling and linking in separate steps, you also need to pass; ``-Wl,-object_path_lto,<lto-filename>.o`` at the linking step to instruct the; ld64 linker not to delete the temporary object file generated during Link; Time Optimization (this flag is automatically passed to the linker by Clang; if compilation and linking are done in a single step). This allows debu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:15532,Performance,optimiz,optimization,15532,"l. .. option:: -fcommon, -fno-common. This flag specifies that variables without initializers get common linkage.; It can be disabled with :option:`-fno-common`. .. option:: -ftls-model=<model>. Set the default thread-local storage (TLS) model to use for thread-local; variables. Valid values are: ""global-dynamic"", ""local-dynamic"",; ""initial-exec"" and ""local-exec"". The default is ""global-dynamic"". The default; model can be overridden with the tls_model attribute. The compiler will try; to choose a more efficient model if possible. .. option:: -flto, -flto=full, -flto=thin, -emit-llvm. Generate output files in LLVM formats, suitable for link time optimization.; When used with :option:`-S` this generates LLVM intermediate language; assembly files, otherwise this generates LLVM bitcode format object files; (which may be passed to the linker depending on the stage selection options). The default for :option:`-flto` is ""full"", in which the; LLVM bitcode is suitable for monolithic Link Time Optimization (LTO), where; the linker merges all such modules into a single combined module for; optimization. With ""thin"", :doc:`ThinLTO <../ThinLTO>`; compilation is invoked instead. .. note::. On Darwin, when using :option:`-flto` along with :option:`-g` and; compiling and linking in separate steps, you also need to pass; ``-Wl,-object_path_lto,<lto-filename>.o`` at the linking step to instruct the; ld64 linker not to delete the temporary object file generated during Link; Time Optimization (this flag is automatically passed to the linker by Clang; if compilation and linking are done in a single step). This allows debugging; the executable as well as generating the ``.dSYM`` bundle using :manpage:`dsymutil(1)`. Driver Options; ~~~~~~~~~~~~~~. .. option:: -###. Print (but do not run) the commands to run for this compilation. .. option:: --help. Display available options. .. option:: -Qunused-arguments. Do not emit any warnings for unused driver arguments. .. option:: -Wa,<args>. Pass ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:2036,Safety,avoid,avoids,2036,"d a "".i"" (for C), "".ii"" (for C++),; "".mi"" (for Objective-C), or "".mii"" (for Objective-C++) file. Parsing and Semantic Analysis; This stage parses the input file, translating preprocessor tokens into a; parse tree. Once in the form of a parse tree, it applies semantic; analysis to compute types for expressions as well and determine whether; the code is well formed. This stage is responsible for generating most of; the compiler warnings as well as parse errors. The output of this stage is; an ""Abstract Syntax Tree"" (AST). Code Generation and Optimization; This stage translates an AST into low-level intermediate code (known as; ""LLVM IR"") and ultimately to machine code. This phase is responsible for; optimizing the generated code and handling target-specific code generation.; The output of this stage is typically called a "".s"" file or ""assembly"" file. Clang also supports the use of an integrated assembler, in which the code; generator produces object files directly. This avoids the overhead of; generating the "".s"" file and of calling the target assembler. Assembler; This stage runs the target assembler to translate the output of the; compiler into a target object file. The output of this stage is typically; called a "".o"" file or ""object"" file. Linker; This stage runs the target linker to merge multiple object files into an; executable or dynamic library. The output of this stage is typically called; an ""a.out"", "".dylib"" or "".so"" file. :program:`Clang Static Analyzer`. The Clang Static Analyzer is a tool that scans source code to try to find bugs; through code analysis. This tool uses many parts of Clang and is built into; the same driver. Please see <https://clang-analyzer.llvm.org> for more details; on how to use the static analyzer. OPTIONS; -------. Stage Selection Options; ~~~~~~~~~~~~~~~~~~~~~~~. .. option:: -E. Run the preprocessor stage. .. option:: -fsyntax-only. Run the preprocessor, parser and semantic analysis stages. .. option:: -S. Run the previous stages a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:12185,Safety,redund,redundant,12185," Like :option:`-O2` with extra optimizations to reduce code; size. :option:`-Oz` Like :option:`-Os` (and thus :option:`-O2`), but reduces code; size further. :option:`-Og` Like :option:`-O1`. In future versions, this option might; disable different optimizations in order to improve debuggability. :option:`-O` Equivalent to :option:`-O1`. :option:`-O4` and higher. Currently equivalent to :option:`-O3`. .. option:: -g, -gline-tables-only, -gmodules. Control debug information output. Note that Clang debug information works; best at :option:`-O0`. When more than one option starting with `-g` is; specified, the last one wins:. :option:`-g` Generate debug information. :option:`-gline-tables-only` Generate only line table debug information. This; allows for symbolicated backtraces with inlining information, but does not; include any information about variables, their locations or types. :option:`-gmodules` Generate debug information that contains external; references to types defined in Clang modules or precompiled headers instead; of emitting redundant debug type information into every object file. This; option transparently switches the Clang module format to object file; containers that hold the Clang module together with the debug information.; When compiling a program that uses Clang modules or precompiled headers,; this option produces complete debug information with faster compile; times and much smaller object files. This option should not be used when building static libraries for; distribution to other machines because the debug info will contain; references to the module cache on the machine the object files in the; library were built on. .. option:: -fstandalone-debug -fno-standalone-debug. Clang supports a number of optimizations to reduce the size of debug; information in the binary. They work based on the assumption that the; debug type information can be spread out over multiple compilation units.; For instance, Clang will not emit type definitions for types",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:14328,Safety,detect,detect,14328," the class. The :option:`-fstandalone-debug` option turns off these optimizations.; This is useful when working with 3rd-party libraries that don't come with; debug information. This is the default on Darwin. Note that Clang will; never emit type information for types that are not referenced at all by the; program. .. option:: -feliminate-unused-debug-types. By default, Clang does not emit type information for types that are defined; but not used in a program. To retain the debug info for these unused types,; the negation **-fno-eliminate-unused-debug-types** can be used. .. option:: -fexceptions. Allow exceptions to be thrown through Clang compiled stack frames (on many; targets, this will enable unwind information for functions that might have; an exception thrown through them). For most targets, this is enabled by; default for C++. .. option:: -ftrapv. Generate code to catch integer overflow errors. Signed integer overflow is; undefined in C. With this flag, extra code is generated to detect this and; abort when it happens. .. option:: -fvisibility. This flag sets the default visibility level. .. option:: -fcommon, -fno-common. This flag specifies that variables without initializers get common linkage.; It can be disabled with :option:`-fno-common`. .. option:: -ftls-model=<model>. Set the default thread-local storage (TLS) model to use for thread-local; variables. Valid values are: ""global-dynamic"", ""local-dynamic"",; ""initial-exec"" and ""local-exec"". The default is ""global-dynamic"". The default; model can be overridden with the tls_model attribute. The compiler will try; to choose a more efficient model if possible. .. option:: -flto, -flto=full, -flto=thin, -emit-llvm. Generate output files in LLVM formats, suitable for link time optimization.; When used with :option:`-S` this generates LLVM intermediate language; assembly files, otherwise this generates LLVM bitcode format object files; (which may be passed to the linker depending on the stage selection options)",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:14345,Safety,abort,abort,14345," the class. The :option:`-fstandalone-debug` option turns off these optimizations.; This is useful when working with 3rd-party libraries that don't come with; debug information. This is the default on Darwin. Note that Clang will; never emit type information for types that are not referenced at all by the; program. .. option:: -feliminate-unused-debug-types. By default, Clang does not emit type information for types that are defined; but not used in a program. To retain the debug info for these unused types,; the negation **-fno-eliminate-unused-debug-types** can be used. .. option:: -fexceptions. Allow exceptions to be thrown through Clang compiled stack frames (on many; targets, this will enable unwind information for functions that might have; an exception thrown through them). For most targets, this is enabled by; default for C++. .. option:: -ftrapv. Generate code to catch integer overflow errors. Signed integer overflow is; undefined in C. With this flag, extra code is generated to detect this and; abort when it happens. .. option:: -fvisibility. This flag sets the default visibility level. .. option:: -fcommon, -fno-common. This flag specifies that variables without initializers get common linkage.; It can be disabled with :option:`-fno-common`. .. option:: -ftls-model=<model>. Set the default thread-local storage (TLS) model to use for thread-local; variables. Valid values are: ""global-dynamic"", ""local-dynamic"",; ""initial-exec"" and ""local-exec"". The default is ""global-dynamic"". The default; model can be overridden with the tls_model attribute. The compiler will try; to choose a more efficient model if possible. .. option:: -flto, -flto=full, -flto=thin, -emit-llvm. Generate output files in LLVM formats, suitable for link time optimization.; When used with :option:`-S` this generates LLVM intermediate language; assembly files, otherwise this generates LLVM bitcode format object files; (which may be passed to the linker depending on the stage selection options)",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst:20206,Testability,test,test,20206,"r which is read before the; source file is preprocessed. .. option:: -include <filename>. Adds an implicit #include into the predefines buffer which is read before the; source file is preprocessed. .. option:: -I<directory>. Add the specified directory to the search path for include files. .. option:: -F<directory>. Add the specified directory to the search path for framework include files. .. option:: -nostdinc. Do not search the standard system directories or compiler builtin directories; for include files. .. option:: -nostdlibinc. Do not search the standard system directories for include files, but do; search compiler builtin include directories. .. option:: -nobuiltininc. Do not search clang's builtin directory for include files. .. option:: -fkeep-system-includes. Usable only with :option:`-E`. Do not copy the preprocessed content of; ""system"" headers to the output; instead, preserve the #include directive.; This can greatly reduce the volume of text produced by :option:`-E` which; can be helpful when trying to produce a ""small"" reproduceable test case. This option does not guarantee reproduceability, however. If the including; source defines preprocessor symbols that influence the behavior of system; headers (for example, ``_XOPEN_SOURCE``) the operation of :option:`-E` will; remove that definition and thus can change the semantics of the included; header. Also, using a different version of the system headers (especially a; different version of the STL) may result in different behavior. Always verify; the preprocessed file by compiling it separately. ENVIRONMENT; -----------. .. envvar:: TMPDIR, TEMP, TMP. These environment variables are checked, in order, for the location to write; temporary files used during the compilation process. .. envvar:: CPATH. If this environment variable is present, it is treated as a delimited list of; paths to be added to the default system include path list. The delimiter is; the platform dependent delimiter, as used in the PATH ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/clang.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/clang.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/index.rst:253,Availability,avail,available,253,"Clang ""man"" pages; -----------------. The following documents are command descriptions for all of the Clang tools.; These pages describe how to use the Clang commands and what their options are.; Note that these pages do not describe all of the options available for all; tools. To get a complete listing, pass the ``--help`` (general options) or; ``--help-hidden`` (general and debugging options) arguments to the tool you are; interested in. Basic Commands; ~~~~~~~~~~~~~~. .. toctree::; :maxdepth: 1. clang; diagtool; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/CommandGuide/index.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/CommandGuide/index.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/EntryFunctions.rst:1802,Deployability,pipeline,pipeline,1802,"tions can be called from other parts of the shader, which has; implications on code generation. Implementation Details; ======================. In Clang, the DXC ``/E`` option is translated to the cc1 flag ``-hlsl-entry``,; which in turn applies the ``HLSLShader`` attribute to the function with the; specified name. This allows code generation for entry functions to always key; off the presence of the ``HLSLShader`` attribute, regardless of what shader; profile you are compiling. In code generation, two functions are generated. One is the user defined; function, which is code generated as a mangled C++ function with internal; linkage following normal function code generation. The actual exported entry function which can be called by the GPU driver is a; ``void(void)`` function that isn't name mangled. In code generation we generate; the unmangled entry function to serve as the actual shader entry. The shader; entry function is annotated with the ``hlsl.shader`` function attribute; identifying the entry's pipeline stage. The body of the unmangled entry function contains first a call to execute global; constructors, then instantiations of the user-defined entry parameters with; their semantic values populated, and a call to the user-defined function.; After the call instruction the return value (if any) is saved using a; target-appropriate intrinsic for storing outputs (for DirectX, the; ``llvm.dx.store.output``). Lastly, any present global destructors will be called; immediately before the return. HLSL does not support C++ ``atexit``; registrations, instead calls to global destructors are compile-time generated. .. note::. HLSL support in Clang is currently focused on compute shaders, which do not; support output semantics. Support for output semantics will not be; implemented until other shader profiles are supported. Below is example IR that represents the planned implementation, subject to; change as the ``llvm.dx.store.output`` and ``llvm.dx.load.input`` intrinsic",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HLSL/EntryFunctions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/EntryFunctions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/EntryFunctions.rst:2761,Performance,load,load,2761,"HLSLShader`` attribute to the function with the; specified name. This allows code generation for entry functions to always key; off the presence of the ``HLSLShader`` attribute, regardless of what shader; profile you are compiling. In code generation, two functions are generated. One is the user defined; function, which is code generated as a mangled C++ function with internal; linkage following normal function code generation. The actual exported entry function which can be called by the GPU driver is a; ``void(void)`` function that isn't name mangled. In code generation we generate; the unmangled entry function to serve as the actual shader entry. The shader; entry function is annotated with the ``hlsl.shader`` function attribute; identifying the entry's pipeline stage. The body of the unmangled entry function contains first a call to execute global; constructors, then instantiations of the user-defined entry parameters with; their semantic values populated, and a call to the user-defined function.; After the call instruction the return value (if any) is saved using a; target-appropriate intrinsic for storing outputs (for DirectX, the; ``llvm.dx.store.output``). Lastly, any present global destructors will be called; immediately before the return. HLSL does not support C++ ``atexit``; registrations, instead calls to global destructors are compile-time generated. .. note::. HLSL support in Clang is currently focused on compute shaders, which do not; support output semantics. Support for output semantics will not be; implemented until other shader profiles are supported. Below is example IR that represents the planned implementation, subject to; change as the ``llvm.dx.store.output`` and ``llvm.dx.load.input`` intrinsics are; not yet implemented. .. code-block:: none. ; Function Attrs: norecurse; define void @main() #1 {; entry:; %0 = call i32 @llvm.dx.load.input.i32(...); %1 = call i32 @""?main@@YAXII@Z""(i32 %0); call @llvm.dx.store.output.i32(%1, ...); ret void; }. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HLSL/EntryFunctions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/EntryFunctions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/EntryFunctions.rst:2919,Performance,load,load,2919,"HLSLShader`` attribute to the function with the; specified name. This allows code generation for entry functions to always key; off the presence of the ``HLSLShader`` attribute, regardless of what shader; profile you are compiling. In code generation, two functions are generated. One is the user defined; function, which is code generated as a mangled C++ function with internal; linkage following normal function code generation. The actual exported entry function which can be called by the GPU driver is a; ``void(void)`` function that isn't name mangled. In code generation we generate; the unmangled entry function to serve as the actual shader entry. The shader; entry function is annotated with the ``hlsl.shader`` function attribute; identifying the entry's pipeline stage. The body of the unmangled entry function contains first a call to execute global; constructors, then instantiations of the user-defined entry parameters with; their semantic values populated, and a call to the user-defined function.; After the call instruction the return value (if any) is saved using a; target-appropriate intrinsic for storing outputs (for DirectX, the; ``llvm.dx.store.output``). Lastly, any present global destructors will be called; immediately before the return. HLSL does not support C++ ``atexit``; registrations, instead calls to global destructors are compile-time generated. .. note::. HLSL support in Clang is currently focused on compute shaders, which do not; support output semantics. Support for output semantics will not be; implemented until other shader profiles are supported. Below is example IR that represents the planned implementation, subject to; change as the ``llvm.dx.store.output`` and ``llvm.dx.load.input`` intrinsics are; not yet implemented. .. code-block:: none. ; Function Attrs: norecurse; define void @main() #1 {; entry:; %0 = call i32 @llvm.dx.load.input.i32(...); %1 = call i32 @""?main@@YAXII@Z""(i32 %0); call @llvm.dx.store.output.i32(%1, ...); ret void; }. ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HLSL/EntryFunctions.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/EntryFunctions.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/FunctionCalls.rst:3248,Integrability,depend,depends,3248,"zing parameters. Implementations are allowed to avoid unnecessary temporaries, and HLSL's strict; no-alias rules can enable some trivial optimizations. Array Temporaries; -----------------. Given the following example:. .. code-block:: c++. void fn(float a[4]) {; a[0] = a[1] + a[2] + a[3];; }. float4 main() : SV_Target {; float arr[4] = {1, 1, 1, 1};; fn(arr);; return float4(arr[0], arr[1], arr[2], arr[3]);; }. In C or C++, the array parameter decays to a pointer, so after the call to; ``fn``, the value of ``arr[0]`` is ``3``. In HLSL, the array is passed by value,; so modifications inside ``fn`` do not propagate out. .. note::. DXC may pass unsized arrays directly as decayed pointers, which is an; unfortunate behavior divergence. Out Parameter Temporaries; -------------------------. .. code-block:: c++. void Init(inout int X, inout int Y) {; Y = 2;; X = 1;; }. void main() {; int V;; Init(V, V); // MSVC (or clang-cl) V == 2, Clang V == 1; }. In the above example the ``Init`` function's behavior depends on the C++; implementation. C++ does not define the order in which parameters are; initialized or destroyed. In MSVC and Clang's MSVC compatibility mode, arguments; are emitted right-to-left and destroyed left-to-right. This means that the; parameter initialization and destruction occurs in the order: {``Y``, ``X``,; ``~X``, ``~Y``}. This causes the write-back of the value of ``Y`` to occur last,; so the resulting value of ``V`` is ``2``. In the Itanium C++ ABI, the parameter; ordering is reversed, so the initialization and destruction occurs in the order:; {``X``, ``Y``, ``~Y``, ``X``}. This causes the write-back of the value ``X`` to; occur last, resulting in the value of ``V`` being set to ``1``. .. code-block:: c++. void Trunc(inout int3 V) { }. void main() {; float3 F = {1.5, 2.6, 3.3};; Trunc(F); // F == {1.0, 2.0, 3.0}; }. In the above example, the argument expression ``F`` undergoes element-wise; conversion from a float vector to an integer vector to create a ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HLSL/FunctionCalls.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/FunctionCalls.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/FunctionCalls.rst:5797,Integrability,depend,depends,5797,"nitialized. In this case; the argument is not initialized in the function so the temporary is still; uninitialized when it is copied back to the argument expression. This is; undefined behavior in HLSL, and any use of the argument after the call is a use; of an undefined value which may be illegal in the target (DXIL programs with; used or potentially used ``undef`` or ``poison`` values fail validation). Clang Implementation; ====================. .. note::. The implementation described here is a proposal. It has not yet been fully; implemented, so the current state of Clang's sources may not reflect this; design. A prototype implementation was built on DXC which is Clang-3.7 based.; The prototype can be found; `here <https://github.com/microsoft/DirectXShaderCompiler/pull/5249>`_. A lot; of the changes in the prototype implementation are restoring Clang-3.7 code; that was previously modified to its original state. The implementation in clang depends on two new AST nodes and minor extensions to; Clang's existing support for Objective-C write-back arguments. The goal of this; design is to capture the semantic details of HLSL function calls in the AST, and; minimize the amount of magic that needs to occur during IR generation. The two new AST nodes are ``HLSLArrayTemporaryExpr`` and ``HLSLOutParamExpr``,; which respectively represent the temporaries used for passing arrays by value; and the temporaries created for function outputs. Array Temporaries; -----------------. The ``HLSLArrayTemporaryExpr`` represents temporary values for input; constant-sized array arguments. This applies for all constant-sized array; arguments regardless of whether or not the parameter is constant-sized or; unsized. .. code-block:: c++. void SizedArray(float a[4]);; void UnsizedArray(float a[]);. void main() {; float arr[4] = {1, 1, 1, 1};; SizedArray(arr);; UnsizedArray(arr);; }. In the example above, the following AST is generated for the call to; ``SizedArray``:. .. code-block:: text. Cal",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HLSL/FunctionCalls.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/FunctionCalls.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/FunctionCalls.rst:10984,Modifiability,extend,extending,10984,"pected AST formulation for this code would be something like:. .. code-block:: text. CallExpr 'void'; |-ImplicitCastExpr 'void (*)(int &)' <FunctionToPointerDecay>; | `-DeclRefExpr 'void (int &)' lvalue Function 'Init' 'void (int &)'; |-HLSLOutParamExpr 'int' lvalue inout; `-DeclRefExpr 'int' lvalue Var 'V' 'int'. The ``HLSLOutParamExpr`` captures that the value is ``inout`` vs ``out`` to; denote whether or not the temporary is initialized from the sub-expression. If; no casting is required the sub-expression denotes the lvalue expression that the; cx-value will be copied to when the value expires. The two sub-expression form of the AST node is required when the argument type; is not the same as the parameter type. Given this example:. .. code-block:: c++. void Trunc(inout int3 V) { }. void main() {; float3 F = {1.5, 2.6, 3.3};; Trunc(F);; }. For this case the ``HLSLOutParamExpr`` will have sub-expressions to record both; casting expression sequences for the initialization and write back:. .. code-block:: text. -CallExpr 'void'; |-ImplicitCastExpr 'void (*)(int3 &)' <FunctionToPointerDecay>; | `-DeclRefExpr 'void (int3 &)' lvalue Function 'inc_i32' 'void (int3 &)'; `-HLSLOutParamExpr 'int3' lvalue inout; |-ImplicitCastExpr 'float3' <IntegralToFloating>; | `-ImplicitCastExpr 'int3' <LValueToRValue>; | `-OpaqueValueExpr 'int3' lvalue; `-ImplicitCastExpr 'int3' <FloatingToIntegral>; `-ImplicitCastExpr 'float3' <LValueToRValue>; `-DeclRefExpr 'float3' lvalue 'F' 'float3'. In this formation the write-back casts are captured as the first sub-expression; and they cast from an ``OpaqueValueExpr``. In IR generation we can use the; ``OpaqueValueExpr`` as a placeholder for the ``HLSLOutParamExpr``'s temporary; value on function return. In code generation this can be implemented with some targeted extensions to the; Objective-C write-back support. Specifically extending CGCall.cpp's; ``EmitWriteback`` function to support casting expressions and emission of; aggregate lvalues.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HLSL/FunctionCalls.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/FunctionCalls.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/FunctionCalls.rst:2375,Performance,optimiz,optimizations,2375,"alue is then passed by-address. For; output-only parameters, the temporary is uninitialized when passed (if the; parameter is not explicitly initialized inside the function an undefined value; is stored back to the argument expression). For parameters that are both input; and output, the temporary is initialized from the lvalue argument expression; through implicit or explicit casting from the lvalue argument type to the; parameter type. On return of the function, the values of any parameter temporaries are written; back to the argument expression through an inverted conversion sequence (if an; ``out`` parameter was not initialized in the function, the uninitialized value; may be written back). Parameters of constant-sized array type are also passed with value semantics.; This requires input parameters of arrays to construct temporaries and the; temporaries go through array-to-pointer decay when initializing parameters. Implementations are allowed to avoid unnecessary temporaries, and HLSL's strict; no-alias rules can enable some trivial optimizations. Array Temporaries; -----------------. Given the following example:. .. code-block:: c++. void fn(float a[4]) {; a[0] = a[1] + a[2] + a[3];; }. float4 main() : SV_Target {; float arr[4] = {1, 1, 1, 1};; fn(arr);; return float4(arr[0], arr[1], arr[2], arr[3]);; }. In C or C++, the array parameter decays to a pointer, so after the call to; ``fn``, the value of ``arr[0]`` is ``3``. In HLSL, the array is passed by value,; so modifications inside ``fn`` do not propagate out. .. note::. DXC may pass unsized arrays directly as decayed pointers, which is an; unfortunate behavior divergence. Out Parameter Temporaries; -------------------------. .. code-block:: c++. void Init(inout int X, inout int Y) {; Y = 2;; X = 1;; }. void main() {; int V;; Init(V, V); // MSVC (or clang-cl) V == 2, Clang V == 1; }. In the above example the ``Init`` function's behavior depends on the C++; implementation. C++ does not define the order in which",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HLSL/FunctionCalls.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/FunctionCalls.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/FunctionCalls.rst:2286,Safety,avoid,avoid,2286,"alue is then passed by-address. For; output-only parameters, the temporary is uninitialized when passed (if the; parameter is not explicitly initialized inside the function an undefined value; is stored back to the argument expression). For parameters that are both input; and output, the temporary is initialized from the lvalue argument expression; through implicit or explicit casting from the lvalue argument type to the; parameter type. On return of the function, the values of any parameter temporaries are written; back to the argument expression through an inverted conversion sequence (if an; ``out`` parameter was not initialized in the function, the uninitialized value; may be written back). Parameters of constant-sized array type are also passed with value semantics.; This requires input parameters of arrays to construct temporaries and the; temporaries go through array-to-pointer decay when initializing parameters. Implementations are allowed to avoid unnecessary temporaries, and HLSL's strict; no-alias rules can enable some trivial optimizations. Array Temporaries; -----------------. Given the following example:. .. code-block:: c++. void fn(float a[4]) {; a[0] = a[1] + a[2] + a[3];; }. float4 main() : SV_Target {; float arr[4] = {1, 1, 1, 1};; fn(arr);; return float4(arr[0], arr[1], arr[2], arr[3]);; }. In C or C++, the array parameter decays to a pointer, so after the call to; ``fn``, the value of ``arr[0]`` is ``3``. In HLSL, the array is passed by value,; so modifications inside ``fn`` do not propagate out. .. note::. DXC may pass unsized arrays directly as decayed pointers, which is an; unfortunate behavior divergence. Out Parameter Temporaries; -------------------------. .. code-block:: c++. void Init(inout int X, inout int Y) {; Y = 2;; X = 1;; }. void main() {; int V;; Init(V, V); // MSVC (or clang-cl) V == 2, Clang V == 1; }. In the above example the ``Init`` function's behavior depends on the C++; implementation. C++ does not define the order in which",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HLSL/FunctionCalls.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/FunctionCalls.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/FunctionCalls.rst:5235,Security,validat,validation,5235,"gument expression ``F`` undergoes element-wise; conversion from a float vector to an integer vector to create a temporary; ``int3``. On expiration the temporary undergoes elementwise conversion back to; the floating point vector type ``float3``. This results in an implicit; element-wise conversion of the vector even if the value is unused in the; function (effectively truncating the floating point values). .. code-block:: c++. void UB(out int X) {}. void main() {; int X = 7;; UB(X); // X is undefined!; }. In this example an initialized value is passed to an ``out`` parameter.; Parameters marked ``out`` are not initialized by the argument expression or; implicitly by the function. They must be explicitly initialized. In this case; the argument is not initialized in the function so the temporary is still; uninitialized when it is copied back to the argument expression. This is; undefined behavior in HLSL, and any use of the argument after the call is a use; of an undefined value which may be illegal in the target (DXIL programs with; used or potentially used ``undef`` or ``poison`` values fail validation). Clang Implementation; ====================. .. note::. The implementation described here is a proposal. It has not yet been fully; implemented, so the current state of Clang's sources may not reflect this; design. A prototype implementation was built on DXC which is Clang-3.7 based.; The prototype can be found; `here <https://github.com/microsoft/DirectXShaderCompiler/pull/5249>`_. A lot; of the changes in the prototype implementation are restoring Clang-3.7 code; that was previously modified to its original state. The implementation in clang depends on two new AST nodes and minor extensions to; Clang's existing support for Objective-C write-back arguments. The goal of this; design is to capture the semantic details of HLSL function calls in the AST, and; minimize the amount of magic that needs to occur during IR generation. The two new AST nodes are ``HLSLArrayTemp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HLSL/FunctionCalls.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/FunctionCalls.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLIRReference.rst:376,Modifiability,variab,variables,376,"=================; HLSL IR Reference; =================. .. contents::; :local:. Introduction; ============. The goal of this document is to provide a reference for all the special purpose; IR metadata and attributes used by the HLSL code generation path. IR Metadata; ===========. ``hlsl.uavs``; -------------. The ``hlsl.uavs`` metadata is a list of all the external global variables that; represent UAV resources. Function Attributes; ===================. ``hlsl.shader``; ---------------. The ``hlsl.shader`` function attribute is a string attribute applied to entry; functions. The value is the string representation of the shader stage (i.e.; ``compute``, ``pixel``, etc).; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HLSL/HLSLIRReference.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLIRReference.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst:1330,Availability,mainten,maintenance,1330,"asies of the HLSL language and how we intend to support them in; Clang. Project Goals; =============. The long term goal of this project is to enable Clang to function as a; replacement for the `DirectXShaderCompiler (DXC); <https://github.com/microsoft/DirectXShaderCompiler/>`_ in all its supported; use cases. Accomplishing that goal will require Clang to be able to process most; existing HLSL programs with a high degree of source compatibility. Non-Goals; ---------. HLSL ASTs do not need to be compatible between DXC and Clang. We do not expect; identical code generation or that features will resemble DXC's implementation or; architecture. In fact, we explicitly expect to deviate from DXC's implementation; in key ways. Guiding Principles; ==================. This document lacks details for architectural decisions that are not yet; finalized. Our top priorities are quality, maintainability, and flexibility. In; accordance with community standards we are expecting a high level of test; coverage, and we will engineer our solutions with long term maintenance in mind.; We are also working to limit modifications to the Clang C++ code paths and; share as much functionality as possible. Architectural Direction; =======================. HLSL support in Clang is expressed as C++ minus unsupported C and C++ features.; This is different from how other Clang languages are implemented. Most languages; in Clang are additive on top of C. HLSL is not a formally or fully specified language, and while our goals require; a high level of source compatibility, implementations can vary and we have some; flexibility to be more or less permissive in some cases. For modern HLSL DXC is; the reference implementation. The HLSL effort prioritizes following similar patterns for other languages,; drivers, runtimes and targets. Specifically, We will maintain separation between; HSLS-specific code and the rest of Clang as much as possible following patterns; in use in Clang code today (i.e. ParseHL",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst:2694,Availability,mainten,maintenance,2694,"; in Clang are additive on top of C. HLSL is not a formally or fully specified language, and while our goals require; a high level of source compatibility, implementations can vary and we have some; flexibility to be more or less permissive in some cases. For modern HLSL DXC is; the reference implementation. The HLSL effort prioritizes following similar patterns for other languages,; drivers, runtimes and targets. Specifically, We will maintain separation between; HSLS-specific code and the rest of Clang as much as possible following patterns; in use in Clang code today (i.e. ParseHLSL.cpp, SemaHLSL.cpp, CGHLSL*.cpp...).; We will use inline checks on language options where the code is simple and; isolated, and prefer HLSL-specific implementation files for any code of; reasonable complexity. In places where the HLSL language is in conflict with C and C++, we will seek to; make minimally invasive changes guarded under the HLSL language options. We will; seek to make HLSL language support as minimal a maintenance burden as possible. DXC Driver; ----------. A DXC driver mode will provide command-line compatibility with DXC, supporting; DXC's options and flags. The DXC driver is HLSL-specific and will create an; HLSLToolchain which will provide the basis to support targeting both DirectX and; Vulkan. Parser; ------. Following the examples of other parser extensions HLSL will add a ParseHLSL.cpp; file to contain the implementations of HLSL-specific extensions to the Clang; parser. The HLSL grammar shares most of its structure with C and C++, so we will; use the existing C/C++ parsing code paths. Sema; ----. HLSL's Sema implementation will also provide an ``ExternalSemaSource``. In DXC,; an ``ExternalSemaSource`` is used to provide definitions for HLSL built-in data; types and built-in templates. Clang is already designed to allow an attached; ``ExternalSemaSource`` to lazily complete data types, which is a **huge**; performance win for HLSL. If precompiled headers are used",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst:5130,Availability,avail,available,5130,"tions and connect the de-serialized decls as the previous; declaration. CodeGen; -------. Like OpenCL, HLSL relies on capturing a lot of information into IR metadata.; *hand wave* *hand wave* *hand wave* As a design principle here we want our IR to; be idiomatic Clang IR as much as possible. We will use IR attributes wherever we; can, and use metadata as sparingly as possible. One example of a difference from; DXC already implemented in Clang is the use of target triples to communicate; shader model versions and shader stages. Our HLSL CodeGen implementation should also have an eye toward generating IR; that will map directly to targets other than DXIL. While IR itself is generally; not re-targetable, we want to share the Clang CodeGen implementation for HLSL; with other GPU graphics targets like SPIR-V and possibly other GPU and even CPU; targets. HLSL Language; =============. The HLSL language is insufficiently documented, and not formally specified.; Documentation is available on `Microsoft's website; <https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl>`_.; The language syntax is similar enough to C and C++ that carefully written C and; C++ code is valid HLSL. HLSL has some key differences from C & C++ which we will; need to handle in Clang. HLSL is not a conforming or valid extension or superset of C or C++. The; language has key incompatibilities with C and C++, both syntactically and; semantically. An Aside on GPU Languages; -------------------------. Due to HLSL being a GPU targeted language HLSL is a Single Program Multiple Data; (SPMD) language relying on the implicit parallelism provided by GPU hardware.; Some language features in HLSL enable programmers to take advantage of the; parallel nature of GPUs in a hardware abstracted language. HLSL also prohibits some features of C and C++ which can have catastrophic; performance or are not widely supportable on GPU hardware or drivers. As an; example, register spilling is often excessi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst:7162,Availability,mask,mask,7162," on GPUs, so HLSL; requires all functions to be inlined during code generation, and does not; support a runtime calling convention. Pointers & References; ---------------------. HLSL does not support referring to values by address. Semantically all variables; are value-types and behave as such. HLSL disallows the pointer dereference; operators (unary ``*``, and ``->``), as well as the address of operator (unary; &). While HLSL disallows pointers and references in the syntax, HLSL does use; reference types in the AST, and we intend to use pointer decay in the AST in; the Clang implementation. HLSL ``this`` Keyword; ---------------------. HLSL does support member functions, and (in HLSL 2021) limited operator; overloading. With member function support, HLSL also has a ``this`` keyword. The; ``this`` keyword is an example of one of the places where HLSL relies on; references in the AST, because ``this`` is a reference. Bitshifts; ---------. In deviation from C, HLSL bitshifts are defined to mask the shift count by the; size of the type. In DXC, the semantics of LLVM IR were altered to accommodate; this, in Clang we intend to generate the mask explicitly in the IR. In cases; where the shift value is constant, this will be constant folded appropriately,; in other cases we can clean it up in the DXIL target. Non-short Circuiting Logical Operators; --------------------------------------. In HLSL 2018 and earlier, HLSL supported logical operators (and the ternary; operator) on vector types. This behavior required that operators not short; circuit. The non-short circuiting behavior applies to all data types until HLSL; 2021. In HLSL 2021, logical and ternary operators do not support vector types; instead builtin functions ``and``, ``or`` and ``select`` are available, and; operators short circuit matching C behavior. Precise Qualifier; -----------------. HLSL has a ``precise`` qualifier that behaves unlike anything else in the C; language. The support for this qualifier in DX",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst:7312,Availability,mask,mask,7312,"lling convention. Pointers & References; ---------------------. HLSL does not support referring to values by address. Semantically all variables; are value-types and behave as such. HLSL disallows the pointer dereference; operators (unary ``*``, and ``->``), as well as the address of operator (unary; &). While HLSL disallows pointers and references in the syntax, HLSL does use; reference types in the AST, and we intend to use pointer decay in the AST in; the Clang implementation. HLSL ``this`` Keyword; ---------------------. HLSL does support member functions, and (in HLSL 2021) limited operator; overloading. With member function support, HLSL also has a ``this`` keyword. The; ``this`` keyword is an example of one of the places where HLSL relies on; references in the AST, because ``this`` is a reference. Bitshifts; ---------. In deviation from C, HLSL bitshifts are defined to mask the shift count by the; size of the type. In DXC, the semantics of LLVM IR were altered to accommodate; this, in Clang we intend to generate the mask explicitly in the IR. In cases; where the shift value is constant, this will be constant folded appropriately,; in other cases we can clean it up in the DXIL target. Non-short Circuiting Logical Operators; --------------------------------------. In HLSL 2018 and earlier, HLSL supported logical operators (and the ternary; operator) on vector types. This behavior required that operators not short; circuit. The non-short circuiting behavior applies to all data types until HLSL; 2021. In HLSL 2021, logical and ternary operators do not support vector types; instead builtin functions ``and``, ``or`` and ``select`` are available, and; operators short circuit matching C behavior. Precise Qualifier; -----------------. HLSL has a ``precise`` qualifier that behaves unlike anything else in the C; language. The support for this qualifier in DXC is buggy, so our bar for; compatibility is low. The ``precise`` qualifier applies in the inverse direction from ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst:7937,Availability,avail,available,7937,"er function support, HLSL also has a ``this`` keyword. The; ``this`` keyword is an example of one of the places where HLSL relies on; references in the AST, because ``this`` is a reference. Bitshifts; ---------. In deviation from C, HLSL bitshifts are defined to mask the shift count by the; size of the type. In DXC, the semantics of LLVM IR were altered to accommodate; this, in Clang we intend to generate the mask explicitly in the IR. In cases; where the shift value is constant, this will be constant folded appropriately,; in other cases we can clean it up in the DXIL target. Non-short Circuiting Logical Operators; --------------------------------------. In HLSL 2018 and earlier, HLSL supported logical operators (and the ternary; operator) on vector types. This behavior required that operators not short; circuit. The non-short circuiting behavior applies to all data types until HLSL; 2021. In HLSL 2021, logical and ternary operators do not support vector types; instead builtin functions ``and``, ``or`` and ``select`` are available, and; operators short circuit matching C behavior. Precise Qualifier; -----------------. HLSL has a ``precise`` qualifier that behaves unlike anything else in the C; language. The support for this qualifier in DXC is buggy, so our bar for; compatibility is low. The ``precise`` qualifier applies in the inverse direction from normal; qualifiers. Rather than signifying that the declaration containing ``precise``; qualifier be precise, it signifies that the operations contributing to the; declaration's value be ``precise``. Additionally, ``precise`` is a misnomer:; values attributed as ``precise`` comply with IEEE-754 floating point semantics,; and are prevented from optimizations which could decrease *or increase*; precision. Differences in Templates; ------------------------. HLSL uses templates to define builtin types and methods, but disallowed; user-defined templates until HLSL 2021. HLSL also allows omitting empty template; parameter lis",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst:9935,Availability,error,errors,9935,"imizations which could decrease *or increase*; precision. Differences in Templates; ------------------------. HLSL uses templates to define builtin types and methods, but disallowed; user-defined templates until HLSL 2021. HLSL also allows omitting empty template; parameter lists when all template parameters are defaulted. This is an ambiguous; syntax in C++, but Clang detects the case and issues a diagnostic. This makes; supporting the case in Clang minimally invasive. Vector Extensions; -----------------. HLSL uses the OpenCL vector extensions, and also provides C++-style constructors; for vectors that are not supported by Clang. Standard Library; ----------------. HLSL does not support the C or C++ standard libraries. Like OpenCL, HLSL; describes its own library of built in types, complex data types, and functions. Unsupported C & C++ Features; ----------------------------. HLSL does not support all features of C and C++. In implementing HLSL in Clang; use of some C and C++ features will produce diagnostics under HLSL, and others; will be supported as language extensions. In general, any C or C++ feature that; can be supported by the DXIL and SPIR-V code generation targets could be treated; as a clang HLSL extension. Features that cannot be lowered to DXIL or SPIR-V,; must be diagnosed as errors. HLSL does not support the following C features:. * Pointers; * References; * ``goto`` or labels; * Variable Length Arrays; * ``_Complex`` and ``_Imaginary``; * C Threads or Atomics (or Obj-C blocks); * ``union`` types `(in progress for HLSL 202x) <https://github.com/microsoft/DirectXShaderCompiler/pull/4132>`_; * Most features C11 and later. HLSL does not support the following C++ features:. * RTTI; * Exceptions; * Multiple inheritance; * Access specifiers; * Anonymous or inline namespaces; * ``new`` & ``delete`` operators in all of their forms (array, placement, etc); * Constructors and destructors; * Any use of the ``virtual`` keyword; * Most features C++11 and later; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst:1157,Modifiability,maintainab,maintainability,1157," This document; describes the high level goals of the project, the guiding principles, as well; as some idiosyncrasies of the HLSL language and how we intend to support them in; Clang. Project Goals; =============. The long term goal of this project is to enable Clang to function as a; replacement for the `DirectXShaderCompiler (DXC); <https://github.com/microsoft/DirectXShaderCompiler/>`_ in all its supported; use cases. Accomplishing that goal will require Clang to be able to process most; existing HLSL programs with a high degree of source compatibility. Non-Goals; ---------. HLSL ASTs do not need to be compatible between DXC and Clang. We do not expect; identical code generation or that features will resemble DXC's implementation or; architecture. In fact, we explicitly expect to deviate from DXC's implementation; in key ways. Guiding Principles; ==================. This document lacks details for architectural decisions that are not yet; finalized. Our top priorities are quality, maintainability, and flexibility. In; accordance with community standards we are expecting a high level of test; coverage, and we will engineer our solutions with long term maintenance in mind.; We are also working to limit modifications to the Clang C++ code paths and; share as much functionality as possible. Architectural Direction; =======================. HLSL support in Clang is expressed as C++ minus unsupported C and C++ features.; This is different from how other Clang languages are implemented. Most languages; in Clang are additive on top of C. HLSL is not a formally or fully specified language, and while our goals require; a high level of source compatibility, implementations can vary and we have some; flexibility to be more or less permissive in some cases. For modern HLSL DXC is; the reference implementation. The HLSL effort prioritizes following similar patterns for other languages,; drivers, runtimes and targets. Specifically, We will maintain separation between; HSLS-spe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst:6408,Modifiability,variab,variables,6408,"dle in Clang. HLSL is not a conforming or valid extension or superset of C or C++. The; language has key incompatibilities with C and C++, both syntactically and; semantically. An Aside on GPU Languages; -------------------------. Due to HLSL being a GPU targeted language HLSL is a Single Program Multiple Data; (SPMD) language relying on the implicit parallelism provided by GPU hardware.; Some language features in HLSL enable programmers to take advantage of the; parallel nature of GPUs in a hardware abstracted language. HLSL also prohibits some features of C and C++ which can have catastrophic; performance or are not widely supportable on GPU hardware or drivers. As an; example, register spilling is often excessively expensive on GPUs, so HLSL; requires all functions to be inlined during code generation, and does not; support a runtime calling convention. Pointers & References; ---------------------. HLSL does not support referring to values by address. Semantically all variables; are value-types and behave as such. HLSL disallows the pointer dereference; operators (unary ``*``, and ``->``), as well as the address of operator (unary; &). While HLSL disallows pointers and references in the syntax, HLSL does use; reference types in the AST, and we intend to use pointer decay in the AST in; the Clang implementation. HLSL ``this`` Keyword; ---------------------. HLSL does support member functions, and (in HLSL 2021) limited operator; overloading. With member function support, HLSL also has a ``this`` keyword. The; ``this`` keyword is an example of one of the places where HLSL relies on; references in the AST, because ``this`` is a reference. Bitshifts; ---------. In deviation from C, HLSL bitshifts are defined to mask the shift count by the; size of the type. In DXC, the semantics of LLVM IR were altered to accommodate; this, in Clang we intend to generate the mask explicitly in the IR. In cases; where the shift value is constant, this will be constant folded appropria",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst:10371,Modifiability,inherit,inheritance,10371,"imizations which could decrease *or increase*; precision. Differences in Templates; ------------------------. HLSL uses templates to define builtin types and methods, but disallowed; user-defined templates until HLSL 2021. HLSL also allows omitting empty template; parameter lists when all template parameters are defaulted. This is an ambiguous; syntax in C++, but Clang detects the case and issues a diagnostic. This makes; supporting the case in Clang minimally invasive. Vector Extensions; -----------------. HLSL uses the OpenCL vector extensions, and also provides C++-style constructors; for vectors that are not supported by Clang. Standard Library; ----------------. HLSL does not support the C or C++ standard libraries. Like OpenCL, HLSL; describes its own library of built in types, complex data types, and functions. Unsupported C & C++ Features; ----------------------------. HLSL does not support all features of C and C++. In implementing HLSL in Clang; use of some C and C++ features will produce diagnostics under HLSL, and others; will be supported as language extensions. In general, any C or C++ feature that; can be supported by the DXIL and SPIR-V code generation targets could be treated; as a clang HLSL extension. Features that cannot be lowered to DXIL or SPIR-V,; must be diagnosed as errors. HLSL does not support the following C features:. * Pointers; * References; * ``goto`` or labels; * Variable Length Arrays; * ``_Complex`` and ``_Imaginary``; * C Threads or Atomics (or Obj-C blocks); * ``union`` types `(in progress for HLSL 202x) <https://github.com/microsoft/DirectXShaderCompiler/pull/4132>`_; * Most features C11 and later. HLSL does not support the following C++ features:. * RTTI; * Exceptions; * Multiple inheritance; * Access specifiers; * Anonymous or inline namespaces; * ``new`` & ``delete`` operators in all of their forms (array, placement, etc); * Constructors and destructors; * Any use of the ``virtual`` keyword; * Most features C++11 and later; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst:3624,Performance,perform,performance,3624,"ally invasive changes guarded under the HLSL language options. We will; seek to make HLSL language support as minimal a maintenance burden as possible. DXC Driver; ----------. A DXC driver mode will provide command-line compatibility with DXC, supporting; DXC's options and flags. The DXC driver is HLSL-specific and will create an; HLSLToolchain which will provide the basis to support targeting both DirectX and; Vulkan. Parser; ------. Following the examples of other parser extensions HLSL will add a ParseHLSL.cpp; file to contain the implementations of HLSL-specific extensions to the Clang; parser. The HLSL grammar shares most of its structure with C and C++, so we will; use the existing C/C++ parsing code paths. Sema; ----. HLSL's Sema implementation will also provide an ``ExternalSemaSource``. In DXC,; an ``ExternalSemaSource`` is used to provide definitions for HLSL built-in data; types and built-in templates. Clang is already designed to allow an attached; ``ExternalSemaSource`` to lazily complete data types, which is a **huge**; performance win for HLSL. If precompiled headers are used when compiling HLSL, the ``ExternalSemaSource``; will be a ``MultiplexExternalSemaSource`` which includes both the ``ASTReader``; and ``HLSLExternalSemaSource``. For Built-in declarations that are already; completed in the serialized AST, the ``HLSLExternalSemaSource`` will reuse the; existing declarations and not introduce new declarations. If the built-in types; are not completed in the serialized AST, the ``HLSLExternalSemaSource`` will; create new declarations and connect the de-serialized decls as the previous; declaration. CodeGen; -------. Like OpenCL, HLSL relies on capturing a lot of information into IR metadata.; *hand wave* *hand wave* *hand wave* As a design principle here we want our IR to; be idiomatic Clang IR as much as possible. We will use IR attributes wherever we; can, and use metadata as sparingly as possible. One example of a difference from; DXC already impl",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst:6025,Performance,perform,performance,6025,"=============. The HLSL language is insufficiently documented, and not formally specified.; Documentation is available on `Microsoft's website; <https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl>`_.; The language syntax is similar enough to C and C++ that carefully written C and; C++ code is valid HLSL. HLSL has some key differences from C & C++ which we will; need to handle in Clang. HLSL is not a conforming or valid extension or superset of C or C++. The; language has key incompatibilities with C and C++, both syntactically and; semantically. An Aside on GPU Languages; -------------------------. Due to HLSL being a GPU targeted language HLSL is a Single Program Multiple Data; (SPMD) language relying on the implicit parallelism provided by GPU hardware.; Some language features in HLSL enable programmers to take advantage of the; parallel nature of GPUs in a hardware abstracted language. HLSL also prohibits some features of C and C++ which can have catastrophic; performance or are not widely supportable on GPU hardware or drivers. As an; example, register spilling is often excessively expensive on GPUs, so HLSL; requires all functions to be inlined during code generation, and does not; support a runtime calling convention. Pointers & References; ---------------------. HLSL does not support referring to values by address. Semantically all variables; are value-types and behave as such. HLSL disallows the pointer dereference; operators (unary ``*``, and ``->``), as well as the address of operator (unary; &). While HLSL disallows pointers and references in the syntax, HLSL does use; reference types in the AST, and we intend to use pointer decay in the AST in; the Clang implementation. HLSL ``this`` Keyword; ---------------------. HLSL does support member functions, and (in HLSL 2021) limited operator; overloading. With member function support, HLSL also has a ``this`` keyword. The; ``this`` keyword is an example of one of the places where HLSL",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst:8619,Performance,optimiz,optimizations,8619," and earlier, HLSL supported logical operators (and the ternary; operator) on vector types. This behavior required that operators not short; circuit. The non-short circuiting behavior applies to all data types until HLSL; 2021. In HLSL 2021, logical and ternary operators do not support vector types; instead builtin functions ``and``, ``or`` and ``select`` are available, and; operators short circuit matching C behavior. Precise Qualifier; -----------------. HLSL has a ``precise`` qualifier that behaves unlike anything else in the C; language. The support for this qualifier in DXC is buggy, so our bar for; compatibility is low. The ``precise`` qualifier applies in the inverse direction from normal; qualifiers. Rather than signifying that the declaration containing ``precise``; qualifier be precise, it signifies that the operations contributing to the; declaration's value be ``precise``. Additionally, ``precise`` is a misnomer:; values attributed as ``precise`` comply with IEEE-754 floating point semantics,; and are prevented from optimizations which could decrease *or increase*; precision. Differences in Templates; ------------------------. HLSL uses templates to define builtin types and methods, but disallowed; user-defined templates until HLSL 2021. HLSL also allows omitting empty template; parameter lists when all template parameters are defaulted. This is an ambiguous; syntax in C++, but Clang detects the case and issues a diagnostic. This makes; supporting the case in Clang minimally invasive. Vector Extensions; -----------------. HLSL uses the OpenCL vector extensions, and also provides C++-style constructors; for vectors that are not supported by Clang. Standard Library; ----------------. HLSL does not support the C or C++ standard libraries. Like OpenCL, HLSL; describes its own library of built in types, complex data types, and functions. Unsupported C & C++ Features; ----------------------------. HLSL does not support all features of C and C++. In implementing",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst:8994,Safety,detect,detects,8994,"havior. Precise Qualifier; -----------------. HLSL has a ``precise`` qualifier that behaves unlike anything else in the C; language. The support for this qualifier in DXC is buggy, so our bar for; compatibility is low. The ``precise`` qualifier applies in the inverse direction from normal; qualifiers. Rather than signifying that the declaration containing ``precise``; qualifier be precise, it signifies that the operations contributing to the; declaration's value be ``precise``. Additionally, ``precise`` is a misnomer:; values attributed as ``precise`` comply with IEEE-754 floating point semantics,; and are prevented from optimizations which could decrease *or increase*; precision. Differences in Templates; ------------------------. HLSL uses templates to define builtin types and methods, but disallowed; user-defined templates until HLSL 2021. HLSL also allows omitting empty template; parameter lists when all template parameters are defaulted. This is an ambiguous; syntax in C++, but Clang detects the case and issues a diagnostic. This makes; supporting the case in Clang minimally invasive. Vector Extensions; -----------------. HLSL uses the OpenCL vector extensions, and also provides C++-style constructors; for vectors that are not supported by Clang. Standard Library; ----------------. HLSL does not support the C or C++ standard libraries. Like OpenCL, HLSL; describes its own library of built in types, complex data types, and functions. Unsupported C & C++ Features; ----------------------------. HLSL does not support all features of C and C++. In implementing HLSL in Clang; use of some C and C++ features will produce diagnostics under HLSL, and others; will be supported as language extensions. In general, any C or C++ feature that; can be supported by the DXIL and SPIR-V code generation targets could be treated; as a clang HLSL extension. Features that cannot be lowered to DXIL or SPIR-V,; must be diagnosed as errors. HLSL does not support the following C features:.",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst:1264,Testability,test,test,1264,"asies of the HLSL language and how we intend to support them in; Clang. Project Goals; =============. The long term goal of this project is to enable Clang to function as a; replacement for the `DirectXShaderCompiler (DXC); <https://github.com/microsoft/DirectXShaderCompiler/>`_ in all its supported; use cases. Accomplishing that goal will require Clang to be able to process most; existing HLSL programs with a high degree of source compatibility. Non-Goals; ---------. HLSL ASTs do not need to be compatible between DXC and Clang. We do not expect; identical code generation or that features will resemble DXC's implementation or; architecture. In fact, we explicitly expect to deviate from DXC's implementation; in key ways. Guiding Principles; ==================. This document lacks details for architectural decisions that are not yet; finalized. Our top priorities are quality, maintainability, and flexibility. In; accordance with community standards we are expecting a high level of test; coverage, and we will engineer our solutions with long term maintenance in mind.; We are also working to limit modifications to the Clang C++ code paths and; share as much functionality as possible. Architectural Direction; =======================. HLSL support in Clang is expressed as C++ minus unsupported C and C++ features.; This is different from how other Clang languages are implemented. Most languages; in Clang are additive on top of C. HLSL is not a formally or fully specified language, and while our goals require; a high level of source compatibility, implementations can vary and we have some; flexibility to be more or less permissive in some cases. For modern HLSL DXC is; the reference implementation. The HLSL effort prioritizes following similar patterns for other languages,; drivers, runtimes and targets. Specifically, We will maintain separation between; HSLS-specific code and the rest of Clang as much as possible following patterns; in use in Clang code today (i.e. ParseHL",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst:7604,Testability,log,logical,7604,"eferences in the syntax, HLSL does use; reference types in the AST, and we intend to use pointer decay in the AST in; the Clang implementation. HLSL ``this`` Keyword; ---------------------. HLSL does support member functions, and (in HLSL 2021) limited operator; overloading. With member function support, HLSL also has a ``this`` keyword. The; ``this`` keyword is an example of one of the places where HLSL relies on; references in the AST, because ``this`` is a reference. Bitshifts; ---------. In deviation from C, HLSL bitshifts are defined to mask the shift count by the; size of the type. In DXC, the semantics of LLVM IR were altered to accommodate; this, in Clang we intend to generate the mask explicitly in the IR. In cases; where the shift value is constant, this will be constant folded appropriately,; in other cases we can clean it up in the DXIL target. Non-short Circuiting Logical Operators; --------------------------------------. In HLSL 2018 and earlier, HLSL supported logical operators (and the ternary; operator) on vector types. This behavior required that operators not short; circuit. The non-short circuiting behavior applies to all data types until HLSL; 2021. In HLSL 2021, logical and ternary operators do not support vector types; instead builtin functions ``and``, ``or`` and ``select`` are available, and; operators short circuit matching C behavior. Precise Qualifier; -----------------. HLSL has a ``precise`` qualifier that behaves unlike anything else in the C; language. The support for this qualifier in DXC is buggy, so our bar for; compatibility is low. The ``precise`` qualifier applies in the inverse direction from normal; qualifiers. Rather than signifying that the declaration containing ``precise``; qualifier be precise, it signifies that the operations contributing to the; declaration's value be ``precise``. Additionally, ``precise`` is a misnomer:; values attributed as ``precise`` comply with IEEE-754 floating point semantics,; and are prevented ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst:7817,Testability,log,logical,7817,"er function support, HLSL also has a ``this`` keyword. The; ``this`` keyword is an example of one of the places where HLSL relies on; references in the AST, because ``this`` is a reference. Bitshifts; ---------. In deviation from C, HLSL bitshifts are defined to mask the shift count by the; size of the type. In DXC, the semantics of LLVM IR were altered to accommodate; this, in Clang we intend to generate the mask explicitly in the IR. In cases; where the shift value is constant, this will be constant folded appropriately,; in other cases we can clean it up in the DXIL target. Non-short Circuiting Logical Operators; --------------------------------------. In HLSL 2018 and earlier, HLSL supported logical operators (and the ternary; operator) on vector types. This behavior required that operators not short; circuit. The non-short circuiting behavior applies to all data types until HLSL; 2021. In HLSL 2021, logical and ternary operators do not support vector types; instead builtin functions ``and``, ``or`` and ``select`` are available, and; operators short circuit matching C behavior. Precise Qualifier; -----------------. HLSL has a ``precise`` qualifier that behaves unlike anything else in the C; language. The support for this qualifier in DXC is buggy, so our bar for; compatibility is low. The ``precise`` qualifier applies in the inverse direction from normal; qualifiers. Rather than signifying that the declaration containing ``precise``; qualifier be precise, it signifies that the operations contributing to the; declaration's value be ``precise``. Additionally, ``precise`` is a misnomer:; values attributed as ``precise`` comply with IEEE-754 floating point semantics,; and are prevented from optimizations which could decrease *or increase*; precision. Differences in Templates; ------------------------. HLSL uses templates to define builtin types and methods, but disallowed; user-defined templates until HLSL 2021. HLSL also allows omitting empty template; parameter lis",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst:224,Usability,guid,guiding,224,"============; HLSL Support; ============. .. contents::; :local:. Introduction; ============. HLSL Support is under active development in the Clang codebase. This document; describes the high level goals of the project, the guiding principles, as well; as some idiosyncrasies of the HLSL language and how we intend to support them in; Clang. Project Goals; =============. The long term goal of this project is to enable Clang to function as a; replacement for the `DirectXShaderCompiler (DXC); <https://github.com/microsoft/DirectXShaderCompiler/>`_ in all its supported; use cases. Accomplishing that goal will require Clang to be able to process most; existing HLSL programs with a high degree of source compatibility. Non-Goals; ---------. HLSL ASTs do not need to be compatible between DXC and Clang. We do not expect; identical code generation or that features will resemble DXC's implementation or; architecture. In fact, we explicitly expect to deviate from DXC's implementation; in key ways. Guiding Principles; ==================. This document lacks details for architectural decisions that are not yet; finalized. Our top priorities are quality, maintainability, and flexibility. In; accordance with community standards we are expecting a high level of test; coverage, and we will engineer our solutions with long term maintenance in mind.; We are also working to limit modifications to the Clang C++ code paths and; share as much functionality as possible. Architectural Direction; =======================. HLSL support in Clang is expressed as C++ minus unsupported C and C++ features.; This is different from how other Clang languages are implemented. Most languages; in Clang are additive on top of C. HLSL is not a formally or fully specified language, and while our goals require; a high level of source compatibility, implementations can vary and we have some; flexibility to be more or less permissive in some cases. For modern HLSL DXC is; the reference implementation. The HLSL ef",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst:2374,Usability,simpl,simple,2374," to the Clang C++ code paths and; share as much functionality as possible. Architectural Direction; =======================. HLSL support in Clang is expressed as C++ minus unsupported C and C++ features.; This is different from how other Clang languages are implemented. Most languages; in Clang are additive on top of C. HLSL is not a formally or fully specified language, and while our goals require; a high level of source compatibility, implementations can vary and we have some; flexibility to be more or less permissive in some cases. For modern HLSL DXC is; the reference implementation. The HLSL effort prioritizes following similar patterns for other languages,; drivers, runtimes and targets. Specifically, We will maintain separation between; HSLS-specific code and the rest of Clang as much as possible following patterns; in use in Clang code today (i.e. ParseHLSL.cpp, SemaHLSL.cpp, CGHLSL*.cpp...).; We will use inline checks on language options where the code is simple and; isolated, and prefer HLSL-specific implementation files for any code of; reasonable complexity. In places where the HLSL language is in conflict with C and C++, we will seek to; make minimally invasive changes guarded under the HLSL language options. We will; seek to make HLSL language support as minimal a maintenance burden as possible. DXC Driver; ----------. A DXC driver mode will provide command-line compatibility with DXC, supporting; DXC's options and flags. The DXC driver is HLSL-specific and will create an; HLSLToolchain which will provide the basis to support targeting both DirectX and; Vulkan. Parser; ------. Following the examples of other parser extensions HLSL will add a ParseHLSL.cpp; file to contain the implementations of HLSL-specific extensions to the Clang; parser. The HLSL grammar shares most of its structure with C and C++, so we will; use the existing C/C++ parsing code paths. Sema; ----. HLSL's Sema implementation will also provide an ``ExternalSemaSource``. In DXC,; an ``",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/HLSLSupport.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/ResourceTypes.rst:679,Performance,load,loads,679,"===================; HLSL Resource Types; ===================. .. contents::; :local:. Introduction; ============. HLSL Resources are runtime-bound data that is provided as input, output or both; to shader programs written in HLSL. Resource Types in HLSL provide key user; abstractions for reading and writing resource data. Implementation Details; ======================. In Clang resource types are forward declared by the ``HLSLExternalSemaSource``; on initialization. They are then lazily completed when ``requiresCompleteType``; is called later in Sema. Resource types are templated class declarations. The template parameter; specifies the expected return type of resource loads, and the expected parameter; type for stores. In Clang's AST and code generation, resource types are classes that store a; pointer of the template parameter type. The pointer is populated from a call to; ``__builtin_hlsl_create_handle``, and treated as a pointer to an array of typed; data through until lowering in the backend. Resource types are annotated with the ``HLSLResource`` attribute, which drives; code generation for resource binding metadata. The ``hlsl`` metadata nodes are; transformed in the backend to the binding information expected by the target; runtime.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/HLSL/ResourceTypes.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/HLSL/ResourceTypes.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst:2715,Availability,avail,available,2715,"end up; interleaved. - debug.DumpTraversal: Prints the name of each branch statement encountered; during a path traversal (""IfStmt"", ""WhileStmt"", etc). Currently used to check; whether the analysis engine is doing BFS or DFS. State Checking; ==============. These checkers will print out information about the analyzer state in the form; of analysis warnings. They are intended for use with the -verify functionality; in regression tests. - debug.TaintTest: Prints out the word ""tainted"" for every expression that; carries taint. At the time of this writing, taint was only introduced by the; checks under experimental.security.taint.TaintPropagation; this checker may; eventually move to the security.taint package. - debug.ExprInspection: Responds to certain function calls, which are modeled; after builtins. These function calls should affect the program state other; than the evaluation of their arguments; to use them, you will need to declare; them within your test file. The available functions are described below. (FIXME: debug.ExprInspection should probably be renamed, since it no longer only; inspects expressions.). ExprInspection checks; ---------------------. - ``void clang_analyzer_eval(bool);``. Prints TRUE if the argument is known to have a non-zero value, FALSE if the; argument is known to have a zero or null value, and UNKNOWN if the argument; isn't sufficiently constrained on this path. You can use this to test other; values by using expressions like ""x == 5"". Note that this functionality is; currently DISABLED in inlined functions, since different calls to the same; inlined function could provide different information, making it difficult to; write proper -verify directives. In C, the argument can be typed as 'int' or as '_Bool'. Example usage::. clang_analyzer_eval(x); // expected-warning{{UNKNOWN}}; if (!x) return;; clang_analyzer_eval(x); // expected-warning{{TRUE}}. - ``void clang_analyzer_checkInlined(bool);``. If a call occurs within an inlined function, p",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst:11081,Availability,avail,available,11081,") {; int n;; clang_analyzer_isTainted(n); // expected-warning{{NO}}; scanf(""%d"", &n);; clang_analyzer_isTainted(n); // expected-warning{{YES}}; clang_analyzer_isTainted(n + 2); // expected-warning{{YES}}; clang_analyzer_isTainted(n > 0); // expected-warning{{YES}}; int next_tainted_value = n; // no-warning; return n;; }. - ``clang_analyzer_dumpExtent(a single argument of any type)``; - ``clang_analyzer_dumpElementCount(a single argument of any type)``. Dumps out the extent and the element count of the argument. Example usage::. void array() {; int a[] = {1, 3};; clang_analyzer_dumpExtent(a); // expected-warning {{8 S64b}}; clang_analyzer_dumpElementCount(a); // expected-warning {{2 S64b}}; }. - ``clang_analyzer_value(a single argument of integer or pointer type)``. Prints an associated value for the given argument.; Supported argument types are integers, enums and pointers.; The value can be represented either as a range set or as a concrete integer.; For the rest of the types function prints ``n/a`` (aka not available). **Note:** This function will print nothing for clang built with Z3 constraint manager.; This may cause crashes of your tests. To manage this use one of the test constraining; techniques:. * llvm-lit commands ``REQUIRES no-z3`` or ``UNSUPPORTED z3`` `See for details. <https://llvm.org/docs/TestingGuide.html#constraining-test-execution>`_. * a preprocessor directive ``#ifndef ANALYZER_CM_Z3``. * a clang command argument ``-analyzer-constraints=range``. Example usage::. void print(char c, unsigned u) {; clang_analyzer_value(c); // expected-warning {{8s:{ [-128, 127] }}}; if(u != 42); clang_analyzer_value(u); // expected-warning {{32u:{ [0, 41], [43, 4294967295] }}}; else; clang_analyzer_value(u); // expected-warning {{32u:42}}; }. Statistics; ==========. The debug.Stats checker collects various information about the analysis of each; function, such as how many blocks were reached and if the analyzer timed out. There is also an additional -analyzer-stat",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst:9876,Energy Efficiency,reduce,reduce,9876,"as a; warning of an arbitrary expression using the function above. Example usage::. void foo() {; int x = 1;; clang_analyzer_hashDump(x); // expected-warning{{hashed string for x}}; }. - ``void clang_analyzer_denote(int, const char *);``. Denotes symbols with strings. A subsequent call to clang_analyzer_express(); will expresses another symbol in terms of these string. Useful for testing; relationships between different symbols. Example usage::. void foo(int x) {; clang_analyzer_denote(x, ""$x"");; clang_analyzer_express(x + 1); // expected-warning{{$x + 1}}; }. - ``void clang_analyzer_express(int);``. See clang_analyzer_denote(). - ``void clang_analyzer_isTainted(a single argument of any type);``. Queries the analyzer whether the expression used as argument is tainted or not.; This is useful in tests, where we don't want to issue warning for all tainted; expressions but only check for certain expressions.; This would help to reduce the *noise* that the `TaintTest` debug checker would; introduce and let you focus on the `expected-warning`'s that you really care; about. Example usage::. int read_integer() {; int n;; clang_analyzer_isTainted(n); // expected-warning{{NO}}; scanf(""%d"", &n);; clang_analyzer_isTainted(n); // expected-warning{{YES}}; clang_analyzer_isTainted(n + 2); // expected-warning{{YES}}; clang_analyzer_isTainted(n > 0); // expected-warning{{YES}}; int next_tainted_value = n; // no-warning; return n;; }. - ``clang_analyzer_dumpExtent(a single argument of any type)``; - ``clang_analyzer_dumpElementCount(a single argument of any type)``. Dumps out the extent and the element count of the argument. Example usage::. void array() {; int a[] = {1, 3};; clang_analyzer_dumpExtent(a); // expected-warning {{8 S64b}}; clang_analyzer_dumpElementCount(a); // expected-warning {{2 S64b}}; }. - ``clang_analyzer_value(a single argument of integer or pointer type)``. Prints an associated value for the given argument.; Supported argument types are integers, enums and point",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst:4416,Integrability,depend,depending,4416,"erent information, making it difficult to; write proper -verify directives. In C, the argument can be typed as 'int' or as '_Bool'. Example usage::. clang_analyzer_eval(x); // expected-warning{{UNKNOWN}}; if (!x) return;; clang_analyzer_eval(x); // expected-warning{{TRUE}}. - ``void clang_analyzer_checkInlined(bool);``. If a call occurs within an inlined function, prints TRUE or FALSE according to; the value of its argument. If a call occurs outside an inlined function,; nothing is printed. The intended use of this checker is to assert that a function is inlined at; least once (by passing 'true' and expecting a warning), or to assert that a; function is never inlined (by passing 'false' and expecting no warning). The; argument is technically unnecessary but is intended to clarify intent. You might wonder why we can't print TRUE if a function is ever inlined and; FALSE if it is not. The problem is that any inlined function could conceivably; also be analyzed as a top-level function (in which case both TRUE and FALSE; would be printed), depending on the value of the -analyzer-inlining option. In C, the argument can be typed as 'int' or as '_Bool'. Example usage::. int inlined() {; clang_analyzer_checkInlined(true); // expected-warning{{TRUE}}; return 42;; }. void topLevel() {; clang_analyzer_checkInlined(false); // no-warning (not inlined); int value = inlined();; // This assertion will not be valid if the previous call was not inlined.; clang_analyzer_eval(value == 42); // expected-warning{{TRUE}}; }. - ``void clang_analyzer_warnIfReached();``. Generate a warning if this line of code gets reached by the analyzer. Example usage::. if (true) {; clang_analyzer_warnIfReached(); // expected-warning{{REACHABLE}}; }; else {; clang_analyzer_warnIfReached(); // no-warning; }. - ``void clang_analyzer_numTimesReached();``. Same as above, but include the number of times this call expression; gets reached by the analyzer during the current analysis. Example usage::. for (int x = 0",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst:6543,Integrability,message,message,6543,"cribe for a delayed warning when the symbol that represents the value of; the argument is garbage-collected by the analyzer. When calling 'clang_analyzer_warnOnDeadSymbol(x)', if value of 'x' is a; symbol, then this symbol is marked by the ExprInspection checker. Then,; during each garbage collection run, the checker sees if the marked symbol is; being collected and issues the 'SYMBOL DEAD' warning if it does.; This way you know where exactly, up to the line of code, the symbol dies. It is unlikely that you call this function after the symbol is already dead,; because the very reference to it as the function argument prevents it from; dying. However, if the argument is not a symbol but a concrete value,; no warning would be issued. Example usage::. do {; int x = generate_some_integer();; clang_analyzer_warnOnDeadSymbol(x);; } while(0); // expected-warning{{SYMBOL DEAD}}. - ``void clang_analyzer_explain(a single argument of any type);``. This function explains the value of its argument in a human-readable manner; in the warning message. You can make as many overrides of its prototype; in the test code as necessary to explain various integral, pointer,; or even record-type values. To simplify usage in C code (where overloading; the function declaration is not allowed), you may append an arbitrary suffix; to the function name, without affecting functionality. Example usage::. void clang_analyzer_explain(int);; void clang_analyzer_explain(void *);. // Useful in C code; void clang_analyzer_explain_int(int);. void foo(int param, void *ptr) {; clang_analyzer_explain(param); // expected-warning{{argument 'param'}}; clang_analyzer_explain_int(param); // expected-warning{{argument 'param'}}; if (!ptr); clang_analyzer_explain(ptr); // expected-warning{{memory address '0'}}; }. - ``void clang_analyzer_dump( /* a single argument of any type */);``. Similar to clang_analyzer_explain, but produces a raw dump of the value,; same as SVal::dump(). Example usage::. void clang_analyzer_",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst:945,Modifiability,variab,variable,945,"============; Debug Checks; ============. .. contents::; :local:. The analyzer contains a number of checkers which can aid in debugging. Enable; them by using the ""-analyzer-checker="" flag, followed by the name of the; checker. General Analysis Dumpers; ========================. These checkers are used to dump the results of various infrastructural analyses; to stderr. Some checkers also have ""view"" variants, which will display a graph; using a 'dot' format viewer (such as Graphviz on macOS) instead. - debug.DumpCallGraph, debug.ViewCallGraph: Show the call graph generated for; the current translation unit. This is used to determine the order in which to; analyze functions when inlining is enabled. - debug.DumpCFG, debug.ViewCFG: Show the CFG generated for each top-level; function being analyzed. - debug.DumpDominators: Shows the dominance tree for the CFG of each top-level; function. - debug.DumpLiveVars: Show the results of live variable analysis for each; top-level function being analyzed. - debug.DumpLiveExprs: Show the results of live expression analysis for each; top-level function being analyzed. - debug.ViewExplodedGraph: Show the Exploded Graphs generated for the; analysis of different functions in the input translation unit. When there; are several functions analyzed, display one graph per function. Beware; that these graphs may grow very large, even for small functions. Path Tracking; =============. These checkers print information about the path taken by the analyzer engine. - debug.DumpCalls: Prints out every function or method call encountered during a; path traversal. This is indented to show the call stack, but does NOT do any; special handling of branches, meaning different paths could end up; interleaved. - debug.DumpTraversal: Prints the name of each branch statement encountered; during a path traversal (""IfStmt"", ""WhileStmt"", etc). Currently used to check; whether the analysis engine is doing BFS or DFS. State Checking; ==============. These check",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst:2351,Security,secur,security,2351,"s may grow very large, even for small functions. Path Tracking; =============. These checkers print information about the path taken by the analyzer engine. - debug.DumpCalls: Prints out every function or method call encountered during a; path traversal. This is indented to show the call stack, but does NOT do any; special handling of branches, meaning different paths could end up; interleaved. - debug.DumpTraversal: Prints the name of each branch statement encountered; during a path traversal (""IfStmt"", ""WhileStmt"", etc). Currently used to check; whether the analysis engine is doing BFS or DFS. State Checking; ==============. These checkers will print out information about the analyzer state in the form; of analysis warnings. They are intended for use with the -verify functionality; in regression tests. - debug.TaintTest: Prints out the word ""tainted"" for every expression that; carries taint. At the time of this writing, taint was only introduced by the; checks under experimental.security.taint.TaintPropagation; this checker may; eventually move to the security.taint package. - debug.ExprInspection: Responds to certain function calls, which are modeled; after builtins. These function calls should affect the program state other; than the evaluation of their arguments; to use them, you will need to declare; them within your test file. The available functions are described below. (FIXME: debug.ExprInspection should probably be renamed, since it no longer only; inspects expressions.). ExprInspection checks; ---------------------. - ``void clang_analyzer_eval(bool);``. Prints TRUE if the argument is known to have a non-zero value, FALSE if the; argument is known to have a zero or null value, and UNKNOWN if the argument; isn't sufficiently constrained on this path. You can use this to test other; values by using expressions like ""x == 5"". Note that this functionality is; currently DISABLED in inlined functions, since different calls to the same; inlined function could pro",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst:2425,Security,secur,security,2425,"ns. Path Tracking; =============. These checkers print information about the path taken by the analyzer engine. - debug.DumpCalls: Prints out every function or method call encountered during a; path traversal. This is indented to show the call stack, but does NOT do any; special handling of branches, meaning different paths could end up; interleaved. - debug.DumpTraversal: Prints the name of each branch statement encountered; during a path traversal (""IfStmt"", ""WhileStmt"", etc). Currently used to check; whether the analysis engine is doing BFS or DFS. State Checking; ==============. These checkers will print out information about the analyzer state in the form; of analysis warnings. They are intended for use with the -verify functionality; in regression tests. - debug.TaintTest: Prints out the word ""tainted"" for every expression that; carries taint. At the time of this writing, taint was only introduced by the; checks under experimental.security.taint.TaintPropagation; this checker may; eventually move to the security.taint package. - debug.ExprInspection: Responds to certain function calls, which are modeled; after builtins. These function calls should affect the program state other; than the evaluation of their arguments; to use them, you will need to declare; them within your test file. The available functions are described below. (FIXME: debug.ExprInspection should probably be renamed, since it no longer only; inspects expressions.). ExprInspection checks; ---------------------. - ``void clang_analyzer_eval(bool);``. Prints TRUE if the argument is known to have a non-zero value, FALSE if the; argument is known to have a zero or null value, and UNKNOWN if the argument; isn't sufficiently constrained on this path. You can use this to test other; values by using expressions like ""x == 5"". Note that this functionality is; currently DISABLED in inlined functions, since different calls to the same; inlined function could provide different information, making it diffic",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst:8813,Security,hash,hash,8813,"valid code that produces this value. However, it may be useful; for testing purposes, to see how well does the analyzer model region extents. Example usage::. void foo() {; int x, *y;; size_t xs = clang_analyzer_getExtent(&x);; clang_analyzer_explain(xs); // expected-warning{{'4'}}; size_t ys = clang_analyzer_getExtent(&y);; clang_analyzer_explain(ys); // expected-warning{{'8'}}; }. - ``void clang_analyzer_printState();``. Dumps the current ProgramState to the stderr. Quickly lookup the program state; at any execution point without ViewExplodedGraph or re-compiling the program.; This is not very useful for writing tests (apart from testing how ProgramState; gets printed), but useful for debugging tests. Also, this method doesn't; produce a warning, so it gets printed on the console before all other; ExprInspection warnings. Example usage::. void foo() {; int x = 1;; clang_analyzer_printState(); // Read the stderr!; }. - ``void clang_analyzer_hashDump(int);``. The analyzer can generate a hash to identify reports. To debug what information; is used to calculate this hash it is possible to dump the hashed string as a; warning of an arbitrary expression using the function above. Example usage::. void foo() {; int x = 1;; clang_analyzer_hashDump(x); // expected-warning{{hashed string for x}}; }. - ``void clang_analyzer_denote(int, const char *);``. Denotes symbols with strings. A subsequent call to clang_analyzer_express(); will expresses another symbol in terms of these string. Useful for testing; relationships between different symbols. Example usage::. void foo(int x) {; clang_analyzer_denote(x, ""$x"");; clang_analyzer_express(x + 1); // expected-warning{{$x + 1}}; }. - ``void clang_analyzer_express(int);``. See clang_analyzer_denote(). - ``void clang_analyzer_isTainted(a single argument of any type);``. Queries the analyzer whether the expression used as argument is tainted or not.; This is useful in tests, where we don't want to issue warning for all tainted; express",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst:8892,Security,hash,hash,8892," analyzer model region extents. Example usage::. void foo() {; int x, *y;; size_t xs = clang_analyzer_getExtent(&x);; clang_analyzer_explain(xs); // expected-warning{{'4'}}; size_t ys = clang_analyzer_getExtent(&y);; clang_analyzer_explain(ys); // expected-warning{{'8'}}; }. - ``void clang_analyzer_printState();``. Dumps the current ProgramState to the stderr. Quickly lookup the program state; at any execution point without ViewExplodedGraph or re-compiling the program.; This is not very useful for writing tests (apart from testing how ProgramState; gets printed), but useful for debugging tests. Also, this method doesn't; produce a warning, so it gets printed on the console before all other; ExprInspection warnings. Example usage::. void foo() {; int x = 1;; clang_analyzer_printState(); // Read the stderr!; }. - ``void clang_analyzer_hashDump(int);``. The analyzer can generate a hash to identify reports. To debug what information; is used to calculate this hash it is possible to dump the hashed string as a; warning of an arbitrary expression using the function above. Example usage::. void foo() {; int x = 1;; clang_analyzer_hashDump(x); // expected-warning{{hashed string for x}}; }. - ``void clang_analyzer_denote(int, const char *);``. Denotes symbols with strings. A subsequent call to clang_analyzer_express(); will expresses another symbol in terms of these string. Useful for testing; relationships between different symbols. Example usage::. void foo(int x) {; clang_analyzer_denote(x, ""$x"");; clang_analyzer_express(x + 1); // expected-warning{{$x + 1}}; }. - ``void clang_analyzer_express(int);``. See clang_analyzer_denote(). - ``void clang_analyzer_isTainted(a single argument of any type);``. Queries the analyzer whether the expression used as argument is tainted or not.; This is useful in tests, where we don't want to issue warning for all tainted; expressions but only check for certain expressions.; This would help to reduce the *noise* that the `TaintTest` debug",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst:8924,Security,hash,hashed,8924," analyzer model region extents. Example usage::. void foo() {; int x, *y;; size_t xs = clang_analyzer_getExtent(&x);; clang_analyzer_explain(xs); // expected-warning{{'4'}}; size_t ys = clang_analyzer_getExtent(&y);; clang_analyzer_explain(ys); // expected-warning{{'8'}}; }. - ``void clang_analyzer_printState();``. Dumps the current ProgramState to the stderr. Quickly lookup the program state; at any execution point without ViewExplodedGraph or re-compiling the program.; This is not very useful for writing tests (apart from testing how ProgramState; gets printed), but useful for debugging tests. Also, this method doesn't; produce a warning, so it gets printed on the console before all other; ExprInspection warnings. Example usage::. void foo() {; int x = 1;; clang_analyzer_printState(); // Read the stderr!; }. - ``void clang_analyzer_hashDump(int);``. The analyzer can generate a hash to identify reports. To debug what information; is used to calculate this hash it is possible to dump the hashed string as a; warning of an arbitrary expression using the function above. Example usage::. void foo() {; int x = 1;; clang_analyzer_hashDump(x); // expected-warning{{hashed string for x}}; }. - ``void clang_analyzer_denote(int, const char *);``. Denotes symbols with strings. A subsequent call to clang_analyzer_express(); will expresses another symbol in terms of these string. Useful for testing; relationships between different symbols. Example usage::. void foo(int x) {; clang_analyzer_denote(x, ""$x"");; clang_analyzer_express(x + 1); // expected-warning{{$x + 1}}; }. - ``void clang_analyzer_express(int);``. See clang_analyzer_denote(). - ``void clang_analyzer_isTainted(a single argument of any type);``. Queries the analyzer whether the expression used as argument is tainted or not.; This is useful in tests, where we don't want to issue warning for all tainted; expressions but only check for certain expressions.; This would help to reduce the *noise* that the `TaintTest` debug",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst:9097,Security,hash,hashed,9097,"xpected-warning{{'4'}}; size_t ys = clang_analyzer_getExtent(&y);; clang_analyzer_explain(ys); // expected-warning{{'8'}}; }. - ``void clang_analyzer_printState();``. Dumps the current ProgramState to the stderr. Quickly lookup the program state; at any execution point without ViewExplodedGraph or re-compiling the program.; This is not very useful for writing tests (apart from testing how ProgramState; gets printed), but useful for debugging tests. Also, this method doesn't; produce a warning, so it gets printed on the console before all other; ExprInspection warnings. Example usage::. void foo() {; int x = 1;; clang_analyzer_printState(); // Read the stderr!; }. - ``void clang_analyzer_hashDump(int);``. The analyzer can generate a hash to identify reports. To debug what information; is used to calculate this hash it is possible to dump the hashed string as a; warning of an arbitrary expression using the function above. Example usage::. void foo() {; int x = 1;; clang_analyzer_hashDump(x); // expected-warning{{hashed string for x}}; }. - ``void clang_analyzer_denote(int, const char *);``. Denotes symbols with strings. A subsequent call to clang_analyzer_express(); will expresses another symbol in terms of these string. Useful for testing; relationships between different symbols. Example usage::. void foo(int x) {; clang_analyzer_denote(x, ""$x"");; clang_analyzer_express(x + 1); // expected-warning{{$x + 1}}; }. - ``void clang_analyzer_express(int);``. See clang_analyzer_denote(). - ``void clang_analyzer_isTainted(a single argument of any type);``. Queries the analyzer whether the expression used as argument is tainted or not.; This is useful in tests, where we don't want to issue warning for all tainted; expressions but only check for certain expressions.; This would help to reduce the *noise* that the `TaintTest` debug checker would; introduce and let you focus on the `expected-warning`'s that you really care; about. Example usage::. int read_integer() {; int n;; cla",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst:2164,Testability,test,tests,2164,"iewExplodedGraph: Show the Exploded Graphs generated for the; analysis of different functions in the input translation unit. When there; are several functions analyzed, display one graph per function. Beware; that these graphs may grow very large, even for small functions. Path Tracking; =============. These checkers print information about the path taken by the analyzer engine. - debug.DumpCalls: Prints out every function or method call encountered during a; path traversal. This is indented to show the call stack, but does NOT do any; special handling of branches, meaning different paths could end up; interleaved. - debug.DumpTraversal: Prints the name of each branch statement encountered; during a path traversal (""IfStmt"", ""WhileStmt"", etc). Currently used to check; whether the analysis engine is doing BFS or DFS. State Checking; ==============. These checkers will print out information about the analyzer state in the form; of analysis warnings. They are intended for use with the -verify functionality; in regression tests. - debug.TaintTest: Prints out the word ""tainted"" for every expression that; carries taint. At the time of this writing, taint was only introduced by the; checks under experimental.security.taint.TaintPropagation; this checker may; eventually move to the security.taint package. - debug.ExprInspection: Responds to certain function calls, which are modeled; after builtins. These function calls should affect the program state other; than the evaluation of their arguments; to use them, you will need to declare; them within your test file. The available functions are described below. (FIXME: debug.ExprInspection should probably be renamed, since it no longer only; inspects expressions.). ExprInspection checks; ---------------------. - ``void clang_analyzer_eval(bool);``. Prints TRUE if the argument is known to have a non-zero value, FALSE if the; argument is known to have a zero or null value, and UNKNOWN if the argument; isn't sufficiently constrained",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst:2700,Testability,test,test,2700," to show the call stack, but does NOT do any; special handling of branches, meaning different paths could end up; interleaved. - debug.DumpTraversal: Prints the name of each branch statement encountered; during a path traversal (""IfStmt"", ""WhileStmt"", etc). Currently used to check; whether the analysis engine is doing BFS or DFS. State Checking; ==============. These checkers will print out information about the analyzer state in the form; of analysis warnings. They are intended for use with the -verify functionality; in regression tests. - debug.TaintTest: Prints out the word ""tainted"" for every expression that; carries taint. At the time of this writing, taint was only introduced by the; checks under experimental.security.taint.TaintPropagation; this checker may; eventually move to the security.taint package. - debug.ExprInspection: Responds to certain function calls, which are modeled; after builtins. These function calls should affect the program state other; than the evaluation of their arguments; to use them, you will need to declare; them within your test file. The available functions are described below. (FIXME: debug.ExprInspection should probably be renamed, since it no longer only; inspects expressions.). ExprInspection checks; ---------------------. - ``void clang_analyzer_eval(bool);``. Prints TRUE if the argument is known to have a non-zero value, FALSE if the; argument is known to have a zero or null value, and UNKNOWN if the argument; isn't sufficiently constrained on this path. You can use this to test other; values by using expressions like ""x == 5"". Note that this functionality is; currently DISABLED in inlined functions, since different calls to the same; inlined function could provide different information, making it difficult to; write proper -verify directives. In C, the argument can be typed as 'int' or as '_Bool'. Example usage::. clang_analyzer_eval(x); // expected-warning{{UNKNOWN}}; if (!x) return;; clang_analyzer_eval(x); // expected-warn",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst:3166,Testability,test,test,3166,"ntTest: Prints out the word ""tainted"" for every expression that; carries taint. At the time of this writing, taint was only introduced by the; checks under experimental.security.taint.TaintPropagation; this checker may; eventually move to the security.taint package. - debug.ExprInspection: Responds to certain function calls, which are modeled; after builtins. These function calls should affect the program state other; than the evaluation of their arguments; to use them, you will need to declare; them within your test file. The available functions are described below. (FIXME: debug.ExprInspection should probably be renamed, since it no longer only; inspects expressions.). ExprInspection checks; ---------------------. - ``void clang_analyzer_eval(bool);``. Prints TRUE if the argument is known to have a non-zero value, FALSE if the; argument is known to have a zero or null value, and UNKNOWN if the argument; isn't sufficiently constrained on this path. You can use this to test other; values by using expressions like ""x == 5"". Note that this functionality is; currently DISABLED in inlined functions, since different calls to the same; inlined function could provide different information, making it difficult to; write proper -verify directives. In C, the argument can be typed as 'int' or as '_Bool'. Example usage::. clang_analyzer_eval(x); // expected-warning{{UNKNOWN}}; if (!x) return;; clang_analyzer_eval(x); // expected-warning{{TRUE}}. - ``void clang_analyzer_checkInlined(bool);``. If a call occurs within an inlined function, prints TRUE or FALSE according to; the value of its argument. If a call occurs outside an inlined function,; nothing is printed. The intended use of this checker is to assert that a function is inlined at; least once (by passing 'true' and expecting a warning), or to assert that a; function is never inlined (by passing 'false' and expecting no warning). The; argument is technically unnecessary but is intended to clarify intent. You might wonder wh",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst:3900,Testability,assert,assert,3900,"t is known to have a non-zero value, FALSE if the; argument is known to have a zero or null value, and UNKNOWN if the argument; isn't sufficiently constrained on this path. You can use this to test other; values by using expressions like ""x == 5"". Note that this functionality is; currently DISABLED in inlined functions, since different calls to the same; inlined function could provide different information, making it difficult to; write proper -verify directives. In C, the argument can be typed as 'int' or as '_Bool'. Example usage::. clang_analyzer_eval(x); // expected-warning{{UNKNOWN}}; if (!x) return;; clang_analyzer_eval(x); // expected-warning{{TRUE}}. - ``void clang_analyzer_checkInlined(bool);``. If a call occurs within an inlined function, prints TRUE or FALSE according to; the value of its argument. If a call occurs outside an inlined function,; nothing is printed. The intended use of this checker is to assert that a function is inlined at; least once (by passing 'true' and expecting a warning), or to assert that a; function is never inlined (by passing 'false' and expecting no warning). The; argument is technically unnecessary but is intended to clarify intent. You might wonder why we can't print TRUE if a function is ever inlined and; FALSE if it is not. The problem is that any inlined function could conceivably; also be analyzed as a top-level function (in which case both TRUE and FALSE; would be printed), depending on the value of the -analyzer-inlining option. In C, the argument can be typed as 'int' or as '_Bool'. Example usage::. int inlined() {; clang_analyzer_checkInlined(true); // expected-warning{{TRUE}}; return 42;; }. void topLevel() {; clang_analyzer_checkInlined(false); // no-warning (not inlined); int value = inlined();; // This assertion will not be valid if the previous call was not inlined.; clang_analyzer_eval(value == 42); // expected-warning{{TRUE}}; }. - ``void clang_analyzer_warnIfReached();``. Generate a warning if this line of code",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst:4000,Testability,assert,assert,4000,"t is known to have a non-zero value, FALSE if the; argument is known to have a zero or null value, and UNKNOWN if the argument; isn't sufficiently constrained on this path. You can use this to test other; values by using expressions like ""x == 5"". Note that this functionality is; currently DISABLED in inlined functions, since different calls to the same; inlined function could provide different information, making it difficult to; write proper -verify directives. In C, the argument can be typed as 'int' or as '_Bool'. Example usage::. clang_analyzer_eval(x); // expected-warning{{UNKNOWN}}; if (!x) return;; clang_analyzer_eval(x); // expected-warning{{TRUE}}. - ``void clang_analyzer_checkInlined(bool);``. If a call occurs within an inlined function, prints TRUE or FALSE according to; the value of its argument. If a call occurs outside an inlined function,; nothing is printed. The intended use of this checker is to assert that a function is inlined at; least once (by passing 'true' and expecting a warning), or to assert that a; function is never inlined (by passing 'false' and expecting no warning). The; argument is technically unnecessary but is intended to clarify intent. You might wonder why we can't print TRUE if a function is ever inlined and; FALSE if it is not. The problem is that any inlined function could conceivably; also be analyzed as a top-level function (in which case both TRUE and FALSE; would be printed), depending on the value of the -analyzer-inlining option. In C, the argument can be typed as 'int' or as '_Bool'. Example usage::. int inlined() {; clang_analyzer_checkInlined(true); // expected-warning{{TRUE}}; return 42;; }. void topLevel() {; clang_analyzer_checkInlined(false); // no-warning (not inlined); int value = inlined();; // This assertion will not be valid if the previous call was not inlined.; clang_analyzer_eval(value == 42); // expected-warning{{TRUE}}; }. - ``void clang_analyzer_warnIfReached();``. Generate a warning if this line of code",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst:4758,Testability,assert,assertion,4758,"prints TRUE or FALSE according to; the value of its argument. If a call occurs outside an inlined function,; nothing is printed. The intended use of this checker is to assert that a function is inlined at; least once (by passing 'true' and expecting a warning), or to assert that a; function is never inlined (by passing 'false' and expecting no warning). The; argument is technically unnecessary but is intended to clarify intent. You might wonder why we can't print TRUE if a function is ever inlined and; FALSE if it is not. The problem is that any inlined function could conceivably; also be analyzed as a top-level function (in which case both TRUE and FALSE; would be printed), depending on the value of the -analyzer-inlining option. In C, the argument can be typed as 'int' or as '_Bool'. Example usage::. int inlined() {; clang_analyzer_checkInlined(true); // expected-warning{{TRUE}}; return 42;; }. void topLevel() {; clang_analyzer_checkInlined(false); // no-warning (not inlined); int value = inlined();; // This assertion will not be valid if the previous call was not inlined.; clang_analyzer_eval(value == 42); // expected-warning{{TRUE}}; }. - ``void clang_analyzer_warnIfReached();``. Generate a warning if this line of code gets reached by the analyzer. Example usage::. if (true) {; clang_analyzer_warnIfReached(); // expected-warning{{REACHABLE}}; }; else {; clang_analyzer_warnIfReached(); // no-warning; }. - ``void clang_analyzer_numTimesReached();``. Same as above, but include the number of times this call expression; gets reached by the analyzer during the current analysis. Example usage::. for (int x = 0; x < 3; ++x) {; clang_analyzer_numTimesReached(); // expected-warning{{3}}; }. - ``void clang_analyzer_warnOnDeadSymbol(int);``. Subscribe for a delayed warning when the symbol that represents the value of; the argument is garbage-collected by the analyzer. When calling 'clang_analyzer_warnOnDeadSymbol(x)', if value of 'x' is a; symbol, then this symbol is marked",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst:6608,Testability,test,test,6608," When calling 'clang_analyzer_warnOnDeadSymbol(x)', if value of 'x' is a; symbol, then this symbol is marked by the ExprInspection checker. Then,; during each garbage collection run, the checker sees if the marked symbol is; being collected and issues the 'SYMBOL DEAD' warning if it does.; This way you know where exactly, up to the line of code, the symbol dies. It is unlikely that you call this function after the symbol is already dead,; because the very reference to it as the function argument prevents it from; dying. However, if the argument is not a symbol but a concrete value,; no warning would be issued. Example usage::. do {; int x = generate_some_integer();; clang_analyzer_warnOnDeadSymbol(x);; } while(0); // expected-warning{{SYMBOL DEAD}}. - ``void clang_analyzer_explain(a single argument of any type);``. This function explains the value of its argument in a human-readable manner; in the warning message. You can make as many overrides of its prototype; in the test code as necessary to explain various integral, pointer,; or even record-type values. To simplify usage in C code (where overloading; the function declaration is not allowed), you may append an arbitrary suffix; to the function name, without affecting functionality. Example usage::. void clang_analyzer_explain(int);; void clang_analyzer_explain(void *);. // Useful in C code; void clang_analyzer_explain_int(int);. void foo(int param, void *ptr) {; clang_analyzer_explain(param); // expected-warning{{argument 'param'}}; clang_analyzer_explain_int(param); // expected-warning{{argument 'param'}}; if (!ptr); clang_analyzer_explain(ptr); // expected-warning{{memory address '0'}}; }. - ``void clang_analyzer_dump( /* a single argument of any type */);``. Similar to clang_analyzer_explain, but produces a raw dump of the value,; same as SVal::dump(). Example usage::. void clang_analyzer_dump(int);; void foo(int x) {; clang_analyzer_dump(x); // expected-warning{{reg_$0<x>}}; }. - ``size_t clang_analyzer_getEx",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst:7879,Testability,test,testing,7879,"d clang_analyzer_explain(int);; void clang_analyzer_explain(void *);. // Useful in C code; void clang_analyzer_explain_int(int);. void foo(int param, void *ptr) {; clang_analyzer_explain(param); // expected-warning{{argument 'param'}}; clang_analyzer_explain_int(param); // expected-warning{{argument 'param'}}; if (!ptr); clang_analyzer_explain(ptr); // expected-warning{{memory address '0'}}; }. - ``void clang_analyzer_dump( /* a single argument of any type */);``. Similar to clang_analyzer_explain, but produces a raw dump of the value,; same as SVal::dump(). Example usage::. void clang_analyzer_dump(int);; void foo(int x) {; clang_analyzer_dump(x); // expected-warning{{reg_$0<x>}}; }. - ``size_t clang_analyzer_getExtent(void *);``. This function returns the value that represents the extent of a memory region; pointed to by the argument. This value is often difficult to obtain otherwise,; because no valid code that produces this value. However, it may be useful; for testing purposes, to see how well does the analyzer model region extents. Example usage::. void foo() {; int x, *y;; size_t xs = clang_analyzer_getExtent(&x);; clang_analyzer_explain(xs); // expected-warning{{'4'}}; size_t ys = clang_analyzer_getExtent(&y);; clang_analyzer_explain(ys); // expected-warning{{'8'}}; }. - ``void clang_analyzer_printState();``. Dumps the current ProgramState to the stderr. Quickly lookup the program state; at any execution point without ViewExplodedGraph or re-compiling the program.; This is not very useful for writing tests (apart from testing how ProgramState; gets printed), but useful for debugging tests. Also, this method doesn't; produce a warning, so it gets printed on the console before all other; ExprInspection warnings. Example usage::. void foo() {; int x = 1;; clang_analyzer_printState(); // Read the stderr!; }. - ``void clang_analyzer_hashDump(int);``. The analyzer can generate a hash to identify reports. To debug what information; is used to calculate this hash it ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst:8433,Testability,test,tests,8433,"p(). Example usage::. void clang_analyzer_dump(int);; void foo(int x) {; clang_analyzer_dump(x); // expected-warning{{reg_$0<x>}}; }. - ``size_t clang_analyzer_getExtent(void *);``. This function returns the value that represents the extent of a memory region; pointed to by the argument. This value is often difficult to obtain otherwise,; because no valid code that produces this value. However, it may be useful; for testing purposes, to see how well does the analyzer model region extents. Example usage::. void foo() {; int x, *y;; size_t xs = clang_analyzer_getExtent(&x);; clang_analyzer_explain(xs); // expected-warning{{'4'}}; size_t ys = clang_analyzer_getExtent(&y);; clang_analyzer_explain(ys); // expected-warning{{'8'}}; }. - ``void clang_analyzer_printState();``. Dumps the current ProgramState to the stderr. Quickly lookup the program state; at any execution point without ViewExplodedGraph or re-compiling the program.; This is not very useful for writing tests (apart from testing how ProgramState; gets printed), but useful for debugging tests. Also, this method doesn't; produce a warning, so it gets printed on the console before all other; ExprInspection warnings. Example usage::. void foo() {; int x = 1;; clang_analyzer_printState(); // Read the stderr!; }. - ``void clang_analyzer_hashDump(int);``. The analyzer can generate a hash to identify reports. To debug what information; is used to calculate this hash it is possible to dump the hashed string as a; warning of an arbitrary expression using the function above. Example usage::. void foo() {; int x = 1;; clang_analyzer_hashDump(x); // expected-warning{{hashed string for x}}; }. - ``void clang_analyzer_denote(int, const char *);``. Denotes symbols with strings. A subsequent call to clang_analyzer_express(); will expresses another symbol in terms of these string. Useful for testing; relationships between different symbols. Example usage::. void foo(int x) {; clang_analyzer_denote(x, ""$x"");; clang_analyzer_expr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst:8451,Testability,test,testing,8451,"p(). Example usage::. void clang_analyzer_dump(int);; void foo(int x) {; clang_analyzer_dump(x); // expected-warning{{reg_$0<x>}}; }. - ``size_t clang_analyzer_getExtent(void *);``. This function returns the value that represents the extent of a memory region; pointed to by the argument. This value is often difficult to obtain otherwise,; because no valid code that produces this value. However, it may be useful; for testing purposes, to see how well does the analyzer model region extents. Example usage::. void foo() {; int x, *y;; size_t xs = clang_analyzer_getExtent(&x);; clang_analyzer_explain(xs); // expected-warning{{'4'}}; size_t ys = clang_analyzer_getExtent(&y);; clang_analyzer_explain(ys); // expected-warning{{'8'}}; }. - ``void clang_analyzer_printState();``. Dumps the current ProgramState to the stderr. Quickly lookup the program state; at any execution point without ViewExplodedGraph or re-compiling the program.; This is not very useful for writing tests (apart from testing how ProgramState; gets printed), but useful for debugging tests. Also, this method doesn't; produce a warning, so it gets printed on the console before all other; ExprInspection warnings. Example usage::. void foo() {; int x = 1;; clang_analyzer_printState(); // Read the stderr!; }. - ``void clang_analyzer_hashDump(int);``. The analyzer can generate a hash to identify reports. To debug what information; is used to calculate this hash it is possible to dump the hashed string as a; warning of an arbitrary expression using the function above. Example usage::. void foo() {; int x = 1;; clang_analyzer_hashDump(x); // expected-warning{{hashed string for x}}; }. - ``void clang_analyzer_denote(int, const char *);``. Denotes symbols with strings. A subsequent call to clang_analyzer_express(); will expresses another symbol in terms of these string. Useful for testing; relationships between different symbols. Example usage::. void foo(int x) {; clang_analyzer_denote(x, ""$x"");; clang_analyzer_expr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst:8517,Testability,test,tests,8517,"p(). Example usage::. void clang_analyzer_dump(int);; void foo(int x) {; clang_analyzer_dump(x); // expected-warning{{reg_$0<x>}}; }. - ``size_t clang_analyzer_getExtent(void *);``. This function returns the value that represents the extent of a memory region; pointed to by the argument. This value is often difficult to obtain otherwise,; because no valid code that produces this value. However, it may be useful; for testing purposes, to see how well does the analyzer model region extents. Example usage::. void foo() {; int x, *y;; size_t xs = clang_analyzer_getExtent(&x);; clang_analyzer_explain(xs); // expected-warning{{'4'}}; size_t ys = clang_analyzer_getExtent(&y);; clang_analyzer_explain(ys); // expected-warning{{'8'}}; }. - ``void clang_analyzer_printState();``. Dumps the current ProgramState to the stderr. Quickly lookup the program state; at any execution point without ViewExplodedGraph or re-compiling the program.; This is not very useful for writing tests (apart from testing how ProgramState; gets printed), but useful for debugging tests. Also, this method doesn't; produce a warning, so it gets printed on the console before all other; ExprInspection warnings. Example usage::. void foo() {; int x = 1;; clang_analyzer_printState(); // Read the stderr!; }. - ``void clang_analyzer_hashDump(int);``. The analyzer can generate a hash to identify reports. To debug what information; is used to calculate this hash it is possible to dump the hashed string as a; warning of an arbitrary expression using the function above. Example usage::. void foo() {; int x = 1;; clang_analyzer_hashDump(x); // expected-warning{{hashed string for x}}; }. - ``void clang_analyzer_denote(int, const char *);``. Denotes symbols with strings. A subsequent call to clang_analyzer_express(); will expresses another symbol in terms of these string. Useful for testing; relationships between different symbols. Example usage::. void foo(int x) {; clang_analyzer_denote(x, ""$x"");; clang_analyzer_expr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst:9321,Testability,test,testing,9321,"t without ViewExplodedGraph or re-compiling the program.; This is not very useful for writing tests (apart from testing how ProgramState; gets printed), but useful for debugging tests. Also, this method doesn't; produce a warning, so it gets printed on the console before all other; ExprInspection warnings. Example usage::. void foo() {; int x = 1;; clang_analyzer_printState(); // Read the stderr!; }. - ``void clang_analyzer_hashDump(int);``. The analyzer can generate a hash to identify reports. To debug what information; is used to calculate this hash it is possible to dump the hashed string as a; warning of an arbitrary expression using the function above. Example usage::. void foo() {; int x = 1;; clang_analyzer_hashDump(x); // expected-warning{{hashed string for x}}; }. - ``void clang_analyzer_denote(int, const char *);``. Denotes symbols with strings. A subsequent call to clang_analyzer_express(); will expresses another symbol in terms of these string. Useful for testing; relationships between different symbols. Example usage::. void foo(int x) {; clang_analyzer_denote(x, ""$x"");; clang_analyzer_express(x + 1); // expected-warning{{$x + 1}}; }. - ``void clang_analyzer_express(int);``. See clang_analyzer_denote(). - ``void clang_analyzer_isTainted(a single argument of any type);``. Queries the analyzer whether the expression used as argument is tainted or not.; This is useful in tests, where we don't want to issue warning for all tainted; expressions but only check for certain expressions.; This would help to reduce the *noise* that the `TaintTest` debug checker would; introduce and let you focus on the `expected-warning`'s that you really care; about. Example usage::. int read_integer() {; int n;; clang_analyzer_isTainted(n); // expected-warning{{NO}}; scanf(""%d"", &n);; clang_analyzer_isTainted(n); // expected-warning{{YES}}; clang_analyzer_isTainted(n + 2); // expected-warning{{YES}}; clang_analyzer_isTainted(n > 0); // expected-warning{{YES}}; int next_tainted_v",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst:9743,Testability,test,tests,9743,"analyzer can generate a hash to identify reports. To debug what information; is used to calculate this hash it is possible to dump the hashed string as a; warning of an arbitrary expression using the function above. Example usage::. void foo() {; int x = 1;; clang_analyzer_hashDump(x); // expected-warning{{hashed string for x}}; }. - ``void clang_analyzer_denote(int, const char *);``. Denotes symbols with strings. A subsequent call to clang_analyzer_express(); will expresses another symbol in terms of these string. Useful for testing; relationships between different symbols. Example usage::. void foo(int x) {; clang_analyzer_denote(x, ""$x"");; clang_analyzer_express(x + 1); // expected-warning{{$x + 1}}; }. - ``void clang_analyzer_express(int);``. See clang_analyzer_denote(). - ``void clang_analyzer_isTainted(a single argument of any type);``. Queries the analyzer whether the expression used as argument is tainted or not.; This is useful in tests, where we don't want to issue warning for all tainted; expressions but only check for certain expressions.; This would help to reduce the *noise* that the `TaintTest` debug checker would; introduce and let you focus on the `expected-warning`'s that you really care; about. Example usage::. int read_integer() {; int n;; clang_analyzer_isTainted(n); // expected-warning{{NO}}; scanf(""%d"", &n);; clang_analyzer_isTainted(n); // expected-warning{{YES}}; clang_analyzer_isTainted(n + 2); // expected-warning{{YES}}; clang_analyzer_isTainted(n > 0); // expected-warning{{YES}}; int next_tainted_value = n; // no-warning; return n;; }. - ``clang_analyzer_dumpExtent(a single argument of any type)``; - ``clang_analyzer_dumpElementCount(a single argument of any type)``. Dumps out the extent and the element count of the argument. Example usage::. void array() {; int a[] = {1, 3};; clang_analyzer_dumpExtent(a); // expected-warning {{8 S64b}}; clang_analyzer_dumpElementCount(a); // expected-warning {{2 S64b}}; }. - ``clang_analyzer_value(a sing",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst:11212,Testability,test,tests,11212,"; clang_analyzer_isTainted(n + 2); // expected-warning{{YES}}; clang_analyzer_isTainted(n > 0); // expected-warning{{YES}}; int next_tainted_value = n; // no-warning; return n;; }. - ``clang_analyzer_dumpExtent(a single argument of any type)``; - ``clang_analyzer_dumpElementCount(a single argument of any type)``. Dumps out the extent and the element count of the argument. Example usage::. void array() {; int a[] = {1, 3};; clang_analyzer_dumpExtent(a); // expected-warning {{8 S64b}}; clang_analyzer_dumpElementCount(a); // expected-warning {{2 S64b}}; }. - ``clang_analyzer_value(a single argument of integer or pointer type)``. Prints an associated value for the given argument.; Supported argument types are integers, enums and pointers.; The value can be represented either as a range set or as a concrete integer.; For the rest of the types function prints ``n/a`` (aka not available). **Note:** This function will print nothing for clang built with Z3 constraint manager.; This may cause crashes of your tests. To manage this use one of the test constraining; techniques:. * llvm-lit commands ``REQUIRES no-z3`` or ``UNSUPPORTED z3`` `See for details. <https://llvm.org/docs/TestingGuide.html#constraining-test-execution>`_. * a preprocessor directive ``#ifndef ANALYZER_CM_Z3``. * a clang command argument ``-analyzer-constraints=range``. Example usage::. void print(char c, unsigned u) {; clang_analyzer_value(c); // expected-warning {{8s:{ [-128, 127] }}}; if(u != 42); clang_analyzer_value(u); // expected-warning {{32u:{ [0, 41], [43, 4294967295] }}}; else; clang_analyzer_value(u); // expected-warning {{32u:42}}; }. Statistics; ==========. The debug.Stats checker collects various information about the analysis of each; function, such as how many blocks were reached and if the analyzer timed out. There is also an additional -analyzer-stats flag, which enables various; statistics within the analyzer engine. Note the Stats checker (which produces at; least one bug report per funct",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst:11249,Testability,test,test,11249,"ing{{YES}}; clang_analyzer_isTainted(n > 0); // expected-warning{{YES}}; int next_tainted_value = n; // no-warning; return n;; }. - ``clang_analyzer_dumpExtent(a single argument of any type)``; - ``clang_analyzer_dumpElementCount(a single argument of any type)``. Dumps out the extent and the element count of the argument. Example usage::. void array() {; int a[] = {1, 3};; clang_analyzer_dumpExtent(a); // expected-warning {{8 S64b}}; clang_analyzer_dumpElementCount(a); // expected-warning {{2 S64b}}; }. - ``clang_analyzer_value(a single argument of integer or pointer type)``. Prints an associated value for the given argument.; Supported argument types are integers, enums and pointers.; The value can be represented either as a range set or as a concrete integer.; For the rest of the types function prints ``n/a`` (aka not available). **Note:** This function will print nothing for clang built with Z3 constraint manager.; This may cause crashes of your tests. To manage this use one of the test constraining; techniques:. * llvm-lit commands ``REQUIRES no-z3`` or ``UNSUPPORTED z3`` `See for details. <https://llvm.org/docs/TestingGuide.html#constraining-test-execution>`_. * a preprocessor directive ``#ifndef ANALYZER_CM_Z3``. * a clang command argument ``-analyzer-constraints=range``. Example usage::. void print(char c, unsigned u) {; clang_analyzer_value(c); // expected-warning {{8s:{ [-128, 127] }}}; if(u != 42); clang_analyzer_value(u); // expected-warning {{32u:{ [0, 41], [43, 4294967295] }}}; else; clang_analyzer_value(u); // expected-warning {{32u:42}}; }. Statistics; ==========. The debug.Stats checker collects various information about the analysis of each; function, such as how many blocks were reached and if the analyzer timed out. There is also an additional -analyzer-stats flag, which enables various; statistics within the analyzer engine. Note the Stats checker (which produces at; least one bug report per function) may actually change the values reported by; -",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst:11414,Testability,test,test-execution,11414,"gle argument of any type)``; - ``clang_analyzer_dumpElementCount(a single argument of any type)``. Dumps out the extent and the element count of the argument. Example usage::. void array() {; int a[] = {1, 3};; clang_analyzer_dumpExtent(a); // expected-warning {{8 S64b}}; clang_analyzer_dumpElementCount(a); // expected-warning {{2 S64b}}; }. - ``clang_analyzer_value(a single argument of integer or pointer type)``. Prints an associated value for the given argument.; Supported argument types are integers, enums and pointers.; The value can be represented either as a range set or as a concrete integer.; For the rest of the types function prints ``n/a`` (aka not available). **Note:** This function will print nothing for clang built with Z3 constraint manager.; This may cause crashes of your tests. To manage this use one of the test constraining; techniques:. * llvm-lit commands ``REQUIRES no-z3`` or ``UNSUPPORTED z3`` `See for details. <https://llvm.org/docs/TestingGuide.html#constraining-test-execution>`_. * a preprocessor directive ``#ifndef ANALYZER_CM_Z3``. * a clang command argument ``-analyzer-constraints=range``. Example usage::. void print(char c, unsigned u) {; clang_analyzer_value(c); // expected-warning {{8s:{ [-128, 127] }}}; if(u != 42); clang_analyzer_value(u); // expected-warning {{32u:{ [0, 41], [43, 4294967295] }}}; else; clang_analyzer_value(u); // expected-warning {{32u:42}}; }. Statistics; ==========. The debug.Stats checker collects various information about the analysis of each; function, such as how many blocks were reached and if the analyzer timed out. There is also an additional -analyzer-stats flag, which enables various; statistics within the analyzer engine. Note the Stats checker (which produces at; least one bug report per function) may actually change the values reported by; -analyzer-stats. Output testing checkers; =======================. - debug.ReportStmts reports a warning at **every** statement, making it a very; useful tool for tes",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst:12272,Testability,test,testing,12272,"t(a single argument of any type)``. Dumps out the extent and the element count of the argument. Example usage::. void array() {; int a[] = {1, 3};; clang_analyzer_dumpExtent(a); // expected-warning {{8 S64b}}; clang_analyzer_dumpElementCount(a); // expected-warning {{2 S64b}}; }. - ``clang_analyzer_value(a single argument of integer or pointer type)``. Prints an associated value for the given argument.; Supported argument types are integers, enums and pointers.; The value can be represented either as a range set or as a concrete integer.; For the rest of the types function prints ``n/a`` (aka not available). **Note:** This function will print nothing for clang built with Z3 constraint manager.; This may cause crashes of your tests. To manage this use one of the test constraining; techniques:. * llvm-lit commands ``REQUIRES no-z3`` or ``UNSUPPORTED z3`` `See for details. <https://llvm.org/docs/TestingGuide.html#constraining-test-execution>`_. * a preprocessor directive ``#ifndef ANALYZER_CM_Z3``. * a clang command argument ``-analyzer-constraints=range``. Example usage::. void print(char c, unsigned u) {; clang_analyzer_value(c); // expected-warning {{8s:{ [-128, 127] }}}; if(u != 42); clang_analyzer_value(u); // expected-warning {{32u:{ [0, 41], [43, 4294967295] }}}; else; clang_analyzer_value(u); // expected-warning {{32u:42}}; }. Statistics; ==========. The debug.Stats checker collects various information about the analysis of each; function, such as how many blocks were reached and if the analyzer timed out. There is also an additional -analyzer-stats flag, which enables various; statistics within the analyzer engine. Note the Stats checker (which produces at; least one bug report per function) may actually change the values reported by; -analyzer-stats. Output testing checkers; =======================. - debug.ReportStmts reports a warning at **every** statement, making it a very; useful tool for testing thoroughly bug report construction and output; emission.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst:12411,Testability,test,testing,12411,"t(a single argument of any type)``. Dumps out the extent and the element count of the argument. Example usage::. void array() {; int a[] = {1, 3};; clang_analyzer_dumpExtent(a); // expected-warning {{8 S64b}}; clang_analyzer_dumpElementCount(a); // expected-warning {{2 S64b}}; }. - ``clang_analyzer_value(a single argument of integer or pointer type)``. Prints an associated value for the given argument.; Supported argument types are integers, enums and pointers.; The value can be represented either as a range set or as a concrete integer.; For the rest of the types function prints ``n/a`` (aka not available). **Note:** This function will print nothing for clang built with Z3 constraint manager.; This may cause crashes of your tests. To manage this use one of the test constraining; techniques:. * llvm-lit commands ``REQUIRES no-z3`` or ``UNSUPPORTED z3`` `See for details. <https://llvm.org/docs/TestingGuide.html#constraining-test-execution>`_. * a preprocessor directive ``#ifndef ANALYZER_CM_Z3``. * a clang command argument ``-analyzer-constraints=range``. Example usage::. void print(char c, unsigned u) {; clang_analyzer_value(c); // expected-warning {{8s:{ [-128, 127] }}}; if(u != 42); clang_analyzer_value(u); // expected-warning {{32u:{ [0, 41], [43, 4294967295] }}}; else; clang_analyzer_value(u); // expected-warning {{32u:42}}; }. Statistics; ==========. The debug.Stats checker collects various information about the analysis of each; function, such as how many blocks were reached and if the analyzer timed out. There is also an additional -analyzer-stats flag, which enables various; statistics within the analyzer engine. Note the Stats checker (which produces at; least one bug report per function) may actually change the values reported by; -analyzer-stats. Output testing checkers; =======================. - debug.ReportStmts reports a warning at **every** statement, making it a very; useful tool for testing thoroughly bug report construction and output; emission.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst:6701,Usability,simpl,simplify,6701,"age collection run, the checker sees if the marked symbol is; being collected and issues the 'SYMBOL DEAD' warning if it does.; This way you know where exactly, up to the line of code, the symbol dies. It is unlikely that you call this function after the symbol is already dead,; because the very reference to it as the function argument prevents it from; dying. However, if the argument is not a symbol but a concrete value,; no warning would be issued. Example usage::. do {; int x = generate_some_integer();; clang_analyzer_warnOnDeadSymbol(x);; } while(0); // expected-warning{{SYMBOL DEAD}}. - ``void clang_analyzer_explain(a single argument of any type);``. This function explains the value of its argument in a human-readable manner; in the warning message. You can make as many overrides of its prototype; in the test code as necessary to explain various integral, pointer,; or even record-type values. To simplify usage in C code (where overloading; the function declaration is not allowed), you may append an arbitrary suffix; to the function name, without affecting functionality. Example usage::. void clang_analyzer_explain(int);; void clang_analyzer_explain(void *);. // Useful in C code; void clang_analyzer_explain_int(int);. void foo(int param, void *ptr) {; clang_analyzer_explain(param); // expected-warning{{argument 'param'}}; clang_analyzer_explain_int(param); // expected-warning{{argument 'param'}}; if (!ptr); clang_analyzer_explain(ptr); // expected-warning{{memory address '0'}}; }. - ``void clang_analyzer_dump( /* a single argument of any type */);``. Similar to clang_analyzer_explain, but produces a raw dump of the value,; same as SVal::dump(). Example usage::. void clang_analyzer_dump(int);; void foo(int x) {; clang_analyzer_dump(x); // expected-warning{{reg_$0<x>}}; }. - ``size_t clang_analyzer_getExtent(void *);``. This function returns the value that represents the extent of a memory region; pointed to by the argument. This value is often difficult to obtain ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/DebugChecks.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:869,Deployability,patch,patch,869,"================; Initializer List; ================; This discussion took place in https://reviews.llvm.org/D35216; ""Escape symbols when creating std::initializer_list"". It touches problems of modelling C++ standard library constructs in general,; including modelling implementation-defined fields within C++ standard library; objects, in particular constructing objects into pointers held by such fields,; and separation of responsibilities between analyzer's core and checkers. **Artem:**. I've seen a few false positives that appear because we construct; C++11 std::initializer_list objects with brace initializers, and such; construction is not properly modeled. For instance, if a new object is; constructed on the heap only to be put into a brace-initialized STL container,; the object is reported to be leaked. Approach (0): This can be trivially fixed by this patch, which causes pointers; passed into initializer list expressions to immediately escape. This fix is overly conservative though. So i did a bit of investigation as to; how model std::initializer_list better. According to the standard, ``std::initializer_list<T>`` is an object that has; methods ``begin(), end(), and size()``, where ``begin()`` returns a pointer to continuous; array of ``size()`` objects of type T, and end() is equal to begin() plus size().; The standard does hint that it should be possible to implement; ``std::initializer_list<T>`` as a pair of pointers, or as a pointer and a size; integer, however specific fields that the object would contain are an; implementation detail. Ideally, we should be able to model the initializer list's methods precisely.; Or, at least, it should be possible to explain to the analyzer that the list; somehow ""takes hold"" of the values put into it. Initializer lists can also be; copied, which is a separate story that i'm not trying to address here. The obvious approach to modeling ``std::initializer_list`` in a checker would be to; construct a SymbolMetadata for the m",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:1240,Deployability,continuous,continuous,1240," standard library constructs in general,; including modelling implementation-defined fields within C++ standard library; objects, in particular constructing objects into pointers held by such fields,; and separation of responsibilities between analyzer's core and checkers. **Artem:**. I've seen a few false positives that appear because we construct; C++11 std::initializer_list objects with brace initializers, and such; construction is not properly modeled. For instance, if a new object is; constructed on the heap only to be put into a brace-initialized STL container,; the object is reported to be leaked. Approach (0): This can be trivially fixed by this patch, which causes pointers; passed into initializer list expressions to immediately escape. This fix is overly conservative though. So i did a bit of investigation as to; how model std::initializer_list better. According to the standard, ``std::initializer_list<T>`` is an object that has; methods ``begin(), end(), and size()``, where ``begin()`` returns a pointer to continuous; array of ``size()`` objects of type T, and end() is equal to begin() plus size().; The standard does hint that it should be possible to implement; ``std::initializer_list<T>`` as a pair of pointers, or as a pointer and a size; integer, however specific fields that the object would contain are an; implementation detail. Ideally, we should be able to model the initializer list's methods precisely.; Or, at least, it should be possible to explain to the analyzer that the list; somehow ""takes hold"" of the values put into it. Initializer lists can also be; copied, which is a separate story that i'm not trying to address here. The obvious approach to modeling ``std::initializer_list`` in a checker would be to; construct a SymbolMetadata for the memory region of the initializer list object,; which would be of type ``T*`` and represent ``begin()``, so we'd trivially model ``begin()``; as a function that returns this symbol. The array pointed to by th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:3141,Deployability,patch,patch,3141,"del ``begin()``; as a function that returns this symbol. The array pointed to by that symbol; would be ``bindLoc()``ed to contain the list's contents (probably as a ``CompoundVal``; to produce less bindings in the store). Extent of this array would represent; ``size()`` and would be equal to the length of the list as written. So this sounds good, however apparently it does nothing to address our false; positives: when the list escapes, our ``RegionStoreManager`` is not magically; guessing that the metadata symbol attached to it, together with its contents,; should also escape. In fact, it's impossible to trigger a pointer escape from; within the checker. Approach (1): If only we enabled ``ProgramState::bindLoc(..., notifyChanges=true)``; to cause pointer escapes (not only region changes) (which sounds like the right; thing to do anyway) such checker would be able to solve the false positives by; triggering escapes when binding list elements to the list. However, it'd be as; conservative as the current patch's solution. Ideally, we do not want escapes to; happen so early. Instead, we'd prefer them to be delayed until the list itself; escapes. So i believe that escaping metadata symbols whenever their base regions escape; would be the right thing to do. Currently we didn't think about that because we; had neither pointer-type metadatas nor non-pointer escapes. Approach (2): We could teach the Store to scan itself for bindings to; metadata-symbolic-based regions during scanReachableSymbols() whenever a region; turns out to be reachable. This requires no work on checker side, but it sounds; performance-heavy. Approach (3): We could let checkers maintain the set of active metadata symbols; in the program state (ideally somewhere in the Store, which sounds weird but; causes the smallest amount of layering violations), so that the core knew what; to escape. This puts a stress on the checkers, but with a smart data map it; wouldn't be a problem. Approach (4): We could allow ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:12988,Deployability,patch,patch,12988," bar(const std::unique_ptr<int> &x);. void foo(std::unique_ptr<int> &x) {; int *a = x.get(); // (a, 0, direct): &AbstractStorageRegion; *a = 1; // (AbstractStorageRegion, 0, direct): 1 S32b; int *b = new int;; *b = 2; // (SymRegion{conj_$0<int *>}, 0 ,direct): 2 S32b; x.reset(b); // Checker map: x -> SymRegion{conj_$0<int *>}; bar(x); // 'a' doesn't escape (the pointer was unique), 'b' does.; clang_analyzer_eval(*a == 1); // Making this true is up to the checker.; clang_analyzer_eval(*b == 2); // Making this unknown is up to the checker.; }. The checker doesn't totally need to ensure that ``*a == 1`` passes - even though the; pointer was unique, it could theoretically have ``.get()``-ed above and the code; could of course break the uniqueness invariant (though we'd probably want it).; The checker can say that ""even if ``*a`` did escape, it was not because it was; stuffed directly into bar()"". The checker's direct responsibility, however, is to solve the ``*b == 2`` thing; (which is in fact the problem we're dealing with in this patch - escaping the; storage region of the object). So we're talking about one more operation over the program state (scanning; reachable symbols and regions) that cannot work without checker support. We can probably add a new callback ""checkReachableSymbols"" to solve this. This; is in fact also related to the dead symbols problem (we're scanning for live; symbols in the store and in the checkers separately, but we need to do so; simultaneously with a single worklist). Hmm, in fact this sounds like a good; idea; we can replace checkLiveSymbols with checkReachableSymbols. Or we could just have ghost member variables, and no checker support required at; all. For ghost member variables, the relation with their parent region (which; would be their superregion) is actually useful, the mutability of their contents; is expressed naturally, and the store automagically sees reachable symbols, live; symbols, escapes, invalidations, whatever. > In my vi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:17009,Deployability,patch,patch,17009,"nvalidation for free. As a metaphor, i'd probably compare it to body farms - the difference between; ghost member variables and metadata symbols seems to me like the difference; between body farms and evalCall. Both are nice to have, and body farms are very; pleasant to work with, even if not omnipotent. I think it's fine for a; FunctionDecl's body in a body farm to have a local variable, even if such; variable doesn't actually exist, even if it cannot be seen from outside the; function call. I'm not seeing immediate practical difference between ""it does; actually exist"" and ""it doesn't actually exist, just a handy abstraction"".; Similarly, i think it's fine if we have a ``CXXRecordDecl`` with; implementation-defined contents, and try to farm up a member variable as a handy; abstraction (we don't even need to know its name or offset, only that it's there; somewhere). **Artem:**. We've discussed it in person with Devin, and he provided more points to think; about:. * If the initializer list consists of non-POD data, constructors of list's; objects need to take the sub-region of the list's region as this-region In the; current (v2) version of this patch, these objects are constructed elsewhere and; then trivial-copied into the list's metadata pointer region, which may be; incorrect. This is our overall problem with C++ constructors, which manifests in; this case as well. Additionally, objects would need to be constructed in the; analyzer's core, which would not be able to predict that it needs to take a; checker-specific region as this-region, which makes it harder, though it might; be mitigated by sharing the checker state traits. * Because ""ghost variables"" are not material to the user, we need to somehow; make super sure that they don't make it into the diagnostic messages. So, because this needs further digging into overall C++ support and rises too; many questions, i'm delaying a better approach to this problem and will fall; back to the original trivial patch.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:17837,Deployability,patch,patch,17837,"nvalidation for free. As a metaphor, i'd probably compare it to body farms - the difference between; ghost member variables and metadata symbols seems to me like the difference; between body farms and evalCall. Both are nice to have, and body farms are very; pleasant to work with, even if not omnipotent. I think it's fine for a; FunctionDecl's body in a body farm to have a local variable, even if such; variable doesn't actually exist, even if it cannot be seen from outside the; function call. I'm not seeing immediate practical difference between ""it does; actually exist"" and ""it doesn't actually exist, just a handy abstraction"".; Similarly, i think it's fine if we have a ``CXXRecordDecl`` with; implementation-defined contents, and try to farm up a member variable as a handy; abstraction (we don't even need to know its name or offset, only that it's there; somewhere). **Artem:**. We've discussed it in person with Devin, and he provided more points to think; about:. * If the initializer list consists of non-POD data, constructors of list's; objects need to take the sub-region of the list's region as this-region In the; current (v2) version of this patch, these objects are constructed elsewhere and; then trivial-copied into the list's metadata pointer region, which may be; incorrect. This is our overall problem with C++ constructors, which manifests in; this case as well. Additionally, objects would need to be constructed in the; analyzer's core, which would not be able to predict that it needs to take a; checker-specific region as this-region, which makes it harder, though it might; be mitigated by sharing the checker state traits. * Because ""ghost variables"" are not material to the user, we need to somehow; make super sure that they don't make it into the diagnostic messages. So, because this needs further digging into overall C++ support and rises too; many questions, i'm delaying a better approach to this problem and will fall; back to the original trivial patch.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:6238,Energy Efficiency,power,powerful,6238,", then maybe it makes more sense to move language; construct modeling to the engine when the checker API is not sufficient instead; of complicating the API. Right now I have no preference or objections between the alternatives but there; are some random thoughts:. * Maybe it would be great to have a guideline how to evolve the analyzer and; follow it, so it can help us to decide in similar situations. * I do care about performance in this case. The reason is that we have a; limited performance budget. And I think we should not expect most of the checker; writers to add modeling of language constructs. So, in my opinion, it is ok to; have less nice/more verbose API for language modeling if we can have better; performance this way, since it only needs to be done once, and is done by the; framework developers. **Artem:** These are some great questions, i guess it'd be better to discuss; them more openly. As a quick dump of my current mood:. * To me it seems obvious that we need to aim for a checker API that is both; simple and powerful. This can probably by keeping the API as powerful as; necessary while providing a layer of simple ready-made solutions on top of it.; Probably a few reusable components for assembling checkers. And this layer; should ideally be pleasant enough to work with, so that people would prefer to; extend it when something is lacking, instead of falling back to the complex; omnipotent API. I'm thinking of AST matchers vs. AST visitors as a roughly; similar situation: matchers are not omnipotent, but they're so nice. * Separation between core and checkers is usually quite strange. Once we have; shared state traits, i generally wouldn't mind having region store or range; constraint manager as checkers (though it's probably not worth it to transform; them - just a mood). The main thing to avoid here would be the situation when; the checker overwrites stuff written by the core because it thinks it has a; better idea what's going on, so the core should",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:6288,Energy Efficiency,power,powerful,6288,"ficient instead; of complicating the API. Right now I have no preference or objections between the alternatives but there; are some random thoughts:. * Maybe it would be great to have a guideline how to evolve the analyzer and; follow it, so it can help us to decide in similar situations. * I do care about performance in this case. The reason is that we have a; limited performance budget. And I think we should not expect most of the checker; writers to add modeling of language constructs. So, in my opinion, it is ok to; have less nice/more verbose API for language modeling if we can have better; performance this way, since it only needs to be done once, and is done by the; framework developers. **Artem:** These are some great questions, i guess it'd be better to discuss; them more openly. As a quick dump of my current mood:. * To me it seems obvious that we need to aim for a checker API that is both; simple and powerful. This can probably by keeping the API as powerful as; necessary while providing a layer of simple ready-made solutions on top of it.; Probably a few reusable components for assembling checkers. And this layer; should ideally be pleasant enough to work with, so that people would prefer to; extend it when something is lacking, instead of falling back to the complex; omnipotent API. I'm thinking of AST matchers vs. AST visitors as a roughly; similar situation: matchers are not omnipotent, but they're so nice. * Separation between core and checkers is usually quite strange. Once we have; shared state traits, i generally wouldn't mind having region store or range; constraint manager as checkers (though it's probably not worth it to transform; them - just a mood). The main thing to avoid here would be the situation when; the checker overwrites stuff written by the core because it thinks it has a; better idea what's going on, so the core should provide a good default behavior. * Yeah, i totally care about performance as well, and if i try to implement; appr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:17641,Integrability,message,messages,17641,"nvalidation for free. As a metaphor, i'd probably compare it to body farms - the difference between; ghost member variables and metadata symbols seems to me like the difference; between body farms and evalCall. Both are nice to have, and body farms are very; pleasant to work with, even if not omnipotent. I think it's fine for a; FunctionDecl's body in a body farm to have a local variable, even if such; variable doesn't actually exist, even if it cannot be seen from outside the; function call. I'm not seeing immediate practical difference between ""it does; actually exist"" and ""it doesn't actually exist, just a handy abstraction"".; Similarly, i think it's fine if we have a ``CXXRecordDecl`` with; implementation-defined contents, and try to farm up a member variable as a handy; abstraction (we don't even need to know its name or offset, only that it's there; somewhere). **Artem:**. We've discussed it in person with Devin, and he provided more points to think; about:. * If the initializer list consists of non-POD data, constructors of list's; objects need to take the sub-region of the list's region as this-region In the; current (v2) version of this patch, these objects are constructed elsewhere and; then trivial-copied into the list's metadata pointer region, which may be; incorrect. This is our overall problem with C++ constructors, which manifests in; this case as well. Additionally, objects would need to be constructed in the; analyzer's core, which would not be able to predict that it needs to take a; checker-specific region as this-region, which makes it harder, though it might; be mitigated by sharing the checker state traits. * Because ""ghost variables"" are not material to the user, we need to somehow; make super sure that they don't make it into the diagnostic messages. So, because this needs further digging into overall C++ support and rises too; many questions, i'm delaying a better approach to this problem and will fall; back to the original trivial patch.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:5516,Modifiability,evolve,evolve,5516,"ng the approach (2) - it should be possible to avoid; performance overhead, and clarity seems nice. **Gabor:**. At this point, I am a bit wondering about two questions. * When should something belong to a checker and when should something belong to the engine?; Sometimes we model library aspects in the engine and model language constructs in checkers. * What is the checker programming model that we are aiming for? Maximum freedom or more easy checker development?. I think if we aim for maximum freedom, we do not need to worry about the; potential stress on checkers, and we can introduce abstractions to mitigate that; later on.; If we want to simplify the API, then maybe it makes more sense to move language; construct modeling to the engine when the checker API is not sufficient instead; of complicating the API. Right now I have no preference or objections between the alternatives but there; are some random thoughts:. * Maybe it would be great to have a guideline how to evolve the analyzer and; follow it, so it can help us to decide in similar situations. * I do care about performance in this case. The reason is that we have a; limited performance budget. And I think we should not expect most of the checker; writers to add modeling of language constructs. So, in my opinion, it is ok to; have less nice/more verbose API for language modeling if we can have better; performance this way, since it only needs to be done once, and is done by the; framework developers. **Artem:** These are some great questions, i guess it'd be better to discuss; them more openly. As a quick dump of my current mood:. * To me it seems obvious that we need to aim for a checker API that is both; simple and powerful. This can probably by keeping the API as powerful as; necessary while providing a layer of simple ready-made solutions on top of it.; Probably a few reusable components for assembling checkers. And this layer; should ideally be pleasant enough to work with, so that people would prefer",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:6537,Modifiability,extend,extend,6537,"r and; follow it, so it can help us to decide in similar situations. * I do care about performance in this case. The reason is that we have a; limited performance budget. And I think we should not expect most of the checker; writers to add modeling of language constructs. So, in my opinion, it is ok to; have less nice/more verbose API for language modeling if we can have better; performance this way, since it only needs to be done once, and is done by the; framework developers. **Artem:** These are some great questions, i guess it'd be better to discuss; them more openly. As a quick dump of my current mood:. * To me it seems obvious that we need to aim for a checker API that is both; simple and powerful. This can probably by keeping the API as powerful as; necessary while providing a layer of simple ready-made solutions on top of it.; Probably a few reusable components for assembling checkers. And this layer; should ideally be pleasant enough to work with, so that people would prefer to; extend it when something is lacking, instead of falling back to the complex; omnipotent API. I'm thinking of AST matchers vs. AST visitors as a roughly; similar situation: matchers are not omnipotent, but they're so nice. * Separation between core and checkers is usually quite strange. Once we have; shared state traits, i generally wouldn't mind having region store or range; constraint manager as checkers (though it's probably not worth it to transform; them - just a mood). The main thing to avoid here would be the situation when; the checker overwrites stuff written by the core because it thinks it has a; better idea what's going on, so the core should provide a good default behavior. * Yeah, i totally care about performance as well, and if i try to implement; approach, i'd make sure it's good. **Artem:**. > Approach (2): We could teach the Store to scan itself for bindings to; > metadata-symbolic-based regions during scanReachableSymbols() whenever; > a region turns out to be reach",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:8974,Modifiability,variab,variables,8974,"0.html), it would have; been much easier, because the ghost field would only contain the actual; metadata, and the Store would always know about it. This example adds to my; belief that ghost fields are exactly what we need for most C++ checkers. **Devin:**. In this case, I would be fine with some sort of; AbstractStorageMemoryRegion that meant ""here is a memory region and somewhere; reachable from here exists another region of type T"". Or even multiple regions; with different identifiers. This wouldn't specify how the memory is reachable,; but it would allow for transfer functions to get at those regions and it would; allow for invalidation. For ``std::initializer_list`` this reachable region would the region for the backing; array and the transfer functions for begin() and end() yield the beginning and; end element regions for it. In my view this differs from ghost variables in that (1) this storage does; actually exist (it is just a library implementation detail where that storage; lives) and (2) it is perfectly valid for a pointer into that storage to be; returned and for another part of the program to read or write from that storage.; (Well, in this case just read since it is allowed to be read-only memory). What I'm not OK with is modeling abstract analysis state (for example, the count; of a NSMutableArray or the typestate of a file handle) as a value stored in some; ginned up region in the store. This takes an easy problem that the analyzer does; well at (modeling typestate) and turns it into a hard one that the analyzer is; bad at (reasoning about the contents of the heap). I think the key criterion here is: ""is the region accessible from outside the; library"". That is, does the library expose the region as a pointer that can be; read to or written from in the client program? If so, then it makes sense for; this to be in the store: we are modeling reachable storage as storage. But if; we're just modeling arbitrary analysis facts that need to be invalidated ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:13602,Modifiability,variab,variables,13602,"eoretically have ``.get()``-ed above and the code; could of course break the uniqueness invariant (though we'd probably want it).; The checker can say that ""even if ``*a`` did escape, it was not because it was; stuffed directly into bar()"". The checker's direct responsibility, however, is to solve the ``*b == 2`` thing; (which is in fact the problem we're dealing with in this patch - escaping the; storage region of the object). So we're talking about one more operation over the program state (scanning; reachable symbols and regions) that cannot work without checker support. We can probably add a new callback ""checkReachableSymbols"" to solve this. This; is in fact also related to the dead symbols problem (we're scanning for live; symbols in the store and in the checkers separately, but we need to do so; simultaneously with a single worklist). Hmm, in fact this sounds like a good; idea; we can replace checkLiveSymbols with checkReachableSymbols. Or we could just have ghost member variables, and no checker support required at; all. For ghost member variables, the relation with their parent region (which; would be their superregion) is actually useful, the mutability of their contents; is expressed naturally, and the store automagically sees reachable symbols, live; symbols, escapes, invalidations, whatever. > In my view this differs from ghost variables in that (1) this storage does; > actually exist (it is just a library implementation detail where that storage; > lives) and (2) it is perfectly valid for a pointer into that storage to be; > returned and for another part of the program to read or write from that; > storage. (Well, in this case just read since it is allowed to be read-only; > memory). > What I'm not OK with is modeling abstract analysis state (for example, the; > count of a NSMutableArray or the typestate of a file handle) as a value stored; > in some ginned up region in the store.This takes an easy problem that the; > analyzer does well at (modeling typ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:13671,Modifiability,variab,variables,13671,"it was not because it was; stuffed directly into bar()"". The checker's direct responsibility, however, is to solve the ``*b == 2`` thing; (which is in fact the problem we're dealing with in this patch - escaping the; storage region of the object). So we're talking about one more operation over the program state (scanning; reachable symbols and regions) that cannot work without checker support. We can probably add a new callback ""checkReachableSymbols"" to solve this. This; is in fact also related to the dead symbols problem (we're scanning for live; symbols in the store and in the checkers separately, but we need to do so; simultaneously with a single worklist). Hmm, in fact this sounds like a good; idea; we can replace checkLiveSymbols with checkReachableSymbols. Or we could just have ghost member variables, and no checker support required at; all. For ghost member variables, the relation with their parent region (which; would be their superregion) is actually useful, the mutability of their contents; is expressed naturally, and the store automagically sees reachable symbols, live; symbols, escapes, invalidations, whatever. > In my view this differs from ghost variables in that (1) this storage does; > actually exist (it is just a library implementation detail where that storage; > lives) and (2) it is perfectly valid for a pointer into that storage to be; > returned and for another part of the program to read or write from that; > storage. (Well, in this case just read since it is allowed to be read-only; > memory). > What I'm not OK with is modeling abstract analysis state (for example, the; > count of a NSMutableArray or the typestate of a file handle) as a value stored; > in some ginned up region in the store.This takes an easy problem that the; > analyzer does well at (modeling typestate) and turns it into a hard one that; > the analyzer is bad at (reasoning about the contents of the heap). Yeah, i tend to agree on that. For simple typestates, this is probably a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:13972,Modifiability,variab,variables,13972,"gram state (scanning; reachable symbols and regions) that cannot work without checker support. We can probably add a new callback ""checkReachableSymbols"" to solve this. This; is in fact also related to the dead symbols problem (we're scanning for live; symbols in the store and in the checkers separately, but we need to do so; simultaneously with a single worklist). Hmm, in fact this sounds like a good; idea; we can replace checkLiveSymbols with checkReachableSymbols. Or we could just have ghost member variables, and no checker support required at; all. For ghost member variables, the relation with their parent region (which; would be their superregion) is actually useful, the mutability of their contents; is expressed naturally, and the store automagically sees reachable symbols, live; symbols, escapes, invalidations, whatever. > In my view this differs from ghost variables in that (1) this storage does; > actually exist (it is just a library implementation detail where that storage; > lives) and (2) it is perfectly valid for a pointer into that storage to be; > returned and for another part of the program to read or write from that; > storage. (Well, in this case just read since it is allowed to be read-only; > memory). > What I'm not OK with is modeling abstract analysis state (for example, the; > count of a NSMutableArray or the typestate of a file handle) as a value stored; > in some ginned up region in the store.This takes an easy problem that the; > analyzer does well at (modeling typestate) and turns it into a hard one that; > the analyzer is bad at (reasoning about the contents of the heap). Yeah, i tend to agree on that. For simple typestates, this is probably an; overkill, so let's definitely put aside the idea of ""ghost symbolic regions""; that i had earlier. But, to summarize a bit, in our current case, however, the typestate we're; looking for is the contents of the heap. And when we try to model such; typestates (complex in this specific manner, i.e. hea",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:15959,Modifiability,variab,variables,15959,"ate we're; looking for is the contents of the heap. And when we try to model such; typestates (complex in this specific manner, i.e. heap-like) in any checker, we; have a choice between re-doing this modeling in every such checker (which is; something analyzer is indeed good at, but at a price of making checkers heavy); or instead relying on the Store to do exactly what it's designed to do. > I think the key criterion here is: ""is the region accessible from outside; > the library"". That is, does the library expose the region as a pointer that; > can be read to or written from in the client program? If so, then it makes; > sense for this to be in the store: we are modeling reachable storage as; > storage. But if we're just modeling arbitrary analysis facts that need to be; > invalidated when a pointer escapes then we shouldn't try to gin up storage; > for them just to get invalidation for free. As a metaphor, i'd probably compare it to body farms - the difference between; ghost member variables and metadata symbols seems to me like the difference; between body farms and evalCall. Both are nice to have, and body farms are very; pleasant to work with, even if not omnipotent. I think it's fine for a; FunctionDecl's body in a body farm to have a local variable, even if such; variable doesn't actually exist, even if it cannot be seen from outside the; function call. I'm not seeing immediate practical difference between ""it does; actually exist"" and ""it doesn't actually exist, just a handy abstraction"".; Similarly, i think it's fine if we have a ``CXXRecordDecl`` with; implementation-defined contents, and try to farm up a member variable as a handy; abstraction (we don't even need to know its name or offset, only that it's there; somewhere). **Artem:**. We've discussed it in person with Devin, and he provided more points to think; about:. * If the initializer list consists of non-POD data, constructors of list's; objects need to take the sub-region of the list's region as t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:16227,Modifiability,variab,variable,16227," a price of making checkers heavy); or instead relying on the Store to do exactly what it's designed to do. > I think the key criterion here is: ""is the region accessible from outside; > the library"". That is, does the library expose the region as a pointer that; > can be read to or written from in the client program? If so, then it makes; > sense for this to be in the store: we are modeling reachable storage as; > storage. But if we're just modeling arbitrary analysis facts that need to be; > invalidated when a pointer escapes then we shouldn't try to gin up storage; > for them just to get invalidation for free. As a metaphor, i'd probably compare it to body farms - the difference between; ghost member variables and metadata symbols seems to me like the difference; between body farms and evalCall. Both are nice to have, and body farms are very; pleasant to work with, even if not omnipotent. I think it's fine for a; FunctionDecl's body in a body farm to have a local variable, even if such; variable doesn't actually exist, even if it cannot be seen from outside the; function call. I'm not seeing immediate practical difference between ""it does; actually exist"" and ""it doesn't actually exist, just a handy abstraction"".; Similarly, i think it's fine if we have a ``CXXRecordDecl`` with; implementation-defined contents, and try to farm up a member variable as a handy; abstraction (we don't even need to know its name or offset, only that it's there; somewhere). **Artem:**. We've discussed it in person with Devin, and he provided more points to think; about:. * If the initializer list consists of non-POD data, constructors of list's; objects need to take the sub-region of the list's region as this-region In the; current (v2) version of this patch, these objects are constructed elsewhere and; then trivial-copied into the list's metadata pointer region, which may be; incorrect. This is our overall problem with C++ constructors, which manifests in; this case as well. Additiona",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:16251,Modifiability,variab,variable,16251," a price of making checkers heavy); or instead relying on the Store to do exactly what it's designed to do. > I think the key criterion here is: ""is the region accessible from outside; > the library"". That is, does the library expose the region as a pointer that; > can be read to or written from in the client program? If so, then it makes; > sense for this to be in the store: we are modeling reachable storage as; > storage. But if we're just modeling arbitrary analysis facts that need to be; > invalidated when a pointer escapes then we shouldn't try to gin up storage; > for them just to get invalidation for free. As a metaphor, i'd probably compare it to body farms - the difference between; ghost member variables and metadata symbols seems to me like the difference; between body farms and evalCall. Both are nice to have, and body farms are very; pleasant to work with, even if not omnipotent. I think it's fine for a; FunctionDecl's body in a body farm to have a local variable, even if such; variable doesn't actually exist, even if it cannot be seen from outside the; function call. I'm not seeing immediate practical difference between ""it does; actually exist"" and ""it doesn't actually exist, just a handy abstraction"".; Similarly, i think it's fine if we have a ``CXXRecordDecl`` with; implementation-defined contents, and try to farm up a member variable as a handy; abstraction (we don't even need to know its name or offset, only that it's there; somewhere). **Artem:**. We've discussed it in person with Devin, and he provided more points to think; about:. * If the initializer list consists of non-POD data, constructors of list's; objects need to take the sub-region of the list's region as this-region In the; current (v2) version of this patch, these objects are constructed elsewhere and; then trivial-copied into the list's metadata pointer region, which may be; incorrect. This is our overall problem with C++ constructors, which manifests in; this case as well. Additiona",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:16610,Modifiability,variab,variable,16610,"is to be in the store: we are modeling reachable storage as; > storage. But if we're just modeling arbitrary analysis facts that need to be; > invalidated when a pointer escapes then we shouldn't try to gin up storage; > for them just to get invalidation for free. As a metaphor, i'd probably compare it to body farms - the difference between; ghost member variables and metadata symbols seems to me like the difference; between body farms and evalCall. Both are nice to have, and body farms are very; pleasant to work with, even if not omnipotent. I think it's fine for a; FunctionDecl's body in a body farm to have a local variable, even if such; variable doesn't actually exist, even if it cannot be seen from outside the; function call. I'm not seeing immediate practical difference between ""it does; actually exist"" and ""it doesn't actually exist, just a handy abstraction"".; Similarly, i think it's fine if we have a ``CXXRecordDecl`` with; implementation-defined contents, and try to farm up a member variable as a handy; abstraction (we don't even need to know its name or offset, only that it's there; somewhere). **Artem:**. We've discussed it in person with Devin, and he provided more points to think; about:. * If the initializer list consists of non-POD data, constructors of list's; objects need to take the sub-region of the list's region as this-region In the; current (v2) version of this patch, these objects are constructed elsewhere and; then trivial-copied into the list's metadata pointer region, which may be; incorrect. This is our overall problem with C++ constructors, which manifests in; this case as well. Additionally, objects would need to be constructed in the; analyzer's core, which would not be able to predict that it needs to take a; checker-specific region as this-region, which makes it harder, though it might; be mitigated by sharing the checker state traits. * Because ""ghost variables"" are not material to the user, we need to somehow; make super sure that t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:17520,Modifiability,variab,variables,17520,"nvalidation for free. As a metaphor, i'd probably compare it to body farms - the difference between; ghost member variables and metadata symbols seems to me like the difference; between body farms and evalCall. Both are nice to have, and body farms are very; pleasant to work with, even if not omnipotent. I think it's fine for a; FunctionDecl's body in a body farm to have a local variable, even if such; variable doesn't actually exist, even if it cannot be seen from outside the; function call. I'm not seeing immediate practical difference between ""it does; actually exist"" and ""it doesn't actually exist, just a handy abstraction"".; Similarly, i think it's fine if we have a ``CXXRecordDecl`` with; implementation-defined contents, and try to farm up a member variable as a handy; abstraction (we don't even need to know its name or offset, only that it's there; somewhere). **Artem:**. We've discussed it in person with Devin, and he provided more points to think; about:. * If the initializer list consists of non-POD data, constructors of list's; objects need to take the sub-region of the list's region as this-region In the; current (v2) version of this patch, these objects are constructed elsewhere and; then trivial-copied into the list's metadata pointer region, which may be; incorrect. This is our overall problem with C++ constructors, which manifests in; this case as well. Additionally, objects would need to be constructed in the; analyzer's core, which would not be able to predict that it needs to take a; checker-specific region as this-region, which makes it harder, though it might; be mitigated by sharing the checker state traits. * Because ""ghost variables"" are not material to the user, we need to somehow; make super sure that they don't make it into the diagnostic messages. So, because this needs further digging into overall C++ support and rises too; many questions, i'm delaying a better approach to this problem and will fall; back to the original trivial patch.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:3738,Performance,perform,performance-heavy,3738,"'s impossible to trigger a pointer escape from; within the checker. Approach (1): If only we enabled ``ProgramState::bindLoc(..., notifyChanges=true)``; to cause pointer escapes (not only region changes) (which sounds like the right; thing to do anyway) such checker would be able to solve the false positives by; triggering escapes when binding list elements to the list. However, it'd be as; conservative as the current patch's solution. Ideally, we do not want escapes to; happen so early. Instead, we'd prefer them to be delayed until the list itself; escapes. So i believe that escaping metadata symbols whenever their base regions escape; would be the right thing to do. Currently we didn't think about that because we; had neither pointer-type metadatas nor non-pointer escapes. Approach (2): We could teach the Store to scan itself for bindings to; metadata-symbolic-based regions during scanReachableSymbols() whenever a region; turns out to be reachable. This requires no work on checker side, but it sounds; performance-heavy. Approach (3): We could let checkers maintain the set of active metadata symbols; in the program state (ideally somewhere in the Store, which sounds weird but; causes the smallest amount of layering violations), so that the core knew what; to escape. This puts a stress on the checkers, but with a smart data map it; wouldn't be a problem. Approach (4): We could allow checkers to trigger pointer escapes in arbitrary; moments. If we allow doing this within ``checkPointerEscape`` callback itself, we; would be able to express facts like ""when this region escapes, that metadata; symbol attached to it should also escape"". This sounds like an ultimate freedom,; with maximum stress on the checkers - still not too much stress when we have; smart data maps. I'm personally liking the approach (2) - it should be possible to avoid; performance overhead, and clarity seems nice. **Gabor:**. At this point, I am a bit wondering about two questions. * When should somet",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:4586,Performance,perform,performance,4586," to; metadata-symbolic-based regions during scanReachableSymbols() whenever a region; turns out to be reachable. This requires no work on checker side, but it sounds; performance-heavy. Approach (3): We could let checkers maintain the set of active metadata symbols; in the program state (ideally somewhere in the Store, which sounds weird but; causes the smallest amount of layering violations), so that the core knew what; to escape. This puts a stress on the checkers, but with a smart data map it; wouldn't be a problem. Approach (4): We could allow checkers to trigger pointer escapes in arbitrary; moments. If we allow doing this within ``checkPointerEscape`` callback itself, we; would be able to express facts like ""when this region escapes, that metadata; symbol attached to it should also escape"". This sounds like an ultimate freedom,; with maximum stress on the checkers - still not too much stress when we have; smart data maps. I'm personally liking the approach (2) - it should be possible to avoid; performance overhead, and clarity seems nice. **Gabor:**. At this point, I am a bit wondering about two questions. * When should something belong to a checker and when should something belong to the engine?; Sometimes we model library aspects in the engine and model language constructs in checkers. * What is the checker programming model that we are aiming for? Maximum freedom or more easy checker development?. I think if we aim for maximum freedom, we do not need to worry about the; potential stress on checkers, and we can introduce abstractions to mitigate that; later on.; If we want to simplify the API, then maybe it makes more sense to move language; construct modeling to the engine when the checker API is not sufficient instead; of complicating the API. Right now I have no preference or objections between the alternatives but there; are some random thoughts:. * Maybe it would be great to have a guideline how to evolve the analyzer and; follow it, so it can help us to",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:5621,Performance,perform,performance,5621,"s nice. **Gabor:**. At this point, I am a bit wondering about two questions. * When should something belong to a checker and when should something belong to the engine?; Sometimes we model library aspects in the engine and model language constructs in checkers. * What is the checker programming model that we are aiming for? Maximum freedom or more easy checker development?. I think if we aim for maximum freedom, we do not need to worry about the; potential stress on checkers, and we can introduce abstractions to mitigate that; later on.; If we want to simplify the API, then maybe it makes more sense to move language; construct modeling to the engine when the checker API is not sufficient instead; of complicating the API. Right now I have no preference or objections between the alternatives but there; are some random thoughts:. * Maybe it would be great to have a guideline how to evolve the analyzer and; follow it, so it can help us to decide in similar situations. * I do care about performance in this case. The reason is that we have a; limited performance budget. And I think we should not expect most of the checker; writers to add modeling of language constructs. So, in my opinion, it is ok to; have less nice/more verbose API for language modeling if we can have better; performance this way, since it only needs to be done once, and is done by the; framework developers. **Artem:** These are some great questions, i guess it'd be better to discuss; them more openly. As a quick dump of my current mood:. * To me it seems obvious that we need to aim for a checker API that is both; simple and powerful. This can probably by keeping the API as powerful as; necessary while providing a layer of simple ready-made solutions on top of it.; Probably a few reusable components for assembling checkers. And this layer; should ideally be pleasant enough to work with, so that people would prefer to; extend it when something is lacking, instead of falling back to the complex; omnipotent",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:5685,Performance,perform,performance,5685,"ring about two questions. * When should something belong to a checker and when should something belong to the engine?; Sometimes we model library aspects in the engine and model language constructs in checkers. * What is the checker programming model that we are aiming for? Maximum freedom or more easy checker development?. I think if we aim for maximum freedom, we do not need to worry about the; potential stress on checkers, and we can introduce abstractions to mitigate that; later on.; If we want to simplify the API, then maybe it makes more sense to move language; construct modeling to the engine when the checker API is not sufficient instead; of complicating the API. Right now I have no preference or objections between the alternatives but there; are some random thoughts:. * Maybe it would be great to have a guideline how to evolve the analyzer and; follow it, so it can help us to decide in similar situations. * I do care about performance in this case. The reason is that we have a; limited performance budget. And I think we should not expect most of the checker; writers to add modeling of language constructs. So, in my opinion, it is ok to; have less nice/more verbose API for language modeling if we can have better; performance this way, since it only needs to be done once, and is done by the; framework developers. **Artem:** These are some great questions, i guess it'd be better to discuss; them more openly. As a quick dump of my current mood:. * To me it seems obvious that we need to aim for a checker API that is both; simple and powerful. This can probably by keeping the API as powerful as; necessary while providing a layer of simple ready-made solutions on top of it.; Probably a few reusable components for assembling checkers. And this layer; should ideally be pleasant enough to work with, so that people would prefer to; extend it when something is lacking, instead of falling back to the complex; omnipotent API. I'm thinking of AST matchers vs. AST visitors",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:5916,Performance,perform,performance,5916,"gramming model that we are aiming for? Maximum freedom or more easy checker development?. I think if we aim for maximum freedom, we do not need to worry about the; potential stress on checkers, and we can introduce abstractions to mitigate that; later on.; If we want to simplify the API, then maybe it makes more sense to move language; construct modeling to the engine when the checker API is not sufficient instead; of complicating the API. Right now I have no preference or objections between the alternatives but there; are some random thoughts:. * Maybe it would be great to have a guideline how to evolve the analyzer and; follow it, so it can help us to decide in similar situations. * I do care about performance in this case. The reason is that we have a; limited performance budget. And I think we should not expect most of the checker; writers to add modeling of language constructs. So, in my opinion, it is ok to; have less nice/more verbose API for language modeling if we can have better; performance this way, since it only needs to be done once, and is done by the; framework developers. **Artem:** These are some great questions, i guess it'd be better to discuss; them more openly. As a quick dump of my current mood:. * To me it seems obvious that we need to aim for a checker API that is both; simple and powerful. This can probably by keeping the API as powerful as; necessary while providing a layer of simple ready-made solutions on top of it.; Probably a few reusable components for assembling checkers. And this layer; should ideally be pleasant enough to work with, so that people would prefer to; extend it when something is lacking, instead of falling back to the complex; omnipotent API. I'm thinking of AST matchers vs. AST visitors as a roughly; similar situation: matchers are not omnipotent, but they're so nice. * Separation between core and checkers is usually quite strange. Once we have; shared state traits, i generally wouldn't mind having region store or ran",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:7261,Performance,perform,performance,7261," powerful as; necessary while providing a layer of simple ready-made solutions on top of it.; Probably a few reusable components for assembling checkers. And this layer; should ideally be pleasant enough to work with, so that people would prefer to; extend it when something is lacking, instead of falling back to the complex; omnipotent API. I'm thinking of AST matchers vs. AST visitors as a roughly; similar situation: matchers are not omnipotent, but they're so nice. * Separation between core and checkers is usually quite strange. Once we have; shared state traits, i generally wouldn't mind having region store or range; constraint manager as checkers (though it's probably not worth it to transform; them - just a mood). The main thing to avoid here would be the situation when; the checker overwrites stuff written by the core because it thinks it has a; better idea what's going on, so the core should provide a good default behavior. * Yeah, i totally care about performance as well, and if i try to implement; approach, i'd make sure it's good. **Artem:**. > Approach (2): We could teach the Store to scan itself for bindings to; > metadata-symbolic-based regions during scanReachableSymbols() whenever; > a region turns out to be reachable. This requires no work on checker side,; > but it sounds performance-heavy. Nope, this approach is wrong. Metadata symbols may become out-of-date: when the; object changes, metadata symbols attached to it aren't changing (because symbols; simply don't change). The same metadata may have different symbols to denote its; value in different moments of time, but at most one of them represents the; actual metadata value. So we'd be escaping more stuff than necessary. If only we had ""ghost fields""; (https://lists.llvm.org/pipermail/cfe-dev/2016-May/049000.html), it would have; been much easier, because the ghost field would only contain the actual; metadata, and the Store would always know about it. This example adds to my; belief that ghost f",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:7597,Performance,perform,performance-heavy,7597,"tead of falling back to the complex; omnipotent API. I'm thinking of AST matchers vs. AST visitors as a roughly; similar situation: matchers are not omnipotent, but they're so nice. * Separation between core and checkers is usually quite strange. Once we have; shared state traits, i generally wouldn't mind having region store or range; constraint manager as checkers (though it's probably not worth it to transform; them - just a mood). The main thing to avoid here would be the situation when; the checker overwrites stuff written by the core because it thinks it has a; better idea what's going on, so the core should provide a good default behavior. * Yeah, i totally care about performance as well, and if i try to implement; approach, i'd make sure it's good. **Artem:**. > Approach (2): We could teach the Store to scan itself for bindings to; > metadata-symbolic-based regions during scanReachableSymbols() whenever; > a region turns out to be reachable. This requires no work on checker side,; > but it sounds performance-heavy. Nope, this approach is wrong. Metadata symbols may become out-of-date: when the; object changes, metadata symbols attached to it aren't changing (because symbols; simply don't change). The same metadata may have different symbols to denote its; value in different moments of time, but at most one of them represents the; actual metadata value. So we'd be escaping more stuff than necessary. If only we had ""ghost fields""; (https://lists.llvm.org/pipermail/cfe-dev/2016-May/049000.html), it would have; been much easier, because the ghost field would only contain the actual; metadata, and the Store would always know about it. This example adds to my; belief that ghost fields are exactly what we need for most C++ checkers. **Devin:**. In this case, I would be fine with some sort of; AbstractStorageMemoryRegion that meant ""here is a memory region and somewhere; reachable from here exists another region of type T"". Or even multiple regions; with different id",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:4579,Safety,avoid,avoid,4579," to; metadata-symbolic-based regions during scanReachableSymbols() whenever a region; turns out to be reachable. This requires no work on checker side, but it sounds; performance-heavy. Approach (3): We could let checkers maintain the set of active metadata symbols; in the program state (ideally somewhere in the Store, which sounds weird but; causes the smallest amount of layering violations), so that the core knew what; to escape. This puts a stress on the checkers, but with a smart data map it; wouldn't be a problem. Approach (4): We could allow checkers to trigger pointer escapes in arbitrary; moments. If we allow doing this within ``checkPointerEscape`` callback itself, we; would be able to express facts like ""when this region escapes, that metadata; symbol attached to it should also escape"". This sounds like an ultimate freedom,; with maximum stress on the checkers - still not too much stress when we have; smart data maps. I'm personally liking the approach (2) - it should be possible to avoid; performance overhead, and clarity seems nice. **Gabor:**. At this point, I am a bit wondering about two questions. * When should something belong to a checker and when should something belong to the engine?; Sometimes we model library aspects in the engine and model language constructs in checkers. * What is the checker programming model that we are aiming for? Maximum freedom or more easy checker development?. I think if we aim for maximum freedom, we do not need to worry about the; potential stress on checkers, and we can introduce abstractions to mitigate that; later on.; If we want to simplify the API, then maybe it makes more sense to move language; construct modeling to the engine when the checker API is not sufficient instead; of complicating the API. Right now I have no preference or objections between the alternatives but there; are some random thoughts:. * Maybe it would be great to have a guideline how to evolve the analyzer and; follow it, so it can help us to",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:7034,Safety,avoid,avoid,7034," dump of my current mood:. * To me it seems obvious that we need to aim for a checker API that is both; simple and powerful. This can probably by keeping the API as powerful as; necessary while providing a layer of simple ready-made solutions on top of it.; Probably a few reusable components for assembling checkers. And this layer; should ideally be pleasant enough to work with, so that people would prefer to; extend it when something is lacking, instead of falling back to the complex; omnipotent API. I'm thinking of AST matchers vs. AST visitors as a roughly; similar situation: matchers are not omnipotent, but they're so nice. * Separation between core and checkers is usually quite strange. Once we have; shared state traits, i generally wouldn't mind having region store or range; constraint manager as checkers (though it's probably not worth it to transform; them - just a mood). The main thing to avoid here would be the situation when; the checker overwrites stuff written by the core because it thinks it has a; better idea what's going on, so the core should provide a good default behavior. * Yeah, i totally care about performance as well, and if i try to implement; approach, i'd make sure it's good. **Artem:**. > Approach (2): We could teach the Store to scan itself for bindings to; > metadata-symbolic-based regions during scanReachableSymbols() whenever; > a region turns out to be reachable. This requires no work on checker side,; > but it sounds performance-heavy. Nope, this approach is wrong. Metadata symbols may become out-of-date: when the; object changes, metadata symbols attached to it aren't changing (because symbols; simply don't change). The same metadata may have different symbols to denote its; value in different moments of time, but at most one of them represents the; actual metadata value. So we'd be escaping more stuff than necessary. If only we had ""ghost fields""; (https://lists.llvm.org/pipermail/cfe-dev/2016-May/049000.html), it would have; been ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:17340,Safety,predict,predict,17340,"nvalidation for free. As a metaphor, i'd probably compare it to body farms - the difference between; ghost member variables and metadata symbols seems to me like the difference; between body farms and evalCall. Both are nice to have, and body farms are very; pleasant to work with, even if not omnipotent. I think it's fine for a; FunctionDecl's body in a body farm to have a local variable, even if such; variable doesn't actually exist, even if it cannot be seen from outside the; function call. I'm not seeing immediate practical difference between ""it does; actually exist"" and ""it doesn't actually exist, just a handy abstraction"".; Similarly, i think it's fine if we have a ``CXXRecordDecl`` with; implementation-defined contents, and try to farm up a member variable as a handy; abstraction (we don't even need to know its name or offset, only that it's there; somewhere). **Artem:**. We've discussed it in person with Devin, and he provided more points to think; about:. * If the initializer list consists of non-POD data, constructors of list's; objects need to take the sub-region of the list's region as this-region In the; current (v2) version of this patch, these objects are constructed elsewhere and; then trivial-copied into the list's metadata pointer region, which may be; incorrect. This is our overall problem with C++ constructors, which manifests in; this case as well. Additionally, objects would need to be constructed in the; analyzer's core, which would not be able to predict that it needs to take a; checker-specific region as this-region, which makes it harder, though it might; be mitigated by sharing the checker state traits. * Because ""ghost variables"" are not material to the user, we need to somehow; make super sure that they don't make it into the diagnostic messages. So, because this needs further digging into overall C++ support and rises too; many questions, i'm delaying a better approach to this problem and will fall; back to the original trivial patch.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:9754,Security,access,accessible,9754,"r ``std::initializer_list`` this reachable region would the region for the backing; array and the transfer functions for begin() and end() yield the beginning and; end element regions for it. In my view this differs from ghost variables in that (1) this storage does; actually exist (it is just a library implementation detail where that storage; lives) and (2) it is perfectly valid for a pointer into that storage to be; returned and for another part of the program to read or write from that storage.; (Well, in this case just read since it is allowed to be read-only memory). What I'm not OK with is modeling abstract analysis state (for example, the count; of a NSMutableArray or the typestate of a file handle) as a value stored in some; ginned up region in the store. This takes an easy problem that the analyzer does; well at (modeling typestate) and turns it into a hard one that the analyzer is; bad at (reasoning about the contents of the heap). I think the key criterion here is: ""is the region accessible from outside the; library"". That is, does the library expose the region as a pointer that can be; read to or written from in the client program? If so, then it makes sense for; this to be in the store: we are modeling reachable storage as storage. But if; we're just modeling arbitrary analysis facts that need to be invalidated when a; pointer escapes then we shouldn't try to gin up storage for them just to get; invalidation for free. **Artem:**. > In this case, I would be fine with some sort of ``AbstractStorageMemoryRegion``; > that meant ""here is a memory region and somewhere reachable from here exists; > another region of type T"". Or even multiple regions with different; > identifiers. This wouldn't specify how the memory is reachable, but it would; > allow for transfer functions to get at those regions and it would allow for; > invalidation. Yeah, this is what we can easily implement now as a; symbolic-region-based-on-a-metadata-symbol (though we can make a new reg",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:9819,Security,expose,expose,9819,"ing and; end element regions for it. In my view this differs from ghost variables in that (1) this storage does; actually exist (it is just a library implementation detail where that storage; lives) and (2) it is perfectly valid for a pointer into that storage to be; returned and for another part of the program to read or write from that storage.; (Well, in this case just read since it is allowed to be read-only memory). What I'm not OK with is modeling abstract analysis state (for example, the count; of a NSMutableArray or the typestate of a file handle) as a value stored in some; ginned up region in the store. This takes an easy problem that the analyzer does; well at (modeling typestate) and turns it into a hard one that the analyzer is; bad at (reasoning about the contents of the heap). I think the key criterion here is: ""is the region accessible from outside the; library"". That is, does the library expose the region as a pointer that can be; read to or written from in the client program? If so, then it makes sense for; this to be in the store: we are modeling reachable storage as storage. But if; we're just modeling arbitrary analysis facts that need to be invalidated when a; pointer escapes then we shouldn't try to gin up storage for them just to get; invalidation for free. **Artem:**. > In this case, I would be fine with some sort of ``AbstractStorageMemoryRegion``; > that meant ""here is a memory region and somewhere reachable from here exists; > another region of type T"". Or even multiple regions with different; > identifiers. This wouldn't specify how the memory is reachable, but it would; > allow for transfer functions to get at those regions and it would allow for; > invalidation. Yeah, this is what we can easily implement now as a; symbolic-region-based-on-a-metadata-symbol (though we can make a new region; class for that if we eg. want it typed). The problem is that the relation; between such storage region and its parent object region is essentially; i",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:15406,Security,access,accessible,15406," example, the; > count of a NSMutableArray or the typestate of a file handle) as a value stored; > in some ginned up region in the store.This takes an easy problem that the; > analyzer does well at (modeling typestate) and turns it into a hard one that; > the analyzer is bad at (reasoning about the contents of the heap). Yeah, i tend to agree on that. For simple typestates, this is probably an; overkill, so let's definitely put aside the idea of ""ghost symbolic regions""; that i had earlier. But, to summarize a bit, in our current case, however, the typestate we're; looking for is the contents of the heap. And when we try to model such; typestates (complex in this specific manner, i.e. heap-like) in any checker, we; have a choice between re-doing this modeling in every such checker (which is; something analyzer is indeed good at, but at a price of making checkers heavy); or instead relying on the Store to do exactly what it's designed to do. > I think the key criterion here is: ""is the region accessible from outside; > the library"". That is, does the library expose the region as a pointer that; > can be read to or written from in the client program? If so, then it makes; > sense for this to be in the store: we are modeling reachable storage as; > storage. But if we're just modeling arbitrary analysis facts that need to be; > invalidated when a pointer escapes then we shouldn't try to gin up storage; > for them just to get invalidation for free. As a metaphor, i'd probably compare it to body farms - the difference between; ghost member variables and metadata symbols seems to me like the difference; between body farms and evalCall. Both are nice to have, and body farms are very; pleasant to work with, even if not omnipotent. I think it's fine for a; FunctionDecl's body in a body farm to have a local variable, even if such; variable doesn't actually exist, even if it cannot be seen from outside the; function call. I'm not seeing immediate practical difference between ""it",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:15473,Security,expose,expose,15473,"lem that the; > analyzer does well at (modeling typestate) and turns it into a hard one that; > the analyzer is bad at (reasoning about the contents of the heap). Yeah, i tend to agree on that. For simple typestates, this is probably an; overkill, so let's definitely put aside the idea of ""ghost symbolic regions""; that i had earlier. But, to summarize a bit, in our current case, however, the typestate we're; looking for is the contents of the heap. And when we try to model such; typestates (complex in this specific manner, i.e. heap-like) in any checker, we; have a choice between re-doing this modeling in every such checker (which is; something analyzer is indeed good at, but at a price of making checkers heavy); or instead relying on the Store to do exactly what it's designed to do. > I think the key criterion here is: ""is the region accessible from outside; > the library"". That is, does the library expose the region as a pointer that; > can be read to or written from in the client program? If so, then it makes; > sense for this to be in the store: we are modeling reachable storage as; > storage. But if we're just modeling arbitrary analysis facts that need to be; > invalidated when a pointer escapes then we shouldn't try to gin up storage; > for them just to get invalidation for free. As a metaphor, i'd probably compare it to body farms - the difference between; ghost member variables and metadata symbols seems to me like the difference; between body farms and evalCall. Both are nice to have, and body farms are very; pleasant to work with, even if not omnipotent. I think it's fine for a; FunctionDecl's body in a body farm to have a local variable, even if such; variable doesn't actually exist, even if it cannot be seen from outside the; function call. I'm not seeing immediate practical difference between ""it does; actually exist"" and ""it doesn't actually exist, just a handy abstraction"".; Similarly, i think it's fine if we have a ``CXXRecordDecl`` with; implementat",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:5182,Usability,simpl,simplify,5182,"uld be able to express facts like ""when this region escapes, that metadata; symbol attached to it should also escape"". This sounds like an ultimate freedom,; with maximum stress on the checkers - still not too much stress when we have; smart data maps. I'm personally liking the approach (2) - it should be possible to avoid; performance overhead, and clarity seems nice. **Gabor:**. At this point, I am a bit wondering about two questions. * When should something belong to a checker and when should something belong to the engine?; Sometimes we model library aspects in the engine and model language constructs in checkers. * What is the checker programming model that we are aiming for? Maximum freedom or more easy checker development?. I think if we aim for maximum freedom, we do not need to worry about the; potential stress on checkers, and we can introduce abstractions to mitigate that; later on.; If we want to simplify the API, then maybe it makes more sense to move language; construct modeling to the engine when the checker API is not sufficient instead; of complicating the API. Right now I have no preference or objections between the alternatives but there; are some random thoughts:. * Maybe it would be great to have a guideline how to evolve the analyzer and; follow it, so it can help us to decide in similar situations. * I do care about performance in this case. The reason is that we have a; limited performance budget. And I think we should not expect most of the checker; writers to add modeling of language constructs. So, in my opinion, it is ok to; have less nice/more verbose API for language modeling if we can have better; performance this way, since it only needs to be done once, and is done by the; framework developers. **Artem:** These are some great questions, i guess it'd be better to discuss; them more openly. As a quick dump of my current mood:. * To me it seems obvious that we need to aim for a checker API that is both; simple and powerful. This can pro",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:5499,Usability,guid,guideline,5499,"ng the approach (2) - it should be possible to avoid; performance overhead, and clarity seems nice. **Gabor:**. At this point, I am a bit wondering about two questions. * When should something belong to a checker and when should something belong to the engine?; Sometimes we model library aspects in the engine and model language constructs in checkers. * What is the checker programming model that we are aiming for? Maximum freedom or more easy checker development?. I think if we aim for maximum freedom, we do not need to worry about the; potential stress on checkers, and we can introduce abstractions to mitigate that; later on.; If we want to simplify the API, then maybe it makes more sense to move language; construct modeling to the engine when the checker API is not sufficient instead; of complicating the API. Right now I have no preference or objections between the alternatives but there; are some random thoughts:. * Maybe it would be great to have a guideline how to evolve the analyzer and; follow it, so it can help us to decide in similar situations. * I do care about performance in this case. The reason is that we have a; limited performance budget. And I think we should not expect most of the checker; writers to add modeling of language constructs. So, in my opinion, it is ok to; have less nice/more verbose API for language modeling if we can have better; performance this way, since it only needs to be done once, and is done by the; framework developers. **Artem:** These are some great questions, i guess it'd be better to discuss; them more openly. As a quick dump of my current mood:. * To me it seems obvious that we need to aim for a checker API that is both; simple and powerful. This can probably by keeping the API as powerful as; necessary while providing a layer of simple ready-made solutions on top of it.; Probably a few reusable components for assembling checkers. And this layer; should ideally be pleasant enough to work with, so that people would prefer",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:6227,Usability,simpl,simple,6227,", then maybe it makes more sense to move language; construct modeling to the engine when the checker API is not sufficient instead; of complicating the API. Right now I have no preference or objections between the alternatives but there; are some random thoughts:. * Maybe it would be great to have a guideline how to evolve the analyzer and; follow it, so it can help us to decide in similar situations. * I do care about performance in this case. The reason is that we have a; limited performance budget. And I think we should not expect most of the checker; writers to add modeling of language constructs. So, in my opinion, it is ok to; have less nice/more verbose API for language modeling if we can have better; performance this way, since it only needs to be done once, and is done by the; framework developers. **Artem:** These are some great questions, i guess it'd be better to discuss; them more openly. As a quick dump of my current mood:. * To me it seems obvious that we need to aim for a checker API that is both; simple and powerful. This can probably by keeping the API as powerful as; necessary while providing a layer of simple ready-made solutions on top of it.; Probably a few reusable components for assembling checkers. And this layer; should ideally be pleasant enough to work with, so that people would prefer to; extend it when something is lacking, instead of falling back to the complex; omnipotent API. I'm thinking of AST matchers vs. AST visitors as a roughly; similar situation: matchers are not omnipotent, but they're so nice. * Separation between core and checkers is usually quite strange. Once we have; shared state traits, i generally wouldn't mind having region store or range; constraint manager as checkers (though it's probably not worth it to transform; them - just a mood). The main thing to avoid here would be the situation when; the checker overwrites stuff written by the core because it thinks it has a; better idea what's going on, so the core should",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:6338,Usability,simpl,simple,6338,"ficient instead; of complicating the API. Right now I have no preference or objections between the alternatives but there; are some random thoughts:. * Maybe it would be great to have a guideline how to evolve the analyzer and; follow it, so it can help us to decide in similar situations. * I do care about performance in this case. The reason is that we have a; limited performance budget. And I think we should not expect most of the checker; writers to add modeling of language constructs. So, in my opinion, it is ok to; have less nice/more verbose API for language modeling if we can have better; performance this way, since it only needs to be done once, and is done by the; framework developers. **Artem:** These are some great questions, i guess it'd be better to discuss; them more openly. As a quick dump of my current mood:. * To me it seems obvious that we need to aim for a checker API that is both; simple and powerful. This can probably by keeping the API as powerful as; necessary while providing a layer of simple ready-made solutions on top of it.; Probably a few reusable components for assembling checkers. And this layer; should ideally be pleasant enough to work with, so that people would prefer to; extend it when something is lacking, instead of falling back to the complex; omnipotent API. I'm thinking of AST matchers vs. AST visitors as a roughly; similar situation: matchers are not omnipotent, but they're so nice. * Separation between core and checkers is usually quite strange. Once we have; shared state traits, i generally wouldn't mind having region store or range; constraint manager as checkers (though it's probably not worth it to transform; them - just a mood). The main thing to avoid here would be the situation when; the checker overwrites stuff written by the core because it thinks it has a; better idea what's going on, so the core should provide a good default behavior. * Yeah, i totally care about performance as well, and if i try to implement; appr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:7779,Usability,simpl,simply,7779,"not omnipotent, but they're so nice. * Separation between core and checkers is usually quite strange. Once we have; shared state traits, i generally wouldn't mind having region store or range; constraint manager as checkers (though it's probably not worth it to transform; them - just a mood). The main thing to avoid here would be the situation when; the checker overwrites stuff written by the core because it thinks it has a; better idea what's going on, so the core should provide a good default behavior. * Yeah, i totally care about performance as well, and if i try to implement; approach, i'd make sure it's good. **Artem:**. > Approach (2): We could teach the Store to scan itself for bindings to; > metadata-symbolic-based regions during scanReachableSymbols() whenever; > a region turns out to be reachable. This requires no work on checker side,; > but it sounds performance-heavy. Nope, this approach is wrong. Metadata symbols may become out-of-date: when the; object changes, metadata symbols attached to it aren't changing (because symbols; simply don't change). The same metadata may have different symbols to denote its; value in different moments of time, but at most one of them represents the; actual metadata value. So we'd be escaping more stuff than necessary. If only we had ""ghost fields""; (https://lists.llvm.org/pipermail/cfe-dev/2016-May/049000.html), it would have; been much easier, because the ghost field would only contain the actual; metadata, and the Store would always know about it. This example adds to my; belief that ghost fields are exactly what we need for most C++ checkers. **Devin:**. In this case, I would be fine with some sort of; AbstractStorageMemoryRegion that meant ""here is a memory region and somewhere; reachable from here exists another region of type T"". Or even multiple regions; with different identifiers. This wouldn't specify how the memory is reachable,; but it would allow for transfer functions to get at those regions and it would; al",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst:14757,Usability,simpl,simple,14757,"naturally, and the store automagically sees reachable symbols, live; symbols, escapes, invalidations, whatever. > In my view this differs from ghost variables in that (1) this storage does; > actually exist (it is just a library implementation detail where that storage; > lives) and (2) it is perfectly valid for a pointer into that storage to be; > returned and for another part of the program to read or write from that; > storage. (Well, in this case just read since it is allowed to be read-only; > memory). > What I'm not OK with is modeling abstract analysis state (for example, the; > count of a NSMutableArray or the typestate of a file handle) as a value stored; > in some ginned up region in the store.This takes an easy problem that the; > analyzer does well at (modeling typestate) and turns it into a hard one that; > the analyzer is bad at (reasoning about the contents of the heap). Yeah, i tend to agree on that. For simple typestates, this is probably an; overkill, so let's definitely put aside the idea of ""ghost symbolic regions""; that i had earlier. But, to summarize a bit, in our current case, however, the typestate we're; looking for is the contents of the heap. And when we try to model such; typestates (complex in this specific manner, i.e. heap-like) in any checker, we; have a choice between re-doing this modeling in every such checker (which is; something analyzer is indeed good at, but at a price of making checkers heavy); or instead relying on the Store to do exactly what it's designed to do. > I think the key criterion here is: ""is the region accessible from outside; > the library"". That is, does the library expose the region as a pointer that; > can be read to or written from in the client program? If so, then it makes; > sense for this to be in the store: we are modeling reachable storage as; > storage. But if we're just modeling arbitrary analysis facts that need to be; > invalidated when a pointer escapes then we shouldn't try to gin up storage; > ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/InitializerLists.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:239,Availability,avail,available,239,"Inlining; ========. There are several options that control which calls the analyzer will consider for; inlining. The major one is ``-analyzer-config ipa``:. * ``analyzer-config ipa=none`` - All inlining is disabled. This is the only mode; available in LLVM 3.1 and earlier and in Xcode 4.3 and earlier. * ``analyzer-config ipa=basic-inlining`` - Turns on inlining for C functions, C++; static member functions, and blocks -- essentially, the calls that behave; like simple C function calls. This is essentially the mode used in; Xcode 4.4. * ``analyzer-config ipa=inlining`` - Turns on inlining when we can confidently find; the function/method body corresponding to the call. (C functions, static; functions, devirtualized C++ methods, Objective-C class methods, Objective-C; instance methods when ExprEngine is confident about the dynamic type of the; instance). * ``analyzer-config ipa=dynamic`` - Inline instance methods for which the type is; determined at runtime and we are not 100% sure that our type info is; correct. For virtual calls, inline the most plausible definition. * ``analyzer-config ipa=dynamic-bifurcate`` - Same as -analyzer-config ipa=dynamic,; but the path is split. We inline on one branch and do not inline on the; other. This mode does not drop the coverage in cases when the parent class; has code that is only exercised when some of its methods are overridden. Currently, ``-analyzer-config ipa=dynamic-bifurcate`` is the default mode. While ``-analyzer-config ipa`` determines in general how aggressively the analyzer; will try to inline functions, several additional options control which types of; functions can inlined, in an all-or-nothing way. These options use the; analyzer's configuration table, so they are all specified as follows:. ``-analyzer-config OPTION=VALUE``. c++-inlining; ------------. This option controls which C++ member functions may be inlined. ``-analyzer-config c++-inlining=[none | methods | constructors | destructors]``. Each of these modes",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:3644,Availability,toler,tolerance,3644,"ardless of the setting of the c++-inlining mode. c++-template-inlining; ^^^^^^^^^^^^^^^^^^^^^. This option controls whether C++ templated functions may be inlined. ``-analyzer-config c++-template-inlining=[true | false]``. Currently, template functions are considered for inlining by default. The motivation behind this option is that very generic code can be a source; of false positives, either by considering paths that the caller considers; impossible (by some unstated precondition), or by inlining some but not all; of a deep implementation of a function. c++-stdlib-inlining; ^^^^^^^^^^^^^^^^^^^. This option controls whether functions from the C++ standard library, including; methods of the container classes in the Standard Template Library, should be; considered for inlining. ``-analyzer-config c++-stdlib-inlining=[true | false]``. Currently, C++ standard library functions are considered for inlining by; default. The standard library functions and the STL in particular are used ubiquitously; enough that our tolerance for false positives is even lower here. A false; positive due to poor modeling of the STL leads to a poor user experience, since; most users would not be comfortable adding assertions to system headers in order; to silence analyzer warnings. c++-container-inlining; ^^^^^^^^^^^^^^^^^^^^^^. This option controls whether constructors and destructors of ""container"" types; should be considered for inlining. ``-analyzer-config c++-container-inlining=[true | false]``. Currently, these constructors and destructors are NOT considered for inlining; by default. The current implementation of this setting checks whether a type has a member; named 'iterator' or a member named 'begin'; these names are idiomatic in C++,; with the latter specified in the C++11 standard. The analyzer currently does a; fairly poor job of modeling certain data structure invariants of container-like; objects. For example, these three expressions should be equivalent:. .. code-block:: cpp. s",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:6514,Availability,recover,recover,6514,"ting an inlined function is a bit more work, fortunately broken up into; reasonable steps:. 1. The CoreEngine realizes we're at the end of an inlined call and generates a; CallExitBegin node. 2. ExprEngine takes over (in processCallExit) and finds the return value of the; function, if it has one. This is bound to the expression that triggered the; call. (In the case of calls without origin expressions, such as destructors,; this step is skipped.). 3. Dead symbols and bindings are cleaned out from the state, including any local; bindings. 4. A CallExitEnd node is generated, which marks the transition back to the; caller's LocationContext. 5. Custom post-call checks are processed and the final nodes are pushed back; onto the work list, so that evaluation of the caller can continue. Retry Without Inlining; ^^^^^^^^^^^^^^^^^^^^^^. In some cases, we would like to retry analysis without inlining a particular; call. Currently, we use this technique to recover coverage in case we stop; analyzing a path due to exceeding the maximum block count inside an inlined; function. When this situation is detected, we walk up the path to find the first node; before inlining was started and enqueue it on the WorkList with a special; ReplayWithoutInlining bit added to it (ExprEngine::replayWithoutInlining). The; path is then re-analyzed from that point without inlining that particular call. Deciding When to Inline; ^^^^^^^^^^^^^^^^^^^^^^^. In general, the analyzer attempts to inline as much as possible, since it; provides a better summary of what actually happens in the program. There are; some cases, however, where the analyzer chooses not to inline:. - If there is no definition available for the called function or method. In; this case, there is no opportunity to inline. - If the CFG cannot be constructed for a called function, or the liveness; cannot be computed. These are prerequisites for analyzing a function body,; with or without inlining. - If the LocationContext chain for a given",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:7242,Availability,avail,available,7242," final nodes are pushed back; onto the work list, so that evaluation of the caller can continue. Retry Without Inlining; ^^^^^^^^^^^^^^^^^^^^^^. In some cases, we would like to retry analysis without inlining a particular; call. Currently, we use this technique to recover coverage in case we stop; analyzing a path due to exceeding the maximum block count inside an inlined; function. When this situation is detected, we walk up the path to find the first node; before inlining was started and enqueue it on the WorkList with a special; ReplayWithoutInlining bit added to it (ExprEngine::replayWithoutInlining). The; path is then re-analyzed from that point without inlining that particular call. Deciding When to Inline; ^^^^^^^^^^^^^^^^^^^^^^^. In general, the analyzer attempts to inline as much as possible, since it; provides a better summary of what actually happens in the program. There are; some cases, however, where the analyzer chooses not to inline:. - If there is no definition available for the called function or method. In; this case, there is no opportunity to inline. - If the CFG cannot be constructed for a called function, or the liveness; cannot be computed. These are prerequisites for analyzing a function body,; with or without inlining. - If the LocationContext chain for a given ExplodedNode reaches a maximum cutoff; depth. This prevents unbounded analysis due to infinite recursion, but also; serves as a useful cutoff for performance reasons. - If the function is variadic. This is not a hard limitation, but an engineering; limitation. Tracked by: <rdar://problem/12147064> Support inlining of variadic functions. - In C++, constructors are not inlined unless the destructor call will be; processed by the ExprEngine. Thus, if the CFG was built without nodes for; implicit destructors, or if the destructors for the given object are not; represented in the CFG, the constructor will not be inlined. (As an exception,; constructors for objects with trivial constructors",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:12248,Availability,avail,available,12248,"ualization, the resulting; RuntimeDefinition contains a Decl corresponding to the definition of the called; function, and RuntimeDefinition::mayHaveOtherDefinitions will return FALSE. In the case of dynamic dispatch where our information is not perfect, CallEvent; can make a guess, but RuntimeDefinition::mayHaveOtherDefinitions will return; TRUE. The RuntimeDefinition object will then also include a MemRegion; corresponding to the object being called (i.e., the ""receiver"" in Objective-C; parlance), which ExprEngine uses to decide whether or not the call should be; inlined. Inlining Dynamic Calls; ^^^^^^^^^^^^^^^^^^^^^^. The -analyzer-config ipa option has five different modes: none, basic-inlining,; inlining, dynamic, and dynamic-bifurcate. Under -analyzer-config ipa=dynamic,; all dynamic calls are inlined, whether we are certain or not that this will; actually be the definition used at runtime. Under -analyzer-config ipa=inlining,; only ""near-perfect"" devirtualized calls are inlined*, and other dynamic calls; are evaluated conservatively (as if no definition were available). * Currently, no Objective-C messages are not inlined under; -analyzer-config ipa=inlining, even if we are reasonably confident of the type; of the receiver. We plan to enable this once we have tested our heuristics; more thoroughly. The last option, -analyzer-config ipa=dynamic-bifurcate, behaves similarly to; ""dynamic"", but performs a conservative invalidation in the general virtual case; in *addition* to inlining. The details of this are discussed below. As stated above, -analyzer-config ipa=basic-inlining does not inline any C++; member functions or Objective-C method calls, even if they are non-virtual or; can be safely devirtualized. Bifurcation; ^^^^^^^^^^^. ExprEngine::BifurcateCall implements the ``-analyzer-config ipa=dynamic-bifurcate``; mode. When a call is made on an object with imprecise dynamic type information; (RuntimeDefinition::mayHaveOtherDefinitions() evaluates to TRUE), Exp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:14126,Availability,avail,available,14126,"cise dynamic type information; (RuntimeDefinition::mayHaveOtherDefinitions() evaluates to TRUE), ExprEngine; bifurcates the path and marks the object's region (retrieved from the; RuntimeDefinition object) with a path-sensitive ""mode"" in the ProgramState. Currently, there are 2 modes:. * ``DynamicDispatchModeInlined`` - Models the case where the dynamic type information; of the receiver (MemoryRegion) is assumed to be perfectly constrained so; that a given definition of a method is expected to be the code actually; called. When this mode is set, ExprEngine uses the Decl from; RuntimeDefinition to inline any dynamically dispatched call sent to this; receiver because the function definition is considered to be fully resolved. * ``DynamicDispatchModeConservative`` - Models the case where the dynamic type; information is assumed to be incorrect, for example, implies that the method; definition is overridden in a subclass. In such cases, ExprEngine does not; inline the methods sent to the receiver (MemoryRegion), even if a candidate; definition is available. This mode is conservative about simulating the; effects of a call. Going forward along the symbolic execution path, ExprEngine consults the mode; of the receiver's MemRegion to make decisions on whether the calls should be; inlined or not, which ensures that there is at most one split per region. At a high level, ""bifurcation mode"" allows for increased semantic coverage in; cases where the parent method contains code which is only executed when the; class is subclassed. The disadvantages of this mode are a (considerable?); performance hit and the possibility of false positives on the path where the; conservative mode is used. Objective-C Message Heuristics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ExprEngine relies on a set of heuristics to partition the set of Objective-C; method calls into those that require bifurcation and those that do not. Below; are the cases when the DynamicTypeInfo of the object is considered precise;",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:1714,Deployability,configurat,configuration,1714,"+ methods, Objective-C class methods, Objective-C; instance methods when ExprEngine is confident about the dynamic type of the; instance). * ``analyzer-config ipa=dynamic`` - Inline instance methods for which the type is; determined at runtime and we are not 100% sure that our type info is; correct. For virtual calls, inline the most plausible definition. * ``analyzer-config ipa=dynamic-bifurcate`` - Same as -analyzer-config ipa=dynamic,; but the path is split. We inline on one branch and do not inline on the; other. This mode does not drop the coverage in cases when the parent class; has code that is only exercised when some of its methods are overridden. Currently, ``-analyzer-config ipa=dynamic-bifurcate`` is the default mode. While ``-analyzer-config ipa`` determines in general how aggressively the analyzer; will try to inline functions, several additional options control which types of; functions can inlined, in an all-or-nothing way. These options use the; analyzer's configuration table, so they are all specified as follows:. ``-analyzer-config OPTION=VALUE``. c++-inlining; ------------. This option controls which C++ member functions may be inlined. ``-analyzer-config c++-inlining=[none | methods | constructors | destructors]``. Each of these modes implies that all the previous member function kinds will be; inlined as well; it doesn't make sense to inline destructors without inlining; constructors, for example. The default c++-inlining mode is 'destructors', meaning that all member; functions with visible definitions will be considered for inlining. In some; cases the analyzer may still choose not to inline the function. Note that under 'constructors', constructors for types with non-trivial; destructors will not be inlined. Additionally, no C++ member functions will be; inlined under -analyzer-config ipa=none or -analyzer-config ipa=basic-inlining,; regardless of the setting of the c++-inlining mode. c++-template-inlining; ^^^^^^^^^^^^^^^^^^^^^. This option",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:9079,Integrability,message,message,9079,"ut nodes for; implicit destructors, or if the destructors for the given object are not; represented in the CFG, the constructor will not be inlined. (As an exception,; constructors for objects with trivial constructors can still be inlined.); See ""C++ Caveats"" below. - In C++, ExprEngine does not inline custom implementations of operator 'new'; or operator 'delete', nor does it inline the constructors and destructors; associated with these. See ""C++ Caveats"" below. - Calls resulting in ""dynamic dispatch"" are specially handled. See more below. - The FunctionSummaries map stores additional information about declarations,; some of which is collected at runtime based on previous analyses.; We do not inline functions which were not profitable to inline in a different; context (for example, if the maximum block count was exceeded; see; ""Retry Without Inlining""). Dynamic Calls and Devirtualization; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ""Dynamic"" calls are those that are resolved at runtime, such as C++ virtual; method calls and Objective-C message sends. Due to the path-sensitive nature of; the analysis, the analyzer may be able to reason about the dynamic type of the; object whose method is being called and thus ""devirtualize"" the call. This path-sensitive devirtualization occurs when the analyzer can determine what; method would actually be called at runtime. This is possible when the type; information is constrained enough for a simulated C++/Objective-C object that; the analyzer can make such a decision. DynamicTypeInfo; ^^^^^^^^^^^^^^^. As the analyzer analyzes a path, it may accrue information to refine the; knowledge about the type of an object. This can then be used to make better; decisions about the target method of a call. Such type information is tracked as DynamicTypeInfo. This is path-sensitive; data that is stored in ProgramState, which defines a mapping from MemRegions to; an (optional) DynamicTypeInfo. If no DynamicTypeInfo has been explicitly set for a MemRe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:12288,Integrability,message,messages,12288,"return FALSE. In the case of dynamic dispatch where our information is not perfect, CallEvent; can make a guess, but RuntimeDefinition::mayHaveOtherDefinitions will return; TRUE. The RuntimeDefinition object will then also include a MemRegion; corresponding to the object being called (i.e., the ""receiver"" in Objective-C; parlance), which ExprEngine uses to decide whether or not the call should be; inlined. Inlining Dynamic Calls; ^^^^^^^^^^^^^^^^^^^^^^. The -analyzer-config ipa option has five different modes: none, basic-inlining,; inlining, dynamic, and dynamic-bifurcate. Under -analyzer-config ipa=dynamic,; all dynamic calls are inlined, whether we are certain or not that this will; actually be the definition used at runtime. Under -analyzer-config ipa=inlining,; only ""near-perfect"" devirtualized calls are inlined*, and other dynamic calls; are evaluated conservatively (as if no definition were available). * Currently, no Objective-C messages are not inlined under; -analyzer-config ipa=inlining, even if we are reasonably confident of the type; of the receiver. We plan to enable this once we have tested our heuristics; more thoroughly. The last option, -analyzer-config ipa=dynamic-bifurcate, behaves similarly to; ""dynamic"", but performs a conservative invalidation in the general virtual case; in *addition* to inlining. The details of this are discussed below. As stated above, -analyzer-config ipa=basic-inlining does not inline any C++; member functions or Objective-C method calls, even if they are non-virtual or; can be safely devirtualized. Bifurcation; ^^^^^^^^^^^. ExprEngine::BifurcateCall implements the ``-analyzer-config ipa=dynamic-bifurcate``; mode. When a call is made on an object with imprecise dynamic type information; (RuntimeDefinition::mayHaveOtherDefinitions() evaluates to TRUE), ExprEngine; bifurcates the path and marks the object's region (retrieved from the; RuntimeDefinition object) with a path-sensitive ""mode"" in the ProgramState. Currently, ther",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:15369,Integrability,interface,interface,15369,"ures that there is at most one split per region. At a high level, ""bifurcation mode"" allows for increased semantic coverage in; cases where the parent method contains code which is only executed when the; class is subclassed. The disadvantages of this mode are a (considerable?); performance hit and the possibility of false positives on the path where the; conservative mode is used. Objective-C Message Heuristics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ExprEngine relies on a set of heuristics to partition the set of Objective-C; method calls into those that require bifurcation and those that do not. Below; are the cases when the DynamicTypeInfo of the object is considered precise; (cannot be a subclass):. - If the object was created with +alloc or +new and initialized with an -init; method. - If the calls are property accesses using dot syntax. This is based on the; assumption that children rarely override properties, or do so in an; essentially compatible way. - If the class interface is declared inside the main source file. In this case; it is unlikely that it will be subclassed. - If the method is not declared outside of main source file, either by the; receiver's class or by any superclasses. C++ Caveats; ^^^^^^^^^^^. C++11 [class.cdtor]p4 describes how the vtable of an object is modified as it is; being constructed or destructed; that is, the type of the object depends on; which base constructors have been completed. This is tracked using; DynamicTypeInfo in the DynamicTypePropagation checker. There are several limitations in the current implementation:. * Temporaries are poorly modeled right now because we're not confident in the; placement of their destructors in the CFG. We currently won't inline their; constructors unless the destructor is trivial, and don't process their; destructors at all, not even to invalidate the region. * 'new' is poorly modeled due to some nasty CFG/design issues. This is tracked; in PR12014. 'delete' is not modeled at all. * Arrays of obje",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:15767,Integrability,depend,depends,15767,"path where the; conservative mode is used. Objective-C Message Heuristics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ExprEngine relies on a set of heuristics to partition the set of Objective-C; method calls into those that require bifurcation and those that do not. Below; are the cases when the DynamicTypeInfo of the object is considered precise; (cannot be a subclass):. - If the object was created with +alloc or +new and initialized with an -init; method. - If the calls are property accesses using dot syntax. This is based on the; assumption that children rarely override properties, or do so in an; essentially compatible way. - If the class interface is declared inside the main source file. In this case; it is unlikely that it will be subclassed. - If the method is not declared outside of main source file, either by the; receiver's class or by any superclasses. C++ Caveats; ^^^^^^^^^^^. C++11 [class.cdtor]p4 describes how the vtable of an object is modified as it is; being constructed or destructed; that is, the type of the object depends on; which base constructors have been completed. This is tracked using; DynamicTypeInfo in the DynamicTypePropagation checker. There are several limitations in the current implementation:. * Temporaries are poorly modeled right now because we're not confident in the; placement of their destructors in the CFG. We currently won't inline their; constructors unless the destructor is trivial, and don't process their; destructors at all, not even to invalidate the region. * 'new' is poorly modeled due to some nasty CFG/design issues. This is tracked; in PR12014. 'delete' is not modeled at all. * Arrays of objects are modeled very poorly right now. ExprEngine currently; only simulates the first constructor and first destructor. Because of this,; ExprEngine does not inline any constructors or destructors for arrays. CallEvent; ^^^^^^^^^. A CallEvent represents a specific call to a function, method, or other body of; code. It is path-sensitive, con",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:142,Modifiability,config,config,142,"Inlining; ========. There are several options that control which calls the analyzer will consider for; inlining. The major one is ``-analyzer-config ipa``:. * ``analyzer-config ipa=none`` - All inlining is disabled. This is the only mode; available in LLVM 3.1 and earlier and in Xcode 4.3 and earlier. * ``analyzer-config ipa=basic-inlining`` - Turns on inlining for C functions, C++; static member functions, and blocks -- essentially, the calls that behave; like simple C function calls. This is essentially the mode used in; Xcode 4.4. * ``analyzer-config ipa=inlining`` - Turns on inlining when we can confidently find; the function/method body corresponding to the call. (C functions, static; functions, devirtualized C++ methods, Objective-C class methods, Objective-C; instance methods when ExprEngine is confident about the dynamic type of the; instance). * ``analyzer-config ipa=dynamic`` - Inline instance methods for which the type is; determined at runtime and we are not 100% sure that our type info is; correct. For virtual calls, inline the most plausible definition. * ``analyzer-config ipa=dynamic-bifurcate`` - Same as -analyzer-config ipa=dynamic,; but the path is split. We inline on one branch and do not inline on the; other. This mode does not drop the coverage in cases when the parent class; has code that is only exercised when some of its methods are overridden. Currently, ``-analyzer-config ipa=dynamic-bifurcate`` is the default mode. While ``-analyzer-config ipa`` determines in general how aggressively the analyzer; will try to inline functions, several additional options control which types of; functions can inlined, in an all-or-nothing way. These options use the; analyzer's configuration table, so they are all specified as follows:. ``-analyzer-config OPTION=VALUE``. c++-inlining; ------------. This option controls which C++ member functions may be inlined. ``-analyzer-config c++-inlining=[none | methods | constructors | destructors]``. Each of these modes",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:170,Modifiability,config,config,170,"Inlining; ========. There are several options that control which calls the analyzer will consider for; inlining. The major one is ``-analyzer-config ipa``:. * ``analyzer-config ipa=none`` - All inlining is disabled. This is the only mode; available in LLVM 3.1 and earlier and in Xcode 4.3 and earlier. * ``analyzer-config ipa=basic-inlining`` - Turns on inlining for C functions, C++; static member functions, and blocks -- essentially, the calls that behave; like simple C function calls. This is essentially the mode used in; Xcode 4.4. * ``analyzer-config ipa=inlining`` - Turns on inlining when we can confidently find; the function/method body corresponding to the call. (C functions, static; functions, devirtualized C++ methods, Objective-C class methods, Objective-C; instance methods when ExprEngine is confident about the dynamic type of the; instance). * ``analyzer-config ipa=dynamic`` - Inline instance methods for which the type is; determined at runtime and we are not 100% sure that our type info is; correct. For virtual calls, inline the most plausible definition. * ``analyzer-config ipa=dynamic-bifurcate`` - Same as -analyzer-config ipa=dynamic,; but the path is split. We inline on one branch and do not inline on the; other. This mode does not drop the coverage in cases when the parent class; has code that is only exercised when some of its methods are overridden. Currently, ``-analyzer-config ipa=dynamic-bifurcate`` is the default mode. While ``-analyzer-config ipa`` determines in general how aggressively the analyzer; will try to inline functions, several additional options control which types of; functions can inlined, in an all-or-nothing way. These options use the; analyzer's configuration table, so they are all specified as follows:. ``-analyzer-config OPTION=VALUE``. c++-inlining; ------------. This option controls which C++ member functions may be inlined. ``-analyzer-config c++-inlining=[none | methods | constructors | destructors]``. Each of these modes",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:316,Modifiability,config,config,316,"Inlining; ========. There are several options that control which calls the analyzer will consider for; inlining. The major one is ``-analyzer-config ipa``:. * ``analyzer-config ipa=none`` - All inlining is disabled. This is the only mode; available in LLVM 3.1 and earlier and in Xcode 4.3 and earlier. * ``analyzer-config ipa=basic-inlining`` - Turns on inlining for C functions, C++; static member functions, and blocks -- essentially, the calls that behave; like simple C function calls. This is essentially the mode used in; Xcode 4.4. * ``analyzer-config ipa=inlining`` - Turns on inlining when we can confidently find; the function/method body corresponding to the call. (C functions, static; functions, devirtualized C++ methods, Objective-C class methods, Objective-C; instance methods when ExprEngine is confident about the dynamic type of the; instance). * ``analyzer-config ipa=dynamic`` - Inline instance methods for which the type is; determined at runtime and we are not 100% sure that our type info is; correct. For virtual calls, inline the most plausible definition. * ``analyzer-config ipa=dynamic-bifurcate`` - Same as -analyzer-config ipa=dynamic,; but the path is split. We inline on one branch and do not inline on the; other. This mode does not drop the coverage in cases when the parent class; has code that is only exercised when some of its methods are overridden. Currently, ``-analyzer-config ipa=dynamic-bifurcate`` is the default mode. While ``-analyzer-config ipa`` determines in general how aggressively the analyzer; will try to inline functions, several additional options control which types of; functions can inlined, in an all-or-nothing way. These options use the; analyzer's configuration table, so they are all specified as follows:. ``-analyzer-config OPTION=VALUE``. c++-inlining; ------------. This option controls which C++ member functions may be inlined. ``-analyzer-config c++-inlining=[none | methods | constructors | destructors]``. Each of these modes",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:553,Modifiability,config,config,553,"Inlining; ========. There are several options that control which calls the analyzer will consider for; inlining. The major one is ``-analyzer-config ipa``:. * ``analyzer-config ipa=none`` - All inlining is disabled. This is the only mode; available in LLVM 3.1 and earlier and in Xcode 4.3 and earlier. * ``analyzer-config ipa=basic-inlining`` - Turns on inlining for C functions, C++; static member functions, and blocks -- essentially, the calls that behave; like simple C function calls. This is essentially the mode used in; Xcode 4.4. * ``analyzer-config ipa=inlining`` - Turns on inlining when we can confidently find; the function/method body corresponding to the call. (C functions, static; functions, devirtualized C++ methods, Objective-C class methods, Objective-C; instance methods when ExprEngine is confident about the dynamic type of the; instance). * ``analyzer-config ipa=dynamic`` - Inline instance methods for which the type is; determined at runtime and we are not 100% sure that our type info is; correct. For virtual calls, inline the most plausible definition. * ``analyzer-config ipa=dynamic-bifurcate`` - Same as -analyzer-config ipa=dynamic,; but the path is split. We inline on one branch and do not inline on the; other. This mode does not drop the coverage in cases when the parent class; has code that is only exercised when some of its methods are overridden. Currently, ``-analyzer-config ipa=dynamic-bifurcate`` is the default mode. While ``-analyzer-config ipa`` determines in general how aggressively the analyzer; will try to inline functions, several additional options control which types of; functions can inlined, in an all-or-nothing way. These options use the; analyzer's configuration table, so they are all specified as follows:. ``-analyzer-config OPTION=VALUE``. c++-inlining; ------------. This option controls which C++ member functions may be inlined. ``-analyzer-config c++-inlining=[none | methods | constructors | destructors]``. Each of these modes",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:878,Modifiability,config,config,878,"Inlining; ========. There are several options that control which calls the analyzer will consider for; inlining. The major one is ``-analyzer-config ipa``:. * ``analyzer-config ipa=none`` - All inlining is disabled. This is the only mode; available in LLVM 3.1 and earlier and in Xcode 4.3 and earlier. * ``analyzer-config ipa=basic-inlining`` - Turns on inlining for C functions, C++; static member functions, and blocks -- essentially, the calls that behave; like simple C function calls. This is essentially the mode used in; Xcode 4.4. * ``analyzer-config ipa=inlining`` - Turns on inlining when we can confidently find; the function/method body corresponding to the call. (C functions, static; functions, devirtualized C++ methods, Objective-C class methods, Objective-C; instance methods when ExprEngine is confident about the dynamic type of the; instance). * ``analyzer-config ipa=dynamic`` - Inline instance methods for which the type is; determined at runtime and we are not 100% sure that our type info is; correct. For virtual calls, inline the most plausible definition. * ``analyzer-config ipa=dynamic-bifurcate`` - Same as -analyzer-config ipa=dynamic,; but the path is split. We inline on one branch and do not inline on the; other. This mode does not drop the coverage in cases when the parent class; has code that is only exercised when some of its methods are overridden. Currently, ``-analyzer-config ipa=dynamic-bifurcate`` is the default mode. While ``-analyzer-config ipa`` determines in general how aggressively the analyzer; will try to inline functions, several additional options control which types of; functions can inlined, in an all-or-nothing way. These options use the; analyzer's configuration table, so they are all specified as follows:. ``-analyzer-config OPTION=VALUE``. c++-inlining; ------------. This option controls which C++ member functions may be inlined. ``-analyzer-config c++-inlining=[none | methods | constructors | destructors]``. Each of these modes",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:1097,Modifiability,config,config,1097,"yzer-config ipa``:. * ``analyzer-config ipa=none`` - All inlining is disabled. This is the only mode; available in LLVM 3.1 and earlier and in Xcode 4.3 and earlier. * ``analyzer-config ipa=basic-inlining`` - Turns on inlining for C functions, C++; static member functions, and blocks -- essentially, the calls that behave; like simple C function calls. This is essentially the mode used in; Xcode 4.4. * ``analyzer-config ipa=inlining`` - Turns on inlining when we can confidently find; the function/method body corresponding to the call. (C functions, static; functions, devirtualized C++ methods, Objective-C class methods, Objective-C; instance methods when ExprEngine is confident about the dynamic type of the; instance). * ``analyzer-config ipa=dynamic`` - Inline instance methods for which the type is; determined at runtime and we are not 100% sure that our type info is; correct. For virtual calls, inline the most plausible definition. * ``analyzer-config ipa=dynamic-bifurcate`` - Same as -analyzer-config ipa=dynamic,; but the path is split. We inline on one branch and do not inline on the; other. This mode does not drop the coverage in cases when the parent class; has code that is only exercised when some of its methods are overridden. Currently, ``-analyzer-config ipa=dynamic-bifurcate`` is the default mode. While ``-analyzer-config ipa`` determines in general how aggressively the analyzer; will try to inline functions, several additional options control which types of; functions can inlined, in an all-or-nothing way. These options use the; analyzer's configuration table, so they are all specified as follows:. ``-analyzer-config OPTION=VALUE``. c++-inlining; ------------. This option controls which C++ member functions may be inlined. ``-analyzer-config c++-inlining=[none | methods | constructors | destructors]``. Each of these modes implies that all the previous member function kinds will be; inlined as well; it doesn't make sense to inline destructors without inlin",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:1148,Modifiability,config,config,1148,"yzer-config ipa``:. * ``analyzer-config ipa=none`` - All inlining is disabled. This is the only mode; available in LLVM 3.1 and earlier and in Xcode 4.3 and earlier. * ``analyzer-config ipa=basic-inlining`` - Turns on inlining for C functions, C++; static member functions, and blocks -- essentially, the calls that behave; like simple C function calls. This is essentially the mode used in; Xcode 4.4. * ``analyzer-config ipa=inlining`` - Turns on inlining when we can confidently find; the function/method body corresponding to the call. (C functions, static; functions, devirtualized C++ methods, Objective-C class methods, Objective-C; instance methods when ExprEngine is confident about the dynamic type of the; instance). * ``analyzer-config ipa=dynamic`` - Inline instance methods for which the type is; determined at runtime and we are not 100% sure that our type info is; correct. For virtual calls, inline the most plausible definition. * ``analyzer-config ipa=dynamic-bifurcate`` - Same as -analyzer-config ipa=dynamic,; but the path is split. We inline on one branch and do not inline on the; other. This mode does not drop the coverage in cases when the parent class; has code that is only exercised when some of its methods are overridden. Currently, ``-analyzer-config ipa=dynamic-bifurcate`` is the default mode. While ``-analyzer-config ipa`` determines in general how aggressively the analyzer; will try to inline functions, several additional options control which types of; functions can inlined, in an all-or-nothing way. These options use the; analyzer's configuration table, so they are all specified as follows:. ``-analyzer-config OPTION=VALUE``. c++-inlining; ------------. This option controls which C++ member functions may be inlined. ``-analyzer-config c++-inlining=[none | methods | constructors | destructors]``. Each of these modes implies that all the previous member function kinds will be; inlined as well; it doesn't make sense to inline destructors without inlin",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:1414,Modifiability,config,config,1414,"sentially, the calls that behave; like simple C function calls. This is essentially the mode used in; Xcode 4.4. * ``analyzer-config ipa=inlining`` - Turns on inlining when we can confidently find; the function/method body corresponding to the call. (C functions, static; functions, devirtualized C++ methods, Objective-C class methods, Objective-C; instance methods when ExprEngine is confident about the dynamic type of the; instance). * ``analyzer-config ipa=dynamic`` - Inline instance methods for which the type is; determined at runtime and we are not 100% sure that our type info is; correct. For virtual calls, inline the most plausible definition. * ``analyzer-config ipa=dynamic-bifurcate`` - Same as -analyzer-config ipa=dynamic,; but the path is split. We inline on one branch and do not inline on the; other. This mode does not drop the coverage in cases when the parent class; has code that is only exercised when some of its methods are overridden. Currently, ``-analyzer-config ipa=dynamic-bifurcate`` is the default mode. While ``-analyzer-config ipa`` determines in general how aggressively the analyzer; will try to inline functions, several additional options control which types of; functions can inlined, in an all-or-nothing way. These options use the; analyzer's configuration table, so they are all specified as follows:. ``-analyzer-config OPTION=VALUE``. c++-inlining; ------------. This option controls which C++ member functions may be inlined. ``-analyzer-config c++-inlining=[none | methods | constructors | destructors]``. Each of these modes implies that all the previous member function kinds will be; inlined as well; it doesn't make sense to inline destructors without inlining; constructors, for example. The default c++-inlining mode is 'destructors', meaning that all member; functions with visible definitions will be considered for inlining. In some; cases the analyzer may still choose not to inline the function. Note that under 'constructors', constructors ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:1484,Modifiability,config,config,1484,"`` - Turns on inlining when we can confidently find; the function/method body corresponding to the call. (C functions, static; functions, devirtualized C++ methods, Objective-C class methods, Objective-C; instance methods when ExprEngine is confident about the dynamic type of the; instance). * ``analyzer-config ipa=dynamic`` - Inline instance methods for which the type is; determined at runtime and we are not 100% sure that our type info is; correct. For virtual calls, inline the most plausible definition. * ``analyzer-config ipa=dynamic-bifurcate`` - Same as -analyzer-config ipa=dynamic,; but the path is split. We inline on one branch and do not inline on the; other. This mode does not drop the coverage in cases when the parent class; has code that is only exercised when some of its methods are overridden. Currently, ``-analyzer-config ipa=dynamic-bifurcate`` is the default mode. While ``-analyzer-config ipa`` determines in general how aggressively the analyzer; will try to inline functions, several additional options control which types of; functions can inlined, in an all-or-nothing way. These options use the; analyzer's configuration table, so they are all specified as follows:. ``-analyzer-config OPTION=VALUE``. c++-inlining; ------------. This option controls which C++ member functions may be inlined. ``-analyzer-config c++-inlining=[none | methods | constructors | destructors]``. Each of these modes implies that all the previous member function kinds will be; inlined as well; it doesn't make sense to inline destructors without inlining; constructors, for example. The default c++-inlining mode is 'destructors', meaning that all member; functions with visible definitions will be considered for inlining. In some; cases the analyzer may still choose not to inline the function. Note that under 'constructors', constructors for types with non-trivial; destructors will not be inlined. Additionally, no C++ member functions will be; inlined under -analyzer-config ipa=n",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:1714,Modifiability,config,configuration,1714,"+ methods, Objective-C class methods, Objective-C; instance methods when ExprEngine is confident about the dynamic type of the; instance). * ``analyzer-config ipa=dynamic`` - Inline instance methods for which the type is; determined at runtime and we are not 100% sure that our type info is; correct. For virtual calls, inline the most plausible definition. * ``analyzer-config ipa=dynamic-bifurcate`` - Same as -analyzer-config ipa=dynamic,; but the path is split. We inline on one branch and do not inline on the; other. This mode does not drop the coverage in cases when the parent class; has code that is only exercised when some of its methods are overridden. Currently, ``-analyzer-config ipa=dynamic-bifurcate`` is the default mode. While ``-analyzer-config ipa`` determines in general how aggressively the analyzer; will try to inline functions, several additional options control which types of; functions can inlined, in an all-or-nothing way. These options use the; analyzer's configuration table, so they are all specified as follows:. ``-analyzer-config OPTION=VALUE``. c++-inlining; ------------. This option controls which C++ member functions may be inlined. ``-analyzer-config c++-inlining=[none | methods | constructors | destructors]``. Each of these modes implies that all the previous member function kinds will be; inlined as well; it doesn't make sense to inline destructors without inlining; constructors, for example. The default c++-inlining mode is 'destructors', meaning that all member; functions with visible definitions will be considered for inlining. In some; cases the analyzer may still choose not to inline the function. Note that under 'constructors', constructors for types with non-trivial; destructors will not be inlined. Additionally, no C++ member functions will be; inlined under -analyzer-config ipa=none or -analyzer-config ipa=basic-inlining,; regardless of the setting of the c++-inlining mode. c++-template-inlining; ^^^^^^^^^^^^^^^^^^^^^. This option",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:1786,Modifiability,config,config,1786,"ods when ExprEngine is confident about the dynamic type of the; instance). * ``analyzer-config ipa=dynamic`` - Inline instance methods for which the type is; determined at runtime and we are not 100% sure that our type info is; correct. For virtual calls, inline the most plausible definition. * ``analyzer-config ipa=dynamic-bifurcate`` - Same as -analyzer-config ipa=dynamic,; but the path is split. We inline on one branch and do not inline on the; other. This mode does not drop the coverage in cases when the parent class; has code that is only exercised when some of its methods are overridden. Currently, ``-analyzer-config ipa=dynamic-bifurcate`` is the default mode. While ``-analyzer-config ipa`` determines in general how aggressively the analyzer; will try to inline functions, several additional options control which types of; functions can inlined, in an all-or-nothing way. These options use the; analyzer's configuration table, so they are all specified as follows:. ``-analyzer-config OPTION=VALUE``. c++-inlining; ------------. This option controls which C++ member functions may be inlined. ``-analyzer-config c++-inlining=[none | methods | constructors | destructors]``. Each of these modes implies that all the previous member function kinds will be; inlined as well; it doesn't make sense to inline destructors without inlining; constructors, for example. The default c++-inlining mode is 'destructors', meaning that all member; functions with visible definitions will be considered for inlining. In some; cases the analyzer may still choose not to inline the function. Note that under 'constructors', constructors for types with non-trivial; destructors will not be inlined. Additionally, no C++ member functions will be; inlined under -analyzer-config ipa=none or -analyzer-config ipa=basic-inlining,; regardless of the setting of the c++-inlining mode. c++-template-inlining; ^^^^^^^^^^^^^^^^^^^^^. This option controls whether C++ templated functions may be inlined. ``-anal",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:1913,Modifiability,config,config,1913,"ype is; determined at runtime and we are not 100% sure that our type info is; correct. For virtual calls, inline the most plausible definition. * ``analyzer-config ipa=dynamic-bifurcate`` - Same as -analyzer-config ipa=dynamic,; but the path is split. We inline on one branch and do not inline on the; other. This mode does not drop the coverage in cases when the parent class; has code that is only exercised when some of its methods are overridden. Currently, ``-analyzer-config ipa=dynamic-bifurcate`` is the default mode. While ``-analyzer-config ipa`` determines in general how aggressively the analyzer; will try to inline functions, several additional options control which types of; functions can inlined, in an all-or-nothing way. These options use the; analyzer's configuration table, so they are all specified as follows:. ``-analyzer-config OPTION=VALUE``. c++-inlining; ------------. This option controls which C++ member functions may be inlined. ``-analyzer-config c++-inlining=[none | methods | constructors | destructors]``. Each of these modes implies that all the previous member function kinds will be; inlined as well; it doesn't make sense to inline destructors without inlining; constructors, for example. The default c++-inlining mode is 'destructors', meaning that all member; functions with visible definitions will be considered for inlining. In some; cases the analyzer may still choose not to inline the function. Note that under 'constructors', constructors for types with non-trivial; destructors will not be inlined. Additionally, no C++ member functions will be; inlined under -analyzer-config ipa=none or -analyzer-config ipa=basic-inlining,; regardless of the setting of the c++-inlining mode. c++-template-inlining; ^^^^^^^^^^^^^^^^^^^^^. This option controls whether C++ templated functions may be inlined. ``-analyzer-config c++-template-inlining=[true | false]``. Currently, template functions are considered for inlining by default. The motivation behind this o",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:2560,Modifiability,config,config,2560,", several additional options control which types of; functions can inlined, in an all-or-nothing way. These options use the; analyzer's configuration table, so they are all specified as follows:. ``-analyzer-config OPTION=VALUE``. c++-inlining; ------------. This option controls which C++ member functions may be inlined. ``-analyzer-config c++-inlining=[none | methods | constructors | destructors]``. Each of these modes implies that all the previous member function kinds will be; inlined as well; it doesn't make sense to inline destructors without inlining; constructors, for example. The default c++-inlining mode is 'destructors', meaning that all member; functions with visible definitions will be considered for inlining. In some; cases the analyzer may still choose not to inline the function. Note that under 'constructors', constructors for types with non-trivial; destructors will not be inlined. Additionally, no C++ member functions will be; inlined under -analyzer-config ipa=none or -analyzer-config ipa=basic-inlining,; regardless of the setting of the c++-inlining mode. c++-template-inlining; ^^^^^^^^^^^^^^^^^^^^^. This option controls whether C++ templated functions may be inlined. ``-analyzer-config c++-template-inlining=[true | false]``. Currently, template functions are considered for inlining by default. The motivation behind this option is that very generic code can be a source; of false positives, either by considering paths that the caller considers; impossible (by some unstated precondition), or by inlining some but not all; of a deep implementation of a function. c++-stdlib-inlining; ^^^^^^^^^^^^^^^^^^^. This option controls whether functions from the C++ standard library, including; methods of the container classes in the Standard Template Library, should be; considered for inlining. ``-analyzer-config c++-stdlib-inlining=[true | false]``. Currently, C++ standard library functions are considered for inlining by; default. The standard library functions",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:2589,Modifiability,config,config,2589,", several additional options control which types of; functions can inlined, in an all-or-nothing way. These options use the; analyzer's configuration table, so they are all specified as follows:. ``-analyzer-config OPTION=VALUE``. c++-inlining; ------------. This option controls which C++ member functions may be inlined. ``-analyzer-config c++-inlining=[none | methods | constructors | destructors]``. Each of these modes implies that all the previous member function kinds will be; inlined as well; it doesn't make sense to inline destructors without inlining; constructors, for example. The default c++-inlining mode is 'destructors', meaning that all member; functions with visible definitions will be considered for inlining. In some; cases the analyzer may still choose not to inline the function. Note that under 'constructors', constructors for types with non-trivial; destructors will not be inlined. Additionally, no C++ member functions will be; inlined under -analyzer-config ipa=none or -analyzer-config ipa=basic-inlining,; regardless of the setting of the c++-inlining mode. c++-template-inlining; ^^^^^^^^^^^^^^^^^^^^^. This option controls whether C++ templated functions may be inlined. ``-analyzer-config c++-template-inlining=[true | false]``. Currently, template functions are considered for inlining by default. The motivation behind this option is that very generic code can be a source; of false positives, either by considering paths that the caller considers; impossible (by some unstated precondition), or by inlining some but not all; of a deep implementation of a function. c++-stdlib-inlining; ^^^^^^^^^^^^^^^^^^^. This option controls whether functions from the C++ standard library, including; methods of the container classes in the Standard Template Library, should be; considered for inlining. ``-analyzer-config c++-stdlib-inlining=[true | false]``. Currently, C++ standard library functions are considered for inlining by; default. The standard library functions",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:2796,Modifiability,config,config,2796,"-inlining; ------------. This option controls which C++ member functions may be inlined. ``-analyzer-config c++-inlining=[none | methods | constructors | destructors]``. Each of these modes implies that all the previous member function kinds will be; inlined as well; it doesn't make sense to inline destructors without inlining; constructors, for example. The default c++-inlining mode is 'destructors', meaning that all member; functions with visible definitions will be considered for inlining. In some; cases the analyzer may still choose not to inline the function. Note that under 'constructors', constructors for types with non-trivial; destructors will not be inlined. Additionally, no C++ member functions will be; inlined under -analyzer-config ipa=none or -analyzer-config ipa=basic-inlining,; regardless of the setting of the c++-inlining mode. c++-template-inlining; ^^^^^^^^^^^^^^^^^^^^^. This option controls whether C++ templated functions may be inlined. ``-analyzer-config c++-template-inlining=[true | false]``. Currently, template functions are considered for inlining by default. The motivation behind this option is that very generic code can be a source; of false positives, either by considering paths that the caller considers; impossible (by some unstated precondition), or by inlining some but not all; of a deep implementation of a function. c++-stdlib-inlining; ^^^^^^^^^^^^^^^^^^^. This option controls whether functions from the C++ standard library, including; methods of the container classes in the Standard Template Library, should be; considered for inlining. ``-analyzer-config c++-stdlib-inlining=[true | false]``. Currently, C++ standard library functions are considered for inlining by; default. The standard library functions and the STL in particular are used ubiquitously; enough that our tolerance for false positives is even lower here. A false; positive due to poor modeling of the STL leads to a poor user experience, since; most users would not be comfo",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:3420,Modifiability,config,config,3420,"es with non-trivial; destructors will not be inlined. Additionally, no C++ member functions will be; inlined under -analyzer-config ipa=none or -analyzer-config ipa=basic-inlining,; regardless of the setting of the c++-inlining mode. c++-template-inlining; ^^^^^^^^^^^^^^^^^^^^^. This option controls whether C++ templated functions may be inlined. ``-analyzer-config c++-template-inlining=[true | false]``. Currently, template functions are considered for inlining by default. The motivation behind this option is that very generic code can be a source; of false positives, either by considering paths that the caller considers; impossible (by some unstated precondition), or by inlining some but not all; of a deep implementation of a function. c++-stdlib-inlining; ^^^^^^^^^^^^^^^^^^^. This option controls whether functions from the C++ standard library, including; methods of the container classes in the Standard Template Library, should be; considered for inlining. ``-analyzer-config c++-stdlib-inlining=[true | false]``. Currently, C++ standard library functions are considered for inlining by; default. The standard library functions and the STL in particular are used ubiquitously; enough that our tolerance for false positives is even lower here. A false; positive due to poor modeling of the STL leads to a poor user experience, since; most users would not be comfortable adding assertions to system headers in order; to silence analyzer warnings. c++-container-inlining; ^^^^^^^^^^^^^^^^^^^^^^. This option controls whether constructors and destructors of ""container"" types; should be considered for inlining. ``-analyzer-config c++-container-inlining=[true | false]``. Currently, these constructors and destructors are NOT considered for inlining; by default. The current implementation of this setting checks whether a type has a member; named 'iterator' or a member named 'begin'; these names are idiomatic in C++,; with the latter specified in the C++11 standard. The analyzer curren",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:4071,Modifiability,config,config,4071,"tated precondition), or by inlining some but not all; of a deep implementation of a function. c++-stdlib-inlining; ^^^^^^^^^^^^^^^^^^^. This option controls whether functions from the C++ standard library, including; methods of the container classes in the Standard Template Library, should be; considered for inlining. ``-analyzer-config c++-stdlib-inlining=[true | false]``. Currently, C++ standard library functions are considered for inlining by; default. The standard library functions and the STL in particular are used ubiquitously; enough that our tolerance for false positives is even lower here. A false; positive due to poor modeling of the STL leads to a poor user experience, since; most users would not be comfortable adding assertions to system headers in order; to silence analyzer warnings. c++-container-inlining; ^^^^^^^^^^^^^^^^^^^^^^. This option controls whether constructors and destructors of ""container"" types; should be considered for inlining. ``-analyzer-config c++-container-inlining=[true | false]``. Currently, these constructors and destructors are NOT considered for inlining; by default. The current implementation of this setting checks whether a type has a member; named 'iterator' or a member named 'begin'; these names are idiomatic in C++,; with the latter specified in the C++11 standard. The analyzer currently does a; fairly poor job of modeling certain data structure invariants of container-like; objects. For example, these three expressions should be equivalent:. .. code-block:: cpp. std::distance(c.begin(), c.end()) == 0; c.begin() == c.end(); c.empty(). Many of these issues are avoided if containers always have unknown, symbolic; state, which is what happens when their constructors are treated as opaque.; In the future, we may decide specific containers are ""safe"" to model through; inlining, or choose to model them directly using checkers instead. Basics of Implementation; ------------------------. The low-level mechanism of inlining a functi",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:11809,Modifiability,config,config,11809,"allEvent's getRuntimeDefinition() method,; which returns a RuntimeDefinition object. When asked to provide a definition,; the CallEvents for dynamic calls will use the DynamicTypeInfo in their; ProgramState to attempt to devirtualize the call. In the case of no dynamic; dispatch, or perfectly constrained devirtualization, the resulting; RuntimeDefinition contains a Decl corresponding to the definition of the called; function, and RuntimeDefinition::mayHaveOtherDefinitions will return FALSE. In the case of dynamic dispatch where our information is not perfect, CallEvent; can make a guess, but RuntimeDefinition::mayHaveOtherDefinitions will return; TRUE. The RuntimeDefinition object will then also include a MemRegion; corresponding to the object being called (i.e., the ""receiver"" in Objective-C; parlance), which ExprEngine uses to decide whether or not the call should be; inlined. Inlining Dynamic Calls; ^^^^^^^^^^^^^^^^^^^^^^. The -analyzer-config ipa option has five different modes: none, basic-inlining,; inlining, dynamic, and dynamic-bifurcate. Under -analyzer-config ipa=dynamic,; all dynamic calls are inlined, whether we are certain or not that this will; actually be the definition used at runtime. Under -analyzer-config ipa=inlining,; only ""near-perfect"" devirtualized calls are inlined*, and other dynamic calls; are evaluated conservatively (as if no definition were available). * Currently, no Objective-C messages are not inlined under; -analyzer-config ipa=inlining, even if we are reasonably confident of the type; of the receiver. We plan to enable this once we have tested our heuristics; more thoroughly. The last option, -analyzer-config ipa=dynamic-bifurcate, behaves similarly to; ""dynamic"", but performs a conservative invalidation in the general virtual case; in *addition* to inlining. The details of this are discussed below. As stated above, -analyzer-config ipa=basic-inlining does not inline any C++; member functions or Objective-C method calls, even if the",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:11934,Modifiability,config,config,11934,"dynamic calls will use the DynamicTypeInfo in their; ProgramState to attempt to devirtualize the call. In the case of no dynamic; dispatch, or perfectly constrained devirtualization, the resulting; RuntimeDefinition contains a Decl corresponding to the definition of the called; function, and RuntimeDefinition::mayHaveOtherDefinitions will return FALSE. In the case of dynamic dispatch where our information is not perfect, CallEvent; can make a guess, but RuntimeDefinition::mayHaveOtherDefinitions will return; TRUE. The RuntimeDefinition object will then also include a MemRegion; corresponding to the object being called (i.e., the ""receiver"" in Objective-C; parlance), which ExprEngine uses to decide whether or not the call should be; inlined. Inlining Dynamic Calls; ^^^^^^^^^^^^^^^^^^^^^^. The -analyzer-config ipa option has five different modes: none, basic-inlining,; inlining, dynamic, and dynamic-bifurcate. Under -analyzer-config ipa=dynamic,; all dynamic calls are inlined, whether we are certain or not that this will; actually be the definition used at runtime. Under -analyzer-config ipa=inlining,; only ""near-perfect"" devirtualized calls are inlined*, and other dynamic calls; are evaluated conservatively (as if no definition were available). * Currently, no Objective-C messages are not inlined under; -analyzer-config ipa=inlining, even if we are reasonably confident of the type; of the receiver. We plan to enable this once we have tested our heuristics; more thoroughly. The last option, -analyzer-config ipa=dynamic-bifurcate, behaves similarly to; ""dynamic"", but performs a conservative invalidation in the general virtual case; in *addition* to inlining. The details of this are discussed below. As stated above, -analyzer-config ipa=basic-inlining does not inline any C++; member functions or Objective-C method calls, even if they are non-virtual or; can be safely devirtualized. Bifurcation; ^^^^^^^^^^^. ExprEngine::BifurcateCall implements the ``-analyzer-config ipa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:12092,Modifiability,config,config,12092,"ualization, the resulting; RuntimeDefinition contains a Decl corresponding to the definition of the called; function, and RuntimeDefinition::mayHaveOtherDefinitions will return FALSE. In the case of dynamic dispatch where our information is not perfect, CallEvent; can make a guess, but RuntimeDefinition::mayHaveOtherDefinitions will return; TRUE. The RuntimeDefinition object will then also include a MemRegion; corresponding to the object being called (i.e., the ""receiver"" in Objective-C; parlance), which ExprEngine uses to decide whether or not the call should be; inlined. Inlining Dynamic Calls; ^^^^^^^^^^^^^^^^^^^^^^. The -analyzer-config ipa option has five different modes: none, basic-inlining,; inlining, dynamic, and dynamic-bifurcate. Under -analyzer-config ipa=dynamic,; all dynamic calls are inlined, whether we are certain or not that this will; actually be the definition used at runtime. Under -analyzer-config ipa=inlining,; only ""near-perfect"" devirtualized calls are inlined*, and other dynamic calls; are evaluated conservatively (as if no definition were available). * Currently, no Objective-C messages are not inlined under; -analyzer-config ipa=inlining, even if we are reasonably confident of the type; of the receiver. We plan to enable this once we have tested our heuristics; more thoroughly. The last option, -analyzer-config ipa=dynamic-bifurcate, behaves similarly to; ""dynamic"", but performs a conservative invalidation in the general virtual case; in *addition* to inlining. The details of this are discussed below. As stated above, -analyzer-config ipa=basic-inlining does not inline any C++; member functions or Objective-C method calls, even if they are non-virtual or; can be safely devirtualized. Bifurcation; ^^^^^^^^^^^. ExprEngine::BifurcateCall implements the ``-analyzer-config ipa=dynamic-bifurcate``; mode. When a call is made on an object with imprecise dynamic type information; (RuntimeDefinition::mayHaveOtherDefinitions() evaluates to TRUE), Exp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:12330,Modifiability,config,config,12330,"return FALSE. In the case of dynamic dispatch where our information is not perfect, CallEvent; can make a guess, but RuntimeDefinition::mayHaveOtherDefinitions will return; TRUE. The RuntimeDefinition object will then also include a MemRegion; corresponding to the object being called (i.e., the ""receiver"" in Objective-C; parlance), which ExprEngine uses to decide whether or not the call should be; inlined. Inlining Dynamic Calls; ^^^^^^^^^^^^^^^^^^^^^^. The -analyzer-config ipa option has five different modes: none, basic-inlining,; inlining, dynamic, and dynamic-bifurcate. Under -analyzer-config ipa=dynamic,; all dynamic calls are inlined, whether we are certain or not that this will; actually be the definition used at runtime. Under -analyzer-config ipa=inlining,; only ""near-perfect"" devirtualized calls are inlined*, and other dynamic calls; are evaluated conservatively (as if no definition were available). * Currently, no Objective-C messages are not inlined under; -analyzer-config ipa=inlining, even if we are reasonably confident of the type; of the receiver. We plan to enable this once we have tested our heuristics; more thoroughly. The last option, -analyzer-config ipa=dynamic-bifurcate, behaves similarly to; ""dynamic"", but performs a conservative invalidation in the general virtual case; in *addition* to inlining. The details of this are discussed below. As stated above, -analyzer-config ipa=basic-inlining does not inline any C++; member functions or Objective-C method calls, even if they are non-virtual or; can be safely devirtualized. Bifurcation; ^^^^^^^^^^^. ExprEngine::BifurcateCall implements the ``-analyzer-config ipa=dynamic-bifurcate``; mode. When a call is made on an object with imprecise dynamic type information; (RuntimeDefinition::mayHaveOtherDefinitions() evaluates to TRUE), ExprEngine; bifurcates the path and marks the object's region (retrieved from the; RuntimeDefinition object) with a path-sensitive ""mode"" in the ProgramState. Currently, ther",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:12520,Modifiability,config,config,12520,"esponding to the object being called (i.e., the ""receiver"" in Objective-C; parlance), which ExprEngine uses to decide whether or not the call should be; inlined. Inlining Dynamic Calls; ^^^^^^^^^^^^^^^^^^^^^^. The -analyzer-config ipa option has five different modes: none, basic-inlining,; inlining, dynamic, and dynamic-bifurcate. Under -analyzer-config ipa=dynamic,; all dynamic calls are inlined, whether we are certain or not that this will; actually be the definition used at runtime. Under -analyzer-config ipa=inlining,; only ""near-perfect"" devirtualized calls are inlined*, and other dynamic calls; are evaluated conservatively (as if no definition were available). * Currently, no Objective-C messages are not inlined under; -analyzer-config ipa=inlining, even if we are reasonably confident of the type; of the receiver. We plan to enable this once we have tested our heuristics; more thoroughly. The last option, -analyzer-config ipa=dynamic-bifurcate, behaves similarly to; ""dynamic"", but performs a conservative invalidation in the general virtual case; in *addition* to inlining. The details of this are discussed below. As stated above, -analyzer-config ipa=basic-inlining does not inline any C++; member functions or Objective-C method calls, even if they are non-virtual or; can be safely devirtualized. Bifurcation; ^^^^^^^^^^^. ExprEngine::BifurcateCall implements the ``-analyzer-config ipa=dynamic-bifurcate``; mode. When a call is made on an object with imprecise dynamic type information; (RuntimeDefinition::mayHaveOtherDefinitions() evaluates to TRUE), ExprEngine; bifurcates the path and marks the object's region (retrieved from the; RuntimeDefinition object) with a path-sensitive ""mode"" in the ProgramState. Currently, there are 2 modes:. * ``DynamicDispatchModeInlined`` - Models the case where the dynamic type information; of the receiver (MemoryRegion) is assumed to be perfectly constrained so; that a given definition of a method is expected to be the code actually",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:12748,Modifiability,config,config,12748,"ig ipa option has five different modes: none, basic-inlining,; inlining, dynamic, and dynamic-bifurcate. Under -analyzer-config ipa=dynamic,; all dynamic calls are inlined, whether we are certain or not that this will; actually be the definition used at runtime. Under -analyzer-config ipa=inlining,; only ""near-perfect"" devirtualized calls are inlined*, and other dynamic calls; are evaluated conservatively (as if no definition were available). * Currently, no Objective-C messages are not inlined under; -analyzer-config ipa=inlining, even if we are reasonably confident of the type; of the receiver. We plan to enable this once we have tested our heuristics; more thoroughly. The last option, -analyzer-config ipa=dynamic-bifurcate, behaves similarly to; ""dynamic"", but performs a conservative invalidation in the general virtual case; in *addition* to inlining. The details of this are discussed below. As stated above, -analyzer-config ipa=basic-inlining does not inline any C++; member functions or Objective-C method calls, even if they are non-virtual or; can be safely devirtualized. Bifurcation; ^^^^^^^^^^^. ExprEngine::BifurcateCall implements the ``-analyzer-config ipa=dynamic-bifurcate``; mode. When a call is made on an object with imprecise dynamic type information; (RuntimeDefinition::mayHaveOtherDefinitions() evaluates to TRUE), ExprEngine; bifurcates the path and marks the object's region (retrieved from the; RuntimeDefinition object) with a path-sensitive ""mode"" in the ProgramState. Currently, there are 2 modes:. * ``DynamicDispatchModeInlined`` - Models the case where the dynamic type information; of the receiver (MemoryRegion) is assumed to be perfectly constrained so; that a given definition of a method is expected to be the code actually; called. When this mode is set, ExprEngine uses the Decl from; RuntimeDefinition to inline any dynamically dispatched call sent to this; receiver because the function definition is considered to be fully resolved. * ``DynamicD",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:12986,Modifiability,config,config,12986,"inlined, whether we are certain or not that this will; actually be the definition used at runtime. Under -analyzer-config ipa=inlining,; only ""near-perfect"" devirtualized calls are inlined*, and other dynamic calls; are evaluated conservatively (as if no definition were available). * Currently, no Objective-C messages are not inlined under; -analyzer-config ipa=inlining, even if we are reasonably confident of the type; of the receiver. We plan to enable this once we have tested our heuristics; more thoroughly. The last option, -analyzer-config ipa=dynamic-bifurcate, behaves similarly to; ""dynamic"", but performs a conservative invalidation in the general virtual case; in *addition* to inlining. The details of this are discussed below. As stated above, -analyzer-config ipa=basic-inlining does not inline any C++; member functions or Objective-C method calls, even if they are non-virtual or; can be safely devirtualized. Bifurcation; ^^^^^^^^^^^. ExprEngine::BifurcateCall implements the ``-analyzer-config ipa=dynamic-bifurcate``; mode. When a call is made on an object with imprecise dynamic type information; (RuntimeDefinition::mayHaveOtherDefinitions() evaluates to TRUE), ExprEngine; bifurcates the path and marks the object's region (retrieved from the; RuntimeDefinition object) with a path-sensitive ""mode"" in the ProgramState. Currently, there are 2 modes:. * ``DynamicDispatchModeInlined`` - Models the case where the dynamic type information; of the receiver (MemoryRegion) is assumed to be perfectly constrained so; that a given definition of a method is expected to be the code actually; called. When this mode is set, ExprEngine uses the Decl from; RuntimeDefinition to inline any dynamically dispatched call sent to this; receiver because the function definition is considered to be fully resolved. * ``DynamicDispatchModeConservative`` - Models the case where the dynamic type; information is assumed to be incorrect, for example, implies that the method; definition is overr",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:7703,Performance,perform,performance,7703,"cted, we walk up the path to find the first node; before inlining was started and enqueue it on the WorkList with a special; ReplayWithoutInlining bit added to it (ExprEngine::replayWithoutInlining). The; path is then re-analyzed from that point without inlining that particular call. Deciding When to Inline; ^^^^^^^^^^^^^^^^^^^^^^^. In general, the analyzer attempts to inline as much as possible, since it; provides a better summary of what actually happens in the program. There are; some cases, however, where the analyzer chooses not to inline:. - If there is no definition available for the called function or method. In; this case, there is no opportunity to inline. - If the CFG cannot be constructed for a called function, or the liveness; cannot be computed. These are prerequisites for analyzing a function body,; with or without inlining. - If the LocationContext chain for a given ExplodedNode reaches a maximum cutoff; depth. This prevents unbounded analysis due to infinite recursion, but also; serves as a useful cutoff for performance reasons. - If the function is variadic. This is not a hard limitation, but an engineering; limitation. Tracked by: <rdar://problem/12147064> Support inlining of variadic functions. - In C++, constructors are not inlined unless the destructor call will be; processed by the ExprEngine. Thus, if the CFG was built without nodes for; implicit destructors, or if the destructors for the given object are not; represented in the CFG, the constructor will not be inlined. (As an exception,; constructors for objects with trivial constructors can still be inlined.); See ""C++ Caveats"" below. - In C++, ExprEngine does not inline custom implementations of operator 'new'; or operator 'delete', nor does it inline the constructors and destructors; associated with these. See ""C++ Caveats"" below. - Calls resulting in ""dynamic dispatch"" are specially handled. See more below. - The FunctionSummaries map stores additional information about declarations,; som",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:12587,Performance,perform,performs,12587,"esponding to the object being called (i.e., the ""receiver"" in Objective-C; parlance), which ExprEngine uses to decide whether or not the call should be; inlined. Inlining Dynamic Calls; ^^^^^^^^^^^^^^^^^^^^^^. The -analyzer-config ipa option has five different modes: none, basic-inlining,; inlining, dynamic, and dynamic-bifurcate. Under -analyzer-config ipa=dynamic,; all dynamic calls are inlined, whether we are certain or not that this will; actually be the definition used at runtime. Under -analyzer-config ipa=inlining,; only ""near-perfect"" devirtualized calls are inlined*, and other dynamic calls; are evaluated conservatively (as if no definition were available). * Currently, no Objective-C messages are not inlined under; -analyzer-config ipa=inlining, even if we are reasonably confident of the type; of the receiver. We plan to enable this once we have tested our heuristics; more thoroughly. The last option, -analyzer-config ipa=dynamic-bifurcate, behaves similarly to; ""dynamic"", but performs a conservative invalidation in the general virtual case; in *addition* to inlining. The details of this are discussed below. As stated above, -analyzer-config ipa=basic-inlining does not inline any C++; member functions or Objective-C method calls, even if they are non-virtual or; can be safely devirtualized. Bifurcation; ^^^^^^^^^^^. ExprEngine::BifurcateCall implements the ``-analyzer-config ipa=dynamic-bifurcate``; mode. When a call is made on an object with imprecise dynamic type information; (RuntimeDefinition::mayHaveOtherDefinitions() evaluates to TRUE), ExprEngine; bifurcates the path and marks the object's region (retrieved from the; RuntimeDefinition object) with a path-sensitive ""mode"" in the ProgramState. Currently, there are 2 modes:. * ``DynamicDispatchModeInlined`` - Models the case where the dynamic type information; of the receiver (MemoryRegion) is assumed to be perfectly constrained so; that a given definition of a method is expected to be the code actually",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:14666,Performance,perform,performance,14666,"lly dispatched call sent to this; receiver because the function definition is considered to be fully resolved. * ``DynamicDispatchModeConservative`` - Models the case where the dynamic type; information is assumed to be incorrect, for example, implies that the method; definition is overridden in a subclass. In such cases, ExprEngine does not; inline the methods sent to the receiver (MemoryRegion), even if a candidate; definition is available. This mode is conservative about simulating the; effects of a call. Going forward along the symbolic execution path, ExprEngine consults the mode; of the receiver's MemRegion to make decisions on whether the calls should be; inlined or not, which ensures that there is at most one split per region. At a high level, ""bifurcation mode"" allows for increased semantic coverage in; cases where the parent method contains code which is only executed when the; class is subclassed. The disadvantages of this mode are a (considerable?); performance hit and the possibility of false positives on the path where the; conservative mode is used. Objective-C Message Heuristics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ExprEngine relies on a set of heuristics to partition the set of Objective-C; method calls into those that require bifurcation and those that do not. Below; are the cases when the DynamicTypeInfo of the object is considered precise; (cannot be a subclass):. - If the object was created with +alloc or +new and initialized with an -init; method. - If the calls are property accesses using dot syntax. This is based on the; assumption that children rarely override properties, or do so in an; essentially compatible way. - If the class interface is declared inside the main source file. In this case; it is unlikely that it will be subclassed. - If the method is not declared outside of main source file, either by the; receiver's class or by any superclasses. C++ Caveats; ^^^^^^^^^^^. C++11 [class.cdtor]p4 describes how the vtable of an object is modified",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:4717,Safety,avoid,avoided,4717,"erience, since; most users would not be comfortable adding assertions to system headers in order; to silence analyzer warnings. c++-container-inlining; ^^^^^^^^^^^^^^^^^^^^^^. This option controls whether constructors and destructors of ""container"" types; should be considered for inlining. ``-analyzer-config c++-container-inlining=[true | false]``. Currently, these constructors and destructors are NOT considered for inlining; by default. The current implementation of this setting checks whether a type has a member; named 'iterator' or a member named 'begin'; these names are idiomatic in C++,; with the latter specified in the C++11 standard. The analyzer currently does a; fairly poor job of modeling certain data structure invariants of container-like; objects. For example, these three expressions should be equivalent:. .. code-block:: cpp. std::distance(c.begin(), c.end()) == 0; c.begin() == c.end(); c.empty(). Many of these issues are avoided if containers always have unknown, symbolic; state, which is what happens when their constructors are treated as opaque.; In the future, we may decide specific containers are ""safe"" to model through; inlining, or choose to model them directly using checkers instead. Basics of Implementation; ------------------------. The low-level mechanism of inlining a function is handled in; ExprEngine::inlineCall and ExprEngine::processCallExit. If the conditions are right for inlining, a CallEnter node is created and added; to the analysis work list. The CallEnter node marks the change to a new; LocationContext representing the called function, and its state includes the; contents of the new stack frame. When the CallEnter node is actually processed,; its single successor will be an edge to the first CFG block in the function. Exiting an inlined function is a bit more work, fortunately broken up into; reasonable steps:. 1. The CoreEngine realizes we're at the end of an inlined call and generates a; CallExitBegin node. 2. ExprEngine takes o",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:4901,Safety,safe,safe,4901,"; ^^^^^^^^^^^^^^^^^^^^^^. This option controls whether constructors and destructors of ""container"" types; should be considered for inlining. ``-analyzer-config c++-container-inlining=[true | false]``. Currently, these constructors and destructors are NOT considered for inlining; by default. The current implementation of this setting checks whether a type has a member; named 'iterator' or a member named 'begin'; these names are idiomatic in C++,; with the latter specified in the C++11 standard. The analyzer currently does a; fairly poor job of modeling certain data structure invariants of container-like; objects. For example, these three expressions should be equivalent:. .. code-block:: cpp. std::distance(c.begin(), c.end()) == 0; c.begin() == c.end(); c.empty(). Many of these issues are avoided if containers always have unknown, symbolic; state, which is what happens when their constructors are treated as opaque.; In the future, we may decide specific containers are ""safe"" to model through; inlining, or choose to model them directly using checkers instead. Basics of Implementation; ------------------------. The low-level mechanism of inlining a function is handled in; ExprEngine::inlineCall and ExprEngine::processCallExit. If the conditions are right for inlining, a CallEnter node is created and added; to the analysis work list. The CallEnter node marks the change to a new; LocationContext representing the called function, and its state includes the; contents of the new stack frame. When the CallEnter node is actually processed,; its single successor will be an edge to the first CFG block in the function. Exiting an inlined function is a bit more work, fortunately broken up into; reasonable steps:. 1. The CoreEngine realizes we're at the end of an inlined call and generates a; CallExitBegin node. 2. ExprEngine takes over (in processCallExit) and finds the return value of the; function, if it has one. This is bound to the expression that triggered the; call. (In the",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:6514,Safety,recover,recover,6514,"ting an inlined function is a bit more work, fortunately broken up into; reasonable steps:. 1. The CoreEngine realizes we're at the end of an inlined call and generates a; CallExitBegin node. 2. ExprEngine takes over (in processCallExit) and finds the return value of the; function, if it has one. This is bound to the expression that triggered the; call. (In the case of calls without origin expressions, such as destructors,; this step is skipped.). 3. Dead symbols and bindings are cleaned out from the state, including any local; bindings. 4. A CallExitEnd node is generated, which marks the transition back to the; caller's LocationContext. 5. Custom post-call checks are processed and the final nodes are pushed back; onto the work list, so that evaluation of the caller can continue. Retry Without Inlining; ^^^^^^^^^^^^^^^^^^^^^^. In some cases, we would like to retry analysis without inlining a particular; call. Currently, we use this technique to recover coverage in case we stop; analyzing a path due to exceeding the maximum block count inside an inlined; function. When this situation is detected, we walk up the path to find the first node; before inlining was started and enqueue it on the WorkList with a special; ReplayWithoutInlining bit added to it (ExprEngine::replayWithoutInlining). The; path is then re-analyzed from that point without inlining that particular call. Deciding When to Inline; ^^^^^^^^^^^^^^^^^^^^^^^. In general, the analyzer attempts to inline as much as possible, since it; provides a better summary of what actually happens in the program. There are; some cases, however, where the analyzer chooses not to inline:. - If there is no definition available for the called function or method. In; this case, there is no opportunity to inline. - If the CFG cannot be constructed for a called function, or the liveness; cannot be computed. These are prerequisites for analyzing a function body,; with or without inlining. - If the LocationContext chain for a given",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:6658,Safety,detect,detected,6658,"2. ExprEngine takes over (in processCallExit) and finds the return value of the; function, if it has one. This is bound to the expression that triggered the; call. (In the case of calls without origin expressions, such as destructors,; this step is skipped.). 3. Dead symbols and bindings are cleaned out from the state, including any local; bindings. 4. A CallExitEnd node is generated, which marks the transition back to the; caller's LocationContext. 5. Custom post-call checks are processed and the final nodes are pushed back; onto the work list, so that evaluation of the caller can continue. Retry Without Inlining; ^^^^^^^^^^^^^^^^^^^^^^. In some cases, we would like to retry analysis without inlining a particular; call. Currently, we use this technique to recover coverage in case we stop; analyzing a path due to exceeding the maximum block count inside an inlined; function. When this situation is detected, we walk up the path to find the first node; before inlining was started and enqueue it on the WorkList with a special; ReplayWithoutInlining bit added to it (ExprEngine::replayWithoutInlining). The; path is then re-analyzed from that point without inlining that particular call. Deciding When to Inline; ^^^^^^^^^^^^^^^^^^^^^^^. In general, the analyzer attempts to inline as much as possible, since it; provides a better summary of what actually happens in the program. There are; some cases, however, where the analyzer chooses not to inline:. - If there is no definition available for the called function or method. In; this case, there is no opportunity to inline. - If the CFG cannot be constructed for a called function, or the liveness; cannot be computed. These are prerequisites for analyzing a function body,; with or without inlining. - If the LocationContext chain for a given ExplodedNode reaches a maximum cutoff; depth. This prevents unbounded analysis due to infinite recursion, but also; serves as a useful cutoff for performance reasons. - If the function is var",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:12885,Safety,safe,safely,12885,"ig ipa option has five different modes: none, basic-inlining,; inlining, dynamic, and dynamic-bifurcate. Under -analyzer-config ipa=dynamic,; all dynamic calls are inlined, whether we are certain or not that this will; actually be the definition used at runtime. Under -analyzer-config ipa=inlining,; only ""near-perfect"" devirtualized calls are inlined*, and other dynamic calls; are evaluated conservatively (as if no definition were available). * Currently, no Objective-C messages are not inlined under; -analyzer-config ipa=inlining, even if we are reasonably confident of the type; of the receiver. We plan to enable this once we have tested our heuristics; more thoroughly. The last option, -analyzer-config ipa=dynamic-bifurcate, behaves similarly to; ""dynamic"", but performs a conservative invalidation in the general virtual case; in *addition* to inlining. The details of this are discussed below. As stated above, -analyzer-config ipa=basic-inlining does not inline any C++; member functions or Objective-C method calls, even if they are non-virtual or; can be safely devirtualized. Bifurcation; ^^^^^^^^^^^. ExprEngine::BifurcateCall implements the ``-analyzer-config ipa=dynamic-bifurcate``; mode. When a call is made on an object with imprecise dynamic type information; (RuntimeDefinition::mayHaveOtherDefinitions() evaluates to TRUE), ExprEngine; bifurcates the path and marks the object's region (retrieved from the; RuntimeDefinition object) with a path-sensitive ""mode"" in the ProgramState. Currently, there are 2 modes:. * ``DynamicDispatchModeInlined`` - Models the case where the dynamic type information; of the receiver (MemoryRegion) is assumed to be perfectly constrained so; that a given definition of a method is expected to be the code actually; called. When this mode is set, ExprEngine uses the Decl from; RuntimeDefinition to inline any dynamically dispatched call sent to this; receiver because the function definition is considered to be fully resolved. * ``DynamicD",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:15208,Security,access,accesses,15208,"ing forward along the symbolic execution path, ExprEngine consults the mode; of the receiver's MemRegion to make decisions on whether the calls should be; inlined or not, which ensures that there is at most one split per region. At a high level, ""bifurcation mode"" allows for increased semantic coverage in; cases where the parent method contains code which is only executed when the; class is subclassed. The disadvantages of this mode are a (considerable?); performance hit and the possibility of false positives on the path where the; conservative mode is used. Objective-C Message Heuristics; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. ExprEngine relies on a set of heuristics to partition the set of Objective-C; method calls into those that require bifurcation and those that do not. Below; are the cases when the DynamicTypeInfo of the object is considered precise; (cannot be a subclass):. - If the object was created with +alloc or +new and initialized with an -init; method. - If the calls are property accesses using dot syntax. This is based on the; assumption that children rarely override properties, or do so in an; essentially compatible way. - If the class interface is declared inside the main source file. In this case; it is unlikely that it will be subclassed. - If the method is not declared outside of main source file, either by the; receiver's class or by any superclasses. C++ Caveats; ^^^^^^^^^^^. C++11 [class.cdtor]p4 describes how the vtable of an object is modified as it is; being constructed or destructed; that is, the type of the object depends on; which base constructors have been completed. This is tracked using; DynamicTypeInfo in the DynamicTypePropagation checker. There are several limitations in the current implementation:. * Temporaries are poorly modeled right now because we're not confident in the; placement of their destructors in the CFG. We currently won't inline their; constructors unless the destructor is trivial, and don't process their; destructors at a",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:16834,Security,access,access,16834,"^^^. C++11 [class.cdtor]p4 describes how the vtable of an object is modified as it is; being constructed or destructed; that is, the type of the object depends on; which base constructors have been completed. This is tracked using; DynamicTypeInfo in the DynamicTypePropagation checker. There are several limitations in the current implementation:. * Temporaries are poorly modeled right now because we're not confident in the; placement of their destructors in the CFG. We currently won't inline their; constructors unless the destructor is trivial, and don't process their; destructors at all, not even to invalidate the region. * 'new' is poorly modeled due to some nasty CFG/design issues. This is tracked; in PR12014. 'delete' is not modeled at all. * Arrays of objects are modeled very poorly right now. ExprEngine currently; only simulates the first constructor and first destructor. Because of this,; ExprEngine does not inline any constructors or destructors for arrays. CallEvent; ^^^^^^^^^. A CallEvent represents a specific call to a function, method, or other body of; code. It is path-sensitive, containing both the current state (ProgramStateRef); and stack space (LocationContext), and provides uniform access to the argument; values and return type of a call, no matter how the call is written in the; source or what sort of code body is being invoked. NOTE: For those familiar with Cocoa, CallEvent is roughly equivalent to; NSInvocation. CallEvent should be used whenever there is logic dealing with function calls; that does not care how the call occurred. Examples include checking that arguments satisfy preconditions (such as; __attribute__((nonnull))), and attempting to inline a call. CallEvents are reference-counted objects managed by a CallEventManager. While; there is no inherent issue with persisting them (say, in a ProgramState's GDM),; they are intended for short-lived use, and can be recreated from CFGElements or; non-top-level StackFrameContexts fairly easily.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:3827,Testability,assert,assertions,3827,"r-config c++-template-inlining=[true | false]``. Currently, template functions are considered for inlining by default. The motivation behind this option is that very generic code can be a source; of false positives, either by considering paths that the caller considers; impossible (by some unstated precondition), or by inlining some but not all; of a deep implementation of a function. c++-stdlib-inlining; ^^^^^^^^^^^^^^^^^^^. This option controls whether functions from the C++ standard library, including; methods of the container classes in the Standard Template Library, should be; considered for inlining. ``-analyzer-config c++-stdlib-inlining=[true | false]``. Currently, C++ standard library functions are considered for inlining by; default. The standard library functions and the STL in particular are used ubiquitously; enough that our tolerance for false positives is even lower here. A false; positive due to poor modeling of the STL leads to a poor user experience, since; most users would not be comfortable adding assertions to system headers in order; to silence analyzer warnings. c++-container-inlining; ^^^^^^^^^^^^^^^^^^^^^^. This option controls whether constructors and destructors of ""container"" types; should be considered for inlining. ``-analyzer-config c++-container-inlining=[true | false]``. Currently, these constructors and destructors are NOT considered for inlining; by default. The current implementation of this setting checks whether a type has a member; named 'iterator' or a member named 'begin'; these names are idiomatic in C++,; with the latter specified in the C++11 standard. The analyzer currently does a; fairly poor job of modeling certain data structure invariants of container-like; objects. For example, these three expressions should be equivalent:. .. code-block:: cpp. std::distance(c.begin(), c.end()) == 0; c.begin() == c.end(); c.empty(). Many of these issues are avoided if containers always have unknown, symbolic; state, which is what hap",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:12453,Testability,test,tested,12453,"RuntimeDefinition::mayHaveOtherDefinitions will return; TRUE. The RuntimeDefinition object will then also include a MemRegion; corresponding to the object being called (i.e., the ""receiver"" in Objective-C; parlance), which ExprEngine uses to decide whether or not the call should be; inlined. Inlining Dynamic Calls; ^^^^^^^^^^^^^^^^^^^^^^. The -analyzer-config ipa option has five different modes: none, basic-inlining,; inlining, dynamic, and dynamic-bifurcate. Under -analyzer-config ipa=dynamic,; all dynamic calls are inlined, whether we are certain or not that this will; actually be the definition used at runtime. Under -analyzer-config ipa=inlining,; only ""near-perfect"" devirtualized calls are inlined*, and other dynamic calls; are evaluated conservatively (as if no definition were available). * Currently, no Objective-C messages are not inlined under; -analyzer-config ipa=inlining, even if we are reasonably confident of the type; of the receiver. We plan to enable this once we have tested our heuristics; more thoroughly. The last option, -analyzer-config ipa=dynamic-bifurcate, behaves similarly to; ""dynamic"", but performs a conservative invalidation in the general virtual case; in *addition* to inlining. The details of this are discussed below. As stated above, -analyzer-config ipa=basic-inlining does not inline any C++; member functions or Objective-C method calls, even if they are non-virtual or; can be safely devirtualized. Bifurcation; ^^^^^^^^^^^. ExprEngine::BifurcateCall implements the ``-analyzer-config ipa=dynamic-bifurcate``; mode. When a call is made on an object with imprecise dynamic type information; (RuntimeDefinition::mayHaveOtherDefinitions() evaluates to TRUE), ExprEngine; bifurcates the path and marks the object's region (retrieved from the; RuntimeDefinition object) with a path-sensitive ""mode"" in the ProgramState. Currently, there are 2 modes:. * ``DynamicDispatchModeInlined`` - Models the case where the dynamic type information; of the receiv",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:17115,Testability,log,logic,17115,"^^^. C++11 [class.cdtor]p4 describes how the vtable of an object is modified as it is; being constructed or destructed; that is, the type of the object depends on; which base constructors have been completed. This is tracked using; DynamicTypeInfo in the DynamicTypePropagation checker. There are several limitations in the current implementation:. * Temporaries are poorly modeled right now because we're not confident in the; placement of their destructors in the CFG. We currently won't inline their; constructors unless the destructor is trivial, and don't process their; destructors at all, not even to invalidate the region. * 'new' is poorly modeled due to some nasty CFG/design issues. This is tracked; in PR12014. 'delete' is not modeled at all. * Arrays of objects are modeled very poorly right now. ExprEngine currently; only simulates the first constructor and first destructor. Because of this,; ExprEngine does not inline any constructors or destructors for arrays. CallEvent; ^^^^^^^^^. A CallEvent represents a specific call to a function, method, or other body of; code. It is path-sensitive, containing both the current state (ProgramStateRef); and stack space (LocationContext), and provides uniform access to the argument; values and return type of a call, no matter how the call is written in the; source or what sort of code body is being invoked. NOTE: For those familiar with Cocoa, CallEvent is roughly equivalent to; NSInvocation. CallEvent should be used whenever there is logic dealing with function calls; that does not care how the call occurred. Examples include checking that arguments satisfy preconditions (such as; __attribute__((nonnull))), and attempting to inline a call. CallEvents are reference-counted objects managed by a CallEventManager. While; there is no inherent issue with persisting them (say, in a ProgramState's GDM),; they are intended for short-lived use, and can be recreated from CFGElements or; non-top-level StackFrameContexts fairly easily.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:466,Usability,simpl,simple,466,"Inlining; ========. There are several options that control which calls the analyzer will consider for; inlining. The major one is ``-analyzer-config ipa``:. * ``analyzer-config ipa=none`` - All inlining is disabled. This is the only mode; available in LLVM 3.1 and earlier and in Xcode 4.3 and earlier. * ``analyzer-config ipa=basic-inlining`` - Turns on inlining for C functions, C++; static member functions, and blocks -- essentially, the calls that behave; like simple C function calls. This is essentially the mode used in; Xcode 4.4. * ``analyzer-config ipa=inlining`` - Turns on inlining when we can confidently find; the function/method body corresponding to the call. (C functions, static; functions, devirtualized C++ methods, Objective-C class methods, Objective-C; instance methods when ExprEngine is confident about the dynamic type of the; instance). * ``analyzer-config ipa=dynamic`` - Inline instance methods for which the type is; determined at runtime and we are not 100% sure that our type info is; correct. For virtual calls, inline the most plausible definition. * ``analyzer-config ipa=dynamic-bifurcate`` - Same as -analyzer-config ipa=dynamic,; but the path is split. We inline on one branch and do not inline on the; other. This mode does not drop the coverage in cases when the parent class; has code that is only exercised when some of its methods are overridden. Currently, ``-analyzer-config ipa=dynamic-bifurcate`` is the default mode. While ``-analyzer-config ipa`` determines in general how aggressively the analyzer; will try to inline functions, several additional options control which types of; functions can inlined, in an all-or-nothing way. These options use the; analyzer's configuration table, so they are all specified as follows:. ``-analyzer-config OPTION=VALUE``. c++-inlining; ------------. This option controls which C++ member functions may be inlined. ``-analyzer-config c++-inlining=[none | methods | constructors | destructors]``. Each of these modes",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst:3760,Usability,user experience,user experience,3760,"r-config c++-template-inlining=[true | false]``. Currently, template functions are considered for inlining by default. The motivation behind this option is that very generic code can be a source; of false positives, either by considering paths that the caller considers; impossible (by some unstated precondition), or by inlining some but not all; of a deep implementation of a function. c++-stdlib-inlining; ^^^^^^^^^^^^^^^^^^^. This option controls whether functions from the C++ standard library, including; methods of the container classes in the Standard Template Library, should be; considered for inlining. ``-analyzer-config c++-stdlib-inlining=[true | false]``. Currently, C++ standard library functions are considered for inlining by; default. The standard library functions and the STL in particular are used ubiquitously; enough that our tolerance for false positives is even lower here. A false; positive due to poor modeling of the STL leads to a poor user experience, since; most users would not be comfortable adding assertions to system headers in order; to silence analyzer warnings. c++-container-inlining; ^^^^^^^^^^^^^^^^^^^^^^. This option controls whether constructors and destructors of ""container"" types; should be considered for inlining. ``-analyzer-config c++-container-inlining=[true | false]``. Currently, these constructors and destructors are NOT considered for inlining; by default. The current implementation of this setting checks whether a type has a member; named 'iterator' or a member named 'begin'; these names are idiomatic in C++,; with the latter specified in the C++11 standard. The analyzer currently does a; fairly poor job of modeling certain data structure invariants of container-like; objects. For example, these three expressions should be equivalent:. .. code-block:: cpp. std::distance(c.begin(), c.end()) == 0; c.begin() == c.end(); c.empty(). Many of these issues are avoided if containers always have unknown, symbolic; state, which is what hap",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/IPA.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/nullability.rst:2033,Availability,error,errors,2033,"ard compatibility hack); anotherTakesNonNull(bar); // would be great to warn here, but not necessary(*). Because bar corresponds to the same symbol all the time it is not easy to implement the checker that way the cast only suppress the first call but not the second. For this reason in the first implementation after a contradictory cast happens, I will treat bar as nullable unspecified, this way all of the warnings will be suppressed. Treating the symbol as nullable unspecified also has an advantage that in case the takesNonNull function body is being inlined, the will be no warning, when the symbol is dereferenced. In case I have time after the initial version I might spend additional time to try to find a more sophisticated solution, in which we would produce the second warning (*). **2) nonnull**. * Dereferencing a nonnull, or sending message to it is ok.; * Converting nonnull to nullable is Ok.; * When there is an explicit cast from nonnull to nullable I will trust the cast (it is probable there for a reason, because this cast does not suppress any warnings or errors).; * But what should we do about null checks?:. .. code-block:: cpp. __nonnull id takesNonnull(__nonnull id x) {; if (x == nil) {; // Defensive backward compatible code:; ....; return nil; // Should the analyzer cover this piece of code? Should we require the cast (__nonnull)nil?; }; ....; }. There are these directions:. * We can either take the branch; this way the branch is analyzed; * Should we not warn about any nullability issues in that branch? Probably not, it is ok to break the nullability postconditions when the nullability preconditions are violated.; * We can assume that these pointers are not null and we lose coverage with the analyzer. (This can be implemented either in constraint solver or in the checker itself.). Other Issues to keep in mind/take care of:. * Messaging:. * Sending a message to a nullable pointer. * Even though the method might return a nonnull pointer, when it was sent",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/nullability.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/nullability.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/nullability.rst:4041,Availability,robust,robust,4041," nonnull pointer. * If the pointer is not assumed to be nil, we should be optimistic and use the nullability implied by the method. * This will not happen automatically, since the AST will have null unspecified in this case. Inlining; --------. A symbol may need to be treated differently inside an inlined body. For example, consider these conversions from nonnull to nullable in presence of inlining:. .. code-block:: cpp. id obj = getNonnull();; takesNullable(obj);; takesNonnull(obj);. void takesNullable(nullable id obj) {; obj->ivar // we should assume obj is nullable and warn here; }. With no special treatment, when the takesNullable is inlined the analyzer will not warn when the obj symbol is dereferenced. One solution for this is to reanalyze takesNullable as a top level function to get possible violations. The alternative method, deducing nullability information from the arguments after inlining is not robust enough (for example there might be more parameters with different nullability, but in the given path the two parameters might end up being the same symbol or there can be nested functions that take different view of the nullability of the same symbol). So the symbol will remain nonnull to avoid false positives but the functions that takes nullable parameters will be analyzed separately as well without inlining. Annotations on multi level pointers; -----------------------------------. Tracking multiple levels of annotations for pointers pointing to pointers would make the checker more complicated, because this way a vector of nullability qualifiers would be needed to be tracked for each symbol. This is not a big caveat, since once the top level pointer is dereferenced, the symvol for the inner pointer will have the nullability information. The lack of multi level annotation tracking only observable, when multiple levels of pointers are passed to a function which has a parameter with multiple levels of annotations. So for now the checker support the top level",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/nullability.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/nullability.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/nullability.rst:1802,Integrability,message,message,1802,"s. Explicit cast from nullable to nonnull:. .. code-block:: cpp. __nullable id foo;; id bar = foo;; takesNonNull((_nonnull) bar); // should not warn here (backward compatibility hack); anotherTakesNonNull(bar); // would be great to warn here, but not necessary(*). Because bar corresponds to the same symbol all the time it is not easy to implement the checker that way the cast only suppress the first call but not the second. For this reason in the first implementation after a contradictory cast happens, I will treat bar as nullable unspecified, this way all of the warnings will be suppressed. Treating the symbol as nullable unspecified also has an advantage that in case the takesNonNull function body is being inlined, the will be no warning, when the symbol is dereferenced. In case I have time after the initial version I might spend additional time to try to find a more sophisticated solution, in which we would produce the second warning (*). **2) nonnull**. * Dereferencing a nonnull, or sending message to it is ok.; * Converting nonnull to nullable is Ok.; * When there is an explicit cast from nonnull to nullable I will trust the cast (it is probable there for a reason, because this cast does not suppress any warnings or errors).; * But what should we do about null checks?:. .. code-block:: cpp. __nonnull id takesNonnull(__nonnull id x) {; if (x == nil) {; // Defensive backward compatible code:; ....; return nil; // Should the analyzer cover this piece of code? Should we require the cast (__nonnull)nil?; }; ....; }. There are these directions:. * We can either take the branch; this way the branch is analyzed; * Should we not warn about any nullability issues in that branch? Probably not, it is ok to break the nullability postconditions when the nullability preconditions are violated.; * We can assume that these pointers are not null and we lose coverage with the analyzer. (This can be implemented either in constraint solver or in the checker itself.). Other Issues to",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/nullability.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/nullability.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/nullability.rst:2848,Integrability,message,message,2848," is Ok.; * When there is an explicit cast from nonnull to nullable I will trust the cast (it is probable there for a reason, because this cast does not suppress any warnings or errors).; * But what should we do about null checks?:. .. code-block:: cpp. __nonnull id takesNonnull(__nonnull id x) {; if (x == nil) {; // Defensive backward compatible code:; ....; return nil; // Should the analyzer cover this piece of code? Should we require the cast (__nonnull)nil?; }; ....; }. There are these directions:. * We can either take the branch; this way the branch is analyzed; * Should we not warn about any nullability issues in that branch? Probably not, it is ok to break the nullability postconditions when the nullability preconditions are violated.; * We can assume that these pointers are not null and we lose coverage with the analyzer. (This can be implemented either in constraint solver or in the checker itself.). Other Issues to keep in mind/take care of:. * Messaging:. * Sending a message to a nullable pointer. * Even though the method might return a nonnull pointer, when it was sent to a nullable pointer the return type will be nullable.; 	* The result is nullable unless the receiver is known to be non null. * Sending a message to an unspecified or nonnull pointer. * If the pointer is not assumed to be nil, we should be optimistic and use the nullability implied by the method. * This will not happen automatically, since the AST will have null unspecified in this case. Inlining; --------. A symbol may need to be treated differently inside an inlined body. For example, consider these conversions from nonnull to nullable in presence of inlining:. .. code-block:: cpp. id obj = getNonnull();; takesNullable(obj);; takesNonnull(obj);. void takesNullable(nullable id obj) {; obj->ivar // we should assume obj is nullable and warn here; }. With no special treatment, when the takesNullable is inlined the analyzer will not warn when the obj symbol is dereferenced. One solution for t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/nullability.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/nullability.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/nullability.rst:3093,Integrability,message,message,3093,"__nonnull id takesNonnull(__nonnull id x) {; if (x == nil) {; // Defensive backward compatible code:; ....; return nil; // Should the analyzer cover this piece of code? Should we require the cast (__nonnull)nil?; }; ....; }. There are these directions:. * We can either take the branch; this way the branch is analyzed; * Should we not warn about any nullability issues in that branch? Probably not, it is ok to break the nullability postconditions when the nullability preconditions are violated.; * We can assume that these pointers are not null and we lose coverage with the analyzer. (This can be implemented either in constraint solver or in the checker itself.). Other Issues to keep in mind/take care of:. * Messaging:. * Sending a message to a nullable pointer. * Even though the method might return a nonnull pointer, when it was sent to a nullable pointer the return type will be nullable.; 	* The result is nullable unless the receiver is known to be non null. * Sending a message to an unspecified or nonnull pointer. * If the pointer is not assumed to be nil, we should be optimistic and use the nullability implied by the method. * This will not happen automatically, since the AST will have null unspecified in this case. Inlining; --------. A symbol may need to be treated differently inside an inlined body. For example, consider these conversions from nonnull to nullable in presence of inlining:. .. code-block:: cpp. id obj = getNonnull();; takesNullable(obj);; takesNonnull(obj);. void takesNullable(nullable id obj) {; obj->ivar // we should assume obj is nullable and warn here; }. With no special treatment, when the takesNullable is inlined the analyzer will not warn when the obj symbol is dereferenced. One solution for this is to reanalyze takesNullable as a top level function to get possible violations. The alternative method, deducing nullability information from the arguments after inlining is not robust enough (for example there might be more parameters with diffe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/nullability.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/nullability.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/nullability.rst:5924,Integrability,wrap,wrapped,5924," with different nullability, but in the given path the two parameters might end up being the same symbol or there can be nested functions that take different view of the nullability of the same symbol). So the symbol will remain nonnull to avoid false positives but the functions that takes nullable parameters will be analyzed separately as well without inlining. Annotations on multi level pointers; -----------------------------------. Tracking multiple levels of annotations for pointers pointing to pointers would make the checker more complicated, because this way a vector of nullability qualifiers would be needed to be tracked for each symbol. This is not a big caveat, since once the top level pointer is dereferenced, the symvol for the inner pointer will have the nullability information. The lack of multi level annotation tracking only observable, when multiple levels of pointers are passed to a function which has a parameter with multiple levels of annotations. So for now the checker support the top level nullability qualifiers only.:. .. code-block:: cpp. int * __nonnull * __nullable p;; int ** q = p;; takesStarNullableStarNullable(q);. Implementation notes; --------------------. What to track?. * The checker would track memory regions, and to each relevant region a qualifier information would be attached which is either nullable, nonnull or null unspecified (or contradicted to suppress warnings for a specific region).; * On a branch, where a nullable pointer is known to be non null, the checker treat it as a same way as a pointer annotated as nonnull.; * When there is an explicit cast from a null unspecified to either nonnull or nullable I will trust the cast.; * Unannotated pointers are treated the same way as pointers annotated with nullability unspecified qualifier, unless the region is wrapped in ASSUME_NONNULL macros.; * We might want to implement a callback for entry points to top level functions, where the pointer nullability assumptions would be made.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/nullability.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/nullability.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/nullability.rst:4338,Safety,avoid,avoid,4338,"ed to be treated differently inside an inlined body. For example, consider these conversions from nonnull to nullable in presence of inlining:. .. code-block:: cpp. id obj = getNonnull();; takesNullable(obj);; takesNonnull(obj);. void takesNullable(nullable id obj) {; obj->ivar // we should assume obj is nullable and warn here; }. With no special treatment, when the takesNullable is inlined the analyzer will not warn when the obj symbol is dereferenced. One solution for this is to reanalyze takesNullable as a top level function to get possible violations. The alternative method, deducing nullability information from the arguments after inlining is not robust enough (for example there might be more parameters with different nullability, but in the given path the two parameters might end up being the same symbol or there can be nested functions that take different view of the nullability of the same symbol). So the symbol will remain nonnull to avoid false positives but the functions that takes nullable parameters will be analyzed separately as well without inlining. Annotations on multi level pointers; -----------------------------------. Tracking multiple levels of annotations for pointers pointing to pointers would make the checker more complicated, because this way a vector of nullability qualifiers would be needed to be tracked for each symbol. This is not a big caveat, since once the top level pointer is dereferenced, the symvol for the inner pointer will have the nullability information. The lack of multi level annotation tracking only observable, when multiple levels of pointers are passed to a function which has a parameter with multiple levels of annotations. So for now the checker support the top level nullability qualifiers only.:. .. code-block:: cpp. int * __nonnull * __nullable p;; int ** q = p;; takesStarNullableStarNullable(q);. Implementation notes; --------------------. What to track?. * The checker would track memory regions, and to each relevant r",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/nullability.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/nullability.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/nullability.rst:487,Testability,assert,assert,487,"==================; Nullability Checks; ==================. This document is a high level description of the nullablility checks.; These checks intended to use the annotations that is described in this; RFC: https://discourse.llvm.org/t/rfc-nullability-qualifiers/35672; (`Mailman <https://lists.llvm.org/pipermail/cfe-dev/2015-March/041779.html>`_). Let's consider the following 2 categories:. **1) nullable**. If a pointer ``p`` has a nullable annotation and no explicit null check or assert, we should warn in the following cases:. * ``p`` gets implicitly converted into nonnull pointer, for example, we are passing it to a function that takes a nonnull parameter.; * ``p`` gets dereferenced. Taking a branch on nullable pointers are the same like taking branch on null unspecified pointers. Explicit cast from nullable to nonnull:. .. code-block:: cpp. __nullable id foo;; id bar = foo;; takesNonNull((_nonnull) bar); // should not warn here (backward compatibility hack); anotherTakesNonNull(bar); // would be great to warn here, but not necessary(*). Because bar corresponds to the same symbol all the time it is not easy to implement the checker that way the cast only suppress the first call but not the second. For this reason in the first implementation after a contradictory cast happens, I will treat bar as nullable unspecified, this way all of the warnings will be suppressed. Treating the symbol as nullable unspecified also has an advantage that in case the takesNonNull function body is being inlined, the will be no warning, when the symbol is dereferenced. In case I have time after the initial version I might spend additional time to try to find a more sophisticated solution, in which we would produce the second warning (*). **2) nonnull**. * Dereferencing a nonnull, or sending message to it is ok.; * Converting nonnull to nullable is Ok.; * When there is an explicit cast from nonnull to nullable I will trust the cast (it is probable there for a reason, because this cast do",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/nullability.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/nullability.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst:670,Energy Efficiency,efficient,efficient,670,"============; Region Store; ============; The analyzer ""Store"" represents the contents of memory regions. It is an opaque; functional data structure stored in each ``ProgramState``; the only class that; can modify the store is its associated StoreManager. Currently (Feb. 2013), the only StoreManager implementation being used is; ``RegionStoreManager``. This store records bindings to memory regions using a; ""base region + offset"" key. (This allows ``*p`` and ``p[0]`` to map to the same; location, among other benefits.). Regions are grouped into ""clusters"", which roughly correspond to ""regions with; the same base region"". This allows certain operations to be more efficient,; such as invalidation. Regions that do not have a known offset use a special ""symbolic"" offset. These; keys store both the original region, and the ""concrete offset region"" -- the; last region whose offset is entirely concrete. (For example, in the expression; ``foo.bar[1][i].baz``, the concrete offset region is the array ``foo.bar[1]``,; since that has a known offset from the start of the top-level ``foo`` struct.). Binding Invalidation; --------------------. Supporting both concrete and symbolic offsets makes things a bit tricky. Here's; an example:. .. code-block:: cpp. foo[0] = 0;; foo[1] = 1;; foo[i] = i;. After the third assignment, nothing can be said about the value of ``foo[0]``,; because ``foo[i]`` may have overwritten it! Thus, *binding to a region with a; symbolic offset invalidates the entire concrete offset region.* We know; ``foo[i]`` is somewhere within ``foo``, so we don't have to invalidate; anything else, but we do have to be conservative about all other bindings within; ``foo``. Continuing the example:. .. code-block:: cpp. foo[i] = i;; foo[0] = 0;. After this latest assignment, nothing can be said about the value of ``foo[i]``,; because ``foo[0]`` may have overwritten it! *Binding to a region R with a; concrete offset invalidates any symbolic offset bindings whose concrete offse",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst:2681,Modifiability,variab,variables,2681,"`. Continuing the example:. .. code-block:: cpp. foo[i] = i;; foo[0] = 0;. After this latest assignment, nothing can be said about the value of ``foo[i]``,; because ``foo[0]`` may have overwritten it! *Binding to a region R with a; concrete offset invalidates any symbolic offset bindings whose concrete offset; region is a super-region **or** sub-region of R.* All we know about ``foo[i]``; is that it is somewhere within ``foo``, so changing *anything* within ``foo``; might change ``foo[i]``, and changing *all* of ``foo`` (or its base region) will; *definitely* change ``foo[i]``. This logic could be improved by using the current constraints on ``i``, at the; cost of speed. The latter case could also be improved by matching region kinds,; i.e. changing ``foo[0].a`` is unlikely to affect ``foo[i].b``, no matter what; ``i`` is. For more detail, read through ``RegionStoreManager::removeSubRegionBindings`` in; RegionStore.cpp. ObjCIvarRegions; ---------------. Objective-C instance variables require a bit of special handling. Like struct; fields, they are not base regions, and when their parent object region is; invalidated, all the instance variables must be invalidated as well. However,; they have no concrete compile-time offsets (in the modern, ""non-fragile""; runtime), and so cannot easily be represented as an offset from the start of; the object in the analyzer. Moreover, this means that invalidating a single; instance variable should *not* invalidate the rest of the object, since unlike; struct fields or array elements there is no way to perform pointer arithmetic; to access another instance variable. Consequently, although the base region of an ObjCIvarRegion is the entire; object, RegionStore offsets are computed from the start of the instance; variable. Thus it is not valid to assume that all bindings with non-symbolic; offsets start from the base region!. Region Invalidation; -------------------. Unlike binding invalidation, region invalidation occurs when the enti",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst:2844,Modifiability,variab,variables,2844,"g can be said about the value of ``foo[i]``,; because ``foo[0]`` may have overwritten it! *Binding to a region R with a; concrete offset invalidates any symbolic offset bindings whose concrete offset; region is a super-region **or** sub-region of R.* All we know about ``foo[i]``; is that it is somewhere within ``foo``, so changing *anything* within ``foo``; might change ``foo[i]``, and changing *all* of ``foo`` (or its base region) will; *definitely* change ``foo[i]``. This logic could be improved by using the current constraints on ``i``, at the; cost of speed. The latter case could also be improved by matching region kinds,; i.e. changing ``foo[0].a`` is unlikely to affect ``foo[i].b``, no matter what; ``i`` is. For more detail, read through ``RegionStoreManager::removeSubRegionBindings`` in; RegionStore.cpp. ObjCIvarRegions; ---------------. Objective-C instance variables require a bit of special handling. Like struct; fields, they are not base regions, and when their parent object region is; invalidated, all the instance variables must be invalidated as well. However,; they have no concrete compile-time offsets (in the modern, ""non-fragile""; runtime), and so cannot easily be represented as an offset from the start of; the object in the analyzer. Moreover, this means that invalidating a single; instance variable should *not* invalidate the rest of the object, since unlike; struct fields or array elements there is no way to perform pointer arithmetic; to access another instance variable. Consequently, although the base region of an ObjCIvarRegion is the entire; object, RegionStore offsets are computed from the start of the instance; variable. Thus it is not valid to assume that all bindings with non-symbolic; offsets start from the base region!. Region Invalidation; -------------------. Unlike binding invalidation, region invalidation occurs when the entire; contents of a region may have changed---say, because it has been passed to a; function the analyzer can mode",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst:3131,Modifiability,variab,variable,3131,"anging *all* of ``foo`` (or its base region) will; *definitely* change ``foo[i]``. This logic could be improved by using the current constraints on ``i``, at the; cost of speed. The latter case could also be improved by matching region kinds,; i.e. changing ``foo[0].a`` is unlikely to affect ``foo[i].b``, no matter what; ``i`` is. For more detail, read through ``RegionStoreManager::removeSubRegionBindings`` in; RegionStore.cpp. ObjCIvarRegions; ---------------. Objective-C instance variables require a bit of special handling. Like struct; fields, they are not base regions, and when their parent object region is; invalidated, all the instance variables must be invalidated as well. However,; they have no concrete compile-time offsets (in the modern, ""non-fragile""; runtime), and so cannot easily be represented as an offset from the start of; the object in the analyzer. Moreover, this means that invalidating a single; instance variable should *not* invalidate the rest of the object, since unlike; struct fields or array elements there is no way to perform pointer arithmetic; to access another instance variable. Consequently, although the base region of an ObjCIvarRegion is the entire; object, RegionStore offsets are computed from the start of the instance; variable. Thus it is not valid to assume that all bindings with non-symbolic; offsets start from the base region!. Region Invalidation; -------------------. Unlike binding invalidation, region invalidation occurs when the entire; contents of a region may have changed---say, because it has been passed to a; function the analyzer can model, like memcpy, or because its address has; escaped, usually as an argument to an opaque function call. In these cases we; need to throw away not just all bindings within the region itself, but within; its entire cluster, since neighboring regions may be accessed via pointer; arithmetic. Region invalidation typically does even more than this, however. Because it; usually represents the co",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst:3308,Modifiability,variab,variable,3308,"anging *all* of ``foo`` (or its base region) will; *definitely* change ``foo[i]``. This logic could be improved by using the current constraints on ``i``, at the; cost of speed. The latter case could also be improved by matching region kinds,; i.e. changing ``foo[0].a`` is unlikely to affect ``foo[i].b``, no matter what; ``i`` is. For more detail, read through ``RegionStoreManager::removeSubRegionBindings`` in; RegionStore.cpp. ObjCIvarRegions; ---------------. Objective-C instance variables require a bit of special handling. Like struct; fields, they are not base regions, and when their parent object region is; invalidated, all the instance variables must be invalidated as well. However,; they have no concrete compile-time offsets (in the modern, ""non-fragile""; runtime), and so cannot easily be represented as an offset from the start of; the object in the analyzer. Moreover, this means that invalidating a single; instance variable should *not* invalidate the rest of the object, since unlike; struct fields or array elements there is no way to perform pointer arithmetic; to access another instance variable. Consequently, although the base region of an ObjCIvarRegion is the entire; object, RegionStore offsets are computed from the start of the instance; variable. Thus it is not valid to assume that all bindings with non-symbolic; offsets start from the base region!. Region Invalidation; -------------------. Unlike binding invalidation, region invalidation occurs when the entire; contents of a region may have changed---say, because it has been passed to a; function the analyzer can model, like memcpy, or because its address has; escaped, usually as an argument to an opaque function call. In these cases we; need to throw away not just all bindings within the region itself, but within; its entire cluster, since neighboring regions may be accessed via pointer; arithmetic. Region invalidation typically does even more than this, however. Because it; usually represents the co",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst:3466,Modifiability,variab,variable,3466,"so be improved by matching region kinds,; i.e. changing ``foo[0].a`` is unlikely to affect ``foo[i].b``, no matter what; ``i`` is. For more detail, read through ``RegionStoreManager::removeSubRegionBindings`` in; RegionStore.cpp. ObjCIvarRegions; ---------------. Objective-C instance variables require a bit of special handling. Like struct; fields, they are not base regions, and when their parent object region is; invalidated, all the instance variables must be invalidated as well. However,; they have no concrete compile-time offsets (in the modern, ""non-fragile""; runtime), and so cannot easily be represented as an offset from the start of; the object in the analyzer. Moreover, this means that invalidating a single; instance variable should *not* invalidate the rest of the object, since unlike; struct fields or array elements there is no way to perform pointer arithmetic; to access another instance variable. Consequently, although the base region of an ObjCIvarRegion is the entire; object, RegionStore offsets are computed from the start of the instance; variable. Thus it is not valid to assume that all bindings with non-symbolic; offsets start from the base region!. Region Invalidation; -------------------. Unlike binding invalidation, region invalidation occurs when the entire; contents of a region may have changed---say, because it has been passed to a; function the analyzer can model, like memcpy, or because its address has; escaped, usually as an argument to an opaque function call. In these cases we; need to throw away not just all bindings within the region itself, but within; its entire cluster, since neighboring regions may be accessed via pointer; arithmetic. Region invalidation typically does even more than this, however. Because it; usually represents the complete escape of a region from the analyzer's model,; its *contents* must also be transitively invalidated. (For example, if a region; ``p`` of type ``int **`` is invalidated, the contents of ``*p`` an",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst:5760,Modifiability,variab,variables,5760," ""ClusterAnalysis"" predates the cluster-based organization of bindings, but; refers to the same concept: during invalidation and liveness analysis, all; bindings within a cluster must be treated in the same way for a conservative; model of program behavior. Default Bindings; ----------------. Most bindings in RegionStore are simple scalar values -- integers and pointers.; These are known as ""Direct"" bindings. However, RegionStore supports a second; type of binding called a ""Default"" binding. These are used to provide values to; all the elements of an aggregate type (struct or array) without having to; explicitly specify a binding for each individual element. When there is no Direct binding for a particular region, the store manager; looks at each super-region in turn to see if there is a Default binding. If so,; this value is used as the value of the original region. The search ends when; the base region is reached, at which point the RegionStore will pick an; appropriate default value for the region (usually a symbolic value, but; sometimes zero, for static data, or ""uninitialized"", for stack variables). .. code-block:: cpp. int manyInts[10];; manyInts[1] = 42; // Creates a Direct binding for manyInts[1].; print(manyInts[1]); // Retrieves the Direct binding for manyInts[1];; print(manyInts[0]); // There is no Direct binding for manyInts[0].; // Is there a Default binding for the entire array?; // There is not, but it is a stack variable, so we use; // ""uninitialized"" as the default value (and emit a; // diagnostic!). NOTE: The fact that bindings are stored as a base region plus an offset limits; the Default Binding strategy, because in C aggregates can contain other; aggregates. In the current implementation of RegionStore, there is no way to; distinguish a Default binding for an entire aggregate from a Default binding; for the sub-aggregate at offset 0. Lazy Bindings (LazyCompoundVal); -------------------------------. RegionStore implements an optimization for copy",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst:6102,Modifiability,variab,variable,6102,"type of binding called a ""Default"" binding. These are used to provide values to; all the elements of an aggregate type (struct or array) without having to; explicitly specify a binding for each individual element. When there is no Direct binding for a particular region, the store manager; looks at each super-region in turn to see if there is a Default binding. If so,; this value is used as the value of the original region. The search ends when; the base region is reached, at which point the RegionStore will pick an; appropriate default value for the region (usually a symbolic value, but; sometimes zero, for static data, or ""uninitialized"", for stack variables). .. code-block:: cpp. int manyInts[10];; manyInts[1] = 42; // Creates a Direct binding for manyInts[1].; print(manyInts[1]); // Retrieves the Direct binding for manyInts[1];; print(manyInts[0]); // There is no Direct binding for manyInts[0].; // Is there a Default binding for the entire array?; // There is not, but it is a stack variable, so we use; // ""uninitialized"" as the default value (and emit a; // diagnostic!). NOTE: The fact that bindings are stored as a base region plus an offset limits; the Default Binding strategy, because in C aggregates can contain other; aggregates. In the current implementation of RegionStore, there is no way to; distinguish a Default binding for an entire aggregate from a Default binding; for the sub-aggregate at offset 0. Lazy Bindings (LazyCompoundVal); -------------------------------. RegionStore implements an optimization for copying aggregates (structs and; arrays) called ""lazy bindings"", implemented using a special SVal called; LazyCompoundVal. When the store is asked for the ""binding"" for an entire; aggregate (i.e. for an lvalue-to-rvalue conversion), it returns a; LazyCompoundVal instead. When this value is then stored into a variable, it is; bound as a Default value. This makes copying arrays and structs much cheaper; than if they had required memberwise access. Under ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst:6956,Modifiability,variab,variable,6956,"nts[0]); // There is no Direct binding for manyInts[0].; // Is there a Default binding for the entire array?; // There is not, but it is a stack variable, so we use; // ""uninitialized"" as the default value (and emit a; // diagnostic!). NOTE: The fact that bindings are stored as a base region plus an offset limits; the Default Binding strategy, because in C aggregates can contain other; aggregates. In the current implementation of RegionStore, there is no way to; distinguish a Default binding for an entire aggregate from a Default binding; for the sub-aggregate at offset 0. Lazy Bindings (LazyCompoundVal); -------------------------------. RegionStore implements an optimization for copying aggregates (structs and; arrays) called ""lazy bindings"", implemented using a special SVal called; LazyCompoundVal. When the store is asked for the ""binding"" for an entire; aggregate (i.e. for an lvalue-to-rvalue conversion), it returns a; LazyCompoundVal instead. When this value is then stored into a variable, it is; bound as a Default value. This makes copying arrays and structs much cheaper; than if they had required memberwise access. Under the hood, a LazyCompoundVal is implemented as a uniqued pair of (region,; store), representing ""the value of the region during this 'snapshot' of the; store"". This has important implications for any sort of liveness or; reachability analysis, which must take the bindings in the old store into; account. Retrieving a value from a lazy binding happens in the same way as any other; Default binding: since there is no direct binding, the store manager falls back; to super-regions to look for an appropriate default binding. LazyCompoundVal; differs from a normal default binding, however, in that it contains several; different values, instead of one value that will appear several times. Because; of this, the store manager has to reconstruct the subregion chain on top of the; LazyCompoundVal region, and look up *that* region in the previous store. Here'",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst:3253,Performance,perform,perform,3253,"anging *all* of ``foo`` (or its base region) will; *definitely* change ``foo[i]``. This logic could be improved by using the current constraints on ``i``, at the; cost of speed. The latter case could also be improved by matching region kinds,; i.e. changing ``foo[0].a`` is unlikely to affect ``foo[i].b``, no matter what; ``i`` is. For more detail, read through ``RegionStoreManager::removeSubRegionBindings`` in; RegionStore.cpp. ObjCIvarRegions; ---------------. Objective-C instance variables require a bit of special handling. Like struct; fields, they are not base regions, and when their parent object region is; invalidated, all the instance variables must be invalidated as well. However,; they have no concrete compile-time offsets (in the modern, ""non-fragile""; runtime), and so cannot easily be represented as an offset from the start of; the object in the analyzer. Moreover, this means that invalidating a single; instance variable should *not* invalidate the rest of the object, since unlike; struct fields or array elements there is no way to perform pointer arithmetic; to access another instance variable. Consequently, although the base region of an ObjCIvarRegion is the entire; object, RegionStore offsets are computed from the start of the instance; variable. Thus it is not valid to assume that all bindings with non-symbolic; offsets start from the base region!. Region Invalidation; -------------------. Unlike binding invalidation, region invalidation occurs when the entire; contents of a region may have changed---say, because it has been passed to a; function the analyzer can model, like memcpy, or because its address has; escaped, usually as an argument to an opaque function call. In these cases we; need to throw away not just all bindings within the region itself, but within; its entire cluster, since neighboring regions may be accessed via pointer; arithmetic. Region invalidation typically does even more than this, however. Because it; usually represents the co",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst:6629,Performance,optimiz,optimization,6629,"value, but; sometimes zero, for static data, or ""uninitialized"", for stack variables). .. code-block:: cpp. int manyInts[10];; manyInts[1] = 42; // Creates a Direct binding for manyInts[1].; print(manyInts[1]); // Retrieves the Direct binding for manyInts[1];; print(manyInts[0]); // There is no Direct binding for manyInts[0].; // Is there a Default binding for the entire array?; // There is not, but it is a stack variable, so we use; // ""uninitialized"" as the default value (and emit a; // diagnostic!). NOTE: The fact that bindings are stored as a base region plus an offset limits; the Default Binding strategy, because in C aggregates can contain other; aggregates. In the current implementation of RegionStore, there is no way to; distinguish a Default binding for an entire aggregate from a Default binding; for the sub-aggregate at offset 0. Lazy Bindings (LazyCompoundVal); -------------------------------. RegionStore implements an optimization for copying aggregates (structs and; arrays) called ""lazy bindings"", implemented using a special SVal called; LazyCompoundVal. When the store is asked for the ""binding"" for an entire; aggregate (i.e. for an lvalue-to-rvalue conversion), it returns a; LazyCompoundVal instead. When this value is then stored into a variable, it is; bound as a Default value. This makes copying arrays and structs much cheaper; than if they had required memberwise access. Under the hood, a LazyCompoundVal is implemented as a uniqued pair of (region,; store), representing ""the value of the region during this 'snapshot' of the; store"". This has important implications for any sort of liveness or; reachability analysis, which must take the bindings in the old store into; account. Retrieving a value from a lazy binding happens in the same way as any other; Default binding: since there is no direct binding, the store manager falls back; to super-regions to look for an appropriate default binding. LazyCompoundVal; differs from a normal default binding, howe",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst:3284,Security,access,access,3284,"anging *all* of ``foo`` (or its base region) will; *definitely* change ``foo[i]``. This logic could be improved by using the current constraints on ``i``, at the; cost of speed. The latter case could also be improved by matching region kinds,; i.e. changing ``foo[0].a`` is unlikely to affect ``foo[i].b``, no matter what; ``i`` is. For more detail, read through ``RegionStoreManager::removeSubRegionBindings`` in; RegionStore.cpp. ObjCIvarRegions; ---------------. Objective-C instance variables require a bit of special handling. Like struct; fields, they are not base regions, and when their parent object region is; invalidated, all the instance variables must be invalidated as well. However,; they have no concrete compile-time offsets (in the modern, ""non-fragile""; runtime), and so cannot easily be represented as an offset from the start of; the object in the analyzer. Moreover, this means that invalidating a single; instance variable should *not* invalidate the rest of the object, since unlike; struct fields or array elements there is no way to perform pointer arithmetic; to access another instance variable. Consequently, although the base region of an ObjCIvarRegion is the entire; object, RegionStore offsets are computed from the start of the instance; variable. Thus it is not valid to assume that all bindings with non-symbolic; offsets start from the base region!. Region Invalidation; -------------------. Unlike binding invalidation, region invalidation occurs when the entire; contents of a region may have changed---say, because it has been passed to a; function the analyzer can model, like memcpy, or because its address has; escaped, usually as an argument to an opaque function call. In these cases we; need to throw away not just all bindings within the region itself, but within; its entire cluster, since neighboring regions may be accessed via pointer; arithmetic. Region invalidation typically does even more than this, however. Because it; usually represents the co",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst:4059,Security,access,accessed,4059,"e represented as an offset from the start of; the object in the analyzer. Moreover, this means that invalidating a single; instance variable should *not* invalidate the rest of the object, since unlike; struct fields or array elements there is no way to perform pointer arithmetic; to access another instance variable. Consequently, although the base region of an ObjCIvarRegion is the entire; object, RegionStore offsets are computed from the start of the instance; variable. Thus it is not valid to assume that all bindings with non-symbolic; offsets start from the base region!. Region Invalidation; -------------------. Unlike binding invalidation, region invalidation occurs when the entire; contents of a region may have changed---say, because it has been passed to a; function the analyzer can model, like memcpy, or because its address has; escaped, usually as an argument to an opaque function call. In these cases we; need to throw away not just all bindings within the region itself, but within; its entire cluster, since neighboring regions may be accessed via pointer; arithmetic. Region invalidation typically does even more than this, however. Because it; usually represents the complete escape of a region from the analyzer's model,; its *contents* must also be transitively invalidated. (For example, if a region; ``p`` of type ``int **`` is invalidated, the contents of ``*p`` and ``**p`` may; have changed as well.) The algorithm that traverses this transitive closure of; accessible regions is known as ClusterAnalysis, and is also used for finding; all live bindings in the store (in order to throw away the dead ones). The name; ""ClusterAnalysis"" predates the cluster-based organization of bindings, but; refers to the same concept: during invalidation and liveness analysis, all; bindings within a cluster must be treated in the same way for a conservative; model of program behavior. Default Bindings; ----------------. Most bindings in RegionStore are simple scalar values -- ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst:4491,Security,access,accessible,4491,"ymbolic; offsets start from the base region!. Region Invalidation; -------------------. Unlike binding invalidation, region invalidation occurs when the entire; contents of a region may have changed---say, because it has been passed to a; function the analyzer can model, like memcpy, or because its address has; escaped, usually as an argument to an opaque function call. In these cases we; need to throw away not just all bindings within the region itself, but within; its entire cluster, since neighboring regions may be accessed via pointer; arithmetic. Region invalidation typically does even more than this, however. Because it; usually represents the complete escape of a region from the analyzer's model,; its *contents* must also be transitively invalidated. (For example, if a region; ``p`` of type ``int **`` is invalidated, the contents of ``*p`` and ``**p`` may; have changed as well.) The algorithm that traverses this transitive closure of; accessible regions is known as ClusterAnalysis, and is also used for finding; all live bindings in the store (in order to throw away the dead ones). The name; ""ClusterAnalysis"" predates the cluster-based organization of bindings, but; refers to the same concept: during invalidation and liveness analysis, all; bindings within a cluster must be treated in the same way for a conservative; model of program behavior. Default Bindings; ----------------. Most bindings in RegionStore are simple scalar values -- integers and pointers.; These are known as ""Direct"" bindings. However, RegionStore supports a second; type of binding called a ""Default"" binding. These are used to provide values to; all the elements of an aggregate type (struct or array) without having to; explicitly specify a binding for each individual element. When there is no Direct binding for a particular region, the store manager; looks at each super-region in turn to see if there is a Default binding. If so,; this value is used as the value of the original region. The sea",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst:7088,Security,access,access,7088,"r the entire array?; // There is not, but it is a stack variable, so we use; // ""uninitialized"" as the default value (and emit a; // diagnostic!). NOTE: The fact that bindings are stored as a base region plus an offset limits; the Default Binding strategy, because in C aggregates can contain other; aggregates. In the current implementation of RegionStore, there is no way to; distinguish a Default binding for an entire aggregate from a Default binding; for the sub-aggregate at offset 0. Lazy Bindings (LazyCompoundVal); -------------------------------. RegionStore implements an optimization for copying aggregates (structs and; arrays) called ""lazy bindings"", implemented using a special SVal called; LazyCompoundVal. When the store is asked for the ""binding"" for an entire; aggregate (i.e. for an lvalue-to-rvalue conversion), it returns a; LazyCompoundVal instead. When this value is then stored into a variable, it is; bound as a Default value. This makes copying arrays and structs much cheaper; than if they had required memberwise access. Under the hood, a LazyCompoundVal is implemented as a uniqued pair of (region,; store), representing ""the value of the region during this 'snapshot' of the; store"". This has important implications for any sort of liveness or; reachability analysis, which must take the bindings in the old store into; account. Retrieving a value from a lazy binding happens in the same way as any other; Default binding: since there is no direct binding, the store manager falls back; to super-regions to look for an appropriate default binding. LazyCompoundVal; differs from a normal default binding, however, in that it contains several; different values, instead of one value that will appear several times. Because; of this, the store manager has to reconstruct the subregion chain on top of the; LazyCompoundVal region, and look up *that* region in the previous store. Here's a concrete example:. .. code-block:: cpp. CGPoint p;; p.x = 42; // A Direct binding is ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst:2282,Testability,log,logic,2282,"ent, nothing can be said about the value of ``foo[0]``,; because ``foo[i]`` may have overwritten it! Thus, *binding to a region with a; symbolic offset invalidates the entire concrete offset region.* We know; ``foo[i]`` is somewhere within ``foo``, so we don't have to invalidate; anything else, but we do have to be conservative about all other bindings within; ``foo``. Continuing the example:. .. code-block:: cpp. foo[i] = i;; foo[0] = 0;. After this latest assignment, nothing can be said about the value of ``foo[i]``,; because ``foo[0]`` may have overwritten it! *Binding to a region R with a; concrete offset invalidates any symbolic offset bindings whose concrete offset; region is a super-region **or** sub-region of R.* All we know about ``foo[i]``; is that it is somewhere within ``foo``, so changing *anything* within ``foo``; might change ``foo[i]``, and changing *all* of ``foo`` (or its base region) will; *definitely* change ``foo[i]``. This logic could be improved by using the current constraints on ``i``, at the; cost of speed. The latter case could also be improved by matching region kinds,; i.e. changing ``foo[0].a`` is unlikely to affect ``foo[i].b``, no matter what; ``i`` is. For more detail, read through ``RegionStoreManager::removeSubRegionBindings`` in; RegionStore.cpp. ObjCIvarRegions; ---------------. Objective-C instance variables require a bit of special handling. Like struct; fields, they are not base regions, and when their parent object region is; invalidated, all the instance variables must be invalidated as well. However,; they have no concrete compile-time offsets (in the modern, ""non-fragile""; runtime), and so cannot easily be represented as an offset from the start of; the object in the analyzer. Moreover, this means that invalidating a single; instance variable should *not* invalidate the rest of the object, since unlike; struct fields or array elements there is no way to perform pointer arithmetic; to access another instance variable. Conseq",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst:4976,Usability,simpl,simple,4976,"ion itself, but within; its entire cluster, since neighboring regions may be accessed via pointer; arithmetic. Region invalidation typically does even more than this, however. Because it; usually represents the complete escape of a region from the analyzer's model,; its *contents* must also be transitively invalidated. (For example, if a region; ``p`` of type ``int **`` is invalidated, the contents of ``*p`` and ``**p`` may; have changed as well.) The algorithm that traverses this transitive closure of; accessible regions is known as ClusterAnalysis, and is also used for finding; all live bindings in the store (in order to throw away the dead ones). The name; ""ClusterAnalysis"" predates the cluster-based organization of bindings, but; refers to the same concept: during invalidation and liveness analysis, all; bindings within a cluster must be treated in the same way for a conservative; model of program behavior. Default Bindings; ----------------. Most bindings in RegionStore are simple scalar values -- integers and pointers.; These are known as ""Direct"" bindings. However, RegionStore supports a second; type of binding called a ""Default"" binding. These are used to provide values to; all the elements of an aggregate type (struct or array) without having to; explicitly specify a binding for each individual element. When there is no Direct binding for a particular region, the store manager; looks at each super-region in turn to see if there is a Default binding. If so,; this value is used as the value of the original region. The search ends when; the base region is reached, at which point the RegionStore will pick an; appropriate default value for the region (usually a symbolic value, but; sometimes zero, for static data, or ""uninitialized"", for stack variables). .. code-block:: cpp. int manyInts[10];; manyInts[1] = 42; // Creates a Direct binding for manyInts[1].; print(manyInts[1]); // Retrieves the Direct binding for manyInts[1];; print(manyInts[0]); // There is no D",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/developer-docs/RegionStore.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst:3412,Availability,avail,available,3412,"ition of `foo` from `foo.cpp` first we have to generate the `AST` (or `PCH`) file; of `foo.cpp`:. .. code-block:: bash. $ pwd $ /path/to/your/project; $ clang++ -emit-ast -o foo.cpp.ast foo.cpp; $ # Check that the .ast file is generated:; $ ls; compile_commands.json foo.cpp.ast foo.cpp main.cpp; $. The next step is to create a CTU index file which holds the `USR` name and location of external definitions in the; source files in format `<USR-Length>:<USR> <File-Path>`:. .. code-block:: bash. $ clang-extdef-mapping -p . foo.cpp; 9:c:@F@foo# /path/to/your/project/foo.cpp; $ clang-extdef-mapping -p . foo.cpp > externalDefMap.txt. We have to modify `externalDefMap.txt` to contain the name of the `.ast` files instead of the source files:. .. code-block:: bash. $ sed -i -e ""s/.cpp/.cpp.ast/g"" externalDefMap.txt. We still have to further modify the `externalDefMap.txt` file to contain relative paths:. .. code-block:: bash. $ sed -i -e ""s|$(pwd)/||g"" externalDefMap.txt. Now everything is available for the CTU analysis.; We have to feed Clang with CTU specific extra arguments:. .. code-block:: bash. $ pwd; /path/to/your/project; $ clang++ --analyze \; -Xclang -analyzer-config -Xclang experimental-enable-naive-ctu-analysis=true \; -Xclang -analyzer-config -Xclang ctu-dir=. \; -Xclang -analyzer-output=plist-multi-file \; main.cpp; main.cpp:5:12: warning: Division by zero; return 3 / foo();; ~~^~~~~~~; 1 warning generated.; $ # The plist file with the result is generated.; $ ls -F; compile_commands.json externalDefMap.txt foo.ast foo.cpp foo.cpp.ast main.cpp main.plist; $. This manual procedure is error-prone and not scalable, therefore to analyze real projects it is recommended to use; `CodeChecker` or `scan-build-py`. Automated CTU Analysis with CodeChecker; #######################################; The `CodeChecker <https://github.com/Ericsson/codechecker>`_ project fully supports automated CTU analysis with Clang.; Once we have set up the `PATH` environment variable and we ac",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst:4030,Availability,error,error-prone,4030,"DefMap.txt` to contain the name of the `.ast` files instead of the source files:. .. code-block:: bash. $ sed -i -e ""s/.cpp/.cpp.ast/g"" externalDefMap.txt. We still have to further modify the `externalDefMap.txt` file to contain relative paths:. .. code-block:: bash. $ sed -i -e ""s|$(pwd)/||g"" externalDefMap.txt. Now everything is available for the CTU analysis.; We have to feed Clang with CTU specific extra arguments:. .. code-block:: bash. $ pwd; /path/to/your/project; $ clang++ --analyze \; -Xclang -analyzer-config -Xclang experimental-enable-naive-ctu-analysis=true \; -Xclang -analyzer-config -Xclang ctu-dir=. \; -Xclang -analyzer-output=plist-multi-file \; main.cpp; main.cpp:5:12: warning: Division by zero; return 3 / foo();; ~~^~~~~~~; 1 warning generated.; $ # The plist file with the result is generated.; $ ls -F; compile_commands.json externalDefMap.txt foo.ast foo.cpp foo.cpp.ast main.cpp main.plist; $. This manual procedure is error-prone and not scalable, therefore to analyze real projects it is recommended to use; `CodeChecker` or `scan-build-py`. Automated CTU Analysis with CodeChecker; #######################################; The `CodeChecker <https://github.com/Ericsson/codechecker>`_ project fully supports automated CTU analysis with Clang.; Once we have set up the `PATH` environment variable and we activated the python `venv` then it is all it takes:. .. code-block:: bash. $ CodeChecker analyze --ctu compile_commands.json -o reports; $ ls -F; compile_commands.json foo.cpp foo.cpp.ast main.cpp reports/; $ tree reports; reports; ├── compile_cmd.json; ├── compiler_info.json; ├── foo.cpp_53f6fbf7ab7ec9931301524b551959e2.plist; ├── main.cpp_23db3d8df52ff0812e6e5a03071c8337.plist; ├── metadata.json; └── unique_compile_commands.json. 0 directories, 6 files; $. The `plist` files contain the results of the analysis, which may be viewed with the regular analysis tools.; E.g. one may use `CodeChecker parse` to view the results in command line:. .. code-block::",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst:6052,Availability,error,errors,6052,"ck:: bash. $ CodeChecker parse reports; [HIGH] /home/egbomrt/ctu_mini_raw_project/main.cpp:5:12: Division by zero [core.DivideZero]; return 3 / foo();; ^. Found 1 defect(s) in main.cpp. ----==== Summary ====----; -----------------------; Filename | Report count; -----------------------; main.cpp | 1; -----------------------; -----------------------; Severity | Report count; -----------------------; HIGH | 1; -----------------------; ----=================----; Total number of reports: 1; ----=================----. Or we can use `CodeChecker parse -e html` to export the results into HTML format:. .. code-block:: bash. $ CodeChecker parse -e html -o html_out reports; $ firefox html_out/index.html. Automated CTU Analysis with scan-build-py (don't do it); #############################################################; We actively develop CTU with CodeChecker as the driver for this feature, `scan-build-py` is not actively developed for CTU.; `scan-build-py` has various errors and issues, expect it to work only with the very basic projects only. Example usage of scan-build-py:. .. code-block:: bash. $ /your/path/to/llvm-project/clang/tools/scan-build-py/bin/analyze-build --ctu; analyze-build: Run 'scan-view /tmp/scan-build-2019-07-17-17-53-33-810365-7fqgWk' to examine bug reports.; $ /your/path/to/llvm-project/clang/tools/scan-view/bin/scan-view /tmp/scan-build-2019-07-17-17-53-33-810365-7fqgWk; Starting scan-view at: http://127.0.0.1:8181; Use Ctrl-C to exit.; [6336:6431:0717/175357.633914:ERROR:browser_process_sub_thread.cc(209)] Waited 5 ms for network service; Opening in existing browser session.; ^C; $. .. _ctu-on-demand:. On-demand analysis; __________________; The analysis produces the necessary AST structure of external TUs during analysis. This requires the; exact compiler invocations for each TU, which can be generated by hand, or by tools driving the analyzer.; The compiler invocation is a shell command that could be used to compile the TU-s main source file.; Th",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst:9200,Availability,avail,available,9200," bash. [; {; ""directory"": ""/path/to/your/project"",; ""command"": ""clang++ -c foo.cpp -o foo.o"",; ""file"": ""foo.cpp""; },; {; ""directory"": ""/path/to/your/project"",; ""command"": ""clang++ -c main.cpp -o main.o"",; ""file"": ""main.cpp""; }; ]. The `invocation list`:. .. code-block:: bash. ""/path/to/your/project/foo.cpp"":; - ""clang++""; - ""-c""; - ""/path/to/your/project/foo.cpp""; - ""-o""; - ""/path/to/your/project/foo.o"". ""/path/to/your/project/main.cpp"":; - ""clang++""; - ""-c""; - ""/path/to/your/project/main.cpp""; - ""-o""; - ""/path/to/your/project/main.o"". We'd like to analyze `main.cpp` and discover the division by zero bug.; As we are using On-demand mode, we only need to create a CTU index file which holds the `USR` name and location of; external definitions in the source files in format `<USR-Length>:<USR> <File-Path>`:. .. code-block:: bash. $ clang-extdef-mapping -p . foo.cpp; 9:c:@F@foo# /path/to/your/project/foo.cpp; $ clang-extdef-mapping -p . foo.cpp > externalDefMap.txt. Now everything is available for the CTU analysis.; We have to feed Clang with CTU specific extra arguments:. .. code-block:: bash. $ pwd; /path/to/your/project; $ clang++ --analyze \; -Xclang -analyzer-config -Xclang experimental-enable-naive-ctu-analysis=true \; -Xclang -analyzer-config -Xclang ctu-dir=. \; -Xclang -analyzer-config -Xclang ctu-invocation-list=invocations.yaml \; -Xclang -analyzer-output=plist-multi-file \; main.cpp; main.cpp:5:12: warning: Division by zero; return 3 / foo();; ~~^~~~~~~; 1 warning generated.; $ # The plist file with the result is generated.; $ ls -F; compile_commands.json externalDefMap.txt foo.cpp main.cpp main.plist; $. This manual procedure is error-prone and not scalable, therefore to analyze real projects it is recommended to use; `CodeChecker` or `scan-build-py`. Automated CTU Analysis with CodeChecker; #######################################; The `CodeChecker <https://github.com/Ericsson/codechecker>`_ project fully supports automated CTU analysis with Clang.; Once we ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst:9871,Availability,error,error-prone,9871,"nd location of; external definitions in the source files in format `<USR-Length>:<USR> <File-Path>`:. .. code-block:: bash. $ clang-extdef-mapping -p . foo.cpp; 9:c:@F@foo# /path/to/your/project/foo.cpp; $ clang-extdef-mapping -p . foo.cpp > externalDefMap.txt. Now everything is available for the CTU analysis.; We have to feed Clang with CTU specific extra arguments:. .. code-block:: bash. $ pwd; /path/to/your/project; $ clang++ --analyze \; -Xclang -analyzer-config -Xclang experimental-enable-naive-ctu-analysis=true \; -Xclang -analyzer-config -Xclang ctu-dir=. \; -Xclang -analyzer-config -Xclang ctu-invocation-list=invocations.yaml \; -Xclang -analyzer-output=plist-multi-file \; main.cpp; main.cpp:5:12: warning: Division by zero; return 3 / foo();; ~~^~~~~~~; 1 warning generated.; $ # The plist file with the result is generated.; $ ls -F; compile_commands.json externalDefMap.txt foo.cpp main.cpp main.plist; $. This manual procedure is error-prone and not scalable, therefore to analyze real projects it is recommended to use; `CodeChecker` or `scan-build-py`. Automated CTU Analysis with CodeChecker; #######################################; The `CodeChecker <https://github.com/Ericsson/codechecker>`_ project fully supports automated CTU analysis with Clang.; Once we have set up the `PATH` environment variable and we activated the python `venv` then it is all it takes:. .. code-block:: bash. $ CodeChecker analyze --ctu --ctu-ast-loading-mode on-demand compile_commands.json -o reports; $ ls -F; compile_commands.json foo.cpp main.cpp reports/; $ tree reports; reports; ├── compile_cmd.json; ├── compiler_info.json; ├── foo.cpp_53f6fbf7ab7ec9931301524b551959e2.plist; ├── main.cpp_23db3d8df52ff0812e6e5a03071c8337.plist; ├── metadata.json; └── unique_compile_commands.json. 0 directories, 6 files; $. The `plist` files contain the results of the analysis, which may be viewed with the regular analysis tools.; E.g. one may use `CodeChecker parse` to view the results in command l",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst:11903,Availability,error,errors,11903,"###########################; The `CodeChecker <https://github.com/Ericsson/codechecker>`_ project fully supports automated CTU analysis with Clang.; Once we have set up the `PATH` environment variable and we activated the python `venv` then it is all it takes:. .. code-block:: bash. $ CodeChecker analyze --ctu --ctu-ast-loading-mode on-demand compile_commands.json -o reports; $ ls -F; compile_commands.json foo.cpp main.cpp reports/; $ tree reports; reports; ├── compile_cmd.json; ├── compiler_info.json; ├── foo.cpp_53f6fbf7ab7ec9931301524b551959e2.plist; ├── main.cpp_23db3d8df52ff0812e6e5a03071c8337.plist; ├── metadata.json; └── unique_compile_commands.json. 0 directories, 6 files; $. The `plist` files contain the results of the analysis, which may be viewed with the regular analysis tools.; E.g. one may use `CodeChecker parse` to view the results in command line:. .. code-block:: bash. $ CodeChecker parse reports; [HIGH] /home/egbomrt/ctu_mini_raw_project/main.cpp:5:12: Division by zero [core.DivideZero]; return 3 / foo();; ^. Found 1 defect(s) in main.cpp. ----==== Summary ====----; -----------------------; Filename | Report count; -----------------------; main.cpp | 1; -----------------------; -----------------------; Severity | Report count; -----------------------; HIGH | 1; -----------------------; ----=================----; Total number of reports: 1; ----=================----. Or we can use `CodeChecker parse -e html` to export the results into HTML format:. .. code-block:: bash. $ CodeChecker parse -e html -o html_out reports; $ firefox html_out/index.html. Automated CTU Analysis with scan-build-py (don't do it); #######################################################; We actively develop CTU with CodeChecker as the driver for feature, `scan-build-py` is not actively developed for CTU.; `scan-build-py` has various errors and issues, expect it to work only with the very basic projects only. Currently On-demand analysis is not supported with `scan-build-py`.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst:231,Deployability,configurat,configuration,231,"=====================================; Cross Translation Unit (CTU) Analysis; =====================================. Normally, static analysis works in the boundary of one translation unit (TU).; However, with additional steps and configuration we can enable the analysis to inline the definition of a function from; another TU. .. contents::; :local:. Overview; ________; CTU analysis can be used in a variety of ways. The importing of external TU definitions can work with pre-dumped PCH; files or generating the necessary AST structure on-demand, during the analysis of the main TU. Driving the static; analysis can also be implemented in multiple ways. The most direct way is to specify the necessary commandline options; of the Clang frontend manually (and generate the prerequisite dependencies of the specific import method by hand). This; process can be automated by other tools, like `CodeChecker <https://github.com/Ericsson/codechecker>`_ and scan-build-py; (preference for the former). PCH-based analysis; __________________; The analysis needs the PCH dumps of all the translations units used in the project.; These can be generated by the Clang Frontend itself, and must be arranged in a specific way in the filesystem.; The index, which maps symbols' USR names to PCH dumps containing them must also be generated by the; `clang-extdef-mapping`. Entries in the index *must* have an `.ast` suffix if the goal; is to use PCH-based analysis, as the lack of that extension signals that the entry is to be used as a source-file, and parsed on-demand.; This tool uses a :doc:`compilation database <../../JSONCompilationDatabase>` to; determine the compilation flags used.; The analysis invocation must be provided with the directory which contains the dumps and the mapping files. Manual CTU Analysis; ###################; Let's consider these source files in our minimal example:. .. code-block:: cpp. // main.cpp; int foo();. int main() {; return 3 / foo();; }. .. code-block:: cpp. // foo.c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst:788,Integrability,depend,dependencies,788,"=====================================; Cross Translation Unit (CTU) Analysis; =====================================. Normally, static analysis works in the boundary of one translation unit (TU).; However, with additional steps and configuration we can enable the analysis to inline the definition of a function from; another TU. .. contents::; :local:. Overview; ________; CTU analysis can be used in a variety of ways. The importing of external TU definitions can work with pre-dumped PCH; files or generating the necessary AST structure on-demand, during the analysis of the main TU. Driving the static; analysis can also be implemented in multiple ways. The most direct way is to specify the necessary commandline options; of the Clang frontend manually (and generate the prerequisite dependencies of the specific import method by hand). This; process can be automated by other tools, like `CodeChecker <https://github.com/Ericsson/codechecker>`_ and scan-build-py; (preference for the former). PCH-based analysis; __________________; The analysis needs the PCH dumps of all the translations units used in the project.; These can be generated by the Clang Frontend itself, and must be arranged in a specific way in the filesystem.; The index, which maps symbols' USR names to PCH dumps containing them must also be generated by the; `clang-extdef-mapping`. Entries in the index *must* have an `.ast` suffix if the goal; is to use PCH-based analysis, as the lack of that extension signals that the entry is to be used as a source-file, and parsed on-demand.; This tool uses a :doc:`compilation database <../../JSONCompilationDatabase>` to; determine the compilation flags used.; The analysis invocation must be provided with the directory which contains the dumps and the mapping files. Manual CTU Analysis; ###################; Let's consider these source files in our minimal example:. .. code-block:: cpp. // main.cpp; int foo();. int main() {; return 3 / foo();; }. .. code-block:: cpp. // foo.c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst:231,Modifiability,config,configuration,231,"=====================================; Cross Translation Unit (CTU) Analysis; =====================================. Normally, static analysis works in the boundary of one translation unit (TU).; However, with additional steps and configuration we can enable the analysis to inline the definition of a function from; another TU. .. contents::; :local:. Overview; ________; CTU analysis can be used in a variety of ways. The importing of external TU definitions can work with pre-dumped PCH; files or generating the necessary AST structure on-demand, during the analysis of the main TU. Driving the static; analysis can also be implemented in multiple ways. The most direct way is to specify the necessary commandline options; of the Clang frontend manually (and generate the prerequisite dependencies of the specific import method by hand). This; process can be automated by other tools, like `CodeChecker <https://github.com/Ericsson/codechecker>`_ and scan-build-py; (preference for the former). PCH-based analysis; __________________; The analysis needs the PCH dumps of all the translations units used in the project.; These can be generated by the Clang Frontend itself, and must be arranged in a specific way in the filesystem.; The index, which maps symbols' USR names to PCH dumps containing them must also be generated by the; `clang-extdef-mapping`. Entries in the index *must* have an `.ast` suffix if the goal; is to use PCH-based analysis, as the lack of that extension signals that the entry is to be used as a source-file, and parsed on-demand.; This tool uses a :doc:`compilation database <../../JSONCompilationDatabase>` to; determine the compilation flags used.; The analysis invocation must be provided with the directory which contains the dumps and the mapping files. Manual CTU Analysis; ###################; Let's consider these source files in our minimal example:. .. code-block:: cpp. // main.cpp; int foo();. int main() {; return 3 / foo();; }. .. code-block:: cpp. // foo.c",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst:3596,Modifiability,config,config,3596," $ # Check that the .ast file is generated:; $ ls; compile_commands.json foo.cpp.ast foo.cpp main.cpp; $. The next step is to create a CTU index file which holds the `USR` name and location of external definitions in the; source files in format `<USR-Length>:<USR> <File-Path>`:. .. code-block:: bash. $ clang-extdef-mapping -p . foo.cpp; 9:c:@F@foo# /path/to/your/project/foo.cpp; $ clang-extdef-mapping -p . foo.cpp > externalDefMap.txt. We have to modify `externalDefMap.txt` to contain the name of the `.ast` files instead of the source files:. .. code-block:: bash. $ sed -i -e ""s/.cpp/.cpp.ast/g"" externalDefMap.txt. We still have to further modify the `externalDefMap.txt` file to contain relative paths:. .. code-block:: bash. $ sed -i -e ""s|$(pwd)/||g"" externalDefMap.txt. Now everything is available for the CTU analysis.; We have to feed Clang with CTU specific extra arguments:. .. code-block:: bash. $ pwd; /path/to/your/project; $ clang++ --analyze \; -Xclang -analyzer-config -Xclang experimental-enable-naive-ctu-analysis=true \; -Xclang -analyzer-config -Xclang ctu-dir=. \; -Xclang -analyzer-output=plist-multi-file \; main.cpp; main.cpp:5:12: warning: Division by zero; return 3 / foo();; ~~^~~~~~~; 1 warning generated.; $ # The plist file with the result is generated.; $ ls -F; compile_commands.json externalDefMap.txt foo.ast foo.cpp foo.cpp.ast main.cpp main.plist; $. This manual procedure is error-prone and not scalable, therefore to analyze real projects it is recommended to use; `CodeChecker` or `scan-build-py`. Automated CTU Analysis with CodeChecker; #######################################; The `CodeChecker <https://github.com/Ericsson/codechecker>`_ project fully supports automated CTU analysis with Clang.; Once we have set up the `PATH` environment variable and we activated the python `venv` then it is all it takes:. .. code-block:: bash. $ CodeChecker analyze --ctu compile_commands.json -o reports; $ ls -F; compile_commands.json foo.cpp foo.cpp.ast main.cp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst:3676,Modifiability,config,config,3676," $ # Check that the .ast file is generated:; $ ls; compile_commands.json foo.cpp.ast foo.cpp main.cpp; $. The next step is to create a CTU index file which holds the `USR` name and location of external definitions in the; source files in format `<USR-Length>:<USR> <File-Path>`:. .. code-block:: bash. $ clang-extdef-mapping -p . foo.cpp; 9:c:@F@foo# /path/to/your/project/foo.cpp; $ clang-extdef-mapping -p . foo.cpp > externalDefMap.txt. We have to modify `externalDefMap.txt` to contain the name of the `.ast` files instead of the source files:. .. code-block:: bash. $ sed -i -e ""s/.cpp/.cpp.ast/g"" externalDefMap.txt. We still have to further modify the `externalDefMap.txt` file to contain relative paths:. .. code-block:: bash. $ sed -i -e ""s|$(pwd)/||g"" externalDefMap.txt. Now everything is available for the CTU analysis.; We have to feed Clang with CTU specific extra arguments:. .. code-block:: bash. $ pwd; /path/to/your/project; $ clang++ --analyze \; -Xclang -analyzer-config -Xclang experimental-enable-naive-ctu-analysis=true \; -Xclang -analyzer-config -Xclang ctu-dir=. \; -Xclang -analyzer-output=plist-multi-file \; main.cpp; main.cpp:5:12: warning: Division by zero; return 3 / foo();; ~~^~~~~~~; 1 warning generated.; $ # The plist file with the result is generated.; $ ls -F; compile_commands.json externalDefMap.txt foo.ast foo.cpp foo.cpp.ast main.cpp main.plist; $. This manual procedure is error-prone and not scalable, therefore to analyze real projects it is recommended to use; `CodeChecker` or `scan-build-py`. Automated CTU Analysis with CodeChecker; #######################################; The `CodeChecker <https://github.com/Ericsson/codechecker>`_ project fully supports automated CTU analysis with Clang.; Once we have set up the `PATH` environment variable and we activated the python `venv` then it is all it takes:. .. code-block:: bash. $ CodeChecker analyze --ctu compile_commands.json -o reports; $ ls -F; compile_commands.json foo.cpp foo.cpp.ast main.cp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst:4400,Modifiability,variab,variable,4400,"available for the CTU analysis.; We have to feed Clang with CTU specific extra arguments:. .. code-block:: bash. $ pwd; /path/to/your/project; $ clang++ --analyze \; -Xclang -analyzer-config -Xclang experimental-enable-naive-ctu-analysis=true \; -Xclang -analyzer-config -Xclang ctu-dir=. \; -Xclang -analyzer-output=plist-multi-file \; main.cpp; main.cpp:5:12: warning: Division by zero; return 3 / foo();; ~~^~~~~~~; 1 warning generated.; $ # The plist file with the result is generated.; $ ls -F; compile_commands.json externalDefMap.txt foo.ast foo.cpp foo.cpp.ast main.cpp main.plist; $. This manual procedure is error-prone and not scalable, therefore to analyze real projects it is recommended to use; `CodeChecker` or `scan-build-py`. Automated CTU Analysis with CodeChecker; #######################################; The `CodeChecker <https://github.com/Ericsson/codechecker>`_ project fully supports automated CTU analysis with Clang.; Once we have set up the `PATH` environment variable and we activated the python `venv` then it is all it takes:. .. code-block:: bash. $ CodeChecker analyze --ctu compile_commands.json -o reports; $ ls -F; compile_commands.json foo.cpp foo.cpp.ast main.cpp reports/; $ tree reports; reports; ├── compile_cmd.json; ├── compiler_info.json; ├── foo.cpp_53f6fbf7ab7ec9931301524b551959e2.plist; ├── main.cpp_23db3d8df52ff0812e6e5a03071c8337.plist; ├── metadata.json; └── unique_compile_commands.json. 0 directories, 6 files; $. The `plist` files contain the results of the analysis, which may be viewed with the regular analysis tools.; E.g. one may use `CodeChecker parse` to view the results in command line:. .. code-block:: bash. $ CodeChecker parse reports; [HIGH] /home/egbomrt/ctu_mini_raw_project/main.cpp:5:12: Division by zero [core.DivideZero]; return 3 / foo();; ^. Found 1 defect(s) in main.cpp. ----==== Summary ====----; -----------------------; Filename | Report count; -----------------------; main.cpp | 1; -----------------------; ----------",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst:7285,Modifiability,config,config,7285,"/your/path/to/llvm-project/clang/tools/scan-build-py/bin/analyze-build --ctu; analyze-build: Run 'scan-view /tmp/scan-build-2019-07-17-17-53-33-810365-7fqgWk' to examine bug reports.; $ /your/path/to/llvm-project/clang/tools/scan-view/bin/scan-view /tmp/scan-build-2019-07-17-17-53-33-810365-7fqgWk; Starting scan-view at: http://127.0.0.1:8181; Use Ctrl-C to exit.; [6336:6431:0717/175357.633914:ERROR:browser_process_sub_thread.cc(209)] Waited 5 ms for network service; Opening in existing browser session.; ^C; $. .. _ctu-on-demand:. On-demand analysis; __________________; The analysis produces the necessary AST structure of external TUs during analysis. This requires the; exact compiler invocations for each TU, which can be generated by hand, or by tools driving the analyzer.; The compiler invocation is a shell command that could be used to compile the TU-s main source file.; The mapping from absolute source file paths of a TU to lists of compilation command segments used to; compile said TU are given in YAML format referred to as `invocation list`, and must be passed as an; analyzer-config argument.; The index, which maps function USR names to source files containing them must also be generated by the; `clang-extdef-mapping`. Entries in the index must *not* have an `.ast` suffix if the goal; is to use On-demand analysis, as that extension signals that the entry is to be used as an PCH-dump.; The mapping of external definitions implicitly uses a; :doc:`compilation database <../../JSONCompilationDatabase>` to determine the compilation flags used.; The analysis invocation must be provided with the directory which contains the mapping; files, and the `invocation list` which is used to determine compiler flags. Manual CTU Analysis; ###################. Let's consider these source files in our minimal example:. .. code-block:: cpp. // main.cpp; int foo();. int main() {; return 3 / foo();; }. .. code-block:: cpp. // foo.cpp; int foo() {; return 0;; }. The compilation databa",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst:9384,Modifiability,config,config,9384," main.o"",; ""file"": ""main.cpp""; }; ]. The `invocation list`:. .. code-block:: bash. ""/path/to/your/project/foo.cpp"":; - ""clang++""; - ""-c""; - ""/path/to/your/project/foo.cpp""; - ""-o""; - ""/path/to/your/project/foo.o"". ""/path/to/your/project/main.cpp"":; - ""clang++""; - ""-c""; - ""/path/to/your/project/main.cpp""; - ""-o""; - ""/path/to/your/project/main.o"". We'd like to analyze `main.cpp` and discover the division by zero bug.; As we are using On-demand mode, we only need to create a CTU index file which holds the `USR` name and location of; external definitions in the source files in format `<USR-Length>:<USR> <File-Path>`:. .. code-block:: bash. $ clang-extdef-mapping -p . foo.cpp; 9:c:@F@foo# /path/to/your/project/foo.cpp; $ clang-extdef-mapping -p . foo.cpp > externalDefMap.txt. Now everything is available for the CTU analysis.; We have to feed Clang with CTU specific extra arguments:. .. code-block:: bash. $ pwd; /path/to/your/project; $ clang++ --analyze \; -Xclang -analyzer-config -Xclang experimental-enable-naive-ctu-analysis=true \; -Xclang -analyzer-config -Xclang ctu-dir=. \; -Xclang -analyzer-config -Xclang ctu-invocation-list=invocations.yaml \; -Xclang -analyzer-output=plist-multi-file \; main.cpp; main.cpp:5:12: warning: Division by zero; return 3 / foo();; ~~^~~~~~~; 1 warning generated.; $ # The plist file with the result is generated.; $ ls -F; compile_commands.json externalDefMap.txt foo.cpp main.cpp main.plist; $. This manual procedure is error-prone and not scalable, therefore to analyze real projects it is recommended to use; `CodeChecker` or `scan-build-py`. Automated CTU Analysis with CodeChecker; #######################################; The `CodeChecker <https://github.com/Ericsson/codechecker>`_ project fully supports automated CTU analysis with Clang.; Once we have set up the `PATH` environment variable and we activated the python `venv` then it is all it takes:. .. code-block:: bash. $ CodeChecker analyze --ctu --ctu-ast-loading-mode on-demand compil",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst:9464,Modifiability,config,config,9464," main.o"",; ""file"": ""main.cpp""; }; ]. The `invocation list`:. .. code-block:: bash. ""/path/to/your/project/foo.cpp"":; - ""clang++""; - ""-c""; - ""/path/to/your/project/foo.cpp""; - ""-o""; - ""/path/to/your/project/foo.o"". ""/path/to/your/project/main.cpp"":; - ""clang++""; - ""-c""; - ""/path/to/your/project/main.cpp""; - ""-o""; - ""/path/to/your/project/main.o"". We'd like to analyze `main.cpp` and discover the division by zero bug.; As we are using On-demand mode, we only need to create a CTU index file which holds the `USR` name and location of; external definitions in the source files in format `<USR-Length>:<USR> <File-Path>`:. .. code-block:: bash. $ clang-extdef-mapping -p . foo.cpp; 9:c:@F@foo# /path/to/your/project/foo.cpp; $ clang-extdef-mapping -p . foo.cpp > externalDefMap.txt. Now everything is available for the CTU analysis.; We have to feed Clang with CTU specific extra arguments:. .. code-block:: bash. $ pwd; /path/to/your/project; $ clang++ --analyze \; -Xclang -analyzer-config -Xclang experimental-enable-naive-ctu-analysis=true \; -Xclang -analyzer-config -Xclang ctu-dir=. \; -Xclang -analyzer-config -Xclang ctu-invocation-list=invocations.yaml \; -Xclang -analyzer-output=plist-multi-file \; main.cpp; main.cpp:5:12: warning: Division by zero; return 3 / foo();; ~~^~~~~~~; 1 warning generated.; $ # The plist file with the result is generated.; $ ls -F; compile_commands.json externalDefMap.txt foo.cpp main.cpp main.plist; $. This manual procedure is error-prone and not scalable, therefore to analyze real projects it is recommended to use; `CodeChecker` or `scan-build-py`. Automated CTU Analysis with CodeChecker; #######################################; The `CodeChecker <https://github.com/Ericsson/codechecker>`_ project fully supports automated CTU analysis with Clang.; Once we have set up the `PATH` environment variable and we activated the python `venv` then it is all it takes:. .. code-block:: bash. $ CodeChecker analyze --ctu --ctu-ast-loading-mode on-demand compil",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst:9510,Modifiability,config,config,9510,"ang++""; - ""-c""; - ""/path/to/your/project/foo.cpp""; - ""-o""; - ""/path/to/your/project/foo.o"". ""/path/to/your/project/main.cpp"":; - ""clang++""; - ""-c""; - ""/path/to/your/project/main.cpp""; - ""-o""; - ""/path/to/your/project/main.o"". We'd like to analyze `main.cpp` and discover the division by zero bug.; As we are using On-demand mode, we only need to create a CTU index file which holds the `USR` name and location of; external definitions in the source files in format `<USR-Length>:<USR> <File-Path>`:. .. code-block:: bash. $ clang-extdef-mapping -p . foo.cpp; 9:c:@F@foo# /path/to/your/project/foo.cpp; $ clang-extdef-mapping -p . foo.cpp > externalDefMap.txt. Now everything is available for the CTU analysis.; We have to feed Clang with CTU specific extra arguments:. .. code-block:: bash. $ pwd; /path/to/your/project; $ clang++ --analyze \; -Xclang -analyzer-config -Xclang experimental-enable-naive-ctu-analysis=true \; -Xclang -analyzer-config -Xclang ctu-dir=. \; -Xclang -analyzer-config -Xclang ctu-invocation-list=invocations.yaml \; -Xclang -analyzer-output=plist-multi-file \; main.cpp; main.cpp:5:12: warning: Division by zero; return 3 / foo();; ~~^~~~~~~; 1 warning generated.; $ # The plist file with the result is generated.; $ ls -F; compile_commands.json externalDefMap.txt foo.cpp main.cpp main.plist; $. This manual procedure is error-prone and not scalable, therefore to analyze real projects it is recommended to use; `CodeChecker` or `scan-build-py`. Automated CTU Analysis with CodeChecker; #######################################; The `CodeChecker <https://github.com/Ericsson/codechecker>`_ project fully supports automated CTU analysis with Clang.; Once we have set up the `PATH` environment variable and we activated the python `venv` then it is all it takes:. .. code-block:: bash. $ CodeChecker analyze --ctu --ctu-ast-loading-mode on-demand compile_commands.json -o reports; $ ls -F; compile_commands.json foo.cpp main.cpp reports/; $ tree reports; reports; ├── compile_",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst:10241,Modifiability,variab,variable,10241,"g with CTU specific extra arguments:. .. code-block:: bash. $ pwd; /path/to/your/project; $ clang++ --analyze \; -Xclang -analyzer-config -Xclang experimental-enable-naive-ctu-analysis=true \; -Xclang -analyzer-config -Xclang ctu-dir=. \; -Xclang -analyzer-config -Xclang ctu-invocation-list=invocations.yaml \; -Xclang -analyzer-output=plist-multi-file \; main.cpp; main.cpp:5:12: warning: Division by zero; return 3 / foo();; ~~^~~~~~~; 1 warning generated.; $ # The plist file with the result is generated.; $ ls -F; compile_commands.json externalDefMap.txt foo.cpp main.cpp main.plist; $. This manual procedure is error-prone and not scalable, therefore to analyze real projects it is recommended to use; `CodeChecker` or `scan-build-py`. Automated CTU Analysis with CodeChecker; #######################################; The `CodeChecker <https://github.com/Ericsson/codechecker>`_ project fully supports automated CTU analysis with Clang.; Once we have set up the `PATH` environment variable and we activated the python `venv` then it is all it takes:. .. code-block:: bash. $ CodeChecker analyze --ctu --ctu-ast-loading-mode on-demand compile_commands.json -o reports; $ ls -F; compile_commands.json foo.cpp main.cpp reports/; $ tree reports; reports; ├── compile_cmd.json; ├── compiler_info.json; ├── foo.cpp_53f6fbf7ab7ec9931301524b551959e2.plist; ├── main.cpp_23db3d8df52ff0812e6e5a03071c8337.plist; ├── metadata.json; └── unique_compile_commands.json. 0 directories, 6 files; $. The `plist` files contain the results of the analysis, which may be viewed with the regular analysis tools.; E.g. one may use `CodeChecker parse` to view the results in command line:. .. code-block:: bash. $ CodeChecker parse reports; [HIGH] /home/egbomrt/ctu_mini_raw_project/main.cpp:5:12: Division by zero [core.DivideZero]; return 3 / foo();; ^. Found 1 defect(s) in main.cpp. ----==== Summary ====----; -----------------------; Filename | Report count; -----------------------; main.cpp | 1; --------------",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst:4050,Performance,scalab,scalable,4050,"DefMap.txt` to contain the name of the `.ast` files instead of the source files:. .. code-block:: bash. $ sed -i -e ""s/.cpp/.cpp.ast/g"" externalDefMap.txt. We still have to further modify the `externalDefMap.txt` file to contain relative paths:. .. code-block:: bash. $ sed -i -e ""s|$(pwd)/||g"" externalDefMap.txt. Now everything is available for the CTU analysis.; We have to feed Clang with CTU specific extra arguments:. .. code-block:: bash. $ pwd; /path/to/your/project; $ clang++ --analyze \; -Xclang -analyzer-config -Xclang experimental-enable-naive-ctu-analysis=true \; -Xclang -analyzer-config -Xclang ctu-dir=. \; -Xclang -analyzer-output=plist-multi-file \; main.cpp; main.cpp:5:12: warning: Division by zero; return 3 / foo();; ~~^~~~~~~; 1 warning generated.; $ # The plist file with the result is generated.; $ ls -F; compile_commands.json externalDefMap.txt foo.ast foo.cpp foo.cpp.ast main.cpp main.plist; $. This manual procedure is error-prone and not scalable, therefore to analyze real projects it is recommended to use; `CodeChecker` or `scan-build-py`. Automated CTU Analysis with CodeChecker; #######################################; The `CodeChecker <https://github.com/Ericsson/codechecker>`_ project fully supports automated CTU analysis with Clang.; Once we have set up the `PATH` environment variable and we activated the python `venv` then it is all it takes:. .. code-block:: bash. $ CodeChecker analyze --ctu compile_commands.json -o reports; $ ls -F; compile_commands.json foo.cpp foo.cpp.ast main.cpp reports/; $ tree reports; reports; ├── compile_cmd.json; ├── compiler_info.json; ├── foo.cpp_53f6fbf7ab7ec9931301524b551959e2.plist; ├── main.cpp_23db3d8df52ff0812e6e5a03071c8337.plist; ├── metadata.json; └── unique_compile_commands.json. 0 directories, 6 files; $. The `plist` files contain the results of the analysis, which may be viewed with the regular analysis tools.; E.g. one may use `CodeChecker parse` to view the results in command line:. .. code-block::",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst:9891,Performance,scalab,scalable,9891,"nd location of; external definitions in the source files in format `<USR-Length>:<USR> <File-Path>`:. .. code-block:: bash. $ clang-extdef-mapping -p . foo.cpp; 9:c:@F@foo# /path/to/your/project/foo.cpp; $ clang-extdef-mapping -p . foo.cpp > externalDefMap.txt. Now everything is available for the CTU analysis.; We have to feed Clang with CTU specific extra arguments:. .. code-block:: bash. $ pwd; /path/to/your/project; $ clang++ --analyze \; -Xclang -analyzer-config -Xclang experimental-enable-naive-ctu-analysis=true \; -Xclang -analyzer-config -Xclang ctu-dir=. \; -Xclang -analyzer-config -Xclang ctu-invocation-list=invocations.yaml \; -Xclang -analyzer-output=plist-multi-file \; main.cpp; main.cpp:5:12: warning: Division by zero; return 3 / foo();; ~~^~~~~~~; 1 warning generated.; $ # The plist file with the result is generated.; $ ls -F; compile_commands.json externalDefMap.txt foo.cpp main.cpp main.plist; $. This manual procedure is error-prone and not scalable, therefore to analyze real projects it is recommended to use; `CodeChecker` or `scan-build-py`. Automated CTU Analysis with CodeChecker; #######################################; The `CodeChecker <https://github.com/Ericsson/codechecker>`_ project fully supports automated CTU analysis with Clang.; Once we have set up the `PATH` environment variable and we activated the python `venv` then it is all it takes:. .. code-block:: bash. $ CodeChecker analyze --ctu --ctu-ast-loading-mode on-demand compile_commands.json -o reports; $ ls -F; compile_commands.json foo.cpp main.cpp reports/; $ tree reports; reports; ├── compile_cmd.json; ├── compiler_info.json; ├── foo.cpp_53f6fbf7ab7ec9931301524b551959e2.plist; ├── main.cpp_23db3d8df52ff0812e6e5a03071c8337.plist; ├── metadata.json; └── unique_compile_commands.json. 0 directories, 6 files; $. The `plist` files contain the results of the analysis, which may be viewed with the regular analysis tools.; E.g. one may use `CodeChecker parse` to view the results in command l",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst:10371,Performance,load,loading-mode,10371,"ng -analyzer-config -Xclang experimental-enable-naive-ctu-analysis=true \; -Xclang -analyzer-config -Xclang ctu-dir=. \; -Xclang -analyzer-config -Xclang ctu-invocation-list=invocations.yaml \; -Xclang -analyzer-output=plist-multi-file \; main.cpp; main.cpp:5:12: warning: Division by zero; return 3 / foo();; ~~^~~~~~~; 1 warning generated.; $ # The plist file with the result is generated.; $ ls -F; compile_commands.json externalDefMap.txt foo.cpp main.cpp main.plist; $. This manual procedure is error-prone and not scalable, therefore to analyze real projects it is recommended to use; `CodeChecker` or `scan-build-py`. Automated CTU Analysis with CodeChecker; #######################################; The `CodeChecker <https://github.com/Ericsson/codechecker>`_ project fully supports automated CTU analysis with Clang.; Once we have set up the `PATH` environment variable and we activated the python `venv` then it is all it takes:. .. code-block:: bash. $ CodeChecker analyze --ctu --ctu-ast-loading-mode on-demand compile_commands.json -o reports; $ ls -F; compile_commands.json foo.cpp main.cpp reports/; $ tree reports; reports; ├── compile_cmd.json; ├── compiler_info.json; ├── foo.cpp_53f6fbf7ab7ec9931301524b551959e2.plist; ├── main.cpp_23db3d8df52ff0812e6e5a03071c8337.plist; ├── metadata.json; └── unique_compile_commands.json. 0 directories, 6 files; $. The `plist` files contain the results of the analysis, which may be viewed with the regular analysis tools.; E.g. one may use `CodeChecker parse` to view the results in command line:. .. code-block:: bash. $ CodeChecker parse reports; [HIGH] /home/egbomrt/ctu_mini_raw_project/main.cpp:5:12: Division by zero [core.DivideZero]; return 3 / foo();; ^. Found 1 defect(s) in main.cpp. ----==== Summary ====----; -----------------------; Filename | Report count; -----------------------; main.cpp | 1; -----------------------; -----------------------; Severity | Report count; -----------------------; HIGH | 1; -----------------------",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/CrossTranslationUnit.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:1166,Availability,error,errors,1166,"icTaintChecker`, which the user can access via the :ref:`alpha-security-taint-TaintPropagation` checker alias and this checker has a default taint-related configuration.; The built-in default settings are defined in code, and they are always in effect once the checker is enabled, either directly or via the alias.; The checker also provides a configuration interface for extending the default settings by providing a configuration file in `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format.; This documentation describes the syntax of the configuration file and gives the informal semantics of the configuration options. .. contents::; :local:. .. _clangsa-taint-configuration-overview:. Overview; ________. Taint analysis works by checking for the occurrence of special operations during the symbolic execution of the program.; Taint analysis defines sources, sinks, and propagation rules. It identifies errors by detecting a flow of information that originates from a taint source, reaches a taint sink, and propagates through the program paths via propagation rules.; A source, sink, or an operation that propagates taint is mainly domain-specific knowledge, but there are some built-in defaults provided by :ref:`alpha-security-taint-TaintPropagation`.; It is possible to express that a statement sanitizes tainted values by providing a ``Filters`` section in the external configuration (see :ref:`clangsa-taint-configuration-example` and :ref:`clangsa-taint-filter-details`).; There are no default filters defined in the built-in settings.; The checker's documentation also specifies how to provide a custom taint configuration with command-line options. .. _clangsa-taint-configuration-example:. Example configuration file; __________________________. .. code-block:: yaml. # The entries that specify arguments use 0-based indexing when specifying; # input arguments, and -1 is used to denote the return value. Filters:; # Filter functions; # Taint is sanitized when tainted",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:8290,Availability,redundant,redundant,8290,"d, the checker will consider all `DstArgs` arguments tainted after the call.; - `DstArgs` is a list of numbers in the range of ``[-1..int_max]`` that indicates the indexes of arguments in the function call.; The number ``-1`` specifies the return value of the function.; If any `SrcArgs` arguments are tainted, the checker will consider all `DstArgs` arguments tainted after the call.; - `VariadicType` is a string that can be one of ``None``, ``Dst``, ``Src``.; It is used in conjunction with `VariadicIndex` to specify arguments inside a variadic argument.; The value of ``Src`` will treat every call site argument that is part of a variadic argument list as a source concerning propagation rules (as if specified by `SrcArg`).; The value of ``Dst`` will treat every call site argument that is part of a variadic argument list a destination concerning propagation rules.; The value of ``None`` will not consider the arguments that are part of a variadic argument list (this option is redundant but can be used to temporarily switch off handling of a particular variadic argument option without removing the VariadicIndex key).; - `VariadicIndex` is a number in the range of ``[0..int_max]``. It indicates the starting index of the variadic argument in the signature of the function. .. _clangsa-taint-sink-details:. Sink syntax and semantics; #########################. An entry under `Sinks` is a `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ object with the following mandatory keys:; - `Name` is a string that specifies the name of a function.; Encountering this function during symbolic execution will emit a taint-related diagnostic if any of the arguments specified with `Args` are tainted at the call site.; - `Args` is a list of numbers in the range of ``[0..int_max]`` that indicates the indexes of arguments in the function call.; The checker reports an error if any of the specified arguments are tainted. The following keys are optional:; - `Scope` is a string that sp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:9188,Availability,error,error,9188,"-1..int_max]`` that indicates the indexes of arguments in the function call.; The number ``-1`` specifies the return value of the function.; If any `SrcArgs` arguments are tainted, the checker will consider all `DstArgs` arguments tainted after the call.; - `VariadicType` is a string that can be one of ``None``, ``Dst``, ``Src``.; It is used in conjunction with `VariadicIndex` to specify arguments inside a variadic argument.; The value of ``Src`` will treat every call site argument that is part of a variadic argument list as a source concerning propagation rules (as if specified by `SrcArg`).; The value of ``Dst`` will treat every call site argument that is part of a variadic argument list a destination concerning propagation rules.; The value of ``None`` will not consider the arguments that are part of a variadic argument list (this option is redundant but can be used to temporarily switch off handling of a particular variadic argument option without removing the VariadicIndex key).; - `VariadicIndex` is a number in the range of ``[0..int_max]``. It indicates the starting index of the variadic argument in the signature of the function. .. _clangsa-taint-sink-details:. Sink syntax and semantics; #########################. An entry under `Sinks` is a `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ object with the following mandatory keys:; - `Name` is a string that specifies the name of a function.; Encountering this function during symbolic execution will emit a taint-related diagnostic if any of the arguments specified with `Args` are tainted at the call site.; - `Args` is a list of numbers in the range of ``[0..int_max]`` that indicates the indexes of arguments in the function call.; The checker reports an error if any of the specified arguments are tainted. The following keys are optional:; - `Scope` is a string that specifies the prefix of the function's name in its fully qualified name. This option restricts the set of matching function calls.; ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:395,Deployability,configurat,configuration,395,"============================; Taint Analysis Configuration; ============================. The Clang Static Analyzer uses taint analysis to detect security-related issues in code.; The backbone of taint analysis in the Clang SA is the `GenericTaintChecker`, which the user can access via the :ref:`alpha-security-taint-TaintPropagation` checker alias and this checker has a default taint-related configuration.; The built-in default settings are defined in code, and they are always in effect once the checker is enabled, either directly or via the alias.; The checker also provides a configuration interface for extending the default settings by providing a configuration file in `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format.; This documentation describes the syntax of the configuration file and gives the informal semantics of the configuration options. .. contents::; :local:. .. _clangsa-taint-configuration-overview:. Overview; ________. Taint analysis works by checking for the occurrence of special operations during the symbolic execution of the program.; Taint analysis defines sources, sinks, and propagation rules. It identifies errors by detecting a flow of information that originates from a taint source, reaches a taint sink, and propagates through the program paths via propagation rules.; A source, sink, or an operation that propagates taint is mainly domain-specific knowledge, but there are some built-in defaults provided by :ref:`alpha-security-taint-TaintPropagation`.; It is possible to express that a statement sanitizes tainted values by providing a ``Filters`` section in the external configuration (see :ref:`clangsa-taint-configuration-example` and :ref:`clangsa-taint-filter-details`).; There are no default filters defined in the built-in settings.; The checker's documentation also specifies how to provide a custom taint configuration with command-line options. .. _clangsa-taint-configuration-example:. Example configuration file; __________",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:584,Deployability,configurat,configuration,584,"============================; Taint Analysis Configuration; ============================. The Clang Static Analyzer uses taint analysis to detect security-related issues in code.; The backbone of taint analysis in the Clang SA is the `GenericTaintChecker`, which the user can access via the :ref:`alpha-security-taint-TaintPropagation` checker alias and this checker has a default taint-related configuration.; The built-in default settings are defined in code, and they are always in effect once the checker is enabled, either directly or via the alias.; The checker also provides a configuration interface for extending the default settings by providing a configuration file in `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format.; This documentation describes the syntax of the configuration file and gives the informal semantics of the configuration options. .. contents::; :local:. .. _clangsa-taint-configuration-overview:. Overview; ________. Taint analysis works by checking for the occurrence of special operations during the symbolic execution of the program.; Taint analysis defines sources, sinks, and propagation rules. It identifies errors by detecting a flow of information that originates from a taint source, reaches a taint sink, and propagates through the program paths via propagation rules.; A source, sink, or an operation that propagates taint is mainly domain-specific knowledge, but there are some built-in defaults provided by :ref:`alpha-security-taint-TaintPropagation`.; It is possible to express that a statement sanitizes tainted values by providing a ``Filters`` section in the external configuration (see :ref:`clangsa-taint-configuration-example` and :ref:`clangsa-taint-filter-details`).; There are no default filters defined in the built-in settings.; The checker's documentation also specifies how to provide a custom taint configuration with command-line options. .. _clangsa-taint-configuration-example:. Example configuration file; __________",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:658,Deployability,configurat,configuration,658,"============================; Taint Analysis Configuration; ============================. The Clang Static Analyzer uses taint analysis to detect security-related issues in code.; The backbone of taint analysis in the Clang SA is the `GenericTaintChecker`, which the user can access via the :ref:`alpha-security-taint-TaintPropagation` checker alias and this checker has a default taint-related configuration.; The built-in default settings are defined in code, and they are always in effect once the checker is enabled, either directly or via the alias.; The checker also provides a configuration interface for extending the default settings by providing a configuration file in `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format.; This documentation describes the syntax of the configuration file and gives the informal semantics of the configuration options. .. contents::; :local:. .. _clangsa-taint-configuration-overview:. Overview; ________. Taint analysis works by checking for the occurrence of special operations during the symbolic execution of the program.; Taint analysis defines sources, sinks, and propagation rules. It identifies errors by detecting a flow of information that originates from a taint source, reaches a taint sink, and propagates through the program paths via propagation rules.; A source, sink, or an operation that propagates taint is mainly domain-specific knowledge, but there are some built-in defaults provided by :ref:`alpha-security-taint-TaintPropagation`.; It is possible to express that a statement sanitizes tainted values by providing a ``Filters`` section in the external configuration (see :ref:`clangsa-taint-configuration-example` and :ref:`clangsa-taint-filter-details`).; There are no default filters defined in the built-in settings.; The checker's documentation also specifies how to provide a custom taint configuration with command-line options. .. _clangsa-taint-configuration-example:. Example configuration file; __________",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:800,Deployability,configurat,configuration,800,"============================; Taint Analysis Configuration; ============================. The Clang Static Analyzer uses taint analysis to detect security-related issues in code.; The backbone of taint analysis in the Clang SA is the `GenericTaintChecker`, which the user can access via the :ref:`alpha-security-taint-TaintPropagation` checker alias and this checker has a default taint-related configuration.; The built-in default settings are defined in code, and they are always in effect once the checker is enabled, either directly or via the alias.; The checker also provides a configuration interface for extending the default settings by providing a configuration file in `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format.; This documentation describes the syntax of the configuration file and gives the informal semantics of the configuration options. .. contents::; :local:. .. _clangsa-taint-configuration-overview:. Overview; ________. Taint analysis works by checking for the occurrence of special operations during the symbolic execution of the program.; Taint analysis defines sources, sinks, and propagation rules. It identifies errors by detecting a flow of information that originates from a taint source, reaches a taint sink, and propagates through the program paths via propagation rules.; A source, sink, or an operation that propagates taint is mainly domain-specific knowledge, but there are some built-in defaults provided by :ref:`alpha-security-taint-TaintPropagation`.; It is possible to express that a statement sanitizes tainted values by providing a ``Filters`` section in the external configuration (see :ref:`clangsa-taint-configuration-example` and :ref:`clangsa-taint-filter-details`).; There are no default filters defined in the built-in settings.; The checker's documentation also specifies how to provide a custom taint configuration with command-line options. .. _clangsa-taint-configuration-example:. Example configuration file; __________",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:859,Deployability,configurat,configuration,859,"============================; Taint Analysis Configuration; ============================. The Clang Static Analyzer uses taint analysis to detect security-related issues in code.; The backbone of taint analysis in the Clang SA is the `GenericTaintChecker`, which the user can access via the :ref:`alpha-security-taint-TaintPropagation` checker alias and this checker has a default taint-related configuration.; The built-in default settings are defined in code, and they are always in effect once the checker is enabled, either directly or via the alias.; The checker also provides a configuration interface for extending the default settings by providing a configuration file in `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format.; This documentation describes the syntax of the configuration file and gives the informal semantics of the configuration options. .. contents::; :local:. .. _clangsa-taint-configuration-overview:. Overview; ________. Taint analysis works by checking for the occurrence of special operations during the symbolic execution of the program.; Taint analysis defines sources, sinks, and propagation rules. It identifies errors by detecting a flow of information that originates from a taint source, reaches a taint sink, and propagates through the program paths via propagation rules.; A source, sink, or an operation that propagates taint is mainly domain-specific knowledge, but there are some built-in defaults provided by :ref:`alpha-security-taint-TaintPropagation`.; It is possible to express that a statement sanitizes tainted values by providing a ``Filters`` section in the external configuration (see :ref:`clangsa-taint-configuration-example` and :ref:`clangsa-taint-filter-details`).; There are no default filters defined in the built-in settings.; The checker's documentation also specifies how to provide a custom taint configuration with command-line options. .. _clangsa-taint-configuration-example:. Example configuration file; __________",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:924,Deployability,configurat,configuration-overview,924,"============================; Taint Analysis Configuration; ============================. The Clang Static Analyzer uses taint analysis to detect security-related issues in code.; The backbone of taint analysis in the Clang SA is the `GenericTaintChecker`, which the user can access via the :ref:`alpha-security-taint-TaintPropagation` checker alias and this checker has a default taint-related configuration.; The built-in default settings are defined in code, and they are always in effect once the checker is enabled, either directly or via the alias.; The checker also provides a configuration interface for extending the default settings by providing a configuration file in `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format.; This documentation describes the syntax of the configuration file and gives the informal semantics of the configuration options. .. contents::; :local:. .. _clangsa-taint-configuration-overview:. Overview; ________. Taint analysis works by checking for the occurrence of special operations during the symbolic execution of the program.; Taint analysis defines sources, sinks, and propagation rules. It identifies errors by detecting a flow of information that originates from a taint source, reaches a taint sink, and propagates through the program paths via propagation rules.; A source, sink, or an operation that propagates taint is mainly domain-specific knowledge, but there are some built-in defaults provided by :ref:`alpha-security-taint-TaintPropagation`.; It is possible to express that a statement sanitizes tainted values by providing a ``Filters`` section in the external configuration (see :ref:`clangsa-taint-configuration-example` and :ref:`clangsa-taint-filter-details`).; There are no default filters defined in the built-in settings.; The checker's documentation also specifies how to provide a custom taint configuration with command-line options. .. _clangsa-taint-configuration-example:. Example configuration file; __________",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:1638,Deployability,configurat,configuration,1638,"ault settings by providing a configuration file in `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format.; This documentation describes the syntax of the configuration file and gives the informal semantics of the configuration options. .. contents::; :local:. .. _clangsa-taint-configuration-overview:. Overview; ________. Taint analysis works by checking for the occurrence of special operations during the symbolic execution of the program.; Taint analysis defines sources, sinks, and propagation rules. It identifies errors by detecting a flow of information that originates from a taint source, reaches a taint sink, and propagates through the program paths via propagation rules.; A source, sink, or an operation that propagates taint is mainly domain-specific knowledge, but there are some built-in defaults provided by :ref:`alpha-security-taint-TaintPropagation`.; It is possible to express that a statement sanitizes tainted values by providing a ``Filters`` section in the external configuration (see :ref:`clangsa-taint-configuration-example` and :ref:`clangsa-taint-filter-details`).; There are no default filters defined in the built-in settings.; The checker's documentation also specifies how to provide a custom taint configuration with command-line options. .. _clangsa-taint-configuration-example:. Example configuration file; __________________________. .. code-block:: yaml. # The entries that specify arguments use 0-based indexing when specifying; # input arguments, and -1 is used to denote the return value. Filters:; # Filter functions; # Taint is sanitized when tainted variables are pass arguments to filters. # Filter function; # void cleanse_first_arg(int* arg); #; # Result example:; # int x; // x is tainted; # cleanse_first_arg(&x); // x is not tainted after the call; - Name: cleanse_first_arg; Args: [0]. Propagations:; # Source functions; # The omission of SrcArgs key indicates unconditional taint propagation,; # which is conceptually what a sour",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:1677,Deployability,configurat,configuration-example,1677,"ault settings by providing a configuration file in `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format.; This documentation describes the syntax of the configuration file and gives the informal semantics of the configuration options. .. contents::; :local:. .. _clangsa-taint-configuration-overview:. Overview; ________. Taint analysis works by checking for the occurrence of special operations during the symbolic execution of the program.; Taint analysis defines sources, sinks, and propagation rules. It identifies errors by detecting a flow of information that originates from a taint source, reaches a taint sink, and propagates through the program paths via propagation rules.; A source, sink, or an operation that propagates taint is mainly domain-specific knowledge, but there are some built-in defaults provided by :ref:`alpha-security-taint-TaintPropagation`.; It is possible to express that a statement sanitizes tainted values by providing a ``Filters`` section in the external configuration (see :ref:`clangsa-taint-configuration-example` and :ref:`clangsa-taint-filter-details`).; There are no default filters defined in the built-in settings.; The checker's documentation also specifies how to provide a custom taint configuration with command-line options. .. _clangsa-taint-configuration-example:. Example configuration file; __________________________. .. code-block:: yaml. # The entries that specify arguments use 0-based indexing when specifying; # input arguments, and -1 is used to denote the return value. Filters:; # Filter functions; # Taint is sanitized when tainted variables are pass arguments to filters. # Filter function; # void cleanse_first_arg(int* arg); #; # Result example:; # int x; // x is tainted; # cleanse_first_arg(&x); // x is not tainted after the call; - Name: cleanse_first_arg; Args: [0]. Propagations:; # Source functions; # The omission of SrcArgs key indicates unconditional taint propagation,; # which is conceptually what a sour",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:1880,Deployability,configurat,configuration,1880,"figuration options. .. contents::; :local:. .. _clangsa-taint-configuration-overview:. Overview; ________. Taint analysis works by checking for the occurrence of special operations during the symbolic execution of the program.; Taint analysis defines sources, sinks, and propagation rules. It identifies errors by detecting a flow of information that originates from a taint source, reaches a taint sink, and propagates through the program paths via propagation rules.; A source, sink, or an operation that propagates taint is mainly domain-specific knowledge, but there are some built-in defaults provided by :ref:`alpha-security-taint-TaintPropagation`.; It is possible to express that a statement sanitizes tainted values by providing a ``Filters`` section in the external configuration (see :ref:`clangsa-taint-configuration-example` and :ref:`clangsa-taint-filter-details`).; There are no default filters defined in the built-in settings.; The checker's documentation also specifies how to provide a custom taint configuration with command-line options. .. _clangsa-taint-configuration-example:. Example configuration file; __________________________. .. code-block:: yaml. # The entries that specify arguments use 0-based indexing when specifying; # input arguments, and -1 is used to denote the return value. Filters:; # Filter functions; # Taint is sanitized when tainted variables are pass arguments to filters. # Filter function; # void cleanse_first_arg(int* arg); #; # Result example:; # int x; // x is tainted; # cleanse_first_arg(&x); // x is not tainted after the call; - Name: cleanse_first_arg; Args: [0]. Propagations:; # Source functions; # The omission of SrcArgs key indicates unconditional taint propagation,; # which is conceptually what a source does. # Source function; # size_t fread(void *ptr, size_t size, size_t nmemb, FILE * stream); #; # Result example:; # FILE* f = fopen(""file.txt"");; # char buf[1024];; # size_t read = fread(buf, sizeof(buf[0]), sizeof(buf)/sizeof(bu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:1939,Deployability,configurat,configuration-example,1939,"view:. Overview; ________. Taint analysis works by checking for the occurrence of special operations during the symbolic execution of the program.; Taint analysis defines sources, sinks, and propagation rules. It identifies errors by detecting a flow of information that originates from a taint source, reaches a taint sink, and propagates through the program paths via propagation rules.; A source, sink, or an operation that propagates taint is mainly domain-specific knowledge, but there are some built-in defaults provided by :ref:`alpha-security-taint-TaintPropagation`.; It is possible to express that a statement sanitizes tainted values by providing a ``Filters`` section in the external configuration (see :ref:`clangsa-taint-configuration-example` and :ref:`clangsa-taint-filter-details`).; There are no default filters defined in the built-in settings.; The checker's documentation also specifies how to provide a custom taint configuration with command-line options. .. _clangsa-taint-configuration-example:. Example configuration file; __________________________. .. code-block:: yaml. # The entries that specify arguments use 0-based indexing when specifying; # input arguments, and -1 is used to denote the return value. Filters:; # Filter functions; # Taint is sanitized when tainted variables are pass arguments to filters. # Filter function; # void cleanse_first_arg(int* arg); #; # Result example:; # int x; // x is tainted; # cleanse_first_arg(&x); // x is not tainted after the call; - Name: cleanse_first_arg; Args: [0]. Propagations:; # Source functions; # The omission of SrcArgs key indicates unconditional taint propagation,; # which is conceptually what a source does. # Source function; # size_t fread(void *ptr, size_t size, size_t nmemb, FILE * stream); #; # Result example:; # FILE* f = fopen(""file.txt"");; # char buf[1024];; # size_t read = fread(buf, sizeof(buf[0]), sizeof(buf)/sizeof(buf[0]), f);; # // both read and buf are tainted; - Name: fread; DstArgs: [0, -1].",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:1971,Deployability,configurat,configuration,1971,"by checking for the occurrence of special operations during the symbolic execution of the program.; Taint analysis defines sources, sinks, and propagation rules. It identifies errors by detecting a flow of information that originates from a taint source, reaches a taint sink, and propagates through the program paths via propagation rules.; A source, sink, or an operation that propagates taint is mainly domain-specific knowledge, but there are some built-in defaults provided by :ref:`alpha-security-taint-TaintPropagation`.; It is possible to express that a statement sanitizes tainted values by providing a ``Filters`` section in the external configuration (see :ref:`clangsa-taint-configuration-example` and :ref:`clangsa-taint-filter-details`).; There are no default filters defined in the built-in settings.; The checker's documentation also specifies how to provide a custom taint configuration with command-line options. .. _clangsa-taint-configuration-example:. Example configuration file; __________________________. .. code-block:: yaml. # The entries that specify arguments use 0-based indexing when specifying; # input arguments, and -1 is used to denote the return value. Filters:; # Filter functions; # Taint is sanitized when tainted variables are pass arguments to filters. # Filter function; # void cleanse_first_arg(int* arg); #; # Result example:; # int x; // x is tainted; # cleanse_first_arg(&x); // x is not tainted after the call; - Name: cleanse_first_arg; Args: [0]. Propagations:; # Source functions; # The omission of SrcArgs key indicates unconditional taint propagation,; # which is conceptually what a source does. # Source function; # size_t fread(void *ptr, size_t size, size_t nmemb, FILE * stream); #; # Result example:; # FILE* f = fopen(""file.txt"");; # char buf[1024];; # size_t read = fread(buf, sizeof(buf[0]), sizeof(buf)/sizeof(buf[0]), f);; # // both read and buf are tainted; - Name: fread; DstArgs: [0, -1]. # Propagation functions; # The presence of Src",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:4127,Deployability,configurat,configuration,4127,"t example:; # char* path = read_path();; # char* dir = dirname(path);; # // dir is tainted if path was tainted; - Name: dirname; SrcArgs: [0]; DstArgs: [-1]. Sinks:; # Sink functions; # If taint reaches any of the arguments specified, a warning is emitted. # Sink function; # int system(const char* command); #; # Result example:; # const char* command = read_command();; # system(command); // emit diagnostic if command is tainted; - Name: system; Args: [0]. In the example file above, the entries under the `Propagation` key implement the conceptual sources and propagations, and sinks have their dedicated `Sinks` key.; The user can define operations (function calls) where the tainted values should be cleansed by listing entries under the `Filters` key.; Filters model the sanitization of values done by the programmer, and providing these is key to avoiding false-positive findings. Configuration file syntax and semantics; _______________________________________. The configuration file should have valid `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ syntax. The configuration file can have the following top-level keys:; - Filters; - Propagations; - Sinks. Under the `Filters` key, the user can specify a list of operations that remove taint (see :ref:`clangsa-taint-filter-details` for details). Under the `Propagations` key, the user can specify a list of operations that introduce and propagate taint (see :ref:`clangsa-taint-propagation-details` for details).; The user can mark taint sources with a `SrcArgs` key in the `Propagation` key, while propagations have none.; The lack of the `SrcArgs` key means unconditional propagation, which is how sources are modeled.; The semantics of propagations are such, that if any of the source arguments are tainted (specified by indexes in `SrcArgs`) then all of the destination arguments (specified by indexes in `DstArgs`) also become tainted. Under the `Sinks` key, the user can specify a list of operations where the checker ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:4240,Deployability,configurat,configuration,4240,"Args: [0]; DstArgs: [-1]. Sinks:; # Sink functions; # If taint reaches any of the arguments specified, a warning is emitted. # Sink function; # int system(const char* command); #; # Result example:; # const char* command = read_command();; # system(command); // emit diagnostic if command is tainted; - Name: system; Args: [0]. In the example file above, the entries under the `Propagation` key implement the conceptual sources and propagations, and sinks have their dedicated `Sinks` key.; The user can define operations (function calls) where the tainted values should be cleansed by listing entries under the `Filters` key.; Filters model the sanitization of values done by the programmer, and providing these is key to avoiding false-positive findings. Configuration file syntax and semantics; _______________________________________. The configuration file should have valid `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ syntax. The configuration file can have the following top-level keys:; - Filters; - Propagations; - Sinks. Under the `Filters` key, the user can specify a list of operations that remove taint (see :ref:`clangsa-taint-filter-details` for details). Under the `Propagations` key, the user can specify a list of operations that introduce and propagate taint (see :ref:`clangsa-taint-propagation-details` for details).; The user can mark taint sources with a `SrcArgs` key in the `Propagation` key, while propagations have none.; The lack of the `SrcArgs` key means unconditional propagation, which is how sources are modeled.; The semantics of propagations are such, that if any of the source arguments are tainted (specified by indexes in `SrcArgs`) then all of the destination arguments (specified by indexes in `DstArgs`) also become tainted. Under the `Sinks` key, the user can specify a list of operations where the checker should emit a bug report if tainted data reaches it (see :ref:`clangsa-taint-sink-details` for details). .. _clangsa-taint-filter-de",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:598,Integrability,interface,interface,598,"============================; Taint Analysis Configuration; ============================. The Clang Static Analyzer uses taint analysis to detect security-related issues in code.; The backbone of taint analysis in the Clang SA is the `GenericTaintChecker`, which the user can access via the :ref:`alpha-security-taint-TaintPropagation` checker alias and this checker has a default taint-related configuration.; The built-in default settings are defined in code, and they are always in effect once the checker is enabled, either directly or via the alias.; The checker also provides a configuration interface for extending the default settings by providing a configuration file in `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format.; This documentation describes the syntax of the configuration file and gives the informal semantics of the configuration options. .. contents::; :local:. .. _clangsa-taint-configuration-overview:. Overview; ________. Taint analysis works by checking for the occurrence of special operations during the symbolic execution of the program.; Taint analysis defines sources, sinks, and propagation rules. It identifies errors by detecting a flow of information that originates from a taint source, reaches a taint sink, and propagates through the program paths via propagation rules.; A source, sink, or an operation that propagates taint is mainly domain-specific knowledge, but there are some built-in defaults provided by :ref:`alpha-security-taint-TaintPropagation`.; It is possible to express that a statement sanitizes tainted values by providing a ``Filters`` section in the external configuration (see :ref:`clangsa-taint-configuration-example` and :ref:`clangsa-taint-filter-details`).; There are no default filters defined in the built-in settings.; The checker's documentation also specifies how to provide a custom taint configuration with command-line options. .. _clangsa-taint-configuration-example:. Example configuration file; __________",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:395,Modifiability,config,configuration,395,"============================; Taint Analysis Configuration; ============================. The Clang Static Analyzer uses taint analysis to detect security-related issues in code.; The backbone of taint analysis in the Clang SA is the `GenericTaintChecker`, which the user can access via the :ref:`alpha-security-taint-TaintPropagation` checker alias and this checker has a default taint-related configuration.; The built-in default settings are defined in code, and they are always in effect once the checker is enabled, either directly or via the alias.; The checker also provides a configuration interface for extending the default settings by providing a configuration file in `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format.; This documentation describes the syntax of the configuration file and gives the informal semantics of the configuration options. .. contents::; :local:. .. _clangsa-taint-configuration-overview:. Overview; ________. Taint analysis works by checking for the occurrence of special operations during the symbolic execution of the program.; Taint analysis defines sources, sinks, and propagation rules. It identifies errors by detecting a flow of information that originates from a taint source, reaches a taint sink, and propagates through the program paths via propagation rules.; A source, sink, or an operation that propagates taint is mainly domain-specific knowledge, but there are some built-in defaults provided by :ref:`alpha-security-taint-TaintPropagation`.; It is possible to express that a statement sanitizes tainted values by providing a ``Filters`` section in the external configuration (see :ref:`clangsa-taint-configuration-example` and :ref:`clangsa-taint-filter-details`).; There are no default filters defined in the built-in settings.; The checker's documentation also specifies how to provide a custom taint configuration with command-line options. .. _clangsa-taint-configuration-example:. Example configuration file; __________",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:584,Modifiability,config,configuration,584,"============================; Taint Analysis Configuration; ============================. The Clang Static Analyzer uses taint analysis to detect security-related issues in code.; The backbone of taint analysis in the Clang SA is the `GenericTaintChecker`, which the user can access via the :ref:`alpha-security-taint-TaintPropagation` checker alias and this checker has a default taint-related configuration.; The built-in default settings are defined in code, and they are always in effect once the checker is enabled, either directly or via the alias.; The checker also provides a configuration interface for extending the default settings by providing a configuration file in `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format.; This documentation describes the syntax of the configuration file and gives the informal semantics of the configuration options. .. contents::; :local:. .. _clangsa-taint-configuration-overview:. Overview; ________. Taint analysis works by checking for the occurrence of special operations during the symbolic execution of the program.; Taint analysis defines sources, sinks, and propagation rules. It identifies errors by detecting a flow of information that originates from a taint source, reaches a taint sink, and propagates through the program paths via propagation rules.; A source, sink, or an operation that propagates taint is mainly domain-specific knowledge, but there are some built-in defaults provided by :ref:`alpha-security-taint-TaintPropagation`.; It is possible to express that a statement sanitizes tainted values by providing a ``Filters`` section in the external configuration (see :ref:`clangsa-taint-configuration-example` and :ref:`clangsa-taint-filter-details`).; There are no default filters defined in the built-in settings.; The checker's documentation also specifies how to provide a custom taint configuration with command-line options. .. _clangsa-taint-configuration-example:. Example configuration file; __________",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:612,Modifiability,extend,extending,612,"============================; Taint Analysis Configuration; ============================. The Clang Static Analyzer uses taint analysis to detect security-related issues in code.; The backbone of taint analysis in the Clang SA is the `GenericTaintChecker`, which the user can access via the :ref:`alpha-security-taint-TaintPropagation` checker alias and this checker has a default taint-related configuration.; The built-in default settings are defined in code, and they are always in effect once the checker is enabled, either directly or via the alias.; The checker also provides a configuration interface for extending the default settings by providing a configuration file in `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format.; This documentation describes the syntax of the configuration file and gives the informal semantics of the configuration options. .. contents::; :local:. .. _clangsa-taint-configuration-overview:. Overview; ________. Taint analysis works by checking for the occurrence of special operations during the symbolic execution of the program.; Taint analysis defines sources, sinks, and propagation rules. It identifies errors by detecting a flow of information that originates from a taint source, reaches a taint sink, and propagates through the program paths via propagation rules.; A source, sink, or an operation that propagates taint is mainly domain-specific knowledge, but there are some built-in defaults provided by :ref:`alpha-security-taint-TaintPropagation`.; It is possible to express that a statement sanitizes tainted values by providing a ``Filters`` section in the external configuration (see :ref:`clangsa-taint-configuration-example` and :ref:`clangsa-taint-filter-details`).; There are no default filters defined in the built-in settings.; The checker's documentation also specifies how to provide a custom taint configuration with command-line options. .. _clangsa-taint-configuration-example:. Example configuration file; __________",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:658,Modifiability,config,configuration,658,"============================; Taint Analysis Configuration; ============================. The Clang Static Analyzer uses taint analysis to detect security-related issues in code.; The backbone of taint analysis in the Clang SA is the `GenericTaintChecker`, which the user can access via the :ref:`alpha-security-taint-TaintPropagation` checker alias and this checker has a default taint-related configuration.; The built-in default settings are defined in code, and they are always in effect once the checker is enabled, either directly or via the alias.; The checker also provides a configuration interface for extending the default settings by providing a configuration file in `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format.; This documentation describes the syntax of the configuration file and gives the informal semantics of the configuration options. .. contents::; :local:. .. _clangsa-taint-configuration-overview:. Overview; ________. Taint analysis works by checking for the occurrence of special operations during the symbolic execution of the program.; Taint analysis defines sources, sinks, and propagation rules. It identifies errors by detecting a flow of information that originates from a taint source, reaches a taint sink, and propagates through the program paths via propagation rules.; A source, sink, or an operation that propagates taint is mainly domain-specific knowledge, but there are some built-in defaults provided by :ref:`alpha-security-taint-TaintPropagation`.; It is possible to express that a statement sanitizes tainted values by providing a ``Filters`` section in the external configuration (see :ref:`clangsa-taint-configuration-example` and :ref:`clangsa-taint-filter-details`).; There are no default filters defined in the built-in settings.; The checker's documentation also specifies how to provide a custom taint configuration with command-line options. .. _clangsa-taint-configuration-example:. Example configuration file; __________",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:800,Modifiability,config,configuration,800,"============================; Taint Analysis Configuration; ============================. The Clang Static Analyzer uses taint analysis to detect security-related issues in code.; The backbone of taint analysis in the Clang SA is the `GenericTaintChecker`, which the user can access via the :ref:`alpha-security-taint-TaintPropagation` checker alias and this checker has a default taint-related configuration.; The built-in default settings are defined in code, and they are always in effect once the checker is enabled, either directly or via the alias.; The checker also provides a configuration interface for extending the default settings by providing a configuration file in `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format.; This documentation describes the syntax of the configuration file and gives the informal semantics of the configuration options. .. contents::; :local:. .. _clangsa-taint-configuration-overview:. Overview; ________. Taint analysis works by checking for the occurrence of special operations during the symbolic execution of the program.; Taint analysis defines sources, sinks, and propagation rules. It identifies errors by detecting a flow of information that originates from a taint source, reaches a taint sink, and propagates through the program paths via propagation rules.; A source, sink, or an operation that propagates taint is mainly domain-specific knowledge, but there are some built-in defaults provided by :ref:`alpha-security-taint-TaintPropagation`.; It is possible to express that a statement sanitizes tainted values by providing a ``Filters`` section in the external configuration (see :ref:`clangsa-taint-configuration-example` and :ref:`clangsa-taint-filter-details`).; There are no default filters defined in the built-in settings.; The checker's documentation also specifies how to provide a custom taint configuration with command-line options. .. _clangsa-taint-configuration-example:. Example configuration file; __________",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:859,Modifiability,config,configuration,859,"============================; Taint Analysis Configuration; ============================. The Clang Static Analyzer uses taint analysis to detect security-related issues in code.; The backbone of taint analysis in the Clang SA is the `GenericTaintChecker`, which the user can access via the :ref:`alpha-security-taint-TaintPropagation` checker alias and this checker has a default taint-related configuration.; The built-in default settings are defined in code, and they are always in effect once the checker is enabled, either directly or via the alias.; The checker also provides a configuration interface for extending the default settings by providing a configuration file in `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format.; This documentation describes the syntax of the configuration file and gives the informal semantics of the configuration options. .. contents::; :local:. .. _clangsa-taint-configuration-overview:. Overview; ________. Taint analysis works by checking for the occurrence of special operations during the symbolic execution of the program.; Taint analysis defines sources, sinks, and propagation rules. It identifies errors by detecting a flow of information that originates from a taint source, reaches a taint sink, and propagates through the program paths via propagation rules.; A source, sink, or an operation that propagates taint is mainly domain-specific knowledge, but there are some built-in defaults provided by :ref:`alpha-security-taint-TaintPropagation`.; It is possible to express that a statement sanitizes tainted values by providing a ``Filters`` section in the external configuration (see :ref:`clangsa-taint-configuration-example` and :ref:`clangsa-taint-filter-details`).; There are no default filters defined in the built-in settings.; The checker's documentation also specifies how to provide a custom taint configuration with command-line options. .. _clangsa-taint-configuration-example:. Example configuration file; __________",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:924,Modifiability,config,configuration-overview,924,"============================; Taint Analysis Configuration; ============================. The Clang Static Analyzer uses taint analysis to detect security-related issues in code.; The backbone of taint analysis in the Clang SA is the `GenericTaintChecker`, which the user can access via the :ref:`alpha-security-taint-TaintPropagation` checker alias and this checker has a default taint-related configuration.; The built-in default settings are defined in code, and they are always in effect once the checker is enabled, either directly or via the alias.; The checker also provides a configuration interface for extending the default settings by providing a configuration file in `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format.; This documentation describes the syntax of the configuration file and gives the informal semantics of the configuration options. .. contents::; :local:. .. _clangsa-taint-configuration-overview:. Overview; ________. Taint analysis works by checking for the occurrence of special operations during the symbolic execution of the program.; Taint analysis defines sources, sinks, and propagation rules. It identifies errors by detecting a flow of information that originates from a taint source, reaches a taint sink, and propagates through the program paths via propagation rules.; A source, sink, or an operation that propagates taint is mainly domain-specific knowledge, but there are some built-in defaults provided by :ref:`alpha-security-taint-TaintPropagation`.; It is possible to express that a statement sanitizes tainted values by providing a ``Filters`` section in the external configuration (see :ref:`clangsa-taint-configuration-example` and :ref:`clangsa-taint-filter-details`).; There are no default filters defined in the built-in settings.; The checker's documentation also specifies how to provide a custom taint configuration with command-line options. .. _clangsa-taint-configuration-example:. Example configuration file; __________",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:1638,Modifiability,config,configuration,1638,"ault settings by providing a configuration file in `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format.; This documentation describes the syntax of the configuration file and gives the informal semantics of the configuration options. .. contents::; :local:. .. _clangsa-taint-configuration-overview:. Overview; ________. Taint analysis works by checking for the occurrence of special operations during the symbolic execution of the program.; Taint analysis defines sources, sinks, and propagation rules. It identifies errors by detecting a flow of information that originates from a taint source, reaches a taint sink, and propagates through the program paths via propagation rules.; A source, sink, or an operation that propagates taint is mainly domain-specific knowledge, but there are some built-in defaults provided by :ref:`alpha-security-taint-TaintPropagation`.; It is possible to express that a statement sanitizes tainted values by providing a ``Filters`` section in the external configuration (see :ref:`clangsa-taint-configuration-example` and :ref:`clangsa-taint-filter-details`).; There are no default filters defined in the built-in settings.; The checker's documentation also specifies how to provide a custom taint configuration with command-line options. .. _clangsa-taint-configuration-example:. Example configuration file; __________________________. .. code-block:: yaml. # The entries that specify arguments use 0-based indexing when specifying; # input arguments, and -1 is used to denote the return value. Filters:; # Filter functions; # Taint is sanitized when tainted variables are pass arguments to filters. # Filter function; # void cleanse_first_arg(int* arg); #; # Result example:; # int x; // x is tainted; # cleanse_first_arg(&x); // x is not tainted after the call; - Name: cleanse_first_arg; Args: [0]. Propagations:; # Source functions; # The omission of SrcArgs key indicates unconditional taint propagation,; # which is conceptually what a sour",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:1677,Modifiability,config,configuration-example,1677,"ault settings by providing a configuration file in `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format.; This documentation describes the syntax of the configuration file and gives the informal semantics of the configuration options. .. contents::; :local:. .. _clangsa-taint-configuration-overview:. Overview; ________. Taint analysis works by checking for the occurrence of special operations during the symbolic execution of the program.; Taint analysis defines sources, sinks, and propagation rules. It identifies errors by detecting a flow of information that originates from a taint source, reaches a taint sink, and propagates through the program paths via propagation rules.; A source, sink, or an operation that propagates taint is mainly domain-specific knowledge, but there are some built-in defaults provided by :ref:`alpha-security-taint-TaintPropagation`.; It is possible to express that a statement sanitizes tainted values by providing a ``Filters`` section in the external configuration (see :ref:`clangsa-taint-configuration-example` and :ref:`clangsa-taint-filter-details`).; There are no default filters defined in the built-in settings.; The checker's documentation also specifies how to provide a custom taint configuration with command-line options. .. _clangsa-taint-configuration-example:. Example configuration file; __________________________. .. code-block:: yaml. # The entries that specify arguments use 0-based indexing when specifying; # input arguments, and -1 is used to denote the return value. Filters:; # Filter functions; # Taint is sanitized when tainted variables are pass arguments to filters. # Filter function; # void cleanse_first_arg(int* arg); #; # Result example:; # int x; // x is tainted; # cleanse_first_arg(&x); // x is not tainted after the call; - Name: cleanse_first_arg; Args: [0]. Propagations:; # Source functions; # The omission of SrcArgs key indicates unconditional taint propagation,; # which is conceptually what a sour",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:1880,Modifiability,config,configuration,1880,"figuration options. .. contents::; :local:. .. _clangsa-taint-configuration-overview:. Overview; ________. Taint analysis works by checking for the occurrence of special operations during the symbolic execution of the program.; Taint analysis defines sources, sinks, and propagation rules. It identifies errors by detecting a flow of information that originates from a taint source, reaches a taint sink, and propagates through the program paths via propagation rules.; A source, sink, or an operation that propagates taint is mainly domain-specific knowledge, but there are some built-in defaults provided by :ref:`alpha-security-taint-TaintPropagation`.; It is possible to express that a statement sanitizes tainted values by providing a ``Filters`` section in the external configuration (see :ref:`clangsa-taint-configuration-example` and :ref:`clangsa-taint-filter-details`).; There are no default filters defined in the built-in settings.; The checker's documentation also specifies how to provide a custom taint configuration with command-line options. .. _clangsa-taint-configuration-example:. Example configuration file; __________________________. .. code-block:: yaml. # The entries that specify arguments use 0-based indexing when specifying; # input arguments, and -1 is used to denote the return value. Filters:; # Filter functions; # Taint is sanitized when tainted variables are pass arguments to filters. # Filter function; # void cleanse_first_arg(int* arg); #; # Result example:; # int x; // x is tainted; # cleanse_first_arg(&x); // x is not tainted after the call; - Name: cleanse_first_arg; Args: [0]. Propagations:; # Source functions; # The omission of SrcArgs key indicates unconditional taint propagation,; # which is conceptually what a source does. # Source function; # size_t fread(void *ptr, size_t size, size_t nmemb, FILE * stream); #; # Result example:; # FILE* f = fopen(""file.txt"");; # char buf[1024];; # size_t read = fread(buf, sizeof(buf[0]), sizeof(buf)/sizeof(bu",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:1939,Modifiability,config,configuration-example,1939,"view:. Overview; ________. Taint analysis works by checking for the occurrence of special operations during the symbolic execution of the program.; Taint analysis defines sources, sinks, and propagation rules. It identifies errors by detecting a flow of information that originates from a taint source, reaches a taint sink, and propagates through the program paths via propagation rules.; A source, sink, or an operation that propagates taint is mainly domain-specific knowledge, but there are some built-in defaults provided by :ref:`alpha-security-taint-TaintPropagation`.; It is possible to express that a statement sanitizes tainted values by providing a ``Filters`` section in the external configuration (see :ref:`clangsa-taint-configuration-example` and :ref:`clangsa-taint-filter-details`).; There are no default filters defined in the built-in settings.; The checker's documentation also specifies how to provide a custom taint configuration with command-line options. .. _clangsa-taint-configuration-example:. Example configuration file; __________________________. .. code-block:: yaml. # The entries that specify arguments use 0-based indexing when specifying; # input arguments, and -1 is used to denote the return value. Filters:; # Filter functions; # Taint is sanitized when tainted variables are pass arguments to filters. # Filter function; # void cleanse_first_arg(int* arg); #; # Result example:; # int x; // x is tainted; # cleanse_first_arg(&x); // x is not tainted after the call; - Name: cleanse_first_arg; Args: [0]. Propagations:; # Source functions; # The omission of SrcArgs key indicates unconditional taint propagation,; # which is conceptually what a source does. # Source function; # size_t fread(void *ptr, size_t size, size_t nmemb, FILE * stream); #; # Result example:; # FILE* f = fopen(""file.txt"");; # char buf[1024];; # size_t read = fread(buf, sizeof(buf[0]), sizeof(buf)/sizeof(buf[0]), f);; # // both read and buf are tainted; - Name: fread; DstArgs: [0, -1].",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:1971,Modifiability,config,configuration,1971,"by checking for the occurrence of special operations during the symbolic execution of the program.; Taint analysis defines sources, sinks, and propagation rules. It identifies errors by detecting a flow of information that originates from a taint source, reaches a taint sink, and propagates through the program paths via propagation rules.; A source, sink, or an operation that propagates taint is mainly domain-specific knowledge, but there are some built-in defaults provided by :ref:`alpha-security-taint-TaintPropagation`.; It is possible to express that a statement sanitizes tainted values by providing a ``Filters`` section in the external configuration (see :ref:`clangsa-taint-configuration-example` and :ref:`clangsa-taint-filter-details`).; There are no default filters defined in the built-in settings.; The checker's documentation also specifies how to provide a custom taint configuration with command-line options. .. _clangsa-taint-configuration-example:. Example configuration file; __________________________. .. code-block:: yaml. # The entries that specify arguments use 0-based indexing when specifying; # input arguments, and -1 is used to denote the return value. Filters:; # Filter functions; # Taint is sanitized when tainted variables are pass arguments to filters. # Filter function; # void cleanse_first_arg(int* arg); #; # Result example:; # int x; // x is tainted; # cleanse_first_arg(&x); // x is not tainted after the call; - Name: cleanse_first_arg; Args: [0]. Propagations:; # Source functions; # The omission of SrcArgs key indicates unconditional taint propagation,; # which is conceptually what a source does. # Source function; # size_t fread(void *ptr, size_t size, size_t nmemb, FILE * stream); #; # Result example:; # FILE* f = fopen(""file.txt"");; # char buf[1024];; # size_t read = fread(buf, sizeof(buf[0]), sizeof(buf)/sizeof(buf[0]), f);; # // both read and buf are tainted; - Name: fread; DstArgs: [0, -1]. # Propagation functions; # The presence of Src",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:2242,Modifiability,variab,variables,2242,"a taint source, reaches a taint sink, and propagates through the program paths via propagation rules.; A source, sink, or an operation that propagates taint is mainly domain-specific knowledge, but there are some built-in defaults provided by :ref:`alpha-security-taint-TaintPropagation`.; It is possible to express that a statement sanitizes tainted values by providing a ``Filters`` section in the external configuration (see :ref:`clangsa-taint-configuration-example` and :ref:`clangsa-taint-filter-details`).; There are no default filters defined in the built-in settings.; The checker's documentation also specifies how to provide a custom taint configuration with command-line options. .. _clangsa-taint-configuration-example:. Example configuration file; __________________________. .. code-block:: yaml. # The entries that specify arguments use 0-based indexing when specifying; # input arguments, and -1 is used to denote the return value. Filters:; # Filter functions; # Taint is sanitized when tainted variables are pass arguments to filters. # Filter function; # void cleanse_first_arg(int* arg); #; # Result example:; # int x; // x is tainted; # cleanse_first_arg(&x); // x is not tainted after the call; - Name: cleanse_first_arg; Args: [0]. Propagations:; # Source functions; # The omission of SrcArgs key indicates unconditional taint propagation,; # which is conceptually what a source does. # Source function; # size_t fread(void *ptr, size_t size, size_t nmemb, FILE * stream); #; # Result example:; # FILE* f = fopen(""file.txt"");; # char buf[1024];; # size_t read = fread(buf, sizeof(buf[0]), sizeof(buf)/sizeof(buf[0]), f);; # // both read and buf are tainted; - Name: fread; DstArgs: [0, -1]. # Propagation functions; # The presence of SrcArgs key indicates conditional taint propagation,; # which is conceptually what a propagator does. # Propagation function; # char *dirname(char *path); #; # Result example:; # char* path = read_path();; # char* dir = dirname(path);; # // di",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:4127,Modifiability,config,configuration,4127,"t example:; # char* path = read_path();; # char* dir = dirname(path);; # // dir is tainted if path was tainted; - Name: dirname; SrcArgs: [0]; DstArgs: [-1]. Sinks:; # Sink functions; # If taint reaches any of the arguments specified, a warning is emitted. # Sink function; # int system(const char* command); #; # Result example:; # const char* command = read_command();; # system(command); // emit diagnostic if command is tainted; - Name: system; Args: [0]. In the example file above, the entries under the `Propagation` key implement the conceptual sources and propagations, and sinks have their dedicated `Sinks` key.; The user can define operations (function calls) where the tainted values should be cleansed by listing entries under the `Filters` key.; Filters model the sanitization of values done by the programmer, and providing these is key to avoiding false-positive findings. Configuration file syntax and semantics; _______________________________________. The configuration file should have valid `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ syntax. The configuration file can have the following top-level keys:; - Filters; - Propagations; - Sinks. Under the `Filters` key, the user can specify a list of operations that remove taint (see :ref:`clangsa-taint-filter-details` for details). Under the `Propagations` key, the user can specify a list of operations that introduce and propagate taint (see :ref:`clangsa-taint-propagation-details` for details).; The user can mark taint sources with a `SrcArgs` key in the `Propagation` key, while propagations have none.; The lack of the `SrcArgs` key means unconditional propagation, which is how sources are modeled.; The semantics of propagations are such, that if any of the source arguments are tainted (specified by indexes in `SrcArgs`) then all of the destination arguments (specified by indexes in `DstArgs`) also become tainted. Under the `Sinks` key, the user can specify a list of operations where the checker ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:4240,Modifiability,config,configuration,4240,"Args: [0]; DstArgs: [-1]. Sinks:; # Sink functions; # If taint reaches any of the arguments specified, a warning is emitted. # Sink function; # int system(const char* command); #; # Result example:; # const char* command = read_command();; # system(command); // emit diagnostic if command is tainted; - Name: system; Args: [0]. In the example file above, the entries under the `Propagation` key implement the conceptual sources and propagations, and sinks have their dedicated `Sinks` key.; The user can define operations (function calls) where the tainted values should be cleansed by listing entries under the `Filters` key.; Filters model the sanitization of values done by the programmer, and providing these is key to avoiding false-positive findings. Configuration file syntax and semantics; _______________________________________. The configuration file should have valid `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ syntax. The configuration file can have the following top-level keys:; - Filters; - Propagations; - Sinks. Under the `Filters` key, the user can specify a list of operations that remove taint (see :ref:`clangsa-taint-filter-details` for details). Under the `Propagations` key, the user can specify a list of operations that introduce and propagate taint (see :ref:`clangsa-taint-propagation-details` for details).; The user can mark taint sources with a `SrcArgs` key in the `Propagation` key, while propagations have none.; The lack of the `SrcArgs` key means unconditional propagation, which is how sources are modeled.; The semantics of propagations are such, that if any of the source arguments are tainted (specified by indexes in `SrcArgs`) then all of the destination arguments (specified by indexes in `DstArgs`) also become tainted. Under the `Sinks` key, the user can specify a list of operations where the checker should emit a bug report if tainted data reaches it (see :ref:`clangsa-taint-sink-details` for details). .. _clangsa-taint-filter-de",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:139,Safety,detect,detect,139,"============================; Taint Analysis Configuration; ============================. The Clang Static Analyzer uses taint analysis to detect security-related issues in code.; The backbone of taint analysis in the Clang SA is the `GenericTaintChecker`, which the user can access via the :ref:`alpha-security-taint-TaintPropagation` checker alias and this checker has a default taint-related configuration.; The built-in default settings are defined in code, and they are always in effect once the checker is enabled, either directly or via the alias.; The checker also provides a configuration interface for extending the default settings by providing a configuration file in `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format.; This documentation describes the syntax of the configuration file and gives the informal semantics of the configuration options. .. contents::; :local:. .. _clangsa-taint-configuration-overview:. Overview; ________. Taint analysis works by checking for the occurrence of special operations during the symbolic execution of the program.; Taint analysis defines sources, sinks, and propagation rules. It identifies errors by detecting a flow of information that originates from a taint source, reaches a taint sink, and propagates through the program paths via propagation rules.; A source, sink, or an operation that propagates taint is mainly domain-specific knowledge, but there are some built-in defaults provided by :ref:`alpha-security-taint-TaintPropagation`.; It is possible to express that a statement sanitizes tainted values by providing a ``Filters`` section in the external configuration (see :ref:`clangsa-taint-configuration-example` and :ref:`clangsa-taint-filter-details`).; There are no default filters defined in the built-in settings.; The checker's documentation also specifies how to provide a custom taint configuration with command-line options. .. _clangsa-taint-configuration-example:. Example configuration file; __________",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:1176,Safety,detect,detecting,1176,"icTaintChecker`, which the user can access via the :ref:`alpha-security-taint-TaintPropagation` checker alias and this checker has a default taint-related configuration.; The built-in default settings are defined in code, and they are always in effect once the checker is enabled, either directly or via the alias.; The checker also provides a configuration interface for extending the default settings by providing a configuration file in `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format.; This documentation describes the syntax of the configuration file and gives the informal semantics of the configuration options. .. contents::; :local:. .. _clangsa-taint-configuration-overview:. Overview; ________. Taint analysis works by checking for the occurrence of special operations during the symbolic execution of the program.; Taint analysis defines sources, sinks, and propagation rules. It identifies errors by detecting a flow of information that originates from a taint source, reaches a taint sink, and propagates through the program paths via propagation rules.; A source, sink, or an operation that propagates taint is mainly domain-specific knowledge, but there are some built-in defaults provided by :ref:`alpha-security-taint-TaintPropagation`.; It is possible to express that a statement sanitizes tainted values by providing a ``Filters`` section in the external configuration (see :ref:`clangsa-taint-configuration-example` and :ref:`clangsa-taint-filter-details`).; There are no default filters defined in the built-in settings.; The checker's documentation also specifies how to provide a custom taint configuration with command-line options. .. _clangsa-taint-configuration-example:. Example configuration file; __________________________. .. code-block:: yaml. # The entries that specify arguments use 0-based indexing when specifying; # input arguments, and -1 is used to denote the return value. Filters:; # Filter functions; # Taint is sanitized when tainted",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:4007,Safety,avoid,avoiding,4007,"presence of SrcArgs key indicates conditional taint propagation,; # which is conceptually what a propagator does. # Propagation function; # char *dirname(char *path); #; # Result example:; # char* path = read_path();; # char* dir = dirname(path);; # // dir is tainted if path was tainted; - Name: dirname; SrcArgs: [0]; DstArgs: [-1]. Sinks:; # Sink functions; # If taint reaches any of the arguments specified, a warning is emitted. # Sink function; # int system(const char* command); #; # Result example:; # const char* command = read_command();; # system(command); // emit diagnostic if command is tainted; - Name: system; Args: [0]. In the example file above, the entries under the `Propagation` key implement the conceptual sources and propagations, and sinks have their dedicated `Sinks` key.; The user can define operations (function calls) where the tainted values should be cleansed by listing entries under the `Filters` key.; Filters model the sanitization of values done by the programmer, and providing these is key to avoiding false-positive findings. Configuration file syntax and semantics; _______________________________________. The configuration file should have valid `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ syntax. The configuration file can have the following top-level keys:; - Filters; - Propagations; - Sinks. Under the `Filters` key, the user can specify a list of operations that remove taint (see :ref:`clangsa-taint-filter-details` for details). Under the `Propagations` key, the user can specify a list of operations that introduce and propagate taint (see :ref:`clangsa-taint-propagation-details` for details).; The user can mark taint sources with a `SrcArgs` key in the `Propagation` key, while propagations have none.; The lack of the `SrcArgs` key means unconditional propagation, which is how sources are modeled.; The semantics of propagations are such, that if any of the source arguments are tainted (specified by indexes in `SrcArgs`) ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:8290,Safety,redund,redundant,8290,"d, the checker will consider all `DstArgs` arguments tainted after the call.; - `DstArgs` is a list of numbers in the range of ``[-1..int_max]`` that indicates the indexes of arguments in the function call.; The number ``-1`` specifies the return value of the function.; If any `SrcArgs` arguments are tainted, the checker will consider all `DstArgs` arguments tainted after the call.; - `VariadicType` is a string that can be one of ``None``, ``Dst``, ``Src``.; It is used in conjunction with `VariadicIndex` to specify arguments inside a variadic argument.; The value of ``Src`` will treat every call site argument that is part of a variadic argument list as a source concerning propagation rules (as if specified by `SrcArg`).; The value of ``Dst`` will treat every call site argument that is part of a variadic argument list a destination concerning propagation rules.; The value of ``None`` will not consider the arguments that are part of a variadic argument list (this option is redundant but can be used to temporarily switch off handling of a particular variadic argument option without removing the VariadicIndex key).; - `VariadicIndex` is a number in the range of ``[0..int_max]``. It indicates the starting index of the variadic argument in the signature of the function. .. _clangsa-taint-sink-details:. Sink syntax and semantics; #########################. An entry under `Sinks` is a `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ object with the following mandatory keys:; - `Name` is a string that specifies the name of a function.; Encountering this function during symbolic execution will emit a taint-related diagnostic if any of the arguments specified with `Args` are tainted at the call site.; - `Args` is a list of numbers in the range of ``[0..int_max]`` that indicates the indexes of arguments in the function call.; The checker reports an error if any of the specified arguments are tainted. The following keys are optional:; - `Scope` is a string that sp",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:146,Security,secur,security-related,146,"============================; Taint Analysis Configuration; ============================. The Clang Static Analyzer uses taint analysis to detect security-related issues in code.; The backbone of taint analysis in the Clang SA is the `GenericTaintChecker`, which the user can access via the :ref:`alpha-security-taint-TaintPropagation` checker alias and this checker has a default taint-related configuration.; The built-in default settings are defined in code, and they are always in effect once the checker is enabled, either directly or via the alias.; The checker also provides a configuration interface for extending the default settings by providing a configuration file in `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format.; This documentation describes the syntax of the configuration file and gives the informal semantics of the configuration options. .. contents::; :local:. .. _clangsa-taint-configuration-overview:. Overview; ________. Taint analysis works by checking for the occurrence of special operations during the symbolic execution of the program.; Taint analysis defines sources, sinks, and propagation rules. It identifies errors by detecting a flow of information that originates from a taint source, reaches a taint sink, and propagates through the program paths via propagation rules.; A source, sink, or an operation that propagates taint is mainly domain-specific knowledge, but there are some built-in defaults provided by :ref:`alpha-security-taint-TaintPropagation`.; It is possible to express that a statement sanitizes tainted values by providing a ``Filters`` section in the external configuration (see :ref:`clangsa-taint-configuration-example` and :ref:`clangsa-taint-filter-details`).; There are no default filters defined in the built-in settings.; The checker's documentation also specifies how to provide a custom taint configuration with command-line options. .. _clangsa-taint-configuration-example:. Example configuration file; __________",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:276,Security,access,access,276,"============================; Taint Analysis Configuration; ============================. The Clang Static Analyzer uses taint analysis to detect security-related issues in code.; The backbone of taint analysis in the Clang SA is the `GenericTaintChecker`, which the user can access via the :ref:`alpha-security-taint-TaintPropagation` checker alias and this checker has a default taint-related configuration.; The built-in default settings are defined in code, and they are always in effect once the checker is enabled, either directly or via the alias.; The checker also provides a configuration interface for extending the default settings by providing a configuration file in `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format.; This documentation describes the syntax of the configuration file and gives the informal semantics of the configuration options. .. contents::; :local:. .. _clangsa-taint-configuration-overview:. Overview; ________. Taint analysis works by checking for the occurrence of special operations during the symbolic execution of the program.; Taint analysis defines sources, sinks, and propagation rules. It identifies errors by detecting a flow of information that originates from a taint source, reaches a taint sink, and propagates through the program paths via propagation rules.; A source, sink, or an operation that propagates taint is mainly domain-specific knowledge, but there are some built-in defaults provided by :ref:`alpha-security-taint-TaintPropagation`.; It is possible to express that a statement sanitizes tainted values by providing a ``Filters`` section in the external configuration (see :ref:`clangsa-taint-configuration-example` and :ref:`clangsa-taint-filter-details`).; There are no default filters defined in the built-in settings.; The checker's documentation also specifies how to provide a custom taint configuration with command-line options. .. _clangsa-taint-configuration-example:. Example configuration file; __________",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:303,Security,secur,security-taint-TaintPropagation,303,"============================; Taint Analysis Configuration; ============================. The Clang Static Analyzer uses taint analysis to detect security-related issues in code.; The backbone of taint analysis in the Clang SA is the `GenericTaintChecker`, which the user can access via the :ref:`alpha-security-taint-TaintPropagation` checker alias and this checker has a default taint-related configuration.; The built-in default settings are defined in code, and they are always in effect once the checker is enabled, either directly or via the alias.; The checker also provides a configuration interface for extending the default settings by providing a configuration file in `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format.; This documentation describes the syntax of the configuration file and gives the informal semantics of the configuration options. .. contents::; :local:. .. _clangsa-taint-configuration-overview:. Overview; ________. Taint analysis works by checking for the occurrence of special operations during the symbolic execution of the program.; Taint analysis defines sources, sinks, and propagation rules. It identifies errors by detecting a flow of information that originates from a taint source, reaches a taint sink, and propagates through the program paths via propagation rules.; A source, sink, or an operation that propagates taint is mainly domain-specific knowledge, but there are some built-in defaults provided by :ref:`alpha-security-taint-TaintPropagation`.; It is possible to express that a statement sanitizes tainted values by providing a ``Filters`` section in the external configuration (see :ref:`clangsa-taint-configuration-example` and :ref:`clangsa-taint-filter-details`).; There are no default filters defined in the built-in settings.; The checker's documentation also specifies how to provide a custom taint configuration with command-line options. .. _clangsa-taint-configuration-example:. Example configuration file; __________",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:1484,Security,secur,security-taint-TaintPropagation,1484," default settings are defined in code, and they are always in effect once the checker is enabled, either directly or via the alias.; The checker also provides a configuration interface for extending the default settings by providing a configuration file in `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format.; This documentation describes the syntax of the configuration file and gives the informal semantics of the configuration options. .. contents::; :local:. .. _clangsa-taint-configuration-overview:. Overview; ________. Taint analysis works by checking for the occurrence of special operations during the symbolic execution of the program.; Taint analysis defines sources, sinks, and propagation rules. It identifies errors by detecting a flow of information that originates from a taint source, reaches a taint sink, and propagates through the program paths via propagation rules.; A source, sink, or an operation that propagates taint is mainly domain-specific knowledge, but there are some built-in defaults provided by :ref:`alpha-security-taint-TaintPropagation`.; It is possible to express that a statement sanitizes tainted values by providing a ``Filters`` section in the external configuration (see :ref:`clangsa-taint-configuration-example` and :ref:`clangsa-taint-filter-details`).; There are no default filters defined in the built-in settings.; The checker's documentation also specifies how to provide a custom taint configuration with command-line options. .. _clangsa-taint-configuration-example:. Example configuration file; __________________________. .. code-block:: yaml. # The entries that specify arguments use 0-based indexing when specifying; # input arguments, and -1 is used to denote the return value. Filters:; # Filter functions; # Taint is sanitized when tainted variables are pass arguments to filters. # Filter function; # void cleanse_first_arg(int* arg); #; # Result example:; # int x; // x is tainted; # cleanse_first_arg(&x); // x is not t",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:1562,Security,sanitiz,sanitizes,1562,"ault settings by providing a configuration file in `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ format.; This documentation describes the syntax of the configuration file and gives the informal semantics of the configuration options. .. contents::; :local:. .. _clangsa-taint-configuration-overview:. Overview; ________. Taint analysis works by checking for the occurrence of special operations during the symbolic execution of the program.; Taint analysis defines sources, sinks, and propagation rules. It identifies errors by detecting a flow of information that originates from a taint source, reaches a taint sink, and propagates through the program paths via propagation rules.; A source, sink, or an operation that propagates taint is mainly domain-specific knowledge, but there are some built-in defaults provided by :ref:`alpha-security-taint-TaintPropagation`.; It is possible to express that a statement sanitizes tainted values by providing a ``Filters`` section in the external configuration (see :ref:`clangsa-taint-configuration-example` and :ref:`clangsa-taint-filter-details`).; There are no default filters defined in the built-in settings.; The checker's documentation also specifies how to provide a custom taint configuration with command-line options. .. _clangsa-taint-configuration-example:. Example configuration file; __________________________. .. code-block:: yaml. # The entries that specify arguments use 0-based indexing when specifying; # input arguments, and -1 is used to denote the return value. Filters:; # Filter functions; # Taint is sanitized when tainted variables are pass arguments to filters. # Filter function; # void cleanse_first_arg(int* arg); #; # Result example:; # int x; // x is tainted; # cleanse_first_arg(&x); // x is not tainted after the call; - Name: cleanse_first_arg; Args: [0]. Propagations:; # Source functions; # The omission of SrcArgs key indicates unconditional taint propagation,; # which is conceptually what a sour",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:2219,Security,sanitiz,sanitized,2219,"a taint source, reaches a taint sink, and propagates through the program paths via propagation rules.; A source, sink, or an operation that propagates taint is mainly domain-specific knowledge, but there are some built-in defaults provided by :ref:`alpha-security-taint-TaintPropagation`.; It is possible to express that a statement sanitizes tainted values by providing a ``Filters`` section in the external configuration (see :ref:`clangsa-taint-configuration-example` and :ref:`clangsa-taint-filter-details`).; There are no default filters defined in the built-in settings.; The checker's documentation also specifies how to provide a custom taint configuration with command-line options. .. _clangsa-taint-configuration-example:. Example configuration file; __________________________. .. code-block:: yaml. # The entries that specify arguments use 0-based indexing when specifying; # input arguments, and -1 is used to denote the return value. Filters:; # Filter functions; # Taint is sanitized when tainted variables are pass arguments to filters. # Filter function; # void cleanse_first_arg(int* arg); #; # Result example:; # int x; // x is tainted; # cleanse_first_arg(&x); // x is not tainted after the call; - Name: cleanse_first_arg; Args: [0]. Propagations:; # Source functions; # The omission of SrcArgs key indicates unconditional taint propagation,; # which is conceptually what a source does. # Source function; # size_t fread(void *ptr, size_t size, size_t nmemb, FILE * stream); #; # Result example:; # FILE* f = fopen(""file.txt"");; # char buf[1024];; # size_t read = fread(buf, sizeof(buf[0]), sizeof(buf)/sizeof(buf[0]), f);; # // both read and buf are tainted; - Name: fread; DstArgs: [0, -1]. # Propagation functions; # The presence of SrcArgs key indicates conditional taint propagation,; # which is conceptually what a propagator does. # Propagation function; # char *dirname(char *path); #; # Result example:; # char* path = read_path();; # char* dir = dirname(path);; # // di",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:3930,Security,sanitiz,sanitization,3930,"presence of SrcArgs key indicates conditional taint propagation,; # which is conceptually what a propagator does. # Propagation function; # char *dirname(char *path); #; # Result example:; # char* path = read_path();; # char* dir = dirname(path);; # // dir is tainted if path was tainted; - Name: dirname; SrcArgs: [0]; DstArgs: [-1]. Sinks:; # Sink functions; # If taint reaches any of the arguments specified, a warning is emitted. # Sink function; # int system(const char* command); #; # Result example:; # const char* command = read_command();; # system(command); // emit diagnostic if command is tainted; - Name: system; Args: [0]. In the example file above, the entries under the `Propagation` key implement the conceptual sources and propagations, and sinks have their dedicated `Sinks` key.; The user can define operations (function calls) where the tainted values should be cleansed by listing entries under the `Filters` key.; Filters model the sanitization of values done by the programmer, and providing these is key to avoiding false-positive findings. Configuration file syntax and semantics; _______________________________________. The configuration file should have valid `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ syntax. The configuration file can have the following top-level keys:; - Filters; - Propagations; - Sinks. Under the `Filters` key, the user can specify a list of operations that remove taint (see :ref:`clangsa-taint-filter-details` for details). Under the `Propagations` key, the user can specify a list of operations that introduce and propagate taint (see :ref:`clangsa-taint-propagation-details` for details).; The user can mark taint sources with a `SrcArgs` key in the `Propagation` key, while propagations have none.; The lack of the `SrcArgs` key means unconditional propagation, which is how sources are modeled.; The semantics of propagations are such, that if any of the source arguments are tainted (specified by indexes in `SrcArgs`) ",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:5619,Security,sanitiz,sanitize,5619,"etails).; The user can mark taint sources with a `SrcArgs` key in the `Propagation` key, while propagations have none.; The lack of the `SrcArgs` key means unconditional propagation, which is how sources are modeled.; The semantics of propagations are such, that if any of the source arguments are tainted (specified by indexes in `SrcArgs`) then all of the destination arguments (specified by indexes in `DstArgs`) also become tainted. Under the `Sinks` key, the user can specify a list of operations where the checker should emit a bug report if tainted data reaches it (see :ref:`clangsa-taint-sink-details` for details). .. _clangsa-taint-filter-details:. Filter syntax and semantics; ###########################. An entry under `Filters` is a `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ object with the following mandatory keys:; - `Name` is a string that specifies the name of a function.; Encountering this function during symbolic execution the checker will sanitize taint from the memory region referred to by the given arguments or return a sanitized value.; - `Args` is a list of numbers in the range of ``[-1..int_max]``.; It indicates the indexes of arguments in the function call.; The number ``-1`` signifies the return value; other numbers identify call arguments.; The values of these arguments are considered clean after the function call. The following keys are optional:; - `Scope` is a string that specifies the prefix of the function's name in its fully qualified name. This option restricts the set of matching function calls. It can encode not only namespaces but struct/class names as well to match member functions. .. _clangsa-taint-propagation-details:. Propagation syntax and semantics; ################################. An entry under `Propagation` is a `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ object with the following mandatory keys:; - `Name` is a string that specifies the name of a function.; Encountering this function du",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst:5704,Security,sanitiz,sanitized,5704,"etails).; The user can mark taint sources with a `SrcArgs` key in the `Propagation` key, while propagations have none.; The lack of the `SrcArgs` key means unconditional propagation, which is how sources are modeled.; The semantics of propagations are such, that if any of the source arguments are tainted (specified by indexes in `SrcArgs`) then all of the destination arguments (specified by indexes in `DstArgs`) also become tainted. Under the `Sinks` key, the user can specify a list of operations where the checker should emit a bug report if tainted data reaches it (see :ref:`clangsa-taint-sink-details` for details). .. _clangsa-taint-filter-details:. Filter syntax and semantics; ###########################. An entry under `Filters` is a `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ object with the following mandatory keys:; - `Name` is a string that specifies the name of a function.; Encountering this function during symbolic execution the checker will sanitize taint from the memory region referred to by the given arguments or return a sanitized value.; - `Args` is a list of numbers in the range of ``[-1..int_max]``.; It indicates the indexes of arguments in the function call.; The number ``-1`` signifies the return value; other numbers identify call arguments.; The values of these arguments are considered clean after the function call. The following keys are optional:; - `Scope` is a string that specifies the prefix of the function's name in its fully qualified name. This option restricts the set of matching function calls. It can encode not only namespaces but struct/class names as well to match member functions. .. _clangsa-taint-propagation-details:. Propagation syntax and semantics; ################################. An entry under `Propagation` is a `YAML <http://llvm.org/docs/YamlIO.html#introduction-to-yaml>`_ object with the following mandatory keys:; - `Name` is a string that specifies the name of a function.; Encountering this function du",MatchSource.DOCS,interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/clang/docs/analyzer/user-docs/TaintAnalysisConfiguration.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst:1758,Availability,avail,available,1758,"LVM IR attributes and their relation to the C/C++; level ACLE attributes:. ``aarch64_pstate_sm_enabled``; is used for functions with ``__attribute__((arm_streaming))``. ``aarch64_pstate_sm_compatible``; is used for functions with ``__attribute__((arm_streaming_compatible))``. ``aarch64_pstate_sm_body``; is used for functions with ``__attribute__((arm_locally_streaming))`` and is; only valid on function definitions (not declarations). ``aarch64_pstate_za_new``; is used for functions with ``__attribute__((arm_new_za))``. ``aarch64_pstate_za_shared``; is used for functions with ``__attribute__((arm_shared_za))``. ``aarch64_pstate_za_preserved``; is used for functions with ``__attribute__((arm_preserves_za))``. ``aarch64_expanded_pstate_za``; is used for functions with ``__attribute__((arm_new_za))``. Clang must ensure that the above attributes are added both to the; function's declaration/definition as well as to their call-sites. This is; important for calls to attributed function pointers, where there is no; definition or declaration available. 2. Handling PSTATE.SM; =====================. When changing PSTATE.SM the execution of FP/vector operations may be transferred; to another processing element. This has three important implications:. * The runtime SVE vector length may change. * The contents of FP/AdvSIMD/SVE registers are zeroed. * The set of allowable instructions changes. This leads to certain restrictions on IR and optimizations. For example, it; is undefined behaviour to share vector-length dependent state between functions; that may operate with different values for PSTATE.SM. Front-ends must honour; these restrictions when generating LLVM IR. Even though the runtime SVE vector length may change, for the purpose of LLVM IR; and almost all parts of CodeGen we can assume that the runtime value for; ``vscale`` does not. If we let the compiler insert the appropriate ``smstart``; and ``smstop`` instructions around call boundaries, then the effects on SVE; stat",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AArch64SME.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst:7791,Availability,mask,masks,7791,"nabled""; ret float %res; }. declare float @bar(float) ""aarch64_pstate_sm_enabled"". The program needs to preserve the value of the floating point argument and; return value in register ``s0``:. .. code-block:: none. foo: // @foo; // %bb.0:; stp d15, d14, [sp, #-80]! // 16-byte Folded Spill; stp d13, d12, [sp, #16] // 16-byte Folded Spill; stp d11, d10, [sp, #32] // 16-byte Folded Spill; stp d9, d8, [sp, #48] // 16-byte Folded Spill; str x30, [sp, #64] // 8-byte Folded Spill; str s0, [sp, #76] // 4-byte Folded Spill; smstart sm; ldr s0, [sp, #76] // 4-byte Folded Reload; bl bar; str s0, [sp, #76] // 4-byte Folded Spill; smstop sm; ldp d9, d8, [sp, #48] // 16-byte Folded Reload; ldp d11, d10, [sp, #32] // 16-byte Folded Reload; ldp d13, d12, [sp, #16] // 16-byte Folded Reload; ldr s0, [sp, #76] // 4-byte Folded Reload; ldr x30, [sp, #64] // 8-byte Folded Reload; ldp d15, d14, [sp], #80 // 16-byte Folded Reload; ret. Setting the correct register masks on the ISD nodes and inserting the; ``smstart/smstop`` in the right places should ensure this is done correctly. Instruction Selection Nodes; ---------------------------. .. code-block:: none. AArch64ISD::SMSTART Chain, [SM|ZA|Both], CurrentState, ExpectedState[, RegMask]; AArch64ISD::SMSTOP Chain, [SM|ZA|Both], CurrentState, ExpectedState[, RegMask]. The ``SMSTART/SMSTOP`` nodes take ``CurrentState`` and ``ExpectedState`` operand for; the case of a conditional SMSTART/SMSTOP. The instruction will only be executed; if CurrentState != ExpectedState. When ``CurrentState`` and ``ExpectedState`` can be evaluated at compile-time; (i.e. they are both constants) then an unconditional ``smstart/smstop``; instruction is emitted. Otherwise the node is matched to a Pseudo instruction; which expands to a compare/branch and a ``smstart/smstop``. This is necessary to; implement transitions from ``SC -> N`` and ``SC -> S``. Unchained Function calls; ------------------------; When a function with ""``aarch64_pstate_sm_enabled``"" calls a fu",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AArch64SME.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst:15201,Availability,avail,available,15201," Folded Reload; ldp d13, d12, [sp, #16] // 16-byte Folded Reload; ldr x28, [sp, #80] // 8-byte Folded Reload; ldp d15, d14, [sp], #96 // 16-byte Folded Reload; ret. Preventing the use of illegal instructions in Streaming Mode; ------------------------------------------------------------. * When executing a program in streaming-mode (PSTATE.SM=1) a subset of SVE/SVE2; instructions and most AdvSIMD/NEON instructions are invalid. * When executing a program in normal mode (PSTATE.SM=0), a subset of SME; instructions are invalid. * Streaming-compatible functions must only use instructions that are valid when; either PSTATE.SM=0 or PSTATE.SM=1. The value of PSTATE.SM is not controlled by the feature flags, but rather by the; function attributes. This means that we can compile for '``+sme``' and the compiler; will code-generate any instructions, even if they are not legal under the requested; streaming mode. The compiler needs to use the function attributes to ensure the; compiler doesn't do transformations under the assumption that certain operations; are available at runtime. We made a conscious choice not to model this with feature flags, because we; still want to support inline-asm in either mode (with the user placing; smstart/smstop manually), and this became rather complicated to implement at the; individual instruction level (see `D120261 <https://reviews.llvm.org/D120261>`_; and `D121208 <https://reviews.llvm.org/D121208>`_) because of limitations in; TableGen. As a first step, this means we'll disable vectorization (LoopVectorize/SLP); entirely when the a function has either of the ``aarch64_pstate_sm_enabled``,; ``aarch64_pstate_sm_body`` or ``aarch64_pstate_sm_compatible`` attributes,; in order to avoid the use of vector instructions. Later on we'll aim to relax these restrictions to enable scalable; auto-vectorization with a subset of streaming-compatible instructions, but that; requires changes to the CostModel, Legalization and SelectionDAG lowering. We will ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AArch64SME.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst:17965,Availability,mask,mask,17965,"ion must be disabled when the call-site needs to toggle; PSTATE.SM, such that the caller can restore the original value of PSTATE.SM. 3. Handling PSTATE.ZA; =====================. In contrast to PSTATE.SM, enabling PSTATE.ZA does not affect the SVE vector; length and also doesn't clobber FP/AdvSIMD/SVE registers. This means it is safe; to toggle PSTATE.ZA using intrinsics. This also makes it simpler to setup a; lazy-save mechanism for calls to private-ZA functions (i.e. functions that may; either directly or indirectly clobber ZA state). For the purpose of handling functions marked with ``aarch64_pstate_za_new``,; we have introduced a new LLVM IR pass (SMEABIPass) that is run just before; SelectionDAG. Any such functions dealt with by this pass are marked with; ``aarch64_expanded_pstate_za``. Setting up a lazy-save; ----------------------. Committing a lazy-save; ----------------------. Exception handling and ZA; -------------------------. 4. Types; ========. AArch64 Predicate-as-Counter Type; ---------------------------------. :Overview:. The predicate-as-counter type represents the type of a predicate-as-counter; value held in a AArch64 SVE predicate register. Such a value contains; information about the number of active lanes, the element width and a bit that; tells whether the generated mask should be inverted. ACLE intrinsics should be; used to move the predicate-as-counter value to/from a predicate vector. There are certain limitations on the type:. * The type can be used for function parameters and return values. * The supported LLVM operations on this type are limited to ``load``, ``store``,; ``phi``, ``select`` and ``alloca`` instructions. The predicate-as-counter type is a scalable type. :Syntax:. ::. target(""aarch64.svcount""). 5. References; =============. .. _aarch64_sme_acle:. 1. `SME ACLE Pull-request <https://github.com/ARM-software/acle/pull/188>`__. .. _aarch64_sme_abi:. 2. `SME ABI Pull-request <https://github.com/ARM-software/abi-aa/pull/123>`__; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AArch64SME.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst:16433,Deployability,toggle,toggle,16433,"me rather complicated to implement at the; individual instruction level (see `D120261 <https://reviews.llvm.org/D120261>`_; and `D121208 <https://reviews.llvm.org/D121208>`_) because of limitations in; TableGen. As a first step, this means we'll disable vectorization (LoopVectorize/SLP); entirely when the a function has either of the ``aarch64_pstate_sm_enabled``,; ``aarch64_pstate_sm_body`` or ``aarch64_pstate_sm_compatible`` attributes,; in order to avoid the use of vector instructions. Later on we'll aim to relax these restrictions to enable scalable; auto-vectorization with a subset of streaming-compatible instructions, but that; requires changes to the CostModel, Legalization and SelectionDAG lowering. We will also emit diagnostics in Clang to prevent the use of; non-streaming(-compatible) operations, e.g. through ACLE intrinsics, when a; function is decorated with the streaming mode attributes. Other things to consider; ------------------------. * Inlining must be disabled when the call-site needs to toggle PSTATE.SM or; when the callee's function body is executed in a different streaming mode than; its caller. This is needed because function calls are the boundaries for; streaming mode changes. * Tail call optimization must be disabled when the call-site needs to toggle; PSTATE.SM, such that the caller can restore the original value of PSTATE.SM. 3. Handling PSTATE.ZA; =====================. In contrast to PSTATE.SM, enabling PSTATE.ZA does not affect the SVE vector; length and also doesn't clobber FP/AdvSIMD/SVE registers. This means it is safe; to toggle PSTATE.ZA using intrinsics. This also makes it simpler to setup a; lazy-save mechanism for calls to private-ZA functions (i.e. functions that may; either directly or indirectly clobber ZA state). For the purpose of handling functions marked with ``aarch64_pstate_za_new``,; we have introduced a new LLVM IR pass (SMEABIPass) that is run just before; SelectionDAG. Any such functions dealt with by this pass are ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AArch64SME.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst:16702,Deployability,toggle,toggle,16702,"tion (LoopVectorize/SLP); entirely when the a function has either of the ``aarch64_pstate_sm_enabled``,; ``aarch64_pstate_sm_body`` or ``aarch64_pstate_sm_compatible`` attributes,; in order to avoid the use of vector instructions. Later on we'll aim to relax these restrictions to enable scalable; auto-vectorization with a subset of streaming-compatible instructions, but that; requires changes to the CostModel, Legalization and SelectionDAG lowering. We will also emit diagnostics in Clang to prevent the use of; non-streaming(-compatible) operations, e.g. through ACLE intrinsics, when a; function is decorated with the streaming mode attributes. Other things to consider; ------------------------. * Inlining must be disabled when the call-site needs to toggle PSTATE.SM or; when the callee's function body is executed in a different streaming mode than; its caller. This is needed because function calls are the boundaries for; streaming mode changes. * Tail call optimization must be disabled when the call-site needs to toggle; PSTATE.SM, such that the caller can restore the original value of PSTATE.SM. 3. Handling PSTATE.ZA; =====================. In contrast to PSTATE.SM, enabling PSTATE.ZA does not affect the SVE vector; length and also doesn't clobber FP/AdvSIMD/SVE registers. This means it is safe; to toggle PSTATE.ZA using intrinsics. This also makes it simpler to setup a; lazy-save mechanism for calls to private-ZA functions (i.e. functions that may; either directly or indirectly clobber ZA state). For the purpose of handling functions marked with ``aarch64_pstate_za_new``,; we have introduced a new LLVM IR pass (SMEABIPass) that is run just before; SelectionDAG. Any such functions dealt with by this pass are marked with; ``aarch64_expanded_pstate_za``. Setting up a lazy-save; ----------------------. Committing a lazy-save; ----------------------. Exception handling and ZA; -------------------------. 4. Types; ========. AArch64 Predicate-as-Counter Type; ------------",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AArch64SME.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst:16994,Deployability,toggle,toggle,16994,"ion with a subset of streaming-compatible instructions, but that; requires changes to the CostModel, Legalization and SelectionDAG lowering. We will also emit diagnostics in Clang to prevent the use of; non-streaming(-compatible) operations, e.g. through ACLE intrinsics, when a; function is decorated with the streaming mode attributes. Other things to consider; ------------------------. * Inlining must be disabled when the call-site needs to toggle PSTATE.SM or; when the callee's function body is executed in a different streaming mode than; its caller. This is needed because function calls are the boundaries for; streaming mode changes. * Tail call optimization must be disabled when the call-site needs to toggle; PSTATE.SM, such that the caller can restore the original value of PSTATE.SM. 3. Handling PSTATE.ZA; =====================. In contrast to PSTATE.SM, enabling PSTATE.ZA does not affect the SVE vector; length and also doesn't clobber FP/AdvSIMD/SVE registers. This means it is safe; to toggle PSTATE.ZA using intrinsics. This also makes it simpler to setup a; lazy-save mechanism for calls to private-ZA functions (i.e. functions that may; either directly or indirectly clobber ZA state). For the purpose of handling functions marked with ``aarch64_pstate_za_new``,; we have introduced a new LLVM IR pass (SMEABIPass) that is run just before; SelectionDAG. Any such functions dealt with by this pass are marked with; ``aarch64_expanded_pstate_za``. Setting up a lazy-save; ----------------------. Committing a lazy-save; ----------------------. Exception handling and ZA; -------------------------. 4. Types; ========. AArch64 Predicate-as-Counter Type; ---------------------------------. :Overview:. The predicate-as-counter type represents the type of a predicate-as-counter; value held in a AArch64 SVE predicate register. Such a value contains; information about the number of active lanes, the element width and a bit that; tells whether the generated mask should be inverted",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AArch64SME.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst:2837,Energy Efficiency,schedul,scheduled,2837," changing PSTATE.SM the execution of FP/vector operations may be transferred; to another processing element. This has three important implications:. * The runtime SVE vector length may change. * The contents of FP/AdvSIMD/SVE registers are zeroed. * The set of allowable instructions changes. This leads to certain restrictions on IR and optimizations. For example, it; is undefined behaviour to share vector-length dependent state between functions; that may operate with different values for PSTATE.SM. Front-ends must honour; these restrictions when generating LLVM IR. Even though the runtime SVE vector length may change, for the purpose of LLVM IR; and almost all parts of CodeGen we can assume that the runtime value for; ``vscale`` does not. If we let the compiler insert the appropriate ``smstart``; and ``smstop`` instructions around call boundaries, then the effects on SVE; state can be mitigated. By limiting the state changes to a very brief window; around the call we can control how the operations are scheduled and how live; values remain preserved between state transitions. In order to control PSTATE.SM at this level of granularity, we use function and; callsite attributes rather than intrinsics. Restrictions on attributes; --------------------------. * It is undefined behaviour to pass or return (pointers to) scalable vector; objects to/from functions which may use a different SVE vector length.; This includes functions with a non-streaming interface, but marked with; ``aarch64_pstate_sm_body``. * It is not allowed for a function to be decorated with both; ``aarch64_pstate_sm_compatible`` and ``aarch64_pstate_sm_enabled``. * It is not allowed for a function to be decorated with both; ``aarch64_pstate_za_new`` and ``aarch64_pstate_za_preserved``. * It is not allowed for a function to be decorated with both; ``aarch64_pstate_za_new`` and ``aarch64_pstate_za_shared``. These restrictions also apply in the higher level SME ACLE, which means we can; emit diagnostics in ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AArch64SME.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst:6340,Energy Efficiency,schedul,scheduling,6340,"SC S If PSTATE.SM before call is 0, If PSTATE.SM before call is 0, If PSTATE.SM before call is 1,; then SMSTART then SMSTOP then SMSTART; SC SC If PSTATE.SM before call is 1,; then SMSTART; ==== ==== =============================== ============================== ==============================. Because changing PSTATE.SM zeroes the FP/vector registers, it is best to emit; the ``smstart`` and ``smstop`` instructions before register allocation, so that; the register allocator can spill/reload registers around the mode change. The compiler should also have sufficient information on which operations are; part of the call/function's arguments/result and which operations are part of; the function's body, so that it can place the mode changes in exactly the right; position. The suitable place to do this seems to be SelectionDAG, where it lowers; the call's arguments/return values to implement the specified calling convention.; SelectionDAG provides Chains and Glue to specify the order of operations and give; preliminary control over the instruction's scheduling. Example of preserving state; ---------------------------. When passing and returning a ``float`` value to/from a function; that has a streaming interface from a function that has a normal interface, the; call-site will need to ensure that the argument/result registers are preserved; and that no other code is scheduled in between the ``smstart/smstop`` and the call. .. code-block:: llvm. define float @foo(float %f) nounwind {; %res = call float @bar(float %f) ""aarch64_pstate_sm_enabled""; ret float %res; }. declare float @bar(float) ""aarch64_pstate_sm_enabled"". The program needs to preserve the value of the floating point argument and; return value in register ``s0``:. .. code-block:: none. foo: // @foo; // %bb.0:; stp d15, d14, [sp, #-80]! // 16-byte Folded Spill; stp d13, d12, [sp, #16] // 16-byte Folded Spill; stp d11, d10, [sp, #32] // 16-byte Folded Spill; stp d9, d8, [sp, #48] // 16-byte Folded Spill; str x30, [s",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AArch64SME.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst:6662,Energy Efficiency,schedul,scheduled,6662,"==========. Because changing PSTATE.SM zeroes the FP/vector registers, it is best to emit; the ``smstart`` and ``smstop`` instructions before register allocation, so that; the register allocator can spill/reload registers around the mode change. The compiler should also have sufficient information on which operations are; part of the call/function's arguments/result and which operations are part of; the function's body, so that it can place the mode changes in exactly the right; position. The suitable place to do this seems to be SelectionDAG, where it lowers; the call's arguments/return values to implement the specified calling convention.; SelectionDAG provides Chains and Glue to specify the order of operations and give; preliminary control over the instruction's scheduling. Example of preserving state; ---------------------------. When passing and returning a ``float`` value to/from a function; that has a streaming interface from a function that has a normal interface, the; call-site will need to ensure that the argument/result registers are preserved; and that no other code is scheduled in between the ``smstart/smstop`` and the call. .. code-block:: llvm. define float @foo(float %f) nounwind {; %res = call float @bar(float %f) ""aarch64_pstate_sm_enabled""; ret float %res; }. declare float @bar(float) ""aarch64_pstate_sm_enabled"". The program needs to preserve the value of the floating point argument and; return value in register ``s0``:. .. code-block:: none. foo: // @foo; // %bb.0:; stp d15, d14, [sp, #-80]! // 16-byte Folded Spill; stp d13, d12, [sp, #16] // 16-byte Folded Spill; stp d11, d10, [sp, #32] // 16-byte Folded Spill; stp d9, d8, [sp, #48] // 16-byte Folded Spill; str x30, [sp, #64] // 8-byte Folded Spill; str s0, [sp, #76] // 4-byte Folded Spill; smstart sm; ldr s0, [sp, #76] // 4-byte Folded Reload; bl bar; str s0, [sp, #76] // 4-byte Folded Spill; smstop sm; ldp d9, d8, [sp, #48] // 16-byte Folded Reload; ldp d11, d10, [sp, #32] // 16-byte Folded Re",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AArch64SME.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst:9173,Energy Efficiency,schedul,scheduled,9173,"START/SMSTOP`` nodes take ``CurrentState`` and ``ExpectedState`` operand for; the case of a conditional SMSTART/SMSTOP. The instruction will only be executed; if CurrentState != ExpectedState. When ``CurrentState`` and ``ExpectedState`` can be evaluated at compile-time; (i.e. they are both constants) then an unconditional ``smstart/smstop``; instruction is emitted. Otherwise the node is matched to a Pseudo instruction; which expands to a compare/branch and a ``smstart/smstop``. This is necessary to; implement transitions from ``SC -> N`` and ``SC -> S``. Unchained Function calls; ------------------------; When a function with ""``aarch64_pstate_sm_enabled``"" calls a function that is not; streaming compatible, the compiler has to insert a SMSTOP before the call and; insert a SMSTOP after the call. If the function that is called is an intrinsic with no side-effects which in; turn is lowered to a function call (e.g. ``@llvm.cos()``), then the call to; ``@llvm.cos()`` is not part of any Chain; it can be scheduled freely. Lowering of a Callsite creates a small chain of nodes which:. - starts a call sequence. - copies input values from virtual registers to physical registers specified by; the ABI. - executes a branch-and-link. - stops the call sequence. - copies the output values from their physical registers to virtual registers. When the callsite's Chain is not used, only the result value from the chained; sequence is used, but the Chain itself is discarded. The ``SMSTART`` and ``SMSTOP`` ISD nodes return a Chain, but no real; values, so when the ``SMSTART/SMSTOP`` nodes are part of a Chain that isn't; used, these nodes are not considered for scheduling and are; removed from the DAG. In order to prevent these nodes; from being removed, we need a way to ensure the results from the; ``CopyFromReg`` can only be **used after** the ``SMSTART/SMSTOP`` has been; executed. We can use a CopyToReg -> CopyFromReg sequence for this, which moves the; value to/from a virtual register a",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AArch64SME.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst:9825,Energy Efficiency,schedul,scheduling,9825,"-------------------; When a function with ""``aarch64_pstate_sm_enabled``"" calls a function that is not; streaming compatible, the compiler has to insert a SMSTOP before the call and; insert a SMSTOP after the call. If the function that is called is an intrinsic with no side-effects which in; turn is lowered to a function call (e.g. ``@llvm.cos()``), then the call to; ``@llvm.cos()`` is not part of any Chain; it can be scheduled freely. Lowering of a Callsite creates a small chain of nodes which:. - starts a call sequence. - copies input values from virtual registers to physical registers specified by; the ABI. - executes a branch-and-link. - stops the call sequence. - copies the output values from their physical registers to virtual registers. When the callsite's Chain is not used, only the result value from the chained; sequence is used, but the Chain itself is discarded. The ``SMSTART`` and ``SMSTOP`` ISD nodes return a Chain, but no real; values, so when the ``SMSTART/SMSTOP`` nodes are part of a Chain that isn't; used, these nodes are not considered for scheduling and are; removed from the DAG. In order to prevent these nodes; from being removed, we need a way to ensure the results from the; ``CopyFromReg`` can only be **used after** the ``SMSTART/SMSTOP`` has been; executed. We can use a CopyToReg -> CopyFromReg sequence for this, which moves the; value to/from a virtual register and chains these nodes with the; SMSTART/SMSTOP to make them part of the expression that calculates; the result value. The resulting COPY nodes are removed by the register; allocator. The example below shows how this is used in a DAG that does not link; together the result by a Chain, but rather by a value:. .. code-block:: none. t0: ch,glue = AArch64ISD::SMSTOP ...; t1: ch,glue = ISD::CALL ....; t2: res,ch,glue = CopyFromReg t1, ...; t3: ch,glue = AArch64ISD::SMSTART t2:1, .... <- this is now part of the expression that returns the result value.; t4: ch = CopyToReg t3, Register:f64 %v",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AArch64SME.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst:11447,Energy Efficiency,allocate,allocate,11447,"64ISD::SMSTOP ...; t1: ch,glue = ISD::CALL ....; t2: res,ch,glue = CopyFromReg t1, ...; t3: ch,glue = AArch64ISD::SMSTART t2:1, .... <- this is now part of the expression that returns the result value.; t4: ch = CopyToReg t3, Register:f64 %vreg, t2; t5: res,ch = CopyFromReg t4, Register:f64 %vreg; t6: res = FADD t5, t9. We also need this for locally streaming functions, where an ``SMSTART`` needs to; be inserted into the DAG at the start of the function. Functions with __attribute__((arm_locally_streaming)); -----------------------------------------------------. If a function is marked as ``arm_locally_streaming``, then the runtime SVE; vector length in the prologue/epilogue may be different from the vector length; in the function's body. This happens because we invoke smstart after setting up; the stack-frame and similarly invoke smstop before deallocating the stack-frame. To ensure we use the correct SVE vector length to allocate the locals with, we; can use the streaming vector-length to allocate the stack-slots through the; ``ADDSVL`` instruction, even when the CPU is not yet in streaming mode. This only works for locals and not callee-save slots, since LLVM doesn't support; mixing two different scalable vector lengths in one stack frame. That means that the; case where a function is marked ``arm_locally_streaming`` and needs to spill SVE; callee-saves in the prologue is currently unsupported. However, it is unlikely; for this to happen without user intervention, because ``arm_locally_streaming``; functions cannot take or return vector-length-dependent values. This would otherwise; require forcing both the SVE PCS using '``aarch64_sve_pcs``' combined with using; ``arm_locally_streaming`` in order to encounter this problem. This combination; can be prevented in Clang through emitting a diagnostic. An example of how the prologue/epilogue would look for a function that is; attributed with ``arm_locally_streaming``:. .. code-block:: c++. #define N 64. void __attribut",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AArch64SME.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst:11516,Energy Efficiency,allocate,allocate,11516,"64ISD::SMSTOP ...; t1: ch,glue = ISD::CALL ....; t2: res,ch,glue = CopyFromReg t1, ...; t3: ch,glue = AArch64ISD::SMSTART t2:1, .... <- this is now part of the expression that returns the result value.; t4: ch = CopyToReg t3, Register:f64 %vreg, t2; t5: res,ch = CopyFromReg t4, Register:f64 %vreg; t6: res = FADD t5, t9. We also need this for locally streaming functions, where an ``SMSTART`` needs to; be inserted into the DAG at the start of the function. Functions with __attribute__((arm_locally_streaming)); -----------------------------------------------------. If a function is marked as ``arm_locally_streaming``, then the runtime SVE; vector length in the prologue/epilogue may be different from the vector length; in the function's body. This happens because we invoke smstart after setting up; the stack-frame and similarly invoke smstop before deallocating the stack-frame. To ensure we use the correct SVE vector length to allocate the locals with, we; can use the streaming vector-length to allocate the stack-slots through the; ``ADDSVL`` instruction, even when the CPU is not yet in streaming mode. This only works for locals and not callee-save slots, since LLVM doesn't support; mixing two different scalable vector lengths in one stack frame. That means that the; case where a function is marked ``arm_locally_streaming`` and needs to spill SVE; callee-saves in the prologue is currently unsupported. However, it is unlikely; for this to happen without user intervention, because ``arm_locally_streaming``; functions cannot take or return vector-length-dependent values. This would otherwise; require forcing both the SVE PCS using '``aarch64_sve_pcs``' combined with using; ``arm_locally_streaming`` in order to encounter this problem. This combination; can be prevented in Clang through emitting a diagnostic. An example of how the prologue/epilogue would look for a function that is; attributed with ``arm_locally_streaming``:. .. code-block:: c++. #define N 64. void __attribut",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AArch64SME.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst:2235,Integrability,depend,dependent,2235,"state_za_shared``; is used for functions with ``__attribute__((arm_shared_za))``. ``aarch64_pstate_za_preserved``; is used for functions with ``__attribute__((arm_preserves_za))``. ``aarch64_expanded_pstate_za``; is used for functions with ``__attribute__((arm_new_za))``. Clang must ensure that the above attributes are added both to the; function's declaration/definition as well as to their call-sites. This is; important for calls to attributed function pointers, where there is no; definition or declaration available. 2. Handling PSTATE.SM; =====================. When changing PSTATE.SM the execution of FP/vector operations may be transferred; to another processing element. This has three important implications:. * The runtime SVE vector length may change. * The contents of FP/AdvSIMD/SVE registers are zeroed. * The set of allowable instructions changes. This leads to certain restrictions on IR and optimizations. For example, it; is undefined behaviour to share vector-length dependent state between functions; that may operate with different values for PSTATE.SM. Front-ends must honour; these restrictions when generating LLVM IR. Even though the runtime SVE vector length may change, for the purpose of LLVM IR; and almost all parts of CodeGen we can assume that the runtime value for; ``vscale`` does not. If we let the compiler insert the appropriate ``smstart``; and ``smstop`` instructions around call boundaries, then the effects on SVE; state can be mitigated. By limiting the state changes to a very brief window; around the call we can control how the operations are scheduled and how live; values remain preserved between state transitions. In order to control PSTATE.SM at this level of granularity, we use function and; callsite attributes rather than intrinsics. Restrictions on attributes; --------------------------. * It is undefined behaviour to pass or return (pointers to) scalable vector; objects to/from functions which may use a different SVE vector length.; This",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AArch64SME.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst:3287,Integrability,interface,interface,3287," different values for PSTATE.SM. Front-ends must honour; these restrictions when generating LLVM IR. Even though the runtime SVE vector length may change, for the purpose of LLVM IR; and almost all parts of CodeGen we can assume that the runtime value for; ``vscale`` does not. If we let the compiler insert the appropriate ``smstart``; and ``smstop`` instructions around call boundaries, then the effects on SVE; state can be mitigated. By limiting the state changes to a very brief window; around the call we can control how the operations are scheduled and how live; values remain preserved between state transitions. In order to control PSTATE.SM at this level of granularity, we use function and; callsite attributes rather than intrinsics. Restrictions on attributes; --------------------------. * It is undefined behaviour to pass or return (pointers to) scalable vector; objects to/from functions which may use a different SVE vector length.; This includes functions with a non-streaming interface, but marked with; ``aarch64_pstate_sm_body``. * It is not allowed for a function to be decorated with both; ``aarch64_pstate_sm_compatible`` and ``aarch64_pstate_sm_enabled``. * It is not allowed for a function to be decorated with both; ``aarch64_pstate_za_new`` and ``aarch64_pstate_za_preserved``. * It is not allowed for a function to be decorated with both; ``aarch64_pstate_za_new`` and ``aarch64_pstate_za_shared``. These restrictions also apply in the higher level SME ACLE, which means we can; emit diagnostics in Clang to signal users about incorrect behaviour. Compiler inserted streaming-mode changes; ----------------------------------------. The table below describes the transitions in PSTATE.SM the compiler has to; account for when doing calls between functions with different attributes.; In this table, we use the following abbreviations:. ``N``; functions with a normal interface (PSTATE.SM=0 on entry, PSTATE.SM=0 on; return). ``S``; functions with a Streaming interface (P",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AArch64SME.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst:4187,Integrability,interface,interface,4187,"/from functions which may use a different SVE vector length.; This includes functions with a non-streaming interface, but marked with; ``aarch64_pstate_sm_body``. * It is not allowed for a function to be decorated with both; ``aarch64_pstate_sm_compatible`` and ``aarch64_pstate_sm_enabled``. * It is not allowed for a function to be decorated with both; ``aarch64_pstate_za_new`` and ``aarch64_pstate_za_preserved``. * It is not allowed for a function to be decorated with both; ``aarch64_pstate_za_new`` and ``aarch64_pstate_za_shared``. These restrictions also apply in the higher level SME ACLE, which means we can; emit diagnostics in Clang to signal users about incorrect behaviour. Compiler inserted streaming-mode changes; ----------------------------------------. The table below describes the transitions in PSTATE.SM the compiler has to; account for when doing calls between functions with different attributes.; In this table, we use the following abbreviations:. ``N``; functions with a normal interface (PSTATE.SM=0 on entry, PSTATE.SM=0 on; return). ``S``; functions with a Streaming interface (PSTATE.SM=1 on entry, PSTATE.SM=1; on return). ``SC``; functions with a Streaming-Compatible interface (PSTATE.SM can be; either 0 or 1 on entry, and is unchanged on return). Functions with ``__attribute__((arm_locally_streaming))`` are excluded from this; table because for the caller the attribute is synonymous to 'streaming', and; for the callee it is merely an implementation detail that is explicitly not; exposed to the caller. .. table:: Combinations of calls for functions with different attributes. ==== ==== =============================== ============================== ==============================; From To Before call After call After exception; ==== ==== =============================== ============================== ==============================; N N; N S SMSTART SMSTOP; N SC; S N SMSTOP SMSTART SMSTART; S S SMSTART; S SC SMSTART; SC N If PSTATE.SM before call is 1, I",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AArch64SME.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst:4279,Integrability,interface,interface,4279," a non-streaming interface, but marked with; ``aarch64_pstate_sm_body``. * It is not allowed for a function to be decorated with both; ``aarch64_pstate_sm_compatible`` and ``aarch64_pstate_sm_enabled``. * It is not allowed for a function to be decorated with both; ``aarch64_pstate_za_new`` and ``aarch64_pstate_za_preserved``. * It is not allowed for a function to be decorated with both; ``aarch64_pstate_za_new`` and ``aarch64_pstate_za_shared``. These restrictions also apply in the higher level SME ACLE, which means we can; emit diagnostics in Clang to signal users about incorrect behaviour. Compiler inserted streaming-mode changes; ----------------------------------------. The table below describes the transitions in PSTATE.SM the compiler has to; account for when doing calls between functions with different attributes.; In this table, we use the following abbreviations:. ``N``; functions with a normal interface (PSTATE.SM=0 on entry, PSTATE.SM=0 on; return). ``S``; functions with a Streaming interface (PSTATE.SM=1 on entry, PSTATE.SM=1; on return). ``SC``; functions with a Streaming-Compatible interface (PSTATE.SM can be; either 0 or 1 on entry, and is unchanged on return). Functions with ``__attribute__((arm_locally_streaming))`` are excluded from this; table because for the caller the attribute is synonymous to 'streaming', and; for the callee it is merely an implementation detail that is explicitly not; exposed to the caller. .. table:: Combinations of calls for functions with different attributes. ==== ==== =============================== ============================== ==============================; From To Before call After call After exception; ==== ==== =============================== ============================== ==============================; N N; N S SMSTART SMSTOP; N SC; S N SMSTOP SMSTART SMSTART; S S SMSTART; S SC SMSTART; SC N If PSTATE.SM before call is 1, If PSTATE.SM before call is 1, If PSTATE.SM before call is 1,; then SMSTOP then SMSTART then",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AArch64SME.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst:4383,Integrability,interface,interface,4383," function to be decorated with both; ``aarch64_pstate_sm_compatible`` and ``aarch64_pstate_sm_enabled``. * It is not allowed for a function to be decorated with both; ``aarch64_pstate_za_new`` and ``aarch64_pstate_za_preserved``. * It is not allowed for a function to be decorated with both; ``aarch64_pstate_za_new`` and ``aarch64_pstate_za_shared``. These restrictions also apply in the higher level SME ACLE, which means we can; emit diagnostics in Clang to signal users about incorrect behaviour. Compiler inserted streaming-mode changes; ----------------------------------------. The table below describes the transitions in PSTATE.SM the compiler has to; account for when doing calls between functions with different attributes.; In this table, we use the following abbreviations:. ``N``; functions with a normal interface (PSTATE.SM=0 on entry, PSTATE.SM=0 on; return). ``S``; functions with a Streaming interface (PSTATE.SM=1 on entry, PSTATE.SM=1; on return). ``SC``; functions with a Streaming-Compatible interface (PSTATE.SM can be; either 0 or 1 on entry, and is unchanged on return). Functions with ``__attribute__((arm_locally_streaming))`` are excluded from this; table because for the caller the attribute is synonymous to 'streaming', and; for the callee it is merely an implementation detail that is explicitly not; exposed to the caller. .. table:: Combinations of calls for functions with different attributes. ==== ==== =============================== ============================== ==============================; From To Before call After call After exception; ==== ==== =============================== ============================== ==============================; N N; N S SMSTART SMSTOP; N SC; S N SMSTOP SMSTART SMSTART; S S SMSTART; S SC SMSTART; SC N If PSTATE.SM before call is 1, If PSTATE.SM before call is 1, If PSTATE.SM before call is 1,; then SMSTOP then SMSTART then SMSTART; SC S If PSTATE.SM before call is 0, If PSTATE.SM before call is 0, If PSTATE.SM before c",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AArch64SME.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst:6496,Integrability,interface,interface,6496,"==========. Because changing PSTATE.SM zeroes the FP/vector registers, it is best to emit; the ``smstart`` and ``smstop`` instructions before register allocation, so that; the register allocator can spill/reload registers around the mode change. The compiler should also have sufficient information on which operations are; part of the call/function's arguments/result and which operations are part of; the function's body, so that it can place the mode changes in exactly the right; position. The suitable place to do this seems to be SelectionDAG, where it lowers; the call's arguments/return values to implement the specified calling convention.; SelectionDAG provides Chains and Glue to specify the order of operations and give; preliminary control over the instruction's scheduling. Example of preserving state; ---------------------------. When passing and returning a ``float`` value to/from a function; that has a streaming interface from a function that has a normal interface, the; call-site will need to ensure that the argument/result registers are preserved; and that no other code is scheduled in between the ``smstart/smstop`` and the call. .. code-block:: llvm. define float @foo(float %f) nounwind {; %res = call float @bar(float %f) ""aarch64_pstate_sm_enabled""; ret float %res; }. declare float @bar(float) ""aarch64_pstate_sm_enabled"". The program needs to preserve the value of the floating point argument and; return value in register ``s0``:. .. code-block:: none. foo: // @foo; // %bb.0:; stp d15, d14, [sp, #-80]! // 16-byte Folded Spill; stp d13, d12, [sp, #16] // 16-byte Folded Spill; stp d11, d10, [sp, #32] // 16-byte Folded Spill; stp d9, d8, [sp, #48] // 16-byte Folded Spill; str x30, [sp, #64] // 8-byte Folded Spill; str s0, [sp, #76] // 4-byte Folded Spill; smstart sm; ldr s0, [sp, #76] // 4-byte Folded Reload; bl bar; str s0, [sp, #76] // 4-byte Folded Spill; smstop sm; ldp d9, d8, [sp, #48] // 16-byte Folded Reload; ldp d11, d10, [sp, #32] // 16-byte Folded Re",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AArch64SME.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst:6540,Integrability,interface,interface,6540,"==========. Because changing PSTATE.SM zeroes the FP/vector registers, it is best to emit; the ``smstart`` and ``smstop`` instructions before register allocation, so that; the register allocator can spill/reload registers around the mode change. The compiler should also have sufficient information on which operations are; part of the call/function's arguments/result and which operations are part of; the function's body, so that it can place the mode changes in exactly the right; position. The suitable place to do this seems to be SelectionDAG, where it lowers; the call's arguments/return values to implement the specified calling convention.; SelectionDAG provides Chains and Glue to specify the order of operations and give; preliminary control over the instruction's scheduling. Example of preserving state; ---------------------------. When passing and returning a ``float`` value to/from a function; that has a streaming interface from a function that has a normal interface, the; call-site will need to ensure that the argument/result registers are preserved; and that no other code is scheduled in between the ``smstart/smstop`` and the call. .. code-block:: llvm. define float @foo(float %f) nounwind {; %res = call float @bar(float %f) ""aarch64_pstate_sm_enabled""; ret float %res; }. declare float @bar(float) ""aarch64_pstate_sm_enabled"". The program needs to preserve the value of the floating point argument and; return value in register ``s0``:. .. code-block:: none. foo: // @foo; // %bb.0:; stp d15, d14, [sp, #-80]! // 16-byte Folded Spill; stp d13, d12, [sp, #16] // 16-byte Folded Spill; stp d11, d10, [sp, #32] // 16-byte Folded Spill; stp d9, d8, [sp, #48] // 16-byte Folded Spill; str x30, [sp, #64] // 8-byte Folded Spill; str s0, [sp, #76] // 4-byte Folded Spill; smstart sm; ldr s0, [sp, #76] // 4-byte Folded Reload; bl bar; str s0, [sp, #76] // 4-byte Folded Spill; smstop sm; ldp d9, d8, [sp, #48] // 16-byte Folded Reload; ldp d11, d10, [sp, #32] // 16-byte Folded Re",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AArch64SME.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst:12083,Integrability,depend,dependent,12083,"aming)); -----------------------------------------------------. If a function is marked as ``arm_locally_streaming``, then the runtime SVE; vector length in the prologue/epilogue may be different from the vector length; in the function's body. This happens because we invoke smstart after setting up; the stack-frame and similarly invoke smstop before deallocating the stack-frame. To ensure we use the correct SVE vector length to allocate the locals with, we; can use the streaming vector-length to allocate the stack-slots through the; ``ADDSVL`` instruction, even when the CPU is not yet in streaming mode. This only works for locals and not callee-save slots, since LLVM doesn't support; mixing two different scalable vector lengths in one stack frame. That means that the; case where a function is marked ``arm_locally_streaming`` and needs to spill SVE; callee-saves in the prologue is currently unsupported. However, it is unlikely; for this to happen without user intervention, because ``arm_locally_streaming``; functions cannot take or return vector-length-dependent values. This would otherwise; require forcing both the SVE PCS using '``aarch64_sve_pcs``' combined with using; ``arm_locally_streaming`` in order to encounter this problem. This combination; can be prevented in Clang through emitting a diagnostic. An example of how the prologue/epilogue would look for a function that is; attributed with ``arm_locally_streaming``:. .. code-block:: c++. #define N 64. void __attribute__((arm_streaming_compatible)) some_use(svfloat32_t *);. // Use a float argument type, to check the value isn't clobbered by smstart.; // Use a float return type to check the value isn't clobbered by smstop.; float __attribute__((noinline, arm_locally_streaming)) foo(float arg) {; // Create local for SVE vector to check local is created with correct; // size when not yet in streaming mode (ADDSVL).; float array[N];; svfloat32_t vector;. some_use(&vector);; svst1_f32(svptrue_b32(), &array[0], vector",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AArch64SME.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst:2157,Performance,optimiz,optimizations,2157,"ons). ``aarch64_pstate_za_new``; is used for functions with ``__attribute__((arm_new_za))``. ``aarch64_pstate_za_shared``; is used for functions with ``__attribute__((arm_shared_za))``. ``aarch64_pstate_za_preserved``; is used for functions with ``__attribute__((arm_preserves_za))``. ``aarch64_expanded_pstate_za``; is used for functions with ``__attribute__((arm_new_za))``. Clang must ensure that the above attributes are added both to the; function's declaration/definition as well as to their call-sites. This is; important for calls to attributed function pointers, where there is no; definition or declaration available. 2. Handling PSTATE.SM; =====================. When changing PSTATE.SM the execution of FP/vector operations may be transferred; to another processing element. This has three important implications:. * The runtime SVE vector length may change. * The contents of FP/AdvSIMD/SVE registers are zeroed. * The set of allowable instructions changes. This leads to certain restrictions on IR and optimizations. For example, it; is undefined behaviour to share vector-length dependent state between functions; that may operate with different values for PSTATE.SM. Front-ends must honour; these restrictions when generating LLVM IR. Even though the runtime SVE vector length may change, for the purpose of LLVM IR; and almost all parts of CodeGen we can assume that the runtime value for; ``vscale`` does not. If we let the compiler insert the appropriate ``smstart``; and ``smstop`` instructions around call boundaries, then the effects on SVE; state can be mitigated. By limiting the state changes to a very brief window; around the call we can control how the operations are scheduled and how live; values remain preserved between state transitions. In order to control PSTATE.SM at this level of granularity, we use function and; callsite attributes rather than intrinsics. Restrictions on attributes; --------------------------. * It is undefined behaviour to pass or return (p",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AArch64SME.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst:3153,Performance,scalab,scalable,3153,"ions. For example, it; is undefined behaviour to share vector-length dependent state between functions; that may operate with different values for PSTATE.SM. Front-ends must honour; these restrictions when generating LLVM IR. Even though the runtime SVE vector length may change, for the purpose of LLVM IR; and almost all parts of CodeGen we can assume that the runtime value for; ``vscale`` does not. If we let the compiler insert the appropriate ``smstart``; and ``smstop`` instructions around call boundaries, then the effects on SVE; state can be mitigated. By limiting the state changes to a very brief window; around the call we can control how the operations are scheduled and how live; values remain preserved between state transitions. In order to control PSTATE.SM at this level of granularity, we use function and; callsite attributes rather than intrinsics. Restrictions on attributes; --------------------------. * It is undefined behaviour to pass or return (pointers to) scalable vector; objects to/from functions which may use a different SVE vector length.; This includes functions with a non-streaming interface, but marked with; ``aarch64_pstate_sm_body``. * It is not allowed for a function to be decorated with both; ``aarch64_pstate_sm_compatible`` and ``aarch64_pstate_sm_enabled``. * It is not allowed for a function to be decorated with both; ``aarch64_pstate_za_new`` and ``aarch64_pstate_za_preserved``. * It is not allowed for a function to be decorated with both; ``aarch64_pstate_za_new`` and ``aarch64_pstate_za_shared``. These restrictions also apply in the higher level SME ACLE, which means we can; emit diagnostics in Clang to signal users about incorrect behaviour. Compiler inserted streaming-mode changes; ----------------------------------------. The table below describes the transitions in PSTATE.SM the compiler has to; account for when doing calls between functions with different attributes.; In this table, we use the following abbreviations:. ``N``; fun",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AArch64SME.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst:11729,Performance,scalab,scalable,11729,"result value.; t4: ch = CopyToReg t3, Register:f64 %vreg, t2; t5: res,ch = CopyFromReg t4, Register:f64 %vreg; t6: res = FADD t5, t9. We also need this for locally streaming functions, where an ``SMSTART`` needs to; be inserted into the DAG at the start of the function. Functions with __attribute__((arm_locally_streaming)); -----------------------------------------------------. If a function is marked as ``arm_locally_streaming``, then the runtime SVE; vector length in the prologue/epilogue may be different from the vector length; in the function's body. This happens because we invoke smstart after setting up; the stack-frame and similarly invoke smstop before deallocating the stack-frame. To ensure we use the correct SVE vector length to allocate the locals with, we; can use the streaming vector-length to allocate the stack-slots through the; ``ADDSVL`` instruction, even when the CPU is not yet in streaming mode. This only works for locals and not callee-save slots, since LLVM doesn't support; mixing two different scalable vector lengths in one stack frame. That means that the; case where a function is marked ``arm_locally_streaming`` and needs to spill SVE; callee-saves in the prologue is currently unsupported. However, it is unlikely; for this to happen without user intervention, because ``arm_locally_streaming``; functions cannot take or return vector-length-dependent values. This would otherwise; require forcing both the SVE PCS using '``aarch64_sve_pcs``' combined with using; ``arm_locally_streaming`` in order to encounter this problem. This combination; can be prevented in Clang through emitting a diagnostic. An example of how the prologue/epilogue would look for a function that is; attributed with ``arm_locally_streaming``:. .. code-block:: c++. #define N 64. void __attribute__((arm_streaming_compatible)) some_use(svfloat32_t *);. // Use a float argument type, to check the value isn't clobbered by smstart.; // Use a float return type to check the value isn't ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AArch64SME.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst:15962,Performance,scalab,scalable,15962,"der the requested; streaming mode. The compiler needs to use the function attributes to ensure the; compiler doesn't do transformations under the assumption that certain operations; are available at runtime. We made a conscious choice not to model this with feature flags, because we; still want to support inline-asm in either mode (with the user placing; smstart/smstop manually), and this became rather complicated to implement at the; individual instruction level (see `D120261 <https://reviews.llvm.org/D120261>`_; and `D121208 <https://reviews.llvm.org/D121208>`_) because of limitations in; TableGen. As a first step, this means we'll disable vectorization (LoopVectorize/SLP); entirely when the a function has either of the ``aarch64_pstate_sm_enabled``,; ``aarch64_pstate_sm_body`` or ``aarch64_pstate_sm_compatible`` attributes,; in order to avoid the use of vector instructions. Later on we'll aim to relax these restrictions to enable scalable; auto-vectorization with a subset of streaming-compatible instructions, but that; requires changes to the CostModel, Legalization and SelectionDAG lowering. We will also emit diagnostics in Clang to prevent the use of; non-streaming(-compatible) operations, e.g. through ACLE intrinsics, when a; function is decorated with the streaming mode attributes. Other things to consider; ------------------------. * Inlining must be disabled when the call-site needs to toggle PSTATE.SM or; when the callee's function body is executed in a different streaming mode than; its caller. This is needed because function calls are the boundaries for; streaming mode changes. * Tail call optimization must be disabled when the call-site needs to toggle; PSTATE.SM, such that the caller can restore the original value of PSTATE.SM. 3. Handling PSTATE.ZA; =====================. In contrast to PSTATE.SM, enabling PSTATE.ZA does not affect the SVE vector; length and also doesn't clobber FP/AdvSIMD/SVE registers. This means it is safe; to toggle PSTATE.ZA using",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AArch64SME.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst:16644,Performance,optimiz,optimization,16644,"tion (LoopVectorize/SLP); entirely when the a function has either of the ``aarch64_pstate_sm_enabled``,; ``aarch64_pstate_sm_body`` or ``aarch64_pstate_sm_compatible`` attributes,; in order to avoid the use of vector instructions. Later on we'll aim to relax these restrictions to enable scalable; auto-vectorization with a subset of streaming-compatible instructions, but that; requires changes to the CostModel, Legalization and SelectionDAG lowering. We will also emit diagnostics in Clang to prevent the use of; non-streaming(-compatible) operations, e.g. through ACLE intrinsics, when a; function is decorated with the streaming mode attributes. Other things to consider; ------------------------. * Inlining must be disabled when the call-site needs to toggle PSTATE.SM or; when the callee's function body is executed in a different streaming mode than; its caller. This is needed because function calls are the boundaries for; streaming mode changes. * Tail call optimization must be disabled when the call-site needs to toggle; PSTATE.SM, such that the caller can restore the original value of PSTATE.SM. 3. Handling PSTATE.ZA; =====================. In contrast to PSTATE.SM, enabling PSTATE.ZA does not affect the SVE vector; length and also doesn't clobber FP/AdvSIMD/SVE registers. This means it is safe; to toggle PSTATE.ZA using intrinsics. This also makes it simpler to setup a; lazy-save mechanism for calls to private-ZA functions (i.e. functions that may; either directly or indirectly clobber ZA state). For the purpose of handling functions marked with ``aarch64_pstate_za_new``,; we have introduced a new LLVM IR pass (SMEABIPass) that is run just before; SelectionDAG. Any such functions dealt with by this pass are marked with; ``aarch64_expanded_pstate_za``. Setting up a lazy-save; ----------------------. Committing a lazy-save; ----------------------. Exception handling and ZA; -------------------------. 4. Types; ========. AArch64 Predicate-as-Counter Type; ------------",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AArch64SME.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst:18261,Performance,load,load,18261,"ion must be disabled when the call-site needs to toggle; PSTATE.SM, such that the caller can restore the original value of PSTATE.SM. 3. Handling PSTATE.ZA; =====================. In contrast to PSTATE.SM, enabling PSTATE.ZA does not affect the SVE vector; length and also doesn't clobber FP/AdvSIMD/SVE registers. This means it is safe; to toggle PSTATE.ZA using intrinsics. This also makes it simpler to setup a; lazy-save mechanism for calls to private-ZA functions (i.e. functions that may; either directly or indirectly clobber ZA state). For the purpose of handling functions marked with ``aarch64_pstate_za_new``,; we have introduced a new LLVM IR pass (SMEABIPass) that is run just before; SelectionDAG. Any such functions dealt with by this pass are marked with; ``aarch64_expanded_pstate_za``. Setting up a lazy-save; ----------------------. Committing a lazy-save; ----------------------. Exception handling and ZA; -------------------------. 4. Types; ========. AArch64 Predicate-as-Counter Type; ---------------------------------. :Overview:. The predicate-as-counter type represents the type of a predicate-as-counter; value held in a AArch64 SVE predicate register. Such a value contains; information about the number of active lanes, the element width and a bit that; tells whether the generated mask should be inverted. ACLE intrinsics should be; used to move the predicate-as-counter value to/from a predicate vector. There are certain limitations on the type:. * The type can be used for function parameters and return values. * The supported LLVM operations on this type are limited to ``load``, ``store``,; ``phi``, ``select`` and ``alloca`` instructions. The predicate-as-counter type is a scalable type. :Syntax:. ::. target(""aarch64.svcount""). 5. References; =============. .. _aarch64_sme_acle:. 1. `SME ACLE Pull-request <https://github.com/ARM-software/acle/pull/188>`__. .. _aarch64_sme_abi:. 2. `SME ABI Pull-request <https://github.com/ARM-software/abi-aa/pull/123>`__; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AArch64SME.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst:18365,Performance,scalab,scalable,18365,"ion must be disabled when the call-site needs to toggle; PSTATE.SM, such that the caller can restore the original value of PSTATE.SM. 3. Handling PSTATE.ZA; =====================. In contrast to PSTATE.SM, enabling PSTATE.ZA does not affect the SVE vector; length and also doesn't clobber FP/AdvSIMD/SVE registers. This means it is safe; to toggle PSTATE.ZA using intrinsics. This also makes it simpler to setup a; lazy-save mechanism for calls to private-ZA functions (i.e. functions that may; either directly or indirectly clobber ZA state). For the purpose of handling functions marked with ``aarch64_pstate_za_new``,; we have introduced a new LLVM IR pass (SMEABIPass) that is run just before; SelectionDAG. Any such functions dealt with by this pass are marked with; ``aarch64_expanded_pstate_za``. Setting up a lazy-save; ----------------------. Committing a lazy-save; ----------------------. Exception handling and ZA; -------------------------. 4. Types; ========. AArch64 Predicate-as-Counter Type; ---------------------------------. :Overview:. The predicate-as-counter type represents the type of a predicate-as-counter; value held in a AArch64 SVE predicate register. Such a value contains; information about the number of active lanes, the element width and a bit that; tells whether the generated mask should be inverted. ACLE intrinsics should be; used to move the predicate-as-counter value to/from a predicate vector. There are certain limitations on the type:. * The type can be used for function parameters and return values. * The supported LLVM operations on this type are limited to ``load``, ``store``,; ``phi``, ``select`` and ``alloca`` instructions. The predicate-as-counter type is a scalable type. :Syntax:. ::. target(""aarch64.svcount""). 5. References; =============. .. _aarch64_sme_acle:. 1. `SME ACLE Pull-request <https://github.com/ARM-software/acle/pull/188>`__. .. _aarch64_sme_abi:. 2. `SME ABI Pull-request <https://github.com/ARM-software/abi-aa/pull/123>`__; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AArch64SME.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst:13110,Safety,avoid,avoid,13110,"his would otherwise; require forcing both the SVE PCS using '``aarch64_sve_pcs``' combined with using; ``arm_locally_streaming`` in order to encounter this problem. This combination; can be prevented in Clang through emitting a diagnostic. An example of how the prologue/epilogue would look for a function that is; attributed with ``arm_locally_streaming``:. .. code-block:: c++. #define N 64. void __attribute__((arm_streaming_compatible)) some_use(svfloat32_t *);. // Use a float argument type, to check the value isn't clobbered by smstart.; // Use a float return type to check the value isn't clobbered by smstop.; float __attribute__((noinline, arm_locally_streaming)) foo(float arg) {; // Create local for SVE vector to check local is created with correct; // size when not yet in streaming mode (ADDSVL).; float array[N];; svfloat32_t vector;. some_use(&vector);; svst1_f32(svptrue_b32(), &array[0], vector);; return array[N - 1] + arg;; }. should use ADDSVL for allocating the stack space and should avoid clobbering; the return/argument values. .. code-block:: none. _Z3foof: // @_Z3foof; // %bb.0: // %entry; stp d15, d14, [sp, #-96]! // 16-byte Folded Spill; stp d13, d12, [sp, #16] // 16-byte Folded Spill; stp d11, d10, [sp, #32] // 16-byte Folded Spill; stp d9, d8, [sp, #48] // 16-byte Folded Spill; stp x29, x30, [sp, #64] // 16-byte Folded Spill; add x29, sp, #64; str x28, [sp, #80] // 8-byte Folded Spill; addsvl sp, sp, #-1; sub sp, sp, #256; str s0, [x29, #28] // 4-byte Folded Spill; smstart sm; sub x0, x29, #64; addsvl x0, x0, #-1; bl _Z10some_usePu13__SVFloat32_t; sub x8, x29, #64; ptrue p0.s; ld1w { z0.s }, p0/z, [x8, #-1, mul vl]; ldr s1, [x29, #28] // 4-byte Folded Reload; st1w { z0.s }, p0, [sp]; ldr s0, [sp, #252]; fadd s0, s0, s1; str s0, [x29, #28] // 4-byte Folded Spill; smstop sm; ldr s0, [x29, #28] // 4-byte Folded Reload; addsvl sp, sp, #1; add sp, sp, #256; ldp x29, x30, [sp, #64] // 16-byte Folded Reload; ldp d9, d8, [sp, #48] // 16-byte Folded Reload; l",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AArch64SME.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst:15867,Safety,avoid,avoid,15867,"=0 or PSTATE.SM=1. The value of PSTATE.SM is not controlled by the feature flags, but rather by the; function attributes. This means that we can compile for '``+sme``' and the compiler; will code-generate any instructions, even if they are not legal under the requested; streaming mode. The compiler needs to use the function attributes to ensure the; compiler doesn't do transformations under the assumption that certain operations; are available at runtime. We made a conscious choice not to model this with feature flags, because we; still want to support inline-asm in either mode (with the user placing; smstart/smstop manually), and this became rather complicated to implement at the; individual instruction level (see `D120261 <https://reviews.llvm.org/D120261>`_; and `D121208 <https://reviews.llvm.org/D121208>`_) because of limitations in; TableGen. As a first step, this means we'll disable vectorization (LoopVectorize/SLP); entirely when the a function has either of the ``aarch64_pstate_sm_enabled``,; ``aarch64_pstate_sm_body`` or ``aarch64_pstate_sm_compatible`` attributes,; in order to avoid the use of vector instructions. Later on we'll aim to relax these restrictions to enable scalable; auto-vectorization with a subset of streaming-compatible instructions, but that; requires changes to the CostModel, Legalization and SelectionDAG lowering. We will also emit diagnostics in Clang to prevent the use of; non-streaming(-compatible) operations, e.g. through ACLE intrinsics, when a; function is decorated with the streaming mode attributes. Other things to consider; ------------------------. * Inlining must be disabled when the call-site needs to toggle PSTATE.SM or; when the callee's function body is executed in a different streaming mode than; its caller. This is needed because function calls are the boundaries for; streaming mode changes. * Tail call optimization must be disabled when the call-site needs to toggle; PSTATE.SM, such that the caller can restore the origi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AArch64SME.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst:16985,Safety,safe,safe,16985,"ion with a subset of streaming-compatible instructions, but that; requires changes to the CostModel, Legalization and SelectionDAG lowering. We will also emit diagnostics in Clang to prevent the use of; non-streaming(-compatible) operations, e.g. through ACLE intrinsics, when a; function is decorated with the streaming mode attributes. Other things to consider; ------------------------. * Inlining must be disabled when the call-site needs to toggle PSTATE.SM or; when the callee's function body is executed in a different streaming mode than; its caller. This is needed because function calls are the boundaries for; streaming mode changes. * Tail call optimization must be disabled when the call-site needs to toggle; PSTATE.SM, such that the caller can restore the original value of PSTATE.SM. 3. Handling PSTATE.ZA; =====================. In contrast to PSTATE.SM, enabling PSTATE.ZA does not affect the SVE vector; length and also doesn't clobber FP/AdvSIMD/SVE registers. This means it is safe; to toggle PSTATE.ZA using intrinsics. This also makes it simpler to setup a; lazy-save mechanism for calls to private-ZA functions (i.e. functions that may; either directly or indirectly clobber ZA state). For the purpose of handling functions marked with ``aarch64_pstate_za_new``,; we have introduced a new LLVM IR pass (SMEABIPass) that is run just before; SelectionDAG. Any such functions dealt with by this pass are marked with; ``aarch64_expanded_pstate_za``. Setting up a lazy-save; ----------------------. Committing a lazy-save; ----------------------. Exception handling and ZA; -------------------------. 4. Types; ========. AArch64 Predicate-as-Counter Type; ---------------------------------. :Overview:. The predicate-as-counter type represents the type of a predicate-as-counter; value held in a AArch64 SVE predicate register. Such a value contains; information about the number of active lanes, the element width and a bit that; tells whether the generated mask should be inverted",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AArch64SME.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst:4702,Security,expose,exposed,4702,"``. * It is not allowed for a function to be decorated with both; ``aarch64_pstate_za_new`` and ``aarch64_pstate_za_shared``. These restrictions also apply in the higher level SME ACLE, which means we can; emit diagnostics in Clang to signal users about incorrect behaviour. Compiler inserted streaming-mode changes; ----------------------------------------. The table below describes the transitions in PSTATE.SM the compiler has to; account for when doing calls between functions with different attributes.; In this table, we use the following abbreviations:. ``N``; functions with a normal interface (PSTATE.SM=0 on entry, PSTATE.SM=0 on; return). ``S``; functions with a Streaming interface (PSTATE.SM=1 on entry, PSTATE.SM=1; on return). ``SC``; functions with a Streaming-Compatible interface (PSTATE.SM can be; either 0 or 1 on entry, and is unchanged on return). Functions with ``__attribute__((arm_locally_streaming))`` are excluded from this; table because for the caller the attribute is synonymous to 'streaming', and; for the callee it is merely an implementation detail that is explicitly not; exposed to the caller. .. table:: Combinations of calls for functions with different attributes. ==== ==== =============================== ============================== ==============================; From To Before call After call After exception; ==== ==== =============================== ============================== ==============================; N N; N S SMSTART SMSTOP; N SC; S N SMSTOP SMSTART SMSTART; S S SMSTART; S SC SMSTART; SC N If PSTATE.SM before call is 1, If PSTATE.SM before call is 1, If PSTATE.SM before call is 1,; then SMSTOP then SMSTART then SMSTART; SC S If PSTATE.SM before call is 0, If PSTATE.SM before call is 0, If PSTATE.SM before call is 1,; then SMSTART then SMSTOP then SMSTART; SC SC If PSTATE.SM before call is 1,; then SMSTART; ==== ==== =============================== ============================== ==============================. Because changing P",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AArch64SME.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst:17048,Usability,simpl,simpler,17048," CostModel, Legalization and SelectionDAG lowering. We will also emit diagnostics in Clang to prevent the use of; non-streaming(-compatible) operations, e.g. through ACLE intrinsics, when a; function is decorated with the streaming mode attributes. Other things to consider; ------------------------. * Inlining must be disabled when the call-site needs to toggle PSTATE.SM or; when the callee's function body is executed in a different streaming mode than; its caller. This is needed because function calls are the boundaries for; streaming mode changes. * Tail call optimization must be disabled when the call-site needs to toggle; PSTATE.SM, such that the caller can restore the original value of PSTATE.SM. 3. Handling PSTATE.ZA; =====================. In contrast to PSTATE.SM, enabling PSTATE.ZA does not affect the SVE vector; length and also doesn't clobber FP/AdvSIMD/SVE registers. This means it is safe; to toggle PSTATE.ZA using intrinsics. This also makes it simpler to setup a; lazy-save mechanism for calls to private-ZA functions (i.e. functions that may; either directly or indirectly clobber ZA state). For the purpose of handling functions marked with ``aarch64_pstate_za_new``,; we have introduced a new LLVM IR pass (SMEABIPass) that is run just before; SelectionDAG. Any such functions dealt with by this pass are marked with; ``aarch64_expanded_pstate_za``. Setting up a lazy-save; ----------------------. Committing a lazy-save; ----------------------. Exception handling and ZA; -------------------------. 4. Types; ========. AArch64 Predicate-as-Counter Type; ---------------------------------. :Overview:. The predicate-as-counter type represents the type of a predicate-as-counter; value held in a AArch64 SVE predicate register. Such a value contains; information about the number of active lanes, the element width and a bit that; tells whether the generated mask should be inverted. ACLE intrinsics should be; used to move the predicate-as-counter value to/from a predic",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AArch64SME.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AArch64SME.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AddingConstrainedIntrinsics.rst:285,Deployability,update,updated,285,"==================================================; How To Add A Constrained Floating-Point Intrinsic; ==================================================. .. contents::; :local:. .. warning::; This is a work in progress. Add the intrinsic; =================. Multiple files need to be updated when adding a new constrained intrinsic. Add the new intrinsic to the table of intrinsics::. include/llvm/IR/Intrinsics.td. Add SelectionDAG node types; ===========================. Add the new STRICT version of the node type to the ISD::NodeType enum::. include/llvm/CodeGen/ISDOpcodes.h. Strict version name must be a concatenation of prefix ``STRICT_`` and the name; of corresponding non-strict node name. For instance, strict version of the; node FADD must be STRICT_FADD. Update mappings; ===============. Add new record to the mapping of instructions to constrained intrinsic and; DAG nodes::. include/llvm/IR/ConstrainedOps.def. Follow instructions provided in this file. Update IR components; ====================. Update the IR verifier::. lib/IR/Verifier.cpp. Update Selector components; ==========================. Building the SelectionDAG; -------------------------. The function SelectionDAGBuilder::visitConstrainedFPIntrinsic builds DAG nodes; using mappings specified in ConstrainedOps.def. If however this default build is; not sufficient, the build can be modified, see how it is implemented for; STRICT_FP_ROUND. The new STRICT node will eventually be converted; to the matching non-STRICT node. For this reason it should have the same; operands and values as the non-STRICT version but should also use the chain.; This makes subsequent sharing of code for STRICT and non-STRICT code paths; easier::. lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp. Most of the STRICT nodes get legalized the same as their matching non-STRICT; counterparts. A new STRICT node with this property must get added to the; switch in SelectionDAGLegalize::LegalizeOp().::. lib/CodeGen/SelectionDAG/LegalizeDAG",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AddingConstrainedIntrinsics.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AddingConstrainedIntrinsics.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AddingConstrainedIntrinsics.rst:2051,Deployability,update,updated,2051,"er::. lib/IR/Verifier.cpp. Update Selector components; ==========================. Building the SelectionDAG; -------------------------. The function SelectionDAGBuilder::visitConstrainedFPIntrinsic builds DAG nodes; using mappings specified in ConstrainedOps.def. If however this default build is; not sufficient, the build can be modified, see how it is implemented for; STRICT_FP_ROUND. The new STRICT node will eventually be converted; to the matching non-STRICT node. For this reason it should have the same; operands and values as the non-STRICT version but should also use the chain.; This makes subsequent sharing of code for STRICT and non-STRICT code paths; easier::. lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp. Most of the STRICT nodes get legalized the same as their matching non-STRICT; counterparts. A new STRICT node with this property must get added to the; switch in SelectionDAGLegalize::LegalizeOp().::. lib/CodeGen/SelectionDAG/LegalizeDAG.cpp. Other parts of the legalizer may need to be updated as well. Look for; places where the non-STRICT counterpart is legalized and update as needed.; Be careful of the chain since STRICT nodes use it but their counterparts; often don't. The code to do the conversion or mutation of the STRICT node to a non-STRICT; version of the node happens in SelectionDAG::mutateStrictFPToFP(). In most cases; the function can do the conversion using information from ConstrainedOps.def. Be; careful updating this function since some nodes have the same return type; as their input operand, but some are different. Both of these cases must; be properly handled::. lib/CodeGen/SelectionDAG/SelectionDAG.cpp. Whether the mutation may happens or not, depends on how the new node has been; registered in TargetLoweringBase::initActions(). By default all strict nodes are; registered with Expand action::. lib/CodeGen/TargetLoweringBase.cpp. To make debug logs readable it is helpful to update the SelectionDAG's; debug logger:::. lib/CodeGen/Selectio",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AddingConstrainedIntrinsics.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AddingConstrainedIntrinsics.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AddingConstrainedIntrinsics.rst:2135,Deployability,update,update,2135,"========. Building the SelectionDAG; -------------------------. The function SelectionDAGBuilder::visitConstrainedFPIntrinsic builds DAG nodes; using mappings specified in ConstrainedOps.def. If however this default build is; not sufficient, the build can be modified, see how it is implemented for; STRICT_FP_ROUND. The new STRICT node will eventually be converted; to the matching non-STRICT node. For this reason it should have the same; operands and values as the non-STRICT version but should also use the chain.; This makes subsequent sharing of code for STRICT and non-STRICT code paths; easier::. lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp. Most of the STRICT nodes get legalized the same as their matching non-STRICT; counterparts. A new STRICT node with this property must get added to the; switch in SelectionDAGLegalize::LegalizeOp().::. lib/CodeGen/SelectionDAG/LegalizeDAG.cpp. Other parts of the legalizer may need to be updated as well. Look for; places where the non-STRICT counterpart is legalized and update as needed.; Be careful of the chain since STRICT nodes use it but their counterparts; often don't. The code to do the conversion or mutation of the STRICT node to a non-STRICT; version of the node happens in SelectionDAG::mutateStrictFPToFP(). In most cases; the function can do the conversion using information from ConstrainedOps.def. Be; careful updating this function since some nodes have the same return type; as their input operand, but some are different. Both of these cases must; be properly handled::. lib/CodeGen/SelectionDAG/SelectionDAG.cpp. Whether the mutation may happens or not, depends on how the new node has been; registered in TargetLoweringBase::initActions(). By default all strict nodes are; registered with Expand action::. lib/CodeGen/TargetLoweringBase.cpp. To make debug logs readable it is helpful to update the SelectionDAG's; debug logger:::. lib/CodeGen/SelectionDAG/SelectionDAGDumper.cpp. Add documentation and tests; ===============",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AddingConstrainedIntrinsics.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AddingConstrainedIntrinsics.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AddingConstrainedIntrinsics.rst:2973,Deployability,update,update,2973,"-------------------------. The function SelectionDAGBuilder::visitConstrainedFPIntrinsic builds DAG nodes; using mappings specified in ConstrainedOps.def. If however this default build is; not sufficient, the build can be modified, see how it is implemented for; STRICT_FP_ROUND. The new STRICT node will eventually be converted; to the matching non-STRICT node. For this reason it should have the same; operands and values as the non-STRICT version but should also use the chain.; This makes subsequent sharing of code for STRICT and non-STRICT code paths; easier::. lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp. Most of the STRICT nodes get legalized the same as their matching non-STRICT; counterparts. A new STRICT node with this property must get added to the; switch in SelectionDAGLegalize::LegalizeOp().::. lib/CodeGen/SelectionDAG/LegalizeDAG.cpp. Other parts of the legalizer may need to be updated as well. Look for; places where the non-STRICT counterpart is legalized and update as needed.; Be careful of the chain since STRICT nodes use it but their counterparts; often don't. The code to do the conversion or mutation of the STRICT node to a non-STRICT; version of the node happens in SelectionDAG::mutateStrictFPToFP(). In most cases; the function can do the conversion using information from ConstrainedOps.def. Be; careful updating this function since some nodes have the same return type; as their input operand, but some are different. Both of these cases must; be properly handled::. lib/CodeGen/SelectionDAG/SelectionDAG.cpp. Whether the mutation may happens or not, depends on how the new node has been; registered in TargetLoweringBase::initActions(). By default all strict nodes are; registered with Expand action::. lib/CodeGen/TargetLoweringBase.cpp. To make debug logs readable it is helpful to update the SelectionDAG's; debug logger:::. lib/CodeGen/SelectionDAG/SelectionDAGDumper.cpp. Add documentation and tests; ===========================. ::. docs/LangRef.rst; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AddingConstrainedIntrinsics.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AddingConstrainedIntrinsics.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AddingConstrainedIntrinsics.rst:2739,Integrability,depend,depends,2739,"-------------------------. The function SelectionDAGBuilder::visitConstrainedFPIntrinsic builds DAG nodes; using mappings specified in ConstrainedOps.def. If however this default build is; not sufficient, the build can be modified, see how it is implemented for; STRICT_FP_ROUND. The new STRICT node will eventually be converted; to the matching non-STRICT node. For this reason it should have the same; operands and values as the non-STRICT version but should also use the chain.; This makes subsequent sharing of code for STRICT and non-STRICT code paths; easier::. lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp. Most of the STRICT nodes get legalized the same as their matching non-STRICT; counterparts. A new STRICT node with this property must get added to the; switch in SelectionDAGLegalize::LegalizeOp().::. lib/CodeGen/SelectionDAG/LegalizeDAG.cpp. Other parts of the legalizer may need to be updated as well. Look for; places where the non-STRICT counterpart is legalized and update as needed.; Be careful of the chain since STRICT nodes use it but their counterparts; often don't. The code to do the conversion or mutation of the STRICT node to a non-STRICT; version of the node happens in SelectionDAG::mutateStrictFPToFP(). In most cases; the function can do the conversion using information from ConstrainedOps.def. Be; careful updating this function since some nodes have the same return type; as their input operand, but some are different. Both of these cases must; be properly handled::. lib/CodeGen/SelectionDAG/SelectionDAG.cpp. Whether the mutation may happens or not, depends on how the new node has been; registered in TargetLoweringBase::initActions(). By default all strict nodes are; registered with Expand action::. lib/CodeGen/TargetLoweringBase.cpp. To make debug logs readable it is helpful to update the SelectionDAG's; debug logger:::. lib/CodeGen/SelectionDAG/SelectionDAGDumper.cpp. Add documentation and tests; ===========================. ::. docs/LangRef.rst; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AddingConstrainedIntrinsics.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AddingConstrainedIntrinsics.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AddingConstrainedIntrinsics.rst:2942,Testability,log,logs,2942,"-------------------------. The function SelectionDAGBuilder::visitConstrainedFPIntrinsic builds DAG nodes; using mappings specified in ConstrainedOps.def. If however this default build is; not sufficient, the build can be modified, see how it is implemented for; STRICT_FP_ROUND. The new STRICT node will eventually be converted; to the matching non-STRICT node. For this reason it should have the same; operands and values as the non-STRICT version but should also use the chain.; This makes subsequent sharing of code for STRICT and non-STRICT code paths; easier::. lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp. Most of the STRICT nodes get legalized the same as their matching non-STRICT; counterparts. A new STRICT node with this property must get added to the; switch in SelectionDAGLegalize::LegalizeOp().::. lib/CodeGen/SelectionDAG/LegalizeDAG.cpp. Other parts of the legalizer may need to be updated as well. Look for; places where the non-STRICT counterpart is legalized and update as needed.; Be careful of the chain since STRICT nodes use it but their counterparts; often don't. The code to do the conversion or mutation of the STRICT node to a non-STRICT; version of the node happens in SelectionDAG::mutateStrictFPToFP(). In most cases; the function can do the conversion using information from ConstrainedOps.def. Be; careful updating this function since some nodes have the same return type; as their input operand, but some are different. Both of these cases must; be properly handled::. lib/CodeGen/SelectionDAG/SelectionDAG.cpp. Whether the mutation may happens or not, depends on how the new node has been; registered in TargetLoweringBase::initActions(). By default all strict nodes are; registered with Expand action::. lib/CodeGen/TargetLoweringBase.cpp. To make debug logs readable it is helpful to update the SelectionDAG's; debug logger:::. lib/CodeGen/SelectionDAG/SelectionDAGDumper.cpp. Add documentation and tests; ===========================. ::. docs/LangRef.rst; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AddingConstrainedIntrinsics.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AddingConstrainedIntrinsics.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AddingConstrainedIntrinsics.rst:3006,Testability,log,logger,3006,"-------------------------. The function SelectionDAGBuilder::visitConstrainedFPIntrinsic builds DAG nodes; using mappings specified in ConstrainedOps.def. If however this default build is; not sufficient, the build can be modified, see how it is implemented for; STRICT_FP_ROUND. The new STRICT node will eventually be converted; to the matching non-STRICT node. For this reason it should have the same; operands and values as the non-STRICT version but should also use the chain.; This makes subsequent sharing of code for STRICT and non-STRICT code paths; easier::. lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp. Most of the STRICT nodes get legalized the same as their matching non-STRICT; counterparts. A new STRICT node with this property must get added to the; switch in SelectionDAGLegalize::LegalizeOp().::. lib/CodeGen/SelectionDAG/LegalizeDAG.cpp. Other parts of the legalizer may need to be updated as well. Look for; places where the non-STRICT counterpart is legalized and update as needed.; Be careful of the chain since STRICT nodes use it but their counterparts; often don't. The code to do the conversion or mutation of the STRICT node to a non-STRICT; version of the node happens in SelectionDAG::mutateStrictFPToFP(). In most cases; the function can do the conversion using information from ConstrainedOps.def. Be; careful updating this function since some nodes have the same return type; as their input operand, but some are different. Both of these cases must; be properly handled::. lib/CodeGen/SelectionDAG/SelectionDAG.cpp. Whether the mutation may happens or not, depends on how the new node has been; registered in TargetLoweringBase::initActions(). By default all strict nodes are; registered with Expand action::. lib/CodeGen/TargetLoweringBase.cpp. To make debug logs readable it is helpful to update the SelectionDAG's; debug logger:::. lib/CodeGen/SelectionDAG/SelectionDAGDumper.cpp. Add documentation and tests; ===========================. ::. docs/LangRef.rst; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AddingConstrainedIntrinsics.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AddingConstrainedIntrinsics.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AddingConstrainedIntrinsics.rst:3088,Testability,test,tests,3088,"-------------------------. The function SelectionDAGBuilder::visitConstrainedFPIntrinsic builds DAG nodes; using mappings specified in ConstrainedOps.def. If however this default build is; not sufficient, the build can be modified, see how it is implemented for; STRICT_FP_ROUND. The new STRICT node will eventually be converted; to the matching non-STRICT node. For this reason it should have the same; operands and values as the non-STRICT version but should also use the chain.; This makes subsequent sharing of code for STRICT and non-STRICT code paths; easier::. lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp. Most of the STRICT nodes get legalized the same as their matching non-STRICT; counterparts. A new STRICT node with this property must get added to the; switch in SelectionDAGLegalize::LegalizeOp().::. lib/CodeGen/SelectionDAG/LegalizeDAG.cpp. Other parts of the legalizer may need to be updated as well. Look for; places where the non-STRICT counterpart is legalized and update as needed.; Be careful of the chain since STRICT nodes use it but their counterparts; often don't. The code to do the conversion or mutation of the STRICT node to a non-STRICT; version of the node happens in SelectionDAG::mutateStrictFPToFP(). In most cases; the function can do the conversion using information from ConstrainedOps.def. Be; careful updating this function since some nodes have the same return type; as their input operand, but some are different. Both of these cases must; be properly handled::. lib/CodeGen/SelectionDAG/SelectionDAG.cpp. Whether the mutation may happens or not, depends on how the new node has been; registered in TargetLoweringBase::initActions(). By default all strict nodes are; registered with Expand action::. lib/CodeGen/TargetLoweringBase.cpp. To make debug logs readable it is helpful to update the SelectionDAG's; debug logger:::. lib/CodeGen/SelectionDAG/SelectionDAGDumper.cpp. Add documentation and tests; ===========================. ::. docs/LangRef.rst; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AddingConstrainedIntrinsics.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AddingConstrainedIntrinsics.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:10170,Availability,avail,available,10170,"ted compiler to; generate profdata based on the training files in clang/utils/perf-training. **stage2**; Depends on stage2-instrumented-generate-profdata and will use the stage1; compiler with the stage2 profdata to build a PGO-optimized compiler. **stage2-check-llvm**; Depends on stage2 and runs check-llvm using the stage2 compiler. **stage2-check-clang**; Depends on stage2 and runs check-clang using the stage2 compiler. **stage2-check-all**; Depends on stage2 and runs check-all using the stage2 compiler. **stage2-test-suite**; Depends on stage2 and runs the test-suite using the stage2 compiler (requires; in-tree test-suite). BOLT; ====. `BOLT <https://github.com/llvm/llvm-project/blob/main/bolt/README.md>`_; (Binary Optimization and Layout Tool) is a tool that optimizes binaries; post-link by profiling them at runtime and then using that information to; optimize the layout of the final binary among other optimizations performed; at the binary level. There are also CMake caches available to build; LLVM/Clang with BOLT. To configure a single-stage build that builds LLVM/Clang and then optimizes; it with BOLT, use the following CMake configuration:. .. code-block:: console. $ cmake <path to source>/llvm -C <path to source>/clang/cmake/caches/BOLT.cmake. Then, build the BOLT-optimized binary by running the following ninja command:. .. code-block:: console. $ ninja clang-bolt. If you're seeing errors in the build process, try building with a recent; version of Clang/LLVM by setting the CMAKE_C_COMPILER and; CMAKE_CXX_COMPILER flags to the appropriate values. It is also possible to use BOLT on top of PGO and (Thin)LTO for an even more; significant runtime speedup. To configure a three stage PGO build with ThinLTO; that optimizes the resulting binary with BOLT, use the following CMake; configuration command:. .. code-block:: console. $ cmake -G Ninja <path to source>/llvm \; -C <path to source>/clang/cmake/caches/BOLT-PGO.cmake \; -DBOOTSTRAP_LLVM_ENABLE_LLD=ON \; -DBOOT",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:10590,Availability,error,errors,10590,"ng the stage2 compiler. **stage2-test-suite**; Depends on stage2 and runs the test-suite using the stage2 compiler (requires; in-tree test-suite). BOLT; ====. `BOLT <https://github.com/llvm/llvm-project/blob/main/bolt/README.md>`_; (Binary Optimization and Layout Tool) is a tool that optimizes binaries; post-link by profiling them at runtime and then using that information to; optimize the layout of the final binary among other optimizations performed; at the binary level. There are also CMake caches available to build; LLVM/Clang with BOLT. To configure a single-stage build that builds LLVM/Clang and then optimizes; it with BOLT, use the following CMake configuration:. .. code-block:: console. $ cmake <path to source>/llvm -C <path to source>/clang/cmake/caches/BOLT.cmake. Then, build the BOLT-optimized binary by running the following ninja command:. .. code-block:: console. $ ninja clang-bolt. If you're seeing errors in the build process, try building with a recent; version of Clang/LLVM by setting the CMAKE_C_COMPILER and; CMAKE_CXX_COMPILER flags to the appropriate values. It is also possible to use BOLT on top of PGO and (Thin)LTO for an even more; significant runtime speedup. To configure a three stage PGO build with ThinLTO; that optimizes the resulting binary with BOLT, use the following CMake; configuration command:. .. code-block:: console. $ cmake -G Ninja <path to source>/llvm \; -C <path to source>/clang/cmake/caches/BOLT-PGO.cmake \; -DBOOTSTRAP_LLVM_ENABLE_LLD=ON \; -DBOOTSTRAP_BOOTSTRAP_LLVM_ENABLE_LLD=ON \; -DPGO_INSTRUMENT_LTO=Thin. Then, to build the final optimized binary, build the stage2-clang-bolt target:. .. code-block:: console. $ ninja stage2-clang-bolt. 3-Stage Non-Determinism; =======================. In the ancient lore of compilers non-determinism is like the multi-headed hydra.; Whenever its head pops up, terror and chaos ensue. Historically one of the tests to verify that a compiler was deterministic would; be a three stage build. The ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:704,Deployability,configurat,configurations,704,"=============================; Advanced Build Configurations; =============================. .. contents::; :local:. Introduction; ============. `CMake <http://www.cmake.org/>`_ is a cross-platform build-generator tool. CMake; does not build the project, it generates the files needed by your build tool; (GNU make, Visual Studio, etc.) for building LLVM. If **you are a new contributor**, please start with the :doc:`GettingStarted` or; :doc:`CMake` pages. This page is intended for users doing more complex builds. Many of the examples below are written assuming specific CMake Generators.; Unless otherwise explicitly called out these commands should work with any CMake; generator. Many of the build configurations mentioned on this documentation page can be; utilized by using a CMake cache. A CMake cache is essentially a configuration; file that sets the necessary flags for a specific build configuration. The caches; for Clang are located in :code:`/clang/cmake/caches` within the monorepo. They; can be passed to CMake using the :code:`-C` flag as demonstrated in the examples; below along with additional configuration flags. Bootstrap Builds; ================. The Clang CMake build system supports bootstrap (aka multi-stage) builds. At a; high level a multi-stage build is a chain of builds that pass data from one; stage into the next. The most common and simple version of this is a traditional; bootstrap build. In a simple two-stage bootstrap build, we build clang using the system compiler,; then use that just-built clang to build clang again. In CMake this simplest form; of a bootstrap build can be configured with a single option,; CLANG_ENABLE_BOOTSTRAP. .. code-block:: console. $ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \; -DCLANG_ENABLE_BOOTSTRAP=On \; -DLLVM_ENABLE_PROJECTS=""clang"" \; <path to source>/llvm; $ ninja stage2. This command itself isn't terribly useful because it assumes default; configurations for each stage. The next series of examples utilize CMake cac",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:828,Deployability,configurat,configuration,828,"=============================; Advanced Build Configurations; =============================. .. contents::; :local:. Introduction; ============. `CMake <http://www.cmake.org/>`_ is a cross-platform build-generator tool. CMake; does not build the project, it generates the files needed by your build tool; (GNU make, Visual Studio, etc.) for building LLVM. If **you are a new contributor**, please start with the :doc:`GettingStarted` or; :doc:`CMake` pages. This page is intended for users doing more complex builds. Many of the examples below are written assuming specific CMake Generators.; Unless otherwise explicitly called out these commands should work with any CMake; generator. Many of the build configurations mentioned on this documentation page can be; utilized by using a CMake cache. A CMake cache is essentially a configuration; file that sets the necessary flags for a specific build configuration. The caches; for Clang are located in :code:`/clang/cmake/caches` within the monorepo. They; can be passed to CMake using the :code:`-C` flag as demonstrated in the examples; below along with additional configuration flags. Bootstrap Builds; ================. The Clang CMake build system supports bootstrap (aka multi-stage) builds. At a; high level a multi-stage build is a chain of builds that pass data from one; stage into the next. The most common and simple version of this is a traditional; bootstrap build. In a simple two-stage bootstrap build, we build clang using the system compiler,; then use that just-built clang to build clang again. In CMake this simplest form; of a bootstrap build can be configured with a single option,; CLANG_ENABLE_BOOTSTRAP. .. code-block:: console. $ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \; -DCLANG_ENABLE_BOOTSTRAP=On \; -DLLVM_ENABLE_PROJECTS=""clang"" \; <path to source>/llvm; $ ninja stage2. This command itself isn't terribly useful because it assumes default; configurations for each stage. The next series of examples utilize CMake cac",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:899,Deployability,configurat,configuration,899,"=============================; Advanced Build Configurations; =============================. .. contents::; :local:. Introduction; ============. `CMake <http://www.cmake.org/>`_ is a cross-platform build-generator tool. CMake; does not build the project, it generates the files needed by your build tool; (GNU make, Visual Studio, etc.) for building LLVM. If **you are a new contributor**, please start with the :doc:`GettingStarted` or; :doc:`CMake` pages. This page is intended for users doing more complex builds. Many of the examples below are written assuming specific CMake Generators.; Unless otherwise explicitly called out these commands should work with any CMake; generator. Many of the build configurations mentioned on this documentation page can be; utilized by using a CMake cache. A CMake cache is essentially a configuration; file that sets the necessary flags for a specific build configuration. The caches; for Clang are located in :code:`/clang/cmake/caches` within the monorepo. They; can be passed to CMake using the :code:`-C` flag as demonstrated in the examples; below along with additional configuration flags. Bootstrap Builds; ================. The Clang CMake build system supports bootstrap (aka multi-stage) builds. At a; high level a multi-stage build is a chain of builds that pass data from one; stage into the next. The most common and simple version of this is a traditional; bootstrap build. In a simple two-stage bootstrap build, we build clang using the system compiler,; then use that just-built clang to build clang again. In CMake this simplest form; of a bootstrap build can be configured with a single option,; CLANG_ENABLE_BOOTSTRAP. .. code-block:: console. $ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \; -DCLANG_ENABLE_BOOTSTRAP=On \; -DLLVM_ENABLE_PROJECTS=""clang"" \; <path to source>/llvm; $ ninja stage2. This command itself isn't terribly useful because it assumes default; configurations for each stage. The next series of examples utilize CMake cac",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:1116,Deployability,configurat,configuration,1116,"========================. .. contents::; :local:. Introduction; ============. `CMake <http://www.cmake.org/>`_ is a cross-platform build-generator tool. CMake; does not build the project, it generates the files needed by your build tool; (GNU make, Visual Studio, etc.) for building LLVM. If **you are a new contributor**, please start with the :doc:`GettingStarted` or; :doc:`CMake` pages. This page is intended for users doing more complex builds. Many of the examples below are written assuming specific CMake Generators.; Unless otherwise explicitly called out these commands should work with any CMake; generator. Many of the build configurations mentioned on this documentation page can be; utilized by using a CMake cache. A CMake cache is essentially a configuration; file that sets the necessary flags for a specific build configuration. The caches; for Clang are located in :code:`/clang/cmake/caches` within the monorepo. They; can be passed to CMake using the :code:`-C` flag as demonstrated in the examples; below along with additional configuration flags. Bootstrap Builds; ================. The Clang CMake build system supports bootstrap (aka multi-stage) builds. At a; high level a multi-stage build is a chain of builds that pass data from one; stage into the next. The most common and simple version of this is a traditional; bootstrap build. In a simple two-stage bootstrap build, we build clang using the system compiler,; then use that just-built clang to build clang again. In CMake this simplest form; of a bootstrap build can be configured with a single option,; CLANG_ENABLE_BOOTSTRAP. .. code-block:: console. $ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \; -DCLANG_ENABLE_BOOTSTRAP=On \; -DLLVM_ENABLE_PROJECTS=""clang"" \; <path to source>/llvm; $ ninja stage2. This command itself isn't terribly useful because it assumes default; configurations for each stage. The next series of examples utilize CMake cache; scripts to provide more complex options. By default, only a few",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:1925,Deployability,configurat,configurations,1925,"guration. The caches; for Clang are located in :code:`/clang/cmake/caches` within the monorepo. They; can be passed to CMake using the :code:`-C` flag as demonstrated in the examples; below along with additional configuration flags. Bootstrap Builds; ================. The Clang CMake build system supports bootstrap (aka multi-stage) builds. At a; high level a multi-stage build is a chain of builds that pass data from one; stage into the next. The most common and simple version of this is a traditional; bootstrap build. In a simple two-stage bootstrap build, we build clang using the system compiler,; then use that just-built clang to build clang again. In CMake this simplest form; of a bootstrap build can be configured with a single option,; CLANG_ENABLE_BOOTSTRAP. .. code-block:: console. $ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \; -DCLANG_ENABLE_BOOTSTRAP=On \; -DLLVM_ENABLE_PROJECTS=""clang"" \; <path to source>/llvm; $ ninja stage2. This command itself isn't terribly useful because it assumes default; configurations for each stage. The next series of examples utilize CMake cache; scripts to provide more complex options. By default, only a few CMake options will be passed between stages.; The list, called _BOOTSTRAP_DEFAULT_PASSTHROUGH, is defined in clang/CMakeLists.txt.; To force the passing of the variables between stages, use the -DCLANG_BOOTSTRAP_PASSTHROUGH; CMake option, each variable separated by a "";"". As example:. .. code-block:: console. $ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \; -DCLANG_ENABLE_BOOTSTRAP=On \; -DCLANG_BOOTSTRAP_PASSTHROUGH=""CMAKE_INSTALL_PREFIX;CMAKE_VERBOSE_MAKEFILE"" \; -DLLVM_ENABLE_PROJECTS=""clang"" \; <path to source>/llvm; $ ninja stage2. CMake options starting by ``BOOTSTRAP_`` will be passed only to the stage2 build.; This gives the opportunity to use Clang specific build flags.; For example, the following CMake call will enabled '-fno-addrsig' only during; the stage2 build for C and C++. .. code-block:: console. $ cmake [..] ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:3101,Deployability,install,installed,3101,".; The list, called _BOOTSTRAP_DEFAULT_PASSTHROUGH, is defined in clang/CMakeLists.txt.; To force the passing of the variables between stages, use the -DCLANG_BOOTSTRAP_PASSTHROUGH; CMake option, each variable separated by a "";"". As example:. .. code-block:: console. $ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \; -DCLANG_ENABLE_BOOTSTRAP=On \; -DCLANG_BOOTSTRAP_PASSTHROUGH=""CMAKE_INSTALL_PREFIX;CMAKE_VERBOSE_MAKEFILE"" \; -DLLVM_ENABLE_PROJECTS=""clang"" \; <path to source>/llvm; $ ninja stage2. CMake options starting by ``BOOTSTRAP_`` will be passed only to the stage2 build.; This gives the opportunity to use Clang specific build flags.; For example, the following CMake call will enabled '-fno-addrsig' only during; the stage2 build for C and C++. .. code-block:: console. $ cmake [..] -DBOOTSTRAP_CMAKE_CXX_FLAGS='-fno-addrsig' -DBOOTSTRAP_CMAKE_C_FLAGS='-fno-addrsig' [..]. The clang build system refers to builds as stages. A stage1 build is a standard; build using the compiler installed on the host, and a stage2 build is built; using the stage1 compiler. This nomenclature holds up to more stages too. In; general a stage*n* build is built using the output from stage*n-1*. Apple Clang Builds (A More Complex Bootstrap); =============================================. Apple's Clang builds are a slightly more complicated example of the simple; bootstrapping scenario. Apple Clang is built using a 2-stage build. The stage1 compiler is a host-only compiler with some options set. The stage1; compiler is a balance of optimization vs build time because it is a throwaway.; The stage2 compiler is the fully optimized compiler intended to ship to users. Setting up these compilers requires a lot of options. To simplify the; configuration the Apple Clang build settings are contained in CMake Cache files.; You can build an Apple Clang compiler using the following commands:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/Apple-stage1.cmake <path to source",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:3846,Deployability,configurat,configuration,3846,"ock:: console. $ cmake [..] -DBOOTSTRAP_CMAKE_CXX_FLAGS='-fno-addrsig' -DBOOTSTRAP_CMAKE_C_FLAGS='-fno-addrsig' [..]. The clang build system refers to builds as stages. A stage1 build is a standard; build using the compiler installed on the host, and a stage2 build is built; using the stage1 compiler. This nomenclature holds up to more stages too. In; general a stage*n* build is built using the output from stage*n-1*. Apple Clang Builds (A More Complex Bootstrap); =============================================. Apple's Clang builds are a slightly more complicated example of the simple; bootstrapping scenario. Apple Clang is built using a 2-stage build. The stage1 compiler is a host-only compiler with some options set. The stage1; compiler is a balance of optimization vs build time because it is a throwaway.; The stage2 compiler is the fully optimized compiler intended to ship to users. Setting up these compilers requires a lot of options. To simplify the; configuration the Apple Clang build settings are contained in CMake Cache files.; You can build an Apple Clang compiler using the following commands:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/Apple-stage1.cmake <path to source>/llvm; $ ninja stage2-distribution. This CMake invocation configures the stage1 host compiler, and sets; CLANG_BOOTSTRAP_CMAKE_ARGS to pass the Apple-stage2.cmake cache script to the; stage2 configuration step. When you build the stage2-distribution target it builds the minimal stage1; compiler and required tools, then configures and builds the stage2 compiler; based on the settings in Apple-stage2.cmake. This pattern of using cache scripts to set complex settings, and specifically to; make later stage builds include cache scripts is common in our more advanced; build configurations. Multi-stage PGO; ===============. Profile-Guided Optimizations (PGO) is a really great way to optimize the code; clang generates. Our multi-stage PGO builds are a workflow f",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:4304,Deployability,configurat,configuration,4304,"*. Apple Clang Builds (A More Complex Bootstrap); =============================================. Apple's Clang builds are a slightly more complicated example of the simple; bootstrapping scenario. Apple Clang is built using a 2-stage build. The stage1 compiler is a host-only compiler with some options set. The stage1; compiler is a balance of optimization vs build time because it is a throwaway.; The stage2 compiler is the fully optimized compiler intended to ship to users. Setting up these compilers requires a lot of options. To simplify the; configuration the Apple Clang build settings are contained in CMake Cache files.; You can build an Apple Clang compiler using the following commands:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/Apple-stage1.cmake <path to source>/llvm; $ ninja stage2-distribution. This CMake invocation configures the stage1 host compiler, and sets; CLANG_BOOTSTRAP_CMAKE_ARGS to pass the Apple-stage2.cmake cache script to the; stage2 configuration step. When you build the stage2-distribution target it builds the minimal stage1; compiler and required tools, then configures and builds the stage2 compiler; based on the settings in Apple-stage2.cmake. This pattern of using cache scripts to set complex settings, and specifically to; make later stage builds include cache scripts is common in our more advanced; build configurations. Multi-stage PGO; ===============. Profile-Guided Optimizations (PGO) is a really great way to optimize the code; clang generates. Our multi-stage PGO builds are a workflow for generating PGO; profiles that can be used to optimize clang. At a high level, the way PGO works is that you build an instrumented compiler,; then you run the instrumented compiler against sample source files. While the; instrumented compiler runs it will output a bunch of files containing; performance counters (.profraw files). After generating all the profraw files; you use llvm-profdata to merge the files into a",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:4688,Deployability,configurat,configurations,4688,"e1; compiler is a balance of optimization vs build time because it is a throwaway.; The stage2 compiler is the fully optimized compiler intended to ship to users. Setting up these compilers requires a lot of options. To simplify the; configuration the Apple Clang build settings are contained in CMake Cache files.; You can build an Apple Clang compiler using the following commands:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/Apple-stage1.cmake <path to source>/llvm; $ ninja stage2-distribution. This CMake invocation configures the stage1 host compiler, and sets; CLANG_BOOTSTRAP_CMAKE_ARGS to pass the Apple-stage2.cmake cache script to the; stage2 configuration step. When you build the stage2-distribution target it builds the minimal stage1; compiler and required tools, then configures and builds the stage2 compiler; based on the settings in Apple-stage2.cmake. This pattern of using cache scripts to set complex settings, and specifically to; make later stage builds include cache scripts is common in our more advanced; build configurations. Multi-stage PGO; ===============. Profile-Guided Optimizations (PGO) is a really great way to optimize the code; clang generates. Our multi-stage PGO builds are a workflow for generating PGO; profiles that can be used to optimize clang. At a high level, the way PGO works is that you build an instrumented compiler,; then you run the instrumented compiler against sample source files. While the; instrumented compiler runs it will output a bunch of files containing; performance counters (.profraw files). After generating all the profraw files; you use llvm-profdata to merge the files into a single profdata file that you; can feed into the LLVM_PROFDATA_FILE option. Our PGO.cmake cache automates that whole process. You can use it for; configuration with CMake with the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; <path to source>/llv",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:5444,Deployability,configurat,configuration,5444,"stage2 compiler; based on the settings in Apple-stage2.cmake. This pattern of using cache scripts to set complex settings, and specifically to; make later stage builds include cache scripts is common in our more advanced; build configurations. Multi-stage PGO; ===============. Profile-Guided Optimizations (PGO) is a really great way to optimize the code; clang generates. Our multi-stage PGO builds are a workflow for generating PGO; profiles that can be used to optimize clang. At a high level, the way PGO works is that you build an instrumented compiler,; then you run the instrumented compiler against sample source files. While the; instrumented compiler runs it will output a bunch of files containing; performance counters (.profraw files). After generating all the profraw files; you use llvm-profdata to merge the files into a single profdata file that you; can feed into the LLVM_PROFDATA_FILE option. Our PGO.cmake cache automates that whole process. You can use it for; configuration with CMake with the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; <path to source>/llvm. There are several additional options that the cache file also accepts to modify; the build, particularly the PGO_INSTRUMENT_LTO option. Setting this option to; Thin or Full will enable ThinLTO or full LTO respectively, further enhancing; the performance gains from a PGO build by enabling interprocedural; optimizations. For example, to run a CMake configuration for a PGO build; that also enables ThinTLO, use the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; -DPGO_INSTRUMENT_LTO=Thin \; <path to source>/llvm. By default, clang will generate profile data by compiling a simple; hello world program. You can also tell clang use an external; project for generating profile data that may be a better fit for your; use case. The project you specify must either be a lit test sui",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:5964,Deployability,configurat,configuration,5964,"d an instrumented compiler,; then you run the instrumented compiler against sample source files. While the; instrumented compiler runs it will output a bunch of files containing; performance counters (.profraw files). After generating all the profraw files; you use llvm-profdata to merge the files into a single profdata file that you; can feed into the LLVM_PROFDATA_FILE option. Our PGO.cmake cache automates that whole process. You can use it for; configuration with CMake with the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; <path to source>/llvm. There are several additional options that the cache file also accepts to modify; the build, particularly the PGO_INSTRUMENT_LTO option. Setting this option to; Thin or Full will enable ThinLTO or full LTO respectively, further enhancing; the performance gains from a PGO build by enabling interprocedural; optimizations. For example, to run a CMake configuration for a PGO build; that also enables ThinTLO, use the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; -DPGO_INSTRUMENT_LTO=Thin \; <path to source>/llvm. By default, clang will generate profile data by compiling a simple; hello world program. You can also tell clang use an external; project for generating profile data that may be a better fit for your; use case. The project you specify must either be a lit test suite; (use the CLANG_PGO_TRAINING_DATA option) or a CMake project (use the; CLANG_PERF_TRAINING_DATA_SOURCE_DIR option). For example, If you wanted to use the; `LLVM Test Suite <https://github.com/llvm/llvm-test-suite/>`_ to generate; profile data you would use the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; -DBOOTSTRAP_CLANG_PGO_TRAINING_DATA_SOURCE_DIR=<path to llvm-test-suite> \; -DBOOTSTRAP_CLANG_PGO_TRAINING_DEPS=runtimes. The BOOTSTRAP\_ prefixes tells C",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:7306,Deployability,configurat,configuration,7306,"fy must either be a lit test suite; (use the CLANG_PGO_TRAINING_DATA option) or a CMake project (use the; CLANG_PERF_TRAINING_DATA_SOURCE_DIR option). For example, If you wanted to use the; `LLVM Test Suite <https://github.com/llvm/llvm-test-suite/>`_ to generate; profile data you would use the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; -DBOOTSTRAP_CLANG_PGO_TRAINING_DATA_SOURCE_DIR=<path to llvm-test-suite> \; -DBOOTSTRAP_CLANG_PGO_TRAINING_DEPS=runtimes. The BOOTSTRAP\_ prefixes tells CMake to pass the variables on to the instrumented; stage two build. And the CLANG_PGO_TRAINING_DEPS option let's you specify; additional build targets to build before building the external project. The; LLVM Test Suite requires compiler-rt to build, so we need to add the; `runtimes` target as a dependency. After configuration, building the stage2-instrumented-generate-profdata target; will automatically build the stage1 compiler, build the instrumented compiler; with the stage1 compiler, and then run the instrumented compiler against the; perf training data:. .. code-block:: console. $ ninja stage2-instrumented-generate-profdata. If you let that run for a few hours or so, it will place a profdata file in your; build directory. This takes a really long time because it builds clang twice,; and you *must* have compiler-rt in your build tree. This process uses any source files under the perf-training directory as training; data as long as the source files are marked up with LIT-style RUN lines. After it finishes you can use :code:`find . -name clang.profdata` to find it, but it; should be at a path something like:. .. code-block:: console. <build dir>/tools/clang/stage2-instrumented-bins/utils/perf-training/clang.profdata. You can feed that file into the LLVM_PROFDATA_FILE option when you build your; optimized compiler. It may be necessary to build additional targets before running perf training, such as; builtins an",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:10327,Deployability,configurat,configuration,10327,"2**; Depends on stage2-instrumented-generate-profdata and will use the stage1; compiler with the stage2 profdata to build a PGO-optimized compiler. **stage2-check-llvm**; Depends on stage2 and runs check-llvm using the stage2 compiler. **stage2-check-clang**; Depends on stage2 and runs check-clang using the stage2 compiler. **stage2-check-all**; Depends on stage2 and runs check-all using the stage2 compiler. **stage2-test-suite**; Depends on stage2 and runs the test-suite using the stage2 compiler (requires; in-tree test-suite). BOLT; ====. `BOLT <https://github.com/llvm/llvm-project/blob/main/bolt/README.md>`_; (Binary Optimization and Layout Tool) is a tool that optimizes binaries; post-link by profiling them at runtime and then using that information to; optimize the layout of the final binary among other optimizations performed; at the binary level. There are also CMake caches available to build; LLVM/Clang with BOLT. To configure a single-stage build that builds LLVM/Clang and then optimizes; it with BOLT, use the following CMake configuration:. .. code-block:: console. $ cmake <path to source>/llvm -C <path to source>/clang/cmake/caches/BOLT.cmake. Then, build the BOLT-optimized binary by running the following ninja command:. .. code-block:: console. $ ninja clang-bolt. If you're seeing errors in the build process, try building with a recent; version of Clang/LLVM by setting the CMAKE_C_COMPILER and; CMAKE_CXX_COMPILER flags to the appropriate values. It is also possible to use BOLT on top of PGO and (Thin)LTO for an even more; significant runtime speedup. To configure a three stage PGO build with ThinLTO; that optimizes the resulting binary with BOLT, use the following CMake; configuration command:. .. code-block:: console. $ cmake -G Ninja <path to source>/llvm \; -C <path to source>/clang/cmake/caches/BOLT-PGO.cmake \; -DBOOTSTRAP_LLVM_ENABLE_LLD=ON \; -DBOOTSTRAP_BOOTSTRAP_LLVM_ENABLE_LLD=ON \; -DPGO_INSTRUMENT_LTO=Thin. Then, to build the final optimized b",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:10988,Deployability,configurat,configuration,10988,"a tool that optimizes binaries; post-link by profiling them at runtime and then using that information to; optimize the layout of the final binary among other optimizations performed; at the binary level. There are also CMake caches available to build; LLVM/Clang with BOLT. To configure a single-stage build that builds LLVM/Clang and then optimizes; it with BOLT, use the following CMake configuration:. .. code-block:: console. $ cmake <path to source>/llvm -C <path to source>/clang/cmake/caches/BOLT.cmake. Then, build the BOLT-optimized binary by running the following ninja command:. .. code-block:: console. $ ninja clang-bolt. If you're seeing errors in the build process, try building with a recent; version of Clang/LLVM by setting the CMAKE_C_COMPILER and; CMAKE_CXX_COMPILER flags to the appropriate values. It is also possible to use BOLT on top of PGO and (Thin)LTO for an even more; significant runtime speedup. To configure a three stage PGO build with ThinLTO; that optimizes the resulting binary with BOLT, use the following CMake; configuration command:. .. code-block:: console. $ cmake -G Ninja <path to source>/llvm \; -C <path to source>/clang/cmake/caches/BOLT-PGO.cmake \; -DBOOTSTRAP_LLVM_ENABLE_LLD=ON \; -DBOOTSTRAP_BOOTSTRAP_LLVM_ENABLE_LLD=ON \; -DPGO_INSTRUMENT_LTO=Thin. Then, to build the final optimized binary, build the stage2-clang-bolt target:. .. code-block:: console. $ ninja stage2-clang-bolt. 3-Stage Non-Determinism; =======================. In the ancient lore of compilers non-determinism is like the multi-headed hydra.; Whenever its head pops up, terror and chaos ensue. Historically one of the tests to verify that a compiler was deterministic would; be a three stage build. The idea of a three stage build is you take your sources; and build a compiler (stage1), then use that compiler to rebuild the sources; (stage2), then you use that compiler to rebuild the sources a third time; (stage3) with an identical configuration to the stage2 build. At th",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:11898,Deployability,configurat,configuration,11898,"configuration:. .. code-block:: console. $ cmake <path to source>/llvm -C <path to source>/clang/cmake/caches/BOLT.cmake. Then, build the BOLT-optimized binary by running the following ninja command:. .. code-block:: console. $ ninja clang-bolt. If you're seeing errors in the build process, try building with a recent; version of Clang/LLVM by setting the CMAKE_C_COMPILER and; CMAKE_CXX_COMPILER flags to the appropriate values. It is also possible to use BOLT on top of PGO and (Thin)LTO for an even more; significant runtime speedup. To configure a three stage PGO build with ThinLTO; that optimizes the resulting binary with BOLT, use the following CMake; configuration command:. .. code-block:: console. $ cmake -G Ninja <path to source>/llvm \; -C <path to source>/clang/cmake/caches/BOLT-PGO.cmake \; -DBOOTSTRAP_LLVM_ENABLE_LLD=ON \; -DBOOTSTRAP_BOOTSTRAP_LLVM_ENABLE_LLD=ON \; -DPGO_INSTRUMENT_LTO=Thin. Then, to build the final optimized binary, build the stage2-clang-bolt target:. .. code-block:: console. $ ninja stage2-clang-bolt. 3-Stage Non-Determinism; =======================. In the ancient lore of compilers non-determinism is like the multi-headed hydra.; Whenever its head pops up, terror and chaos ensue. Historically one of the tests to verify that a compiler was deterministic would; be a three stage build. The idea of a three stage build is you take your sources; and build a compiler (stage1), then use that compiler to rebuild the sources; (stage2), then you use that compiler to rebuild the sources a third time; (stage3) with an identical configuration to the stage2 build. At the end of; this, you have a stage2 and stage3 compiler that should be bit-for-bit; identical. You can perform one of these 3-stage builds with LLVM and clang using the; following commands:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/3-stage.cmake <path to source>/llvm; $ ninja stage3. After the build you can compare the stage2 and stage3 compilers.; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:7288,Integrability,depend,dependency,7288,"compiling a simple; hello world program. You can also tell clang use an external; project for generating profile data that may be a better fit for your; use case. The project you specify must either be a lit test suite; (use the CLANG_PGO_TRAINING_DATA option) or a CMake project (use the; CLANG_PERF_TRAINING_DATA_SOURCE_DIR option). For example, If you wanted to use the; `LLVM Test Suite <https://github.com/llvm/llvm-test-suite/>`_ to generate; profile data you would use the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; -DBOOTSTRAP_CLANG_PGO_TRAINING_DATA_SOURCE_DIR=<path to llvm-test-suite> \; -DBOOTSTRAP_CLANG_PGO_TRAINING_DEPS=runtimes. The BOOTSTRAP\_ prefixes tells CMake to pass the variables on to the instrumented; stage two build. And the CLANG_PGO_TRAINING_DEPS option let's you specify; additional build targets to build before building the external project. The; LLVM Test Suite requires compiler-rt to build, so we need to add the; `runtimes` target as a dependency. After configuration, building the stage2-instrumented-generate-profdata target; will automatically build the stage1 compiler, build the instrumented compiler; with the stage1 compiler, and then run the instrumented compiler against the; perf training data:. .. code-block:: console. $ ninja stage2-instrumented-generate-profdata. If you let that run for a few hours or so, it will place a profdata file in your; build directory. This takes a really long time because it builds clang twice,; and you *must* have compiler-rt in your build tree. This process uses any source files under the perf-training directory as training; data as long as the source files are marked up with LIT-style RUN lines. After it finishes you can use :code:`find . -name clang.profdata` to find it, but it; should be at a path something like:. .. code-block:: console. <build dir>/tools/clang/stage2-instrumented-bins/utils/perf-training/clang.profdata. You can feed ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:704,Modifiability,config,configurations,704,"=============================; Advanced Build Configurations; =============================. .. contents::; :local:. Introduction; ============. `CMake <http://www.cmake.org/>`_ is a cross-platform build-generator tool. CMake; does not build the project, it generates the files needed by your build tool; (GNU make, Visual Studio, etc.) for building LLVM. If **you are a new contributor**, please start with the :doc:`GettingStarted` or; :doc:`CMake` pages. This page is intended for users doing more complex builds. Many of the examples below are written assuming specific CMake Generators.; Unless otherwise explicitly called out these commands should work with any CMake; generator. Many of the build configurations mentioned on this documentation page can be; utilized by using a CMake cache. A CMake cache is essentially a configuration; file that sets the necessary flags for a specific build configuration. The caches; for Clang are located in :code:`/clang/cmake/caches` within the monorepo. They; can be passed to CMake using the :code:`-C` flag as demonstrated in the examples; below along with additional configuration flags. Bootstrap Builds; ================. The Clang CMake build system supports bootstrap (aka multi-stage) builds. At a; high level a multi-stage build is a chain of builds that pass data from one; stage into the next. The most common and simple version of this is a traditional; bootstrap build. In a simple two-stage bootstrap build, we build clang using the system compiler,; then use that just-built clang to build clang again. In CMake this simplest form; of a bootstrap build can be configured with a single option,; CLANG_ENABLE_BOOTSTRAP. .. code-block:: console. $ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \; -DCLANG_ENABLE_BOOTSTRAP=On \; -DLLVM_ENABLE_PROJECTS=""clang"" \; <path to source>/llvm; $ ninja stage2. This command itself isn't terribly useful because it assumes default; configurations for each stage. The next series of examples utilize CMake cac",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:828,Modifiability,config,configuration,828,"=============================; Advanced Build Configurations; =============================. .. contents::; :local:. Introduction; ============. `CMake <http://www.cmake.org/>`_ is a cross-platform build-generator tool. CMake; does not build the project, it generates the files needed by your build tool; (GNU make, Visual Studio, etc.) for building LLVM. If **you are a new contributor**, please start with the :doc:`GettingStarted` or; :doc:`CMake` pages. This page is intended for users doing more complex builds. Many of the examples below are written assuming specific CMake Generators.; Unless otherwise explicitly called out these commands should work with any CMake; generator. Many of the build configurations mentioned on this documentation page can be; utilized by using a CMake cache. A CMake cache is essentially a configuration; file that sets the necessary flags for a specific build configuration. The caches; for Clang are located in :code:`/clang/cmake/caches` within the monorepo. They; can be passed to CMake using the :code:`-C` flag as demonstrated in the examples; below along with additional configuration flags. Bootstrap Builds; ================. The Clang CMake build system supports bootstrap (aka multi-stage) builds. At a; high level a multi-stage build is a chain of builds that pass data from one; stage into the next. The most common and simple version of this is a traditional; bootstrap build. In a simple two-stage bootstrap build, we build clang using the system compiler,; then use that just-built clang to build clang again. In CMake this simplest form; of a bootstrap build can be configured with a single option,; CLANG_ENABLE_BOOTSTRAP. .. code-block:: console. $ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \; -DCLANG_ENABLE_BOOTSTRAP=On \; -DLLVM_ENABLE_PROJECTS=""clang"" \; <path to source>/llvm; $ ninja stage2. This command itself isn't terribly useful because it assumes default; configurations for each stage. The next series of examples utilize CMake cac",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:899,Modifiability,config,configuration,899,"=============================; Advanced Build Configurations; =============================. .. contents::; :local:. Introduction; ============. `CMake <http://www.cmake.org/>`_ is a cross-platform build-generator tool. CMake; does not build the project, it generates the files needed by your build tool; (GNU make, Visual Studio, etc.) for building LLVM. If **you are a new contributor**, please start with the :doc:`GettingStarted` or; :doc:`CMake` pages. This page is intended for users doing more complex builds. Many of the examples below are written assuming specific CMake Generators.; Unless otherwise explicitly called out these commands should work with any CMake; generator. Many of the build configurations mentioned on this documentation page can be; utilized by using a CMake cache. A CMake cache is essentially a configuration; file that sets the necessary flags for a specific build configuration. The caches; for Clang are located in :code:`/clang/cmake/caches` within the monorepo. They; can be passed to CMake using the :code:`-C` flag as demonstrated in the examples; below along with additional configuration flags. Bootstrap Builds; ================. The Clang CMake build system supports bootstrap (aka multi-stage) builds. At a; high level a multi-stage build is a chain of builds that pass data from one; stage into the next. The most common and simple version of this is a traditional; bootstrap build. In a simple two-stage bootstrap build, we build clang using the system compiler,; then use that just-built clang to build clang again. In CMake this simplest form; of a bootstrap build can be configured with a single option,; CLANG_ENABLE_BOOTSTRAP. .. code-block:: console. $ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \; -DCLANG_ENABLE_BOOTSTRAP=On \; -DLLVM_ENABLE_PROJECTS=""clang"" \; <path to source>/llvm; $ ninja stage2. This command itself isn't terribly useful because it assumes default; configurations for each stage. The next series of examples utilize CMake cac",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:1116,Modifiability,config,configuration,1116,"========================. .. contents::; :local:. Introduction; ============. `CMake <http://www.cmake.org/>`_ is a cross-platform build-generator tool. CMake; does not build the project, it generates the files needed by your build tool; (GNU make, Visual Studio, etc.) for building LLVM. If **you are a new contributor**, please start with the :doc:`GettingStarted` or; :doc:`CMake` pages. This page is intended for users doing more complex builds. Many of the examples below are written assuming specific CMake Generators.; Unless otherwise explicitly called out these commands should work with any CMake; generator. Many of the build configurations mentioned on this documentation page can be; utilized by using a CMake cache. A CMake cache is essentially a configuration; file that sets the necessary flags for a specific build configuration. The caches; for Clang are located in :code:`/clang/cmake/caches` within the monorepo. They; can be passed to CMake using the :code:`-C` flag as demonstrated in the examples; below along with additional configuration flags. Bootstrap Builds; ================. The Clang CMake build system supports bootstrap (aka multi-stage) builds. At a; high level a multi-stage build is a chain of builds that pass data from one; stage into the next. The most common and simple version of this is a traditional; bootstrap build. In a simple two-stage bootstrap build, we build clang using the system compiler,; then use that just-built clang to build clang again. In CMake this simplest form; of a bootstrap build can be configured with a single option,; CLANG_ENABLE_BOOTSTRAP. .. code-block:: console. $ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \; -DCLANG_ENABLE_BOOTSTRAP=On \; -DLLVM_ENABLE_PROJECTS=""clang"" \; <path to source>/llvm; $ ninja stage2. This command itself isn't terribly useful because it assumes default; configurations for each stage. The next series of examples utilize CMake cache; scripts to provide more complex options. By default, only a few",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:1621,Modifiability,config,configured,1621," called out these commands should work with any CMake; generator. Many of the build configurations mentioned on this documentation page can be; utilized by using a CMake cache. A CMake cache is essentially a configuration; file that sets the necessary flags for a specific build configuration. The caches; for Clang are located in :code:`/clang/cmake/caches` within the monorepo. They; can be passed to CMake using the :code:`-C` flag as demonstrated in the examples; below along with additional configuration flags. Bootstrap Builds; ================. The Clang CMake build system supports bootstrap (aka multi-stage) builds. At a; high level a multi-stage build is a chain of builds that pass data from one; stage into the next. The most common and simple version of this is a traditional; bootstrap build. In a simple two-stage bootstrap build, we build clang using the system compiler,; then use that just-built clang to build clang again. In CMake this simplest form; of a bootstrap build can be configured with a single option,; CLANG_ENABLE_BOOTSTRAP. .. code-block:: console. $ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \; -DCLANG_ENABLE_BOOTSTRAP=On \; -DLLVM_ENABLE_PROJECTS=""clang"" \; <path to source>/llvm; $ ninja stage2. This command itself isn't terribly useful because it assumes default; configurations for each stage. The next series of examples utilize CMake cache; scripts to provide more complex options. By default, only a few CMake options will be passed between stages.; The list, called _BOOTSTRAP_DEFAULT_PASSTHROUGH, is defined in clang/CMakeLists.txt.; To force the passing of the variables between stages, use the -DCLANG_BOOTSTRAP_PASSTHROUGH; CMake option, each variable separated by a "";"". As example:. .. code-block:: console. $ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \; -DCLANG_ENABLE_BOOTSTRAP=On \; -DCLANG_BOOTSTRAP_PASSTHROUGH=""CMAKE_INSTALL_PREFIX;CMAKE_VERBOSE_MAKEFILE"" \; -DLLVM_ENABLE_PROJECTS=""clang"" \; <path to source>/llvm; $ ninja stage2. CMake optio",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:1925,Modifiability,config,configurations,1925,"guration. The caches; for Clang are located in :code:`/clang/cmake/caches` within the monorepo. They; can be passed to CMake using the :code:`-C` flag as demonstrated in the examples; below along with additional configuration flags. Bootstrap Builds; ================. The Clang CMake build system supports bootstrap (aka multi-stage) builds. At a; high level a multi-stage build is a chain of builds that pass data from one; stage into the next. The most common and simple version of this is a traditional; bootstrap build. In a simple two-stage bootstrap build, we build clang using the system compiler,; then use that just-built clang to build clang again. In CMake this simplest form; of a bootstrap build can be configured with a single option,; CLANG_ENABLE_BOOTSTRAP. .. code-block:: console. $ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \; -DCLANG_ENABLE_BOOTSTRAP=On \; -DLLVM_ENABLE_PROJECTS=""clang"" \; <path to source>/llvm; $ ninja stage2. This command itself isn't terribly useful because it assumes default; configurations for each stage. The next series of examples utilize CMake cache; scripts to provide more complex options. By default, only a few CMake options will be passed between stages.; The list, called _BOOTSTRAP_DEFAULT_PASSTHROUGH, is defined in clang/CMakeLists.txt.; To force the passing of the variables between stages, use the -DCLANG_BOOTSTRAP_PASSTHROUGH; CMake option, each variable separated by a "";"". As example:. .. code-block:: console. $ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \; -DCLANG_ENABLE_BOOTSTRAP=On \; -DCLANG_BOOTSTRAP_PASSTHROUGH=""CMAKE_INSTALL_PREFIX;CMAKE_VERBOSE_MAKEFILE"" \; -DLLVM_ENABLE_PROJECTS=""clang"" \; <path to source>/llvm; $ ninja stage2. CMake options starting by ``BOOTSTRAP_`` will be passed only to the stage2 build.; This gives the opportunity to use Clang specific build flags.; For example, the following CMake call will enabled '-fno-addrsig' only during; the stage2 build for C and C++. .. code-block:: console. $ cmake [..] ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:2229,Modifiability,variab,variables,2229,"i-stage build is a chain of builds that pass data from one; stage into the next. The most common and simple version of this is a traditional; bootstrap build. In a simple two-stage bootstrap build, we build clang using the system compiler,; then use that just-built clang to build clang again. In CMake this simplest form; of a bootstrap build can be configured with a single option,; CLANG_ENABLE_BOOTSTRAP. .. code-block:: console. $ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \; -DCLANG_ENABLE_BOOTSTRAP=On \; -DLLVM_ENABLE_PROJECTS=""clang"" \; <path to source>/llvm; $ ninja stage2. This command itself isn't terribly useful because it assumes default; configurations for each stage. The next series of examples utilize CMake cache; scripts to provide more complex options. By default, only a few CMake options will be passed between stages.; The list, called _BOOTSTRAP_DEFAULT_PASSTHROUGH, is defined in clang/CMakeLists.txt.; To force the passing of the variables between stages, use the -DCLANG_BOOTSTRAP_PASSTHROUGH; CMake option, each variable separated by a "";"". As example:. .. code-block:: console. $ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \; -DCLANG_ENABLE_BOOTSTRAP=On \; -DCLANG_BOOTSTRAP_PASSTHROUGH=""CMAKE_INSTALL_PREFIX;CMAKE_VERBOSE_MAKEFILE"" \; -DLLVM_ENABLE_PROJECTS=""clang"" \; <path to source>/llvm; $ ninja stage2. CMake options starting by ``BOOTSTRAP_`` will be passed only to the stage2 build.; This gives the opportunity to use Clang specific build flags.; For example, the following CMake call will enabled '-fno-addrsig' only during; the stage2 build for C and C++. .. code-block:: console. $ cmake [..] -DBOOTSTRAP_CMAKE_CXX_FLAGS='-fno-addrsig' -DBOOTSTRAP_CMAKE_C_FLAGS='-fno-addrsig' [..]. The clang build system refers to builds as stages. A stage1 build is a standard; build using the compiler installed on the host, and a stage2 build is built; using the stage1 compiler. This nomenclature holds up to more stages too. In; general a stage*n* build is built using",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:2313,Modifiability,variab,variable,2313,"i-stage build is a chain of builds that pass data from one; stage into the next. The most common and simple version of this is a traditional; bootstrap build. In a simple two-stage bootstrap build, we build clang using the system compiler,; then use that just-built clang to build clang again. In CMake this simplest form; of a bootstrap build can be configured with a single option,; CLANG_ENABLE_BOOTSTRAP. .. code-block:: console. $ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \; -DCLANG_ENABLE_BOOTSTRAP=On \; -DLLVM_ENABLE_PROJECTS=""clang"" \; <path to source>/llvm; $ ninja stage2. This command itself isn't terribly useful because it assumes default; configurations for each stage. The next series of examples utilize CMake cache; scripts to provide more complex options. By default, only a few CMake options will be passed between stages.; The list, called _BOOTSTRAP_DEFAULT_PASSTHROUGH, is defined in clang/CMakeLists.txt.; To force the passing of the variables between stages, use the -DCLANG_BOOTSTRAP_PASSTHROUGH; CMake option, each variable separated by a "";"". As example:. .. code-block:: console. $ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \; -DCLANG_ENABLE_BOOTSTRAP=On \; -DCLANG_BOOTSTRAP_PASSTHROUGH=""CMAKE_INSTALL_PREFIX;CMAKE_VERBOSE_MAKEFILE"" \; -DLLVM_ENABLE_PROJECTS=""clang"" \; <path to source>/llvm; $ ninja stage2. CMake options starting by ``BOOTSTRAP_`` will be passed only to the stage2 build.; This gives the opportunity to use Clang specific build flags.; For example, the following CMake call will enabled '-fno-addrsig' only during; the stage2 build for C and C++. .. code-block:: console. $ cmake [..] -DBOOTSTRAP_CMAKE_CXX_FLAGS='-fno-addrsig' -DBOOTSTRAP_CMAKE_C_FLAGS='-fno-addrsig' [..]. The clang build system refers to builds as stages. A stage1 build is a standard; build using the compiler installed on the host, and a stage2 build is built; using the stage1 compiler. This nomenclature holds up to more stages too. In; general a stage*n* build is built using",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:3846,Modifiability,config,configuration,3846,"ock:: console. $ cmake [..] -DBOOTSTRAP_CMAKE_CXX_FLAGS='-fno-addrsig' -DBOOTSTRAP_CMAKE_C_FLAGS='-fno-addrsig' [..]. The clang build system refers to builds as stages. A stage1 build is a standard; build using the compiler installed on the host, and a stage2 build is built; using the stage1 compiler. This nomenclature holds up to more stages too. In; general a stage*n* build is built using the output from stage*n-1*. Apple Clang Builds (A More Complex Bootstrap); =============================================. Apple's Clang builds are a slightly more complicated example of the simple; bootstrapping scenario. Apple Clang is built using a 2-stage build. The stage1 compiler is a host-only compiler with some options set. The stage1; compiler is a balance of optimization vs build time because it is a throwaway.; The stage2 compiler is the fully optimized compiler intended to ship to users. Setting up these compilers requires a lot of options. To simplify the; configuration the Apple Clang build settings are contained in CMake Cache files.; You can build an Apple Clang compiler using the following commands:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/Apple-stage1.cmake <path to source>/llvm; $ ninja stage2-distribution. This CMake invocation configures the stage1 host compiler, and sets; CLANG_BOOTSTRAP_CMAKE_ARGS to pass the Apple-stage2.cmake cache script to the; stage2 configuration step. When you build the stage2-distribution target it builds the minimal stage1; compiler and required tools, then configures and builds the stage2 compiler; based on the settings in Apple-stage2.cmake. This pattern of using cache scripts to set complex settings, and specifically to; make later stage builds include cache scripts is common in our more advanced; build configurations. Multi-stage PGO; ===============. Profile-Guided Optimizations (PGO) is a really great way to optimize the code; clang generates. Our multi-stage PGO builds are a workflow f",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:4171,Modifiability,config,configures,4171," more stages too. In; general a stage*n* build is built using the output from stage*n-1*. Apple Clang Builds (A More Complex Bootstrap); =============================================. Apple's Clang builds are a slightly more complicated example of the simple; bootstrapping scenario. Apple Clang is built using a 2-stage build. The stage1 compiler is a host-only compiler with some options set. The stage1; compiler is a balance of optimization vs build time because it is a throwaway.; The stage2 compiler is the fully optimized compiler intended to ship to users. Setting up these compilers requires a lot of options. To simplify the; configuration the Apple Clang build settings are contained in CMake Cache files.; You can build an Apple Clang compiler using the following commands:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/Apple-stage1.cmake <path to source>/llvm; $ ninja stage2-distribution. This CMake invocation configures the stage1 host compiler, and sets; CLANG_BOOTSTRAP_CMAKE_ARGS to pass the Apple-stage2.cmake cache script to the; stage2 configuration step. When you build the stage2-distribution target it builds the minimal stage1; compiler and required tools, then configures and builds the stage2 compiler; based on the settings in Apple-stage2.cmake. This pattern of using cache scripts to set complex settings, and specifically to; make later stage builds include cache scripts is common in our more advanced; build configurations. Multi-stage PGO; ===============. Profile-Guided Optimizations (PGO) is a really great way to optimize the code; clang generates. Our multi-stage PGO builds are a workflow for generating PGO; profiles that can be used to optimize clang. At a high level, the way PGO works is that you build an instrumented compiler,; then you run the instrumented compiler against sample source files. While the; instrumented compiler runs it will output a bunch of files containing; performance counters (.profraw files).",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:4304,Modifiability,config,configuration,4304,"*. Apple Clang Builds (A More Complex Bootstrap); =============================================. Apple's Clang builds are a slightly more complicated example of the simple; bootstrapping scenario. Apple Clang is built using a 2-stage build. The stage1 compiler is a host-only compiler with some options set. The stage1; compiler is a balance of optimization vs build time because it is a throwaway.; The stage2 compiler is the fully optimized compiler intended to ship to users. Setting up these compilers requires a lot of options. To simplify the; configuration the Apple Clang build settings are contained in CMake Cache files.; You can build an Apple Clang compiler using the following commands:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/Apple-stage1.cmake <path to source>/llvm; $ ninja stage2-distribution. This CMake invocation configures the stage1 host compiler, and sets; CLANG_BOOTSTRAP_CMAKE_ARGS to pass the Apple-stage2.cmake cache script to the; stage2 configuration step. When you build the stage2-distribution target it builds the minimal stage1; compiler and required tools, then configures and builds the stage2 compiler; based on the settings in Apple-stage2.cmake. This pattern of using cache scripts to set complex settings, and specifically to; make later stage builds include cache scripts is common in our more advanced; build configurations. Multi-stage PGO; ===============. Profile-Guided Optimizations (PGO) is a really great way to optimize the code; clang generates. Our multi-stage PGO builds are a workflow for generating PGO; profiles that can be used to optimize clang. At a high level, the way PGO works is that you build an instrumented compiler,; then you run the instrumented compiler against sample source files. While the; instrumented compiler runs it will output a bunch of files containing; performance counters (.profraw files). After generating all the profraw files; you use llvm-profdata to merge the files into a",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:4434,Modifiability,config,configures,4434," slightly more complicated example of the simple; bootstrapping scenario. Apple Clang is built using a 2-stage build. The stage1 compiler is a host-only compiler with some options set. The stage1; compiler is a balance of optimization vs build time because it is a throwaway.; The stage2 compiler is the fully optimized compiler intended to ship to users. Setting up these compilers requires a lot of options. To simplify the; configuration the Apple Clang build settings are contained in CMake Cache files.; You can build an Apple Clang compiler using the following commands:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/Apple-stage1.cmake <path to source>/llvm; $ ninja stage2-distribution. This CMake invocation configures the stage1 host compiler, and sets; CLANG_BOOTSTRAP_CMAKE_ARGS to pass the Apple-stage2.cmake cache script to the; stage2 configuration step. When you build the stage2-distribution target it builds the minimal stage1; compiler and required tools, then configures and builds the stage2 compiler; based on the settings in Apple-stage2.cmake. This pattern of using cache scripts to set complex settings, and specifically to; make later stage builds include cache scripts is common in our more advanced; build configurations. Multi-stage PGO; ===============. Profile-Guided Optimizations (PGO) is a really great way to optimize the code; clang generates. Our multi-stage PGO builds are a workflow for generating PGO; profiles that can be used to optimize clang. At a high level, the way PGO works is that you build an instrumented compiler,; then you run the instrumented compiler against sample source files. While the; instrumented compiler runs it will output a bunch of files containing; performance counters (.profraw files). After generating all the profraw files; you use llvm-profdata to merge the files into a single profdata file that you; can feed into the LLVM_PROFDATA_FILE option. Our PGO.cmake cache automates that whole proc",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:4688,Modifiability,config,configurations,4688,"e1; compiler is a balance of optimization vs build time because it is a throwaway.; The stage2 compiler is the fully optimized compiler intended to ship to users. Setting up these compilers requires a lot of options. To simplify the; configuration the Apple Clang build settings are contained in CMake Cache files.; You can build an Apple Clang compiler using the following commands:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/Apple-stage1.cmake <path to source>/llvm; $ ninja stage2-distribution. This CMake invocation configures the stage1 host compiler, and sets; CLANG_BOOTSTRAP_CMAKE_ARGS to pass the Apple-stage2.cmake cache script to the; stage2 configuration step. When you build the stage2-distribution target it builds the minimal stage1; compiler and required tools, then configures and builds the stage2 compiler; based on the settings in Apple-stage2.cmake. This pattern of using cache scripts to set complex settings, and specifically to; make later stage builds include cache scripts is common in our more advanced; build configurations. Multi-stage PGO; ===============. Profile-Guided Optimizations (PGO) is a really great way to optimize the code; clang generates. Our multi-stage PGO builds are a workflow for generating PGO; profiles that can be used to optimize clang. At a high level, the way PGO works is that you build an instrumented compiler,; then you run the instrumented compiler against sample source files. While the; instrumented compiler runs it will output a bunch of files containing; performance counters (.profraw files). After generating all the profraw files; you use llvm-profdata to merge the files into a single profdata file that you; can feed into the LLVM_PROFDATA_FILE option. Our PGO.cmake cache automates that whole process. You can use it for; configuration with CMake with the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; <path to source>/llv",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:5444,Modifiability,config,configuration,5444,"stage2 compiler; based on the settings in Apple-stage2.cmake. This pattern of using cache scripts to set complex settings, and specifically to; make later stage builds include cache scripts is common in our more advanced; build configurations. Multi-stage PGO; ===============. Profile-Guided Optimizations (PGO) is a really great way to optimize the code; clang generates. Our multi-stage PGO builds are a workflow for generating PGO; profiles that can be used to optimize clang. At a high level, the way PGO works is that you build an instrumented compiler,; then you run the instrumented compiler against sample source files. While the; instrumented compiler runs it will output a bunch of files containing; performance counters (.profraw files). After generating all the profraw files; you use llvm-profdata to merge the files into a single profdata file that you; can feed into the LLVM_PROFDATA_FILE option. Our PGO.cmake cache automates that whole process. You can use it for; configuration with CMake with the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; <path to source>/llvm. There are several additional options that the cache file also accepts to modify; the build, particularly the PGO_INSTRUMENT_LTO option. Setting this option to; Thin or Full will enable ThinLTO or full LTO respectively, further enhancing; the performance gains from a PGO build by enabling interprocedural; optimizations. For example, to run a CMake configuration for a PGO build; that also enables ThinTLO, use the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; -DPGO_INSTRUMENT_LTO=Thin \; <path to source>/llvm. By default, clang will generate profile data by compiling a simple; hello world program. You can also tell clang use an external; project for generating profile data that may be a better fit for your; use case. The project you specify must either be a lit test sui",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:5964,Modifiability,config,configuration,5964,"d an instrumented compiler,; then you run the instrumented compiler against sample source files. While the; instrumented compiler runs it will output a bunch of files containing; performance counters (.profraw files). After generating all the profraw files; you use llvm-profdata to merge the files into a single profdata file that you; can feed into the LLVM_PROFDATA_FILE option. Our PGO.cmake cache automates that whole process. You can use it for; configuration with CMake with the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; <path to source>/llvm. There are several additional options that the cache file also accepts to modify; the build, particularly the PGO_INSTRUMENT_LTO option. Setting this option to; Thin or Full will enable ThinLTO or full LTO respectively, further enhancing; the performance gains from a PGO build by enabling interprocedural; optimizations. For example, to run a CMake configuration for a PGO build; that also enables ThinTLO, use the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; -DPGO_INSTRUMENT_LTO=Thin \; <path to source>/llvm. By default, clang will generate profile data by compiling a simple; hello world program. You can also tell clang use an external; project for generating profile data that may be a better fit for your; use case. The project you specify must either be a lit test suite; (use the CLANG_PGO_TRAINING_DATA option) or a CMake project (use the; CLANG_PERF_TRAINING_DATA_SOURCE_DIR option). For example, If you wanted to use the; `LLVM Test Suite <https://github.com/llvm/llvm-test-suite/>`_ to generate; profile data you would use the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; -DBOOTSTRAP_CLANG_PGO_TRAINING_DATA_SOURCE_DIR=<path to llvm-test-suite> \; -DBOOTSTRAP_CLANG_PGO_TRAINING_DEPS=runtimes. The BOOTSTRAP\_ prefixes tells C",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:7009,Modifiability,variab,variables,7009,"les ThinTLO, use the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; -DPGO_INSTRUMENT_LTO=Thin \; <path to source>/llvm. By default, clang will generate profile data by compiling a simple; hello world program. You can also tell clang use an external; project for generating profile data that may be a better fit for your; use case. The project you specify must either be a lit test suite; (use the CLANG_PGO_TRAINING_DATA option) or a CMake project (use the; CLANG_PERF_TRAINING_DATA_SOURCE_DIR option). For example, If you wanted to use the; `LLVM Test Suite <https://github.com/llvm/llvm-test-suite/>`_ to generate; profile data you would use the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; -DBOOTSTRAP_CLANG_PGO_TRAINING_DATA_SOURCE_DIR=<path to llvm-test-suite> \; -DBOOTSTRAP_CLANG_PGO_TRAINING_DEPS=runtimes. The BOOTSTRAP\_ prefixes tells CMake to pass the variables on to the instrumented; stage two build. And the CLANG_PGO_TRAINING_DEPS option let's you specify; additional build targets to build before building the external project. The; LLVM Test Suite requires compiler-rt to build, so we need to add the; `runtimes` target as a dependency. After configuration, building the stage2-instrumented-generate-profdata target; will automatically build the stage1 compiler, build the instrumented compiler; with the stage1 compiler, and then run the instrumented compiler against the; perf training data:. .. code-block:: console. $ ninja stage2-instrumented-generate-profdata. If you let that run for a few hours or so, it will place a profdata file in your; build directory. This takes a really long time because it builds clang twice,; and you *must* have compiler-rt in your build tree. This process uses any source files under the perf-training directory as training; data as long as the source files are marked up with LIT-style RUN lines. After it fi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:7306,Modifiability,config,configuration,7306,"fy must either be a lit test suite; (use the CLANG_PGO_TRAINING_DATA option) or a CMake project (use the; CLANG_PERF_TRAINING_DATA_SOURCE_DIR option). For example, If you wanted to use the; `LLVM Test Suite <https://github.com/llvm/llvm-test-suite/>`_ to generate; profile data you would use the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; -DBOOTSTRAP_CLANG_PGO_TRAINING_DATA_SOURCE_DIR=<path to llvm-test-suite> \; -DBOOTSTRAP_CLANG_PGO_TRAINING_DEPS=runtimes. The BOOTSTRAP\_ prefixes tells CMake to pass the variables on to the instrumented; stage two build. And the CLANG_PGO_TRAINING_DEPS option let's you specify; additional build targets to build before building the external project. The; LLVM Test Suite requires compiler-rt to build, so we need to add the; `runtimes` target as a dependency. After configuration, building the stage2-instrumented-generate-profdata target; will automatically build the stage1 compiler, build the instrumented compiler; with the stage1 compiler, and then run the instrumented compiler against the; perf training data:. .. code-block:: console. $ ninja stage2-instrumented-generate-profdata. If you let that run for a few hours or so, it will place a profdata file in your; build directory. This takes a really long time because it builds clang twice,; and you *must* have compiler-rt in your build tree. This process uses any source files under the perf-training directory as training; data as long as the source files are marked up with LIT-style RUN lines. After it finishes you can use :code:`find . -name clang.profdata` to find it, but it; should be at a path something like:. .. code-block:: console. <build dir>/tools/clang/stage2-instrumented-bins/utils/perf-training/clang.profdata. You can feed that file into the LLVM_PROFDATA_FILE option when you build your; optimized compiler. It may be necessary to build additional targets before running perf training, such as; builtins an",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:8504,Modifiability,variab,variable,8504,"then run the instrumented compiler against the; perf training data:. .. code-block:: console. $ ninja stage2-instrumented-generate-profdata. If you let that run for a few hours or so, it will place a profdata file in your; build directory. This takes a really long time because it builds clang twice,; and you *must* have compiler-rt in your build tree. This process uses any source files under the perf-training directory as training; data as long as the source files are marked up with LIT-style RUN lines. After it finishes you can use :code:`find . -name clang.profdata` to find it, but it; should be at a path something like:. .. code-block:: console. <build dir>/tools/clang/stage2-instrumented-bins/utils/perf-training/clang.profdata. You can feed that file into the LLVM_PROFDATA_FILE option when you build your; optimized compiler. It may be necessary to build additional targets before running perf training, such as; builtins and runtime libraries. You can use the :code:`CLANG_PGO_TRAINING_DEPS` CMake; variable for that purpose:. .. code-block:: cmake. set(CLANG_PGO_TRAINING_DEPS builtins runtimes CACHE STRING """"). The PGO cache has a slightly different stage naming scheme than other; multi-stage builds. It generates three stages: stage1, stage2-instrumented, and; stage2. Both of the stage2 builds are built using the stage1 compiler. The PGO cache generates the following additional targets:. **stage2-instrumented**; Builds a stage1 compiler, runtime, and required tools (llvm-config,; llvm-profdata) then uses that compiler to build an instrumented stage2 compiler. **stage2-instrumented-generate-profdata**; Depends on stage2-instrumented and will use the instrumented compiler to; generate profdata based on the training files in clang/utils/perf-training. **stage2**; Depends on stage2-instrumented-generate-profdata and will use the stage1; compiler with the stage2 profdata to build a PGO-optimized compiler. **stage2-check-llvm**; Depends on stage2 and runs check-llvm using",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:8986,Modifiability,config,config,8986,"RUN lines. After it finishes you can use :code:`find . -name clang.profdata` to find it, but it; should be at a path something like:. .. code-block:: console. <build dir>/tools/clang/stage2-instrumented-bins/utils/perf-training/clang.profdata. You can feed that file into the LLVM_PROFDATA_FILE option when you build your; optimized compiler. It may be necessary to build additional targets before running perf training, such as; builtins and runtime libraries. You can use the :code:`CLANG_PGO_TRAINING_DEPS` CMake; variable for that purpose:. .. code-block:: cmake. set(CLANG_PGO_TRAINING_DEPS builtins runtimes CACHE STRING """"). The PGO cache has a slightly different stage naming scheme than other; multi-stage builds. It generates three stages: stage1, stage2-instrumented, and; stage2. Both of the stage2 builds are built using the stage1 compiler. The PGO cache generates the following additional targets:. **stage2-instrumented**; Builds a stage1 compiler, runtime, and required tools (llvm-config,; llvm-profdata) then uses that compiler to build an instrumented stage2 compiler. **stage2-instrumented-generate-profdata**; Depends on stage2-instrumented and will use the instrumented compiler to; generate profdata based on the training files in clang/utils/perf-training. **stage2**; Depends on stage2-instrumented-generate-profdata and will use the stage1; compiler with the stage2 profdata to build a PGO-optimized compiler. **stage2-check-llvm**; Depends on stage2 and runs check-llvm using the stage2 compiler. **stage2-check-clang**; Depends on stage2 and runs check-clang using the stage2 compiler. **stage2-check-all**; Depends on stage2 and runs check-all using the stage2 compiler. **stage2-test-suite**; Depends on stage2 and runs the test-suite using the stage2 compiler (requires; in-tree test-suite). BOLT; ====. `BOLT <https://github.com/llvm/llvm-project/blob/main/bolt/README.md>`_; (Binary Optimization and Layout Tool) is a tool that optimizes binaries; post-link by profil",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:10215,Modifiability,config,configure,10215,"2**; Depends on stage2-instrumented-generate-profdata and will use the stage1; compiler with the stage2 profdata to build a PGO-optimized compiler. **stage2-check-llvm**; Depends on stage2 and runs check-llvm using the stage2 compiler. **stage2-check-clang**; Depends on stage2 and runs check-clang using the stage2 compiler. **stage2-check-all**; Depends on stage2 and runs check-all using the stage2 compiler. **stage2-test-suite**; Depends on stage2 and runs the test-suite using the stage2 compiler (requires; in-tree test-suite). BOLT; ====. `BOLT <https://github.com/llvm/llvm-project/blob/main/bolt/README.md>`_; (Binary Optimization and Layout Tool) is a tool that optimizes binaries; post-link by profiling them at runtime and then using that information to; optimize the layout of the final binary among other optimizations performed; at the binary level. There are also CMake caches available to build; LLVM/Clang with BOLT. To configure a single-stage build that builds LLVM/Clang and then optimizes; it with BOLT, use the following CMake configuration:. .. code-block:: console. $ cmake <path to source>/llvm -C <path to source>/clang/cmake/caches/BOLT.cmake. Then, build the BOLT-optimized binary by running the following ninja command:. .. code-block:: console. $ ninja clang-bolt. If you're seeing errors in the build process, try building with a recent; version of Clang/LLVM by setting the CMAKE_C_COMPILER and; CMAKE_CXX_COMPILER flags to the appropriate values. It is also possible to use BOLT on top of PGO and (Thin)LTO for an even more; significant runtime speedup. To configure a three stage PGO build with ThinLTO; that optimizes the resulting binary with BOLT, use the following CMake; configuration command:. .. code-block:: console. $ cmake -G Ninja <path to source>/llvm \; -C <path to source>/clang/cmake/caches/BOLT-PGO.cmake \; -DBOOTSTRAP_LLVM_ENABLE_LLD=ON \; -DBOOTSTRAP_BOOTSTRAP_LLVM_ENABLE_LLD=ON \; -DPGO_INSTRUMENT_LTO=Thin. Then, to build the final optimized b",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:10327,Modifiability,config,configuration,10327,"2**; Depends on stage2-instrumented-generate-profdata and will use the stage1; compiler with the stage2 profdata to build a PGO-optimized compiler. **stage2-check-llvm**; Depends on stage2 and runs check-llvm using the stage2 compiler. **stage2-check-clang**; Depends on stage2 and runs check-clang using the stage2 compiler. **stage2-check-all**; Depends on stage2 and runs check-all using the stage2 compiler. **stage2-test-suite**; Depends on stage2 and runs the test-suite using the stage2 compiler (requires; in-tree test-suite). BOLT; ====. `BOLT <https://github.com/llvm/llvm-project/blob/main/bolt/README.md>`_; (Binary Optimization and Layout Tool) is a tool that optimizes binaries; post-link by profiling them at runtime and then using that information to; optimize the layout of the final binary among other optimizations performed; at the binary level. There are also CMake caches available to build; LLVM/Clang with BOLT. To configure a single-stage build that builds LLVM/Clang and then optimizes; it with BOLT, use the following CMake configuration:. .. code-block:: console. $ cmake <path to source>/llvm -C <path to source>/clang/cmake/caches/BOLT.cmake. Then, build the BOLT-optimized binary by running the following ninja command:. .. code-block:: console. $ ninja clang-bolt. If you're seeing errors in the build process, try building with a recent; version of Clang/LLVM by setting the CMAKE_C_COMPILER and; CMAKE_CXX_COMPILER flags to the appropriate values. It is also possible to use BOLT on top of PGO and (Thin)LTO for an even more; significant runtime speedup. To configure a three stage PGO build with ThinLTO; that optimizes the resulting binary with BOLT, use the following CMake; configuration command:. .. code-block:: console. $ cmake -G Ninja <path to source>/llvm \; -C <path to source>/clang/cmake/caches/BOLT-PGO.cmake \; -DBOOTSTRAP_LLVM_ENABLE_LLD=ON \; -DBOOTSTRAP_BOOTSTRAP_LLVM_ENABLE_LLD=ON \; -DPGO_INSTRUMENT_LTO=Thin. Then, to build the final optimized b",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:10868,Modifiability,config,configure,10868,"a tool that optimizes binaries; post-link by profiling them at runtime and then using that information to; optimize the layout of the final binary among other optimizations performed; at the binary level. There are also CMake caches available to build; LLVM/Clang with BOLT. To configure a single-stage build that builds LLVM/Clang and then optimizes; it with BOLT, use the following CMake configuration:. .. code-block:: console. $ cmake <path to source>/llvm -C <path to source>/clang/cmake/caches/BOLT.cmake. Then, build the BOLT-optimized binary by running the following ninja command:. .. code-block:: console. $ ninja clang-bolt. If you're seeing errors in the build process, try building with a recent; version of Clang/LLVM by setting the CMAKE_C_COMPILER and; CMAKE_CXX_COMPILER flags to the appropriate values. It is also possible to use BOLT on top of PGO and (Thin)LTO for an even more; significant runtime speedup. To configure a three stage PGO build with ThinLTO; that optimizes the resulting binary with BOLT, use the following CMake; configuration command:. .. code-block:: console. $ cmake -G Ninja <path to source>/llvm \; -C <path to source>/clang/cmake/caches/BOLT-PGO.cmake \; -DBOOTSTRAP_LLVM_ENABLE_LLD=ON \; -DBOOTSTRAP_BOOTSTRAP_LLVM_ENABLE_LLD=ON \; -DPGO_INSTRUMENT_LTO=Thin. Then, to build the final optimized binary, build the stage2-clang-bolt target:. .. code-block:: console. $ ninja stage2-clang-bolt. 3-Stage Non-Determinism; =======================. In the ancient lore of compilers non-determinism is like the multi-headed hydra.; Whenever its head pops up, terror and chaos ensue. Historically one of the tests to verify that a compiler was deterministic would; be a three stage build. The idea of a three stage build is you take your sources; and build a compiler (stage1), then use that compiler to rebuild the sources; (stage2), then you use that compiler to rebuild the sources a third time; (stage3) with an identical configuration to the stage2 build. At th",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:10988,Modifiability,config,configuration,10988,"a tool that optimizes binaries; post-link by profiling them at runtime and then using that information to; optimize the layout of the final binary among other optimizations performed; at the binary level. There are also CMake caches available to build; LLVM/Clang with BOLT. To configure a single-stage build that builds LLVM/Clang and then optimizes; it with BOLT, use the following CMake configuration:. .. code-block:: console. $ cmake <path to source>/llvm -C <path to source>/clang/cmake/caches/BOLT.cmake. Then, build the BOLT-optimized binary by running the following ninja command:. .. code-block:: console. $ ninja clang-bolt. If you're seeing errors in the build process, try building with a recent; version of Clang/LLVM by setting the CMAKE_C_COMPILER and; CMAKE_CXX_COMPILER flags to the appropriate values. It is also possible to use BOLT on top of PGO and (Thin)LTO for an even more; significant runtime speedup. To configure a three stage PGO build with ThinLTO; that optimizes the resulting binary with BOLT, use the following CMake; configuration command:. .. code-block:: console. $ cmake -G Ninja <path to source>/llvm \; -C <path to source>/clang/cmake/caches/BOLT-PGO.cmake \; -DBOOTSTRAP_LLVM_ENABLE_LLD=ON \; -DBOOTSTRAP_BOOTSTRAP_LLVM_ENABLE_LLD=ON \; -DPGO_INSTRUMENT_LTO=Thin. Then, to build the final optimized binary, build the stage2-clang-bolt target:. .. code-block:: console. $ ninja stage2-clang-bolt. 3-Stage Non-Determinism; =======================. In the ancient lore of compilers non-determinism is like the multi-headed hydra.; Whenever its head pops up, terror and chaos ensue. Historically one of the tests to verify that a compiler was deterministic would; be a three stage build. The idea of a three stage build is you take your sources; and build a compiler (stage1), then use that compiler to rebuild the sources; (stage2), then you use that compiler to rebuild the sources a third time; (stage3) with an identical configuration to the stage2 build. At th",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:11898,Modifiability,config,configuration,11898,"configuration:. .. code-block:: console. $ cmake <path to source>/llvm -C <path to source>/clang/cmake/caches/BOLT.cmake. Then, build the BOLT-optimized binary by running the following ninja command:. .. code-block:: console. $ ninja clang-bolt. If you're seeing errors in the build process, try building with a recent; version of Clang/LLVM by setting the CMAKE_C_COMPILER and; CMAKE_CXX_COMPILER flags to the appropriate values. It is also possible to use BOLT on top of PGO and (Thin)LTO for an even more; significant runtime speedup. To configure a three stage PGO build with ThinLTO; that optimizes the resulting binary with BOLT, use the following CMake; configuration command:. .. code-block:: console. $ cmake -G Ninja <path to source>/llvm \; -C <path to source>/clang/cmake/caches/BOLT-PGO.cmake \; -DBOOTSTRAP_LLVM_ENABLE_LLD=ON \; -DBOOTSTRAP_BOOTSTRAP_LLVM_ENABLE_LLD=ON \; -DPGO_INSTRUMENT_LTO=Thin. Then, to build the final optimized binary, build the stage2-clang-bolt target:. .. code-block:: console. $ ninja stage2-clang-bolt. 3-Stage Non-Determinism; =======================. In the ancient lore of compilers non-determinism is like the multi-headed hydra.; Whenever its head pops up, terror and chaos ensue. Historically one of the tests to verify that a compiler was deterministic would; be a three stage build. The idea of a three stage build is you take your sources; and build a compiler (stage1), then use that compiler to rebuild the sources; (stage2), then you use that compiler to rebuild the sources a third time; (stage3) with an identical configuration to the stage2 build. At the end of; this, you have a stage2 and stage3 compiler that should be bit-for-bit; identical. You can perform one of these 3-stage builds with LLVM and clang using the; following commands:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/3-stage.cmake <path to source>/llvm; $ ninja stage3. After the build you can compare the stage2 and stage3 compilers.; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:790,Performance,cache,cache,790,"=============================; Advanced Build Configurations; =============================. .. contents::; :local:. Introduction; ============. `CMake <http://www.cmake.org/>`_ is a cross-platform build-generator tool. CMake; does not build the project, it generates the files needed by your build tool; (GNU make, Visual Studio, etc.) for building LLVM. If **you are a new contributor**, please start with the :doc:`GettingStarted` or; :doc:`CMake` pages. This page is intended for users doing more complex builds. Many of the examples below are written assuming specific CMake Generators.; Unless otherwise explicitly called out these commands should work with any CMake; generator. Many of the build configurations mentioned on this documentation page can be; utilized by using a CMake cache. A CMake cache is essentially a configuration; file that sets the necessary flags for a specific build configuration. The caches; for Clang are located in :code:`/clang/cmake/caches` within the monorepo. They; can be passed to CMake using the :code:`-C` flag as demonstrated in the examples; below along with additional configuration flags. Bootstrap Builds; ================. The Clang CMake build system supports bootstrap (aka multi-stage) builds. At a; high level a multi-stage build is a chain of builds that pass data from one; stage into the next. The most common and simple version of this is a traditional; bootstrap build. In a simple two-stage bootstrap build, we build clang using the system compiler,; then use that just-built clang to build clang again. In CMake this simplest form; of a bootstrap build can be configured with a single option,; CLANG_ENABLE_BOOTSTRAP. .. code-block:: console. $ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \; -DCLANG_ENABLE_BOOTSTRAP=On \; -DLLVM_ENABLE_PROJECTS=""clang"" \; <path to source>/llvm; $ ninja stage2. This command itself isn't terribly useful because it assumes default; configurations for each stage. The next series of examples utilize CMake cac",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:805,Performance,cache,cache,805,"=============================; Advanced Build Configurations; =============================. .. contents::; :local:. Introduction; ============. `CMake <http://www.cmake.org/>`_ is a cross-platform build-generator tool. CMake; does not build the project, it generates the files needed by your build tool; (GNU make, Visual Studio, etc.) for building LLVM. If **you are a new contributor**, please start with the :doc:`GettingStarted` or; :doc:`CMake` pages. This page is intended for users doing more complex builds. Many of the examples below are written assuming specific CMake Generators.; Unless otherwise explicitly called out these commands should work with any CMake; generator. Many of the build configurations mentioned on this documentation page can be; utilized by using a CMake cache. A CMake cache is essentially a configuration; file that sets the necessary flags for a specific build configuration. The caches; for Clang are located in :code:`/clang/cmake/caches` within the monorepo. They; can be passed to CMake using the :code:`-C` flag as demonstrated in the examples; below along with additional configuration flags. Bootstrap Builds; ================. The Clang CMake build system supports bootstrap (aka multi-stage) builds. At a; high level a multi-stage build is a chain of builds that pass data from one; stage into the next. The most common and simple version of this is a traditional; bootstrap build. In a simple two-stage bootstrap build, we build clang using the system compiler,; then use that just-built clang to build clang again. In CMake this simplest form; of a bootstrap build can be configured with a single option,; CLANG_ENABLE_BOOTSTRAP. .. code-block:: console. $ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \; -DCLANG_ENABLE_BOOTSTRAP=On \; -DLLVM_ENABLE_PROJECTS=""clang"" \; <path to source>/llvm; $ ninja stage2. This command itself isn't terribly useful because it assumes default; configurations for each stage. The next series of examples utilize CMake cac",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:918,Performance,cache,caches,918,"=============================; Advanced Build Configurations; =============================. .. contents::; :local:. Introduction; ============. `CMake <http://www.cmake.org/>`_ is a cross-platform build-generator tool. CMake; does not build the project, it generates the files needed by your build tool; (GNU make, Visual Studio, etc.) for building LLVM. If **you are a new contributor**, please start with the :doc:`GettingStarted` or; :doc:`CMake` pages. This page is intended for users doing more complex builds. Many of the examples below are written assuming specific CMake Generators.; Unless otherwise explicitly called out these commands should work with any CMake; generator. Many of the build configurations mentioned on this documentation page can be; utilized by using a CMake cache. A CMake cache is essentially a configuration; file that sets the necessary flags for a specific build configuration. The caches; for Clang are located in :code:`/clang/cmake/caches` within the monorepo. They; can be passed to CMake using the :code:`-C` flag as demonstrated in the examples; below along with additional configuration flags. Bootstrap Builds; ================. The Clang CMake build system supports bootstrap (aka multi-stage) builds. At a; high level a multi-stage build is a chain of builds that pass data from one; stage into the next. The most common and simple version of this is a traditional; bootstrap build. In a simple two-stage bootstrap build, we build clang using the system compiler,; then use that just-built clang to build clang again. In CMake this simplest form; of a bootstrap build can be configured with a single option,; CLANG_ENABLE_BOOTSTRAP. .. code-block:: console. $ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \; -DCLANG_ENABLE_BOOTSTRAP=On \; -DLLVM_ENABLE_PROJECTS=""clang"" \; <path to source>/llvm; $ ninja stage2. This command itself isn't terribly useful because it assumes default; configurations for each stage. The next series of examples utilize CMake cac",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:971,Performance,cache,caches,971,"=============================; Advanced Build Configurations; =============================. .. contents::; :local:. Introduction; ============. `CMake <http://www.cmake.org/>`_ is a cross-platform build-generator tool. CMake; does not build the project, it generates the files needed by your build tool; (GNU make, Visual Studio, etc.) for building LLVM. If **you are a new contributor**, please start with the :doc:`GettingStarted` or; :doc:`CMake` pages. This page is intended for users doing more complex builds. Many of the examples below are written assuming specific CMake Generators.; Unless otherwise explicitly called out these commands should work with any CMake; generator. Many of the build configurations mentioned on this documentation page can be; utilized by using a CMake cache. A CMake cache is essentially a configuration; file that sets the necessary flags for a specific build configuration. The caches; for Clang are located in :code:`/clang/cmake/caches` within the monorepo. They; can be passed to CMake using the :code:`-C` flag as demonstrated in the examples; below along with additional configuration flags. Bootstrap Builds; ================. The Clang CMake build system supports bootstrap (aka multi-stage) builds. At a; high level a multi-stage build is a chain of builds that pass data from one; stage into the next. The most common and simple version of this is a traditional; bootstrap build. In a simple two-stage bootstrap build, we build clang using the system compiler,; then use that just-built clang to build clang again. In CMake this simplest form; of a bootstrap build can be configured with a single option,; CLANG_ENABLE_BOOTSTRAP. .. code-block:: console. $ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \; -DCLANG_ENABLE_BOOTSTRAP=On \; -DLLVM_ENABLE_PROJECTS=""clang"" \; <path to source>/llvm; $ ninja stage2. This command itself isn't terribly useful because it assumes default; configurations for each stage. The next series of examples utilize CMake cac",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:1998,Performance,cache,cache,1998,"They; can be passed to CMake using the :code:`-C` flag as demonstrated in the examples; below along with additional configuration flags. Bootstrap Builds; ================. The Clang CMake build system supports bootstrap (aka multi-stage) builds. At a; high level a multi-stage build is a chain of builds that pass data from one; stage into the next. The most common and simple version of this is a traditional; bootstrap build. In a simple two-stage bootstrap build, we build clang using the system compiler,; then use that just-built clang to build clang again. In CMake this simplest form; of a bootstrap build can be configured with a single option,; CLANG_ENABLE_BOOTSTRAP. .. code-block:: console. $ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \; -DCLANG_ENABLE_BOOTSTRAP=On \; -DLLVM_ENABLE_PROJECTS=""clang"" \; <path to source>/llvm; $ ninja stage2. This command itself isn't terribly useful because it assumes default; configurations for each stage. The next series of examples utilize CMake cache; scripts to provide more complex options. By default, only a few CMake options will be passed between stages.; The list, called _BOOTSTRAP_DEFAULT_PASSTHROUGH, is defined in clang/CMakeLists.txt.; To force the passing of the variables between stages, use the -DCLANG_BOOTSTRAP_PASSTHROUGH; CMake option, each variable separated by a "";"". As example:. .. code-block:: console. $ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \; -DCLANG_ENABLE_BOOTSTRAP=On \; -DCLANG_BOOTSTRAP_PASSTHROUGH=""CMAKE_INSTALL_PREFIX;CMAKE_VERBOSE_MAKEFILE"" \; -DLLVM_ENABLE_PROJECTS=""clang"" \; <path to source>/llvm; $ ninja stage2. CMake options starting by ``BOOTSTRAP_`` will be passed only to the stage2 build.; This gives the opportunity to use Clang specific build flags.; For example, the following CMake call will enabled '-fno-addrsig' only during; the stage2 build for C and C++. .. code-block:: console. $ cmake [..] -DBOOTSTRAP_CMAKE_CXX_FLAGS='-fno-addrsig' -DBOOTSTRAP_CMAKE_C_FLAGS='-fno-addrsig' [..]. The c",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:3641,Performance,optimiz,optimization,3641,"`` will be passed only to the stage2 build.; This gives the opportunity to use Clang specific build flags.; For example, the following CMake call will enabled '-fno-addrsig' only during; the stage2 build for C and C++. .. code-block:: console. $ cmake [..] -DBOOTSTRAP_CMAKE_CXX_FLAGS='-fno-addrsig' -DBOOTSTRAP_CMAKE_C_FLAGS='-fno-addrsig' [..]. The clang build system refers to builds as stages. A stage1 build is a standard; build using the compiler installed on the host, and a stage2 build is built; using the stage1 compiler. This nomenclature holds up to more stages too. In; general a stage*n* build is built using the output from stage*n-1*. Apple Clang Builds (A More Complex Bootstrap); =============================================. Apple's Clang builds are a slightly more complicated example of the simple; bootstrapping scenario. Apple Clang is built using a 2-stage build. The stage1 compiler is a host-only compiler with some options set. The stage1; compiler is a balance of optimization vs build time because it is a throwaway.; The stage2 compiler is the fully optimized compiler intended to ship to users. Setting up these compilers requires a lot of options. To simplify the; configuration the Apple Clang build settings are contained in CMake Cache files.; You can build an Apple Clang compiler using the following commands:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/Apple-stage1.cmake <path to source>/llvm; $ ninja stage2-distribution. This CMake invocation configures the stage1 host compiler, and sets; CLANG_BOOTSTRAP_CMAKE_ARGS to pass the Apple-stage2.cmake cache script to the; stage2 configuration step. When you build the stage2-distribution target it builds the minimal stage1; compiler and required tools, then configures and builds the stage2 compiler; based on the settings in Apple-stage2.cmake. This pattern of using cache scripts to set complex settings, and specifically to; make later stage builds include cache scripts",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:3729,Performance,optimiz,optimized,3729,"pecific build flags.; For example, the following CMake call will enabled '-fno-addrsig' only during; the stage2 build for C and C++. .. code-block:: console. $ cmake [..] -DBOOTSTRAP_CMAKE_CXX_FLAGS='-fno-addrsig' -DBOOTSTRAP_CMAKE_C_FLAGS='-fno-addrsig' [..]. The clang build system refers to builds as stages. A stage1 build is a standard; build using the compiler installed on the host, and a stage2 build is built; using the stage1 compiler. This nomenclature holds up to more stages too. In; general a stage*n* build is built using the output from stage*n-1*. Apple Clang Builds (A More Complex Bootstrap); =============================================. Apple's Clang builds are a slightly more complicated example of the simple; bootstrapping scenario. Apple Clang is built using a 2-stage build. The stage1 compiler is a host-only compiler with some options set. The stage1; compiler is a balance of optimization vs build time because it is a throwaway.; The stage2 compiler is the fully optimized compiler intended to ship to users. Setting up these compilers requires a lot of options. To simplify the; configuration the Apple Clang build settings are contained in CMake Cache files.; You can build an Apple Clang compiler using the following commands:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/Apple-stage1.cmake <path to source>/llvm; $ ninja stage2-distribution. This CMake invocation configures the stage1 host compiler, and sets; CLANG_BOOTSTRAP_CMAKE_ARGS to pass the Apple-stage2.cmake cache script to the; stage2 configuration step. When you build the stage2-distribution target it builds the minimal stage1; compiler and required tools, then configures and builds the stage2 compiler; based on the settings in Apple-stage2.cmake. This pattern of using cache scripts to set complex settings, and specifically to; make later stage builds include cache scripts is common in our more advanced; build configurations. Multi-stage PGO; =============",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:4071,Performance,cache,caches,4071,"uild is a standard; build using the compiler installed on the host, and a stage2 build is built; using the stage1 compiler. This nomenclature holds up to more stages too. In; general a stage*n* build is built using the output from stage*n-1*. Apple Clang Builds (A More Complex Bootstrap); =============================================. Apple's Clang builds are a slightly more complicated example of the simple; bootstrapping scenario. Apple Clang is built using a 2-stage build. The stage1 compiler is a host-only compiler with some options set. The stage1; compiler is a balance of optimization vs build time because it is a throwaway.; The stage2 compiler is the fully optimized compiler intended to ship to users. Setting up these compilers requires a lot of options. To simplify the; configuration the Apple Clang build settings are contained in CMake Cache files.; You can build an Apple Clang compiler using the following commands:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/Apple-stage1.cmake <path to source>/llvm; $ ninja stage2-distribution. This CMake invocation configures the stage1 host compiler, and sets; CLANG_BOOTSTRAP_CMAKE_ARGS to pass the Apple-stage2.cmake cache script to the; stage2 configuration step. When you build the stage2-distribution target it builds the minimal stage1; compiler and required tools, then configures and builds the stage2 compiler; based on the settings in Apple-stage2.cmake. This pattern of using cache scripts to set complex settings, and specifically to; make later stage builds include cache scripts is common in our more advanced; build configurations. Multi-stage PGO; ===============. Profile-Guided Optimizations (PGO) is a really great way to optimize the code; clang generates. Our multi-stage PGO builds are a workflow for generating PGO; profiles that can be used to optimize clang. At a high level, the way PGO works is that you build an instrumented compiler,; then you run the instrumented compi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:4276,Performance,cache,cache,4276,"*. Apple Clang Builds (A More Complex Bootstrap); =============================================. Apple's Clang builds are a slightly more complicated example of the simple; bootstrapping scenario. Apple Clang is built using a 2-stage build. The stage1 compiler is a host-only compiler with some options set. The stage1; compiler is a balance of optimization vs build time because it is a throwaway.; The stage2 compiler is the fully optimized compiler intended to ship to users. Setting up these compilers requires a lot of options. To simplify the; configuration the Apple Clang build settings are contained in CMake Cache files.; You can build an Apple Clang compiler using the following commands:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/Apple-stage1.cmake <path to source>/llvm; $ ninja stage2-distribution. This CMake invocation configures the stage1 host compiler, and sets; CLANG_BOOTSTRAP_CMAKE_ARGS to pass the Apple-stage2.cmake cache script to the; stage2 configuration step. When you build the stage2-distribution target it builds the minimal stage1; compiler and required tools, then configures and builds the stage2 compiler; based on the settings in Apple-stage2.cmake. This pattern of using cache scripts to set complex settings, and specifically to; make later stage builds include cache scripts is common in our more advanced; build configurations. Multi-stage PGO; ===============. Profile-Guided Optimizations (PGO) is a really great way to optimize the code; clang generates. Our multi-stage PGO builds are a workflow for generating PGO; profiles that can be used to optimize clang. At a high level, the way PGO works is that you build an instrumented compiler,; then you run the instrumented compiler against sample source files. While the; instrumented compiler runs it will output a bunch of files containing; performance counters (.profraw files). After generating all the profraw files; you use llvm-profdata to merge the files into a",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:4544,Performance,cache,cache,4544,"e1; compiler is a balance of optimization vs build time because it is a throwaway.; The stage2 compiler is the fully optimized compiler intended to ship to users. Setting up these compilers requires a lot of options. To simplify the; configuration the Apple Clang build settings are contained in CMake Cache files.; You can build an Apple Clang compiler using the following commands:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/Apple-stage1.cmake <path to source>/llvm; $ ninja stage2-distribution. This CMake invocation configures the stage1 host compiler, and sets; CLANG_BOOTSTRAP_CMAKE_ARGS to pass the Apple-stage2.cmake cache script to the; stage2 configuration step. When you build the stage2-distribution target it builds the minimal stage1; compiler and required tools, then configures and builds the stage2 compiler; based on the settings in Apple-stage2.cmake. This pattern of using cache scripts to set complex settings, and specifically to; make later stage builds include cache scripts is common in our more advanced; build configurations. Multi-stage PGO; ===============. Profile-Guided Optimizations (PGO) is a really great way to optimize the code; clang generates. Our multi-stage PGO builds are a workflow for generating PGO; profiles that can be used to optimize clang. At a high level, the way PGO works is that you build an instrumented compiler,; then you run the instrumented compiler against sample source files. While the; instrumented compiler runs it will output a bunch of files containing; performance counters (.profraw files). After generating all the profraw files; you use llvm-profdata to merge the files into a single profdata file that you; can feed into the LLVM_PROFDATA_FILE option. Our PGO.cmake cache automates that whole process. You can use it for; configuration with CMake with the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; <path to source>/llv",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:4636,Performance,cache,cache,4636,"e1; compiler is a balance of optimization vs build time because it is a throwaway.; The stage2 compiler is the fully optimized compiler intended to ship to users. Setting up these compilers requires a lot of options. To simplify the; configuration the Apple Clang build settings are contained in CMake Cache files.; You can build an Apple Clang compiler using the following commands:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/Apple-stage1.cmake <path to source>/llvm; $ ninja stage2-distribution. This CMake invocation configures the stage1 host compiler, and sets; CLANG_BOOTSTRAP_CMAKE_ARGS to pass the Apple-stage2.cmake cache script to the; stage2 configuration step. When you build the stage2-distribution target it builds the minimal stage1; compiler and required tools, then configures and builds the stage2 compiler; based on the settings in Apple-stage2.cmake. This pattern of using cache scripts to set complex settings, and specifically to; make later stage builds include cache scripts is common in our more advanced; build configurations. Multi-stage PGO; ===============. Profile-Guided Optimizations (PGO) is a really great way to optimize the code; clang generates. Our multi-stage PGO builds are a workflow for generating PGO; profiles that can be used to optimize clang. At a high level, the way PGO works is that you build an instrumented compiler,; then you run the instrumented compiler against sample source files. While the; instrumented compiler runs it will output a bunch of files containing; performance counters (.profraw files). After generating all the profraw files; you use llvm-profdata to merge the files into a single profdata file that you; can feed into the LLVM_PROFDATA_FILE option. Our PGO.cmake cache automates that whole process. You can use it for; configuration with CMake with the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; <path to source>/llv",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:4798,Performance,optimiz,optimize,4798," these compilers requires a lot of options. To simplify the; configuration the Apple Clang build settings are contained in CMake Cache files.; You can build an Apple Clang compiler using the following commands:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/Apple-stage1.cmake <path to source>/llvm; $ ninja stage2-distribution. This CMake invocation configures the stage1 host compiler, and sets; CLANG_BOOTSTRAP_CMAKE_ARGS to pass the Apple-stage2.cmake cache script to the; stage2 configuration step. When you build the stage2-distribution target it builds the minimal stage1; compiler and required tools, then configures and builds the stage2 compiler; based on the settings in Apple-stage2.cmake. This pattern of using cache scripts to set complex settings, and specifically to; make later stage builds include cache scripts is common in our more advanced; build configurations. Multi-stage PGO; ===============. Profile-Guided Optimizations (PGO) is a really great way to optimize the code; clang generates. Our multi-stage PGO builds are a workflow for generating PGO; profiles that can be used to optimize clang. At a high level, the way PGO works is that you build an instrumented compiler,; then you run the instrumented compiler against sample source files. While the; instrumented compiler runs it will output a bunch of files containing; performance counters (.profraw files). After generating all the profraw files; you use llvm-profdata to merge the files into a single profdata file that you; can feed into the LLVM_PROFDATA_FILE option. Our PGO.cmake cache automates that whole process. You can use it for; configuration with CMake with the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; <path to source>/llvm. There are several additional options that the cache file also accepts to modify; the build, particularly the PGO_INSTRUMENT_LTO option. Setting this option to; Thin or Fu",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:4925,Performance,optimiz,optimize,4925,"ings are contained in CMake Cache files.; You can build an Apple Clang compiler using the following commands:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/Apple-stage1.cmake <path to source>/llvm; $ ninja stage2-distribution. This CMake invocation configures the stage1 host compiler, and sets; CLANG_BOOTSTRAP_CMAKE_ARGS to pass the Apple-stage2.cmake cache script to the; stage2 configuration step. When you build the stage2-distribution target it builds the minimal stage1; compiler and required tools, then configures and builds the stage2 compiler; based on the settings in Apple-stage2.cmake. This pattern of using cache scripts to set complex settings, and specifically to; make later stage builds include cache scripts is common in our more advanced; build configurations. Multi-stage PGO; ===============. Profile-Guided Optimizations (PGO) is a really great way to optimize the code; clang generates. Our multi-stage PGO builds are a workflow for generating PGO; profiles that can be used to optimize clang. At a high level, the way PGO works is that you build an instrumented compiler,; then you run the instrumented compiler against sample source files. While the; instrumented compiler runs it will output a bunch of files containing; performance counters (.profraw files). After generating all the profraw files; you use llvm-profdata to merge the files into a single profdata file that you; can feed into the LLVM_PROFDATA_FILE option. Our PGO.cmake cache automates that whole process. You can use it for; configuration with CMake with the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; <path to source>/llvm. There are several additional options that the cache file also accepts to modify; the build, particularly the PGO_INSTRUMENT_LTO option. Setting this option to; Thin or Full will enable ThinLTO or full LTO respectively, further enhancing; the performance gains from a PGO b",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:5171,Performance,perform,performance,5171,"bution. This CMake invocation configures the stage1 host compiler, and sets; CLANG_BOOTSTRAP_CMAKE_ARGS to pass the Apple-stage2.cmake cache script to the; stage2 configuration step. When you build the stage2-distribution target it builds the minimal stage1; compiler and required tools, then configures and builds the stage2 compiler; based on the settings in Apple-stage2.cmake. This pattern of using cache scripts to set complex settings, and specifically to; make later stage builds include cache scripts is common in our more advanced; build configurations. Multi-stage PGO; ===============. Profile-Guided Optimizations (PGO) is a really great way to optimize the code; clang generates. Our multi-stage PGO builds are a workflow for generating PGO; profiles that can be used to optimize clang. At a high level, the way PGO works is that you build an instrumented compiler,; then you run the instrumented compiler against sample source files. While the; instrumented compiler runs it will output a bunch of files containing; performance counters (.profraw files). After generating all the profraw files; you use llvm-profdata to merge the files into a single profdata file that you; can feed into the LLVM_PROFDATA_FILE option. Our PGO.cmake cache automates that whole process. You can use it for; configuration with CMake with the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; <path to source>/llvm. There are several additional options that the cache file also accepts to modify; the build, particularly the PGO_INSTRUMENT_LTO option. Setting this option to; Thin or Full will enable ThinLTO or full LTO respectively, further enhancing; the performance gains from a PGO build by enabling interprocedural; optimizations. For example, to run a CMake configuration for a PGO build; that also enables ThinTLO, use the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:5388,Performance,cache,cache,5388,"mpiler and required tools, then configures and builds the stage2 compiler; based on the settings in Apple-stage2.cmake. This pattern of using cache scripts to set complex settings, and specifically to; make later stage builds include cache scripts is common in our more advanced; build configurations. Multi-stage PGO; ===============. Profile-Guided Optimizations (PGO) is a really great way to optimize the code; clang generates. Our multi-stage PGO builds are a workflow for generating PGO; profiles that can be used to optimize clang. At a high level, the way PGO works is that you build an instrumented compiler,; then you run the instrumented compiler against sample source files. While the; instrumented compiler runs it will output a bunch of files containing; performance counters (.profraw files). After generating all the profraw files; you use llvm-profdata to merge the files into a single profdata file that you; can feed into the LLVM_PROFDATA_FILE option. Our PGO.cmake cache automates that whole process. You can use it for; configuration with CMake with the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; <path to source>/llvm. There are several additional options that the cache file also accepts to modify; the build, particularly the PGO_INSTRUMENT_LTO option. Setting this option to; Thin or Full will enable ThinLTO or full LTO respectively, further enhancing; the performance gains from a PGO build by enabling interprocedural; optimizations. For example, to run a CMake configuration for a PGO build; that also enables ThinTLO, use the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; -DPGO_INSTRUMENT_LTO=Thin \; <path to source>/llvm. By default, clang will generate profile data by compiling a simple; hello world program. You can also tell clang use an external; project for generating profile data that may be a better fit for your; use ca",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:5572,Performance,cache,caches,5572,"ripts to set complex settings, and specifically to; make later stage builds include cache scripts is common in our more advanced; build configurations. Multi-stage PGO; ===============. Profile-Guided Optimizations (PGO) is a really great way to optimize the code; clang generates. Our multi-stage PGO builds are a workflow for generating PGO; profiles that can be used to optimize clang. At a high level, the way PGO works is that you build an instrumented compiler,; then you run the instrumented compiler against sample source files. While the; instrumented compiler runs it will output a bunch of files containing; performance counters (.profraw files). After generating all the profraw files; you use llvm-profdata to merge the files into a single profdata file that you; can feed into the LLVM_PROFDATA_FILE option. Our PGO.cmake cache automates that whole process. You can use it for; configuration with CMake with the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; <path to source>/llvm. There are several additional options that the cache file also accepts to modify; the build, particularly the PGO_INSTRUMENT_LTO option. Setting this option to; Thin or Full will enable ThinLTO or full LTO respectively, further enhancing; the performance gains from a PGO build by enabling interprocedural; optimizations. For example, to run a CMake configuration for a PGO build; that also enables ThinTLO, use the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; -DPGO_INSTRUMENT_LTO=Thin \; <path to source>/llvm. By default, clang will generate profile data by compiling a simple; hello world program. You can also tell clang use an external; project for generating profile data that may be a better fit for your; use case. The project you specify must either be a lit test suite; (use the CLANG_PGO_TRAINING_DATA option) or a CMake project (use the; CLANG_PERF_TRAINING",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:5661,Performance,cache,cache,5661,"build configurations. Multi-stage PGO; ===============. Profile-Guided Optimizations (PGO) is a really great way to optimize the code; clang generates. Our multi-stage PGO builds are a workflow for generating PGO; profiles that can be used to optimize clang. At a high level, the way PGO works is that you build an instrumented compiler,; then you run the instrumented compiler against sample source files. While the; instrumented compiler runs it will output a bunch of files containing; performance counters (.profraw files). After generating all the profraw files; you use llvm-profdata to merge the files into a single profdata file that you; can feed into the LLVM_PROFDATA_FILE option. Our PGO.cmake cache automates that whole process. You can use it for; configuration with CMake with the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; <path to source>/llvm. There are several additional options that the cache file also accepts to modify; the build, particularly the PGO_INSTRUMENT_LTO option. Setting this option to; Thin or Full will enable ThinLTO or full LTO respectively, further enhancing; the performance gains from a PGO build by enabling interprocedural; optimizations. For example, to run a CMake configuration for a PGO build; that also enables ThinTLO, use the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; -DPGO_INSTRUMENT_LTO=Thin \; <path to source>/llvm. By default, clang will generate profile data by compiling a simple; hello world program. You can also tell clang use an external; project for generating profile data that may be a better fit for your; use case. The project you specify must either be a lit test suite; (use the CLANG_PGO_TRAINING_DATA option) or a CMake project (use the; CLANG_PERF_TRAINING_DATA_SOURCE_DIR option). For example, If you wanted to use the; `LLVM Test Suite <https://github.com/llvm/llvm-test-suite/>`_ to",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:5857,Performance,perform,performance,5857,"i-stage PGO builds are a workflow for generating PGO; profiles that can be used to optimize clang. At a high level, the way PGO works is that you build an instrumented compiler,; then you run the instrumented compiler against sample source files. While the; instrumented compiler runs it will output a bunch of files containing; performance counters (.profraw files). After generating all the profraw files; you use llvm-profdata to merge the files into a single profdata file that you; can feed into the LLVM_PROFDATA_FILE option. Our PGO.cmake cache automates that whole process. You can use it for; configuration with CMake with the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; <path to source>/llvm. There are several additional options that the cache file also accepts to modify; the build, particularly the PGO_INSTRUMENT_LTO option. Setting this option to; Thin or Full will enable ThinLTO or full LTO respectively, further enhancing; the performance gains from a PGO build by enabling interprocedural; optimizations. For example, to run a CMake configuration for a PGO build; that also enables ThinTLO, use the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; -DPGO_INSTRUMENT_LTO=Thin \; <path to source>/llvm. By default, clang will generate profile data by compiling a simple; hello world program. You can also tell clang use an external; project for generating profile data that may be a better fit for your; use case. The project you specify must either be a lit test suite; (use the CLANG_PGO_TRAINING_DATA option) or a CMake project (use the; CLANG_PERF_TRAINING_DATA_SOURCE_DIR option). For example, If you wanted to use the; `LLVM Test Suite <https://github.com/llvm/llvm-test-suite/>`_ to generate; profile data you would use the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; -DBOO",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:5921,Performance,optimiz,optimizations,5921,"i-stage PGO builds are a workflow for generating PGO; profiles that can be used to optimize clang. At a high level, the way PGO works is that you build an instrumented compiler,; then you run the instrumented compiler against sample source files. While the; instrumented compiler runs it will output a bunch of files containing; performance counters (.profraw files). After generating all the profraw files; you use llvm-profdata to merge the files into a single profdata file that you; can feed into the LLVM_PROFDATA_FILE option. Our PGO.cmake cache automates that whole process. You can use it for; configuration with CMake with the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; <path to source>/llvm. There are several additional options that the cache file also accepts to modify; the build, particularly the PGO_INSTRUMENT_LTO option. Setting this option to; Thin or Full will enable ThinLTO or full LTO respectively, further enhancing; the performance gains from a PGO build by enabling interprocedural; optimizations. For example, to run a CMake configuration for a PGO build; that also enables ThinTLO, use the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; -DPGO_INSTRUMENT_LTO=Thin \; <path to source>/llvm. By default, clang will generate profile data by compiling a simple; hello world program. You can also tell clang use an external; project for generating profile data that may be a better fit for your; use case. The project you specify must either be a lit test suite; (use the CLANG_PGO_TRAINING_DATA option) or a CMake project (use the; CLANG_PERF_TRAINING_DATA_SOURCE_DIR option). For example, If you wanted to use the; `LLVM Test Suite <https://github.com/llvm/llvm-test-suite/>`_ to generate; profile data you would use the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; -DBOO",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:6124,Performance,cache,caches,6124,"rumented compiler runs it will output a bunch of files containing; performance counters (.profraw files). After generating all the profraw files; you use llvm-profdata to merge the files into a single profdata file that you; can feed into the LLVM_PROFDATA_FILE option. Our PGO.cmake cache automates that whole process. You can use it for; configuration with CMake with the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; <path to source>/llvm. There are several additional options that the cache file also accepts to modify; the build, particularly the PGO_INSTRUMENT_LTO option. Setting this option to; Thin or Full will enable ThinLTO or full LTO respectively, further enhancing; the performance gains from a PGO build by enabling interprocedural; optimizations. For example, to run a CMake configuration for a PGO build; that also enables ThinTLO, use the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; -DPGO_INSTRUMENT_LTO=Thin \; <path to source>/llvm. By default, clang will generate profile data by compiling a simple; hello world program. You can also tell clang use an external; project for generating profile data that may be a better fit for your; use case. The project you specify must either be a lit test suite; (use the CLANG_PGO_TRAINING_DATA option) or a CMake project (use the; CLANG_PERF_TRAINING_DATA_SOURCE_DIR option). For example, If you wanted to use the; `LLVM Test Suite <https://github.com/llvm/llvm-test-suite/>`_ to generate; profile data you would use the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; -DBOOTSTRAP_CLANG_PGO_TRAINING_DATA_SOURCE_DIR=<path to llvm-test-suite> \; -DBOOTSTRAP_CLANG_PGO_TRAINING_DEPS=runtimes. The BOOTSTRAP\_ prefixes tells CMake to pass the variables on to the instrumented; stage two build. And the CLANG_PGO_TRAINING_DEPS option let's ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:6818,Performance,cache,caches,6818,"e ThinLTO or full LTO respectively, further enhancing; the performance gains from a PGO build by enabling interprocedural; optimizations. For example, to run a CMake configuration for a PGO build; that also enables ThinTLO, use the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; -DPGO_INSTRUMENT_LTO=Thin \; <path to source>/llvm. By default, clang will generate profile data by compiling a simple; hello world program. You can also tell clang use an external; project for generating profile data that may be a better fit for your; use case. The project you specify must either be a lit test suite; (use the CLANG_PGO_TRAINING_DATA option) or a CMake project (use the; CLANG_PERF_TRAINING_DATA_SOURCE_DIR option). For example, If you wanted to use the; `LLVM Test Suite <https://github.com/llvm/llvm-test-suite/>`_ to generate; profile data you would use the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; -DBOOTSTRAP_CLANG_PGO_TRAINING_DATA_SOURCE_DIR=<path to llvm-test-suite> \; -DBOOTSTRAP_CLANG_PGO_TRAINING_DEPS=runtimes. The BOOTSTRAP\_ prefixes tells CMake to pass the variables on to the instrumented; stage two build. And the CLANG_PGO_TRAINING_DEPS option let's you specify; additional build targets to build before building the external project. The; LLVM Test Suite requires compiler-rt to build, so we need to add the; `runtimes` target as a dependency. After configuration, building the stage2-instrumented-generate-profdata target; will automatically build the stage1 compiler, build the instrumented compiler; with the stage1 compiler, and then run the instrumented compiler against the; perf training data:. .. code-block:: console. $ ninja stage2-instrumented-generate-profdata. If you let that run for a few hours or so, it will place a profdata file in your; build directory. This takes a really long time because it builds clang twice,; and you ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:8310,Performance,optimiz,optimized,8310,"get as a dependency. After configuration, building the stage2-instrumented-generate-profdata target; will automatically build the stage1 compiler, build the instrumented compiler; with the stage1 compiler, and then run the instrumented compiler against the; perf training data:. .. code-block:: console. $ ninja stage2-instrumented-generate-profdata. If you let that run for a few hours or so, it will place a profdata file in your; build directory. This takes a really long time because it builds clang twice,; and you *must* have compiler-rt in your build tree. This process uses any source files under the perf-training directory as training; data as long as the source files are marked up with LIT-style RUN lines. After it finishes you can use :code:`find . -name clang.profdata` to find it, but it; should be at a path something like:. .. code-block:: console. <build dir>/tools/clang/stage2-instrumented-bins/utils/perf-training/clang.profdata. You can feed that file into the LLVM_PROFDATA_FILE option when you build your; optimized compiler. It may be necessary to build additional targets before running perf training, such as; builtins and runtime libraries. You can use the :code:`CLANG_PGO_TRAINING_DEPS` CMake; variable for that purpose:. .. code-block:: cmake. set(CLANG_PGO_TRAINING_DEPS builtins runtimes CACHE STRING """"). The PGO cache has a slightly different stage naming scheme than other; multi-stage builds. It generates three stages: stage1, stage2-instrumented, and; stage2. Both of the stage2 builds are built using the stage1 compiler. The PGO cache generates the following additional targets:. **stage2-instrumented**; Builds a stage1 compiler, runtime, and required tools (llvm-config,; llvm-profdata) then uses that compiler to build an instrumented stage2 compiler. **stage2-instrumented-generate-profdata**; Depends on stage2-instrumented and will use the instrumented compiler to; generate profdata based on the training files in clang/utils/perf-training. **stage2**;",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:8627,Performance,cache,cache,8627,"rs or so, it will place a profdata file in your; build directory. This takes a really long time because it builds clang twice,; and you *must* have compiler-rt in your build tree. This process uses any source files under the perf-training directory as training; data as long as the source files are marked up with LIT-style RUN lines. After it finishes you can use :code:`find . -name clang.profdata` to find it, but it; should be at a path something like:. .. code-block:: console. <build dir>/tools/clang/stage2-instrumented-bins/utils/perf-training/clang.profdata. You can feed that file into the LLVM_PROFDATA_FILE option when you build your; optimized compiler. It may be necessary to build additional targets before running perf training, such as; builtins and runtime libraries. You can use the :code:`CLANG_PGO_TRAINING_DEPS` CMake; variable for that purpose:. .. code-block:: cmake. set(CLANG_PGO_TRAINING_DEPS builtins runtimes CACHE STRING """"). The PGO cache has a slightly different stage naming scheme than other; multi-stage builds. It generates three stages: stage1, stage2-instrumented, and; stage2. Both of the stage2 builds are built using the stage1 compiler. The PGO cache generates the following additional targets:. **stage2-instrumented**; Builds a stage1 compiler, runtime, and required tools (llvm-config,; llvm-profdata) then uses that compiler to build an instrumented stage2 compiler. **stage2-instrumented-generate-profdata**; Depends on stage2-instrumented and will use the instrumented compiler to; generate profdata based on the training files in clang/utils/perf-training. **stage2**; Depends on stage2-instrumented-generate-profdata and will use the stage1; compiler with the stage2 profdata to build a PGO-optimized compiler. **stage2-check-llvm**; Depends on stage2 and runs check-llvm using the stage2 compiler. **stage2-check-clang**; Depends on stage2 and runs check-clang using the stage2 compiler. **stage2-check-all**; Depends on stage2 and runs check-all usi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:8850,Performance,cache,cache,8850,"e files under the perf-training directory as training; data as long as the source files are marked up with LIT-style RUN lines. After it finishes you can use :code:`find . -name clang.profdata` to find it, but it; should be at a path something like:. .. code-block:: console. <build dir>/tools/clang/stage2-instrumented-bins/utils/perf-training/clang.profdata. You can feed that file into the LLVM_PROFDATA_FILE option when you build your; optimized compiler. It may be necessary to build additional targets before running perf training, such as; builtins and runtime libraries. You can use the :code:`CLANG_PGO_TRAINING_DEPS` CMake; variable for that purpose:. .. code-block:: cmake. set(CLANG_PGO_TRAINING_DEPS builtins runtimes CACHE STRING """"). The PGO cache has a slightly different stage naming scheme than other; multi-stage builds. It generates three stages: stage1, stage2-instrumented, and; stage2. Both of the stage2 builds are built using the stage1 compiler. The PGO cache generates the following additional targets:. **stage2-instrumented**; Builds a stage1 compiler, runtime, and required tools (llvm-config,; llvm-profdata) then uses that compiler to build an instrumented stage2 compiler. **stage2-instrumented-generate-profdata**; Depends on stage2-instrumented and will use the instrumented compiler to; generate profdata based on the training files in clang/utils/perf-training. **stage2**; Depends on stage2-instrumented-generate-profdata and will use the stage1; compiler with the stage2 profdata to build a PGO-optimized compiler. **stage2-check-llvm**; Depends on stage2 and runs check-llvm using the stage2 compiler. **stage2-check-clang**; Depends on stage2 and runs check-clang using the stage2 compiler. **stage2-check-all**; Depends on stage2 and runs check-all using the stage2 compiler. **stage2-test-suite**; Depends on stage2 and runs the test-suite using the stage2 compiler (requires; in-tree test-suite). BOLT; ====. `BOLT <https://github.com/llvm/llvm-project/blob",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:9404,Performance,optimiz,optimized,9404,"sary to build additional targets before running perf training, such as; builtins and runtime libraries. You can use the :code:`CLANG_PGO_TRAINING_DEPS` CMake; variable for that purpose:. .. code-block:: cmake. set(CLANG_PGO_TRAINING_DEPS builtins runtimes CACHE STRING """"). The PGO cache has a slightly different stage naming scheme than other; multi-stage builds. It generates three stages: stage1, stage2-instrumented, and; stage2. Both of the stage2 builds are built using the stage1 compiler. The PGO cache generates the following additional targets:. **stage2-instrumented**; Builds a stage1 compiler, runtime, and required tools (llvm-config,; llvm-profdata) then uses that compiler to build an instrumented stage2 compiler. **stage2-instrumented-generate-profdata**; Depends on stage2-instrumented and will use the instrumented compiler to; generate profdata based on the training files in clang/utils/perf-training. **stage2**; Depends on stage2-instrumented-generate-profdata and will use the stage1; compiler with the stage2 profdata to build a PGO-optimized compiler. **stage2-check-llvm**; Depends on stage2 and runs check-llvm using the stage2 compiler. **stage2-check-clang**; Depends on stage2 and runs check-clang using the stage2 compiler. **stage2-check-all**; Depends on stage2 and runs check-all using the stage2 compiler. **stage2-test-suite**; Depends on stage2 and runs the test-suite using the stage2 compiler (requires; in-tree test-suite). BOLT; ====. `BOLT <https://github.com/llvm/llvm-project/blob/main/bolt/README.md>`_; (Binary Optimization and Layout Tool) is a tool that optimizes binaries; post-link by profiling them at runtime and then using that information to; optimize the layout of the final binary among other optimizations performed; at the binary level. There are also CMake caches available to build; LLVM/Clang with BOLT. To configure a single-stage build that builds LLVM/Clang and then optimizes; it with BOLT, use the following CMake configuration:. .. ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:9949,Performance,optimiz,optimizes,9949,"uses that compiler to build an instrumented stage2 compiler. **stage2-instrumented-generate-profdata**; Depends on stage2-instrumented and will use the instrumented compiler to; generate profdata based on the training files in clang/utils/perf-training. **stage2**; Depends on stage2-instrumented-generate-profdata and will use the stage1; compiler with the stage2 profdata to build a PGO-optimized compiler. **stage2-check-llvm**; Depends on stage2 and runs check-llvm using the stage2 compiler. **stage2-check-clang**; Depends on stage2 and runs check-clang using the stage2 compiler. **stage2-check-all**; Depends on stage2 and runs check-all using the stage2 compiler. **stage2-test-suite**; Depends on stage2 and runs the test-suite using the stage2 compiler (requires; in-tree test-suite). BOLT; ====. `BOLT <https://github.com/llvm/llvm-project/blob/main/bolt/README.md>`_; (Binary Optimization and Layout Tool) is a tool that optimizes binaries; post-link by profiling them at runtime and then using that information to; optimize the layout of the final binary among other optimizations performed; at the binary level. There are also CMake caches available to build; LLVM/Clang with BOLT. To configure a single-stage build that builds LLVM/Clang and then optimizes; it with BOLT, use the following CMake configuration:. .. code-block:: console. $ cmake <path to source>/llvm -C <path to source>/clang/cmake/caches/BOLT.cmake. Then, build the BOLT-optimized binary by running the following ninja command:. .. code-block:: console. $ ninja clang-bolt. If you're seeing errors in the build process, try building with a recent; version of Clang/LLVM by setting the CMAKE_C_COMPILER and; CMAKE_CXX_COMPILER flags to the appropriate values. It is also possible to use BOLT on top of PGO and (Thin)LTO for an even more; significant runtime speedup. To configure a three stage PGO build with ThinLTO; that optimizes the resulting binary with BOLT, use the following CMake; configuration command:. .. ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:10044,Performance,optimiz,optimize,10044,"uses that compiler to build an instrumented stage2 compiler. **stage2-instrumented-generate-profdata**; Depends on stage2-instrumented and will use the instrumented compiler to; generate profdata based on the training files in clang/utils/perf-training. **stage2**; Depends on stage2-instrumented-generate-profdata and will use the stage1; compiler with the stage2 profdata to build a PGO-optimized compiler. **stage2-check-llvm**; Depends on stage2 and runs check-llvm using the stage2 compiler. **stage2-check-clang**; Depends on stage2 and runs check-clang using the stage2 compiler. **stage2-check-all**; Depends on stage2 and runs check-all using the stage2 compiler. **stage2-test-suite**; Depends on stage2 and runs the test-suite using the stage2 compiler (requires; in-tree test-suite). BOLT; ====. `BOLT <https://github.com/llvm/llvm-project/blob/main/bolt/README.md>`_; (Binary Optimization and Layout Tool) is a tool that optimizes binaries; post-link by profiling them at runtime and then using that information to; optimize the layout of the final binary among other optimizations performed; at the binary level. There are also CMake caches available to build; LLVM/Clang with BOLT. To configure a single-stage build that builds LLVM/Clang and then optimizes; it with BOLT, use the following CMake configuration:. .. code-block:: console. $ cmake <path to source>/llvm -C <path to source>/clang/cmake/caches/BOLT.cmake. Then, build the BOLT-optimized binary by running the following ninja command:. .. code-block:: console. $ ninja clang-bolt. If you're seeing errors in the build process, try building with a recent; version of Clang/LLVM by setting the CMAKE_C_COMPILER and; CMAKE_CXX_COMPILER flags to the appropriate values. It is also possible to use BOLT on top of PGO and (Thin)LTO for an even more; significant runtime speedup. To configure a three stage PGO build with ThinLTO; that optimizes the resulting binary with BOLT, use the following CMake; configuration command:. .. ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:10096,Performance,optimiz,optimizations,10096,"uses that compiler to build an instrumented stage2 compiler. **stage2-instrumented-generate-profdata**; Depends on stage2-instrumented and will use the instrumented compiler to; generate profdata based on the training files in clang/utils/perf-training. **stage2**; Depends on stage2-instrumented-generate-profdata and will use the stage1; compiler with the stage2 profdata to build a PGO-optimized compiler. **stage2-check-llvm**; Depends on stage2 and runs check-llvm using the stage2 compiler. **stage2-check-clang**; Depends on stage2 and runs check-clang using the stage2 compiler. **stage2-check-all**; Depends on stage2 and runs check-all using the stage2 compiler. **stage2-test-suite**; Depends on stage2 and runs the test-suite using the stage2 compiler (requires; in-tree test-suite). BOLT; ====. `BOLT <https://github.com/llvm/llvm-project/blob/main/bolt/README.md>`_; (Binary Optimization and Layout Tool) is a tool that optimizes binaries; post-link by profiling them at runtime and then using that information to; optimize the layout of the final binary among other optimizations performed; at the binary level. There are also CMake caches available to build; LLVM/Clang with BOLT. To configure a single-stage build that builds LLVM/Clang and then optimizes; it with BOLT, use the following CMake configuration:. .. code-block:: console. $ cmake <path to source>/llvm -C <path to source>/clang/cmake/caches/BOLT.cmake. Then, build the BOLT-optimized binary by running the following ninja command:. .. code-block:: console. $ ninja clang-bolt. If you're seeing errors in the build process, try building with a recent; version of Clang/LLVM by setting the CMAKE_C_COMPILER and; CMAKE_CXX_COMPILER flags to the appropriate values. It is also possible to use BOLT on top of PGO and (Thin)LTO for an even more; significant runtime speedup. To configure a three stage PGO build with ThinLTO; that optimizes the resulting binary with BOLT, use the following CMake; configuration command:. .. ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:10110,Performance,perform,performed,10110,"uses that compiler to build an instrumented stage2 compiler. **stage2-instrumented-generate-profdata**; Depends on stage2-instrumented and will use the instrumented compiler to; generate profdata based on the training files in clang/utils/perf-training. **stage2**; Depends on stage2-instrumented-generate-profdata and will use the stage1; compiler with the stage2 profdata to build a PGO-optimized compiler. **stage2-check-llvm**; Depends on stage2 and runs check-llvm using the stage2 compiler. **stage2-check-clang**; Depends on stage2 and runs check-clang using the stage2 compiler. **stage2-check-all**; Depends on stage2 and runs check-all using the stage2 compiler. **stage2-test-suite**; Depends on stage2 and runs the test-suite using the stage2 compiler (requires; in-tree test-suite). BOLT; ====. `BOLT <https://github.com/llvm/llvm-project/blob/main/bolt/README.md>`_; (Binary Optimization and Layout Tool) is a tool that optimizes binaries; post-link by profiling them at runtime and then using that information to; optimize the layout of the final binary among other optimizations performed; at the binary level. There are also CMake caches available to build; LLVM/Clang with BOLT. To configure a single-stage build that builds LLVM/Clang and then optimizes; it with BOLT, use the following CMake configuration:. .. code-block:: console. $ cmake <path to source>/llvm -C <path to source>/clang/cmake/caches/BOLT.cmake. Then, build the BOLT-optimized binary by running the following ninja command:. .. code-block:: console. $ ninja clang-bolt. If you're seeing errors in the build process, try building with a recent; version of Clang/LLVM by setting the CMAKE_C_COMPILER and; CMAKE_CXX_COMPILER flags to the appropriate values. It is also possible to use BOLT on top of PGO and (Thin)LTO for an even more; significant runtime speedup. To configure a three stage PGO build with ThinLTO; that optimizes the resulting binary with BOLT, use the following CMake; configuration command:. .. ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:10163,Performance,cache,caches,10163,"ted compiler to; generate profdata based on the training files in clang/utils/perf-training. **stage2**; Depends on stage2-instrumented-generate-profdata and will use the stage1; compiler with the stage2 profdata to build a PGO-optimized compiler. **stage2-check-llvm**; Depends on stage2 and runs check-llvm using the stage2 compiler. **stage2-check-clang**; Depends on stage2 and runs check-clang using the stage2 compiler. **stage2-check-all**; Depends on stage2 and runs check-all using the stage2 compiler. **stage2-test-suite**; Depends on stage2 and runs the test-suite using the stage2 compiler (requires; in-tree test-suite). BOLT; ====. `BOLT <https://github.com/llvm/llvm-project/blob/main/bolt/README.md>`_; (Binary Optimization and Layout Tool) is a tool that optimizes binaries; post-link by profiling them at runtime and then using that information to; optimize the layout of the final binary among other optimizations performed; at the binary level. There are also CMake caches available to build; LLVM/Clang with BOLT. To configure a single-stage build that builds LLVM/Clang and then optimizes; it with BOLT, use the following CMake configuration:. .. code-block:: console. $ cmake <path to source>/llvm -C <path to source>/clang/cmake/caches/BOLT.cmake. Then, build the BOLT-optimized binary by running the following ninja command:. .. code-block:: console. $ ninja clang-bolt. If you're seeing errors in the build process, try building with a recent; version of Clang/LLVM by setting the CMAKE_C_COMPILER and; CMAKE_CXX_COMPILER flags to the appropriate values. It is also possible to use BOLT on top of PGO and (Thin)LTO for an even more; significant runtime speedup. To configure a three stage PGO build with ThinLTO; that optimizes the resulting binary with BOLT, use the following CMake; configuration command:. .. code-block:: console. $ cmake -G Ninja <path to source>/llvm \; -C <path to source>/clang/cmake/caches/BOLT-PGO.cmake \; -DBOOTSTRAP_LLVM_ENABLE_LLD=ON \; -DBOOT",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:10278,Performance,optimiz,optimizes,10278,"2**; Depends on stage2-instrumented-generate-profdata and will use the stage1; compiler with the stage2 profdata to build a PGO-optimized compiler. **stage2-check-llvm**; Depends on stage2 and runs check-llvm using the stage2 compiler. **stage2-check-clang**; Depends on stage2 and runs check-clang using the stage2 compiler. **stage2-check-all**; Depends on stage2 and runs check-all using the stage2 compiler. **stage2-test-suite**; Depends on stage2 and runs the test-suite using the stage2 compiler (requires; in-tree test-suite). BOLT; ====. `BOLT <https://github.com/llvm/llvm-project/blob/main/bolt/README.md>`_; (Binary Optimization and Layout Tool) is a tool that optimizes binaries; post-link by profiling them at runtime and then using that information to; optimize the layout of the final binary among other optimizations performed; at the binary level. There are also CMake caches available to build; LLVM/Clang with BOLT. To configure a single-stage build that builds LLVM/Clang and then optimizes; it with BOLT, use the following CMake configuration:. .. code-block:: console. $ cmake <path to source>/llvm -C <path to source>/clang/cmake/caches/BOLT.cmake. Then, build the BOLT-optimized binary by running the following ninja command:. .. code-block:: console. $ ninja clang-bolt. If you're seeing errors in the build process, try building with a recent; version of Clang/LLVM by setting the CMAKE_C_COMPILER and; CMAKE_CXX_COMPILER flags to the appropriate values. It is also possible to use BOLT on top of PGO and (Thin)LTO for an even more; significant runtime speedup. To configure a three stage PGO build with ThinLTO; that optimizes the resulting binary with BOLT, use the following CMake; configuration command:. .. code-block:: console. $ cmake -G Ninja <path to source>/llvm \; -C <path to source>/clang/cmake/caches/BOLT-PGO.cmake \; -DBOOTSTRAP_LLVM_ENABLE_LLD=ON \; -DBOOTSTRAP_BOOTSTRAP_LLVM_ENABLE_LLD=ON \; -DPGO_INSTRUMENT_LTO=Thin. Then, to build the final optimized b",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:10430,Performance,cache,caches,10430,"optimized compiler. **stage2-check-llvm**; Depends on stage2 and runs check-llvm using the stage2 compiler. **stage2-check-clang**; Depends on stage2 and runs check-clang using the stage2 compiler. **stage2-check-all**; Depends on stage2 and runs check-all using the stage2 compiler. **stage2-test-suite**; Depends on stage2 and runs the test-suite using the stage2 compiler (requires; in-tree test-suite). BOLT; ====. `BOLT <https://github.com/llvm/llvm-project/blob/main/bolt/README.md>`_; (Binary Optimization and Layout Tool) is a tool that optimizes binaries; post-link by profiling them at runtime and then using that information to; optimize the layout of the final binary among other optimizations performed; at the binary level. There are also CMake caches available to build; LLVM/Clang with BOLT. To configure a single-stage build that builds LLVM/Clang and then optimizes; it with BOLT, use the following CMake configuration:. .. code-block:: console. $ cmake <path to source>/llvm -C <path to source>/clang/cmake/caches/BOLT.cmake. Then, build the BOLT-optimized binary by running the following ninja command:. .. code-block:: console. $ ninja clang-bolt. If you're seeing errors in the build process, try building with a recent; version of Clang/LLVM by setting the CMAKE_C_COMPILER and; CMAKE_CXX_COMPILER flags to the appropriate values. It is also possible to use BOLT on top of PGO and (Thin)LTO for an even more; significant runtime speedup. To configure a three stage PGO build with ThinLTO; that optimizes the resulting binary with BOLT, use the following CMake; configuration command:. .. code-block:: console. $ cmake -G Ninja <path to source>/llvm \; -C <path to source>/clang/cmake/caches/BOLT-PGO.cmake \; -DBOOTSTRAP_LLVM_ENABLE_LLD=ON \; -DBOOTSTRAP_BOOTSTRAP_LLVM_ENABLE_LLD=ON \; -DPGO_INSTRUMENT_LTO=Thin. Then, to build the final optimized binary, build the stage2-clang-bolt target:. .. code-block:: console. $ ninja stage2-clang-bolt. 3-Stage Non-Determinism; =======",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:10470,Performance,optimiz,optimized,10470,"ing the stage2 compiler. **stage2-check-clang**; Depends on stage2 and runs check-clang using the stage2 compiler. **stage2-check-all**; Depends on stage2 and runs check-all using the stage2 compiler. **stage2-test-suite**; Depends on stage2 and runs the test-suite using the stage2 compiler (requires; in-tree test-suite). BOLT; ====. `BOLT <https://github.com/llvm/llvm-project/blob/main/bolt/README.md>`_; (Binary Optimization and Layout Tool) is a tool that optimizes binaries; post-link by profiling them at runtime and then using that information to; optimize the layout of the final binary among other optimizations performed; at the binary level. There are also CMake caches available to build; LLVM/Clang with BOLT. To configure a single-stage build that builds LLVM/Clang and then optimizes; it with BOLT, use the following CMake configuration:. .. code-block:: console. $ cmake <path to source>/llvm -C <path to source>/clang/cmake/caches/BOLT.cmake. Then, build the BOLT-optimized binary by running the following ninja command:. .. code-block:: console. $ ninja clang-bolt. If you're seeing errors in the build process, try building with a recent; version of Clang/LLVM by setting the CMAKE_C_COMPILER and; CMAKE_CXX_COMPILER flags to the appropriate values. It is also possible to use BOLT on top of PGO and (Thin)LTO for an even more; significant runtime speedup. To configure a three stage PGO build with ThinLTO; that optimizes the resulting binary with BOLT, use the following CMake; configuration command:. .. code-block:: console. $ cmake -G Ninja <path to source>/llvm \; -C <path to source>/clang/cmake/caches/BOLT-PGO.cmake \; -DBOOTSTRAP_LLVM_ENABLE_LLD=ON \; -DBOOTSTRAP_BOOTSTRAP_LLVM_ENABLE_LLD=ON \; -DPGO_INSTRUMENT_LTO=Thin. Then, to build the final optimized binary, build the stage2-clang-bolt target:. .. code-block:: console. $ ninja stage2-clang-bolt. 3-Stage Non-Determinism; =======================. In the ancient lore of compilers non-determinism is like the mult",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:10921,Performance,optimiz,optimizes,10921,"a tool that optimizes binaries; post-link by profiling them at runtime and then using that information to; optimize the layout of the final binary among other optimizations performed; at the binary level. There are also CMake caches available to build; LLVM/Clang with BOLT. To configure a single-stage build that builds LLVM/Clang and then optimizes; it with BOLT, use the following CMake configuration:. .. code-block:: console. $ cmake <path to source>/llvm -C <path to source>/clang/cmake/caches/BOLT.cmake. Then, build the BOLT-optimized binary by running the following ninja command:. .. code-block:: console. $ ninja clang-bolt. If you're seeing errors in the build process, try building with a recent; version of Clang/LLVM by setting the CMAKE_C_COMPILER and; CMAKE_CXX_COMPILER flags to the appropriate values. It is also possible to use BOLT on top of PGO and (Thin)LTO for an even more; significant runtime speedup. To configure a three stage PGO build with ThinLTO; that optimizes the resulting binary with BOLT, use the following CMake; configuration command:. .. code-block:: console. $ cmake -G Ninja <path to source>/llvm \; -C <path to source>/clang/cmake/caches/BOLT-PGO.cmake \; -DBOOTSTRAP_LLVM_ENABLE_LLD=ON \; -DBOOTSTRAP_BOOTSTRAP_LLVM_ENABLE_LLD=ON \; -DPGO_INSTRUMENT_LTO=Thin. Then, to build the final optimized binary, build the stage2-clang-bolt target:. .. code-block:: console. $ ninja stage2-clang-bolt. 3-Stage Non-Determinism; =======================. In the ancient lore of compilers non-determinism is like the multi-headed hydra.; Whenever its head pops up, terror and chaos ensue. Historically one of the tests to verify that a compiler was deterministic would; be a three stage build. The idea of a three stage build is you take your sources; and build a compiler (stage1), then use that compiler to rebuild the sources; (stage2), then you use that compiler to rebuild the sources a third time; (stage3) with an identical configuration to the stage2 build. At th",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:11111,Performance,cache,caches,11111,"ry among other optimizations performed; at the binary level. There are also CMake caches available to build; LLVM/Clang with BOLT. To configure a single-stage build that builds LLVM/Clang and then optimizes; it with BOLT, use the following CMake configuration:. .. code-block:: console. $ cmake <path to source>/llvm -C <path to source>/clang/cmake/caches/BOLT.cmake. Then, build the BOLT-optimized binary by running the following ninja command:. .. code-block:: console. $ ninja clang-bolt. If you're seeing errors in the build process, try building with a recent; version of Clang/LLVM by setting the CMAKE_C_COMPILER and; CMAKE_CXX_COMPILER flags to the appropriate values. It is also possible to use BOLT on top of PGO and (Thin)LTO for an even more; significant runtime speedup. To configure a three stage PGO build with ThinLTO; that optimizes the resulting binary with BOLT, use the following CMake; configuration command:. .. code-block:: console. $ cmake -G Ninja <path to source>/llvm \; -C <path to source>/clang/cmake/caches/BOLT-PGO.cmake \; -DBOOTSTRAP_LLVM_ENABLE_LLD=ON \; -DBOOTSTRAP_BOOTSTRAP_LLVM_ENABLE_LLD=ON \; -DPGO_INSTRUMENT_LTO=Thin. Then, to build the final optimized binary, build the stage2-clang-bolt target:. .. code-block:: console. $ ninja stage2-clang-bolt. 3-Stage Non-Determinism; =======================. In the ancient lore of compilers non-determinism is like the multi-headed hydra.; Whenever its head pops up, terror and chaos ensue. Historically one of the tests to verify that a compiler was deterministic would; be a three stage build. The idea of a three stage build is you take your sources; and build a compiler (stage1), then use that compiler to rebuild the sources; (stage2), then you use that compiler to rebuild the sources a third time; (stage3) with an identical configuration to the stage2 build. At the end of; this, you have a stage2 and stage3 compiler that should be bit-for-bit; identical. You can perform one of these 3-stage builds with LL",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:11266,Performance,optimiz,optimized,11266,"timizes; it with BOLT, use the following CMake configuration:. .. code-block:: console. $ cmake <path to source>/llvm -C <path to source>/clang/cmake/caches/BOLT.cmake. Then, build the BOLT-optimized binary by running the following ninja command:. .. code-block:: console. $ ninja clang-bolt. If you're seeing errors in the build process, try building with a recent; version of Clang/LLVM by setting the CMAKE_C_COMPILER and; CMAKE_CXX_COMPILER flags to the appropriate values. It is also possible to use BOLT on top of PGO and (Thin)LTO for an even more; significant runtime speedup. To configure a three stage PGO build with ThinLTO; that optimizes the resulting binary with BOLT, use the following CMake; configuration command:. .. code-block:: console. $ cmake -G Ninja <path to source>/llvm \; -C <path to source>/clang/cmake/caches/BOLT-PGO.cmake \; -DBOOTSTRAP_LLVM_ENABLE_LLD=ON \; -DBOOTSTRAP_BOOTSTRAP_LLVM_ENABLE_LLD=ON \; -DPGO_INSTRUMENT_LTO=Thin. Then, to build the final optimized binary, build the stage2-clang-bolt target:. .. code-block:: console. $ ninja stage2-clang-bolt. 3-Stage Non-Determinism; =======================. In the ancient lore of compilers non-determinism is like the multi-headed hydra.; Whenever its head pops up, terror and chaos ensue. Historically one of the tests to verify that a compiler was deterministic would; be a three stage build. The idea of a three stage build is you take your sources; and build a compiler (stage1), then use that compiler to rebuild the sources; (stage2), then you use that compiler to rebuild the sources a third time; (stage3) with an identical configuration to the stage2 build. At the end of; this, you have a stage2 and stage3 compiler that should be bit-for-bit; identical. You can perform one of these 3-stage builds with LLVM and clang using the; following commands:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/3-stage.cmake <path to source>/llvm; $ ninja stage3. After the build you",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:12039,Performance,perform,perform,12039,"configuration:. .. code-block:: console. $ cmake <path to source>/llvm -C <path to source>/clang/cmake/caches/BOLT.cmake. Then, build the BOLT-optimized binary by running the following ninja command:. .. code-block:: console. $ ninja clang-bolt. If you're seeing errors in the build process, try building with a recent; version of Clang/LLVM by setting the CMAKE_C_COMPILER and; CMAKE_CXX_COMPILER flags to the appropriate values. It is also possible to use BOLT on top of PGO and (Thin)LTO for an even more; significant runtime speedup. To configure a three stage PGO build with ThinLTO; that optimizes the resulting binary with BOLT, use the following CMake; configuration command:. .. code-block:: console. $ cmake -G Ninja <path to source>/llvm \; -C <path to source>/clang/cmake/caches/BOLT-PGO.cmake \; -DBOOTSTRAP_LLVM_ENABLE_LLD=ON \; -DBOOTSTRAP_BOOTSTRAP_LLVM_ENABLE_LLD=ON \; -DPGO_INSTRUMENT_LTO=Thin. Then, to build the final optimized binary, build the stage2-clang-bolt target:. .. code-block:: console. $ ninja stage2-clang-bolt. 3-Stage Non-Determinism; =======================. In the ancient lore of compilers non-determinism is like the multi-headed hydra.; Whenever its head pops up, terror and chaos ensue. Historically one of the tests to verify that a compiler was deterministic would; be a three stage build. The idea of a three stage build is you take your sources; and build a compiler (stage1), then use that compiler to rebuild the sources; (stage2), then you use that compiler to rebuild the sources a third time; (stage3) with an identical configuration to the stage2 build. At the end of; this, you have a stage2 and stage3 compiler that should be bit-for-bit; identical. You can perform one of these 3-stage builds with LLVM and clang using the; following commands:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/3-stage.cmake <path to source>/llvm; $ ninja stage3. After the build you can compare the stage2 and stage3 compilers.; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:12201,Performance,cache,caches,12201,"configuration:. .. code-block:: console. $ cmake <path to source>/llvm -C <path to source>/clang/cmake/caches/BOLT.cmake. Then, build the BOLT-optimized binary by running the following ninja command:. .. code-block:: console. $ ninja clang-bolt. If you're seeing errors in the build process, try building with a recent; version of Clang/LLVM by setting the CMAKE_C_COMPILER and; CMAKE_CXX_COMPILER flags to the appropriate values. It is also possible to use BOLT on top of PGO and (Thin)LTO for an even more; significant runtime speedup. To configure a three stage PGO build with ThinLTO; that optimizes the resulting binary with BOLT, use the following CMake; configuration command:. .. code-block:: console. $ cmake -G Ninja <path to source>/llvm \; -C <path to source>/clang/cmake/caches/BOLT-PGO.cmake \; -DBOOTSTRAP_LLVM_ENABLE_LLD=ON \; -DBOOTSTRAP_BOOTSTRAP_LLVM_ENABLE_LLD=ON \; -DPGO_INSTRUMENT_LTO=Thin. Then, to build the final optimized binary, build the stage2-clang-bolt target:. .. code-block:: console. $ ninja stage2-clang-bolt. 3-Stage Non-Determinism; =======================. In the ancient lore of compilers non-determinism is like the multi-headed hydra.; Whenever its head pops up, terror and chaos ensue. Historically one of the tests to verify that a compiler was deterministic would; be a three stage build. The idea of a three stage build is you take your sources; and build a compiler (stage1), then use that compiler to rebuild the sources; (stage2), then you use that compiler to rebuild the sources a third time; (stage3) with an identical configuration to the stage2 build. At the end of; this, you have a stage2 and stage3 compiler that should be bit-for-bit; identical. You can perform one of these 3-stage builds with LLVM and clang using the; following commands:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/3-stage.cmake <path to source>/llvm; $ ninja stage3. After the build you can compare the stage2 and stage3 compilers.; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:6452,Testability,test,test,6452,"and:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; <path to source>/llvm. There are several additional options that the cache file also accepts to modify; the build, particularly the PGO_INSTRUMENT_LTO option. Setting this option to; Thin or Full will enable ThinLTO or full LTO respectively, further enhancing; the performance gains from a PGO build by enabling interprocedural; optimizations. For example, to run a CMake configuration for a PGO build; that also enables ThinTLO, use the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; -DPGO_INSTRUMENT_LTO=Thin \; <path to source>/llvm. By default, clang will generate profile data by compiling a simple; hello world program. You can also tell clang use an external; project for generating profile data that may be a better fit for your; use case. The project you specify must either be a lit test suite; (use the CLANG_PGO_TRAINING_DATA option) or a CMake project (use the; CLANG_PERF_TRAINING_DATA_SOURCE_DIR option). For example, If you wanted to use the; `LLVM Test Suite <https://github.com/llvm/llvm-test-suite/>`_ to generate; profile data you would use the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; -DBOOTSTRAP_CLANG_PGO_TRAINING_DATA_SOURCE_DIR=<path to llvm-test-suite> \; -DBOOTSTRAP_CLANG_PGO_TRAINING_DEPS=runtimes. The BOOTSTRAP\_ prefixes tells CMake to pass the variables on to the instrumented; stage two build. And the CLANG_PGO_TRAINING_DEPS option let's you specify; additional build targets to build before building the external project. The; LLVM Test Suite requires compiler-rt to build, so we need to add the; `runtimes` target as a dependency. After configuration, building the stage2-instrumented-generate-profdata target; will automatically build the stage1 compiler, build the instrumented compiler; with the stage1 compiler, and the",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:6665,Testability,test,test-suite,6665,"he build, particularly the PGO_INSTRUMENT_LTO option. Setting this option to; Thin or Full will enable ThinLTO or full LTO respectively, further enhancing; the performance gains from a PGO build by enabling interprocedural; optimizations. For example, to run a CMake configuration for a PGO build; that also enables ThinTLO, use the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; -DPGO_INSTRUMENT_LTO=Thin \; <path to source>/llvm. By default, clang will generate profile data by compiling a simple; hello world program. You can also tell clang use an external; project for generating profile data that may be a better fit for your; use case. The project you specify must either be a lit test suite; (use the CLANG_PGO_TRAINING_DATA option) or a CMake project (use the; CLANG_PERF_TRAINING_DATA_SOURCE_DIR option). For example, If you wanted to use the; `LLVM Test Suite <https://github.com/llvm/llvm-test-suite/>`_ to generate; profile data you would use the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; -DBOOTSTRAP_CLANG_PGO_TRAINING_DATA_SOURCE_DIR=<path to llvm-test-suite> \; -DBOOTSTRAP_CLANG_PGO_TRAINING_DEPS=runtimes. The BOOTSTRAP\_ prefixes tells CMake to pass the variables on to the instrumented; stage two build. And the CLANG_PGO_TRAINING_DEPS option let's you specify; additional build targets to build before building the external project. The; LLVM Test Suite requires compiler-rt to build, so we need to add the; `runtimes` target as a dependency. After configuration, building the stage2-instrumented-generate-profdata target; will automatically build the stage1 compiler, build the instrumented compiler; with the stage1 compiler, and then run the instrumented compiler against the; perf training data:. .. code-block:: console. $ ninja stage2-instrumented-generate-profdata. If you let that run for a few hours or so, it will place a profdata",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:6899,Testability,test,test-suite,6899," enabling interprocedural; optimizations. For example, to run a CMake configuration for a PGO build; that also enables ThinTLO, use the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; -DPGO_INSTRUMENT_LTO=Thin \; <path to source>/llvm. By default, clang will generate profile data by compiling a simple; hello world program. You can also tell clang use an external; project for generating profile data that may be a better fit for your; use case. The project you specify must either be a lit test suite; (use the CLANG_PGO_TRAINING_DATA option) or a CMake project (use the; CLANG_PERF_TRAINING_DATA_SOURCE_DIR option). For example, If you wanted to use the; `LLVM Test Suite <https://github.com/llvm/llvm-test-suite/>`_ to generate; profile data you would use the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; -DBOOTSTRAP_CLANG_PGO_TRAINING_DATA_SOURCE_DIR=<path to llvm-test-suite> \; -DBOOTSTRAP_CLANG_PGO_TRAINING_DEPS=runtimes. The BOOTSTRAP\_ prefixes tells CMake to pass the variables on to the instrumented; stage two build. And the CLANG_PGO_TRAINING_DEPS option let's you specify; additional build targets to build before building the external project. The; LLVM Test Suite requires compiler-rt to build, so we need to add the; `runtimes` target as a dependency. After configuration, building the stage2-instrumented-generate-profdata target; will automatically build the stage1 compiler, build the instrumented compiler; with the stage1 compiler, and then run the instrumented compiler against the; perf training data:. .. code-block:: console. $ ninja stage2-instrumented-generate-profdata. If you let that run for a few hours or so, it will place a profdata file in your; build directory. This takes a really long time because it builds clang twice,; and you *must* have compiler-rt in your build tree. This process uses any source files under the perf-t",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:9697,Testability,test,test-suite,9697,"ge2-instrumented, and; stage2. Both of the stage2 builds are built using the stage1 compiler. The PGO cache generates the following additional targets:. **stage2-instrumented**; Builds a stage1 compiler, runtime, and required tools (llvm-config,; llvm-profdata) then uses that compiler to build an instrumented stage2 compiler. **stage2-instrumented-generate-profdata**; Depends on stage2-instrumented and will use the instrumented compiler to; generate profdata based on the training files in clang/utils/perf-training. **stage2**; Depends on stage2-instrumented-generate-profdata and will use the stage1; compiler with the stage2 profdata to build a PGO-optimized compiler. **stage2-check-llvm**; Depends on stage2 and runs check-llvm using the stage2 compiler. **stage2-check-clang**; Depends on stage2 and runs check-clang using the stage2 compiler. **stage2-check-all**; Depends on stage2 and runs check-all using the stage2 compiler. **stage2-test-suite**; Depends on stage2 and runs the test-suite using the stage2 compiler (requires; in-tree test-suite). BOLT; ====. `BOLT <https://github.com/llvm/llvm-project/blob/main/bolt/README.md>`_; (Binary Optimization and Layout Tool) is a tool that optimizes binaries; post-link by profiling them at runtime and then using that information to; optimize the layout of the final binary among other optimizations performed; at the binary level. There are also CMake caches available to build; LLVM/Clang with BOLT. To configure a single-stage build that builds LLVM/Clang and then optimizes; it with BOLT, use the following CMake configuration:. .. code-block:: console. $ cmake <path to source>/llvm -C <path to source>/clang/cmake/caches/BOLT.cmake. Then, build the BOLT-optimized binary by running the following ninja command:. .. code-block:: console. $ ninja clang-bolt. If you're seeing errors in the build process, try building with a recent; version of Clang/LLVM by setting the CMAKE_C_COMPILER and; CMAKE_CXX_COMPILER flags to the appropriate",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:9742,Testability,test,test-suite,9742,"ge2-instrumented, and; stage2. Both of the stage2 builds are built using the stage1 compiler. The PGO cache generates the following additional targets:. **stage2-instrumented**; Builds a stage1 compiler, runtime, and required tools (llvm-config,; llvm-profdata) then uses that compiler to build an instrumented stage2 compiler. **stage2-instrumented-generate-profdata**; Depends on stage2-instrumented and will use the instrumented compiler to; generate profdata based on the training files in clang/utils/perf-training. **stage2**; Depends on stage2-instrumented-generate-profdata and will use the stage1; compiler with the stage2 profdata to build a PGO-optimized compiler. **stage2-check-llvm**; Depends on stage2 and runs check-llvm using the stage2 compiler. **stage2-check-clang**; Depends on stage2 and runs check-clang using the stage2 compiler. **stage2-check-all**; Depends on stage2 and runs check-all using the stage2 compiler. **stage2-test-suite**; Depends on stage2 and runs the test-suite using the stage2 compiler (requires; in-tree test-suite). BOLT; ====. `BOLT <https://github.com/llvm/llvm-project/blob/main/bolt/README.md>`_; (Binary Optimization and Layout Tool) is a tool that optimizes binaries; post-link by profiling them at runtime and then using that information to; optimize the layout of the final binary among other optimizations performed; at the binary level. There are also CMake caches available to build; LLVM/Clang with BOLT. To configure a single-stage build that builds LLVM/Clang and then optimizes; it with BOLT, use the following CMake configuration:. .. code-block:: console. $ cmake <path to source>/llvm -C <path to source>/clang/cmake/caches/BOLT.cmake. Then, build the BOLT-optimized binary by running the following ninja command:. .. code-block:: console. $ ninja clang-bolt. If you're seeing errors in the build process, try building with a recent; version of Clang/LLVM by setting the CMAKE_C_COMPILER and; CMAKE_CXX_COMPILER flags to the appropriate",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:9798,Testability,test,test-suite,9798,"ge2-instrumented, and; stage2. Both of the stage2 builds are built using the stage1 compiler. The PGO cache generates the following additional targets:. **stage2-instrumented**; Builds a stage1 compiler, runtime, and required tools (llvm-config,; llvm-profdata) then uses that compiler to build an instrumented stage2 compiler. **stage2-instrumented-generate-profdata**; Depends on stage2-instrumented and will use the instrumented compiler to; generate profdata based on the training files in clang/utils/perf-training. **stage2**; Depends on stage2-instrumented-generate-profdata and will use the stage1; compiler with the stage2 profdata to build a PGO-optimized compiler. **stage2-check-llvm**; Depends on stage2 and runs check-llvm using the stage2 compiler. **stage2-check-clang**; Depends on stage2 and runs check-clang using the stage2 compiler. **stage2-check-all**; Depends on stage2 and runs check-all using the stage2 compiler. **stage2-test-suite**; Depends on stage2 and runs the test-suite using the stage2 compiler (requires; in-tree test-suite). BOLT; ====. `BOLT <https://github.com/llvm/llvm-project/blob/main/bolt/README.md>`_; (Binary Optimization and Layout Tool) is a tool that optimizes binaries; post-link by profiling them at runtime and then using that information to; optimize the layout of the final binary among other optimizations performed; at the binary level. There are also CMake caches available to build; LLVM/Clang with BOLT. To configure a single-stage build that builds LLVM/Clang and then optimizes; it with BOLT, use the following CMake configuration:. .. code-block:: console. $ cmake <path to source>/llvm -C <path to source>/clang/cmake/caches/BOLT.cmake. Then, build the BOLT-optimized binary by running the following ninja command:. .. code-block:: console. $ ninja clang-bolt. If you're seeing errors in the build process, try building with a recent; version of Clang/LLVM by setting the CMAKE_C_COMPILER and; CMAKE_CXX_COMPILER flags to the appropriate",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:11580,Testability,test,tests,11580,"configuration:. .. code-block:: console. $ cmake <path to source>/llvm -C <path to source>/clang/cmake/caches/BOLT.cmake. Then, build the BOLT-optimized binary by running the following ninja command:. .. code-block:: console. $ ninja clang-bolt. If you're seeing errors in the build process, try building with a recent; version of Clang/LLVM by setting the CMAKE_C_COMPILER and; CMAKE_CXX_COMPILER flags to the appropriate values. It is also possible to use BOLT on top of PGO and (Thin)LTO for an even more; significant runtime speedup. To configure a three stage PGO build with ThinLTO; that optimizes the resulting binary with BOLT, use the following CMake; configuration command:. .. code-block:: console. $ cmake -G Ninja <path to source>/llvm \; -C <path to source>/clang/cmake/caches/BOLT-PGO.cmake \; -DBOOTSTRAP_LLVM_ENABLE_LLD=ON \; -DBOOTSTRAP_BOOTSTRAP_LLVM_ENABLE_LLD=ON \; -DPGO_INSTRUMENT_LTO=Thin. Then, to build the final optimized binary, build the stage2-clang-bolt target:. .. code-block:: console. $ ninja stage2-clang-bolt. 3-Stage Non-Determinism; =======================. In the ancient lore of compilers non-determinism is like the multi-headed hydra.; Whenever its head pops up, terror and chaos ensue. Historically one of the tests to verify that a compiler was deterministic would; be a three stage build. The idea of a three stage build is you take your sources; and build a compiler (stage1), then use that compiler to rebuild the sources; (stage2), then you use that compiler to rebuild the sources a third time; (stage3) with an identical configuration to the stage2 build. At the end of; this, you have a stage2 and stage3 compiler that should be bit-for-bit; identical. You can perform one of these 3-stage builds with LLVM and clang using the; following commands:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/3-stage.cmake <path to source>/llvm; $ ninja stage3. After the build you can compare the stage2 and stage3 compilers.; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:1371,Usability,simpl,simple,1371," please start with the :doc:`GettingStarted` or; :doc:`CMake` pages. This page is intended for users doing more complex builds. Many of the examples below are written assuming specific CMake Generators.; Unless otherwise explicitly called out these commands should work with any CMake; generator. Many of the build configurations mentioned on this documentation page can be; utilized by using a CMake cache. A CMake cache is essentially a configuration; file that sets the necessary flags for a specific build configuration. The caches; for Clang are located in :code:`/clang/cmake/caches` within the monorepo. They; can be passed to CMake using the :code:`-C` flag as demonstrated in the examples; below along with additional configuration flags. Bootstrap Builds; ================. The Clang CMake build system supports bootstrap (aka multi-stage) builds. At a; high level a multi-stage build is a chain of builds that pass data from one; stage into the next. The most common and simple version of this is a traditional; bootstrap build. In a simple two-stage bootstrap build, we build clang using the system compiler,; then use that just-built clang to build clang again. In CMake this simplest form; of a bootstrap build can be configured with a single option,; CLANG_ENABLE_BOOTSTRAP. .. code-block:: console. $ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \; -DCLANG_ENABLE_BOOTSTRAP=On \; -DLLVM_ENABLE_PROJECTS=""clang"" \; <path to source>/llvm; $ ninja stage2. This command itself isn't terribly useful because it assumes default; configurations for each stage. The next series of examples utilize CMake cache; scripts to provide more complex options. By default, only a few CMake options will be passed between stages.; The list, called _BOOTSTRAP_DEFAULT_PASSTHROUGH, is defined in clang/CMakeLists.txt.; To force the passing of the variables between stages, use the -DCLANG_BOOTSTRAP_PASSTHROUGH; CMake option, each variable separated by a "";"". As example:. .. code-block:: console. $ cmake -",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:1434,Usability,simpl,simple,1434," more complex builds. Many of the examples below are written assuming specific CMake Generators.; Unless otherwise explicitly called out these commands should work with any CMake; generator. Many of the build configurations mentioned on this documentation page can be; utilized by using a CMake cache. A CMake cache is essentially a configuration; file that sets the necessary flags for a specific build configuration. The caches; for Clang are located in :code:`/clang/cmake/caches` within the monorepo. They; can be passed to CMake using the :code:`-C` flag as demonstrated in the examples; below along with additional configuration flags. Bootstrap Builds; ================. The Clang CMake build system supports bootstrap (aka multi-stage) builds. At a; high level a multi-stage build is a chain of builds that pass data from one; stage into the next. The most common and simple version of this is a traditional; bootstrap build. In a simple two-stage bootstrap build, we build clang using the system compiler,; then use that just-built clang to build clang again. In CMake this simplest form; of a bootstrap build can be configured with a single option,; CLANG_ENABLE_BOOTSTRAP. .. code-block:: console. $ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \; -DCLANG_ENABLE_BOOTSTRAP=On \; -DLLVM_ENABLE_PROJECTS=""clang"" \; <path to source>/llvm; $ ninja stage2. This command itself isn't terribly useful because it assumes default; configurations for each stage. The next series of examples utilize CMake cache; scripts to provide more complex options. By default, only a few CMake options will be passed between stages.; The list, called _BOOTSTRAP_DEFAULT_PASSTHROUGH, is defined in clang/CMakeLists.txt.; To force the passing of the variables between stages, use the -DCLANG_BOOTSTRAP_PASSTHROUGH; CMake option, each variable separated by a "";"". As example:. .. code-block:: console. $ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \; -DCLANG_ENABLE_BOOTSTRAP=On \; -DCLANG_BOOTSTRAP_PASSTHROUGH=""CMAKE_I",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:1578,Usability,simpl,simplest,1578," called out these commands should work with any CMake; generator. Many of the build configurations mentioned on this documentation page can be; utilized by using a CMake cache. A CMake cache is essentially a configuration; file that sets the necessary flags for a specific build configuration. The caches; for Clang are located in :code:`/clang/cmake/caches` within the monorepo. They; can be passed to CMake using the :code:`-C` flag as demonstrated in the examples; below along with additional configuration flags. Bootstrap Builds; ================. The Clang CMake build system supports bootstrap (aka multi-stage) builds. At a; high level a multi-stage build is a chain of builds that pass data from one; stage into the next. The most common and simple version of this is a traditional; bootstrap build. In a simple two-stage bootstrap build, we build clang using the system compiler,; then use that just-built clang to build clang again. In CMake this simplest form; of a bootstrap build can be configured with a single option,; CLANG_ENABLE_BOOTSTRAP. .. code-block:: console. $ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \; -DCLANG_ENABLE_BOOTSTRAP=On \; -DLLVM_ENABLE_PROJECTS=""clang"" \; <path to source>/llvm; $ ninja stage2. This command itself isn't terribly useful because it assumes default; configurations for each stage. The next series of examples utilize CMake cache; scripts to provide more complex options. By default, only a few CMake options will be passed between stages.; The list, called _BOOTSTRAP_DEFAULT_PASSTHROUGH, is defined in clang/CMakeLists.txt.; To force the passing of the variables between stages, use the -DCLANG_BOOTSTRAP_PASSTHROUGH; CMake option, each variable separated by a "";"". As example:. .. code-block:: console. $ cmake -G Ninja -DCMAKE_BUILD_TYPE=Release \; -DCLANG_ENABLE_BOOTSTRAP=On \; -DCLANG_BOOTSTRAP_PASSTHROUGH=""CMAKE_INSTALL_PREFIX;CMAKE_VERBOSE_MAKEFILE"" \; -DLLVM_ENABLE_PROJECTS=""clang"" \; <path to source>/llvm; $ ninja stage2. CMake optio",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:3461,Usability,simpl,simple,3461,"BOOTSTRAP=On \; -DCLANG_BOOTSTRAP_PASSTHROUGH=""CMAKE_INSTALL_PREFIX;CMAKE_VERBOSE_MAKEFILE"" \; -DLLVM_ENABLE_PROJECTS=""clang"" \; <path to source>/llvm; $ ninja stage2. CMake options starting by ``BOOTSTRAP_`` will be passed only to the stage2 build.; This gives the opportunity to use Clang specific build flags.; For example, the following CMake call will enabled '-fno-addrsig' only during; the stage2 build for C and C++. .. code-block:: console. $ cmake [..] -DBOOTSTRAP_CMAKE_CXX_FLAGS='-fno-addrsig' -DBOOTSTRAP_CMAKE_C_FLAGS='-fno-addrsig' [..]. The clang build system refers to builds as stages. A stage1 build is a standard; build using the compiler installed on the host, and a stage2 build is built; using the stage1 compiler. This nomenclature holds up to more stages too. In; general a stage*n* build is built using the output from stage*n-1*. Apple Clang Builds (A More Complex Bootstrap); =============================================. Apple's Clang builds are a slightly more complicated example of the simple; bootstrapping scenario. Apple Clang is built using a 2-stage build. The stage1 compiler is a host-only compiler with some options set. The stage1; compiler is a balance of optimization vs build time because it is a throwaway.; The stage2 compiler is the fully optimized compiler intended to ship to users. Setting up these compilers requires a lot of options. To simplify the; configuration the Apple Clang build settings are contained in CMake Cache files.; You can build an Apple Clang compiler using the following commands:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/Apple-stage1.cmake <path to source>/llvm; $ ninja stage2-distribution. This CMake invocation configures the stage1 host compiler, and sets; CLANG_BOOTSTRAP_CMAKE_ARGS to pass the Apple-stage2.cmake cache script to the; stage2 configuration step. When you build the stage2-distribution target it builds the minimal stage1; compiler and required tools, then configur",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:3832,Usability,simpl,simplify,3832,"ock:: console. $ cmake [..] -DBOOTSTRAP_CMAKE_CXX_FLAGS='-fno-addrsig' -DBOOTSTRAP_CMAKE_C_FLAGS='-fno-addrsig' [..]. The clang build system refers to builds as stages. A stage1 build is a standard; build using the compiler installed on the host, and a stage2 build is built; using the stage1 compiler. This nomenclature holds up to more stages too. In; general a stage*n* build is built using the output from stage*n-1*. Apple Clang Builds (A More Complex Bootstrap); =============================================. Apple's Clang builds are a slightly more complicated example of the simple; bootstrapping scenario. Apple Clang is built using a 2-stage build. The stage1 compiler is a host-only compiler with some options set. The stage1; compiler is a balance of optimization vs build time because it is a throwaway.; The stage2 compiler is the fully optimized compiler intended to ship to users. Setting up these compilers requires a lot of options. To simplify the; configuration the Apple Clang build settings are contained in CMake Cache files.; You can build an Apple Clang compiler using the following commands:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/Apple-stage1.cmake <path to source>/llvm; $ ninja stage2-distribution. This CMake invocation configures the stage1 host compiler, and sets; CLANG_BOOTSTRAP_CMAKE_ARGS to pass the Apple-stage2.cmake cache script to the; stage2 configuration step. When you build the stage2-distribution target it builds the minimal stage1; compiler and required tools, then configures and builds the stage2 compiler; based on the settings in Apple-stage2.cmake. This pattern of using cache scripts to set complex settings, and specifically to; make later stage builds include cache scripts is common in our more advanced; build configurations. Multi-stage PGO; ===============. Profile-Guided Optimizations (PGO) is a really great way to optimize the code; clang generates. Our multi-stage PGO builds are a workflow f",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst:6256,Usability,simpl,simple,6256,"raw files; you use llvm-profdata to merge the files into a single profdata file that you; can feed into the LLVM_PROFDATA_FILE option. Our PGO.cmake cache automates that whole process. You can use it for; configuration with CMake with the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; <path to source>/llvm. There are several additional options that the cache file also accepts to modify; the build, particularly the PGO_INSTRUMENT_LTO option. Setting this option to; Thin or Full will enable ThinLTO or full LTO respectively, further enhancing; the performance gains from a PGO build by enabling interprocedural; optimizations. For example, to run a CMake configuration for a PGO build; that also enables ThinTLO, use the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; -DPGO_INSTRUMENT_LTO=Thin \; <path to source>/llvm. By default, clang will generate profile data by compiling a simple; hello world program. You can also tell clang use an external; project for generating profile data that may be a better fit for your; use case. The project you specify must either be a lit test suite; (use the CLANG_PGO_TRAINING_DATA option) or a CMake project (use the; CLANG_PERF_TRAINING_DATA_SOURCE_DIR option). For example, If you wanted to use the; `LLVM Test Suite <https://github.com/llvm/llvm-test-suite/>`_ to generate; profile data you would use the following command:. .. code-block:: console. $ cmake -G Ninja -C <path to source>/clang/cmake/caches/PGO.cmake \; -DBOOTSTRAP_CLANG_PGO_TRAINING_DATA_SOURCE_DIR=<path to llvm-test-suite> \; -DBOOTSTRAP_CLANG_PGO_TRAINING_DEPS=runtimes. The BOOTSTRAP\_ prefixes tells CMake to pass the variables on to the instrumented; stage two build. And the CLANG_PGO_TRAINING_DEPS option let's you specify; additional build targets to build before building the external project. The; LLVM Test Suite requires compiler-rt to build",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AdvancedBuilds.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:4117,Availability,avail,available,4117,"size is critically; important for correct Alias Analyses. For example, consider this (silly, but; possible) C code:. .. code-block:: c++. int i;; char C[2];; char A[10];; /* ... */; for (i = 0; i != 10; ++i) {; C[0] = A[i]; /* One byte store */; C[1] = A[9-i]; /* One byte store */; }. In this case, the ``basic-aa`` pass will disambiguate the stores to ``C[0]`` and; ``C[1]`` because they are accesses to two distinct locations one byte apart, and; the accesses are each one byte. In this case, the Loop Invariant Code Motion; (LICM) pass can use store motion to remove the stores from the loop. In; contrast, the following code:. .. code-block:: c++. int i;; char C[2];; char A[10];; /* ... */; for (i = 0; i != 10; ++i) {; ((short*)C)[0] = A[i]; /* Two byte store! */; C[1] = A[9-i]; /* One byte store */; }. In this case, the two stores to C do alias each other, because the access to the; ``&C[0]`` element is a two byte access. If size information wasn't available in; the query, even the first case would have to conservatively assume that the; accesses alias. .. _alias:. The ``alias`` method; --------------------. The ``alias`` method is the primary interface used to determine whether or not; two memory objects alias each other. It takes two memory objects as input and; returns MustAlias, PartialAlias, MayAlias, or NoAlias as appropriate. Like all ``AliasAnalysis`` interfaces, the ``alias`` method requires that either; the two pointer values be defined within the same function, or at least one of; the values is a :ref:`constant <constants>`. .. _Must, May, or No:. Must, May, and No Alias Responses; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``NoAlias`` response may be used when there is never an immediate dependence; between any memory reference *based* on one pointer and any memory reference; *based* the other. The most obvious example is when the two pointers point to; non-overlapping memory ranges. Another is when the two pointers are only ever; used for reading memory. Anot",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:18614,Availability,error,errors,18614,"alue`` methods which are intended to allow a pass to; keep an AliasAnalysis consistent, however there's no way for a pass to declare; in its ``getAnalysisUsage`` that it does so. Some passes attempt to use; ``AU.addPreserved<AliasAnalysis>``, however this doesn't actually have any; effect. Similarly, the ``opt -p`` option introduces ``ModulePass`` passes between each; pass, which prevents the use of ``FunctionPass`` alias analysis passes. The ``AliasAnalysis`` API does have functions for notifying implementations when; values are deleted or copied, however these aren't sufficient. There are many; other ways that LLVM IR can be modified which could be relevant to; ``AliasAnalysis`` implementations which can not be expressed. The ``AliasAnalysisDebugger`` utility seems to suggest that ``AliasAnalysis``; implementations can expect that they will be informed of any relevant ``Value``; before it appears in an alias query. However, popular clients such as ``GVN``; don't support this, and are known to trigger errors when run with the; ``AliasAnalysisDebugger``. The ``AliasSetTracker`` class (which is used by ``LICM``) makes a; non-deterministic number of alias queries. This can cause debugging techniques; involving pausing execution after a predetermined number of queries to be; unreliable. Many alias queries can be reformulated in terms of other alias queries. When; multiple ``AliasAnalysis`` queries are chained together, it would make sense to; start those queries from the beginning of the chain, with care taken to avoid; infinite looping, however currently an implementation which wants to do this can; only start such queries from itself. Using alias analysis results; ============================. There are several different ways to use alias analysis results. In order of; preference, these are:. Using the ``MemoryDependenceAnalysis`` Pass; -------------------------------------------. The ``memdep`` pass uses alias analysis to provide high-level dependence; information a",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:23244,Availability,avail,available,23244,"hrough; these hash-table nodes to avoid having to allocate memory unnecessarily, and to; make merging alias sets extremely efficient (the linked list merge is constant; time). You shouldn't need to understand these details if you are just a client of the; AliasSetTracker, but if you look at the code, hopefully this brief description; will help make sense of why things are designed the way they are. Using the ``AliasAnalysis`` interface directly; ----------------------------------------------. If neither of these utility class are what your pass needs, you should use the; interfaces exposed by the ``AliasAnalysis`` class directly. Try to use the; higher-level methods when possible (e.g., use mod/ref information instead of the; `alias`_ method directly if possible) to get the best precision and efficiency. Existing alias analysis implementations and clients; ===================================================. If you're going to be working with the LLVM alias analysis infrastructure, you; should know what clients and implementations of alias analysis are available.; In particular, if you are implementing an alias analysis, you should be aware of; the `the clients`_ that are useful for monitoring and evaluating different; implementations. .. _various alias analysis implementations:. Available ``AliasAnalysis`` implementations; -------------------------------------------. This section lists the various implementations of the ``AliasAnalysis``; interface. All of these :ref:`chain <aliasanalysis-chaining>` to other; alias analysis implementations. The ``-basic-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^^. The ``-basic-aa`` pass is an aggressive local analysis that *knows* many; important facts:. * Distinct globals, stack allocations, and heap allocations can never alias.; * Globals, stack allocations, and heap allocations never alias the null pointer.; * Different fields of a structure do not alias.; * Indexes into arrays with statically differing subscripts cannot alias.; * Many co",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:26047,Availability,avail,available,26047,"ref; information for call instructions. This allows the optimizer to know that calls; to a function do not clobber or read the value of the global, allowing loads and; stores to be eliminated. .. note::. This pass is somewhat limited in its scope (only support non-address taken; globals), but is very quick analysis. The ``-steens-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^^^. The ``-steens-aa`` pass implements a variation on the well-known ""Steensgaard's; algorithm"" for interprocedural alias analysis. Steensgaard's algorithm is a; unification-based, flow-insensitive, context-insensitive, and field-insensitive; alias analysis that is also very scalable (effectively linear time). The LLVM ``-steens-aa`` pass implements a ""speculatively field-**sensitive**""; version of Steensgaard's algorithm using the Data Structure Analysis framework.; This gives it substantially more precision than the standard algorithm while; maintaining excellent analysis scalability. .. note::. ``-steens-aa`` is available in the optional ""poolalloc"" module. It is not part; of the LLVM core. The ``-ds-aa`` pass; ^^^^^^^^^^^^^^^^^^^. The ``-ds-aa`` pass implements the full Data Structure Analysis algorithm. Data; Structure Analysis is a modular unification-based, flow-insensitive,; context-**sensitive**, and speculatively field-**sensitive** alias; analysis that is also quite scalable, usually at ``O(n * log(n))``. This algorithm is capable of responding to a full variety of alias analysis; queries, and can provide context-sensitive mod/ref information as well. The; only major facility not implemented so far is support for must-alias; information. .. note::. ``-ds-aa`` is available in the optional ""poolalloc"" module. It is not part of; the LLVM core. The ``-scev-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^. The ``-scev-aa`` pass implements AliasAnalysis queries by translating them into; ScalarEvolution queries. This gives it a more complete understanding of; ``getelementptr`` instructions and loop induction variables th",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:26718,Availability,avail,available,26718,"). The LLVM ``-steens-aa`` pass implements a ""speculatively field-**sensitive**""; version of Steensgaard's algorithm using the Data Structure Analysis framework.; This gives it substantially more precision than the standard algorithm while; maintaining excellent analysis scalability. .. note::. ``-steens-aa`` is available in the optional ""poolalloc"" module. It is not part; of the LLVM core. The ``-ds-aa`` pass; ^^^^^^^^^^^^^^^^^^^. The ``-ds-aa`` pass implements the full Data Structure Analysis algorithm. Data; Structure Analysis is a modular unification-based, flow-insensitive,; context-**sensitive**, and speculatively field-**sensitive** alias; analysis that is also quite scalable, usually at ``O(n * log(n))``. This algorithm is capable of responding to a full variety of alias analysis; queries, and can provide context-sensitive mod/ref information as well. The; only major facility not implemented so far is support for must-alias; information. .. note::. ``-ds-aa`` is available in the optional ""poolalloc"" module. It is not part of; the LLVM core. The ``-scev-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^. The ``-scev-aa`` pass implements AliasAnalysis queries by translating them into; ScalarEvolution queries. This gives it a more complete understanding of; ``getelementptr`` instructions and loop induction variables than other alias; analyses have. Alias analysis driven transformations; -------------------------------------. LLVM includes several alias-analysis driven transformations which can be used; with any of the implementations above. The ``-adce`` pass; ^^^^^^^^^^^^^^^^^^. The ``-adce`` pass, which implements Aggressive Dead Code Elimination uses the; ``AliasAnalysis`` interface to delete calls to functions that do not have; side-effects and are not used. The ``-licm`` pass; ^^^^^^^^^^^^^^^^^^. The ``-licm`` pass implements various Loop Invariant Code Motion related; transformations. It uses the ``AliasAnalysis`` interface for several different; transformations:. * It use",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:13486,Deployability,update,update,13486," you are; implementing, you just override the interfaces you can improve. .. _aliasanalysis-chaining:. ``AliasAnalysis`` chaining behavior; -----------------------------------. Every alias analysis pass chains to another alias analysis implementation (for; example, the user can specify ""``-basic-aa -ds-aa -licm``"" to get the maximum; benefit from both alias analyses). The alias analysis class automatically; takes care of most of this for methods that you don't override. For methods; that you do override, in code paths that return a conservative MayAlias or; Mod/Ref result, simply return whatever the superclass computes. For example:. .. code-block:: c++. AliasResult alias(const Value *V1, unsigned V1Size,; const Value *V2, unsigned V2Size) {; if (...); return NoAlias;; ... // Couldn't determine a must or no-alias result.; return AliasAnalysis::alias(V1, V1Size, V2, V2Size);; }. In addition to analysis queries, you must make sure to unconditionally pass LLVM; `update notification`_ methods to the superclass as well if you override them,; which allows all alias analyses in a change to be updated. .. _update notification:. Updating analysis results for transformations; ---------------------------------------------. Alias analysis information is initially computed for a static snapshot of the; program, but clients will use this information to make transformations to the; code. All but the most trivial forms of alias analysis will need to have their; analysis results updated to reflect the changes made by these transformations. The ``AliasAnalysis`` interface exposes four methods which are used to; communicate program changes from the clients to the analysis implementations.; Various alias analysis implementations should use these methods to ensure that; their internal data structures are kept up-to-date as the program changes (for; example, when an instruction is deleted), and clients of alias analysis must be; sure to call these interfaces appropriately. The ``deleteVal",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:13615,Deployability,update,updated,13615," you are; implementing, you just override the interfaces you can improve. .. _aliasanalysis-chaining:. ``AliasAnalysis`` chaining behavior; -----------------------------------. Every alias analysis pass chains to another alias analysis implementation (for; example, the user can specify ""``-basic-aa -ds-aa -licm``"" to get the maximum; benefit from both alias analyses). The alias analysis class automatically; takes care of most of this for methods that you don't override. For methods; that you do override, in code paths that return a conservative MayAlias or; Mod/Ref result, simply return whatever the superclass computes. For example:. .. code-block:: c++. AliasResult alias(const Value *V1, unsigned V1Size,; const Value *V2, unsigned V2Size) {; if (...); return NoAlias;; ... // Couldn't determine a must or no-alias result.; return AliasAnalysis::alias(V1, V1Size, V2, V2Size);; }. In addition to analysis queries, you must make sure to unconditionally pass LLVM; `update notification`_ methods to the superclass as well if you override them,; which allows all alias analyses in a change to be updated. .. _update notification:. Updating analysis results for transformations; ---------------------------------------------. Alias analysis information is initially computed for a static snapshot of the; program, but clients will use this information to make transformations to the; code. All but the most trivial forms of alias analysis will need to have their; analysis results updated to reflect the changes made by these transformations. The ``AliasAnalysis`` interface exposes four methods which are used to; communicate program changes from the clients to the analysis implementations.; Various alias analysis implementations should use these methods to ensure that; their internal data structures are kept up-to-date as the program changes (for; example, when an instruction is deleted), and clients of alias analysis must be; sure to call these interfaces appropriately. The ``deleteVal",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:13999,Deployability,update,updated,13999,"de. For methods; that you do override, in code paths that return a conservative MayAlias or; Mod/Ref result, simply return whatever the superclass computes. For example:. .. code-block:: c++. AliasResult alias(const Value *V1, unsigned V1Size,; const Value *V2, unsigned V2Size) {; if (...); return NoAlias;; ... // Couldn't determine a must or no-alias result.; return AliasAnalysis::alias(V1, V1Size, V2, V2Size);; }. In addition to analysis queries, you must make sure to unconditionally pass LLVM; `update notification`_ methods to the superclass as well if you override them,; which allows all alias analyses in a change to be updated. .. _update notification:. Updating analysis results for transformations; ---------------------------------------------. Alias analysis information is initially computed for a static snapshot of the; program, but clients will use this information to make transformations to the; code. All but the most trivial forms of alias analysis will need to have their; analysis results updated to reflect the changes made by these transformations. The ``AliasAnalysis`` interface exposes four methods which are used to; communicate program changes from the clients to the analysis implementations.; Various alias analysis implementations should use these methods to ensure that; their internal data structures are kept up-to-date as the program changes (for; example, when an instruction is deleted), and clients of alias analysis must be; sure to call these interfaces appropriately. The ``deleteValue`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``deleteValue`` method is called by transformations when they remove an; instruction or any other value from the program (including values that do not; use pointers). Typically alias analyses keep data structures that have entries; for each value in the program. When this method is called, they should remove; any entries for the specified value, if they exist. The ``copyValue`` method; ^^^^^^^^^^^^^^^^^^^^^^^^. The ``copyV",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:1429,Energy Efficiency,power,powerful,1429,"d many; different ways of classifying them: flow-sensitive vs. flow-insensitive,; context-sensitive vs. context-insensitive, field-sensitive; vs. field-insensitive, unification-based vs. subset-based, etc. Traditionally,; alias analyses respond to a query with a `Must, May, or No`_ alias response,; indicating that two pointers always point to the same object, might point to the; same object, or are known to never point to the same object. The LLVM `AliasAnalysis; <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`__ class is the; primary interface used by clients and implementations of alias analyses in the; LLVM system. This class is the common interface between clients of alias; analysis information and the implementations providing it, and is designed to; support a wide range of implementations and clients (but currently all clients; are assumed to be flow-insensitive). In addition to simple alias analysis; information, this class exposes Mod/Ref information from those implementations; which can provide it, allowing for powerful analyses and transformations to work; well together. This document contains information necessary to successfully implement this; interface, use it, and to test both sides. It also explains some of the finer; points about what exactly results mean. ``AliasAnalysis`` Class Overview; ================================. The `AliasAnalysis <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`__; class defines the interface that the various alias analysis implementations; should support. This class exports two important enums: ``AliasResult`` and; ``ModRefResult`` which represent the result of an alias query or a mod/ref; query, respectively. The ``AliasAnalysis`` interface exposes information about memory, represented in; several different ways. In particular, memory objects are represented as a; starting address and size, and function calls are represented as the actual; ``call`` or ``invoke`` instructions that performs the call. ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:16545,Energy Efficiency,efficient,efficient,16545,"nformation to the new; value, then deleting the old value. This method cannot be overridden by alias; analysis implementations. The ``addEscapingUse`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``addEscapingUse`` method is used when the uses of a pointer value have; changed in ways that may invalidate precomputed analysis information.; Implementations may either use this callback to provide conservative responses; for points whose uses have change since analysis time, or may recompute some or; all of their internal state to continue providing accurate responses. In general, any new use of a pointer value is considered an escaping use, and; must be reported through this callback, *except* for the uses below:. * A ``bitcast`` or ``getelementptr`` of the pointer; * A ``store`` through the pointer (but not a ``store`` *of* the pointer); * A ``load`` through the pointer. Efficiency Issues; -----------------. From the LLVM perspective, the only thing you need to do to provide an efficient; alias analysis is to make sure that alias analysis **queries** are serviced; quickly. The actual calculation of the alias analysis results (the ""run""; method) is only performed once, but many (perhaps duplicate) queries may be; performed. Because of this, try to move as much computation to the run method; as possible (within reason). Limitations; -----------. The AliasAnalysis infrastructure has several limitations which make writing a; new ``AliasAnalysis`` implementation difficult. There is no way to override the default alias analysis. It would be very useful; to be able to do something like ""``opt -my-aa -O2``"" and have it use ``-my-aa``; for all passes which need AliasAnalysis, but there is currently no support for; that, short of changing the source code and recompiling. Similarly, there is; also no way of setting a chain of analyses as the default. There is no way for transform passes to declare that they preserve; ``AliasAnalysis`` implementations. The ``AliasAnalysis`` interfac",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:19736,Energy Efficiency,efficient,efficient,19736,"umber of alias queries. This can cause debugging techniques; involving pausing execution after a predetermined number of queries to be; unreliable. Many alias queries can be reformulated in terms of other alias queries. When; multiple ``AliasAnalysis`` queries are chained together, it would make sense to; start those queries from the beginning of the chain, with care taken to avoid; infinite looping, however currently an implementation which wants to do this can; only start such queries from itself. Using alias analysis results; ============================. There are several different ways to use alias analysis results. In order of; preference, these are:. Using the ``MemoryDependenceAnalysis`` Pass; -------------------------------------------. The ``memdep`` pass uses alias analysis to provide high-level dependence; information about memory-using instructions. This will tell you which store; feeds into a load, for example. It uses caching and other techniques to be; efficient, and is used by Dead Store Elimination, GVN, and memcpy optimizations. .. _AliasSetTracker:. Using the ``AliasSetTracker`` class; -----------------------------------. Many transformations need information about alias **sets** that are active in; some scope, rather than information about pairwise aliasing. The; `AliasSetTracker <https://llvm.org/doxygen/classllvm_1_1AliasSetTracker.html>`__; class is used to efficiently build these Alias Sets from the pairwise alias; analysis information provided by the ``AliasAnalysis`` interface. First you initialize the AliasSetTracker by using the ""``add``"" methods to add; information about various potentially aliasing instructions in the scope you are; interested in. Once all of the alias sets are completed, your pass should; simply iterate through the constructed alias sets, using the ``AliasSetTracker``; ``begin()``/``end()`` methods. The ``AliasSet``\s formed by the ``AliasSetTracker`` are guaranteed to be; disjoint, calculate mod/ref information and vo",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:20157,Energy Efficiency,efficient,efficiently,20157,"o do this can; only start such queries from itself. Using alias analysis results; ============================. There are several different ways to use alias analysis results. In order of; preference, these are:. Using the ``MemoryDependenceAnalysis`` Pass; -------------------------------------------. The ``memdep`` pass uses alias analysis to provide high-level dependence; information about memory-using instructions. This will tell you which store; feeds into a load, for example. It uses caching and other techniques to be; efficient, and is used by Dead Store Elimination, GVN, and memcpy optimizations. .. _AliasSetTracker:. Using the ``AliasSetTracker`` class; -----------------------------------. Many transformations need information about alias **sets** that are active in; some scope, rather than information about pairwise aliasing. The; `AliasSetTracker <https://llvm.org/doxygen/classllvm_1_1AliasSetTracker.html>`__; class is used to efficiently build these Alias Sets from the pairwise alias; analysis information provided by the ``AliasAnalysis`` interface. First you initialize the AliasSetTracker by using the ""``add``"" methods to add; information about various potentially aliasing instructions in the scope you are; interested in. Once all of the alias sets are completed, your pass should; simply iterate through the constructed alias sets, using the ``AliasSetTracker``; ``begin()``/``end()`` methods. The ``AliasSet``\s formed by the ``AliasSetTracker`` are guaranteed to be; disjoint, calculate mod/ref information and volatility for the set, and keep; track of whether or not all of the pointers in the set are Must aliases. The; AliasSetTracker also makes sure that sets are properly folded due to call; instructions, and can provide a list of pointers in each set. As an example user of this, the `Loop Invariant Code Motion; <doxygen/structLICM.html>`_ pass uses ``AliasSetTracker``\s to calculate alias; sets for each loop nest. If an ``AliasSet`` in a loop is not mod",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:21689,Energy Efficiency,efficient,efficient,21689,"etTracker`` are guaranteed to be; disjoint, calculate mod/ref information and volatility for the set, and keep; track of whether or not all of the pointers in the set are Must aliases. The; AliasSetTracker also makes sure that sets are properly folded due to call; instructions, and can provide a list of pointers in each set. As an example user of this, the `Loop Invariant Code Motion; <doxygen/structLICM.html>`_ pass uses ``AliasSetTracker``\s to calculate alias; sets for each loop nest. If an ``AliasSet`` in a loop is not modified, then all; load instructions from that set may be hoisted out of the loop. If any alias; sets are stored to **and** are must alias sets, then the stores may be sunk; to outside of the loop, promoting the memory location to a register for the; duration of the loop nest. Both of these transformations only apply if the; pointer argument is loop-invariant. The AliasSetTracker implementation; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The AliasSetTracker class is implemented to be as efficient as possible. It; uses the union-find algorithm to efficiently merge AliasSets when a pointer is; inserted into the AliasSetTracker that aliases multiple sets. The primary data; structure is a hash table mapping pointers to the AliasSet they are in. The AliasSetTracker class must maintain a list of all of the LLVM ``Value*``\s; that are in each AliasSet. Since the hash table already has entries for each; LLVM ``Value*`` of interest, the AliasesSets thread the linked list through; these hash-table nodes to avoid having to allocate memory unnecessarily, and to; make merging alias sets extremely efficient (the linked list merge is constant; time). You shouldn't need to understand these details if you are just a client of the; AliasSetTracker, but if you look at the code, hopefully this brief description; will help make sense of why things are designed the way they are. Using the ``AliasAnalysis`` interface directly; ----------------------------------------------. If",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:21749,Energy Efficiency,efficient,efficiently,21749,"; track of whether or not all of the pointers in the set are Must aliases. The; AliasSetTracker also makes sure that sets are properly folded due to call; instructions, and can provide a list of pointers in each set. As an example user of this, the `Loop Invariant Code Motion; <doxygen/structLICM.html>`_ pass uses ``AliasSetTracker``\s to calculate alias; sets for each loop nest. If an ``AliasSet`` in a loop is not modified, then all; load instructions from that set may be hoisted out of the loop. If any alias; sets are stored to **and** are must alias sets, then the stores may be sunk; to outside of the loop, promoting the memory location to a register for the; duration of the loop nest. Both of these transformations only apply if the; pointer argument is loop-invariant. The AliasSetTracker implementation; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The AliasSetTracker class is implemented to be as efficient as possible. It; uses the union-find algorithm to efficiently merge AliasSets when a pointer is; inserted into the AliasSetTracker that aliases multiple sets. The primary data; structure is a hash table mapping pointers to the AliasSet they are in. The AliasSetTracker class must maintain a list of all of the LLVM ``Value*``\s; that are in each AliasSet. Since the hash table already has entries for each; LLVM ``Value*`` of interest, the AliasesSets thread the linked list through; these hash-table nodes to avoid having to allocate memory unnecessarily, and to; make merging alias sets extremely efficient (the linked list merge is constant; time). You shouldn't need to understand these details if you are just a client of the; AliasSetTracker, but if you look at the code, hopefully this brief description; will help make sense of why things are designed the way they are. Using the ``AliasAnalysis`` interface directly; ----------------------------------------------. If neither of these utility class are what your pass needs, you should use the; interfaces exposed by the ``Ali",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:22225,Energy Efficiency,allocate,allocate,22225," modified, then all; load instructions from that set may be hoisted out of the loop. If any alias; sets are stored to **and** are must alias sets, then the stores may be sunk; to outside of the loop, promoting the memory location to a register for the; duration of the loop nest. Both of these transformations only apply if the; pointer argument is loop-invariant. The AliasSetTracker implementation; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The AliasSetTracker class is implemented to be as efficient as possible. It; uses the union-find algorithm to efficiently merge AliasSets when a pointer is; inserted into the AliasSetTracker that aliases multiple sets. The primary data; structure is a hash table mapping pointers to the AliasSet they are in. The AliasSetTracker class must maintain a list of all of the LLVM ``Value*``\s; that are in each AliasSet. Since the hash table already has entries for each; LLVM ``Value*`` of interest, the AliasesSets thread the linked list through; these hash-table nodes to avoid having to allocate memory unnecessarily, and to; make merging alias sets extremely efficient (the linked list merge is constant; time). You shouldn't need to understand these details if you are just a client of the; AliasSetTracker, but if you look at the code, hopefully this brief description; will help make sense of why things are designed the way they are. Using the ``AliasAnalysis`` interface directly; ----------------------------------------------. If neither of these utility class are what your pass needs, you should use the; interfaces exposed by the ``AliasAnalysis`` class directly. Try to use the; higher-level methods when possible (e.g., use mod/ref information instead of the; `alias`_ method directly if possible) to get the best precision and efficiency. Existing alias analysis implementations and clients; ===================================================. If you're going to be working with the LLVM alias analysis infrastructure, you; should know what clients ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:22298,Energy Efficiency,efficient,efficient,22298," modified, then all; load instructions from that set may be hoisted out of the loop. If any alias; sets are stored to **and** are must alias sets, then the stores may be sunk; to outside of the loop, promoting the memory location to a register for the; duration of the loop nest. Both of these transformations only apply if the; pointer argument is loop-invariant. The AliasSetTracker implementation; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The AliasSetTracker class is implemented to be as efficient as possible. It; uses the union-find algorithm to efficiently merge AliasSets when a pointer is; inserted into the AliasSetTracker that aliases multiple sets. The primary data; structure is a hash table mapping pointers to the AliasSet they are in. The AliasSetTracker class must maintain a list of all of the LLVM ``Value*``\s; that are in each AliasSet. Since the hash table already has entries for each; LLVM ``Value*`` of interest, the AliasesSets thread the linked list through; these hash-table nodes to avoid having to allocate memory unnecessarily, and to; make merging alias sets extremely efficient (the linked list merge is constant; time). You shouldn't need to understand these details if you are just a client of the; AliasSetTracker, but if you look at the code, hopefully this brief description; will help make sense of why things are designed the way they are. Using the ``AliasAnalysis`` interface directly; ----------------------------------------------. If neither of these utility class are what your pass needs, you should use the; interfaces exposed by the ``AliasAnalysis`` class directly. Try to use the; higher-level methods when possible (e.g., use mod/ref information instead of the; `alias`_ method directly if possible) to get the best precision and efficiency. Existing alias analysis implementations and clients; ===================================================. If you're going to be working with the LLVM alias analysis infrastructure, you; should know what clients ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:23377,Energy Efficiency,monitor,monitoring,23377,"; time). You shouldn't need to understand these details if you are just a client of the; AliasSetTracker, but if you look at the code, hopefully this brief description; will help make sense of why things are designed the way they are. Using the ``AliasAnalysis`` interface directly; ----------------------------------------------. If neither of these utility class are what your pass needs, you should use the; interfaces exposed by the ``AliasAnalysis`` class directly. Try to use the; higher-level methods when possible (e.g., use mod/ref information instead of the; `alias`_ method directly if possible) to get the best precision and efficiency. Existing alias analysis implementations and clients; ===================================================. If you're going to be working with the LLVM alias analysis infrastructure, you; should know what clients and implementations of alias analysis are available.; In particular, if you are implementing an alias analysis, you should be aware of; the `the clients`_ that are useful for monitoring and evaluating different; implementations. .. _various alias analysis implementations:. Available ``AliasAnalysis`` implementations; -------------------------------------------. This section lists the various implementations of the ``AliasAnalysis``; interface. All of these :ref:`chain <aliasanalysis-chaining>` to other; alias analysis implementations. The ``-basic-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^^. The ``-basic-aa`` pass is an aggressive local analysis that *knows* many; important facts:. * Distinct globals, stack allocations, and heap allocations can never alias.; * Globals, stack allocations, and heap allocations never alias the null pointer.; * Different fields of a structure do not alias.; * Indexes into arrays with statically differing subscripts cannot alias.; * Many common standard C library functions `never access memory or only read; memory`_.; * Pointers that obviously point to constant globals ""``pointToConstantMemory``"".; * Fun",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:24446,Energy Efficiency,allocate,allocates,24446,"lementations. .. _various alias analysis implementations:. Available ``AliasAnalysis`` implementations; -------------------------------------------. This section lists the various implementations of the ``AliasAnalysis``; interface. All of these :ref:`chain <aliasanalysis-chaining>` to other; alias analysis implementations. The ``-basic-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^^. The ``-basic-aa`` pass is an aggressive local analysis that *knows* many; important facts:. * Distinct globals, stack allocations, and heap allocations can never alias.; * Globals, stack allocations, and heap allocations never alias the null pointer.; * Different fields of a structure do not alias.; * Indexes into arrays with statically differing subscripts cannot alias.; * Many common standard C library functions `never access memory or only read; memory`_.; * Pointers that obviously point to constant globals ""``pointToConstantMemory``"".; * Function calls can not modify or references stack allocations if they never; escape from the function that allocates them (a common case for automatic; arrays). The ``-globalsmodref-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This pass implements a simple context-sensitive mod/ref and alias analysis for; internal global variables that don't ""have their address taken"". If a global; does not have its address taken, the pass knows that no pointers alias the; global. This pass also keeps track of functions that it knows never access; memory or never read memory. This allows certain optimizations (e.g. GVN) to; eliminate call instructions entirely. The real power of this pass is that it provides context-sensitive mod/ref; information for call instructions. This allows the optimizer to know that calls; to a function do not clobber or read the value of the global, allowing loads and; stores to be eliminated. .. note::. This pass is somewhat limited in its scope (only support non-address taken; globals), but is very quick analysis. The ``-steens-aa`` pass; ^^^^^^^^^^^^^^",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:24999,Energy Efficiency,power,power,24999," Different fields of a structure do not alias.; * Indexes into arrays with statically differing subscripts cannot alias.; * Many common standard C library functions `never access memory or only read; memory`_.; * Pointers that obviously point to constant globals ""``pointToConstantMemory``"".; * Function calls can not modify or references stack allocations if they never; escape from the function that allocates them (a common case for automatic; arrays). The ``-globalsmodref-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This pass implements a simple context-sensitive mod/ref and alias analysis for; internal global variables that don't ""have their address taken"". If a global; does not have its address taken, the pass knows that no pointers alias the; global. This pass also keeps track of functions that it knows never access; memory or never read memory. This allows certain optimizations (e.g. GVN) to; eliminate call instructions entirely. The real power of this pass is that it provides context-sensitive mod/ref; information for call instructions. This allows the optimizer to know that calls; to a function do not clobber or read the value of the global, allowing loads and; stores to be eliminated. .. note::. This pass is somewhat limited in its scope (only support non-address taken; globals), but is very quick analysis. The ``-steens-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^^^. The ``-steens-aa`` pass implements a variation on the well-known ""Steensgaard's; algorithm"" for interprocedural alias analysis. Steensgaard's algorithm is a; unification-based, flow-insensitive, context-insensitive, and field-insensitive; alias analysis that is also very scalable (effectively linear time). The LLVM ``-steens-aa`` pass implements a ""speculatively field-**sensitive**""; version of Steensgaard's algorithm using the Data Structure Analysis framework.; This gives it substantially more precision than the standard algorithm while; maintaining excellent analysis scalability. .. note::. ``-steens-aa`` ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:934,Integrability,interface,interface,934,"==================================; LLVM Alias Analysis Infrastructure; ==================================. .. contents::; :local:. Introduction; ============. Alias Analysis (aka Pointer Analysis) is a class of techniques which attempt to; determine whether or not two pointers ever can point to the same object in; memory. There are many different algorithms for alias analysis and many; different ways of classifying them: flow-sensitive vs. flow-insensitive,; context-sensitive vs. context-insensitive, field-sensitive; vs. field-insensitive, unification-based vs. subset-based, etc. Traditionally,; alias analyses respond to a query with a `Must, May, or No`_ alias response,; indicating that two pointers always point to the same object, might point to the; same object, or are known to never point to the same object. The LLVM `AliasAnalysis; <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`__ class is the; primary interface used by clients and implementations of alias analyses in the; LLVM system. This class is the common interface between clients of alias; analysis information and the implementations providing it, and is designed to; support a wide range of implementations and clients (but currently all clients; are assumed to be flow-insensitive). In addition to simple alias analysis; information, this class exposes Mod/Ref information from those implementations; which can provide it, allowing for powerful analyses and transformations to work; well together. This document contains information necessary to successfully implement this; interface, use it, and to test both sides. It also explains some of the finer; points about what exactly results mean. ``AliasAnalysis`` Class Overview; ================================. The `AliasAnalysis <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`__; class defines the interface that the various alias analysis implementations; should support. This class exports two important enums: ``AliasResult`` and; ``ModRefRe",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:1044,Integrability,interface,interface,1044,"============. Alias Analysis (aka Pointer Analysis) is a class of techniques which attempt to; determine whether or not two pointers ever can point to the same object in; memory. There are many different algorithms for alias analysis and many; different ways of classifying them: flow-sensitive vs. flow-insensitive,; context-sensitive vs. context-insensitive, field-sensitive; vs. field-insensitive, unification-based vs. subset-based, etc. Traditionally,; alias analyses respond to a query with a `Must, May, or No`_ alias response,; indicating that two pointers always point to the same object, might point to the; same object, or are known to never point to the same object. The LLVM `AliasAnalysis; <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`__ class is the; primary interface used by clients and implementations of alias analyses in the; LLVM system. This class is the common interface between clients of alias; analysis information and the implementations providing it, and is designed to; support a wide range of implementations and clients (but currently all clients; are assumed to be flow-insensitive). In addition to simple alias analysis; information, this class exposes Mod/Ref information from those implementations; which can provide it, allowing for powerful analyses and transformations to work; well together. This document contains information necessary to successfully implement this; interface, use it, and to test both sides. It also explains some of the finer; points about what exactly results mean. ``AliasAnalysis`` Class Overview; ================================. The `AliasAnalysis <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`__; class defines the interface that the various alias analysis implementations; should support. This class exports two important enums: ``AliasResult`` and; ``ModRefResult`` which represent the result of an alias query or a mod/ref; query, respectively. The ``AliasAnalysis`` interface exposes information about m",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:1568,Integrability,interface,interface,1568,"fication-based vs. subset-based, etc. Traditionally,; alias analyses respond to a query with a `Must, May, or No`_ alias response,; indicating that two pointers always point to the same object, might point to the; same object, or are known to never point to the same object. The LLVM `AliasAnalysis; <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`__ class is the; primary interface used by clients and implementations of alias analyses in the; LLVM system. This class is the common interface between clients of alias; analysis information and the implementations providing it, and is designed to; support a wide range of implementations and clients (but currently all clients; are assumed to be flow-insensitive). In addition to simple alias analysis; information, this class exposes Mod/Ref information from those implementations; which can provide it, allowing for powerful analyses and transformations to work; well together. This document contains information necessary to successfully implement this; interface, use it, and to test both sides. It also explains some of the finer; points about what exactly results mean. ``AliasAnalysis`` Class Overview; ================================. The `AliasAnalysis <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`__; class defines the interface that the various alias analysis implementations; should support. This class exports two important enums: ``AliasResult`` and; ``ModRefResult`` which represent the result of an alias query or a mod/ref; query, respectively. The ``AliasAnalysis`` interface exposes information about memory, represented in; several different ways. In particular, memory objects are represented as a; starting address and size, and function calls are represented as the actual; ``call`` or ``invoke`` instructions that performs the call. The; ``AliasAnalysis`` interface also exposes some helper methods which allow you to; get mod/ref information for arbitrary instructions. All ``AliasAnalysis`` interfa",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:1855,Integrability,interface,interface,1855,"assllvm_1_1AliasAnalysis.html>`__ class is the; primary interface used by clients and implementations of alias analyses in the; LLVM system. This class is the common interface between clients of alias; analysis information and the implementations providing it, and is designed to; support a wide range of implementations and clients (but currently all clients; are assumed to be flow-insensitive). In addition to simple alias analysis; information, this class exposes Mod/Ref information from those implementations; which can provide it, allowing for powerful analyses and transformations to work; well together. This document contains information necessary to successfully implement this; interface, use it, and to test both sides. It also explains some of the finer; points about what exactly results mean. ``AliasAnalysis`` Class Overview; ================================. The `AliasAnalysis <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`__; class defines the interface that the various alias analysis implementations; should support. This class exports two important enums: ``AliasResult`` and; ``ModRefResult`` which represent the result of an alias query or a mod/ref; query, respectively. The ``AliasAnalysis`` interface exposes information about memory, represented in; several different ways. In particular, memory objects are represented as a; starting address and size, and function calls are represented as the actual; ``call`` or ``invoke`` instructions that performs the call. The; ``AliasAnalysis`` interface also exposes some helper methods which allow you to; get mod/ref information for arbitrary instructions. All ``AliasAnalysis`` interfaces require that in queries involving multiple; values, values which are not :ref:`constants <constants>` are all; defined within the same function. Representation of Pointers; --------------------------. Most importantly, the ``AliasAnalysis`` class provides several methods which are; used to query whether or not two memory o",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:2110,Integrability,interface,interface,2110,"nd is designed to; support a wide range of implementations and clients (but currently all clients; are assumed to be flow-insensitive). In addition to simple alias analysis; information, this class exposes Mod/Ref information from those implementations; which can provide it, allowing for powerful analyses and transformations to work; well together. This document contains information necessary to successfully implement this; interface, use it, and to test both sides. It also explains some of the finer; points about what exactly results mean. ``AliasAnalysis`` Class Overview; ================================. The `AliasAnalysis <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`__; class defines the interface that the various alias analysis implementations; should support. This class exports two important enums: ``AliasResult`` and; ``ModRefResult`` which represent the result of an alias query or a mod/ref; query, respectively. The ``AliasAnalysis`` interface exposes information about memory, represented in; several different ways. In particular, memory objects are represented as a; starting address and size, and function calls are represented as the actual; ``call`` or ``invoke`` instructions that performs the call. The; ``AliasAnalysis`` interface also exposes some helper methods which allow you to; get mod/ref information for arbitrary instructions. All ``AliasAnalysis`` interfaces require that in queries involving multiple; values, values which are not :ref:`constants <constants>` are all; defined within the same function. Representation of Pointers; --------------------------. Most importantly, the ``AliasAnalysis`` class provides several methods which are; used to query whether or not two memory objects alias, whether function calls; can modify or read a memory object, etc. For all of these queries, memory; objects are represented as a pair of their starting address (a symbolic LLVM; ``Value*``) and a static size. Representing memory objects as a startin",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:2406,Integrability,interface,interface,2406,"transformations to work; well together. This document contains information necessary to successfully implement this; interface, use it, and to test both sides. It also explains some of the finer; points about what exactly results mean. ``AliasAnalysis`` Class Overview; ================================. The `AliasAnalysis <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`__; class defines the interface that the various alias analysis implementations; should support. This class exports two important enums: ``AliasResult`` and; ``ModRefResult`` which represent the result of an alias query or a mod/ref; query, respectively. The ``AliasAnalysis`` interface exposes information about memory, represented in; several different ways. In particular, memory objects are represented as a; starting address and size, and function calls are represented as the actual; ``call`` or ``invoke`` instructions that performs the call. The; ``AliasAnalysis`` interface also exposes some helper methods which allow you to; get mod/ref information for arbitrary instructions. All ``AliasAnalysis`` interfaces require that in queries involving multiple; values, values which are not :ref:`constants <constants>` are all; defined within the same function. Representation of Pointers; --------------------------. Most importantly, the ``AliasAnalysis`` class provides several methods which are; used to query whether or not two memory objects alias, whether function calls; can modify or read a memory object, etc. For all of these queries, memory; objects are represented as a pair of their starting address (a symbolic LLVM; ``Value*``) and a static size. Representing memory objects as a starting address and a size is critically; important for correct Alias Analyses. For example, consider this (silly, but; possible) C code:. .. code-block:: c++. int i;; char C[2];; char A[10];; /* ... */; for (i = 0; i != 10; ++i) {; C[0] = A[i]; /* One byte store */; C[1] = A[9-i]; /* One byte store */; }. In this c",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:2543,Integrability,interface,interfaces,2543,". It also explains some of the finer; points about what exactly results mean. ``AliasAnalysis`` Class Overview; ================================. The `AliasAnalysis <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`__; class defines the interface that the various alias analysis implementations; should support. This class exports two important enums: ``AliasResult`` and; ``ModRefResult`` which represent the result of an alias query or a mod/ref; query, respectively. The ``AliasAnalysis`` interface exposes information about memory, represented in; several different ways. In particular, memory objects are represented as a; starting address and size, and function calls are represented as the actual; ``call`` or ``invoke`` instructions that performs the call. The; ``AliasAnalysis`` interface also exposes some helper methods which allow you to; get mod/ref information for arbitrary instructions. All ``AliasAnalysis`` interfaces require that in queries involving multiple; values, values which are not :ref:`constants <constants>` are all; defined within the same function. Representation of Pointers; --------------------------. Most importantly, the ``AliasAnalysis`` class provides several methods which are; used to query whether or not two memory objects alias, whether function calls; can modify or read a memory object, etc. For all of these queries, memory; objects are represented as a pair of their starting address (a symbolic LLVM; ``Value*``) and a static size. Representing memory objects as a starting address and a size is critically; important for correct Alias Analyses. For example, consider this (silly, but; possible) C code:. .. code-block:: c++. int i;; char C[2];; char A[10];; /* ... */; for (i = 0; i != 10; ++i) {; C[0] = A[i]; /* One byte store */; C[1] = A[9-i]; /* One byte store */; }. In this case, the ``basic-aa`` pass will disambiguate the stores to ``C[0]`` and; ``C[1]`` because they are accesses to two distinct locations one byte apart, and; the",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:4316,Integrability,interface,interface,4316," for (i = 0; i != 10; ++i) {; C[0] = A[i]; /* One byte store */; C[1] = A[9-i]; /* One byte store */; }. In this case, the ``basic-aa`` pass will disambiguate the stores to ``C[0]`` and; ``C[1]`` because they are accesses to two distinct locations one byte apart, and; the accesses are each one byte. In this case, the Loop Invariant Code Motion; (LICM) pass can use store motion to remove the stores from the loop. In; contrast, the following code:. .. code-block:: c++. int i;; char C[2];; char A[10];; /* ... */; for (i = 0; i != 10; ++i) {; ((short*)C)[0] = A[i]; /* Two byte store! */; C[1] = A[9-i]; /* One byte store */; }. In this case, the two stores to C do alias each other, because the access to the; ``&C[0]`` element is a two byte access. If size information wasn't available in; the query, even the first case would have to conservatively assume that the; accesses alias. .. _alias:. The ``alias`` method; --------------------. The ``alias`` method is the primary interface used to determine whether or not; two memory objects alias each other. It takes two memory objects as input and; returns MustAlias, PartialAlias, MayAlias, or NoAlias as appropriate. Like all ``AliasAnalysis`` interfaces, the ``alias`` method requires that either; the two pointer values be defined within the same function, or at least one of; the values is a :ref:`constant <constants>`. .. _Must, May, or No:. Must, May, and No Alias Responses; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``NoAlias`` response may be used when there is never an immediate dependence; between any memory reference *based* on one pointer and any memory reference; *based* the other. The most obvious example is when the two pointers point to; non-overlapping memory ranges. Another is when the two pointers are only ever; used for reading memory. Another is when the memory is freed and reallocated; between accesses through one pointer and accesses through the other --- in this; case, there is a dependence, but it's mediated by th",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:4536,Integrability,interface,interfaces,4536,"ccesses are each one byte. In this case, the Loop Invariant Code Motion; (LICM) pass can use store motion to remove the stores from the loop. In; contrast, the following code:. .. code-block:: c++. int i;; char C[2];; char A[10];; /* ... */; for (i = 0; i != 10; ++i) {; ((short*)C)[0] = A[i]; /* Two byte store! */; C[1] = A[9-i]; /* One byte store */; }. In this case, the two stores to C do alias each other, because the access to the; ``&C[0]`` element is a two byte access. If size information wasn't available in; the query, even the first case would have to conservatively assume that the; accesses alias. .. _alias:. The ``alias`` method; --------------------. The ``alias`` method is the primary interface used to determine whether or not; two memory objects alias each other. It takes two memory objects as input and; returns MustAlias, PartialAlias, MayAlias, or NoAlias as appropriate. Like all ``AliasAnalysis`` interfaces, the ``alias`` method requires that either; the two pointer values be defined within the same function, or at least one of; the values is a :ref:`constant <constants>`. .. _Must, May, or No:. Must, May, and No Alias Responses; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``NoAlias`` response may be used when there is never an immediate dependence; between any memory reference *based* on one pointer and any memory reference; *based* the other. The most obvious example is when the two pointers point to; non-overlapping memory ranges. Another is when the two pointers are only ever; used for reading memory. Another is when the memory is freed and reallocated; between accesses through one pointer and accesses through the other --- in this; case, there is a dependence, but it's mediated by the free and reallocation. As an exception to this is with the :ref:`noalias <noalias>` keyword;; the ""irrelevant"" dependencies are ignored. The ``MayAlias`` response is used whenever the two pointers might refer to the; same object. The ``PartialAlias`` response is used when",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:4879,Integrability,depend,dependence,4879,"= A[i]; /* Two byte store! */; C[1] = A[9-i]; /* One byte store */; }. In this case, the two stores to C do alias each other, because the access to the; ``&C[0]`` element is a two byte access. If size information wasn't available in; the query, even the first case would have to conservatively assume that the; accesses alias. .. _alias:. The ``alias`` method; --------------------. The ``alias`` method is the primary interface used to determine whether or not; two memory objects alias each other. It takes two memory objects as input and; returns MustAlias, PartialAlias, MayAlias, or NoAlias as appropriate. Like all ``AliasAnalysis`` interfaces, the ``alias`` method requires that either; the two pointer values be defined within the same function, or at least one of; the values is a :ref:`constant <constants>`. .. _Must, May, or No:. Must, May, and No Alias Responses; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``NoAlias`` response may be used when there is never an immediate dependence; between any memory reference *based* on one pointer and any memory reference; *based* the other. The most obvious example is when the two pointers point to; non-overlapping memory ranges. Another is when the two pointers are only ever; used for reading memory. Another is when the memory is freed and reallocated; between accesses through one pointer and accesses through the other --- in this; case, there is a dependence, but it's mediated by the free and reallocation. As an exception to this is with the :ref:`noalias <noalias>` keyword;; the ""irrelevant"" dependencies are ignored. The ``MayAlias`` response is used whenever the two pointers might refer to the; same object. The ``PartialAlias`` response is used when the two memory objects are known to; be overlapping in some way, regardless whether they start at the same address; or not. The ``MustAlias`` response may only be returned if the two memory objects are; guaranteed to always start at exactly the same location. A ``MustAlias``; response",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:5303,Integrability,depend,dependence,5303,"; --------------------. The ``alias`` method is the primary interface used to determine whether or not; two memory objects alias each other. It takes two memory objects as input and; returns MustAlias, PartialAlias, MayAlias, or NoAlias as appropriate. Like all ``AliasAnalysis`` interfaces, the ``alias`` method requires that either; the two pointer values be defined within the same function, or at least one of; the values is a :ref:`constant <constants>`. .. _Must, May, or No:. Must, May, and No Alias Responses; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``NoAlias`` response may be used when there is never an immediate dependence; between any memory reference *based* on one pointer and any memory reference; *based* the other. The most obvious example is when the two pointers point to; non-overlapping memory ranges. Another is when the two pointers are only ever; used for reading memory. Another is when the memory is freed and reallocated; between accesses through one pointer and accesses through the other --- in this; case, there is a dependence, but it's mediated by the free and reallocation. As an exception to this is with the :ref:`noalias <noalias>` keyword;; the ""irrelevant"" dependencies are ignored. The ``MayAlias`` response is used whenever the two pointers might refer to the; same object. The ``PartialAlias`` response is used when the two memory objects are known to; be overlapping in some way, regardless whether they start at the same address; or not. The ``MustAlias`` response may only be returned if the two memory objects are; guaranteed to always start at exactly the same location. A ``MustAlias``; response does not imply that the pointers compare equal. The ``getModRefInfo`` methods; -----------------------------. The ``getModRefInfo`` methods return information about whether the execution of; an instruction can read or modify a memory location. Mod/Ref information is; always conservative: if an instruction **might** read or write a location,; ``ModRef`` is ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:5324,Integrability,mediat,mediated,5324,"; --------------------. The ``alias`` method is the primary interface used to determine whether or not; two memory objects alias each other. It takes two memory objects as input and; returns MustAlias, PartialAlias, MayAlias, or NoAlias as appropriate. Like all ``AliasAnalysis`` interfaces, the ``alias`` method requires that either; the two pointer values be defined within the same function, or at least one of; the values is a :ref:`constant <constants>`. .. _Must, May, or No:. Must, May, and No Alias Responses; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``NoAlias`` response may be used when there is never an immediate dependence; between any memory reference *based* on one pointer and any memory reference; *based* the other. The most obvious example is when the two pointers point to; non-overlapping memory ranges. Another is when the two pointers are only ever; used for reading memory. Another is when the memory is freed and reallocated; between accesses through one pointer and accesses through the other --- in this; case, there is a dependence, but it's mediated by the free and reallocation. As an exception to this is with the :ref:`noalias <noalias>` keyword;; the ""irrelevant"" dependencies are ignored. The ``MayAlias`` response is used whenever the two pointers might refer to the; same object. The ``PartialAlias`` response is used when the two memory objects are known to; be overlapping in some way, regardless whether they start at the same address; or not. The ``MustAlias`` response may only be returned if the two memory objects are; guaranteed to always start at exactly the same location. A ``MustAlias``; response does not imply that the pointers compare equal. The ``getModRefInfo`` methods; -----------------------------. The ``getModRefInfo`` methods return information about whether the execution of; an instruction can read or modify a memory location. Mod/Ref information is; always conservative: if an instruction **might** read or write a location,; ``ModRef`` is ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:5451,Integrability,depend,dependencies,5451,"jects as input and; returns MustAlias, PartialAlias, MayAlias, or NoAlias as appropriate. Like all ``AliasAnalysis`` interfaces, the ``alias`` method requires that either; the two pointer values be defined within the same function, or at least one of; the values is a :ref:`constant <constants>`. .. _Must, May, or No:. Must, May, and No Alias Responses; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``NoAlias`` response may be used when there is never an immediate dependence; between any memory reference *based* on one pointer and any memory reference; *based* the other. The most obvious example is when the two pointers point to; non-overlapping memory ranges. Another is when the two pointers are only ever; used for reading memory. Another is when the memory is freed and reallocated; between accesses through one pointer and accesses through the other --- in this; case, there is a dependence, but it's mediated by the free and reallocation. As an exception to this is with the :ref:`noalias <noalias>` keyword;; the ""irrelevant"" dependencies are ignored. The ``MayAlias`` response is used whenever the two pointers might refer to the; same object. The ``PartialAlias`` response is used when the two memory objects are known to; be overlapping in some way, regardless whether they start at the same address; or not. The ``MustAlias`` response may only be returned if the two memory objects are; guaranteed to always start at exactly the same location. A ``MustAlias``; response does not imply that the pointers compare equal. The ``getModRefInfo`` methods; -----------------------------. The ``getModRefInfo`` methods return information about whether the execution of; an instruction can read or modify a memory location. Mod/Ref information is; always conservative: if an instruction **might** read or write a location,; ``ModRef`` is returned. The ``AliasAnalysis`` class also provides a ``getModRefInfo`` method for testing; dependencies between function calls. This method takes two call sites ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:6349,Integrability,depend,dependencies,6349,"ediated by the free and reallocation. As an exception to this is with the :ref:`noalias <noalias>` keyword;; the ""irrelevant"" dependencies are ignored. The ``MayAlias`` response is used whenever the two pointers might refer to the; same object. The ``PartialAlias`` response is used when the two memory objects are known to; be overlapping in some way, regardless whether they start at the same address; or not. The ``MustAlias`` response may only be returned if the two memory objects are; guaranteed to always start at exactly the same location. A ``MustAlias``; response does not imply that the pointers compare equal. The ``getModRefInfo`` methods; -----------------------------. The ``getModRefInfo`` methods return information about whether the execution of; an instruction can read or modify a memory location. Mod/Ref information is; always conservative: if an instruction **might** read or write a location,; ``ModRef`` is returned. The ``AliasAnalysis`` class also provides a ``getModRefInfo`` method for testing; dependencies between function calls. This method takes two call sites (``CS1``; & ``CS2``), returns ``NoModRef`` if neither call writes to memory read or; written by the other, ``Ref`` if ``CS1`` reads memory written by ``CS2``,; ``Mod`` if ``CS1`` writes to memory read or written by ``CS2``, or ``ModRef`` if; ``CS1`` might read or write memory written to by ``CS2``. Note that this; relation is not commutative. Other useful ``AliasAnalysis`` methods; --------------------------------------. Several other tidbits of information are often collected by various alias; analysis implementations and can be put to good use by various clients. The ``getModRefInfoMask`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``getModRefInfoMask`` method returns a bound on Mod/Ref information for; the supplied pointer, based on knowledge about whether the pointer points to; globally-constant memory (for which it returns ``NoModRef``) or; locally-invariant memory (for which it returns ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:8661,Integrability,depend,depend,8661,"he corresponding function call. Given Mod/Ref information; ``MRI`` for a memory location ``Loc``, ``MRI`` can be refined with a statement; like ``MRI &= AA.getModRefInfoMask(Loc);``. Another useful idiom is; ``isModSet(AA.getModRefInfoMask(Loc))``; this checks to see if the given; location can be modified at all. For convenience, there is also a method; ``pointsToConstantMemory(Loc)``; this is synonymous with; ``isNoModRef(AA.getModRefInfoMask(Loc))``. .. _never access memory or only read memory:. The ``doesNotAccessMemory`` and ``onlyReadsMemory`` methods; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. These methods are used to provide very simple mod/ref information for function; calls. The ``doesNotAccessMemory`` method returns true for a function if the; analysis can prove that the function never reads or writes to memory, or if the; function only reads from constant memory. Functions with this property are; side-effect free and only depend on their input arguments, allowing them to be; eliminated if they form common subexpressions or be hoisted out of loops. Many; common functions behave this way (e.g., ``sin`` and ``cos``) but many others do; not (e.g., ``acos``, which modifies the ``errno`` variable). The ``onlyReadsMemory`` method returns true for a function if analysis can prove; that (at most) the function only reads from non-volatile memory. Functions with; this property are side-effect free, only depending on their input arguments and; the state of memory when they are called. This property allows calls to these; functions to be eliminated and moved around, as long as there is no store; instruction that changes the contents of memory. Note that all functions that; satisfy the ``doesNotAccessMemory`` method also satisfy ``onlyReadsMemory``. Writing a new ``AliasAnalysis`` Implementation; ==============================================. Writing a new alias analysis implementation for LLVM is quite straight-forward.; There are already several ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:9141,Integrability,depend,depending,9141,". _never access memory or only read memory:. The ``doesNotAccessMemory`` and ``onlyReadsMemory`` methods; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. These methods are used to provide very simple mod/ref information for function; calls. The ``doesNotAccessMemory`` method returns true for a function if the; analysis can prove that the function never reads or writes to memory, or if the; function only reads from constant memory. Functions with this property are; side-effect free and only depend on their input arguments, allowing them to be; eliminated if they form common subexpressions or be hoisted out of loops. Many; common functions behave this way (e.g., ``sin`` and ``cos``) but many others do; not (e.g., ``acos``, which modifies the ``errno`` variable). The ``onlyReadsMemory`` method returns true for a function if analysis can prove; that (at most) the function only reads from non-volatile memory. Functions with; this property are side-effect free, only depending on their input arguments and; the state of memory when they are called. This property allows calls to these; functions to be eliminated and moved around, as long as there is no store; instruction that changes the contents of memory. Note that all functions that; satisfy the ``doesNotAccessMemory`` method also satisfy ``onlyReadsMemory``. Writing a new ``AliasAnalysis`` Implementation; ==============================================. Writing a new alias analysis implementation for LLVM is quite straight-forward.; There are already several implementations that you can use for examples, and the; following information should help fill in any details. For examples, take a; look at the `various alias analysis implementations`_ included with LLVM. Different Pass styles; ---------------------. The first step to determining what type of :doc:`LLVM pass <WritingAnLLVMPass>`; you need to use for your Alias Analysis. As is the case with most other; analyses and transformations, the answer should be f",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:10534,Integrability,interface,interface,10534,"=====================================. Writing a new alias analysis implementation for LLVM is quite straight-forward.; There are already several implementations that you can use for examples, and the; following information should help fill in any details. For examples, take a; look at the `various alias analysis implementations`_ included with LLVM. Different Pass styles; ---------------------. The first step to determining what type of :doc:`LLVM pass <WritingAnLLVMPass>`; you need to use for your Alias Analysis. As is the case with most other; analyses and transformations, the answer should be fairly obvious from what type; of problem you are trying to solve:. #. If you require interprocedural analysis, it should be a ``Pass``.; #. If you are a function-local analysis, subclass ``FunctionPass``.; #. If you don't need to look at the program at all, subclass ``ImmutablePass``. In addition to the pass that you subclass, you should also inherit from the; ``AliasAnalysis`` interface, of course, and use the ``RegisterAnalysisGroup``; template to register as an implementation of ``AliasAnalysis``. Required initialization calls; -----------------------------. Your subclass of ``AliasAnalysis`` is required to invoke two methods on the; ``AliasAnalysis`` base class: ``getAnalysisUsage`` and; ``InitializeAliasAnalysis``. In particular, your implementation of; ``getAnalysisUsage`` should explicitly call into the; ``AliasAnalysis::getAnalysisUsage`` method in addition to doing any declaring; any pass dependencies your pass has. Thus you should have something like this:. .. code-block:: c++. void getAnalysisUsage(AnalysisUsage &AU) const {; AliasAnalysis::getAnalysisUsage(AU);; // declare your dependencies here.; }. Additionally, your must invoke the ``InitializeAliasAnalysis`` method from your; analysis run method (``run`` for a ``Pass``, ``runOnFunction`` for a; ``FunctionPass``, or ``InitializePass`` for an ``ImmutablePass``). For example; (as part of a ``Pass``):. .. code-",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:11064,Integrability,depend,dependencies,11064," of :doc:`LLVM pass <WritingAnLLVMPass>`; you need to use for your Alias Analysis. As is the case with most other; analyses and transformations, the answer should be fairly obvious from what type; of problem you are trying to solve:. #. If you require interprocedural analysis, it should be a ``Pass``.; #. If you are a function-local analysis, subclass ``FunctionPass``.; #. If you don't need to look at the program at all, subclass ``ImmutablePass``. In addition to the pass that you subclass, you should also inherit from the; ``AliasAnalysis`` interface, of course, and use the ``RegisterAnalysisGroup``; template to register as an implementation of ``AliasAnalysis``. Required initialization calls; -----------------------------. Your subclass of ``AliasAnalysis`` is required to invoke two methods on the; ``AliasAnalysis`` base class: ``getAnalysisUsage`` and; ``InitializeAliasAnalysis``. In particular, your implementation of; ``getAnalysisUsage`` should explicitly call into the; ``AliasAnalysis::getAnalysisUsage`` method in addition to doing any declaring; any pass dependencies your pass has. Thus you should have something like this:. .. code-block:: c++. void getAnalysisUsage(AnalysisUsage &AU) const {; AliasAnalysis::getAnalysisUsage(AU);; // declare your dependencies here.; }. Additionally, your must invoke the ``InitializeAliasAnalysis`` method from your; analysis run method (``run`` for a ``Pass``, ``runOnFunction`` for a; ``FunctionPass``, or ``InitializePass`` for an ``ImmutablePass``). For example; (as part of a ``Pass``):. .. code-block:: c++. bool run(Module &M) {; InitializeAliasAnalysis(this);; // Perform analysis here...; return false;; }. Required methods to override; ----------------------------. You must override the ``getAdjustedAnalysisPointer`` method on all subclasses; of ``AliasAnalysis``. An example implementation of this method would look like:. .. code-block:: c++. void *getAdjustedAnalysisPointer(const void* ID) override {; if (ID == &AliasAnalys",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:11260,Integrability,depend,dependencies,11260,"e:. #. If you require interprocedural analysis, it should be a ``Pass``.; #. If you are a function-local analysis, subclass ``FunctionPass``.; #. If you don't need to look at the program at all, subclass ``ImmutablePass``. In addition to the pass that you subclass, you should also inherit from the; ``AliasAnalysis`` interface, of course, and use the ``RegisterAnalysisGroup``; template to register as an implementation of ``AliasAnalysis``. Required initialization calls; -----------------------------. Your subclass of ``AliasAnalysis`` is required to invoke two methods on the; ``AliasAnalysis`` base class: ``getAnalysisUsage`` and; ``InitializeAliasAnalysis``. In particular, your implementation of; ``getAnalysisUsage`` should explicitly call into the; ``AliasAnalysis::getAnalysisUsage`` method in addition to doing any declaring; any pass dependencies your pass has. Thus you should have something like this:. .. code-block:: c++. void getAnalysisUsage(AnalysisUsage &AU) const {; AliasAnalysis::getAnalysisUsage(AU);; // declare your dependencies here.; }. Additionally, your must invoke the ``InitializeAliasAnalysis`` method from your; analysis run method (``run`` for a ``Pass``, ``runOnFunction`` for a; ``FunctionPass``, or ``InitializePass`` for an ``ImmutablePass``). For example; (as part of a ``Pass``):. .. code-block:: c++. bool run(Module &M) {; InitializeAliasAnalysis(this);; // Perform analysis here...; return false;; }. Required methods to override; ----------------------------. You must override the ``getAdjustedAnalysisPointer`` method on all subclasses; of ``AliasAnalysis``. An example implementation of this method would look like:. .. code-block:: c++. void *getAdjustedAnalysisPointer(const void* ID) override {; if (ID == &AliasAnalysis::ID); return (AliasAnalysis*)this;; return this;; }. Interfaces which may be specified; ---------------------------------. All of the `AliasAnalysis; <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`__ virtual methods",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:12558,Integrability,interface,interfaces,12558," a ``Pass``):. .. code-block:: c++. bool run(Module &M) {; InitializeAliasAnalysis(this);; // Perform analysis here...; return false;; }. Required methods to override; ----------------------------. You must override the ``getAdjustedAnalysisPointer`` method on all subclasses; of ``AliasAnalysis``. An example implementation of this method would look like:. .. code-block:: c++. void *getAdjustedAnalysisPointer(const void* ID) override {; if (ID == &AliasAnalysis::ID); return (AliasAnalysis*)this;; return this;; }. Interfaces which may be specified; ---------------------------------. All of the `AliasAnalysis; <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`__ virtual methods; default to providing :ref:`chaining <aliasanalysis-chaining>` to another alias; analysis implementation, which ends up returning conservatively correct; information (returning ""May"" Alias and ""Mod/Ref"" for alias and mod/ref queries; respectively). Depending on the capabilities of the analysis you are; implementing, you just override the interfaces you can improve. .. _aliasanalysis-chaining:. ``AliasAnalysis`` chaining behavior; -----------------------------------. Every alias analysis pass chains to another alias analysis implementation (for; example, the user can specify ""``-basic-aa -ds-aa -licm``"" to get the maximum; benefit from both alias analyses). The alias analysis class automatically; takes care of most of this for methods that you don't override. For methods; that you do override, in code paths that return a conservative MayAlias or; Mod/Ref result, simply return whatever the superclass computes. For example:. .. code-block:: c++. AliasResult alias(const Value *V1, unsigned V1Size,; const Value *V2, unsigned V2Size) {; if (...); return NoAlias;; ... // Couldn't determine a must or no-alias result.; return AliasAnalysis::alias(V1, V1Size, V2, V2Size);; }. In addition to analysis queries, you must make sure to unconditionally pass LLVM; `update notification`_ methods to the sup",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:14083,Integrability,interface,interface,14083,"tes. For example:. .. code-block:: c++. AliasResult alias(const Value *V1, unsigned V1Size,; const Value *V2, unsigned V2Size) {; if (...); return NoAlias;; ... // Couldn't determine a must or no-alias result.; return AliasAnalysis::alias(V1, V1Size, V2, V2Size);; }. In addition to analysis queries, you must make sure to unconditionally pass LLVM; `update notification`_ methods to the superclass as well if you override them,; which allows all alias analyses in a change to be updated. .. _update notification:. Updating analysis results for transformations; ---------------------------------------------. Alias analysis information is initially computed for a static snapshot of the; program, but clients will use this information to make transformations to the; code. All but the most trivial forms of alias analysis will need to have their; analysis results updated to reflect the changes made by these transformations. The ``AliasAnalysis`` interface exposes four methods which are used to; communicate program changes from the clients to the analysis implementations.; Various alias analysis implementations should use these methods to ensure that; their internal data structures are kept up-to-date as the program changes (for; example, when an instruction is deleted), and clients of alias analysis must be; sure to call these interfaces appropriately. The ``deleteValue`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``deleteValue`` method is called by transformations when they remove an; instruction or any other value from the program (including values that do not; use pointers). Typically alias analyses keep data structures that have entries; for each value in the program. When this method is called, they should remove; any entries for the specified value, if they exist. The ``copyValue`` method; ^^^^^^^^^^^^^^^^^^^^^^^^. The ``copyValue`` method is used when a new value is introduced into the; program. There is no way to introduce a value into the program that did not; exist befor",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:14472,Integrability,interface,interfaces,14472,"AliasAnalysis::alias(V1, V1Size, V2, V2Size);; }. In addition to analysis queries, you must make sure to unconditionally pass LLVM; `update notification`_ methods to the superclass as well if you override them,; which allows all alias analyses in a change to be updated. .. _update notification:. Updating analysis results for transformations; ---------------------------------------------. Alias analysis information is initially computed for a static snapshot of the; program, but clients will use this information to make transformations to the; code. All but the most trivial forms of alias analysis will need to have their; analysis results updated to reflect the changes made by these transformations. The ``AliasAnalysis`` interface exposes four methods which are used to; communicate program changes from the clients to the analysis implementations.; Various alias analysis implementations should use these methods to ensure that; their internal data structures are kept up-to-date as the program changes (for; example, when an instruction is deleted), and clients of alias analysis must be; sure to call these interfaces appropriately. The ``deleteValue`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``deleteValue`` method is called by transformations when they remove an; instruction or any other value from the program (including values that do not; use pointers). Typically alias analyses keep data structures that have entries; for each value in the program. When this method is called, they should remove; any entries for the specified value, if they exist. The ``copyValue`` method; ^^^^^^^^^^^^^^^^^^^^^^^^. The ``copyValue`` method is used when a new value is introduced into the; program. There is no way to introduce a value into the program that did not; exist before (this doesn't make sense for a safe compiler transformation), so; this is the only way to introduce a new value. This method indicates that the; new value has exactly the same properties as the value being copied. The",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:17549,Integrability,interface,interface,17549,"al calculation of the alias analysis results (the ""run""; method) is only performed once, but many (perhaps duplicate) queries may be; performed. Because of this, try to move as much computation to the run method; as possible (within reason). Limitations; -----------. The AliasAnalysis infrastructure has several limitations which make writing a; new ``AliasAnalysis`` implementation difficult. There is no way to override the default alias analysis. It would be very useful; to be able to do something like ""``opt -my-aa -O2``"" and have it use ``-my-aa``; for all passes which need AliasAnalysis, but there is currently no support for; that, short of changing the source code and recompiling. Similarly, there is; also no way of setting a chain of analyses as the default. There is no way for transform passes to declare that they preserve; ``AliasAnalysis`` implementations. The ``AliasAnalysis`` interface includes; ``deleteValue`` and ``copyValue`` methods which are intended to allow a pass to; keep an AliasAnalysis consistent, however there's no way for a pass to declare; in its ``getAnalysisUsage`` that it does so. Some passes attempt to use; ``AU.addPreserved<AliasAnalysis>``, however this doesn't actually have any; effect. Similarly, the ``opt -p`` option introduces ``ModulePass`` passes between each; pass, which prevents the use of ``FunctionPass`` alias analysis passes. The ``AliasAnalysis`` API does have functions for notifying implementations when; values are deleted or copied, however these aren't sufficient. There are many; other ways that LLVM IR can be modified which could be relevant to; ``AliasAnalysis`` implementations which can not be expressed. The ``AliasAnalysisDebugger`` utility seems to suggest that ``AliasAnalysis``; implementations can expect that they will be informed of any relevant ``Value``; before it appears in an alias query. However, popular clients such as ``GVN``; don't support this, and are known to trigger errors when run with the; ``AliasAna",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:19571,Integrability,depend,dependence,19571,"; don't support this, and are known to trigger errors when run with the; ``AliasAnalysisDebugger``. The ``AliasSetTracker`` class (which is used by ``LICM``) makes a; non-deterministic number of alias queries. This can cause debugging techniques; involving pausing execution after a predetermined number of queries to be; unreliable. Many alias queries can be reformulated in terms of other alias queries. When; multiple ``AliasAnalysis`` queries are chained together, it would make sense to; start those queries from the beginning of the chain, with care taken to avoid; infinite looping, however currently an implementation which wants to do this can; only start such queries from itself. Using alias analysis results; ============================. There are several different ways to use alias analysis results. In order of; preference, these are:. Using the ``MemoryDependenceAnalysis`` Pass; -------------------------------------------. The ``memdep`` pass uses alias analysis to provide high-level dependence; information about memory-using instructions. This will tell you which store; feeds into a load, for example. It uses caching and other techniques to be; efficient, and is used by Dead Store Elimination, GVN, and memcpy optimizations. .. _AliasSetTracker:. Using the ``AliasSetTracker`` class; -----------------------------------. Many transformations need information about alias **sets** that are active in; some scope, rather than information about pairwise aliasing. The; `AliasSetTracker <https://llvm.org/doxygen/classllvm_1_1AliasSetTracker.html>`__; class is used to efficiently build these Alias Sets from the pairwise alias; analysis information provided by the ``AliasAnalysis`` interface. First you initialize the AliasSetTracker by using the ""``add``"" methods to add; information about various potentially aliasing instructions in the scope you are; interested in. Once all of the alias sets are completed, your pass should; simply iterate through the constructed alias set",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:20272,Integrability,interface,interface,20272,"o do this can; only start such queries from itself. Using alias analysis results; ============================. There are several different ways to use alias analysis results. In order of; preference, these are:. Using the ``MemoryDependenceAnalysis`` Pass; -------------------------------------------. The ``memdep`` pass uses alias analysis to provide high-level dependence; information about memory-using instructions. This will tell you which store; feeds into a load, for example. It uses caching and other techniques to be; efficient, and is used by Dead Store Elimination, GVN, and memcpy optimizations. .. _AliasSetTracker:. Using the ``AliasSetTracker`` class; -----------------------------------. Many transformations need information about alias **sets** that are active in; some scope, rather than information about pairwise aliasing. The; `AliasSetTracker <https://llvm.org/doxygen/classllvm_1_1AliasSetTracker.html>`__; class is used to efficiently build these Alias Sets from the pairwise alias; analysis information provided by the ``AliasAnalysis`` interface. First you initialize the AliasSetTracker by using the ""``add``"" methods to add; information about various potentially aliasing instructions in the scope you are; interested in. Once all of the alias sets are completed, your pass should; simply iterate through the constructed alias sets, using the ``AliasSetTracker``; ``begin()``/``end()`` methods. The ``AliasSet``\s formed by the ``AliasSetTracker`` are guaranteed to be; disjoint, calculate mod/ref information and volatility for the set, and keep; track of whether or not all of the pointers in the set are Must aliases. The; AliasSetTracker also makes sure that sets are properly folded due to call; instructions, and can provide a list of pointers in each set. As an example user of this, the `Loop Invariant Code Motion; <doxygen/structLICM.html>`_ pass uses ``AliasSetTracker``\s to calculate alias; sets for each loop nest. If an ``AliasSet`` in a loop is not mod",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:22605,Integrability,interface,interface,22605,"^^^^^^^^^^^^^. The AliasSetTracker class is implemented to be as efficient as possible. It; uses the union-find algorithm to efficiently merge AliasSets when a pointer is; inserted into the AliasSetTracker that aliases multiple sets. The primary data; structure is a hash table mapping pointers to the AliasSet they are in. The AliasSetTracker class must maintain a list of all of the LLVM ``Value*``\s; that are in each AliasSet. Since the hash table already has entries for each; LLVM ``Value*`` of interest, the AliasesSets thread the linked list through; these hash-table nodes to avoid having to allocate memory unnecessarily, and to; make merging alias sets extremely efficient (the linked list merge is constant; time). You shouldn't need to understand these details if you are just a client of the; AliasSetTracker, but if you look at the code, hopefully this brief description; will help make sense of why things are designed the way they are. Using the ``AliasAnalysis`` interface directly; ----------------------------------------------. If neither of these utility class are what your pass needs, you should use the; interfaces exposed by the ``AliasAnalysis`` class directly. Try to use the; higher-level methods when possible (e.g., use mod/ref information instead of the; `alias`_ method directly if possible) to get the best precision and efficiency. Existing alias analysis implementations and clients; ===================================================. If you're going to be working with the LLVM alias analysis infrastructure, you; should know what clients and implementations of alias analysis are available.; In particular, if you are implementing an alias analysis, you should be aware of; the `the clients`_ that are useful for monitoring and evaluating different; implementations. .. _various alias analysis implementations:. Available ``AliasAnalysis`` implementations; -------------------------------------------. This section lists the various implementations of the ``Al",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:22753,Integrability,interface,interfaces,22753,"thm to efficiently merge AliasSets when a pointer is; inserted into the AliasSetTracker that aliases multiple sets. The primary data; structure is a hash table mapping pointers to the AliasSet they are in. The AliasSetTracker class must maintain a list of all of the LLVM ``Value*``\s; that are in each AliasSet. Since the hash table already has entries for each; LLVM ``Value*`` of interest, the AliasesSets thread the linked list through; these hash-table nodes to avoid having to allocate memory unnecessarily, and to; make merging alias sets extremely efficient (the linked list merge is constant; time). You shouldn't need to understand these details if you are just a client of the; AliasSetTracker, but if you look at the code, hopefully this brief description; will help make sense of why things are designed the way they are. Using the ``AliasAnalysis`` interface directly; ----------------------------------------------. If neither of these utility class are what your pass needs, you should use the; interfaces exposed by the ``AliasAnalysis`` class directly. Try to use the; higher-level methods when possible (e.g., use mod/ref information instead of the; `alias`_ method directly if possible) to get the best precision and efficiency. Existing alias analysis implementations and clients; ===================================================. If you're going to be working with the LLVM alias analysis infrastructure, you; should know what clients and implementations of alias analysis are available.; In particular, if you are implementing an alias analysis, you should be aware of; the `the clients`_ that are useful for monitoring and evaluating different; implementations. .. _various alias analysis implementations:. Available ``AliasAnalysis`` implementations; -------------------------------------------. This section lists the various implementations of the ``AliasAnalysis``; interface. All of these :ref:`chain <aliasanalysis-chaining>` to other; alias analysis implementations.",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:23639,Integrability,interface,interface,23639,"terface directly; ----------------------------------------------. If neither of these utility class are what your pass needs, you should use the; interfaces exposed by the ``AliasAnalysis`` class directly. Try to use the; higher-level methods when possible (e.g., use mod/ref information instead of the; `alias`_ method directly if possible) to get the best precision and efficiency. Existing alias analysis implementations and clients; ===================================================. If you're going to be working with the LLVM alias analysis infrastructure, you; should know what clients and implementations of alias analysis are available.; In particular, if you are implementing an alias analysis, you should be aware of; the `the clients`_ that are useful for monitoring and evaluating different; implementations. .. _various alias analysis implementations:. Available ``AliasAnalysis`` implementations; -------------------------------------------. This section lists the various implementations of the ``AliasAnalysis``; interface. All of these :ref:`chain <aliasanalysis-chaining>` to other; alias analysis implementations. The ``-basic-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^^. The ``-basic-aa`` pass is an aggressive local analysis that *knows* many; important facts:. * Distinct globals, stack allocations, and heap allocations can never alias.; * Globals, stack allocations, and heap allocations never alias the null pointer.; * Different fields of a structure do not alias.; * Indexes into arrays with statically differing subscripts cannot alias.; * Many common standard C library functions `never access memory or only read; memory`_.; * Pointers that obviously point to constant globals ""``pointToConstantMemory``"".; * Function calls can not modify or references stack allocations if they never; escape from the function that allocates them (a common case for automatic; arrays). The ``-globalsmodref-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This pass implements a simple context-sensi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:27425,Integrability,interface,interface,27425,"lable, usually at ``O(n * log(n))``. This algorithm is capable of responding to a full variety of alias analysis; queries, and can provide context-sensitive mod/ref information as well. The; only major facility not implemented so far is support for must-alias; information. .. note::. ``-ds-aa`` is available in the optional ""poolalloc"" module. It is not part of; the LLVM core. The ``-scev-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^. The ``-scev-aa`` pass implements AliasAnalysis queries by translating them into; ScalarEvolution queries. This gives it a more complete understanding of; ``getelementptr`` instructions and loop induction variables than other alias; analyses have. Alias analysis driven transformations; -------------------------------------. LLVM includes several alias-analysis driven transformations which can be used; with any of the implementations above. The ``-adce`` pass; ^^^^^^^^^^^^^^^^^^. The ``-adce`` pass, which implements Aggressive Dead Code Elimination uses the; ``AliasAnalysis`` interface to delete calls to functions that do not have; side-effects and are not used. The ``-licm`` pass; ^^^^^^^^^^^^^^^^^^. The ``-licm`` pass implements various Loop Invariant Code Motion related; transformations. It uses the ``AliasAnalysis`` interface for several different; transformations:. * It uses mod/ref information to hoist or sink load instructions out of loops if; there are no instructions in the loop that modifies the memory loaded. * It uses mod/ref information to hoist function calls out of loops that do not; write to memory and are loop-invariant. * It uses alias information to promote memory objects that are loaded and stored; to in loops to live in a register instead. It can do this if there are no may; aliases to the loaded/stored memory location. The ``-argpromotion`` pass; ^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``-argpromotion`` pass promotes by-reference arguments to be passed in; by-value instead. In particular, if pointer arguments are only loaded from it; pas",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:27674,Integrability,interface,interface,27674,"ormation. .. note::. ``-ds-aa`` is available in the optional ""poolalloc"" module. It is not part of; the LLVM core. The ``-scev-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^. The ``-scev-aa`` pass implements AliasAnalysis queries by translating them into; ScalarEvolution queries. This gives it a more complete understanding of; ``getelementptr`` instructions and loop induction variables than other alias; analyses have. Alias analysis driven transformations; -------------------------------------. LLVM includes several alias-analysis driven transformations which can be used; with any of the implementations above. The ``-adce`` pass; ^^^^^^^^^^^^^^^^^^. The ``-adce`` pass, which implements Aggressive Dead Code Elimination uses the; ``AliasAnalysis`` interface to delete calls to functions that do not have; side-effects and are not used. The ``-licm`` pass; ^^^^^^^^^^^^^^^^^^. The ``-licm`` pass implements various Loop Invariant Code Motion related; transformations. It uses the ``AliasAnalysis`` interface for several different; transformations:. * It uses mod/ref information to hoist or sink load instructions out of loops if; there are no instructions in the loop that modifies the memory loaded. * It uses mod/ref information to hoist function calls out of loops that do not; write to memory and are loop-invariant. * It uses alias information to promote memory objects that are loaded and stored; to in loops to live in a register instead. It can do this if there are no may; aliases to the loaded/stored memory location. The ``-argpromotion`` pass; ^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``-argpromotion`` pass promotes by-reference arguments to be passed in; by-value instead. In particular, if pointer arguments are only loaded from it; passes in the value loaded instead of the address to the function. This pass; uses alias information to make sure that the value loaded from the argument; pointer is not modified between the entry of the function and any load of the; pointer. The ``-gvn``, ``-memcpyop",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:30261,Integrability,interface,interface,30261,"ction and any load of the; pointer. The ``-gvn``, ``-memcpyopt``, and ``-dse`` passes; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. These passes use AliasAnalysis information to reason about loads and stores. .. _the clients:. Clients for debugging and evaluation of implementations; -------------------------------------------------------. These passes are useful for evaluating the various alias analysis; implementations. You can use them with commands like:. .. code-block:: bash. % opt -ds-aa -aa-eval foo.bc -disable-output -stats. The ``-print-alias-sets`` pass; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``-print-alias-sets`` pass is exposed as part of the ``opt`` tool to print; out the Alias Sets formed by the `AliasSetTracker`_ class. This is useful if; you're using the ``AliasSetTracker`` class. To use it, use something like:. .. code-block:: bash. % opt -ds-aa -print-alias-sets -disable-output. The ``-aa-eval`` pass; ^^^^^^^^^^^^^^^^^^^^^. The ``-aa-eval`` pass simply iterates through all pairs of pointers in a; function and asks an alias analysis whether or not the pointers alias. This; gives an indication of the precision of the alias analysis. Statistics are; printed indicating the percent of no/may/must aliases found (a more precise; algorithm will have a lower number of may aliases). Memory Dependence Analysis; ==========================. .. note::. We are currently in the process of migrating things from; ``MemoryDependenceAnalysis`` to :doc:`MemorySSA`. Please try to use; that instead. If you're just looking to be a client of alias analysis information, consider; using the Memory Dependence Analysis interface instead. MemDep is a lazy,; caching layer on top of alias analysis that is able to answer the question of; what preceding memory operations a given instruction depends on, either at an; intra- or inter-block level. Because of its laziness and caching policy, using; MemDep can be a significant performance win over accessing alias analysis; directly.; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:30431,Integrability,depend,depends,30431,"ction and any load of the; pointer. The ``-gvn``, ``-memcpyopt``, and ``-dse`` passes; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. These passes use AliasAnalysis information to reason about loads and stores. .. _the clients:. Clients for debugging and evaluation of implementations; -------------------------------------------------------. These passes are useful for evaluating the various alias analysis; implementations. You can use them with commands like:. .. code-block:: bash. % opt -ds-aa -aa-eval foo.bc -disable-output -stats. The ``-print-alias-sets`` pass; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``-print-alias-sets`` pass is exposed as part of the ``opt`` tool to print; out the Alias Sets formed by the `AliasSetTracker`_ class. This is useful if; you're using the ``AliasSetTracker`` class. To use it, use something like:. .. code-block:: bash. % opt -ds-aa -print-alias-sets -disable-output. The ``-aa-eval`` pass; ^^^^^^^^^^^^^^^^^^^^^. The ``-aa-eval`` pass simply iterates through all pairs of pointers in a; function and asks an alias analysis whether or not the pointers alias. This; gives an indication of the precision of the alias analysis. Statistics are; printed indicating the percent of no/may/must aliases found (a more precise; algorithm will have a lower number of may aliases). Memory Dependence Analysis; ==========================. .. note::. We are currently in the process of migrating things from; ``MemoryDependenceAnalysis`` to :doc:`MemorySSA`. Please try to use; that instead. If you're just looking to be a client of alias analysis information, consider; using the Memory Dependence Analysis interface instead. MemDep is a lazy,; caching layer on top of alias analysis that is able to answer the question of; what preceding memory operations a given instruction depends on, either at an; intra- or inter-block level. Because of its laziness and caching policy, using; MemDep can be a significant performance win over accessing alias analysis; directly.; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:7398,Modifiability,variab,variables,7398,"ls. This method takes two call sites (``CS1``; & ``CS2``), returns ``NoModRef`` if neither call writes to memory read or; written by the other, ``Ref`` if ``CS1`` reads memory written by ``CS2``,; ``Mod`` if ``CS1`` writes to memory read or written by ``CS2``, or ``ModRef`` if; ``CS1`` might read or write memory written to by ``CS2``. Note that this; relation is not commutative. Other useful ``AliasAnalysis`` methods; --------------------------------------. Several other tidbits of information are often collected by various alias; analysis implementations and can be put to good use by various clients. The ``getModRefInfoMask`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``getModRefInfoMask`` method returns a bound on Mod/Ref information for; the supplied pointer, based on knowledge about whether the pointer points to; globally-constant memory (for which it returns ``NoModRef``) or; locally-invariant memory (for which it returns ``Ref``). Globally-constant; memory includes functions, constant global variables, and the null pointer.; Locally-invariant memory is memory that we know is invariant for the lifetime; of its SSA value, but not necessarily for the life of the program: for example,; the memory pointed to by ``readonly`` ``noalias`` parameters is known-invariant; for the duration of the corresponding function call. Given Mod/Ref information; ``MRI`` for a memory location ``Loc``, ``MRI`` can be refined with a statement; like ``MRI &= AA.getModRefInfoMask(Loc);``. Another useful idiom is; ``isModSet(AA.getModRefInfoMask(Loc))``; this checks to see if the given; location can be modified at all. For convenience, there is also a method; ``pointsToConstantMemory(Loc)``; this is synonymous with; ``isNoModRef(AA.getModRefInfoMask(Loc))``. .. _never access memory or only read memory:. The ``doesNotAccessMemory`` and ``onlyReadsMemory`` methods; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. These methods are used to provide very simple mod/ref informati",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:8926,Modifiability,variab,variable,8926,"et(AA.getModRefInfoMask(Loc))``; this checks to see if the given; location can be modified at all. For convenience, there is also a method; ``pointsToConstantMemory(Loc)``; this is synonymous with; ``isNoModRef(AA.getModRefInfoMask(Loc))``. .. _never access memory or only read memory:. The ``doesNotAccessMemory`` and ``onlyReadsMemory`` methods; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. These methods are used to provide very simple mod/ref information for function; calls. The ``doesNotAccessMemory`` method returns true for a function if the; analysis can prove that the function never reads or writes to memory, or if the; function only reads from constant memory. Functions with this property are; side-effect free and only depend on their input arguments, allowing them to be; eliminated if they form common subexpressions or be hoisted out of loops. Many; common functions behave this way (e.g., ``sin`` and ``cos``) but many others do; not (e.g., ``acos``, which modifies the ``errno`` variable). The ``onlyReadsMemory`` method returns true for a function if analysis can prove; that (at most) the function only reads from non-volatile memory. Functions with; this property are side-effect free, only depending on their input arguments and; the state of memory when they are called. This property allows calls to these; functions to be eliminated and moved around, as long as there is no store; instruction that changes the contents of memory. Note that all functions that; satisfy the ``doesNotAccessMemory`` method also satisfy ``onlyReadsMemory``. Writing a new ``AliasAnalysis`` Implementation; ==============================================. Writing a new alias analysis implementation for LLVM is quite straight-forward.; There are already several implementations that you can use for examples, and the; following information should help fill in any details. For examples, take a; look at the `various alias analysis implementations`_ included with LLVM. Different ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:10498,Modifiability,inherit,inherit,10498,"=====================================. Writing a new alias analysis implementation for LLVM is quite straight-forward.; There are already several implementations that you can use for examples, and the; following information should help fill in any details. For examples, take a; look at the `various alias analysis implementations`_ included with LLVM. Different Pass styles; ---------------------. The first step to determining what type of :doc:`LLVM pass <WritingAnLLVMPass>`; you need to use for your Alias Analysis. As is the case with most other; analyses and transformations, the answer should be fairly obvious from what type; of problem you are trying to solve:. #. If you require interprocedural analysis, it should be a ``Pass``.; #. If you are a function-local analysis, subclass ``FunctionPass``.; #. If you don't need to look at the program at all, subclass ``ImmutablePass``. In addition to the pass that you subclass, you should also inherit from the; ``AliasAnalysis`` interface, of course, and use the ``RegisterAnalysisGroup``; template to register as an implementation of ``AliasAnalysis``. Required initialization calls; -----------------------------. Your subclass of ``AliasAnalysis`` is required to invoke two methods on the; ``AliasAnalysis`` base class: ``getAnalysisUsage`` and; ``InitializeAliasAnalysis``. In particular, your implementation of; ``getAnalysisUsage`` should explicitly call into the; ``AliasAnalysis::getAnalysisUsage`` method in addition to doing any declaring; any pass dependencies your pass has. Thus you should have something like this:. .. code-block:: c++. void getAnalysisUsage(AnalysisUsage &AU) const {; AliasAnalysis::getAnalysisUsage(AU);; // declare your dependencies here.; }. Additionally, your must invoke the ``InitializeAliasAnalysis`` method from your; analysis run method (``run`` for a ``Pass``, ``runOnFunction`` for a; ``FunctionPass``, or ``InitializePass`` for an ``ImmutablePass``). For example; (as part of a ``Pass``):. .. code-",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:24660,Modifiability,variab,variables,24660,"``; interface. All of these :ref:`chain <aliasanalysis-chaining>` to other; alias analysis implementations. The ``-basic-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^^. The ``-basic-aa`` pass is an aggressive local analysis that *knows* many; important facts:. * Distinct globals, stack allocations, and heap allocations can never alias.; * Globals, stack allocations, and heap allocations never alias the null pointer.; * Different fields of a structure do not alias.; * Indexes into arrays with statically differing subscripts cannot alias.; * Many common standard C library functions `never access memory or only read; memory`_.; * Pointers that obviously point to constant globals ""``pointToConstantMemory``"".; * Function calls can not modify or references stack allocations if they never; escape from the function that allocates them (a common case for automatic; arrays). The ``-globalsmodref-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This pass implements a simple context-sensitive mod/ref and alias analysis for; internal global variables that don't ""have their address taken"". If a global; does not have its address taken, the pass knows that no pointers alias the; global. This pass also keeps track of functions that it knows never access; memory or never read memory. This allows certain optimizations (e.g. GVN) to; eliminate call instructions entirely. The real power of this pass is that it provides context-sensitive mod/ref; information for call instructions. This allows the optimizer to know that calls; to a function do not clobber or read the value of the global, allowing loads and; stores to be eliminated. .. note::. This pass is somewhat limited in its scope (only support non-address taken; globals), but is very quick analysis. The ``-steens-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^^^. The ``-steens-aa`` pass implements a variation on the well-known ""Steensgaard's; algorithm"" for interprocedural alias analysis. Steensgaard's algorithm is a; unification-based, flow-insensitive, context-insen",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:27048,Modifiability,variab,variables,27048,". note::. ``-steens-aa`` is available in the optional ""poolalloc"" module. It is not part; of the LLVM core. The ``-ds-aa`` pass; ^^^^^^^^^^^^^^^^^^^. The ``-ds-aa`` pass implements the full Data Structure Analysis algorithm. Data; Structure Analysis is a modular unification-based, flow-insensitive,; context-**sensitive**, and speculatively field-**sensitive** alias; analysis that is also quite scalable, usually at ``O(n * log(n))``. This algorithm is capable of responding to a full variety of alias analysis; queries, and can provide context-sensitive mod/ref information as well. The; only major facility not implemented so far is support for must-alias; information. .. note::. ``-ds-aa`` is available in the optional ""poolalloc"" module. It is not part of; the LLVM core. The ``-scev-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^. The ``-scev-aa`` pass implements AliasAnalysis queries by translating them into; ScalarEvolution queries. This gives it a more complete understanding of; ``getelementptr`` instructions and loop induction variables than other alias; analyses have. Alias analysis driven transformations; -------------------------------------. LLVM includes several alias-analysis driven transformations which can be used; with any of the implementations above. The ``-adce`` pass; ^^^^^^^^^^^^^^^^^^. The ``-adce`` pass, which implements Aggressive Dead Code Elimination uses the; ``AliasAnalysis`` interface to delete calls to functions that do not have; side-effects and are not used. The ``-licm`` pass; ^^^^^^^^^^^^^^^^^^. The ``-licm`` pass implements various Loop Invariant Code Motion related; transformations. It uses the ``AliasAnalysis`` interface for several different; transformations:. * It uses mod/ref information to hoist or sink load instructions out of loops if; there are no instructions in the loop that modifies the memory loaded. * It uses mod/ref information to hoist function calls out of loops that do not; write to memory and are loop-invariant. * It uses alias inform",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:2364,Performance,perform,performs,2364," to simple alias analysis; information, this class exposes Mod/Ref information from those implementations; which can provide it, allowing for powerful analyses and transformations to work; well together. This document contains information necessary to successfully implement this; interface, use it, and to test both sides. It also explains some of the finer; points about what exactly results mean. ``AliasAnalysis`` Class Overview; ================================. The `AliasAnalysis <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`__; class defines the interface that the various alias analysis implementations; should support. This class exports two important enums: ``AliasResult`` and; ``ModRefResult`` which represent the result of an alias query or a mod/ref; query, respectively. The ``AliasAnalysis`` interface exposes information about memory, represented in; several different ways. In particular, memory objects are represented as a; starting address and size, and function calls are represented as the actual; ``call`` or ``invoke`` instructions that performs the call. The; ``AliasAnalysis`` interface also exposes some helper methods which allow you to; get mod/ref information for arbitrary instructions. All ``AliasAnalysis`` interfaces require that in queries involving multiple; values, values which are not :ref:`constants <constants>` are all; defined within the same function. Representation of Pointers; --------------------------. Most importantly, the ``AliasAnalysis`` class provides several methods which are; used to query whether or not two memory objects alias, whether function calls; can modify or read a memory object, etc. For all of these queries, memory; objects are represented as a pair of their starting address (a symbolic LLVM; ``Value*``) and a static size. Representing memory objects as a starting address and a size is critically; important for correct Alias Analyses. For example, consider this (silly, but; possible) C code:. .. code-block::",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:16408,Performance,load,load,16408," ``replaceWithNewValue`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This method is a simple helper method that is provided to make clients easier to; use. It is implemented by copying the old analysis information to the new; value, then deleting the old value. This method cannot be overridden by alias; analysis implementations. The ``addEscapingUse`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``addEscapingUse`` method is used when the uses of a pointer value have; changed in ways that may invalidate precomputed analysis information.; Implementations may either use this callback to provide conservative responses; for points whose uses have change since analysis time, or may recompute some or; all of their internal state to continue providing accurate responses. In general, any new use of a pointer value is considered an escaping use, and; must be reported through this callback, *except* for the uses below:. * A ``bitcast`` or ``getelementptr`` of the pointer; * A ``store`` through the pointer (but not a ``store`` *of* the pointer); * A ``load`` through the pointer. Efficiency Issues; -----------------. From the LLVM perspective, the only thing you need to do to provide an efficient; alias analysis is to make sure that alias analysis **queries** are serviced; quickly. The actual calculation of the alias analysis results (the ""run""; method) is only performed once, but many (perhaps duplicate) queries may be; performed. Because of this, try to move as much computation to the run method; as possible (within reason). Limitations; -----------. The AliasAnalysis infrastructure has several limitations which make writing a; new ``AliasAnalysis`` implementation difficult. There is no way to override the default alias analysis. It would be very useful; to be able to do something like ""``opt -my-aa -O2``"" and have it use ``-my-aa``; for all passes which need AliasAnalysis, but there is currently no support for; that, short of changing the source code and recompiling. Similarly, ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:16723,Performance,perform,performed,16723,"^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``addEscapingUse`` method is used when the uses of a pointer value have; changed in ways that may invalidate precomputed analysis information.; Implementations may either use this callback to provide conservative responses; for points whose uses have change since analysis time, or may recompute some or; all of their internal state to continue providing accurate responses. In general, any new use of a pointer value is considered an escaping use, and; must be reported through this callback, *except* for the uses below:. * A ``bitcast`` or ``getelementptr`` of the pointer; * A ``store`` through the pointer (but not a ``store`` *of* the pointer); * A ``load`` through the pointer. Efficiency Issues; -----------------. From the LLVM perspective, the only thing you need to do to provide an efficient; alias analysis is to make sure that alias analysis **queries** are serviced; quickly. The actual calculation of the alias analysis results (the ""run""; method) is only performed once, but many (perhaps duplicate) queries may be; performed. Because of this, try to move as much computation to the run method; as possible (within reason). Limitations; -----------. The AliasAnalysis infrastructure has several limitations which make writing a; new ``AliasAnalysis`` implementation difficult. There is no way to override the default alias analysis. It would be very useful; to be able to do something like ""``opt -my-aa -O2``"" and have it use ``-my-aa``; for all passes which need AliasAnalysis, but there is currently no support for; that, short of changing the source code and recompiling. Similarly, there is; also no way of setting a chain of analyses as the default. There is no way for transform passes to declare that they preserve; ``AliasAnalysis`` implementations. The ``AliasAnalysis`` interface includes; ``deleteValue`` and ``copyValue`` methods which are intended to allow a pass to; keep an AliasAnalysis consistent, however there's no way for a pass ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:16784,Performance,perform,performed,16784,"^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``addEscapingUse`` method is used when the uses of a pointer value have; changed in ways that may invalidate precomputed analysis information.; Implementations may either use this callback to provide conservative responses; for points whose uses have change since analysis time, or may recompute some or; all of their internal state to continue providing accurate responses. In general, any new use of a pointer value is considered an escaping use, and; must be reported through this callback, *except* for the uses below:. * A ``bitcast`` or ``getelementptr`` of the pointer; * A ``store`` through the pointer (but not a ``store`` *of* the pointer); * A ``load`` through the pointer. Efficiency Issues; -----------------. From the LLVM perspective, the only thing you need to do to provide an efficient; alias analysis is to make sure that alias analysis **queries** are serviced; quickly. The actual calculation of the alias analysis results (the ""run""; method) is only performed once, but many (perhaps duplicate) queries may be; performed. Because of this, try to move as much computation to the run method; as possible (within reason). Limitations; -----------. The AliasAnalysis infrastructure has several limitations which make writing a; new ``AliasAnalysis`` implementation difficult. There is no way to override the default alias analysis. It would be very useful; to be able to do something like ""``opt -my-aa -O2``"" and have it use ``-my-aa``; for all passes which need AliasAnalysis, but there is currently no support for; that, short of changing the source code and recompiling. Similarly, there is; also no way of setting a chain of analyses as the default. There is no way for transform passes to declare that they preserve; ``AliasAnalysis`` implementations. The ``AliasAnalysis`` interface includes; ``deleteValue`` and ``copyValue`` methods which are intended to allow a pass to; keep an AliasAnalysis consistent, however there's no way for a pass ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:19673,Performance,load,load,19673,"gger``. The ``AliasSetTracker`` class (which is used by ``LICM``) makes a; non-deterministic number of alias queries. This can cause debugging techniques; involving pausing execution after a predetermined number of queries to be; unreliable. Many alias queries can be reformulated in terms of other alias queries. When; multiple ``AliasAnalysis`` queries are chained together, it would make sense to; start those queries from the beginning of the chain, with care taken to avoid; infinite looping, however currently an implementation which wants to do this can; only start such queries from itself. Using alias analysis results; ============================. There are several different ways to use alias analysis results. In order of; preference, these are:. Using the ``MemoryDependenceAnalysis`` Pass; -------------------------------------------. The ``memdep`` pass uses alias analysis to provide high-level dependence; information about memory-using instructions. This will tell you which store; feeds into a load, for example. It uses caching and other techniques to be; efficient, and is used by Dead Store Elimination, GVN, and memcpy optimizations. .. _AliasSetTracker:. Using the ``AliasSetTracker`` class; -----------------------------------. Many transformations need information about alias **sets** that are active in; some scope, rather than information about pairwise aliasing. The; `AliasSetTracker <https://llvm.org/doxygen/classllvm_1_1AliasSetTracker.html>`__; class is used to efficiently build these Alias Sets from the pairwise alias; analysis information provided by the ``AliasAnalysis`` interface. First you initialize the AliasSetTracker by using the ""``add``"" methods to add; information about various potentially aliasing instructions in the scope you are; interested in. Once all of the alias sets are completed, your pass should; simply iterate through the constructed alias sets, using the ``AliasSetTracker``; ``begin()``/``end()`` methods. The ``AliasSet``\s formed ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:19802,Performance,optimiz,optimizations,19802,"umber of alias queries. This can cause debugging techniques; involving pausing execution after a predetermined number of queries to be; unreliable. Many alias queries can be reformulated in terms of other alias queries. When; multiple ``AliasAnalysis`` queries are chained together, it would make sense to; start those queries from the beginning of the chain, with care taken to avoid; infinite looping, however currently an implementation which wants to do this can; only start such queries from itself. Using alias analysis results; ============================. There are several different ways to use alias analysis results. In order of; preference, these are:. Using the ``MemoryDependenceAnalysis`` Pass; -------------------------------------------. The ``memdep`` pass uses alias analysis to provide high-level dependence; information about memory-using instructions. This will tell you which store; feeds into a load, for example. It uses caching and other techniques to be; efficient, and is used by Dead Store Elimination, GVN, and memcpy optimizations. .. _AliasSetTracker:. Using the ``AliasSetTracker`` class; -----------------------------------. Many transformations need information about alias **sets** that are active in; some scope, rather than information about pairwise aliasing. The; `AliasSetTracker <https://llvm.org/doxygen/classllvm_1_1AliasSetTracker.html>`__; class is used to efficiently build these Alias Sets from the pairwise alias; analysis information provided by the ``AliasAnalysis`` interface. First you initialize the AliasSetTracker by using the ""``add``"" methods to add; information about various potentially aliasing instructions in the scope you are; interested in. Once all of the alias sets are completed, your pass should; simply iterate through the constructed alias sets, using the ``AliasSetTracker``; ``begin()``/``end()`` methods. The ``AliasSet``\s formed by the ``AliasSetTracker`` are guaranteed to be; disjoint, calculate mod/ref information and vo",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:21223,Performance,load,load,21223,"information provided by the ``AliasAnalysis`` interface. First you initialize the AliasSetTracker by using the ""``add``"" methods to add; information about various potentially aliasing instructions in the scope you are; interested in. Once all of the alias sets are completed, your pass should; simply iterate through the constructed alias sets, using the ``AliasSetTracker``; ``begin()``/``end()`` methods. The ``AliasSet``\s formed by the ``AliasSetTracker`` are guaranteed to be; disjoint, calculate mod/ref information and volatility for the set, and keep; track of whether or not all of the pointers in the set are Must aliases. The; AliasSetTracker also makes sure that sets are properly folded due to call; instructions, and can provide a list of pointers in each set. As an example user of this, the `Loop Invariant Code Motion; <doxygen/structLICM.html>`_ pass uses ``AliasSetTracker``\s to calculate alias; sets for each loop nest. If an ``AliasSet`` in a loop is not modified, then all; load instructions from that set may be hoisted out of the loop. If any alias; sets are stored to **and** are must alias sets, then the stores may be sunk; to outside of the loop, promoting the memory location to a register for the; duration of the loop nest. Both of these transformations only apply if the; pointer argument is loop-invariant. The AliasSetTracker implementation; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The AliasSetTracker class is implemented to be as efficient as possible. It; uses the union-find algorithm to efficiently merge AliasSets when a pointer is; inserted into the AliasSetTracker that aliases multiple sets. The primary data; structure is a hash table mapping pointers to the AliasSet they are in. The AliasSetTracker class must maintain a list of all of the LLVM ``Value*``\s; that are in each AliasSet. Since the hash table already has entries for each; LLVM ``Value*`` of interest, the AliasesSets thread the linked list through; these hash-table nodes to avoid having to a",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:24923,Performance,optimiz,optimizations,24923," and heap allocations can never alias.; * Globals, stack allocations, and heap allocations never alias the null pointer.; * Different fields of a structure do not alias.; * Indexes into arrays with statically differing subscripts cannot alias.; * Many common standard C library functions `never access memory or only read; memory`_.; * Pointers that obviously point to constant globals ""``pointToConstantMemory``"".; * Function calls can not modify or references stack allocations if they never; escape from the function that allocates them (a common case for automatic; arrays). The ``-globalsmodref-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This pass implements a simple context-sensitive mod/ref and alias analysis for; internal global variables that don't ""have their address taken"". If a global; does not have its address taken, the pass knows that no pointers alias the; global. This pass also keeps track of functions that it knows never access; memory or never read memory. This allows certain optimizations (e.g. GVN) to; eliminate call instructions entirely. The real power of this pass is that it provides context-sensitive mod/ref; information for call instructions. This allows the optimizer to know that calls; to a function do not clobber or read the value of the global, allowing loads and; stores to be eliminated. .. note::. This pass is somewhat limited in its scope (only support non-address taken; globals), but is very quick analysis. The ``-steens-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^^^. The ``-steens-aa`` pass implements a variation on the well-known ""Steensgaard's; algorithm"" for interprocedural alias analysis. Steensgaard's algorithm is a; unification-based, flow-insensitive, context-insensitive, and field-insensitive; alias analysis that is also very scalable (effectively linear time). The LLVM ``-steens-aa`` pass implements a ""speculatively field-**sensitive**""; version of Steensgaard's algorithm using the Data Structure Analysis framework.; This gives it substantial",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:25116,Performance,optimiz,optimizer,25116,"mmon standard C library functions `never access memory or only read; memory`_.; * Pointers that obviously point to constant globals ""``pointToConstantMemory``"".; * Function calls can not modify or references stack allocations if they never; escape from the function that allocates them (a common case for automatic; arrays). The ``-globalsmodref-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This pass implements a simple context-sensitive mod/ref and alias analysis for; internal global variables that don't ""have their address taken"". If a global; does not have its address taken, the pass knows that no pointers alias the; global. This pass also keeps track of functions that it knows never access; memory or never read memory. This allows certain optimizations (e.g. GVN) to; eliminate call instructions entirely. The real power of this pass is that it provides context-sensitive mod/ref; information for call instructions. This allows the optimizer to know that calls; to a function do not clobber or read the value of the global, allowing loads and; stores to be eliminated. .. note::. This pass is somewhat limited in its scope (only support non-address taken; globals), but is very quick analysis. The ``-steens-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^^^. The ``-steens-aa`` pass implements a variation on the well-known ""Steensgaard's; algorithm"" for interprocedural alias analysis. Steensgaard's algorithm is a; unification-based, flow-insensitive, context-insensitive, and field-insensitive; alias analysis that is also very scalable (effectively linear time). The LLVM ``-steens-aa`` pass implements a ""speculatively field-**sensitive**""; version of Steensgaard's algorithm using the Data Structure Analysis framework.; This gives it substantially more precision than the standard algorithm while; maintaining excellent analysis scalability. .. note::. ``-steens-aa`` is available in the optional ""poolalloc"" module. It is not part; of the LLVM core. The ``-ds-aa`` pass; ^^^^^^^^^^^^^^^^^^^. The ``-",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:25217,Performance,load,loads,25217,"mmon standard C library functions `never access memory or only read; memory`_.; * Pointers that obviously point to constant globals ""``pointToConstantMemory``"".; * Function calls can not modify or references stack allocations if they never; escape from the function that allocates them (a common case for automatic; arrays). The ``-globalsmodref-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This pass implements a simple context-sensitive mod/ref and alias analysis for; internal global variables that don't ""have their address taken"". If a global; does not have its address taken, the pass knows that no pointers alias the; global. This pass also keeps track of functions that it knows never access; memory or never read memory. This allows certain optimizations (e.g. GVN) to; eliminate call instructions entirely. The real power of this pass is that it provides context-sensitive mod/ref; information for call instructions. This allows the optimizer to know that calls; to a function do not clobber or read the value of the global, allowing loads and; stores to be eliminated. .. note::. This pass is somewhat limited in its scope (only support non-address taken; globals), but is very quick analysis. The ``-steens-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^^^. The ``-steens-aa`` pass implements a variation on the well-known ""Steensgaard's; algorithm"" for interprocedural alias analysis. Steensgaard's algorithm is a; unification-based, flow-insensitive, context-insensitive, and field-insensitive; alias analysis that is also very scalable (effectively linear time). The LLVM ``-steens-aa`` pass implements a ""speculatively field-**sensitive**""; version of Steensgaard's algorithm using the Data Structure Analysis framework.; This gives it substantially more precision than the standard algorithm while; maintaining excellent analysis scalability. .. note::. ``-steens-aa`` is available in the optional ""poolalloc"" module. It is not part; of the LLVM core. The ``-ds-aa`` pass; ^^^^^^^^^^^^^^^^^^^. The ``-",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:25700,Performance,scalab,scalable,25700,"nternal global variables that don't ""have their address taken"". If a global; does not have its address taken, the pass knows that no pointers alias the; global. This pass also keeps track of functions that it knows never access; memory or never read memory. This allows certain optimizations (e.g. GVN) to; eliminate call instructions entirely. The real power of this pass is that it provides context-sensitive mod/ref; information for call instructions. This allows the optimizer to know that calls; to a function do not clobber or read the value of the global, allowing loads and; stores to be eliminated. .. note::. This pass is somewhat limited in its scope (only support non-address taken; globals), but is very quick analysis. The ``-steens-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^^^. The ``-steens-aa`` pass implements a variation on the well-known ""Steensgaard's; algorithm"" for interprocedural alias analysis. Steensgaard's algorithm is a; unification-based, flow-insensitive, context-insensitive, and field-insensitive; alias analysis that is also very scalable (effectively linear time). The LLVM ``-steens-aa`` pass implements a ""speculatively field-**sensitive**""; version of Steensgaard's algorithm using the Data Structure Analysis framework.; This gives it substantially more precision than the standard algorithm while; maintaining excellent analysis scalability. .. note::. ``-steens-aa`` is available in the optional ""poolalloc"" module. It is not part; of the LLVM core. The ``-ds-aa`` pass; ^^^^^^^^^^^^^^^^^^^. The ``-ds-aa`` pass implements the full Data Structure Analysis algorithm. Data; Structure Analysis is a modular unification-based, flow-insensitive,; context-**sensitive**, and speculatively field-**sensitive** alias; analysis that is also quite scalable, usually at ``O(n * log(n))``. This algorithm is capable of responding to a full variety of alias analysis; queries, and can provide context-sensitive mod/ref information as well. The; only major facility not implemented",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:26005,Performance,scalab,scalability,26005,"minate call instructions entirely. The real power of this pass is that it provides context-sensitive mod/ref; information for call instructions. This allows the optimizer to know that calls; to a function do not clobber or read the value of the global, allowing loads and; stores to be eliminated. .. note::. This pass is somewhat limited in its scope (only support non-address taken; globals), but is very quick analysis. The ``-steens-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^^^. The ``-steens-aa`` pass implements a variation on the well-known ""Steensgaard's; algorithm"" for interprocedural alias analysis. Steensgaard's algorithm is a; unification-based, flow-insensitive, context-insensitive, and field-insensitive; alias analysis that is also very scalable (effectively linear time). The LLVM ``-steens-aa`` pass implements a ""speculatively field-**sensitive**""; version of Steensgaard's algorithm using the Data Structure Analysis framework.; This gives it substantially more precision than the standard algorithm while; maintaining excellent analysis scalability. .. note::. ``-steens-aa`` is available in the optional ""poolalloc"" module. It is not part; of the LLVM core. The ``-ds-aa`` pass; ^^^^^^^^^^^^^^^^^^^. The ``-ds-aa`` pass implements the full Data Structure Analysis algorithm. Data; Structure Analysis is a modular unification-based, flow-insensitive,; context-**sensitive**, and speculatively field-**sensitive** alias; analysis that is also quite scalable, usually at ``O(n * log(n))``. This algorithm is capable of responding to a full variety of alias analysis; queries, and can provide context-sensitive mod/ref information as well. The; only major facility not implemented so far is support for must-alias; information. .. note::. ``-ds-aa`` is available in the optional ""poolalloc"" module. It is not part of; the LLVM core. The ``-scev-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^. The ``-scev-aa`` pass implements AliasAnalysis queries by translating them into; ScalarEvolution queries. This g",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:26416,Performance,scalab,scalable,26416," but is very quick analysis. The ``-steens-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^^^. The ``-steens-aa`` pass implements a variation on the well-known ""Steensgaard's; algorithm"" for interprocedural alias analysis. Steensgaard's algorithm is a; unification-based, flow-insensitive, context-insensitive, and field-insensitive; alias analysis that is also very scalable (effectively linear time). The LLVM ``-steens-aa`` pass implements a ""speculatively field-**sensitive**""; version of Steensgaard's algorithm using the Data Structure Analysis framework.; This gives it substantially more precision than the standard algorithm while; maintaining excellent analysis scalability. .. note::. ``-steens-aa`` is available in the optional ""poolalloc"" module. It is not part; of the LLVM core. The ``-ds-aa`` pass; ^^^^^^^^^^^^^^^^^^^. The ``-ds-aa`` pass implements the full Data Structure Analysis algorithm. Data; Structure Analysis is a modular unification-based, flow-insensitive,; context-**sensitive**, and speculatively field-**sensitive** alias; analysis that is also quite scalable, usually at ``O(n * log(n))``. This algorithm is capable of responding to a full variety of alias analysis; queries, and can provide context-sensitive mod/ref information as well. The; only major facility not implemented so far is support for must-alias; information. .. note::. ``-ds-aa`` is available in the optional ""poolalloc"" module. It is not part of; the LLVM core. The ``-scev-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^. The ``-scev-aa`` pass implements AliasAnalysis queries by translating them into; ScalarEvolution queries. This gives it a more complete understanding of; ``getelementptr`` instructions and loop induction variables than other alias; analyses have. Alias analysis driven transformations; -------------------------------------. LLVM includes several alias-analysis driven transformations which can be used; with any of the implementations above. The ``-adce`` pass; ^^^^^^^^^^^^^^^^^^. The ``-adce`` pass, wh",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:27772,Performance,load,load,27772,"e ``-scev-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^. The ``-scev-aa`` pass implements AliasAnalysis queries by translating them into; ScalarEvolution queries. This gives it a more complete understanding of; ``getelementptr`` instructions and loop induction variables than other alias; analyses have. Alias analysis driven transformations; -------------------------------------. LLVM includes several alias-analysis driven transformations which can be used; with any of the implementations above. The ``-adce`` pass; ^^^^^^^^^^^^^^^^^^. The ``-adce`` pass, which implements Aggressive Dead Code Elimination uses the; ``AliasAnalysis`` interface to delete calls to functions that do not have; side-effects and are not used. The ``-licm`` pass; ^^^^^^^^^^^^^^^^^^. The ``-licm`` pass implements various Loop Invariant Code Motion related; transformations. It uses the ``AliasAnalysis`` interface for several different; transformations:. * It uses mod/ref information to hoist or sink load instructions out of loops if; there are no instructions in the loop that modifies the memory loaded. * It uses mod/ref information to hoist function calls out of loops that do not; write to memory and are loop-invariant. * It uses alias information to promote memory objects that are loaded and stored; to in loops to live in a register instead. It can do this if there are no may; aliases to the loaded/stored memory location. The ``-argpromotion`` pass; ^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``-argpromotion`` pass promotes by-reference arguments to be passed in; by-value instead. In particular, if pointer arguments are only loaded from it; passes in the value loaded instead of the address to the function. This pass; uses alias information to make sure that the value loaded from the argument; pointer is not modified between the entry of the function and any load of the; pointer. The ``-gvn``, ``-memcpyopt``, and ``-dse`` passes; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. These passes use AliasAnalysis informati",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:27870,Performance,load,loaded,27870,"e ``-scev-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^. The ``-scev-aa`` pass implements AliasAnalysis queries by translating them into; ScalarEvolution queries. This gives it a more complete understanding of; ``getelementptr`` instructions and loop induction variables than other alias; analyses have. Alias analysis driven transformations; -------------------------------------. LLVM includes several alias-analysis driven transformations which can be used; with any of the implementations above. The ``-adce`` pass; ^^^^^^^^^^^^^^^^^^. The ``-adce`` pass, which implements Aggressive Dead Code Elimination uses the; ``AliasAnalysis`` interface to delete calls to functions that do not have; side-effects and are not used. The ``-licm`` pass; ^^^^^^^^^^^^^^^^^^. The ``-licm`` pass implements various Loop Invariant Code Motion related; transformations. It uses the ``AliasAnalysis`` interface for several different; transformations:. * It uses mod/ref information to hoist or sink load instructions out of loops if; there are no instructions in the loop that modifies the memory loaded. * It uses mod/ref information to hoist function calls out of loops that do not; write to memory and are loop-invariant. * It uses alias information to promote memory objects that are loaded and stored; to in loops to live in a register instead. It can do this if there are no may; aliases to the loaded/stored memory location. The ``-argpromotion`` pass; ^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``-argpromotion`` pass promotes by-reference arguments to be passed in; by-value instead. In particular, if pointer arguments are only loaded from it; passes in the value loaded instead of the address to the function. This pass; uses alias information to make sure that the value loaded from the argument; pointer is not modified between the entry of the function and any load of the; pointer. The ``-gvn``, ``-memcpyopt``, and ``-dse`` passes; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. These passes use AliasAnalysis informati",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:28061,Performance,load,loaded,28061,"han other alias; analyses have. Alias analysis driven transformations; -------------------------------------. LLVM includes several alias-analysis driven transformations which can be used; with any of the implementations above. The ``-adce`` pass; ^^^^^^^^^^^^^^^^^^. The ``-adce`` pass, which implements Aggressive Dead Code Elimination uses the; ``AliasAnalysis`` interface to delete calls to functions that do not have; side-effects and are not used. The ``-licm`` pass; ^^^^^^^^^^^^^^^^^^. The ``-licm`` pass implements various Loop Invariant Code Motion related; transformations. It uses the ``AliasAnalysis`` interface for several different; transformations:. * It uses mod/ref information to hoist or sink load instructions out of loops if; there are no instructions in the loop that modifies the memory loaded. * It uses mod/ref information to hoist function calls out of loops that do not; write to memory and are loop-invariant. * It uses alias information to promote memory objects that are loaded and stored; to in loops to live in a register instead. It can do this if there are no may; aliases to the loaded/stored memory location. The ``-argpromotion`` pass; ^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``-argpromotion`` pass promotes by-reference arguments to be passed in; by-value instead. In particular, if pointer arguments are only loaded from it; passes in the value loaded instead of the address to the function. This pass; uses alias information to make sure that the value loaded from the argument; pointer is not modified between the entry of the function and any load of the; pointer. The ``-gvn``, ``-memcpyopt``, and ``-dse`` passes; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. These passes use AliasAnalysis information to reason about loads and stores. .. _the clients:. Clients for debugging and evaluation of implementations; -------------------------------------------------------. These passes are useful for evaluating the various alias analysis; implementations. You ca",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:28174,Performance,load,loaded,28174,"----. LLVM includes several alias-analysis driven transformations which can be used; with any of the implementations above. The ``-adce`` pass; ^^^^^^^^^^^^^^^^^^. The ``-adce`` pass, which implements Aggressive Dead Code Elimination uses the; ``AliasAnalysis`` interface to delete calls to functions that do not have; side-effects and are not used. The ``-licm`` pass; ^^^^^^^^^^^^^^^^^^. The ``-licm`` pass implements various Loop Invariant Code Motion related; transformations. It uses the ``AliasAnalysis`` interface for several different; transformations:. * It uses mod/ref information to hoist or sink load instructions out of loops if; there are no instructions in the loop that modifies the memory loaded. * It uses mod/ref information to hoist function calls out of loops that do not; write to memory and are loop-invariant. * It uses alias information to promote memory objects that are loaded and stored; to in loops to live in a register instead. It can do this if there are no may; aliases to the loaded/stored memory location. The ``-argpromotion`` pass; ^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``-argpromotion`` pass promotes by-reference arguments to be passed in; by-value instead. In particular, if pointer arguments are only loaded from it; passes in the value loaded instead of the address to the function. This pass; uses alias information to make sure that the value loaded from the argument; pointer is not modified between the entry of the function and any load of the; pointer. The ``-gvn``, ``-memcpyopt``, and ``-dse`` passes; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. These passes use AliasAnalysis information to reason about loads and stores. .. _the clients:. Clients for debugging and evaluation of implementations; -------------------------------------------------------. These passes are useful for evaluating the various alias analysis; implementations. You can use them with commands like:. .. code-block:: bash. % opt -ds-aa -aa-eval foo.bc -disable-output -sta",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:28400,Performance,load,loaded,28400,"ysis`` interface to delete calls to functions that do not have; side-effects and are not used. The ``-licm`` pass; ^^^^^^^^^^^^^^^^^^. The ``-licm`` pass implements various Loop Invariant Code Motion related; transformations. It uses the ``AliasAnalysis`` interface for several different; transformations:. * It uses mod/ref information to hoist or sink load instructions out of loops if; there are no instructions in the loop that modifies the memory loaded. * It uses mod/ref information to hoist function calls out of loops that do not; write to memory and are loop-invariant. * It uses alias information to promote memory objects that are loaded and stored; to in loops to live in a register instead. It can do this if there are no may; aliases to the loaded/stored memory location. The ``-argpromotion`` pass; ^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``-argpromotion`` pass promotes by-reference arguments to be passed in; by-value instead. In particular, if pointer arguments are only loaded from it; passes in the value loaded instead of the address to the function. This pass; uses alias information to make sure that the value loaded from the argument; pointer is not modified between the entry of the function and any load of the; pointer. The ``-gvn``, ``-memcpyopt``, and ``-dse`` passes; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. These passes use AliasAnalysis information to reason about loads and stores. .. _the clients:. Clients for debugging and evaluation of implementations; -------------------------------------------------------. These passes are useful for evaluating the various alias analysis; implementations. You can use them with commands like:. .. code-block:: bash. % opt -ds-aa -aa-eval foo.bc -disable-output -stats. The ``-print-alias-sets`` pass; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``-print-alias-sets`` pass is exposed as part of the ``opt`` tool to print; out the Alias Sets formed by the `AliasSetTracker`_ class. This is useful if; you're using the ``AliasSetTr",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:28436,Performance,load,loaded,28436,"ysis`` interface to delete calls to functions that do not have; side-effects and are not used. The ``-licm`` pass; ^^^^^^^^^^^^^^^^^^. The ``-licm`` pass implements various Loop Invariant Code Motion related; transformations. It uses the ``AliasAnalysis`` interface for several different; transformations:. * It uses mod/ref information to hoist or sink load instructions out of loops if; there are no instructions in the loop that modifies the memory loaded. * It uses mod/ref information to hoist function calls out of loops that do not; write to memory and are loop-invariant. * It uses alias information to promote memory objects that are loaded and stored; to in loops to live in a register instead. It can do this if there are no may; aliases to the loaded/stored memory location. The ``-argpromotion`` pass; ^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``-argpromotion`` pass promotes by-reference arguments to be passed in; by-value instead. In particular, if pointer arguments are only loaded from it; passes in the value loaded instead of the address to the function. This pass; uses alias information to make sure that the value loaded from the argument; pointer is not modified between the entry of the function and any load of the; pointer. The ``-gvn``, ``-memcpyopt``, and ``-dse`` passes; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. These passes use AliasAnalysis information to reason about loads and stores. .. _the clients:. Clients for debugging and evaluation of implementations; -------------------------------------------------------. These passes are useful for evaluating the various alias analysis; implementations. You can use them with commands like:. .. code-block:: bash. % opt -ds-aa -aa-eval foo.bc -disable-output -stats. The ``-print-alias-sets`` pass; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``-print-alias-sets`` pass is exposed as part of the ``opt`` tool to print; out the Alias Sets formed by the `AliasSetTracker`_ class. This is useful if; you're using the ``AliasSetTr",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:28545,Performance,load,loaded,28545,"s implements various Loop Invariant Code Motion related; transformations. It uses the ``AliasAnalysis`` interface for several different; transformations:. * It uses mod/ref information to hoist or sink load instructions out of loops if; there are no instructions in the loop that modifies the memory loaded. * It uses mod/ref information to hoist function calls out of loops that do not; write to memory and are loop-invariant. * It uses alias information to promote memory objects that are loaded and stored; to in loops to live in a register instead. It can do this if there are no may; aliases to the loaded/stored memory location. The ``-argpromotion`` pass; ^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``-argpromotion`` pass promotes by-reference arguments to be passed in; by-value instead. In particular, if pointer arguments are only loaded from it; passes in the value loaded instead of the address to the function. This pass; uses alias information to make sure that the value loaded from the argument; pointer is not modified between the entry of the function and any load of the; pointer. The ``-gvn``, ``-memcpyopt``, and ``-dse`` passes; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. These passes use AliasAnalysis information to reason about loads and stores. .. _the clients:. Clients for debugging and evaluation of implementations; -------------------------------------------------------. These passes are useful for evaluating the various alias analysis; implementations. You can use them with commands like:. .. code-block:: bash. % opt -ds-aa -aa-eval foo.bc -disable-output -stats. The ``-print-alias-sets`` pass; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``-print-alias-sets`` pass is exposed as part of the ``opt`` tool to print; out the Alias Sets formed by the `AliasSetTracker`_ class. This is useful if; you're using the ``AliasSetTracker`` class. To use it, use something like:. .. code-block:: bash. % opt -ds-aa -print-alias-sets -disable-output. The ``-aa-eval`` pass; ^^^^^^^^^^^^",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:28637,Performance,load,load,28637,"s implements various Loop Invariant Code Motion related; transformations. It uses the ``AliasAnalysis`` interface for several different; transformations:. * It uses mod/ref information to hoist or sink load instructions out of loops if; there are no instructions in the loop that modifies the memory loaded. * It uses mod/ref information to hoist function calls out of loops that do not; write to memory and are loop-invariant. * It uses alias information to promote memory objects that are loaded and stored; to in loops to live in a register instead. It can do this if there are no may; aliases to the loaded/stored memory location. The ``-argpromotion`` pass; ^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``-argpromotion`` pass promotes by-reference arguments to be passed in; by-value instead. In particular, if pointer arguments are only loaded from it; passes in the value loaded instead of the address to the function. This pass; uses alias information to make sure that the value loaded from the argument; pointer is not modified between the entry of the function and any load of the; pointer. The ``-gvn``, ``-memcpyopt``, and ``-dse`` passes; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. These passes use AliasAnalysis information to reason about loads and stores. .. _the clients:. Clients for debugging and evaluation of implementations; -------------------------------------------------------. These passes are useful for evaluating the various alias analysis; implementations. You can use them with commands like:. .. code-block:: bash. % opt -ds-aa -aa-eval foo.bc -disable-output -stats. The ``-print-alias-sets`` pass; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``-print-alias-sets`` pass is exposed as part of the ``opt`` tool to print; out the Alias Sets formed by the `AliasSetTracker`_ class. This is useful if; you're using the ``AliasSetTracker`` class. To use it, use something like:. .. code-block:: bash. % opt -ds-aa -print-alias-sets -disable-output. The ``-aa-eval`` pass; ^^^^^^^^^^^^",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:28820,Performance,load,loads,28820,"oops if; there are no instructions in the loop that modifies the memory loaded. * It uses mod/ref information to hoist function calls out of loops that do not; write to memory and are loop-invariant. * It uses alias information to promote memory objects that are loaded and stored; to in loops to live in a register instead. It can do this if there are no may; aliases to the loaded/stored memory location. The ``-argpromotion`` pass; ^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``-argpromotion`` pass promotes by-reference arguments to be passed in; by-value instead. In particular, if pointer arguments are only loaded from it; passes in the value loaded instead of the address to the function. This pass; uses alias information to make sure that the value loaded from the argument; pointer is not modified between the entry of the function and any load of the; pointer. The ``-gvn``, ``-memcpyopt``, and ``-dse`` passes; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. These passes use AliasAnalysis information to reason about loads and stores. .. _the clients:. Clients for debugging and evaluation of implementations; -------------------------------------------------------. These passes are useful for evaluating the various alias analysis; implementations. You can use them with commands like:. .. code-block:: bash. % opt -ds-aa -aa-eval foo.bc -disable-output -stats. The ``-print-alias-sets`` pass; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``-print-alias-sets`` pass is exposed as part of the ``opt`` tool to print; out the Alias Sets formed by the `AliasSetTracker`_ class. This is useful if; you're using the ``AliasSetTracker`` class. To use it, use something like:. .. code-block:: bash. % opt -ds-aa -print-alias-sets -disable-output. The ``-aa-eval`` pass; ^^^^^^^^^^^^^^^^^^^^^. The ``-aa-eval`` pass simply iterates through all pairs of pointers in a; function and asks an alias analysis whether or not the pointers alias. This; gives an indication of the precision of the alias analysis. Statist",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:30565,Performance,perform,performance,30565,"ction and any load of the; pointer. The ``-gvn``, ``-memcpyopt``, and ``-dse`` passes; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. These passes use AliasAnalysis information to reason about loads and stores. .. _the clients:. Clients for debugging and evaluation of implementations; -------------------------------------------------------. These passes are useful for evaluating the various alias analysis; implementations. You can use them with commands like:. .. code-block:: bash. % opt -ds-aa -aa-eval foo.bc -disable-output -stats. The ``-print-alias-sets`` pass; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``-print-alias-sets`` pass is exposed as part of the ``opt`` tool to print; out the Alias Sets formed by the `AliasSetTracker`_ class. This is useful if; you're using the ``AliasSetTracker`` class. To use it, use something like:. .. code-block:: bash. % opt -ds-aa -print-alias-sets -disable-output. The ``-aa-eval`` pass; ^^^^^^^^^^^^^^^^^^^^^. The ``-aa-eval`` pass simply iterates through all pairs of pointers in a; function and asks an alias analysis whether or not the pointers alias. This; gives an indication of the precision of the alias analysis. Statistics are; printed indicating the percent of no/may/must aliases found (a more precise; algorithm will have a lower number of may aliases). Memory Dependence Analysis; ==========================. .. note::. We are currently in the process of migrating things from; ``MemoryDependenceAnalysis`` to :doc:`MemorySSA`. Please try to use; that instead. If you're just looking to be a client of alias analysis information, consider; using the Memory Dependence Analysis interface instead. MemDep is a lazy,; caching layer on top of alias analysis that is able to answer the question of; what preceding memory operations a given instruction depends on, either at an; intra- or inter-block level. Because of its laziness and caching policy, using; MemDep can be a significant performance win over accessing alias analysis; directly.; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:15168,Safety,safe,safe,15168," changes from the clients to the analysis implementations.; Various alias analysis implementations should use these methods to ensure that; their internal data structures are kept up-to-date as the program changes (for; example, when an instruction is deleted), and clients of alias analysis must be; sure to call these interfaces appropriately. The ``deleteValue`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``deleteValue`` method is called by transformations when they remove an; instruction or any other value from the program (including values that do not; use pointers). Typically alias analyses keep data structures that have entries; for each value in the program. When this method is called, they should remove; any entries for the specified value, if they exist. The ``copyValue`` method; ^^^^^^^^^^^^^^^^^^^^^^^^. The ``copyValue`` method is used when a new value is introduced into the; program. There is no way to introduce a value into the program that did not; exist before (this doesn't make sense for a safe compiler transformation), so; this is the only way to introduce a new value. This method indicates that the; new value has exactly the same properties as the value being copied. The ``replaceWithNewValue`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This method is a simple helper method that is provided to make clients easier to; use. It is implemented by copying the old analysis information to the new; value, then deleting the old value. This method cannot be overridden by alias; analysis implementations. The ``addEscapingUse`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``addEscapingUse`` method is used when the uses of a pointer value have; changed in ways that may invalidate precomputed analysis information.; Implementations may either use this callback to provide conservative responses; for points whose uses have change since analysis time, or may recompute some or; all of their internal state to continue providing accurate responses. In general, any new use of",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:19132,Safety,avoid,avoid,19132," when; values are deleted or copied, however these aren't sufficient. There are many; other ways that LLVM IR can be modified which could be relevant to; ``AliasAnalysis`` implementations which can not be expressed. The ``AliasAnalysisDebugger`` utility seems to suggest that ``AliasAnalysis``; implementations can expect that they will be informed of any relevant ``Value``; before it appears in an alias query. However, popular clients such as ``GVN``; don't support this, and are known to trigger errors when run with the; ``AliasAnalysisDebugger``. The ``AliasSetTracker`` class (which is used by ``LICM``) makes a; non-deterministic number of alias queries. This can cause debugging techniques; involving pausing execution after a predetermined number of queries to be; unreliable. Many alias queries can be reformulated in terms of other alias queries. When; multiple ``AliasAnalysis`` queries are chained together, it would make sense to; start those queries from the beginning of the chain, with care taken to avoid; infinite looping, however currently an implementation which wants to do this can; only start such queries from itself. Using alias analysis results; ============================. There are several different ways to use alias analysis results. In order of; preference, these are:. Using the ``MemoryDependenceAnalysis`` Pass; -------------------------------------------. The ``memdep`` pass uses alias analysis to provide high-level dependence; information about memory-using instructions. This will tell you which store; feeds into a load, for example. It uses caching and other techniques to be; efficient, and is used by Dead Store Elimination, GVN, and memcpy optimizations. .. _AliasSetTracker:. Using the ``AliasSetTracker`` class; -----------------------------------. Many transformations need information about alias **sets** that are active in; some scope, rather than information about pairwise aliasing. The; `AliasSetTracker <https://llvm.org/doxygen/classllvm_1_1A",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:22209,Safety,avoid,avoid,22209," modified, then all; load instructions from that set may be hoisted out of the loop. If any alias; sets are stored to **and** are must alias sets, then the stores may be sunk; to outside of the loop, promoting the memory location to a register for the; duration of the loop nest. Both of these transformations only apply if the; pointer argument is loop-invariant. The AliasSetTracker implementation; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The AliasSetTracker class is implemented to be as efficient as possible. It; uses the union-find algorithm to efficiently merge AliasSets when a pointer is; inserted into the AliasSetTracker that aliases multiple sets. The primary data; structure is a hash table mapping pointers to the AliasSet they are in. The AliasSetTracker class must maintain a list of all of the LLVM ``Value*``\s; that are in each AliasSet. Since the hash table already has entries for each; LLVM ``Value*`` of interest, the AliasesSets thread the linked list through; these hash-table nodes to avoid having to allocate memory unnecessarily, and to; make merging alias sets extremely efficient (the linked list merge is constant; time). You shouldn't need to understand these details if you are just a client of the; AliasSetTracker, but if you look at the code, hopefully this brief description; will help make sense of why things are designed the way they are. Using the ``AliasAnalysis`` interface directly; ----------------------------------------------. If neither of these utility class are what your pass needs, you should use the; interfaces exposed by the ``AliasAnalysis`` class directly. Try to use the; higher-level methods when possible (e.g., use mod/ref information instead of the; `alias`_ method directly if possible) to get the best precision and efficiency. Existing alias analysis implementations and clients; ===================================================. If you're going to be working with the LLVM alias analysis infrastructure, you; should know what clients ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:1338,Security,expose,exposes,1338,"d many; different ways of classifying them: flow-sensitive vs. flow-insensitive,; context-sensitive vs. context-insensitive, field-sensitive; vs. field-insensitive, unification-based vs. subset-based, etc. Traditionally,; alias analyses respond to a query with a `Must, May, or No`_ alias response,; indicating that two pointers always point to the same object, might point to the; same object, or are known to never point to the same object. The LLVM `AliasAnalysis; <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`__ class is the; primary interface used by clients and implementations of alias analyses in the; LLVM system. This class is the common interface between clients of alias; analysis information and the implementations providing it, and is designed to; support a wide range of implementations and clients (but currently all clients; are assumed to be flow-insensitive). In addition to simple alias analysis; information, this class exposes Mod/Ref information from those implementations; which can provide it, allowing for powerful analyses and transformations to work; well together. This document contains information necessary to successfully implement this; interface, use it, and to test both sides. It also explains some of the finer; points about what exactly results mean. ``AliasAnalysis`` Class Overview; ================================. The `AliasAnalysis <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`__; class defines the interface that the various alias analysis implementations; should support. This class exports two important enums: ``AliasResult`` and; ``ModRefResult`` which represent the result of an alias query or a mod/ref; query, respectively. The ``AliasAnalysis`` interface exposes information about memory, represented in; several different ways. In particular, memory objects are represented as a; starting address and size, and function calls are represented as the actual; ``call`` or ``invoke`` instructions that performs the call. ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:2120,Security,expose,exposes,2120,"nd is designed to; support a wide range of implementations and clients (but currently all clients; are assumed to be flow-insensitive). In addition to simple alias analysis; information, this class exposes Mod/Ref information from those implementations; which can provide it, allowing for powerful analyses and transformations to work; well together. This document contains information necessary to successfully implement this; interface, use it, and to test both sides. It also explains some of the finer; points about what exactly results mean. ``AliasAnalysis`` Class Overview; ================================. The `AliasAnalysis <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`__; class defines the interface that the various alias analysis implementations; should support. This class exports two important enums: ``AliasResult`` and; ``ModRefResult`` which represent the result of an alias query or a mod/ref; query, respectively. The ``AliasAnalysis`` interface exposes information about memory, represented in; several different ways. In particular, memory objects are represented as a; starting address and size, and function calls are represented as the actual; ``call`` or ``invoke`` instructions that performs the call. The; ``AliasAnalysis`` interface also exposes some helper methods which allow you to; get mod/ref information for arbitrary instructions. All ``AliasAnalysis`` interfaces require that in queries involving multiple; values, values which are not :ref:`constants <constants>` are all; defined within the same function. Representation of Pointers; --------------------------. Most importantly, the ``AliasAnalysis`` class provides several methods which are; used to query whether or not two memory objects alias, whether function calls; can modify or read a memory object, etc. For all of these queries, memory; objects are represented as a pair of their starting address (a symbolic LLVM; ``Value*``) and a static size. Representing memory objects as a startin",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:2421,Security,expose,exposes,2421,"transformations to work; well together. This document contains information necessary to successfully implement this; interface, use it, and to test both sides. It also explains some of the finer; points about what exactly results mean. ``AliasAnalysis`` Class Overview; ================================. The `AliasAnalysis <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`__; class defines the interface that the various alias analysis implementations; should support. This class exports two important enums: ``AliasResult`` and; ``ModRefResult`` which represent the result of an alias query or a mod/ref; query, respectively. The ``AliasAnalysis`` interface exposes information about memory, represented in; several different ways. In particular, memory objects are represented as a; starting address and size, and function calls are represented as the actual; ``call`` or ``invoke`` instructions that performs the call. The; ``AliasAnalysis`` interface also exposes some helper methods which allow you to; get mod/ref information for arbitrary instructions. All ``AliasAnalysis`` interfaces require that in queries involving multiple; values, values which are not :ref:`constants <constants>` are all; defined within the same function. Representation of Pointers; --------------------------. Most importantly, the ``AliasAnalysis`` class provides several methods which are; used to query whether or not two memory objects alias, whether function calls; can modify or read a memory object, etc. For all of these queries, memory; objects are represented as a pair of their starting address (a symbolic LLVM; ``Value*``) and a static size. Representing memory objects as a starting address and a size is critically; important for correct Alias Analyses. For example, consider this (silly, but; possible) C code:. .. code-block:: c++. int i;; char C[2];; char A[10];; /* ... */; for (i = 0; i != 10; ++i) {; C[0] = A[i]; /* One byte store */; C[1] = A[9-i]; /* One byte store */; }. In this c",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:3550,Security,access,accesses,3550,"s`` interfaces require that in queries involving multiple; values, values which are not :ref:`constants <constants>` are all; defined within the same function. Representation of Pointers; --------------------------. Most importantly, the ``AliasAnalysis`` class provides several methods which are; used to query whether or not two memory objects alias, whether function calls; can modify or read a memory object, etc. For all of these queries, memory; objects are represented as a pair of their starting address (a symbolic LLVM; ``Value*``) and a static size. Representing memory objects as a starting address and a size is critically; important for correct Alias Analyses. For example, consider this (silly, but; possible) C code:. .. code-block:: c++. int i;; char C[2];; char A[10];; /* ... */; for (i = 0; i != 10; ++i) {; C[0] = A[i]; /* One byte store */; C[1] = A[9-i]; /* One byte store */; }. In this case, the ``basic-aa`` pass will disambiguate the stores to ``C[0]`` and; ``C[1]`` because they are accesses to two distinct locations one byte apart, and; the accesses are each one byte. In this case, the Loop Invariant Code Motion; (LICM) pass can use store motion to remove the stores from the loop. In; contrast, the following code:. .. code-block:: c++. int i;; char C[2];; char A[10];; /* ... */; for (i = 0; i != 10; ++i) {; ((short*)C)[0] = A[i]; /* Two byte store! */; C[1] = A[9-i]; /* One byte store */; }. In this case, the two stores to C do alias each other, because the access to the; ``&C[0]`` element is a two byte access. If size information wasn't available in; the query, even the first case would have to conservatively assume that the; accesses alias. .. _alias:. The ``alias`` method; --------------------. The ``alias`` method is the primary interface used to determine whether or not; two memory objects alias each other. It takes two memory objects as input and; returns MustAlias, PartialAlias, MayAlias, or NoAlias as appropriate. Like all ``AliasAnalysis`` int",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:3610,Security,access,accesses,3610,"s`` interfaces require that in queries involving multiple; values, values which are not :ref:`constants <constants>` are all; defined within the same function. Representation of Pointers; --------------------------. Most importantly, the ``AliasAnalysis`` class provides several methods which are; used to query whether or not two memory objects alias, whether function calls; can modify or read a memory object, etc. For all of these queries, memory; objects are represented as a pair of their starting address (a symbolic LLVM; ``Value*``) and a static size. Representing memory objects as a starting address and a size is critically; important for correct Alias Analyses. For example, consider this (silly, but; possible) C code:. .. code-block:: c++. int i;; char C[2];; char A[10];; /* ... */; for (i = 0; i != 10; ++i) {; C[0] = A[i]; /* One byte store */; C[1] = A[9-i]; /* One byte store */; }. In this case, the ``basic-aa`` pass will disambiguate the stores to ``C[0]`` and; ``C[1]`` because they are accesses to two distinct locations one byte apart, and; the accesses are each one byte. In this case, the Loop Invariant Code Motion; (LICM) pass can use store motion to remove the stores from the loop. In; contrast, the following code:. .. code-block:: c++. int i;; char C[2];; char A[10];; /* ... */; for (i = 0; i != 10; ++i) {; ((short*)C)[0] = A[i]; /* Two byte store! */; C[1] = A[9-i]; /* One byte store */; }. In this case, the two stores to C do alias each other, because the access to the; ``&C[0]`` element is a two byte access. If size information wasn't available in; the query, even the first case would have to conservatively assume that the; accesses alias. .. _alias:. The ``alias`` method; --------------------. The ``alias`` method is the primary interface used to determine whether or not; two memory objects alias each other. It takes two memory objects as input and; returns MustAlias, PartialAlias, MayAlias, or NoAlias as appropriate. Like all ``AliasAnalysis`` int",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:4035,Security,access,access,4035,"their starting address (a symbolic LLVM; ``Value*``) and a static size. Representing memory objects as a starting address and a size is critically; important for correct Alias Analyses. For example, consider this (silly, but; possible) C code:. .. code-block:: c++. int i;; char C[2];; char A[10];; /* ... */; for (i = 0; i != 10; ++i) {; C[0] = A[i]; /* One byte store */; C[1] = A[9-i]; /* One byte store */; }. In this case, the ``basic-aa`` pass will disambiguate the stores to ``C[0]`` and; ``C[1]`` because they are accesses to two distinct locations one byte apart, and; the accesses are each one byte. In this case, the Loop Invariant Code Motion; (LICM) pass can use store motion to remove the stores from the loop. In; contrast, the following code:. .. code-block:: c++. int i;; char C[2];; char A[10];; /* ... */; for (i = 0; i != 10; ++i) {; ((short*)C)[0] = A[i]; /* Two byte store! */; C[1] = A[9-i]; /* One byte store */; }. In this case, the two stores to C do alias each other, because the access to the; ``&C[0]`` element is a two byte access. If size information wasn't available in; the query, even the first case would have to conservatively assume that the; accesses alias. .. _alias:. The ``alias`` method; --------------------. The ``alias`` method is the primary interface used to determine whether or not; two memory objects alias each other. It takes two memory objects as input and; returns MustAlias, PartialAlias, MayAlias, or NoAlias as appropriate. Like all ``AliasAnalysis`` interfaces, the ``alias`` method requires that either; the two pointer values be defined within the same function, or at least one of; the values is a :ref:`constant <constants>`. .. _Must, May, or No:. Must, May, and No Alias Responses; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``NoAlias`` response may be used when there is never an immediate dependence; between any memory reference *based* on one pointer and any memory reference; *based* the other. The most obvious example is when the two",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:4082,Security,access,access,4082,"their starting address (a symbolic LLVM; ``Value*``) and a static size. Representing memory objects as a starting address and a size is critically; important for correct Alias Analyses. For example, consider this (silly, but; possible) C code:. .. code-block:: c++. int i;; char C[2];; char A[10];; /* ... */; for (i = 0; i != 10; ++i) {; C[0] = A[i]; /* One byte store */; C[1] = A[9-i]; /* One byte store */; }. In this case, the ``basic-aa`` pass will disambiguate the stores to ``C[0]`` and; ``C[1]`` because they are accesses to two distinct locations one byte apart, and; the accesses are each one byte. In this case, the Loop Invariant Code Motion; (LICM) pass can use store motion to remove the stores from the loop. In; contrast, the following code:. .. code-block:: c++. int i;; char C[2];; char A[10];; /* ... */; for (i = 0; i != 10; ++i) {; ((short*)C)[0] = A[i]; /* Two byte store! */; C[1] = A[9-i]; /* One byte store */; }. In this case, the two stores to C do alias each other, because the access to the; ``&C[0]`` element is a two byte access. If size information wasn't available in; the query, even the first case would have to conservatively assume that the; accesses alias. .. _alias:. The ``alias`` method; --------------------. The ``alias`` method is the primary interface used to determine whether or not; two memory objects alias each other. It takes two memory objects as input and; returns MustAlias, PartialAlias, MayAlias, or NoAlias as appropriate. Like all ``AliasAnalysis`` interfaces, the ``alias`` method requires that either; the two pointer values be defined within the same function, or at least one of; the values is a :ref:`constant <constants>`. .. _Must, May, or No:. Must, May, and No Alias Responses; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``NoAlias`` response may be used when there is never an immediate dependence; between any memory reference *based* on one pointer and any memory reference; *based* the other. The most obvious example is when the two",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:4208,Security,access,accesses,4208,"size is critically; important for correct Alias Analyses. For example, consider this (silly, but; possible) C code:. .. code-block:: c++. int i;; char C[2];; char A[10];; /* ... */; for (i = 0; i != 10; ++i) {; C[0] = A[i]; /* One byte store */; C[1] = A[9-i]; /* One byte store */; }. In this case, the ``basic-aa`` pass will disambiguate the stores to ``C[0]`` and; ``C[1]`` because they are accesses to two distinct locations one byte apart, and; the accesses are each one byte. In this case, the Loop Invariant Code Motion; (LICM) pass can use store motion to remove the stores from the loop. In; contrast, the following code:. .. code-block:: c++. int i;; char C[2];; char A[10];; /* ... */; for (i = 0; i != 10; ++i) {; ((short*)C)[0] = A[i]; /* Two byte store! */; C[1] = A[9-i]; /* One byte store */; }. In this case, the two stores to C do alias each other, because the access to the; ``&C[0]`` element is a two byte access. If size information wasn't available in; the query, even the first case would have to conservatively assume that the; accesses alias. .. _alias:. The ``alias`` method; --------------------. The ``alias`` method is the primary interface used to determine whether or not; two memory objects alias each other. It takes two memory objects as input and; returns MustAlias, PartialAlias, MayAlias, or NoAlias as appropriate. Like all ``AliasAnalysis`` interfaces, the ``alias`` method requires that either; the two pointer values be defined within the same function, or at least one of; the values is a :ref:`constant <constants>`. .. _Must, May, or No:. Must, May, and No Alias Responses; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``NoAlias`` response may be used when there is never an immediate dependence; between any memory reference *based* on one pointer and any memory reference; *based* the other. The most obvious example is when the two pointers point to; non-overlapping memory ranges. Another is when the two pointers are only ever; used for reading memory. Anot",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:5213,Security,access,accesses,5213,"; --------------------. The ``alias`` method is the primary interface used to determine whether or not; two memory objects alias each other. It takes two memory objects as input and; returns MustAlias, PartialAlias, MayAlias, or NoAlias as appropriate. Like all ``AliasAnalysis`` interfaces, the ``alias`` method requires that either; the two pointer values be defined within the same function, or at least one of; the values is a :ref:`constant <constants>`. .. _Must, May, or No:. Must, May, and No Alias Responses; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``NoAlias`` response may be used when there is never an immediate dependence; between any memory reference *based* on one pointer and any memory reference; *based* the other. The most obvious example is when the two pointers point to; non-overlapping memory ranges. Another is when the two pointers are only ever; used for reading memory. Another is when the memory is freed and reallocated; between accesses through one pointer and accesses through the other --- in this; case, there is a dependence, but it's mediated by the free and reallocation. As an exception to this is with the :ref:`noalias <noalias>` keyword;; the ""irrelevant"" dependencies are ignored. The ``MayAlias`` response is used whenever the two pointers might refer to the; same object. The ``PartialAlias`` response is used when the two memory objects are known to; be overlapping in some way, regardless whether they start at the same address; or not. The ``MustAlias`` response may only be returned if the two memory objects are; guaranteed to always start at exactly the same location. A ``MustAlias``; response does not imply that the pointers compare equal. The ``getModRefInfo`` methods; -----------------------------. The ``getModRefInfo`` methods return information about whether the execution of; an instruction can read or modify a memory location. Mod/Ref information is; always conservative: if an instruction **might** read or write a location,; ``ModRef`` is ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:5246,Security,access,accesses,5246,"; --------------------. The ``alias`` method is the primary interface used to determine whether or not; two memory objects alias each other. It takes two memory objects as input and; returns MustAlias, PartialAlias, MayAlias, or NoAlias as appropriate. Like all ``AliasAnalysis`` interfaces, the ``alias`` method requires that either; the two pointer values be defined within the same function, or at least one of; the values is a :ref:`constant <constants>`. .. _Must, May, or No:. Must, May, and No Alias Responses; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``NoAlias`` response may be used when there is never an immediate dependence; between any memory reference *based* on one pointer and any memory reference; *based* the other. The most obvious example is when the two pointers point to; non-overlapping memory ranges. Another is when the two pointers are only ever; used for reading memory. Another is when the memory is freed and reallocated; between accesses through one pointer and accesses through the other --- in this; case, there is a dependence, but it's mediated by the free and reallocation. As an exception to this is with the :ref:`noalias <noalias>` keyword;; the ""irrelevant"" dependencies are ignored. The ``MayAlias`` response is used whenever the two pointers might refer to the; same object. The ``PartialAlias`` response is used when the two memory objects are known to; be overlapping in some way, regardless whether they start at the same address; or not. The ``MustAlias`` response may only be returned if the two memory objects are; guaranteed to always start at exactly the same location. A ``MustAlias``; response does not imply that the pointers compare equal. The ``getModRefInfo`` methods; -----------------------------. The ``getModRefInfo`` methods return information about whether the execution of; an instruction can read or modify a memory location. Mod/Ref information is; always conservative: if an instruction **might** read or write a location,; ``ModRef`` is ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:8161,Security,access,access,8161,"ge about whether the pointer points to; globally-constant memory (for which it returns ``NoModRef``) or; locally-invariant memory (for which it returns ``Ref``). Globally-constant; memory includes functions, constant global variables, and the null pointer.; Locally-invariant memory is memory that we know is invariant for the lifetime; of its SSA value, but not necessarily for the life of the program: for example,; the memory pointed to by ``readonly`` ``noalias`` parameters is known-invariant; for the duration of the corresponding function call. Given Mod/Ref information; ``MRI`` for a memory location ``Loc``, ``MRI`` can be refined with a statement; like ``MRI &= AA.getModRefInfoMask(Loc);``. Another useful idiom is; ``isModSet(AA.getModRefInfoMask(Loc))``; this checks to see if the given; location can be modified at all. For convenience, there is also a method; ``pointsToConstantMemory(Loc)``; this is synonymous with; ``isNoModRef(AA.getModRefInfoMask(Loc))``. .. _never access memory or only read memory:. The ``doesNotAccessMemory`` and ``onlyReadsMemory`` methods; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. These methods are used to provide very simple mod/ref information for function; calls. The ``doesNotAccessMemory`` method returns true for a function if the; analysis can prove that the function never reads or writes to memory, or if the; function only reads from constant memory. Functions with this property are; side-effect free and only depend on their input arguments, allowing them to be; eliminated if they form common subexpressions or be hoisted out of loops. Many; common functions behave this way (e.g., ``sin`` and ``cos``) but many others do; not (e.g., ``acos``, which modifies the ``errno`` variable). The ``onlyReadsMemory`` method returns true for a function if analysis can prove; that (at most) the function only reads from non-volatile memory. Functions with; this property are side-effect free, only depending on their input arguments",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:14093,Security,expose,exposes,14093,"tes. For example:. .. code-block:: c++. AliasResult alias(const Value *V1, unsigned V1Size,; const Value *V2, unsigned V2Size) {; if (...); return NoAlias;; ... // Couldn't determine a must or no-alias result.; return AliasAnalysis::alias(V1, V1Size, V2, V2Size);; }. In addition to analysis queries, you must make sure to unconditionally pass LLVM; `update notification`_ methods to the superclass as well if you override them,; which allows all alias analyses in a change to be updated. .. _update notification:. Updating analysis results for transformations; ---------------------------------------------. Alias analysis information is initially computed for a static snapshot of the; program, but clients will use this information to make transformations to the; code. All but the most trivial forms of alias analysis will need to have their; analysis results updated to reflect the changes made by these transformations. The ``AliasAnalysis`` interface exposes four methods which are used to; communicate program changes from the clients to the analysis implementations.; Various alias analysis implementations should use these methods to ensure that; their internal data structures are kept up-to-date as the program changes (for; example, when an instruction is deleted), and clients of alias analysis must be; sure to call these interfaces appropriately. The ``deleteValue`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``deleteValue`` method is called by transformations when they remove an; instruction or any other value from the program (including values that do not; use pointers). Typically alias analyses keep data structures that have entries; for each value in the program. When this method is called, they should remove; any entries for the specified value, if they exist. The ``copyValue`` method; ^^^^^^^^^^^^^^^^^^^^^^^^. The ``copyValue`` method is used when a new value is introduced into the; program. There is no way to introduce a value into the program that did not; exist befor",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:21891,Security,hash,hash,21891,"ets are properly folded due to call; instructions, and can provide a list of pointers in each set. As an example user of this, the `Loop Invariant Code Motion; <doxygen/structLICM.html>`_ pass uses ``AliasSetTracker``\s to calculate alias; sets for each loop nest. If an ``AliasSet`` in a loop is not modified, then all; load instructions from that set may be hoisted out of the loop. If any alias; sets are stored to **and** are must alias sets, then the stores may be sunk; to outside of the loop, promoting the memory location to a register for the; duration of the loop nest. Both of these transformations only apply if the; pointer argument is loop-invariant. The AliasSetTracker implementation; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The AliasSetTracker class is implemented to be as efficient as possible. It; uses the union-find algorithm to efficiently merge AliasSets when a pointer is; inserted into the AliasSetTracker that aliases multiple sets. The primary data; structure is a hash table mapping pointers to the AliasSet they are in. The AliasSetTracker class must maintain a list of all of the LLVM ``Value*``\s; that are in each AliasSet. Since the hash table already has entries for each; LLVM ``Value*`` of interest, the AliasesSets thread the linked list through; these hash-table nodes to avoid having to allocate memory unnecessarily, and to; make merging alias sets extremely efficient (the linked list merge is constant; time). You shouldn't need to understand these details if you are just a client of the; AliasSetTracker, but if you look at the code, hopefully this brief description; will help make sense of why things are designed the way they are. Using the ``AliasAnalysis`` interface directly; ----------------------------------------------. If neither of these utility class are what your pass needs, you should use the; interfaces exposed by the ``AliasAnalysis`` class directly. Try to use the; higher-level methods when possible (e.g., use mod/ref information instead",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:22065,Security,hash,hash,22065," modified, then all; load instructions from that set may be hoisted out of the loop. If any alias; sets are stored to **and** are must alias sets, then the stores may be sunk; to outside of the loop, promoting the memory location to a register for the; duration of the loop nest. Both of these transformations only apply if the; pointer argument is loop-invariant. The AliasSetTracker implementation; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The AliasSetTracker class is implemented to be as efficient as possible. It; uses the union-find algorithm to efficiently merge AliasSets when a pointer is; inserted into the AliasSetTracker that aliases multiple sets. The primary data; structure is a hash table mapping pointers to the AliasSet they are in. The AliasSetTracker class must maintain a list of all of the LLVM ``Value*``\s; that are in each AliasSet. Since the hash table already has entries for each; LLVM ``Value*`` of interest, the AliasesSets thread the linked list through; these hash-table nodes to avoid having to allocate memory unnecessarily, and to; make merging alias sets extremely efficient (the linked list merge is constant; time). You shouldn't need to understand these details if you are just a client of the; AliasSetTracker, but if you look at the code, hopefully this brief description; will help make sense of why things are designed the way they are. Using the ``AliasAnalysis`` interface directly; ----------------------------------------------. If neither of these utility class are what your pass needs, you should use the; interfaces exposed by the ``AliasAnalysis`` class directly. Try to use the; higher-level methods when possible (e.g., use mod/ref information instead of the; `alias`_ method directly if possible) to get the best precision and efficiency. Existing alias analysis implementations and clients; ===================================================. If you're going to be working with the LLVM alias analysis infrastructure, you; should know what clients ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:22189,Security,hash,hash-table,22189," modified, then all; load instructions from that set may be hoisted out of the loop. If any alias; sets are stored to **and** are must alias sets, then the stores may be sunk; to outside of the loop, promoting the memory location to a register for the; duration of the loop nest. Both of these transformations only apply if the; pointer argument is loop-invariant. The AliasSetTracker implementation; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The AliasSetTracker class is implemented to be as efficient as possible. It; uses the union-find algorithm to efficiently merge AliasSets when a pointer is; inserted into the AliasSetTracker that aliases multiple sets. The primary data; structure is a hash table mapping pointers to the AliasSet they are in. The AliasSetTracker class must maintain a list of all of the LLVM ``Value*``\s; that are in each AliasSet. Since the hash table already has entries for each; LLVM ``Value*`` of interest, the AliasesSets thread the linked list through; these hash-table nodes to avoid having to allocate memory unnecessarily, and to; make merging alias sets extremely efficient (the linked list merge is constant; time). You shouldn't need to understand these details if you are just a client of the; AliasSetTracker, but if you look at the code, hopefully this brief description; will help make sense of why things are designed the way they are. Using the ``AliasAnalysis`` interface directly; ----------------------------------------------. If neither of these utility class are what your pass needs, you should use the; interfaces exposed by the ``AliasAnalysis`` class directly. Try to use the; higher-level methods when possible (e.g., use mod/ref information instead of the; `alias`_ method directly if possible) to get the best precision and efficiency. Existing alias analysis implementations and clients; ===================================================. If you're going to be working with the LLVM alias analysis infrastructure, you; should know what clients ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:22764,Security,expose,exposed,22764,"thm to efficiently merge AliasSets when a pointer is; inserted into the AliasSetTracker that aliases multiple sets. The primary data; structure is a hash table mapping pointers to the AliasSet they are in. The AliasSetTracker class must maintain a list of all of the LLVM ``Value*``\s; that are in each AliasSet. Since the hash table already has entries for each; LLVM ``Value*`` of interest, the AliasesSets thread the linked list through; these hash-table nodes to avoid having to allocate memory unnecessarily, and to; make merging alias sets extremely efficient (the linked list merge is constant; time). You shouldn't need to understand these details if you are just a client of the; AliasSetTracker, but if you look at the code, hopefully this brief description; will help make sense of why things are designed the way they are. Using the ``AliasAnalysis`` interface directly; ----------------------------------------------. If neither of these utility class are what your pass needs, you should use the; interfaces exposed by the ``AliasAnalysis`` class directly. Try to use the; higher-level methods when possible (e.g., use mod/ref information instead of the; `alias`_ method directly if possible) to get the best precision and efficiency. Existing alias analysis implementations and clients; ===================================================. If you're going to be working with the LLVM alias analysis infrastructure, you; should know what clients and implementations of alias analysis are available.; In particular, if you are implementing an alias analysis, you should be aware of; the `the clients`_ that are useful for monitoring and evaluating different; implementations. .. _various alias analysis implementations:. Available ``AliasAnalysis`` implementations; -------------------------------------------. This section lists the various implementations of the ``AliasAnalysis``; interface. All of these :ref:`chain <aliasanalysis-chaining>` to other; alias analysis implementations.",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:24216,Security,access,access,24216,"plementations of alias analysis are available.; In particular, if you are implementing an alias analysis, you should be aware of; the `the clients`_ that are useful for monitoring and evaluating different; implementations. .. _various alias analysis implementations:. Available ``AliasAnalysis`` implementations; -------------------------------------------. This section lists the various implementations of the ``AliasAnalysis``; interface. All of these :ref:`chain <aliasanalysis-chaining>` to other; alias analysis implementations. The ``-basic-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^^. The ``-basic-aa`` pass is an aggressive local analysis that *knows* many; important facts:. * Distinct globals, stack allocations, and heap allocations can never alias.; * Globals, stack allocations, and heap allocations never alias the null pointer.; * Different fields of a structure do not alias.; * Indexes into arrays with statically differing subscripts cannot alias.; * Many common standard C library functions `never access memory or only read; memory`_.; * Pointers that obviously point to constant globals ""``pointToConstantMemory``"".; * Function calls can not modify or references stack allocations if they never; escape from the function that allocates them (a common case for automatic; arrays). The ``-globalsmodref-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This pass implements a simple context-sensitive mod/ref and alias analysis for; internal global variables that don't ""have their address taken"". If a global; does not have its address taken, the pass knows that no pointers alias the; global. This pass also keeps track of functions that it knows never access; memory or never read memory. This allows certain optimizations (e.g. GVN) to; eliminate call instructions entirely. The real power of this pass is that it provides context-sensitive mod/ref; information for call instructions. This allows the optimizer to know that calls; to a function do not clobber or read the value of the global, a",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:24866,Security,access,access,24866,"nows* many; important facts:. * Distinct globals, stack allocations, and heap allocations can never alias.; * Globals, stack allocations, and heap allocations never alias the null pointer.; * Different fields of a structure do not alias.; * Indexes into arrays with statically differing subscripts cannot alias.; * Many common standard C library functions `never access memory or only read; memory`_.; * Pointers that obviously point to constant globals ""``pointToConstantMemory``"".; * Function calls can not modify or references stack allocations if they never; escape from the function that allocates them (a common case for automatic; arrays). The ``-globalsmodref-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This pass implements a simple context-sensitive mod/ref and alias analysis for; internal global variables that don't ""have their address taken"". If a global; does not have its address taken, the pass knows that no pointers alias the; global. This pass also keeps track of functions that it knows never access; memory or never read memory. This allows certain optimizations (e.g. GVN) to; eliminate call instructions entirely. The real power of this pass is that it provides context-sensitive mod/ref; information for call instructions. This allows the optimizer to know that calls; to a function do not clobber or read the value of the global, allowing loads and; stores to be eliminated. .. note::. This pass is somewhat limited in its scope (only support non-address taken; globals), but is very quick analysis. The ``-steens-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^^^. The ``-steens-aa`` pass implements a variation on the well-known ""Steensgaard's; algorithm"" for interprocedural alias analysis. Steensgaard's algorithm is a; unification-based, flow-insensitive, context-insensitive, and field-insensitive; alias analysis that is also very scalable (effectively linear time). The LLVM ``-steens-aa`` pass implements a ""speculatively field-**sensitive**""; version of Steensgaard's algorithm usin",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:29265,Security,expose,exposed,29265,"-reference arguments to be passed in; by-value instead. In particular, if pointer arguments are only loaded from it; passes in the value loaded instead of the address to the function. This pass; uses alias information to make sure that the value loaded from the argument; pointer is not modified between the entry of the function and any load of the; pointer. The ``-gvn``, ``-memcpyopt``, and ``-dse`` passes; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. These passes use AliasAnalysis information to reason about loads and stores. .. _the clients:. Clients for debugging and evaluation of implementations; -------------------------------------------------------. These passes are useful for evaluating the various alias analysis; implementations. You can use them with commands like:. .. code-block:: bash. % opt -ds-aa -aa-eval foo.bc -disable-output -stats. The ``-print-alias-sets`` pass; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``-print-alias-sets`` pass is exposed as part of the ``opt`` tool to print; out the Alias Sets formed by the `AliasSetTracker`_ class. This is useful if; you're using the ``AliasSetTracker`` class. To use it, use something like:. .. code-block:: bash. % opt -ds-aa -print-alias-sets -disable-output. The ``-aa-eval`` pass; ^^^^^^^^^^^^^^^^^^^^^. The ``-aa-eval`` pass simply iterates through all pairs of pointers in a; function and asks an alias analysis whether or not the pointers alias. This; gives an indication of the precision of the alias analysis. Statistics are; printed indicating the percent of no/may/must aliases found (a more precise; algorithm will have a lower number of may aliases). Memory Dependence Analysis; ==========================. .. note::. We are currently in the process of migrating things from; ``MemoryDependenceAnalysis`` to :doc:`MemorySSA`. Please try to use; that instead. If you're just looking to be a client of alias analysis information, consider; using the Memory Dependence Analysis interface instead. MemDep is a lazy,; c",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:30586,Security,access,accessing,30586,"ction and any load of the; pointer. The ``-gvn``, ``-memcpyopt``, and ``-dse`` passes; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. These passes use AliasAnalysis information to reason about loads and stores. .. _the clients:. Clients for debugging and evaluation of implementations; -------------------------------------------------------. These passes are useful for evaluating the various alias analysis; implementations. You can use them with commands like:. .. code-block:: bash. % opt -ds-aa -aa-eval foo.bc -disable-output -stats. The ``-print-alias-sets`` pass; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``-print-alias-sets`` pass is exposed as part of the ``opt`` tool to print; out the Alias Sets formed by the `AliasSetTracker`_ class. This is useful if; you're using the ``AliasSetTracker`` class. To use it, use something like:. .. code-block:: bash. % opt -ds-aa -print-alias-sets -disable-output. The ``-aa-eval`` pass; ^^^^^^^^^^^^^^^^^^^^^. The ``-aa-eval`` pass simply iterates through all pairs of pointers in a; function and asks an alias analysis whether or not the pointers alias. This; gives an indication of the precision of the alias analysis. Statistics are; printed indicating the percent of no/may/must aliases found (a more precise; algorithm will have a lower number of may aliases). Memory Dependence Analysis; ==========================. .. note::. We are currently in the process of migrating things from; ``MemoryDependenceAnalysis`` to :doc:`MemorySSA`. Please try to use; that instead. If you're just looking to be a client of alias analysis information, consider; using the Memory Dependence Analysis interface instead. MemDep is a lazy,; caching layer on top of alias analysis that is able to answer the question of; what preceding memory operations a given instruction depends on, either at an; intra- or inter-block level. Because of its laziness and caching policy, using; MemDep can be a significant performance win over accessing alias analysis; directly.; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:1594,Testability,test,test,1594,"fication-based vs. subset-based, etc. Traditionally,; alias analyses respond to a query with a `Must, May, or No`_ alias response,; indicating that two pointers always point to the same object, might point to the; same object, or are known to never point to the same object. The LLVM `AliasAnalysis; <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`__ class is the; primary interface used by clients and implementations of alias analyses in the; LLVM system. This class is the common interface between clients of alias; analysis information and the implementations providing it, and is designed to; support a wide range of implementations and clients (but currently all clients; are assumed to be flow-insensitive). In addition to simple alias analysis; information, this class exposes Mod/Ref information from those implementations; which can provide it, allowing for powerful analyses and transformations to work; well together. This document contains information necessary to successfully implement this; interface, use it, and to test both sides. It also explains some of the finer; points about what exactly results mean. ``AliasAnalysis`` Class Overview; ================================. The `AliasAnalysis <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`__; class defines the interface that the various alias analysis implementations; should support. This class exports two important enums: ``AliasResult`` and; ``ModRefResult`` which represent the result of an alias query or a mod/ref; query, respectively. The ``AliasAnalysis`` interface exposes information about memory, represented in; several different ways. In particular, memory objects are represented as a; starting address and size, and function calls are represented as the actual; ``call`` or ``invoke`` instructions that performs the call. The; ``AliasAnalysis`` interface also exposes some helper methods which allow you to; get mod/ref information for arbitrary instructions. All ``AliasAnalysis`` interfa",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:6340,Testability,test,testing,6340,"ediated by the free and reallocation. As an exception to this is with the :ref:`noalias <noalias>` keyword;; the ""irrelevant"" dependencies are ignored. The ``MayAlias`` response is used whenever the two pointers might refer to the; same object. The ``PartialAlias`` response is used when the two memory objects are known to; be overlapping in some way, regardless whether they start at the same address; or not. The ``MustAlias`` response may only be returned if the two memory objects are; guaranteed to always start at exactly the same location. A ``MustAlias``; response does not imply that the pointers compare equal. The ``getModRefInfo`` methods; -----------------------------. The ``getModRefInfo`` methods return information about whether the execution of; an instruction can read or modify a memory location. Mod/Ref information is; always conservative: if an instruction **might** read or write a location,; ``ModRef`` is returned. The ``AliasAnalysis`` class also provides a ``getModRefInfo`` method for testing; dependencies between function calls. This method takes two call sites (``CS1``; & ``CS2``), returns ``NoModRef`` if neither call writes to memory read or; written by the other, ``Ref`` if ``CS1`` reads memory written by ``CS2``,; ``Mod`` if ``CS1`` writes to memory read or written by ``CS2``, or ``ModRef`` if; ``CS1`` might read or write memory written to by ``CS2``. Note that this; relation is not commutative. Other useful ``AliasAnalysis`` methods; --------------------------------------. Several other tidbits of information are often collected by various alias; analysis implementations and can be put to good use by various clients. The ``getModRefInfoMask`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``getModRefInfoMask`` method returns a bound on Mod/Ref information for; the supplied pointer, based on knowledge about whether the pointer points to; globally-constant memory (for which it returns ``NoModRef``) or; locally-invariant memory (for which it returns ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:26445,Testability,log,log,26445," but is very quick analysis. The ``-steens-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^^^. The ``-steens-aa`` pass implements a variation on the well-known ""Steensgaard's; algorithm"" for interprocedural alias analysis. Steensgaard's algorithm is a; unification-based, flow-insensitive, context-insensitive, and field-insensitive; alias analysis that is also very scalable (effectively linear time). The LLVM ``-steens-aa`` pass implements a ""speculatively field-**sensitive**""; version of Steensgaard's algorithm using the Data Structure Analysis framework.; This gives it substantially more precision than the standard algorithm while; maintaining excellent analysis scalability. .. note::. ``-steens-aa`` is available in the optional ""poolalloc"" module. It is not part; of the LLVM core. The ``-ds-aa`` pass; ^^^^^^^^^^^^^^^^^^^. The ``-ds-aa`` pass implements the full Data Structure Analysis algorithm. Data; Structure Analysis is a modular unification-based, flow-insensitive,; context-**sensitive**, and speculatively field-**sensitive** alias; analysis that is also quite scalable, usually at ``O(n * log(n))``. This algorithm is capable of responding to a full variety of alias analysis; queries, and can provide context-sensitive mod/ref information as well. The; only major facility not implemented so far is support for must-alias; information. .. note::. ``-ds-aa`` is available in the optional ""poolalloc"" module. It is not part of; the LLVM core. The ``-scev-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^. The ``-scev-aa`` pass implements AliasAnalysis queries by translating them into; ScalarEvolution queries. This gives it a more complete understanding of; ``getelementptr`` instructions and loop induction variables than other alias; analyses have. Alias analysis driven transformations; -------------------------------------. LLVM includes several alias-analysis driven transformations which can be used; with any of the implementations above. The ``-adce`` pass; ^^^^^^^^^^^^^^^^^^. The ``-adce`` pass, wh",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:1291,Usability,simpl,simple,1291,"d many; different ways of classifying them: flow-sensitive vs. flow-insensitive,; context-sensitive vs. context-insensitive, field-sensitive; vs. field-insensitive, unification-based vs. subset-based, etc. Traditionally,; alias analyses respond to a query with a `Must, May, or No`_ alias response,; indicating that two pointers always point to the same object, might point to the; same object, or are known to never point to the same object. The LLVM `AliasAnalysis; <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`__ class is the; primary interface used by clients and implementations of alias analyses in the; LLVM system. This class is the common interface between clients of alias; analysis information and the implementations providing it, and is designed to; support a wide range of implementations and clients (but currently all clients; are assumed to be flow-insensitive). In addition to simple alias analysis; information, this class exposes Mod/Ref information from those implementations; which can provide it, allowing for powerful analyses and transformations to work; well together. This document contains information necessary to successfully implement this; interface, use it, and to test both sides. It also explains some of the finer; points about what exactly results mean. ``AliasAnalysis`` Class Overview; ================================. The `AliasAnalysis <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`__; class defines the interface that the various alias analysis implementations; should support. This class exports two important enums: ``AliasResult`` and; ``ModRefResult`` which represent the result of an alias query or a mod/ref; query, respectively. The ``AliasAnalysis`` interface exposes information about memory, represented in; several different ways. In particular, memory objects are represented as a; starting address and size, and function calls are represented as the actual; ``call`` or ``invoke`` instructions that performs the call. ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:8359,Usability,simpl,simple,8359,"includes functions, constant global variables, and the null pointer.; Locally-invariant memory is memory that we know is invariant for the lifetime; of its SSA value, but not necessarily for the life of the program: for example,; the memory pointed to by ``readonly`` ``noalias`` parameters is known-invariant; for the duration of the corresponding function call. Given Mod/Ref information; ``MRI`` for a memory location ``Loc``, ``MRI`` can be refined with a statement; like ``MRI &= AA.getModRefInfoMask(Loc);``. Another useful idiom is; ``isModSet(AA.getModRefInfoMask(Loc))``; this checks to see if the given; location can be modified at all. For convenience, there is also a method; ``pointsToConstantMemory(Loc)``; this is synonymous with; ``isNoModRef(AA.getModRefInfoMask(Loc))``. .. _never access memory or only read memory:. The ``doesNotAccessMemory`` and ``onlyReadsMemory`` methods; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. These methods are used to provide very simple mod/ref information for function; calls. The ``doesNotAccessMemory`` method returns true for a function if the; analysis can prove that the function never reads or writes to memory, or if the; function only reads from constant memory. Functions with this property are; side-effect free and only depend on their input arguments, allowing them to be; eliminated if they form common subexpressions or be hoisted out of loops. Many; common functions behave this way (e.g., ``sin`` and ``cos``) but many others do; not (e.g., ``acos``, which modifies the ``errno`` variable). The ``onlyReadsMemory`` method returns true for a function if analysis can prove; that (at most) the function only reads from non-volatile memory. Functions with; this property are side-effect free, only depending on their input arguments and; the state of memory when they are called. This property allows calls to these; functions to be eliminated and moved around, as long as there is no store; instruction that changes the",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:13092,Usability,simpl,simply,13092,"y be specified; ---------------------------------. All of the `AliasAnalysis; <https://llvm.org/doxygen/classllvm_1_1AliasAnalysis.html>`__ virtual methods; default to providing :ref:`chaining <aliasanalysis-chaining>` to another alias; analysis implementation, which ends up returning conservatively correct; information (returning ""May"" Alias and ""Mod/Ref"" for alias and mod/ref queries; respectively). Depending on the capabilities of the analysis you are; implementing, you just override the interfaces you can improve. .. _aliasanalysis-chaining:. ``AliasAnalysis`` chaining behavior; -----------------------------------. Every alias analysis pass chains to another alias analysis implementation (for; example, the user can specify ""``-basic-aa -ds-aa -licm``"" to get the maximum; benefit from both alias analyses). The alias analysis class automatically; takes care of most of this for methods that you don't override. For methods; that you do override, in code paths that return a conservative MayAlias or; Mod/Ref result, simply return whatever the superclass computes. For example:. .. code-block:: c++. AliasResult alias(const Value *V1, unsigned V1Size,; const Value *V2, unsigned V2Size) {; if (...); return NoAlias;; ... // Couldn't determine a must or no-alias result.; return AliasAnalysis::alias(V1, V1Size, V2, V2Size);; }. In addition to analysis queries, you must make sure to unconditionally pass LLVM; `update notification`_ methods to the superclass as well if you override them,; which allows all alias analyses in a change to be updated. .. _update notification:. Updating analysis results for transformations; ---------------------------------------------. Alias analysis information is initially computed for a static snapshot of the; program, but clients will use this information to make transformations to the; code. All but the most trivial forms of alias analysis will need to have their; analysis results updated to reflect the changes made by these transformations. Th",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:15440,Usability,simpl,simple,15440," these interfaces appropriately. The ``deleteValue`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``deleteValue`` method is called by transformations when they remove an; instruction or any other value from the program (including values that do not; use pointers). Typically alias analyses keep data structures that have entries; for each value in the program. When this method is called, they should remove; any entries for the specified value, if they exist. The ``copyValue`` method; ^^^^^^^^^^^^^^^^^^^^^^^^. The ``copyValue`` method is used when a new value is introduced into the; program. There is no way to introduce a value into the program that did not; exist before (this doesn't make sense for a safe compiler transformation), so; this is the only way to introduce a new value. This method indicates that the; new value has exactly the same properties as the value being copied. The ``replaceWithNewValue`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This method is a simple helper method that is provided to make clients easier to; use. It is implemented by copying the old analysis information to the new; value, then deleting the old value. This method cannot be overridden by alias; analysis implementations. The ``addEscapingUse`` method; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``addEscapingUse`` method is used when the uses of a pointer value have; changed in ways that may invalidate precomputed analysis information.; Implementations may either use this callback to provide conservative responses; for points whose uses have change since analysis time, or may recompute some or; all of their internal state to continue providing accurate responses. In general, any new use of a pointer value is considered an escaping use, and; must be reported through this callback, *except* for the uses below:. * A ``bitcast`` or ``getelementptr`` of the pointer; * A ``store`` through the pointer (but not a ``store`` *of* the pointer); * A ``load`` through the pointer. Efficiency Issues; -----------",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:20520,Usability,simpl,simply,20520,"sis to provide high-level dependence; information about memory-using instructions. This will tell you which store; feeds into a load, for example. It uses caching and other techniques to be; efficient, and is used by Dead Store Elimination, GVN, and memcpy optimizations. .. _AliasSetTracker:. Using the ``AliasSetTracker`` class; -----------------------------------. Many transformations need information about alias **sets** that are active in; some scope, rather than information about pairwise aliasing. The; `AliasSetTracker <https://llvm.org/doxygen/classllvm_1_1AliasSetTracker.html>`__; class is used to efficiently build these Alias Sets from the pairwise alias; analysis information provided by the ``AliasAnalysis`` interface. First you initialize the AliasSetTracker by using the ""``add``"" methods to add; information about various potentially aliasing instructions in the scope you are; interested in. Once all of the alias sets are completed, your pass should; simply iterate through the constructed alias sets, using the ``AliasSetTracker``; ``begin()``/``end()`` methods. The ``AliasSet``\s formed by the ``AliasSetTracker`` are guaranteed to be; disjoint, calculate mod/ref information and volatility for the set, and keep; track of whether or not all of the pointers in the set are Must aliases. The; AliasSetTracker also makes sure that sets are properly folded due to call; instructions, and can provide a list of pointers in each set. As an example user of this, the `Loop Invariant Code Motion; <doxygen/structLICM.html>`_ pass uses ``AliasSetTracker``\s to calculate alias; sets for each loop nest. If an ``AliasSet`` in a loop is not modified, then all; load instructions from that set may be hoisted out of the loop. If any alias; sets are stored to **and** are must alias sets, then the stores may be sunk; to outside of the loop, promoting the memory location to a register for the; duration of the loop nest. Both of these transformations only apply if the; pointer argumen",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:24587,Usability,simpl,simple,24587,"``; interface. All of these :ref:`chain <aliasanalysis-chaining>` to other; alias analysis implementations. The ``-basic-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^^. The ``-basic-aa`` pass is an aggressive local analysis that *knows* many; important facts:. * Distinct globals, stack allocations, and heap allocations can never alias.; * Globals, stack allocations, and heap allocations never alias the null pointer.; * Different fields of a structure do not alias.; * Indexes into arrays with statically differing subscripts cannot alias.; * Many common standard C library functions `never access memory or only read; memory`_.; * Pointers that obviously point to constant globals ""``pointToConstantMemory``"".; * Function calls can not modify or references stack allocations if they never; escape from the function that allocates them (a common case for automatic; arrays). The ``-globalsmodref-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. This pass implements a simple context-sensitive mod/ref and alias analysis for; internal global variables that don't ""have their address taken"". If a global; does not have its address taken, the pass knows that no pointers alias the; global. This pass also keeps track of functions that it knows never access; memory or never read memory. This allows certain optimizations (e.g. GVN) to; eliminate call instructions entirely. The real power of this pass is that it provides context-sensitive mod/ref; information for call instructions. This allows the optimizer to know that calls; to a function do not clobber or read the value of the global, allowing loads and; stores to be eliminated. .. note::. This pass is somewhat limited in its scope (only support non-address taken; globals), but is very quick analysis. The ``-steens-aa`` pass; ^^^^^^^^^^^^^^^^^^^^^^^. The ``-steens-aa`` pass implements a variation on the well-known ""Steensgaard's; algorithm"" for interprocedural alias analysis. Steensgaard's algorithm is a; unification-based, flow-insensitive, context-insen",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst:29603,Usability,simpl,simply,29603,"ction and any load of the; pointer. The ``-gvn``, ``-memcpyopt``, and ``-dse`` passes; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. These passes use AliasAnalysis information to reason about loads and stores. .. _the clients:. Clients for debugging and evaluation of implementations; -------------------------------------------------------. These passes are useful for evaluating the various alias analysis; implementations. You can use them with commands like:. .. code-block:: bash. % opt -ds-aa -aa-eval foo.bc -disable-output -stats. The ``-print-alias-sets`` pass; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. The ``-print-alias-sets`` pass is exposed as part of the ``opt`` tool to print; out the Alias Sets formed by the `AliasSetTracker`_ class. This is useful if; you're using the ``AliasSetTracker`` class. To use it, use something like:. .. code-block:: bash. % opt -ds-aa -print-alias-sets -disable-output. The ``-aa-eval`` pass; ^^^^^^^^^^^^^^^^^^^^^. The ``-aa-eval`` pass simply iterates through all pairs of pointers in a; function and asks an alias analysis whether or not the pointers alias. This; gives an indication of the precision of the alias analysis. Statistics are; printed indicating the percent of no/may/must aliases found (a more precise; algorithm will have a lower number of may aliases). Memory Dependence Analysis; ==========================. .. note::. We are currently in the process of migrating things from; ``MemoryDependenceAnalysis`` to :doc:`MemorySSA`. Please try to use; that instead. If you're just looking to be a client of alias analysis information, consider; using the Memory Dependence Analysis interface instead. MemDep is a lazy,; caching layer on top of alias analysis that is able to answer the question of; what preceding memory operations a given instruction depends on, either at an; intra- or inter-block level. Because of its laziness and caching policy, using; MemDep can be a significant performance win over accessing alias analysis; directly.; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AliasAnalysis.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AliasAnalysis.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:1634,Availability,avail,available,1634,"n in a high level; language such as C++ or Fortran with OpenMP pragmas, OpenCL, or HIP (a portable; C++ programming environment for heterogeneous computing [:ref:`HIP; <amdgpu-dwarf-HIP>`]). A heterogeneous compiler and runtime allows a program to; execute on multiple devices within the same native process. Devices could; include CPUs, GPUs, DSPs, FPGAs, or other special purpose accelerators.; Currently HIP programs execute on systems with CPUs and GPUs. The AMD [:ref:`AMD <amdgpu-dwarf-AMD>`] ROCm platform [:ref:`AMD-ROCm; <amdgpu-dwarf-AMD-ROCm>`] is an implementation of the industry standard for; heterogeneous computing devices defined by the Heterogeneous System Architecture; (HSA) Foundation [:ref:`HSA <amdgpu-dwarf-HSA>`]. It is open sourced and; includes contributions to open source projects such as LLVM [:ref:`LLVM; <amdgpu-dwarf-LLVM>`] for compilation and GDB for debugging [:ref:`GDB; <amdgpu-dwarf-GDB>`]. The LLVM compiler has upstream support for commercially available AMD GPU; hardware (AMDGPU) [:ref:`AMDGPU-LLVM <amdgpu-dwarf-AMDGPU-LLVM>`]. The open; source ROCgdb [:ref:`AMD-ROCgdb <amdgpu-dwarf-AMD-ROCgdb>`] GDB based debugger; also has support for AMDGPU which is being upstreamed. Support for AMDGPU is; also being added by third parties to the GCC [:ref:`GCC <amdgpu-dwarf-GCC>`]; compiler and the Perforce TotalView HPC Debugger [:ref:`Perforce-TotalView; <amdgpu-dwarf-Perforce-TotalView>`]. To support debugging heterogeneous programs several features that are not; provided by current DWARF Version 5 [:ref:`DWARF <amdgpu-dwarf-DWARF>`] have; been identified. The :ref:`amdgpu-dwarf-extensions` section gives an overview of; the extensions devised to address the missing features. The extensions seek to; be general in nature and backwards compatible with DWARF Version 5. Their goal; is to be applicable to meeting the needs of any heterogeneous system and not be; vendor or architecture specific. That is followed by appendix; :ref:`amdgpu-dwarf-changes-rel",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:11661,Availability,error,error,11661,"ize Offsetting of Location Descriptions; --------------------------------------------------. The ``DW_OP_plus`` and ``DW_OP_minus`` operations can be defined to operate on a; memory location description in the default target architecture specific address; space and a generic type value to produce an updated memory location; description. This allows them to continue to be used to offset an address. To generalize offsetting to any location description, including location; descriptions that describe when bytes are in registers, are implicit, or a; composite of these, the ``DW_OP_LLVM_offset``, ``DW_OP_LLVM_offset_uconst``, and; ``DW_OP_LLVM_bit_offset`` offset operations are added. The offset operations can operate on location storage of any size. For example,; implicit location storage could be any number of bits in size. It is simpler to; define offsets that exceed the size of the location storage as being an; evaluation error, than having to force an implementation to support potentially; infinite precision offsets to allow it to correctly track a series of positive; and negative offsets that may transiently overflow or underflow, but end up in; range. This is simple for the arithmetic operations as they are defined in terms; of two's complement arithmetic on a base type of a fixed size. Therefore, the; offset operation define that integer overflow is ill-formed. This is in contrast; to the ``DW_OP_plus``, ``DW_OP_plus_uconst``, and ``DW_OP_minus`` arithmetic; operations which define that it causes wrap-around. Having the offset operations allows ``DW_OP_push_object_address`` to push a; location description that may be in a register, or be an implicit value. The; DWARF expression of ``DW_TAG_ptr_to_member_type`` can use the offset operations; without regard to what kind of location description was pushed. Since; :ref:`amdgpu-dwarf-allow-location-description-on-the-dwarf-evaluation-stack` has; generalized location storage to be bit indexable, ``DW_OP_LLVM_bit_offset``",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:24970,Availability,mask,mask,24970,"register, rather than a separate expression for each lane's; dword of the vector register. It also allows the compiler to produce DWARF; that indexes the vector register if it spills scalar registers into portions; of a vector register. Since DWARF stack value entries have a base type and AMDGPU registers are a; vector of dwords, the ability to specify that a base type is a vector is; required. See ``DW_AT_LLVM_vector_size`` in :ref:`amdgpu-dwarf-base-type-entries`. .. _amdgpu-dwarf-operation-to-create-vector-composite-location-descriptions:. 2.10 DWARF Operations to Create Vector Composite Location Descriptions; ----------------------------------------------------------------------. AMDGPU optimized code may spill vector registers to non-global address space; memory, and this spilling may be done only for SIMT lanes that are active on; entry to the subprogram. To support this the CFI rule for the partially spilled; register needs to use an expression that uses the EXEC register as a bit mask to; select between the register (for inactive lanes) and the stack spill location; (for active lanes that are spilled). This needs to evaluate to a location; description, and not a value, as a debugger needs to change the value if the; user assigns to the variable. Another usage is to create an expression that evaluates to provide a vector of; logical PCs for active and inactive lanes in a SIMT execution model. Again the; EXEC register is used to select between active and inactive PC values. In order; to represent a vector of PC values, a way to create a composite location; description that is a vector of a single location is used. It may be possible to use existing DWARF to incrementally build the composite; location description, possibly using the DWARF operations for control flow to; create a loop. However, for the AMDGPU that would require loop iteration of 64.; A concern is that the resulting DWARF would have a significant size and would be; reasonably common as it is need",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:26242,Availability,mask,masked,26242,"er assigns to the variable. Another usage is to create an expression that evaluates to provide a vector of; logical PCs for active and inactive lanes in a SIMT execution model. Again the; EXEC register is used to select between active and inactive PC values. In order; to represent a vector of PC values, a way to create a composite location; description that is a vector of a single location is used. It may be possible to use existing DWARF to incrementally build the composite; location description, possibly using the DWARF operations for control flow to; create a loop. However, for the AMDGPU that would require loop iteration of 64.; A concern is that the resulting DWARF would have a significant size and would be; reasonably common as it is needed for every vector register that is spilled in a; function. AMDGPU can have up to 512 vector registers. Another concern is the; time taken to evaluate such non-trivial expressions repeatedly. To avoid these issues, a composite location description that can be created as a; masked select is proposed. In addition, an operation that creates a composite; location description that is a vector on another location description is needed.; These operations generate the composite location description using a single; DWARF operation that combines all lanes of the vector in one step. The DWARF; expression is more compact, and can be evaluated by a consumer far more; efficiently. An example that uses these operations is referenced in the; :ref:`amdgpu-dwarf-further-examples` appendix. See ``DW_OP_LLVM_select_bit_piece`` and ``DW_OP_LLVM_extend`` in; :ref:`amdgpu-dwarf-composite-location-description-operations`. 2.11 DWARF Operation to Access Call Frame Entry Registers; ---------------------------------------------------------. As described in; :ref:`amdgpu-dwarf-operation-to-create-vector-composite-location-descriptions`,; a DWARF expression involving the set of SIMT lanes active on entry to a; subprogram is required. The SIMT active lane ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:27214,Availability,mask,mask,27214," masked select is proposed. In addition, an operation that creates a composite; location description that is a vector on another location description is needed.; These operations generate the composite location description using a single; DWARF operation that combines all lanes of the vector in one step. The DWARF; expression is more compact, and can be evaluated by a consumer far more; efficiently. An example that uses these operations is referenced in the; :ref:`amdgpu-dwarf-further-examples` appendix. See ``DW_OP_LLVM_select_bit_piece`` and ``DW_OP_LLVM_extend`` in; :ref:`amdgpu-dwarf-composite-location-description-operations`. 2.11 DWARF Operation to Access Call Frame Entry Registers; ---------------------------------------------------------. As described in; :ref:`amdgpu-dwarf-operation-to-create-vector-composite-location-descriptions`,; a DWARF expression involving the set of SIMT lanes active on entry to a; subprogram is required. The SIMT active lane mask may be held in a register that; is modified as the subprogram executes. However, its value may be saved on entry; to the subprogram. The Call Frame Information (CFI) already encodes such register saving, so it is; more efficient to provide an operation to return the location of a saved; register than have to generate a loclist to describe the same information. This; is now possible since; :ref:`amdgpu-dwarf-allow-location-description-on-the-dwarf-evaluation-stack`; allows location descriptions on the stack. See ``DW_OP_LLVM_call_frame_entry_reg`` in; :ref:`amdgpu-dwarf-general-location-description-operations` and; :ref:`amdgpu-dwarf-call-frame-information`. 2.12 Support for Source Languages Mapped to SIMT Hardware; ---------------------------------------------------------. If the source language is mapped onto the AMDGPU wavefronts in a SIMT manner,; then the variable DWARF location expressions must compute the location for a; single lane of the wavefront. Therefore, a DWARF operation is required to denote;",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:28945,Availability,mask,mask,28945,"Languages Mapped to SIMT Hardware; ---------------------------------------------------------. If the source language is mapped onto the AMDGPU wavefronts in a SIMT manner,; then the variable DWARF location expressions must compute the location for a; single lane of the wavefront. Therefore, a DWARF operation is required to denote; the current lane, much like ``DW_OP_push_object_address`` denotes the current; object. See ``DW_OP_LLVM_push_lane`` in :ref:`amdgpu-dwarf-literal-operations`. In addition, a way is needed for the compiler to communicate how many source; language threads of execution are mapped to a target architecture thread's SIMT; lanes. See ``DW_AT_LLVM_lanes`` in :ref:`amdgpu-dwarf-low-level-information`. .. _amdgpu-dwarf-support-for-divergent-control-flow-of-simt-hardware:. 2.13 Support for Divergent Control Flow of SIMT Hardware; --------------------------------------------------------. If the source language is mapped onto the AMDGPU wavefronts in a SIMT manner the; compiler can use the AMDGPU execution mask register to control which lanes are; active. To describe the conceptual location of non-active lanes requires an; attribute that has an expression that computes the source location PC for each; lane. For efficiency, the expression calculates the source location the wavefront as a; whole. This can be done using the ``DW_OP_LLVM_select_bit_piece`` (see; :ref:`amdgpu-dwarf-operation-to-create-vector-composite-location-descriptions`); operation. The AMDGPU may update the execution mask to perform whole wavefront operations.; Therefore, there is a need for an attribute that computes the current active; lane mask. This can have an expression that may evaluate to the SIMT active lane; mask register or to a saved mask when in whole wavefront execution mode. An example that uses these attributes is referenced in the; :ref:`amdgpu-dwarf-further-examples` appendix. See ``DW_AT_LLVM_lane_pc`` and ``DW_AT_LLVM_active_lane`` in; :ref:`amdgpu-dwarf-composite-l",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:29432,Availability,mask,mask,29432,"he compiler to communicate how many source; language threads of execution are mapped to a target architecture thread's SIMT; lanes. See ``DW_AT_LLVM_lanes`` in :ref:`amdgpu-dwarf-low-level-information`. .. _amdgpu-dwarf-support-for-divergent-control-flow-of-simt-hardware:. 2.13 Support for Divergent Control Flow of SIMT Hardware; --------------------------------------------------------. If the source language is mapped onto the AMDGPU wavefronts in a SIMT manner the; compiler can use the AMDGPU execution mask register to control which lanes are; active. To describe the conceptual location of non-active lanes requires an; attribute that has an expression that computes the source location PC for each; lane. For efficiency, the expression calculates the source location the wavefront as a; whole. This can be done using the ``DW_OP_LLVM_select_bit_piece`` (see; :ref:`amdgpu-dwarf-operation-to-create-vector-composite-location-descriptions`); operation. The AMDGPU may update the execution mask to perform whole wavefront operations.; Therefore, there is a need for an attribute that computes the current active; lane mask. This can have an expression that may evaluate to the SIMT active lane; mask register or to a saved mask when in whole wavefront execution mode. An example that uses these attributes is referenced in the; :ref:`amdgpu-dwarf-further-examples` appendix. See ``DW_AT_LLVM_lane_pc`` and ``DW_AT_LLVM_active_lane`` in; :ref:`amdgpu-dwarf-composite-location-description-operations`. 2.14 Define Source Language Memory Classes; -------------------------------------------. AMDGPU supports languages, such as OpenCL [:ref:`OpenCL <amdgpu-dwarf-OpenCL>`],; that define source language memory classes. Support is added to define language; specific memory spaces so they can be used in a consistent way by consumers. Support for using memory spaces in defining source language types and data; object allocation is also added. See :ref:`amdgpu-dwarf-memory-spaces`. 2.15 Define Augm",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:29560,Availability,mask,mask,29560,"to a target architecture thread's SIMT; lanes. See ``DW_AT_LLVM_lanes`` in :ref:`amdgpu-dwarf-low-level-information`. .. _amdgpu-dwarf-support-for-divergent-control-flow-of-simt-hardware:. 2.13 Support for Divergent Control Flow of SIMT Hardware; --------------------------------------------------------. If the source language is mapped onto the AMDGPU wavefronts in a SIMT manner the; compiler can use the AMDGPU execution mask register to control which lanes are; active. To describe the conceptual location of non-active lanes requires an; attribute that has an expression that computes the source location PC for each; lane. For efficiency, the expression calculates the source location the wavefront as a; whole. This can be done using the ``DW_OP_LLVM_select_bit_piece`` (see; :ref:`amdgpu-dwarf-operation-to-create-vector-composite-location-descriptions`); operation. The AMDGPU may update the execution mask to perform whole wavefront operations.; Therefore, there is a need for an attribute that computes the current active; lane mask. This can have an expression that may evaluate to the SIMT active lane; mask register or to a saved mask when in whole wavefront execution mode. An example that uses these attributes is referenced in the; :ref:`amdgpu-dwarf-further-examples` appendix. See ``DW_AT_LLVM_lane_pc`` and ``DW_AT_LLVM_active_lane`` in; :ref:`amdgpu-dwarf-composite-location-description-operations`. 2.14 Define Source Language Memory Classes; -------------------------------------------. AMDGPU supports languages, such as OpenCL [:ref:`OpenCL <amdgpu-dwarf-OpenCL>`],; that define source language memory classes. Support is added to define language; specific memory spaces so they can be used in a consistent way by consumers. Support for using memory spaces in defining source language types and data; object allocation is also added. See :ref:`amdgpu-dwarf-memory-spaces`. 2.15 Define Augmentation Strings to Support Multiple Extensions; ------------------------------------",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:29637,Availability,mask,mask,29637," .. _amdgpu-dwarf-support-for-divergent-control-flow-of-simt-hardware:. 2.13 Support for Divergent Control Flow of SIMT Hardware; --------------------------------------------------------. If the source language is mapped onto the AMDGPU wavefronts in a SIMT manner the; compiler can use the AMDGPU execution mask register to control which lanes are; active. To describe the conceptual location of non-active lanes requires an; attribute that has an expression that computes the source location PC for each; lane. For efficiency, the expression calculates the source location the wavefront as a; whole. This can be done using the ``DW_OP_LLVM_select_bit_piece`` (see; :ref:`amdgpu-dwarf-operation-to-create-vector-composite-location-descriptions`); operation. The AMDGPU may update the execution mask to perform whole wavefront operations.; Therefore, there is a need for an attribute that computes the current active; lane mask. This can have an expression that may evaluate to the SIMT active lane; mask register or to a saved mask when in whole wavefront execution mode. An example that uses these attributes is referenced in the; :ref:`amdgpu-dwarf-further-examples` appendix. See ``DW_AT_LLVM_lane_pc`` and ``DW_AT_LLVM_active_lane`` in; :ref:`amdgpu-dwarf-composite-location-description-operations`. 2.14 Define Source Language Memory Classes; -------------------------------------------. AMDGPU supports languages, such as OpenCL [:ref:`OpenCL <amdgpu-dwarf-OpenCL>`],; that define source language memory classes. Support is added to define language; specific memory spaces so they can be used in a consistent way by consumers. Support for using memory spaces in defining source language types and data; object allocation is also added. See :ref:`amdgpu-dwarf-memory-spaces`. 2.15 Define Augmentation Strings to Support Multiple Extensions; ---------------------------------------------------------------. A ``DW_AT_LLVM_augmentation`` attribute is added to a compilation unit debugger; informa",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:29665,Availability,mask,mask,29665," .. _amdgpu-dwarf-support-for-divergent-control-flow-of-simt-hardware:. 2.13 Support for Divergent Control Flow of SIMT Hardware; --------------------------------------------------------. If the source language is mapped onto the AMDGPU wavefronts in a SIMT manner the; compiler can use the AMDGPU execution mask register to control which lanes are; active. To describe the conceptual location of non-active lanes requires an; attribute that has an expression that computes the source location PC for each; lane. For efficiency, the expression calculates the source location the wavefront as a; whole. This can be done using the ``DW_OP_LLVM_select_bit_piece`` (see; :ref:`amdgpu-dwarf-operation-to-create-vector-composite-location-descriptions`); operation. The AMDGPU may update the execution mask to perform whole wavefront operations.; Therefore, there is a need for an attribute that computes the current active; lane mask. This can have an expression that may evaluate to the SIMT active lane; mask register or to a saved mask when in whole wavefront execution mode. An example that uses these attributes is referenced in the; :ref:`amdgpu-dwarf-further-examples` appendix. See ``DW_AT_LLVM_lane_pc`` and ``DW_AT_LLVM_active_lane`` in; :ref:`amdgpu-dwarf-composite-location-description-operations`. 2.14 Define Source Language Memory Classes; -------------------------------------------. AMDGPU supports languages, such as OpenCL [:ref:`OpenCL <amdgpu-dwarf-OpenCL>`],; that define source language memory classes. Support is added to define language; specific memory spaces so they can be used in a consistent way by consumers. Support for using memory spaces in defining source language types and data; object allocation is also added. See :ref:`amdgpu-dwarf-memory-spaces`. 2.15 Define Augmentation Strings to Support Multiple Extensions; ---------------------------------------------------------------. A ``DW_AT_LLVM_augmentation`` attribute is added to a compilation unit debugger; informa",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:39336,Availability,avail,available,39336,"------------------------. AMDGPU supports languages, such as OpenCL, that define source language memory; spaces. Support is added to define language specific memory spaces so they can; be used in a consistent way by consumers. See :ref:`amdgpu-dwarf-memory-spaces`. A new attribute ``DW_AT_LLVM_memory_space`` is added to support using memory; spaces in defining source language pointer and reference types (see; :ref:`amdgpu-dwarf-type-modifier-entries`) and data object allocation (see; :ref:`amdgpu-dwarf-data-object-entries`). 2.22 Expression Operation Vendor Extensibility Opcode; -----------------------------------------------------. The vendor extension encoding space for DWARF expression operations; accommodates only 32 unique operations. In practice, the lack of a central; registry and a desire for backwards compatibility means vendor extensions are; never retired, even when standard versions are accepted into DWARF proper. This; has produced a situation where the effective encoding space available for new; vendor extensions is miniscule today. To expand this encoding space a new DWARF operation ``DW_OP_LLVM_user`` is; added which acts as a ""prefix"" for vendor extensions. It is followed by a; ULEB128 encoded vendor extension opcode, which is then followed by the operands; of the corresponding vendor extension operation. This approach allows all remaining operations defined in these extensions to be; encoded without conflicting with existing vendor extensions. See ``DW_OP_LLVM_user`` in :ref:`amdgpu-dwarf-vendor-extensions-operations`. .. _amdgpu-dwarf-changes-relative-to-dwarf-version-5:. A. Changes Relative to DWARF Version 5; ======================================. .. note::. This appendix provides changes relative to DWARF Version 5. It has been; defined such that it is backwards compatible with DWARF Version 5.; Non-normative text is shown in *italics*. The section numbers generally; correspond to those in the DWARF Version 5 standard unless specified; otherwis",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:40916,Availability,avail,available,40916,"ions-operations`. .. _amdgpu-dwarf-changes-relative-to-dwarf-version-5:. A. Changes Relative to DWARF Version 5; ======================================. .. note::. This appendix provides changes relative to DWARF Version 5. It has been; defined such that it is backwards compatible with DWARF Version 5.; Non-normative text is shown in *italics*. The section numbers generally; correspond to those in the DWARF Version 5 standard unless specified; otherwise. Definitions are given for the additional operations, as well as; clarifying how existing expression operations, CFI operations, and attributes; behave with respect to generalized location descriptions that support address; spaces and multiple places. The names for the new operations, attributes, and constants include ""\; ``LLVM``\ "" and are encoded with vendor specific codes so these extensions; can be implemented as an LLVM vendor extension to DWARF Version 5. New; operations other than ``DW_OP_LLVM_user`` are ""prefixed"" by; ``DW_OP_LLVM_user`` to make enough encoding space available for their; implementation. .. note::. Notes are included to describe how the changes are to be applied to the; DWARF Version 5 standard. They also describe rational and issues that may; need further consideration. A.2 General Description; -----------------------. A.2.2 Attribute Types; ~~~~~~~~~~~~~~~~~~~~~. .. note::. This augments DWARF Version 5 section 2.2 and Table 2.2. The following table provides the additional attributes. .. table:: Attribute names; :name: amdgpu-dwarf-attribute-names-table. ============================ ====================================; Attribute Usage; ============================ ====================================; ``DW_AT_LLVM_active_lane`` SIMT active lanes (see :ref:`amdgpu-dwarf-low-level-information`); ``DW_AT_LLVM_augmentation`` Compilation unit augmentation string (see :ref:`amdgpu-dwarf-full-and-partial-compilation-unit-entries`); ``DW_AT_LLVM_lane_pc`` SIMT lane program location (see :ref:`amdgp",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:43212,Availability,error,error,43212,":ref:`amdgpu-dwarf-address-spaces`); ``DW_AT_LLVM_memory_space`` Pointer or reference types (see 5.3 ""Type Modifier Entries""); Data objects (see 4.1 ""Data Object Entries""); ============================ ====================================. .. _amdgpu-dwarf-expressions:. A.2.5 DWARF Expressions; ~~~~~~~~~~~~~~~~~~~~~~~. .. note::. This section, and its nested sections, replaces DWARF Version 5 section 2.5; and section 2.6. The new DWARF expression operation extensions are defined as; well as clarifying the extensions to already existing DWARF Version 5; operations. It is based on the text of the existing DWARF Version 5 standard. DWARF expressions describe how to compute a value or specify a location. *The evaluation of a DWARF expression can provide the location of an object, the; value of an array bound, the length of a dynamic string, the desired value; itself, and so on.*. If the evaluation of a DWARF expression does not encounter an error, then it can; either result in a value (see :ref:`amdgpu-dwarf-expression-value`) or a; location description (see :ref:`amdgpu-dwarf-location-description`). When a; DWARF expression is evaluated, it may be specified whether a value or location; description is required as the result kind. If a result kind is specified, and the result of the evaluation does not match; the specified result kind, then the implicit conversions described in; :ref:`amdgpu-dwarf-memory-location-description-operations` are performed if; valid. Otherwise, the DWARF expression is ill-formed. If the evaluation of a DWARF expression encounters an evaluation error, then the; result is an evaluation error. .. note::. Decided to define the concept of an evaluation error. An alternative is to; introduce an undefined value base type in a similar way to location; descriptions having an undefined location description. Then operations that; encounter an evaluation error can return the undefined location description or; value with an undefined base type. All operatio",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:43854,Availability,error,error,43854,"on the text of the existing DWARF Version 5 standard. DWARF expressions describe how to compute a value or specify a location. *The evaluation of a DWARF expression can provide the location of an object, the; value of an array bound, the length of a dynamic string, the desired value; itself, and so on.*. If the evaluation of a DWARF expression does not encounter an error, then it can; either result in a value (see :ref:`amdgpu-dwarf-expression-value`) or a; location description (see :ref:`amdgpu-dwarf-location-description`). When a; DWARF expression is evaluated, it may be specified whether a value or location; description is required as the result kind. If a result kind is specified, and the result of the evaluation does not match; the specified result kind, then the implicit conversions described in; :ref:`amdgpu-dwarf-memory-location-description-operations` are performed if; valid. Otherwise, the DWARF expression is ill-formed. If the evaluation of a DWARF expression encounters an evaluation error, then the; result is an evaluation error. .. note::. Decided to define the concept of an evaluation error. An alternative is to; introduce an undefined value base type in a similar way to location; descriptions having an undefined location description. Then operations that; encounter an evaluation error can return the undefined location description or; value with an undefined base type. All operations that act on values would return an undefined entity if given an; undefined value. The expression would then always evaluate to completion, and; can be tested to determine if it is an undefined entity. However, this would add considerable additional complexity and does not match; that GDB throws an exception when these evaluation errors occur. If a DWARF expression is ill-formed, then the result is undefined. The following sections detail the rules for when a DWARF expression is; ill-formed or results in an evaluation error. A DWARF expression can either be encoded as an ope",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:43895,Availability,error,error,43895,"on the text of the existing DWARF Version 5 standard. DWARF expressions describe how to compute a value or specify a location. *The evaluation of a DWARF expression can provide the location of an object, the; value of an array bound, the length of a dynamic string, the desired value; itself, and so on.*. If the evaluation of a DWARF expression does not encounter an error, then it can; either result in a value (see :ref:`amdgpu-dwarf-expression-value`) or a; location description (see :ref:`amdgpu-dwarf-location-description`). When a; DWARF expression is evaluated, it may be specified whether a value or location; description is required as the result kind. If a result kind is specified, and the result of the evaluation does not match; the specified result kind, then the implicit conversions described in; :ref:`amdgpu-dwarf-memory-location-description-operations` are performed if; valid. Otherwise, the DWARF expression is ill-formed. If the evaluation of a DWARF expression encounters an evaluation error, then the; result is an evaluation error. .. note::. Decided to define the concept of an evaluation error. An alternative is to; introduce an undefined value base type in a similar way to location; descriptions having an undefined location description. Then operations that; encounter an evaluation error can return the undefined location description or; value with an undefined base type. All operations that act on values would return an undefined entity if given an; undefined value. The expression would then always evaluate to completion, and; can be tested to determine if it is an undefined entity. However, this would add considerable additional complexity and does not match; that GDB throws an exception when these evaluation errors occur. If a DWARF expression is ill-formed, then the result is undefined. The following sections detail the rules for when a DWARF expression is; ill-formed or results in an evaluation error. A DWARF expression can either be encoded as an ope",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:43960,Availability,error,error,43960," a value or specify a location. *The evaluation of a DWARF expression can provide the location of an object, the; value of an array bound, the length of a dynamic string, the desired value; itself, and so on.*. If the evaluation of a DWARF expression does not encounter an error, then it can; either result in a value (see :ref:`amdgpu-dwarf-expression-value`) or a; location description (see :ref:`amdgpu-dwarf-location-description`). When a; DWARF expression is evaluated, it may be specified whether a value or location; description is required as the result kind. If a result kind is specified, and the result of the evaluation does not match; the specified result kind, then the implicit conversions described in; :ref:`amdgpu-dwarf-memory-location-description-operations` are performed if; valid. Otherwise, the DWARF expression is ill-formed. If the evaluation of a DWARF expression encounters an evaluation error, then the; result is an evaluation error. .. note::. Decided to define the concept of an evaluation error. An alternative is to; introduce an undefined value base type in a similar way to location; descriptions having an undefined location description. Then operations that; encounter an evaluation error can return the undefined location description or; value with an undefined base type. All operations that act on values would return an undefined entity if given an; undefined value. The expression would then always evaluate to completion, and; can be tested to determine if it is an undefined entity. However, this would add considerable additional complexity and does not match; that GDB throws an exception when these evaluation errors occur. If a DWARF expression is ill-formed, then the result is undefined. The following sections detail the rules for when a DWARF expression is; ill-formed or results in an evaluation error. A DWARF expression can either be encoded as an operation expression (see; :ref:`amdgpu-dwarf-operation-expressions`), or as a location list expr",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:44159,Availability,error,error,44159,"xpression does not encounter an error, then it can; either result in a value (see :ref:`amdgpu-dwarf-expression-value`) or a; location description (see :ref:`amdgpu-dwarf-location-description`). When a; DWARF expression is evaluated, it may be specified whether a value or location; description is required as the result kind. If a result kind is specified, and the result of the evaluation does not match; the specified result kind, then the implicit conversions described in; :ref:`amdgpu-dwarf-memory-location-description-operations` are performed if; valid. Otherwise, the DWARF expression is ill-formed. If the evaluation of a DWARF expression encounters an evaluation error, then the; result is an evaluation error. .. note::. Decided to define the concept of an evaluation error. An alternative is to; introduce an undefined value base type in a similar way to location; descriptions having an undefined location description. Then operations that; encounter an evaluation error can return the undefined location description or; value with an undefined base type. All operations that act on values would return an undefined entity if given an; undefined value. The expression would then always evaluate to completion, and; can be tested to determine if it is an undefined entity. However, this would add considerable additional complexity and does not match; that GDB throws an exception when these evaluation errors occur. If a DWARF expression is ill-formed, then the result is undefined. The following sections detail the rules for when a DWARF expression is; ill-formed or results in an evaluation error. A DWARF expression can either be encoded as an operation expression (see; :ref:`amdgpu-dwarf-operation-expressions`), or as a location list expression; (see :ref:`amdgpu-dwarf-location-list-expressions`). .. _amdgpu-dwarf-expression-evaluation-context:. A.2.5.1 DWARF Expression Evaluation Context; +++++++++++++++++++++++++++++++++++++++++++. A DWARF expression is evaluated in a conte",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:44596,Availability,error,errors,44596," and the result of the evaluation does not match; the specified result kind, then the implicit conversions described in; :ref:`amdgpu-dwarf-memory-location-description-operations` are performed if; valid. Otherwise, the DWARF expression is ill-formed. If the evaluation of a DWARF expression encounters an evaluation error, then the; result is an evaluation error. .. note::. Decided to define the concept of an evaluation error. An alternative is to; introduce an undefined value base type in a similar way to location; descriptions having an undefined location description. Then operations that; encounter an evaluation error can return the undefined location description or; value with an undefined base type. All operations that act on values would return an undefined entity if given an; undefined value. The expression would then always evaluate to completion, and; can be tested to determine if it is an undefined entity. However, this would add considerable additional complexity and does not match; that GDB throws an exception when these evaluation errors occur. If a DWARF expression is ill-formed, then the result is undefined. The following sections detail the rules for when a DWARF expression is; ill-formed or results in an evaluation error. A DWARF expression can either be encoded as an operation expression (see; :ref:`amdgpu-dwarf-operation-expressions`), or as a location list expression; (see :ref:`amdgpu-dwarf-location-list-expressions`). .. _amdgpu-dwarf-expression-evaluation-context:. A.2.5.1 DWARF Expression Evaluation Context; +++++++++++++++++++++++++++++++++++++++++++. A DWARF expression is evaluated in a context that can include a number of; context elements. If multiple context elements are specified then they must be; self consistent or the result of the evaluation is undefined. The context; elements that can be specified are:. *A current result kind*. The kind of result required by the DWARF expression evaluation. If specified; it can be a location descrip",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:44788,Availability,error,error,44788,"valid. Otherwise, the DWARF expression is ill-formed. If the evaluation of a DWARF expression encounters an evaluation error, then the; result is an evaluation error. .. note::. Decided to define the concept of an evaluation error. An alternative is to; introduce an undefined value base type in a similar way to location; descriptions having an undefined location description. Then operations that; encounter an evaluation error can return the undefined location description or; value with an undefined base type. All operations that act on values would return an undefined entity if given an; undefined value. The expression would then always evaluate to completion, and; can be tested to determine if it is an undefined entity. However, this would add considerable additional complexity and does not match; that GDB throws an exception when these evaluation errors occur. If a DWARF expression is ill-formed, then the result is undefined. The following sections detail the rules for when a DWARF expression is; ill-formed or results in an evaluation error. A DWARF expression can either be encoded as an operation expression (see; :ref:`amdgpu-dwarf-operation-expressions`), or as a location list expression; (see :ref:`amdgpu-dwarf-location-list-expressions`). .. _amdgpu-dwarf-expression-evaluation-context:. A.2.5.1 DWARF Expression Evaluation Context; +++++++++++++++++++++++++++++++++++++++++++. A DWARF expression is evaluated in a context that can include a number of; context elements. If multiple context elements are specified then they must be; self consistent or the result of the evaluation is undefined. The context; elements that can be specified are:. *A current result kind*. The kind of result required by the DWARF expression evaluation. If specified; it can be a location description or a value. *A current thread*. The target architecture thread identifier. For source languages that are not; implemented using a SIMT execution model, this corresponds to the source; program t",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:54164,Availability,error,error,54164,"he location description of a program object. It is required for the ``DW_OP_push_object_address`` operation. *For example, the* ``DW_AT_data_location`` *attribute on type debug; information entries specifies the program object corresponding to a runtime; descriptor as the current object when it evaluates its associated expression.*. The result is undefined if the location description is invalid (see; :ref:`amdgpu-dwarf-location-description`). *An initial stack*. This is a list of values or location descriptions that will be pushed on the; operation expression evaluation stack in the order provided before evaluation; of an operation expression starts. Some debugger information entries have attributes that evaluate their DWARF; expression value with initial stack entries. In all other cases the initial; stack is empty. The result is undefined if any location descriptions are invalid (see; :ref:`amdgpu-dwarf-location-description`). If the evaluation requires a context element that is not specified, then the; result of the evaluation is an error. *A DWARF expression for a location description may be able to be evaluated; without a thread, lane, call frame, program location, or architecture context.; For example, the location of a global variable may be able to be evaluated; without such context. If the expression evaluates with an error then it may; indicate the variable has been optimized and so requires more context.*. *The DWARF expression for call frame information (see*; :ref:`amdgpu-dwarf-call-frame-information`\ *) operations are restricted to; those that do not require the compilation unit context to be specified.*. The DWARF is ill-formed if all the ``address_size`` fields in the headers of all; the entries in the ``.debug_info``, ``.debug_addr``, ``.debug_line``,; ``.debug_rnglists``, ``.debug_rnglists.dwo``, ``.debug_loclists``, and; ``.debug_loclists.dwo`` sections corresponding to any given program location do; not match. .. _amdgpu-dwarf-expression-value:.",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:54461,Availability,error,error,54461,"description is invalid (see; :ref:`amdgpu-dwarf-location-description`). *An initial stack*. This is a list of values or location descriptions that will be pushed on the; operation expression evaluation stack in the order provided before evaluation; of an operation expression starts. Some debugger information entries have attributes that evaluate their DWARF; expression value with initial stack entries. In all other cases the initial; stack is empty. The result is undefined if any location descriptions are invalid (see; :ref:`amdgpu-dwarf-location-description`). If the evaluation requires a context element that is not specified, then the; result of the evaluation is an error. *A DWARF expression for a location description may be able to be evaluated; without a thread, lane, call frame, program location, or architecture context.; For example, the location of a global variable may be able to be evaluated; without such context. If the expression evaluates with an error then it may; indicate the variable has been optimized and so requires more context.*. *The DWARF expression for call frame information (see*; :ref:`amdgpu-dwarf-call-frame-information`\ *) operations are restricted to; those that do not require the compilation unit context to be specified.*. The DWARF is ill-formed if all the ``address_size`` fields in the headers of all; the entries in the ``.debug_info``, ``.debug_addr``, ``.debug_line``,; ``.debug_rnglists``, ``.debug_rnglists.dwo``, ``.debug_loclists``, and; ``.debug_loclists.dwo`` sections corresponding to any given program location do; not match. .. _amdgpu-dwarf-expression-value:. A.2.5.2 DWARF Expression Value; ++++++++++++++++++++++++++++++. A value has a type and a literal value. It can represent a literal value of any; supported base type of the target architecture. The base type specifies the; size, encoding, and endianity of the literal value. .. note::. It may be desirable to add an implicit pointer base type encoding. It would be; used for ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:58499,Availability,avail,available,58499,"ne or more single location descriptions. A single location description specifies the location storage that holds a; program object and a position within the location storage where the program; object starts. The position within the location storage is expressed as a bit; offset relative to the start of the location storage. A location storage is a linear stream of bits that can hold values. Each; location storage has a size in bits and can be accessed using a zero-based bit; offset. The ordering of bits within a location storage uses the bit numbering; and direction conventions that are appropriate to the current language on the; target architecture. There are five kinds of location storage:. *memory location storage*; Corresponds to the target architecture memory address spaces. *register location storage*; Corresponds to the target architecture registers. *implicit location storage*; Corresponds to fixed values that can only be read. *undefined location storage*; Indicates no value is available and therefore cannot be read or written. *composite location storage*; Allows a mixture of these where some bits come from one location storage and; some from another location storage, or from disjoint parts of the same; location storage. .. note::. It may be better to add an implicit pointer location storage kind used by the; ``DW_OP_implicit_pointer`` and ``DW_OP_LLVM_aspace_implicit_pointer``; operations. It would specify the debugger information entry and byte offset; provided by the operations. *Location descriptions are a language independent representation of addressing; rules.*. * *They can be the result of evaluating a debugger information entry attribute; that specifies an operation expression of arbitrary complexity. In this usage; they can describe the location of an object as long as its lifetime is either; static or the same as the lexical block (see; :ref:`amdgpu-dwarf-lexical-block-entries`) that owns it, and it does not move; during its lifetime.*. * *They c",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:65081,Availability,error,error,65081,"++++++++++++++. An operation expression is comprised of a stream of operations, each consisting; of an opcode followed by zero or more operands. The number of operands is; implied by the opcode. Operations represent a postfix operation on a simple stack machine. Each stack; entry can hold either a value or a location description. Operations can act on; entries on the stack, including adding entries and removing entries. If the kind; of a stack entry does not match the kind required by the operation and is not; implicitly convertible to the required kind (see; :ref:`amdgpu-dwarf-memory-location-description-operations`), then the DWARF; operation expression is ill-formed. Evaluation of an operation expression starts with an empty stack on which the; entries from the initial stack provided by the context are pushed in the order; provided. Then the operations are evaluated, starting with the first operation; of the stream. Evaluation continues until either an operation has an evaluation; error, or until one past the last operation of the stream is reached. The result of the evaluation is:. * If an operation has an evaluation error, or an operation evaluates an; expression that has an evaluation error, then the result is an evaluation; error. * If the current result kind specifies a location description, then:. * If the stack is empty, the result is a location description with one; undefined location description. *This rule is for backwards compatibility with DWARF Version 5 which has no; explicit operation to create an undefined location description, and uses an; empty operation expression for this purpose.*. * If the top stack entry is a location description, or can be converted; to one (see :ref:`amdgpu-dwarf-memory-location-description-operations`),; then the result is that, possibly converted, location description. Any other; entries on the stack are discarded. * Otherwise the DWARF expression is ill-formed. .. note::. Could define this case as returning an implicit",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:65221,Availability,error,error,65221," by the opcode. Operations represent a postfix operation on a simple stack machine. Each stack; entry can hold either a value or a location description. Operations can act on; entries on the stack, including adding entries and removing entries. If the kind; of a stack entry does not match the kind required by the operation and is not; implicitly convertible to the required kind (see; :ref:`amdgpu-dwarf-memory-location-description-operations`), then the DWARF; operation expression is ill-formed. Evaluation of an operation expression starts with an empty stack on which the; entries from the initial stack provided by the context are pushed in the order; provided. Then the operations are evaluated, starting with the first operation; of the stream. Evaluation continues until either an operation has an evaluation; error, or until one past the last operation of the stream is reached. The result of the evaluation is:. * If an operation has an evaluation error, or an operation evaluates an; expression that has an evaluation error, then the result is an evaluation; error. * If the current result kind specifies a location description, then:. * If the stack is empty, the result is a location description with one; undefined location description. *This rule is for backwards compatibility with DWARF Version 5 which has no; explicit operation to create an undefined location description, and uses an; empty operation expression for this purpose.*. * If the top stack entry is a location description, or can be converted; to one (see :ref:`amdgpu-dwarf-memory-location-description-operations`),; then the result is that, possibly converted, location description. Any other; entries on the stack are discarded. * Otherwise the DWARF expression is ill-formed. .. note::. Could define this case as returning an implicit location description as; if the ``DW_OP_implicit`` operation is performed. * If the current result kind specifies a value, then:. * If the top stack entry is a value, or can be co",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:65292,Availability,error,error,65292," by the opcode. Operations represent a postfix operation on a simple stack machine. Each stack; entry can hold either a value or a location description. Operations can act on; entries on the stack, including adding entries and removing entries. If the kind; of a stack entry does not match the kind required by the operation and is not; implicitly convertible to the required kind (see; :ref:`amdgpu-dwarf-memory-location-description-operations`), then the DWARF; operation expression is ill-formed. Evaluation of an operation expression starts with an empty stack on which the; entries from the initial stack provided by the context are pushed in the order; provided. Then the operations are evaluated, starting with the first operation; of the stream. Evaluation continues until either an operation has an evaluation; error, or until one past the last operation of the stream is reached. The result of the evaluation is:. * If an operation has an evaluation error, or an operation evaluates an; expression that has an evaluation error, then the result is an evaluation; error. * If the current result kind specifies a location description, then:. * If the stack is empty, the result is a location description with one; undefined location description. *This rule is for backwards compatibility with DWARF Version 5 which has no; explicit operation to create an undefined location description, and uses an; empty operation expression for this purpose.*. * If the top stack entry is a location description, or can be converted; to one (see :ref:`amdgpu-dwarf-memory-location-description-operations`),; then the result is that, possibly converted, location description. Any other; entries on the stack are discarded. * Otherwise the DWARF expression is ill-formed. .. note::. Could define this case as returning an implicit location description as; if the ``DW_OP_implicit`` operation is performed. * If the current result kind specifies a value, then:. * If the top stack entry is a value, or can be co",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:65333,Availability,error,error,65333," by the opcode. Operations represent a postfix operation on a simple stack machine. Each stack; entry can hold either a value or a location description. Operations can act on; entries on the stack, including adding entries and removing entries. If the kind; of a stack entry does not match the kind required by the operation and is not; implicitly convertible to the required kind (see; :ref:`amdgpu-dwarf-memory-location-description-operations`), then the DWARF; operation expression is ill-formed. Evaluation of an operation expression starts with an empty stack on which the; entries from the initial stack provided by the context are pushed in the order; provided. Then the operations are evaluated, starting with the first operation; of the stream. Evaluation continues until either an operation has an evaluation; error, or until one past the last operation of the stream is reached. The result of the evaluation is:. * If an operation has an evaluation error, or an operation evaluates an; expression that has an evaluation error, then the result is an evaluation; error. * If the current result kind specifies a location description, then:. * If the stack is empty, the result is a location description with one; undefined location description. *This rule is for backwards compatibility with DWARF Version 5 which has no; explicit operation to create an undefined location description, and uses an; empty operation expression for this purpose.*. * If the top stack entry is a location description, or can be converted; to one (see :ref:`amdgpu-dwarf-memory-location-description-operations`),; then the result is that, possibly converted, location description. Any other; entries on the stack are discarded. * Otherwise the DWARF expression is ill-formed. .. note::. Could define this case as returning an implicit location description as; if the ``DW_OP_implicit`` operation is performed. * If the current result kind specifies a value, then:. * If the top stack entry is a value, or can be co",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:66995,Availability,error,error,66995," is ill-formed. .. note::. Could define this case as returning an implicit location description as; if the ``DW_OP_implicit`` operation is performed. * If the current result kind specifies a value, then:. * If the top stack entry is a value, or can be converted to one (see; :ref:`amdgpu-dwarf-memory-location-description-operations`), then the result; is that, possibly converted, value. Any other entries on the stack are; discarded. * Otherwise the DWARF expression is ill-formed. * If the current result kind is not specified, then:. * If the stack is empty, the result is a location description with one; undefined location description. *This rule is for backwards compatibility with DWARF Version 5 which has no; explicit operation to create an undefined location description, and uses an; empty operation expression for this purpose.*. .. note::. This rule is consistent with the rule above for when a location; description is requested. However, GDB appears to report this as an error; and no GDB tests appear to cause an empty stack for this case. * Otherwise, the top stack entry is returned. Any other entries on the stack; are discarded. An operation expression is encoded as a byte block with some form of prefix that; specifies the byte count. It can be used:. * as the value of a debugging information entry attribute that is encoded using; class ``exprloc`` (see :ref:`amdgpu-dwarf-classes-and-forms`),. * as the operand to certain operation expression operations,. * as the operand to certain call frame information operations (see; :ref:`amdgpu-dwarf-call-frame-information`),. * and in location list entries (see; :ref:`amdgpu-dwarf-location-list-expressions`). .. _amdgpu-dwarf-vendor-extensions-operations:. A.2.5.4.0 Vendor Extension Operations; #####################################. 1. ``DW_OP_LLVM_user``. ``DW_OP_LLVM_user`` encodes a vendor extension operation. It has at least one; operand: a ULEB128 constant identifying a vendor extension operation. The; remaining opera",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:88003,Availability,failure,failures,88003,"tly defined:. 1. ``DW_OP_regval_type``. ``DW_OP_regval_type`` has two operands. The first is an unsigned LEB128; integer that represents a register number R. The second is an unsigned; LEB128 integer DR that represents the byte offset of a debugging information; entry D relative to the beginning of the current compilation unit, that; provides the type T of the register value. The operation is equivalent to performing ``DW_OP_regx R; DW_OP_deref_type; DR``. .. note::. Should DWARF allow the type T to be a larger size than the size of the; register R? Restricting a larger bit size avoids any issue of conversion; as the, possibly truncated, bit contents of the register is simply; interpreted as a value of T. If a conversion is wanted it can be done; explicitly using a ``DW_OP_convert`` operation. GDB has a per register hook that allows a target specific conversion on a; register by register basis. It defaults to truncation of bigger registers.; Removing use of the target hook does not cause any test failures in common; architectures. If the compiler for a target architecture did want some; form of conversion, including a larger result type, it could always; explicitly use the ``DW_OP_convert`` operation. If T is a larger type than the register size, then the default GDB; register hook reads bytes from the next register (or reads out of bounds; for the last register!). Removing use of the target hook does not cause; any test failures in common architectures (except an illegal hand written; assembly test). If a target architecture requires this behavior, these; extensions allow a composite location description to be used to combine; multiple registers. 2. ``DW_OP_deref``. S is the bit size of the generic type divided by 8 (the byte size) and; rounded up to a whole number. DR is the offset of a hypothetical debug; information entry D in the current compilation unit for a base type of the; generic type. The operation is equivalent to performing ``DW_OP_deref_type S, DR``. ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:88436,Availability,failure,failures,88436,"R``. .. note::. Should DWARF allow the type T to be a larger size than the size of the; register R? Restricting a larger bit size avoids any issue of conversion; as the, possibly truncated, bit contents of the register is simply; interpreted as a value of T. If a conversion is wanted it can be done; explicitly using a ``DW_OP_convert`` operation. GDB has a per register hook that allows a target specific conversion on a; register by register basis. It defaults to truncation of bigger registers.; Removing use of the target hook does not cause any test failures in common; architectures. If the compiler for a target architecture did want some; form of conversion, including a larger result type, it could always; explicitly use the ``DW_OP_convert`` operation. If T is a larger type than the register size, then the default GDB; register hook reads bytes from the next register (or reads out of bounds; for the last register!). Removing use of the target hook does not cause; any test failures in common architectures (except an illegal hand written; assembly test). If a target architecture requires this behavior, these; extensions allow a composite location description to be used to combine; multiple registers. 2. ``DW_OP_deref``. S is the bit size of the generic type divided by 8 (the byte size) and; rounded up to a whole number. DR is the offset of a hypothetical debug; information entry D in the current compilation unit for a base type of the; generic type. The operation is equivalent to performing ``DW_OP_deref_type S, DR``. 3. ``DW_OP_deref_size``. ``DW_OP_deref_size`` has a single 1-byte unsigned integral constant that; represents a byte result size S. TS is the smaller of the generic type bit size and S scaled by 8 (the byte; size). If TS is smaller than the generic type bit size then T is an unsigned; integral type of bit size TS, otherwise T is the generic type. DR is the; offset of a hypothetical debug information entry D in the current; compilation unit for a base ty",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:91606,Availability,error,error,91606,"not needed for parsing. Any evaluation needs to get the base; type T to push with the value to know its encoding and bit size. It pops one stack entry that must be a location description L. A value V of TS bits is retrieved from the location storage LS specified by; one of the single location descriptions SL of L. *If L, or the location description of any composite location description; part that is a subcomponent of L, has more than one single location; description, then any one of them can be selected as they are required to; all have the same value. For any single location description SL, bits are; retrieved from the associated storage location starting at the bit offset; specified by SL. For a composite location description, the retrieved bits; are the concatenation of the N bits from each composite location part PL,; where N is limited to the size of PL.*. V is pushed on the stack with the type T. .. note::. This definition makes it an evaluation error if L is a register location; description that has less than TS bits remaining in the register storage.; Particularly since these extensions extend location descriptions to have; a bit offset, it would be odd to define this as performing sign extension; based on the type, or be target architecture dependent, as the number of; remaining bits could be any number. This matches the GDB implementation; for ``DW_OP_deref_type``. These extensions define ``DW_OP_*breg*`` in terms of; ``DW_OP_regval_type``. ``DW_OP_regval_type`` is defined in terms of; ``DW_OP_regx``, which uses a 0 bit offset, and ``DW_OP_deref_type``.; Therefore, it requires the register size to be greater or equal to the; address size of the address space. This matches the GDB implementation for; ``DW_OP_*breg*``. The DWARF is ill-formed if D is not in the current compilation unit, D is; not a ``DW_TAG_base_type`` debugging information entry, or if TS divided by; 8 (the byte size) and rounded up to a whole number is not equal to S. .. note::. This defin",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:92749,Availability,error,error,92749,"rforming sign extension; based on the type, or be target architecture dependent, as the number of; remaining bits could be any number. This matches the GDB implementation; for ``DW_OP_deref_type``. These extensions define ``DW_OP_*breg*`` in terms of; ``DW_OP_regval_type``. ``DW_OP_regval_type`` is defined in terms of; ``DW_OP_regx``, which uses a 0 bit offset, and ``DW_OP_deref_type``.; Therefore, it requires the register size to be greater or equal to the; address size of the address space. This matches the GDB implementation for; ``DW_OP_*breg*``. The DWARF is ill-formed if D is not in the current compilation unit, D is; not a ``DW_TAG_base_type`` debugging information entry, or if TS divided by; 8 (the byte size) and rounded up to a whole number is not equal to S. .. note::. This definition allows the base type to be a bit size since there seems no; reason to restrict it. It is an evaluation error if any bit of the value is retrieved from the; undefined location storage or the offset of any bit exceeds the size of the; location storage LS specified by any single location description SL of L. See :ref:`amdgpu-dwarf-implicit-location-description-operations` for special; rules concerning implicit location descriptions created by the; ``DW_OP_implicit_pointer`` and ``DW_OP_LLVM_aspace_implicit_pointer``; operations. 5. ``DW_OP_xderef`` *Deprecated*. ``DW_OP_xderef`` pops two stack entries. The first must be an integral type; value that represents an address A. The second must be an integral type; value that represents a target architecture specific address space; identifier AS. The operation is equivalent to performing ``DW_OP_swap;; DW_OP_LLVM_form_aspace_address; DW_OP_deref``. The value V retrieved is left; on the stack with the generic type. *This operation is deprecated as the* ``DW_OP_LLVM_form_aspace_address``; *operation can be used and provides greater expressiveness.*. 6. ``DW_OP_xderef_size`` *Deprecated*. ``DW_OP_xderef_size`` has a single 1-byte unsigne",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:98670,Availability,error,error,98670,"te::. GDB only implements ``DW_OP_entry_value`` when E is exactly; ``DW_OP_reg*`` or ``DW_OP_breg*; DW_OP_deref*``. .. _amdgpu-dwarf-location-description-operations:. A.2.5.4.4 Location Description Operations; #########################################. This section describes the operations that push location descriptions on the; stack. .. _amdgpu-dwarf-general-location-description-operations:. A.2.5.4.4.1 General Location Description Operations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. note::. This section replaces part of DWARF Version 5 section 2.5.1.3. 1. ``DW_OP_LLVM_offset`` *New*. ``DW_OP_LLVM_offset`` pops two stack entries. The first must be an integral; type value that represents a byte displacement B. The second must be a; location description L. It adds the value of B scaled by 8 (the byte size) to the bit offset of each; single location description SL of L, and pushes the updated L. It is an evaluation error if the updated bit offset of any SL is less than 0; or greater than or equal to the size of the location storage specified by; SL. 2. ``DW_OP_LLVM_offset_uconst`` *New*. ``DW_OP_LLVM_offset_uconst`` has a single unsigned LEB128 integer operand; that represents a byte displacement B. The operation is equivalent to performing ``DW_OP_constu B;; DW_OP_LLVM_offset``. *This operation is supplied specifically to be able to encode more field; displacements in two bytes than can be done with* ``DW_OP_lit*;; DW_OP_LLVM_offset``\ *.*. .. note::. Should this be named ``DW_OP_LLVM_offset_uconst`` to match; ``DW_OP_plus_uconst``, or ``DW_OP_LLVM_offset_constu`` to match; ``DW_OP_constu``?. 3. ``DW_OP_LLVM_bit_offset`` *New*. ``DW_OP_LLVM_bit_offset`` pops two stack entries. The first must be an; integral type value that represents a bit displacement B. The second must be; a location description L. It adds the value of B to the bit offset of each single location description; SL of L, and pushes the updated L. It is an evaluation error if the updated ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:99707,Availability,error,error,99707," of the location storage specified by; SL. 2. ``DW_OP_LLVM_offset_uconst`` *New*. ``DW_OP_LLVM_offset_uconst`` has a single unsigned LEB128 integer operand; that represents a byte displacement B. The operation is equivalent to performing ``DW_OP_constu B;; DW_OP_LLVM_offset``. *This operation is supplied specifically to be able to encode more field; displacements in two bytes than can be done with* ``DW_OP_lit*;; DW_OP_LLVM_offset``\ *.*. .. note::. Should this be named ``DW_OP_LLVM_offset_uconst`` to match; ``DW_OP_plus_uconst``, or ``DW_OP_LLVM_offset_constu`` to match; ``DW_OP_constu``?. 3. ``DW_OP_LLVM_bit_offset`` *New*. ``DW_OP_LLVM_bit_offset`` pops two stack entries. The first must be an; integral type value that represents a bit displacement B. The second must be; a location description L. It adds the value of B to the bit offset of each single location description; SL of L, and pushes the updated L. It is an evaluation error if the updated bit offset of any SL is less than 0; or greater than or equal to the size of the location storage specified by; SL. 4. ``DW_OP_push_object_address``. ``DW_OP_push_object_address`` pushes the location description L of the; current object. *This object may correspond to an independent variable that is part of a; user presented expression that is being evaluated. The object location; description may be determined from the variable's own debugging information; entry or it may be a component of an array, structure, or class whose; address has been dynamically determined by an earlier step during user; expression evaluation.*. *This operation provides explicit functionality (especially for arrays; involving descriptors) that is analogous to the implicit push of the base; location description of a structure prior to evaluation of a*; ``DW_AT_data_member_location`` *to access a data member of a structure.*. .. note::. This operation could be removed and the object location description; specified as the initial stack as for ``DW_A",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:107590,Availability,error,error,107590,"re default address space with a; bit offset equal to V scaled by 8 (the byte size). .. note::. If it is wanted to allow any integral type value to be implicitly converted to; a memory location description in the target architecture default address; space:. If a stack entry is required to be a location description, but is a value V; with an integral type, then it is implicitly converted to a location; description L with a one memory location description SL. If the type size of; V is less than the generic type size, then the value V is zero extended to; the size of the generic type. The least significant generic type size bits; are treated as an unsigned value to be used as an address A. SL specifies; memory location storage corresponding to the target architecture default; address space with a bit offset equal to A scaled by 8 (the byte size). The implicit conversion could also be defined as target architecture specific.; For example, GDB checks if V is an integral type. If it is not it gives an; error. Otherwise, GDB zero-extends V to 64 bits. If the GDB target defines a; hook function, then it is called. The target specific hook function can modify; the 64-bit value, possibly sign extending based on the original value type.; Finally, GDB treats the 64-bit value V as a memory location address. If a stack entry is required to be a location description, but it is an implicit; pointer value IPV with the target architecture default address space, then it is; implicitly converted to a location description with one single location; description specified by IPV. See; :ref:`amdgpu-dwarf-implicit-location-description-operations`. .. note::. Is this rule required for DWARF Version 5 backwards compatibility? If not, it; can be eliminated, and the producer can use; ``DW_OP_LLVM_form_aspace_address``. If a stack entry is required to be a value, but it is a location description L; with one memory location description SL in the target architecture default; address space with a bit ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:124315,Availability,error,error,124315,"ng; information entry D relative to the beginning of the ``.debug_info`` section; that contains the current compilation unit. The second operand is a signed; LEB128 integer that represents a byte displacement B. *Note that D might not be in the current compilation unit.*. *The first operand interpretation is exactly like that for*; ``DW_FORM_ref_addr``\ *.*. The address space identifier AS is defined as the one corresponding to the; target architecture specific default address space. The address size S is defined as the address bit size of the target; architecture specific address space corresponding to AS. An implicit location storage LS is created with the debugging information; entry D, address space AS, and size of S. It pushes a location description L that comprises one implicit location; description SL on the stack. SL specifies LS with a bit offset of 0. It is an evaluation error if a ``DW_OP_deref*`` operation pops a location; description L', and retrieves S bits, such that any retrieved bits come from; an implicit location storage that is the same as LS, unless both the; following conditions are met:. 1. All retrieved bits come from an implicit location description that; refers to an implicit location storage that is the same as LS. *Note that all bits do not have to come from the same implicit location; description, as L' may involve composite location descriptions.*. 2. The bits come from consecutive ascending offsets within their respective; implicit location storage. *These rules are equivalent to retrieving the complete contents of LS.*. If both the above conditions are met, then the value V pushed by the; ``DW_OP_deref*`` operation is an implicit pointer value IPV with a target; architecture specific address space of AS, a debugging information entry of; D, and a base type of T. If AS is the target architecture default address; space, then T is the generic type. Otherwise, T is a target architecture; specific integral type with a bit size equal to S. ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:126874,Availability,error,error,126874,"e current context, except; that the result kind is a location description, the compilation unit is; the one that contains D, the object is unspecified, and the initial stack; is empty. RL is the expression result. *Note that E is evaluated with the context of the expression accessing; IPV, and not the context of the expression that contained the*; ``DW_OP_implicit_pointer`` *or* ``DW_OP_LLVM_aspace_implicit_pointer``; *operation that created L.*. * If D has a ``DW_AT_const_value`` attribute, then an implicit location; storage RLS is created from the ``DW_AT_const_value`` attribute's value; with a size matching the size of the ``DW_AT_const_value`` attribute's; value. RL comprises one implicit location description SRL. SRL specifies; RLS with a bit offset of 0. .. note::. If using ``DW_AT_const_value`` for variables and formal parameters is; deprecated and instead ``DW_AT_location`` is used with an implicit; location description, then this rule would not be required. * Otherwise, it is an evaluation error. The bit offset of RL is updated as if the ``DW_OP_LLVM_offset_uconst B``; operation was applied. If a ``DW_OP_stack_value`` operation pops a value that is the same as IPV,; then it pushes a location description that is the same as L. It is an evaluation error if LS or IPV is accessed in any other manner. *The restrictions on how an implicit pointer location description created; by* ``DW_OP_implicit_pointer`` *and* ``DW_OP_LLVM_aspace_implicit_pointer``; *can be used are to simplify the DWARF consumer. Similarly, for an implicit; pointer value created by* ``DW_OP_deref*`` *and* ``DW_OP_stack_value``\ *.*. 4. ``DW_OP_LLVM_aspace_implicit_pointer`` *New*. ``DW_OP_LLVM_aspace_implicit_pointer`` has two operands that are the same as; for ``DW_OP_implicit_pointer``. It pops one stack entry that must be an integral type value that represents; a target architecture specific address space identifier AS. The location description L that is pushed on the stack is the same as f",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:127135,Availability,error,error,127135," and not the context of the expression that contained the*; ``DW_OP_implicit_pointer`` *or* ``DW_OP_LLVM_aspace_implicit_pointer``; *operation that created L.*. * If D has a ``DW_AT_const_value`` attribute, then an implicit location; storage RLS is created from the ``DW_AT_const_value`` attribute's value; with a size matching the size of the ``DW_AT_const_value`` attribute's; value. RL comprises one implicit location description SRL. SRL specifies; RLS with a bit offset of 0. .. note::. If using ``DW_AT_const_value`` for variables and formal parameters is; deprecated and instead ``DW_AT_location`` is used with an implicit; location description, then this rule would not be required. * Otherwise, it is an evaluation error. The bit offset of RL is updated as if the ``DW_OP_LLVM_offset_uconst B``; operation was applied. If a ``DW_OP_stack_value`` operation pops a value that is the same as IPV,; then it pushes a location description that is the same as L. It is an evaluation error if LS or IPV is accessed in any other manner. *The restrictions on how an implicit pointer location description created; by* ``DW_OP_implicit_pointer`` *and* ``DW_OP_LLVM_aspace_implicit_pointer``; *can be used are to simplify the DWARF consumer. Similarly, for an implicit; pointer value created by* ``DW_OP_deref*`` *and* ``DW_OP_stack_value``\ *.*. 4. ``DW_OP_LLVM_aspace_implicit_pointer`` *New*. ``DW_OP_LLVM_aspace_implicit_pointer`` has two operands that are the same as; for ``DW_OP_implicit_pointer``. It pops one stack entry that must be an integral type value that represents; a target architecture specific address space identifier AS. The location description L that is pushed on the stack is the same as for; ``DW_OP_implicit_pointer``, except that the address space identifier used is; AS. The DWARF expression is ill-formed if AS is not one of the values defined by; the target architecture specific ``DW_ASPACE_LLVM_*`` values. .. note::. This definition of ``DW_OP_LLVM_aspace_implicit_point",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:138781,Availability,mask,mask,138781,"parts. 4. ``DW_OP_LLVM_extend`` *New*. ``DW_OP_LLVM_extend`` has two operands. The first is an unsigned LEB128; integer that represents the element bit size S. The second is an unsigned; LEB128 integer that represents a count C. It pops one stack entry that must be a location description and is treated; as the part location description PL. A location description L comprised of one complete composite location; description SL is pushed on the stack. A complete composite location storage LS is created with C identical parts; P. Each P specifies PL and has a bit size of S. SL specifies LS with a bit offset of 0. The DWARF expression is ill-formed if the element bit size or count are 0. 5. ``DW_OP_LLVM_select_bit_piece`` *New*. ``DW_OP_LLVM_select_bit_piece`` has two operands. The first is an unsigned; LEB128 integer that represents the element bit size S. The second is an; unsigned LEB128 integer that represents a count C. It pops three stack entries. The first must be an integral type value that; represents a bit mask value M. The second must be a location description; that represents the one-location description L1. The third must be a; location description that represents the zero-location description L0. A complete composite location storage LS is created with C parts P\ :sub:`N`; ordered in ascending N from 0 to C-1 inclusive. Each P\ :sub:`N` specifies; location description PL\ :sub:`N` and has a bit size of S. PL\ :sub:`N` is as if the ``DW_OP_LLVM_bit_offset N*S`` operation was; applied to PLX\ :sub:`N`\ . PLX\ :sub:`N` is the same as L0 if the N\ :sup:`th` least significant bit of; M is a zero, otherwise it is the same as L1. A location description L comprised of one complete composite location; description SL is pushed on the stack. SL specifies LS with a bit offset of; 0. The DWARF expression is ill-formed if S or C are 0, or if the bit size of M; is less than C. .. note::. Should the count operand for DW_OP_extend and DW_OP_select_bit_piece be; changed to ge",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:145345,Availability,avail,available,145345,"inds of; bounded location description entries. The applicable base address of a bounded; location description entry is the address specified by the closest preceding; base address entry in the same location list. If there is no preceding base; address entry, then the applicable base address defaults to the base address; of the compilation unit (see DWARF Version 5 section 3.1.1). In the case of a compilation unit where all of the machine code is contained; in a single contiguous section, no base address entry is needed. *End-of-list*. This kind of location list entry marks the end of the location list; expression. The address ranges defined by the bounded location description entries of a; location list expression may overlap. When they do, they describe a situation in; which an object exists simultaneously in more than one place. If all of the address ranges in a given location list expression do not; collectively cover the entire range over which the object in question is; defined, and there is no following default location description entry, it is; assumed that the object is not available for the portion of the range that is; not covered. The result of the evaluation of a DWARF location list expression is:. * If the current program location is not specified, then it is an evaluation; error. .. note::. If the location list only has a single default entry, should that be; considered a match if there is no program location? If there are non-default; entries then it seems it has to be an evaluation error when there is no; program location as that indicates the location depends on the program; location which is not known. * If there are no matching location list entries, then the result is a location; description that comprises one undefined location description. * Otherwise, the operation expression E of each matching location list entry is; evaluated with the current context, except that the result kind is a location; description, the object is unspecified, and the i",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:145554,Availability,error,error,145554,"licable base address defaults to the base address; of the compilation unit (see DWARF Version 5 section 3.1.1). In the case of a compilation unit where all of the machine code is contained; in a single contiguous section, no base address entry is needed. *End-of-list*. This kind of location list entry marks the end of the location list; expression. The address ranges defined by the bounded location description entries of a; location list expression may overlap. When they do, they describe a situation in; which an object exists simultaneously in more than one place. If all of the address ranges in a given location list expression do not; collectively cover the entire range over which the object in question is; defined, and there is no following default location description entry, it is; assumed that the object is not available for the portion of the range that is; not covered. The result of the evaluation of a DWARF location list expression is:. * If the current program location is not specified, then it is an evaluation; error. .. note::. If the location list only has a single default entry, should that be; considered a match if there is no program location? If there are non-default; entries then it seems it has to be an evaluation error when there is no; program location as that indicates the location depends on the program; location which is not known. * If there are no matching location list entries, then the result is a location; description that comprises one undefined location description. * Otherwise, the operation expression E of each matching location list entry is; evaluated with the current context, except that the result kind is a location; description, the object is unspecified, and the initial stack is empty. The; location list entry result is the location description returned by the; evaluation of E. The result is a location description that is comprised of the union of the; single location descriptions of the location description result of each; match",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:145769,Availability,error,error,145769,"ction, no base address entry is needed. *End-of-list*. This kind of location list entry marks the end of the location list; expression. The address ranges defined by the bounded location description entries of a; location list expression may overlap. When they do, they describe a situation in; which an object exists simultaneously in more than one place. If all of the address ranges in a given location list expression do not; collectively cover the entire range over which the object in question is; defined, and there is no following default location description entry, it is; assumed that the object is not available for the portion of the range that is; not covered. The result of the evaluation of a DWARF location list expression is:. * If the current program location is not specified, then it is an evaluation; error. .. note::. If the location list only has a single default entry, should that be; considered a match if there is no program location? If there are non-default; entries then it seems it has to be an evaluation error when there is no; program location as that indicates the location depends on the program; location which is not known. * If there are no matching location list entries, then the result is a location; description that comprises one undefined location description. * Otherwise, the operation expression E of each matching location list entry is; evaluated with the current context, except that the result kind is a location; description, the object is unspecified, and the initial stack is empty. The; location list entry result is the location description returned by the; evaluation of E. The result is a location description that is comprised of the union of the; single location descriptions of the location description result of each; matching location list entry. A location list expression can only be used as the value of a debugger; information entry attribute that is encoded using class ``loclist`` or; ``loclistsptr`` (see :ref:`amdgpu-dwarf-class",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:164398,Availability,mask,mask,164398," undefined location description or one memory location description.*. If not present, the target architecture thread is not being used in a SIMT; manner, and the thread's current program location is used. 6. For languages that are implemented using a SIMT execution model, a; ``DW_TAG_subprogram``, ``DW_TAG_inlined_subroutine``, or; ``DW_TAG_entry_point`` debugger information entry may have a; ``DW_AT_LLVM_active_lane`` attribute whose value is a DWARF expression E. E is evaluated with a context that has a result kind of a location; description, an unspecified object, the compilation unit that contains E, an; empty initial stack, and other context elements corresponding to the source; language thread of execution upon which the user is focused, if any. The DWARF is ill-formed if L does not have exactly one single location; description SL. The active lane bit mask V for the current program location is obtained by; reading from SL using a target architecture specific integral base type T; that has a bit size equal to the value of the ``DW_AT_LLVM_lanes`` attribute; of the subprogram corresponding to context's frame and program location. The; N\ :sup:`th` least significant bit of the mask corresponds to the N\; :sup:`th` lane. If the bit is 1 the lane is active, otherwise it is; inactive. The result of the attribute is the value V. *Some targets may update the target architecture execution mask for regions; of code that must execute with different sets of lanes than the current; active lanes. For example, some code must execute with all lanes made; temporarily active.* ``DW_AT_LLVM_active_lane`` *allows the compiler to; provide the means to determine the source language active lanes at any; program location. Typically, this attribute will use a loclist to express; different locations of the active lane mask at different program locations.*. If not present and ``DW_AT_LLVM_lanes`` is greater than 1, then the target; architecture execution mask is used. 7. A ``DW_TAG_subp",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:164727,Availability,mask,mask,164727,"is used. 6. For languages that are implemented using a SIMT execution model, a; ``DW_TAG_subprogram``, ``DW_TAG_inlined_subroutine``, or; ``DW_TAG_entry_point`` debugger information entry may have a; ``DW_AT_LLVM_active_lane`` attribute whose value is a DWARF expression E. E is evaluated with a context that has a result kind of a location; description, an unspecified object, the compilation unit that contains E, an; empty initial stack, and other context elements corresponding to the source; language thread of execution upon which the user is focused, if any. The DWARF is ill-formed if L does not have exactly one single location; description SL. The active lane bit mask V for the current program location is obtained by; reading from SL using a target architecture specific integral base type T; that has a bit size equal to the value of the ``DW_AT_LLVM_lanes`` attribute; of the subprogram corresponding to context's frame and program location. The; N\ :sup:`th` least significant bit of the mask corresponds to the N\; :sup:`th` lane. If the bit is 1 the lane is active, otherwise it is; inactive. The result of the attribute is the value V. *Some targets may update the target architecture execution mask for regions; of code that must execute with different sets of lanes than the current; active lanes. For example, some code must execute with all lanes made; temporarily active.* ``DW_AT_LLVM_active_lane`` *allows the compiler to; provide the means to determine the source language active lanes at any; program location. Typically, this attribute will use a loclist to express; different locations of the active lane mask at different program locations.*. If not present and ``DW_AT_LLVM_lanes`` is greater than 1, then the target; architecture execution mask is used. 7. A ``DW_TAG_subprogram``, ``DW_TAG_inlined_subroutine``, or; ``DW_TAG_entry_point`` debugger information entry may have a; ``DW_AT_LLVM_iterations`` attribute whose value is an integer constant or a; DWARF express",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:164937,Availability,mask,mask,164937,"e whose value is a DWARF expression E. E is evaluated with a context that has a result kind of a location; description, an unspecified object, the compilation unit that contains E, an; empty initial stack, and other context elements corresponding to the source; language thread of execution upon which the user is focused, if any. The DWARF is ill-formed if L does not have exactly one single location; description SL. The active lane bit mask V for the current program location is obtained by; reading from SL using a target architecture specific integral base type T; that has a bit size equal to the value of the ``DW_AT_LLVM_lanes`` attribute; of the subprogram corresponding to context's frame and program location. The; N\ :sup:`th` least significant bit of the mask corresponds to the N\; :sup:`th` lane. If the bit is 1 the lane is active, otherwise it is; inactive. The result of the attribute is the value V. *Some targets may update the target architecture execution mask for regions; of code that must execute with different sets of lanes than the current; active lanes. For example, some code must execute with all lanes made; temporarily active.* ``DW_AT_LLVM_active_lane`` *allows the compiler to; provide the means to determine the source language active lanes at any; program location. Typically, this attribute will use a loclist to express; different locations of the active lane mask at different program locations.*. If not present and ``DW_AT_LLVM_lanes`` is greater than 1, then the target; architecture execution mask is used. 7. A ``DW_TAG_subprogram``, ``DW_TAG_inlined_subroutine``, or; ``DW_TAG_entry_point`` debugger information entry may have a; ``DW_AT_LLVM_iterations`` attribute whose value is an integer constant or a; DWARF expression E. Its value is the number of source language loop; iterations executing concurrently by the target architecture for a single; source language thread of execution. *A compiler may generate code that executes more than one iteratio",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:165358,Availability,mask,mask,165358," have exactly one single location; description SL. The active lane bit mask V for the current program location is obtained by; reading from SL using a target architecture specific integral base type T; that has a bit size equal to the value of the ``DW_AT_LLVM_lanes`` attribute; of the subprogram corresponding to context's frame and program location. The; N\ :sup:`th` least significant bit of the mask corresponds to the N\; :sup:`th` lane. If the bit is 1 the lane is active, otherwise it is; inactive. The result of the attribute is the value V. *Some targets may update the target architecture execution mask for regions; of code that must execute with different sets of lanes than the current; active lanes. For example, some code must execute with all lanes made; temporarily active.* ``DW_AT_LLVM_active_lane`` *allows the compiler to; provide the means to determine the source language active lanes at any; program location. Typically, this attribute will use a loclist to express; different locations of the active lane mask at different program locations.*. If not present and ``DW_AT_LLVM_lanes`` is greater than 1, then the target; architecture execution mask is used. 7. A ``DW_TAG_subprogram``, ``DW_TAG_inlined_subroutine``, or; ``DW_TAG_entry_point`` debugger information entry may have a; ``DW_AT_LLVM_iterations`` attribute whose value is an integer constant or a; DWARF expression E. Its value is the number of source language loop; iterations executing concurrently by the target architecture for a single; source language thread of execution. *A compiler may generate code that executes more than one iteration of a; source language loop concurrently using optimization techniques such as; software pipelining or SIMD vectorization. The number of concurrent; iterations may vary for different loop nests in the same subprogram.; Typically, this attribute will use a loclist to express different values at; different program locations.*. If the attribute is an integer constant, ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:165496,Availability,mask,mask,165496,"; reading from SL using a target architecture specific integral base type T; that has a bit size equal to the value of the ``DW_AT_LLVM_lanes`` attribute; of the subprogram corresponding to context's frame and program location. The; N\ :sup:`th` least significant bit of the mask corresponds to the N\; :sup:`th` lane. If the bit is 1 the lane is active, otherwise it is; inactive. The result of the attribute is the value V. *Some targets may update the target architecture execution mask for regions; of code that must execute with different sets of lanes than the current; active lanes. For example, some code must execute with all lanes made; temporarily active.* ``DW_AT_LLVM_active_lane`` *allows the compiler to; provide the means to determine the source language active lanes at any; program location. Typically, this attribute will use a loclist to express; different locations of the active lane mask at different program locations.*. If not present and ``DW_AT_LLVM_lanes`` is greater than 1, then the target; architecture execution mask is used. 7. A ``DW_TAG_subprogram``, ``DW_TAG_inlined_subroutine``, or; ``DW_TAG_entry_point`` debugger information entry may have a; ``DW_AT_LLVM_iterations`` attribute whose value is an integer constant or a; DWARF expression E. Its value is the number of source language loop; iterations executing concurrently by the target architecture for a single; source language thread of execution. *A compiler may generate code that executes more than one iteration of a; source language loop concurrently using optimization techniques such as; software pipelining or SIMD vectorization. The number of concurrent; iterations may vary for different loop nests in the same subprogram.; Typically, this attribute will use a loclist to express different values at; different program locations.*. If the attribute is an integer constant, then the value is the constant. The; DWARF is ill-formed if the constant is less than or equal to 0. Otherwise, E is evaluate",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:188639,Availability,avail,available,188639,"[:ref:`SEMVER; <amdgpu-dwarf-SEMVER>`]. The *options* string must not contain the ""\ ``]``\ ""; character. For example:. ::. [abc:v0.0][def:v1.2:feature-a=on,feature-b=3]. .. note::. This is different to the definition in DWARF Version 5 but is consistent with; the other augmentation strings and allows multiple vendor extensions to be; supported. .. _amdgpu-dwarf-line-number-information:. A.6.2 Line Number Information; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. A.6.2.4 The Line Number Program Header; ++++++++++++++++++++++++++++++++++++++. A.6.2.4.1 Standard Content Descriptions; #######################################. .. note::. This augments DWARF Version 5 section 6.2.4.1. .. _amdgpu-dwarf-line-number-information-dw-lnct-llvm-source:. 1. ``DW_LNCT_LLVM_source``. The component is a null-terminated UTF-8 source text string with ""\ ``\n``\; "" line endings. This content code is paired with the same forms as; ``DW_LNCT_path``. It can be used for file name entries. The value is an empty null-terminated string if no source is available. If; the source is available but is an empty file then the value is a; null-terminated single ""\ ``\n``\ "". *When the source field is present, consumers can use the embedded source; instead of attempting to discover the source on disk using the file path; provided by the* ``DW_LNCT_path`` *field. When the source field is absent,; consumers can access the file to get the source text.*. *This is particularly useful for programming languages that support runtime; compilation and runtime generation of source text. In these cases, the; source text does not reside in any permanent file. For example, the OpenCL; language [:ref:`OpenCL <amdgpu-dwarf-OpenCL>`] supports online compilation.*. 2. ``DW_LNCT_LLVM_is_MD5``. ``DW_LNCT_LLVM_is_MD5`` indicates if the ``DW_LNCT_MD5`` content kind, if; present, is valid: when 0 it is not valid and when 1 it is valid. If; ``DW_LNCT_LLVM_is_MD5`` content kind is not present, and ``DW_LNCT_MD5``; content kind is present, t",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:188668,Availability,avail,available,188668,"`\ ""; character. For example:. ::. [abc:v0.0][def:v1.2:feature-a=on,feature-b=3]. .. note::. This is different to the definition in DWARF Version 5 but is consistent with; the other augmentation strings and allows multiple vendor extensions to be; supported. .. _amdgpu-dwarf-line-number-information:. A.6.2 Line Number Information; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. A.6.2.4 The Line Number Program Header; ++++++++++++++++++++++++++++++++++++++. A.6.2.4.1 Standard Content Descriptions; #######################################. .. note::. This augments DWARF Version 5 section 6.2.4.1. .. _amdgpu-dwarf-line-number-information-dw-lnct-llvm-source:. 1. ``DW_LNCT_LLVM_source``. The component is a null-terminated UTF-8 source text string with ""\ ``\n``\; "" line endings. This content code is paired with the same forms as; ``DW_LNCT_path``. It can be used for file name entries. The value is an empty null-terminated string if no source is available. If; the source is available but is an empty file then the value is a; null-terminated single ""\ ``\n``\ "". *When the source field is present, consumers can use the embedded source; instead of attempting to discover the source on disk using the file path; provided by the* ``DW_LNCT_path`` *field. When the source field is absent,; consumers can access the file to get the source text.*. *This is particularly useful for programming languages that support runtime; compilation and runtime generation of source text. In these cases, the; source text does not reside in any permanent file. For example, the OpenCL; language [:ref:`OpenCL <amdgpu-dwarf-OpenCL>`] supports online compilation.*. 2. ``DW_LNCT_LLVM_is_MD5``. ``DW_LNCT_LLVM_is_MD5`` indicates if the ``DW_LNCT_MD5`` content kind, if; present, is valid: when 0 it is not valid and when 1 it is valid. If; ``DW_LNCT_LLVM_is_MD5`` content kind is not present, and ``DW_LNCT_MD5``; content kind is present, then the MD5 checksum is valid. ``DW_LNCT_LLVM_is_MD5`` is always paired with the ``DW_FORM",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:190610,Availability,recover,recoverable,190610,"resent, then the MD5 checksum is valid. ``DW_LNCT_LLVM_is_MD5`` is always paired with the ``DW_FORM_udata`` form. *This allows a compilation unit to have a mixture of files with and without; MD5 checksums. This can happen when multiple relocatable files are linked; together.*. .. _amdgpu-dwarf-call-frame-information:. A.6.4 Call Frame Information; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. note::. This section provides changes to existing call frame information and defines; instructions added by these extensions. Additional support is added for; address spaces. Register unwind DWARF expressions are generalized to allow any; location description, including those with composite and implicit location; descriptions. These changes would be incorporated into the DWARF Version 5 section 6.4. .. _amdgpu-dwarf-structure_of-call-frame-information:. A.6.4.1 Structure of Call Frame Information; +++++++++++++++++++++++++++++++++++++++++++. The register rules are:. *undefined*; A register that has this rule has no recoverable value in the previous frame.; The previous value of this register is the undefined location description (see; :ref:`amdgpu-dwarf-undefined-location-description-operations`). *By convention, the register is not preserved by a callee.*. *same value*; This register has not been modified from the previous caller frame. If the current frame is the top frame, then the previous value of this; register is the location description L that specifies one register location; description SL. SL specifies the register location storage that corresponds to; the register with a bit offset of 0 for the current thread. If the current frame is not the top frame, then the previous value of this; register is the location description obtained using the call frame information; for the callee frame and callee program location invoked by the current caller; frame for the same register. *By convention, the register is preserved by the callee, but the callee has; not modified it.*. *offset(N)*; N i",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:228186,Availability,mask,mask,228186,"f the memory location is calculated by adding 16 to the value; contained in register 5 upon entering the current subprogram. D.2 Aggregate Examples; ~~~~~~~~~~~~~~~~~~~~~~. D.2.1 Fortran Simple Array Example; ++++++++++++++++++++++++++++++++++. Figure D.4: Fortran array example: DWARF description. .. code::; :number-lines:. -------------------------------------------------------------------------------; ! Description for type of 'ap'; !; 1$: DW_TAG_array_type; ! No name, default (Fortran) ordering, default stride; DW_AT_type(reference to REAL); DW_AT_associated(expression= ! Test 'ptr_assoc' flag; DW_OP_push_object_address; DW_OP_lit<n> ! where n == offset(ptr_assoc); DW_OP_offset; DW_OP_deref; DW_OP_lit1 ! mask for 'ptr_assoc' flag; DW_OP_and); DW_AT_data_location(expression= ! Get raw data address; DW_OP_push_object_address; DW_OP_lit<n> ! where n == offset(base); DW_OP_offset; DW_OP_deref) ! Type of index of array 'ap'; 2$: DW_TAG_subrange_type; ! No name, default stride; DW_AT_type(reference to INTEGER); DW_AT_lower_bound(expression=; DW_OP_push_object_address; DW_OP_lit<n> ! where n ==; ! offset(desc, dims) +; ! offset(dims_str, lower_bound); DW_OP_offset; DW_OP_deref); DW_AT_upper_bound(expression=; DW_OP_push_object_address; DW_OP_lit<n> ! where n ==; ! offset(desc, dims) +; ! offset(dims_str, upper_bound); DW_OP_offset; DW_OP_deref); ! Note: for the m'th dimension, the second operator becomes; ! DW_OP_lit<n> where; ! n == offset(desc, dims) +; ! (m-1)*sizeof(dims_str) +; ! offset(dims_str, [lower|upper]_bound); ! That is, the expression does not get longer for each successive; ! dimension (other than to express the larger offsets involved).; 3$: DW_TAG_structure_type; DW_AT_name(""array_ptr""); DW_AT_byte_size(constant sizeof(REAL) + sizeof(desc<1>)); 4$: DW_TAG_member; DW_AT_name(""myvar""); DW_AT_type(reference to REAL); DW_AT_data_member_location(constant 0); 5$: DW_TAG_member; DW_AT_name(""ap"");; DW_AT_type(reference to 1$); DW_AT_data_member_location(constant",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:234095,Availability,avail,available,234095,"ructure_type; DW_AT_name(""REC2""); 27$: DW_TAG_member; DW_AT_name(""N""); DW_AT_type(reference to subtype TEENY at 21$); DW_AT_data_member_location(constant 0); 28$: DW_TAG_array_type; ! No name, default (Ada) order, default stride; ! Default data location; DW_AT_type(reference to INTEGER); 29$: DW_TAG_subrange_type; DW_AT_type(reference to subrange TEENY at 21$); DW_AT_lower_bound(constant 1); DW_AT_upper_bound(reference to member N at 27$); 30$: DW_TAG_member; DW_AT_name(""VEC2""); DW_AT_type(reference to array ""subtype"" at 28$); DW_AT_data_member_location(machine=; DW_OP_lit<n> ! where n == offset(REC2, VEC2); DW_OP_offset); ...; 41$: DW_TAG_variable; DW_AT_name(""OBJ2B""); DW_AT_type(reference to REC2 at 26$); DW_AT_location(...as appropriate...); ----------------------------------------------------------------------------. .. _amdgpu-dwarf-further-examples:. C. Further Examples; ===================. The AMD GPU specific usage of the features in these extensions, including; examples, is available at *User Guide for AMDGPU Backend* section; :ref:`amdgpu-dwarf-debug-information`. .. note::. Change examples to use ``DW_OP_LLVM_offset`` instead of ``DW_OP_add`` when; acting on a location description. Need to provide examples of new features. .. _amdgpu-dwarf-references:. D. References; =============. .. _amdgpu-dwarf-AMD:. 1. [AMD] `Advanced Micro Devices <https://www.amd.com/>`__. .. _amdgpu-dwarf-AMD-ROCgdb:. 2. [AMD-ROCgdb] `AMD ROCm Debugger (ROCgdb) <https://github.com/ROCm-Developer-Tools/ROCgdb>`__. .. _amdgpu-dwarf-AMD-ROCm:. 3. [AMD-ROCm] `AMD ROCm Platform <https://rocm-documentation.readthedocs.io>`__. .. _amdgpu-dwarf-AMDGPU-DWARF-LOC:. 4. [AMDGPU-DWARF-LOC] `Allow Location Descriptions on the DWARF Expression Stack <https://llvm.org/docs/AMDGPUDwarfExtensionAllowLocationDescriptionOnTheDwarfExpressionStack/AMDGPUDwarfExtensionAllowLocationDescriptionOnTheDwarfExpressionStack.html>`__. .. _amdgpu-dwarf-AMDGPU-LLVM:. 5. [AMDGPU-LLVM] `User Guide for AMDGPU LLVM B",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:11028,Deployability,update,updated,11028,"e; generalized to support location descriptions that can have multiple places. This; is backwards compatible with DWARF Version 5 and allows objects with multiple; places to be supported. For example, the expression that describes how to access; the field of an object can be evaluated with a location description that has; multiple places and will result in a location description with multiple places. With this change, the separate DWARF Version 5 sections that described DWARF; expressions and location lists are unified into a single section that describes; DWARF expressions in general. This unification is a natural consequence of, and; a necessity of, allowing location descriptions to be part of the evaluation; stack. See :ref:`amdgpu-dwarf-location-description`. 2.4 Generalize Offsetting of Location Descriptions; --------------------------------------------------. The ``DW_OP_plus`` and ``DW_OP_minus`` operations can be defined to operate on a; memory location description in the default target architecture specific address; space and a generic type value to produce an updated memory location; description. This allows them to continue to be used to offset an address. To generalize offsetting to any location description, including location; descriptions that describe when bytes are in registers, are implicit, or a; composite of these, the ``DW_OP_LLVM_offset``, ``DW_OP_LLVM_offset_uconst``, and; ``DW_OP_LLVM_bit_offset`` offset operations are added. The offset operations can operate on location storage of any size. For example,; implicit location storage could be any number of bits in size. It is simpler to; define offsets that exceed the size of the location storage as being an; evaluation error, than having to force an implementation to support potentially; infinite precision offsets to allow it to correctly track a series of positive; and negative offsets that may transiently overflow or underflow, but end up in; range. This is simple for the arithmetic operations",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:29411,Deployability,update,update,29411,"he compiler to communicate how many source; language threads of execution are mapped to a target architecture thread's SIMT; lanes. See ``DW_AT_LLVM_lanes`` in :ref:`amdgpu-dwarf-low-level-information`. .. _amdgpu-dwarf-support-for-divergent-control-flow-of-simt-hardware:. 2.13 Support for Divergent Control Flow of SIMT Hardware; --------------------------------------------------------. If the source language is mapped onto the AMDGPU wavefronts in a SIMT manner the; compiler can use the AMDGPU execution mask register to control which lanes are; active. To describe the conceptual location of non-active lanes requires an; attribute that has an expression that computes the source location PC for each; lane. For efficiency, the expression calculates the source location the wavefront as a; whole. This can be done using the ``DW_OP_LLVM_select_bit_piece`` (see; :ref:`amdgpu-dwarf-operation-to-create-vector-composite-location-descriptions`); operation. The AMDGPU may update the execution mask to perform whole wavefront operations.; Therefore, there is a need for an attribute that computes the current active; lane mask. This can have an expression that may evaluate to the SIMT active lane; mask register or to a saved mask when in whole wavefront execution mode. An example that uses these attributes is referenced in the; :ref:`amdgpu-dwarf-further-examples` appendix. See ``DW_AT_LLVM_lane_pc`` and ``DW_AT_LLVM_active_lane`` in; :ref:`amdgpu-dwarf-composite-location-description-operations`. 2.14 Define Source Language Memory Classes; -------------------------------------------. AMDGPU supports languages, such as OpenCL [:ref:`OpenCL <amdgpu-dwarf-OpenCL>`],; that define source language memory classes. Support is added to define language; specific memory spaces so they can be used in a consistent way by consumers. Support for using memory spaces in defining source language types and data; object allocation is also added. See :ref:`amdgpu-dwarf-memory-spaces`. 2.15 Define Augm",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:61178,Deployability,update,updated,61178,"itialized. *A location description that has more than one single location description can; only be created by a location list expression that has overlapping program; location ranges, or certain expression operations that act on a location; description that has more than one single location description. There are no; operation expression operations that can directly create a location description; with more than one single location description.*. *A location description with more than one single location description can be; used to describe objects that reside in more than one piece of storage at the; same time. An object may have more than one location as a result of; optimization. For example, a value that is only read may be promoted from memory; to a register for some region of code, but later code may revert to reading the; value from memory as the register may be used for other purposes. For the code; region where the value is in a register, any change to the object value must be; made in both the register and the memory so both regions of code will read the; updated value.*. *A consumer of a location description with more than one single location; description can read the object's value from any of the single location; descriptions (since they all refer to location storage that has the same value),; but must write any changed value to all the single location descriptions.*. The evaluation of an expression may require context elements to create a; location description. If such a location description is accessed, the storage it; denotes is that associated with the context element values specified when the; location description was created, which may differ from the context at the time; it is accessed. *For example, creating a register location description requires the thread; context: the location storage is for the specified register of that thread.; Creating a memory location description for an address space may required a; thread and a lane context: the locat",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:69362,Deployability,update,update,69362,".4.1 Stack Operations; ##########################. .. note::. This section replaces DWARF Version 5 section 2.5.1.3. The following operations manipulate the DWARF stack. Operations that index the; stack assume that the top of the stack (most recently added entry) has index 0.; They allow the stack entries to be either a value or location description. If any stack entry accessed by a stack operation is an incomplete composite; location description (see; :ref:`amdgpu-dwarf-composite-location-description-operations`), then the DWARF; expression is ill-formed. .. note::. These operations now support stack entries that are values and location; descriptions. .. note::. If it is desired to also make them work with incomplete composite location; descriptions, then would need to define that the composite location storage; specified by the incomplete composite location description is also replicated; when a copy is pushed. This ensures that each copy of the incomplete composite; location description can update the composite location storage they specify; independently. 1. ``DW_OP_dup``. ``DW_OP_dup`` duplicates the stack entry at the top of the stack. 2. ``DW_OP_drop``. ``DW_OP_drop`` pops the stack entry at the top of the stack and discards it. 3. ``DW_OP_pick``. ``DW_OP_pick`` has a single unsigned 1-byte operand that represents an index; I. A copy of the stack entry with index I is pushed onto the stack. 4. ``DW_OP_over``. ``DW_OP_over`` pushes a copy of the entry with index 1. *This is equivalent to a* ``DW_OP_pick 1`` *operation.*. 5. ``DW_OP_swap``. ``DW_OP_swap`` swaps the top two stack entries. The entry at the top of the; stack becomes the second stack entry, and the second stack entry becomes the; top of the stack. 6. ``DW_OP_rot``. ``DW_OP_rot`` rotates the first three stack entries. The entry at the top of; the stack becomes the third stack entry, the second entry becomes the top of; the stack, and the third entry becomes the second entry. *Examples illustrating ma",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:71232,Deployability,update,updated,71232," the third entry becomes the second entry. *Examples illustrating many of these stack operations are found in Appendix; D.1.2 on page 289.*. .. _amdgpu-dwarf-control-flow-operations:. A.2.5.4.2 Control Flow Operations; #################################. .. note::. This section replaces DWARF Version 5 section 2.5.1.5. The following operations provide simple control of the flow of a DWARF operation; expression. 1. ``DW_OP_nop``. ``DW_OP_nop`` is a place holder. It has no effect on the DWARF stack; entries. 2. ``DW_OP_le``, ``DW_OP_ge``, ``DW_OP_eq``, ``DW_OP_lt``, ``DW_OP_gt``,; ``DW_OP_ne``. .. note::. The same as in DWARF Version 5 section 2.5.1.5. 3. ``DW_OP_skip``. ``DW_OP_skip`` is an unconditional branch. Its single operand is a 2-byte; signed integer constant. The 2-byte constant is the number of bytes of the; DWARF expression to skip forward or backward from the current operation,; beginning after the 2-byte constant. If the updated position is at one past the end of the last operation, then; the operation expression evaluation is complete. Otherwise, the DWARF expression is ill-formed if the updated operation; position is not in the range of the first to last operation inclusive, or; not at the start of an operation. 4. ``DW_OP_bra``. ``DW_OP_bra`` is a conditional branch. Its single operand is a 2-byte signed; integer constant. This operation pops the top of stack. If the value popped; is not the constant 0, the 2-byte constant operand is the number of bytes of; the DWARF operation expression to skip forward or backward from the current; operation, beginning after the 2-byte constant. If the updated position is at one past the end of the last operation, then; the operation expression evaluation is complete. Otherwise, the DWARF expression is ill-formed if the updated operation; position is not in the range of the first to last operation inclusive, or; not at the start of an operation. 5. ``DW_OP_call2, DW_OP_call4, DW_OP_call_ref``. ``DW_OP_call2``, ``DW_OP_",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:71403,Deployability,update,updated,71403,"warf-control-flow-operations:. A.2.5.4.2 Control Flow Operations; #################################. .. note::. This section replaces DWARF Version 5 section 2.5.1.5. The following operations provide simple control of the flow of a DWARF operation; expression. 1. ``DW_OP_nop``. ``DW_OP_nop`` is a place holder. It has no effect on the DWARF stack; entries. 2. ``DW_OP_le``, ``DW_OP_ge``, ``DW_OP_eq``, ``DW_OP_lt``, ``DW_OP_gt``,; ``DW_OP_ne``. .. note::. The same as in DWARF Version 5 section 2.5.1.5. 3. ``DW_OP_skip``. ``DW_OP_skip`` is an unconditional branch. Its single operand is a 2-byte; signed integer constant. The 2-byte constant is the number of bytes of the; DWARF expression to skip forward or backward from the current operation,; beginning after the 2-byte constant. If the updated position is at one past the end of the last operation, then; the operation expression evaluation is complete. Otherwise, the DWARF expression is ill-formed if the updated operation; position is not in the range of the first to last operation inclusive, or; not at the start of an operation. 4. ``DW_OP_bra``. ``DW_OP_bra`` is a conditional branch. Its single operand is a 2-byte signed; integer constant. This operation pops the top of stack. If the value popped; is not the constant 0, the 2-byte constant operand is the number of bytes of; the DWARF operation expression to skip forward or backward from the current; operation, beginning after the 2-byte constant. If the updated position is at one past the end of the last operation, then; the operation expression evaluation is complete. Otherwise, the DWARF expression is ill-formed if the updated operation; position is not in the range of the first to last operation inclusive, or; not at the start of an operation. 5. ``DW_OP_call2, DW_OP_call4, DW_OP_call_ref``. ``DW_OP_call2``, ``DW_OP_call4``, and ``DW_OP_call_ref`` perform DWARF; procedure calls during evaluation of a DWARF operation expression. ``DW_OP_call2`` and ``DW_OP_call4``, ha",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:71914,Deployability,update,updated,71914,"OP_skip`` is an unconditional branch. Its single operand is a 2-byte; signed integer constant. The 2-byte constant is the number of bytes of the; DWARF expression to skip forward or backward from the current operation,; beginning after the 2-byte constant. If the updated position is at one past the end of the last operation, then; the operation expression evaluation is complete. Otherwise, the DWARF expression is ill-formed if the updated operation; position is not in the range of the first to last operation inclusive, or; not at the start of an operation. 4. ``DW_OP_bra``. ``DW_OP_bra`` is a conditional branch. Its single operand is a 2-byte signed; integer constant. This operation pops the top of stack. If the value popped; is not the constant 0, the 2-byte constant operand is the number of bytes of; the DWARF operation expression to skip forward or backward from the current; operation, beginning after the 2-byte constant. If the updated position is at one past the end of the last operation, then; the operation expression evaluation is complete. Otherwise, the DWARF expression is ill-formed if the updated operation; position is not in the range of the first to last operation inclusive, or; not at the start of an operation. 5. ``DW_OP_call2, DW_OP_call4, DW_OP_call_ref``. ``DW_OP_call2``, ``DW_OP_call4``, and ``DW_OP_call_ref`` perform DWARF; procedure calls during evaluation of a DWARF operation expression. ``DW_OP_call2`` and ``DW_OP_call4``, have one operand that is, respectively,; a 2-byte or 4-byte unsigned offset DR that represents the byte offset of a; debugging information entry D relative to the beginning of the current; compilation unit. ``DW_OP_call_ref`` has one operand that is a 4-byte unsigned value in the; 32-bit DWARF format, or an 8-byte unsigned value in the 64-bit DWARF format,; that represents the byte offset DR of a debugging information entry D; relative to the beginning of the ``.debug_info`` section that contains the; current compilation unit",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:72085,Deployability,update,updated,72085,"xpression to skip forward or backward from the current operation,; beginning after the 2-byte constant. If the updated position is at one past the end of the last operation, then; the operation expression evaluation is complete. Otherwise, the DWARF expression is ill-formed if the updated operation; position is not in the range of the first to last operation inclusive, or; not at the start of an operation. 4. ``DW_OP_bra``. ``DW_OP_bra`` is a conditional branch. Its single operand is a 2-byte signed; integer constant. This operation pops the top of stack. If the value popped; is not the constant 0, the 2-byte constant operand is the number of bytes of; the DWARF operation expression to skip forward or backward from the current; operation, beginning after the 2-byte constant. If the updated position is at one past the end of the last operation, then; the operation expression evaluation is complete. Otherwise, the DWARF expression is ill-formed if the updated operation; position is not in the range of the first to last operation inclusive, or; not at the start of an operation. 5. ``DW_OP_call2, DW_OP_call4, DW_OP_call_ref``. ``DW_OP_call2``, ``DW_OP_call4``, and ``DW_OP_call_ref`` perform DWARF; procedure calls during evaluation of a DWARF operation expression. ``DW_OP_call2`` and ``DW_OP_call4``, have one operand that is, respectively,; a 2-byte or 4-byte unsigned offset DR that represents the byte offset of a; debugging information entry D relative to the beginning of the current; compilation unit. ``DW_OP_call_ref`` has one operand that is a 4-byte unsigned value in the; 32-bit DWARF format, or an 8-byte unsigned value in the 64-bit DWARF format,; that represents the byte offset DR of a debugging information entry D; relative to the beginning of the ``.debug_info`` section that contains the; current compilation unit. D may not be in the current compilation unit. .. note::. DWARF Version 5 states that DR can be an offset in a ``.debug_info``; section other than the o",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:98639,Deployability,update,updated,98639,"virtually; unwound. The* ``DW_OP_LLVM_call_frame_entry_reg`` *operation provides access; to registers in the virtually unwound calling frame.*. .. note::. GDB only implements ``DW_OP_entry_value`` when E is exactly; ``DW_OP_reg*`` or ``DW_OP_breg*; DW_OP_deref*``. .. _amdgpu-dwarf-location-description-operations:. A.2.5.4.4 Location Description Operations; #########################################. This section describes the operations that push location descriptions on the; stack. .. _amdgpu-dwarf-general-location-description-operations:. A.2.5.4.4.1 General Location Description Operations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. note::. This section replaces part of DWARF Version 5 section 2.5.1.3. 1. ``DW_OP_LLVM_offset`` *New*. ``DW_OP_LLVM_offset`` pops two stack entries. The first must be an integral; type value that represents a byte displacement B. The second must be a; location description L. It adds the value of B scaled by 8 (the byte size) to the bit offset of each; single location description SL of L, and pushes the updated L. It is an evaluation error if the updated bit offset of any SL is less than 0; or greater than or equal to the size of the location storage specified by; SL. 2. ``DW_OP_LLVM_offset_uconst`` *New*. ``DW_OP_LLVM_offset_uconst`` has a single unsigned LEB128 integer operand; that represents a byte displacement B. The operation is equivalent to performing ``DW_OP_constu B;; DW_OP_LLVM_offset``. *This operation is supplied specifically to be able to encode more field; displacements in two bytes than can be done with* ``DW_OP_lit*;; DW_OP_LLVM_offset``\ *.*. .. note::. Should this be named ``DW_OP_LLVM_offset_uconst`` to match; ``DW_OP_plus_uconst``, or ``DW_OP_LLVM_offset_constu`` to match; ``DW_OP_constu``?. 3. ``DW_OP_LLVM_bit_offset`` *New*. ``DW_OP_LLVM_bit_offset`` pops two stack entries. The first must be an; integral type value that represents a bit displacement B. The second must be; a location description L. It ad",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:98683,Deployability,update,updated,98683,"te::. GDB only implements ``DW_OP_entry_value`` when E is exactly; ``DW_OP_reg*`` or ``DW_OP_breg*; DW_OP_deref*``. .. _amdgpu-dwarf-location-description-operations:. A.2.5.4.4 Location Description Operations; #########################################. This section describes the operations that push location descriptions on the; stack. .. _amdgpu-dwarf-general-location-description-operations:. A.2.5.4.4.1 General Location Description Operations; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^. .. note::. This section replaces part of DWARF Version 5 section 2.5.1.3. 1. ``DW_OP_LLVM_offset`` *New*. ``DW_OP_LLVM_offset`` pops two stack entries. The first must be an integral; type value that represents a byte displacement B. The second must be a; location description L. It adds the value of B scaled by 8 (the byte size) to the bit offset of each; single location description SL of L, and pushes the updated L. It is an evaluation error if the updated bit offset of any SL is less than 0; or greater than or equal to the size of the location storage specified by; SL. 2. ``DW_OP_LLVM_offset_uconst`` *New*. ``DW_OP_LLVM_offset_uconst`` has a single unsigned LEB128 integer operand; that represents a byte displacement B. The operation is equivalent to performing ``DW_OP_constu B;; DW_OP_LLVM_offset``. *This operation is supplied specifically to be able to encode more field; displacements in two bytes than can be done with* ``DW_OP_lit*;; DW_OP_LLVM_offset``\ *.*. .. note::. Should this be named ``DW_OP_LLVM_offset_uconst`` to match; ``DW_OP_plus_uconst``, or ``DW_OP_LLVM_offset_constu`` to match; ``DW_OP_constu``?. 3. ``DW_OP_LLVM_bit_offset`` *New*. ``DW_OP_LLVM_bit_offset`` pops two stack entries. The first must be an; integral type value that represents a bit displacement B. The second must be; a location description L. It adds the value of B to the bit offset of each single location description; SL of L, and pushes the updated L. It is an evaluation error if the updated ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:99676,Deployability,update,updated,99676,"ushes the updated L. It is an evaluation error if the updated bit offset of any SL is less than 0; or greater than or equal to the size of the location storage specified by; SL. 2. ``DW_OP_LLVM_offset_uconst`` *New*. ``DW_OP_LLVM_offset_uconst`` has a single unsigned LEB128 integer operand; that represents a byte displacement B. The operation is equivalent to performing ``DW_OP_constu B;; DW_OP_LLVM_offset``. *This operation is supplied specifically to be able to encode more field; displacements in two bytes than can be done with* ``DW_OP_lit*;; DW_OP_LLVM_offset``\ *.*. .. note::. Should this be named ``DW_OP_LLVM_offset_uconst`` to match; ``DW_OP_plus_uconst``, or ``DW_OP_LLVM_offset_constu`` to match; ``DW_OP_constu``?. 3. ``DW_OP_LLVM_bit_offset`` *New*. ``DW_OP_LLVM_bit_offset`` pops two stack entries. The first must be an; integral type value that represents a bit displacement B. The second must be; a location description L. It adds the value of B to the bit offset of each single location description; SL of L, and pushes the updated L. It is an evaluation error if the updated bit offset of any SL is less than 0; or greater than or equal to the size of the location storage specified by; SL. 4. ``DW_OP_push_object_address``. ``DW_OP_push_object_address`` pushes the location description L of the; current object. *This object may correspond to an independent variable that is part of a; user presented expression that is being evaluated. The object location; description may be determined from the variable's own debugging information; entry or it may be a component of an array, structure, or class whose; address has been dynamically determined by an earlier step during user; expression evaluation.*. *This operation provides explicit functionality (especially for arrays; involving descriptors) that is analogous to the implicit push of the base; location description of a structure prior to evaluation of a*; ``DW_AT_data_member_location`` *to access a data member of a st",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:99720,Deployability,update,updated,99720," of the location storage specified by; SL. 2. ``DW_OP_LLVM_offset_uconst`` *New*. ``DW_OP_LLVM_offset_uconst`` has a single unsigned LEB128 integer operand; that represents a byte displacement B. The operation is equivalent to performing ``DW_OP_constu B;; DW_OP_LLVM_offset``. *This operation is supplied specifically to be able to encode more field; displacements in two bytes than can be done with* ``DW_OP_lit*;; DW_OP_LLVM_offset``\ *.*. .. note::. Should this be named ``DW_OP_LLVM_offset_uconst`` to match; ``DW_OP_plus_uconst``, or ``DW_OP_LLVM_offset_constu`` to match; ``DW_OP_constu``?. 3. ``DW_OP_LLVM_bit_offset`` *New*. ``DW_OP_LLVM_bit_offset`` pops two stack entries. The first must be an; integral type value that represents a bit displacement B. The second must be; a location description L. It adds the value of B to the bit offset of each single location description; SL of L, and pushes the updated L. It is an evaluation error if the updated bit offset of any SL is less than 0; or greater than or equal to the size of the location storage specified by; SL. 4. ``DW_OP_push_object_address``. ``DW_OP_push_object_address`` pushes the location description L of the; current object. *This object may correspond to an independent variable that is part of a; user presented expression that is being evaluated. The object location; description may be determined from the variable's own debugging information; entry or it may be a component of an array, structure, or class whose; address has been dynamically determined by an earlier step during user; expression evaluation.*. *This operation provides explicit functionality (especially for arrays; involving descriptors) that is analogous to the implicit push of the base; location description of a structure prior to evaluation of a*; ``DW_AT_data_member_location`` *to access a data member of a structure.*. .. note::. This operation could be removed and the object location description; specified as the initial stack as for ``DW_A",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:115122,Deployability,update,updated,115122,":ref:`amdgpu-dwarf-call-frame-information`. *Although the value of the* ``DW_AT_frame_base`` *attribute of the debugger; information entry corresponding to the current subprogram can be computed; using a location list expression, in some cases this would require an; extensive location list because the values of the registers used in; computing the CFA change during a subprogram execution. If the call frame; information is present, then it already encodes such changes, and it is; space efficient to reference that using the* ``DW_OP_call_frame_cfa``; *operation.*. 6. ``DW_OP_fbreg``. ``DW_OP_fbreg`` has a single signed LEB128 integer operand that represents a; byte displacement B. The location description L for the *frame base* of the current subprogram is; obtained from the ``DW_AT_frame_base`` attribute of the debugger information; entry corresponding to the current subprogram as described in; :ref:`amdgpu-dwarf-low-level-information`. The location description L is updated as if the ``DW_OP_LLVM_offset_uconst; B`` operation was applied. The updated L is pushed on the stack. 7. ``DW_OP_breg0``, ``DW_OP_breg1``, ..., ``DW_OP_breg31``. The ``DW_OP_breg<N>`` operations encode the numbers of up to 32 registers,; numbered from 0 through 31, inclusive. The register number R corresponds to; the N in the operation name. They have a single signed LEB128 integer operand that represents a byte; displacement B. The address space identifier AS is defined as the one corresponding to the; target architecture specific default address space. The address size S is defined as the address bit size of the target; architecture specific address space corresponding to AS. The contents of the register specified by R are retrieved as if a; ``DW_OP_regval_type R, DR`` operation was performed where DR is the offset; of a hypothetical debug information entry in the current compilation unit; for an unsigned integral base type of size S bits. B is added and the least; significant S bits are treated",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:115199,Deployability,update,updated,115199," ``DW_AT_frame_base`` *attribute of the debugger; information entry corresponding to the current subprogram can be computed; using a location list expression, in some cases this would require an; extensive location list because the values of the registers used in; computing the CFA change during a subprogram execution. If the call frame; information is present, then it already encodes such changes, and it is; space efficient to reference that using the* ``DW_OP_call_frame_cfa``; *operation.*. 6. ``DW_OP_fbreg``. ``DW_OP_fbreg`` has a single signed LEB128 integer operand that represents a; byte displacement B. The location description L for the *frame base* of the current subprogram is; obtained from the ``DW_AT_frame_base`` attribute of the debugger information; entry corresponding to the current subprogram as described in; :ref:`amdgpu-dwarf-low-level-information`. The location description L is updated as if the ``DW_OP_LLVM_offset_uconst; B`` operation was applied. The updated L is pushed on the stack. 7. ``DW_OP_breg0``, ``DW_OP_breg1``, ..., ``DW_OP_breg31``. The ``DW_OP_breg<N>`` operations encode the numbers of up to 32 registers,; numbered from 0 through 31, inclusive. The register number R corresponds to; the N in the operation name. They have a single signed LEB128 integer operand that represents a byte; displacement B. The address space identifier AS is defined as the one corresponding to the; target architecture specific default address space. The address size S is defined as the address bit size of the target; architecture specific address space corresponding to AS. The contents of the register specified by R are retrieved as if a; ``DW_OP_regval_type R, DR`` operation was performed where DR is the offset; of a hypothetical debug information entry in the current compilation unit; for an unsigned integral base type of size S bits. B is added and the least; significant S bits are treated as an unsigned value to be used as an address; A. They push a locatio",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:126905,Deployability,update,updated,126905,"ption, the compilation unit is; the one that contains D, the object is unspecified, and the initial stack; is empty. RL is the expression result. *Note that E is evaluated with the context of the expression accessing; IPV, and not the context of the expression that contained the*; ``DW_OP_implicit_pointer`` *or* ``DW_OP_LLVM_aspace_implicit_pointer``; *operation that created L.*. * If D has a ``DW_AT_const_value`` attribute, then an implicit location; storage RLS is created from the ``DW_AT_const_value`` attribute's value; with a size matching the size of the ``DW_AT_const_value`` attribute's; value. RL comprises one implicit location description SRL. SRL specifies; RLS with a bit offset of 0. .. note::. If using ``DW_AT_const_value`` for variables and formal parameters is; deprecated and instead ``DW_AT_location`` is used with an implicit; location description, then this rule would not be required. * Otherwise, it is an evaluation error. The bit offset of RL is updated as if the ``DW_OP_LLVM_offset_uconst B``; operation was applied. If a ``DW_OP_stack_value`` operation pops a value that is the same as IPV,; then it pushes a location description that is the same as L. It is an evaluation error if LS or IPV is accessed in any other manner. *The restrictions on how an implicit pointer location description created; by* ``DW_OP_implicit_pointer`` *and* ``DW_OP_LLVM_aspace_implicit_pointer``; *can be used are to simplify the DWARF consumer. Similarly, for an implicit; pointer value created by* ``DW_OP_deref*`` *and* ``DW_OP_stack_value``\ *.*. 4. ``DW_OP_LLVM_aspace_implicit_pointer`` *New*. ``DW_OP_LLVM_aspace_implicit_pointer`` has two operands that are the same as; for ``DW_OP_implicit_pointer``. It pops one stack entry that must be an integral type value that represents; a target architecture specific address space identifier AS. The location description L that is pushed on the stack is the same as for; ``DW_OP_implicit_pointer``, except that the address space identif",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:134178,Deployability,update,updated,134178,"ompose composite; location descriptions from any other location description, including those that; have multiple single location descriptions, and those that have composite; location descriptions.*. *The incremental composite location description operations are defined to be; compatible with the definitions in DWARF Version 5.*. 1. ``DW_OP_piece``. ``DW_OP_piece`` has a single unsigned LEB128 integer that represents a byte; size S. The action is based on the context:. * If the stack is empty, then a location description L comprised of one; incomplete composite location description SL is pushed on the stack. An incomplete composite location storage LS is created with a single part; P. P specifies a location description PL and has a bit size of S scaled by; 8 (the byte size). PL is comprised of one undefined location description; PSL. SL specifies LS with a bit offset of 0. * Otherwise, if the top stack entry is a location description L comprised of; one incomplete composite location description SL, then the incomplete; composite location storage LS that SL specifies is updated to append a new; part P. P specifies a location description PL and has a bit size of S; scaled by 8 (the byte size). PL is comprised of one undefined location; description PSL. L is left on the stack. * Otherwise, if the top stack entry is a location description or can be; converted to one, then it is popped and treated as a part location; description PL. Then:. * If the top stack entry (after popping PL) is a location description L; comprised of one incomplete composite location description SL, then the; incomplete composite location storage LS that SL specifies is updated to; append a new part P. P specifies the location description PL and has a; bit size of S scaled by 8 (the byte size). L is left on the stack. * Otherwise, a location description L comprised of one incomplete; composite location description SL is pushed on the stack. An incomplete composite location storage LS is created with",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:134759,Deployability,update,updated,134759,"escription SL is pushed on the stack. An incomplete composite location storage LS is created with a single part; P. P specifies a location description PL and has a bit size of S scaled by; 8 (the byte size). PL is comprised of one undefined location description; PSL. SL specifies LS with a bit offset of 0. * Otherwise, if the top stack entry is a location description L comprised of; one incomplete composite location description SL, then the incomplete; composite location storage LS that SL specifies is updated to append a new; part P. P specifies a location description PL and has a bit size of S; scaled by 8 (the byte size). PL is comprised of one undefined location; description PSL. L is left on the stack. * Otherwise, if the top stack entry is a location description or can be; converted to one, then it is popped and treated as a part location; description PL. Then:. * If the top stack entry (after popping PL) is a location description L; comprised of one incomplete composite location description SL, then the; incomplete composite location storage LS that SL specifies is updated to; append a new part P. P specifies the location description PL and has a; bit size of S scaled by 8 (the byte size). L is left on the stack. * Otherwise, a location description L comprised of one incomplete; composite location description SL is pushed on the stack. An incomplete composite location storage LS is created with a single; part P. P specifies the location description PL and has a bit size of S; scaled by 8 (the byte size). SL specifies LS with a bit offset of 0. * Otherwise, the DWARF expression is ill-formed. *Many compilers store a single variable in sets of registers or store a; variable partially in memory and partially in registers.* ``DW_OP_piece``; *provides a way of describing where a part of a variable is located.*. *If a non-0 byte displacement is required, the* ``DW_OP_LLVM_offset``; *operation can be used to update the location description before using it as; the par",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:135612,Deployability,update,update,135612," L; comprised of one incomplete composite location description SL, then the; incomplete composite location storage LS that SL specifies is updated to; append a new part P. P specifies the location description PL and has a; bit size of S scaled by 8 (the byte size). L is left on the stack. * Otherwise, a location description L comprised of one incomplete; composite location description SL is pushed on the stack. An incomplete composite location storage LS is created with a single; part P. P specifies the location description PL and has a bit size of S; scaled by 8 (the byte size). SL specifies LS with a bit offset of 0. * Otherwise, the DWARF expression is ill-formed. *Many compilers store a single variable in sets of registers or store a; variable partially in memory and partially in registers.* ``DW_OP_piece``; *provides a way of describing where a part of a variable is located.*. *If a non-0 byte displacement is required, the* ``DW_OP_LLVM_offset``; *operation can be used to update the location description before using it as; the part location description of a* ``DW_OP_piece`` *operation.*. *The evaluation rules for the* ``DW_OP_piece`` *operation allow it to be; compatible with the DWARF Version 5 definition.*. .. note::. Since these extensions allow location descriptions to be entries on the; stack, a simpler operation to create composite location descriptions could; be defined. For example, just one operation that specifies how many parts,; and pops pairs of stack entries for the part size and location; description. Not only would this be a simpler operation and avoid the; complexities of incomplete composite location descriptions, but it may; also have a smaller encoding in practice. However, the desire for; compatibility with DWARF Version 5 is likely a stronger consideration. 2. ``DW_OP_bit_piece``. ``DW_OP_bit_piece`` has two operands. The first is an unsigned LEB128; integer that represents the part bit size S. The second is an unsigned; LEB128 integer that",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:136808,Deployability,update,updated,136808,"e`` *operation allow it to be; compatible with the DWARF Version 5 definition.*. .. note::. Since these extensions allow location descriptions to be entries on the; stack, a simpler operation to create composite location descriptions could; be defined. For example, just one operation that specifies how many parts,; and pops pairs of stack entries for the part size and location; description. Not only would this be a simpler operation and avoid the; complexities of incomplete composite location descriptions, but it may; also have a smaller encoding in practice. However, the desire for; compatibility with DWARF Version 5 is likely a stronger consideration. 2. ``DW_OP_bit_piece``. ``DW_OP_bit_piece`` has two operands. The first is an unsigned LEB128; integer that represents the part bit size S. The second is an unsigned; LEB128 integer that represents a bit displacement B. The action is the same as for ``DW_OP_piece``, except that any part created; has the bit size S, and the location description PL of any created part is; updated as if the ``DW_OP_constu B; DW_OP_LLVM_bit_offset`` operations were; applied. ``DW_OP_bit_piece`` *is used instead of* ``DW_OP_piece`` *when the piece to; be assembled is not byte-sized or is not at the start of the part location; description.*. *If a computed bit displacement is required, the* ``DW_OP_LLVM_bit_offset``; *operation can be used to update the location description before using it as; the part location description of a* ``DW_OP_bit_piece`` *operation.*. .. note::. The bit offset operand is not needed as ``DW_OP_LLVM_bit_offset`` can be; used on the part's location description. 3. ``DW_OP_LLVM_piece_end`` *New*. If the top stack entry is not a location description L comprised of one; incomplete composite location description SL, then the DWARF expression is; ill-formed. Otherwise, the incomplete composite location storage LS specified by SL is; updated to be a complete composite location description with the same parts. 4. ``DW_OP_L",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:137165,Deployability,update,update,137165,"nly would this be a simpler operation and avoid the; complexities of incomplete composite location descriptions, but it may; also have a smaller encoding in practice. However, the desire for; compatibility with DWARF Version 5 is likely a stronger consideration. 2. ``DW_OP_bit_piece``. ``DW_OP_bit_piece`` has two operands. The first is an unsigned LEB128; integer that represents the part bit size S. The second is an unsigned; LEB128 integer that represents a bit displacement B. The action is the same as for ``DW_OP_piece``, except that any part created; has the bit size S, and the location description PL of any created part is; updated as if the ``DW_OP_constu B; DW_OP_LLVM_bit_offset`` operations were; applied. ``DW_OP_bit_piece`` *is used instead of* ``DW_OP_piece`` *when the piece to; be assembled is not byte-sized or is not at the start of the part location; description.*. *If a computed bit displacement is required, the* ``DW_OP_LLVM_bit_offset``; *operation can be used to update the location description before using it as; the part location description of a* ``DW_OP_bit_piece`` *operation.*. .. note::. The bit offset operand is not needed as ``DW_OP_LLVM_bit_offset`` can be; used on the part's location description. 3. ``DW_OP_LLVM_piece_end`` *New*. If the top stack entry is not a location description L comprised of one; incomplete composite location description SL, then the DWARF expression is; ill-formed. Otherwise, the incomplete composite location storage LS specified by SL is; updated to be a complete composite location description with the same parts. 4. ``DW_OP_LLVM_extend`` *New*. ``DW_OP_LLVM_extend`` has two operands. The first is an unsigned LEB128; integer that represents the element bit size S. The second is an unsigned; LEB128 integer that represents a count C. It pops one stack entry that must be a location description and is treated; as the part location description PL. A location description L comprised of one complete composite location; descr",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:137685,Deployability,update,updated,137685," ``DW_OP_piece``, except that any part created; has the bit size S, and the location description PL of any created part is; updated as if the ``DW_OP_constu B; DW_OP_LLVM_bit_offset`` operations were; applied. ``DW_OP_bit_piece`` *is used instead of* ``DW_OP_piece`` *when the piece to; be assembled is not byte-sized or is not at the start of the part location; description.*. *If a computed bit displacement is required, the* ``DW_OP_LLVM_bit_offset``; *operation can be used to update the location description before using it as; the part location description of a* ``DW_OP_bit_piece`` *operation.*. .. note::. The bit offset operand is not needed as ``DW_OP_LLVM_bit_offset`` can be; used on the part's location description. 3. ``DW_OP_LLVM_piece_end`` *New*. If the top stack entry is not a location description L comprised of one; incomplete composite location description SL, then the DWARF expression is; ill-formed. Otherwise, the incomplete composite location storage LS specified by SL is; updated to be a complete composite location description with the same parts. 4. ``DW_OP_LLVM_extend`` *New*. ``DW_OP_LLVM_extend`` has two operands. The first is an unsigned LEB128; integer that represents the element bit size S. The second is an unsigned; LEB128 integer that represents a count C. It pops one stack entry that must be a location description and is treated; as the part location description PL. A location description L comprised of one complete composite location; description SL is pushed on the stack. A complete composite location storage LS is created with C identical parts; P. Each P specifies PL and has a bit size of S. SL specifies LS with a bit offset of 0. The DWARF expression is ill-formed if the element bit size or count are 0. 5. ``DW_OP_LLVM_select_bit_piece`` *New*. ``DW_OP_LLVM_select_bit_piece`` has two operands. The first is an unsigned; LEB128 integer that represents the element bit size S. The second is an; unsigned LEB128 integer that represents a count ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:164896,Deployability,update,update,164896,"e whose value is a DWARF expression E. E is evaluated with a context that has a result kind of a location; description, an unspecified object, the compilation unit that contains E, an; empty initial stack, and other context elements corresponding to the source; language thread of execution upon which the user is focused, if any. The DWARF is ill-formed if L does not have exactly one single location; description SL. The active lane bit mask V for the current program location is obtained by; reading from SL using a target architecture specific integral base type T; that has a bit size equal to the value of the ``DW_AT_LLVM_lanes`` attribute; of the subprogram corresponding to context's frame and program location. The; N\ :sup:`th` least significant bit of the mask corresponds to the N\; :sup:`th` lane. If the bit is 1 the lane is active, otherwise it is; inactive. The result of the attribute is the value V. *Some targets may update the target architecture execution mask for regions; of code that must execute with different sets of lanes than the current; active lanes. For example, some code must execute with all lanes made; temporarily active.* ``DW_AT_LLVM_active_lane`` *allows the compiler to; provide the means to determine the source language active lanes at any; program location. Typically, this attribute will use a loclist to express; different locations of the active lane mask at different program locations.*. If not present and ``DW_AT_LLVM_lanes`` is greater than 1, then the target; architecture execution mask is used. 7. A ``DW_TAG_subprogram``, ``DW_TAG_inlined_subroutine``, or; ``DW_TAG_entry_point`` debugger information entry may have a; ``DW_AT_LLVM_iterations`` attribute whose value is an integer constant or a; DWARF expression E. Its value is the number of source language loop; iterations executing concurrently by the target architecture for a single; source language thread of execution. *A compiler may generate code that executes more than one iteratio",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:232307,Deployability,update,updated,232307,"_OP_mul ! dim[i]; DW_OP_lit<n> ! dim[i] offsetof(dim); DW_OP_plus ! dim[i]+offset; DW_OP_push_object_address ! dim[i]+offsetof(dim) objptr; DW_OP_swap ! objptr dim[i]+offsetof(dim); DW_OP_offset ! objptr.dim[i]; DW_OP_lit<n> ! objptr.dim[i] offsetof(lb); DW_OP_offset ! objptr.dim[i].lowerbound; DW_OP_deref) ! *objptr.dim[i].lowerbound; DW_AT_upper_bound(expression=; ! Looks up the upper bound of dimension i.; DW_OP_lit<n> ! sizeof(dim); DW_OP_mul; DW_OP_lit<n> ! offsetof(dim); DW_OP_plus; DW_OP_push_object_address; DW_OP_swap; DW_OP_offset; DW_OP_lit<n> ! offset of upperbound in dim; DW_OP_offset; DW_OP_deref); DW_AT_byte_stride(expression=; ! Looks up the byte stride of dimension i.; ...; ! (analogous to DW_AT_upper_bound); ); ----------------------------------------------------------------------------. .. note::. This example suggests that ``DW_AT_lower_bound`` and ``DW_AT_upper_bound``; evaluate an exprloc with an initial stack containing the rank value. The; attribute definition should be updated to state this. D.2.6 Ada Example; +++++++++++++++++. Figure D.20: Ada example: DWARF description. .. code::; :number-lines:. ----------------------------------------------------------------------------; 11$: DW_TAG_variable; DW_AT_name(""M""); DW_AT_type(reference to INTEGER); 12$: DW_TAG_array_type; ! No name, default (Ada) order, default stride; DW_AT_type(reference to INTEGER); 13$: DW_TAG_subrange_type; DW_AT_type(reference to INTEGER); DW_AT_lower_bound(constant 1); DW_AT_upper_bound(reference to variable M at 11$); 14$: DW_TAG_variable; DW_AT_name(""VEC1""); DW_AT_type(reference to array type at 12$); ...; 21$: DW_TAG_subrange_type; DW_AT_name(""TEENY""); DW_AT_type(reference to INTEGER); DW_AT_lower_bound(constant 1); DW_AT_upper_bound(constant 100); ...; 26$: DW_TAG_structure_type; DW_AT_name(""REC2""); 27$: DW_TAG_member; DW_AT_name(""N""); DW_AT_type(reference to subtype TEENY at 21$); DW_AT_data_member_location(constant 0); 28$: DW_TAG_array_type; ! No name, default (Ad",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:6225,Energy Efficiency,power,power,6225,"ies on the DWARF; expression stack. They can only be the final result of the evaluation of a DWARF; expression. However, by allowing a location description to be a first-class; entry on the DWARF expression stack it becomes possible to compose expressions; containing both values and location descriptions naturally. It allows objects to; be located in any kind of memory address space, in registers, be implicit; values, be undefined, or a composite of any of these. By extending DWARF carefully, all existing DWARF expressions can retain their; current semantic meaning. DWARF has implicit conversions that convert from a; value that represents an address in the default address space to a memory; location description. This can be extended to allow a default address space; memory location description to be implicitly converted back to its address; value. This allows all DWARF Version 5 expressions to retain their same meaning,; while enabling the ability to explicitly create memory location descriptions in; non-default address spaces and generalizing the power of composite location; descriptions to any kind of location description. For those familiar with the definition of location descriptions in DWARF Version; 5, the definitions in these extensions are presented differently, but does in; fact define the same concept with the same fundamental semantics. However, it; does so in a way that allows the concept to extend to support address spaces,; bit addressing, the ability for composite location descriptions to be composed; of any kind of location description, and the ability to support objects located; at multiple places. Collectively these changes expand the set of architectures; that can be supported and improves support for optimized code. Several approaches were considered, and the one presented, together with the; extensions it enables, appears to be the simplest and cleanest one that offers; the greatest improvement of DWARF's ability to support debugging optimized GP",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:17748,Energy Efficiency,allocate,allocated,17748,"Spaces; --------------------------------------. AMDGPU needs to be able to describe addresses that are in different kinds of; memory. Optimized code may need to describe a variable that resides in pieces; that are in different kinds of storage which may include parts of registers,; memory that is in a mixture of memory kinds, implicit values, or be undefined. DWARF has the concept of segment addresses. However, the segment cannot be; specified within a DWARF expression, which is only able to specify the offset; portion of a segment address. The segment index is only provided by the entity; that specifies the DWARF expression. Therefore, the segment index is a property; that can only be put on complete objects, such as a variable. That makes it only; suitable for describing an entity (such as variable or subprogram code) that is; in a single kind of memory. AMDGPU uses multiple address spaces. For example, a variable may be allocated in; a register that is partially spilled to the call stack which is in the private; address space, and partially spilled to the local address space. DWARF mentions; address spaces, for example as an argument to the ``DW_OP_xderef*`` operations.; A new section that defines address spaces is added (see; :ref:`amdgpu-dwarf-address-spaces`). A new attribute ``DW_AT_LLVM_address_space`` is added to pointer and reference; types (see :ref:`amdgpu-dwarf-type-modifier-entries`). This allows the compiler; to specify which address space is being used to represent the pointer or; reference type. DWARF uses the concept of an address in many expression operations but does not; define how it relates to address spaces. For example,; ``DW_OP_push_object_address`` pushes the address of an object. Other contexts; implicitly push an address on the stack before evaluating an expression. For; example, the ``DW_AT_use_location`` attribute of the; ``DW_TAG_ptr_to_member_type``. The expression belongs to a source language type; which may apply to objects allocat",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:18804,Energy Efficiency,allocate,allocated,18804,"ially spilled to the call stack which is in the private; address space, and partially spilled to the local address space. DWARF mentions; address spaces, for example as an argument to the ``DW_OP_xderef*`` operations.; A new section that defines address spaces is added (see; :ref:`amdgpu-dwarf-address-spaces`). A new attribute ``DW_AT_LLVM_address_space`` is added to pointer and reference; types (see :ref:`amdgpu-dwarf-type-modifier-entries`). This allows the compiler; to specify which address space is being used to represent the pointer or; reference type. DWARF uses the concept of an address in many expression operations but does not; define how it relates to address spaces. For example,; ``DW_OP_push_object_address`` pushes the address of an object. Other contexts; implicitly push an address on the stack before evaluating an expression. For; example, the ``DW_AT_use_location`` attribute of the; ``DW_TAG_ptr_to_member_type``. The expression belongs to a source language type; which may apply to objects allocated in different kinds of storage. Therefore,; it is desirable that the expression that uses the address can do so without; regard to what kind of storage it specifies, including the address space of a; memory location description. For example, a pointer to member value may want to; be applied to an object that may reside in any address space. The DWARF ``DW_OP_xderef*`` operations allow a value to be converted into an; address of a specified address space which is then read. But it provides no; way to create a memory location description for an address in the non-default; address space. For example, AMDGPU variables can be allocated in the local; address space at a fixed address. The ``DW_OP_LLVM_form_aspace_address`` (see; :ref:`amdgpu-dwarf-memory-location-description-operations`) operation is defined; to create a memory location description from an address and address space. If; can be used to specify the location of a variable that is allocated in a; speci",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:19442,Energy Efficiency,allocate,allocated,19442," to address spaces. For example,; ``DW_OP_push_object_address`` pushes the address of an object. Other contexts; implicitly push an address on the stack before evaluating an expression. For; example, the ``DW_AT_use_location`` attribute of the; ``DW_TAG_ptr_to_member_type``. The expression belongs to a source language type; which may apply to objects allocated in different kinds of storage. Therefore,; it is desirable that the expression that uses the address can do so without; regard to what kind of storage it specifies, including the address space of a; memory location description. For example, a pointer to member value may want to; be applied to an object that may reside in any address space. The DWARF ``DW_OP_xderef*`` operations allow a value to be converted into an; address of a specified address space which is then read. But it provides no; way to create a memory location description for an address in the non-default; address space. For example, AMDGPU variables can be allocated in the local; address space at a fixed address. The ``DW_OP_LLVM_form_aspace_address`` (see; :ref:`amdgpu-dwarf-memory-location-description-operations`) operation is defined; to create a memory location description from an address and address space. If; can be used to specify the location of a variable that is allocated in a; specific address space. This allows the size of addresses in an address space to; be larger than the generic type. It also allows a consumer great implementation; freedom. It allows the implicit conversion back to a value to be limited only to; the default address space to maintain compatibility with DWARF Version 5. For; other address spaces the producer can use the new operations that explicitly; specify the address space. In contrast, if the ``DW_OP_LLVM_form_aspace_address`` operation had been; defined to produce a value, and an implicit conversion to a memory location; description was defined, then it would be limited to the size of the generic; type (which m",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:19764,Energy Efficiency,allocate,allocated,19764," a source language type; which may apply to objects allocated in different kinds of storage. Therefore,; it is desirable that the expression that uses the address can do so without; regard to what kind of storage it specifies, including the address space of a; memory location description. For example, a pointer to member value may want to; be applied to an object that may reside in any address space. The DWARF ``DW_OP_xderef*`` operations allow a value to be converted into an; address of a specified address space which is then read. But it provides no; way to create a memory location description for an address in the non-default; address space. For example, AMDGPU variables can be allocated in the local; address space at a fixed address. The ``DW_OP_LLVM_form_aspace_address`` (see; :ref:`amdgpu-dwarf-memory-location-description-operations`) operation is defined; to create a memory location description from an address and address space. If; can be used to specify the location of a variable that is allocated in a; specific address space. This allows the size of addresses in an address space to; be larger than the generic type. It also allows a consumer great implementation; freedom. It allows the implicit conversion back to a value to be limited only to; the default address space to maintain compatibility with DWARF Version 5. For; other address spaces the producer can use the new operations that explicitly; specify the address space. In contrast, if the ``DW_OP_LLVM_form_aspace_address`` operation had been; defined to produce a value, and an implicit conversion to a memory location; description was defined, then it would be limited to the size of the generic; type (which matches the size of the default address space). An implementation; would likely have to use *reserved ranges* of value to represent different; address spaces. Such a value would likely not match any address value in the; actual hardware. That would require the consumer to have special treatment for; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:23852,Energy Efficiency,efficient,efficient,23852," so they can be used to read memory with only the memory location; description and no extra information. The same set of operations can operate on; locations independent of their kind of storage. The ``DW_OP_deref*`` therefore; can be used on any storage kind, including memory location descriptions of; different address spaces. Therefore, the ``DW_OP_xderef*`` operations are; unnecessary, except to become a more compact way to encode a non-default address; space address followed by dereferencing it. See; :ref:`amdgpu-dwarf-general-operations`. 2.9 Support for Vector Base Types; ---------------------------------. The vector registers of the AMDGPU are represented as their full wavefront; size, meaning the wavefront size times the dword size. This reflects the; actual hardware and allows the compiler to generate DWARF for languages that; map a thread to the complete wavefront. It also allows more efficient DWARF to; be generated to describe the CFI as only a single expression is required for; the whole vector register, rather than a separate expression for each lane's; dword of the vector register. It also allows the compiler to produce DWARF; that indexes the vector register if it spills scalar registers into portions; of a vector register. Since DWARF stack value entries have a base type and AMDGPU registers are a; vector of dwords, the ability to specify that a base type is a vector is; required. See ``DW_AT_LLVM_vector_size`` in :ref:`amdgpu-dwarf-base-type-entries`. .. _amdgpu-dwarf-operation-to-create-vector-composite-location-descriptions:. 2.10 DWARF Operations to Create Vector Composite Location Descriptions; ----------------------------------------------------------------------. AMDGPU optimized code may spill vector registers to non-global address space; memory, and this spilling may be done only for SIMT lanes that are active on; entry to the subprogram. To support this the CFI rule for the partially spilled; register needs to use an expression that uses t",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:26631,Energy Efficiency,efficient,efficiently,26631,"le location is used. It may be possible to use existing DWARF to incrementally build the composite; location description, possibly using the DWARF operations for control flow to; create a loop. However, for the AMDGPU that would require loop iteration of 64.; A concern is that the resulting DWARF would have a significant size and would be; reasonably common as it is needed for every vector register that is spilled in a; function. AMDGPU can have up to 512 vector registers. Another concern is the; time taken to evaluate such non-trivial expressions repeatedly. To avoid these issues, a composite location description that can be created as a; masked select is proposed. In addition, an operation that creates a composite; location description that is a vector on another location description is needed.; These operations generate the composite location description using a single; DWARF operation that combines all lanes of the vector in one step. The DWARF; expression is more compact, and can be evaluated by a consumer far more; efficiently. An example that uses these operations is referenced in the; :ref:`amdgpu-dwarf-further-examples` appendix. See ``DW_OP_LLVM_select_bit_piece`` and ``DW_OP_LLVM_extend`` in; :ref:`amdgpu-dwarf-composite-location-description-operations`. 2.11 DWARF Operation to Access Call Frame Entry Registers; ---------------------------------------------------------. As described in; :ref:`amdgpu-dwarf-operation-to-create-vector-composite-location-descriptions`,; a DWARF expression involving the set of SIMT lanes active on entry to a; subprogram is required. The SIMT active lane mask may be held in a register that; is modified as the subprogram executes. However, its value may be saved on entry; to the subprogram. The Call Frame Information (CFI) already encodes such register saving, so it is; more efficient to provide an operation to return the location of a saved; register than have to generate a loclist to describe the same information. This; is now ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:27438,Energy Efficiency,efficient,efficient,27438,"ing a single; DWARF operation that combines all lanes of the vector in one step. The DWARF; expression is more compact, and can be evaluated by a consumer far more; efficiently. An example that uses these operations is referenced in the; :ref:`amdgpu-dwarf-further-examples` appendix. See ``DW_OP_LLVM_select_bit_piece`` and ``DW_OP_LLVM_extend`` in; :ref:`amdgpu-dwarf-composite-location-description-operations`. 2.11 DWARF Operation to Access Call Frame Entry Registers; ---------------------------------------------------------. As described in; :ref:`amdgpu-dwarf-operation-to-create-vector-composite-location-descriptions`,; a DWARF expression involving the set of SIMT lanes active on entry to a; subprogram is required. The SIMT active lane mask may be held in a register that; is modified as the subprogram executes. However, its value may be saved on entry; to the subprogram. The Call Frame Information (CFI) already encodes such register saving, so it is; more efficient to provide an operation to return the location of a saved; register than have to generate a loclist to describe the same information. This; is now possible since; :ref:`amdgpu-dwarf-allow-location-description-on-the-dwarf-evaluation-stack`; allows location descriptions on the stack. See ``DW_OP_LLVM_call_frame_entry_reg`` in; :ref:`amdgpu-dwarf-general-location-description-operations` and; :ref:`amdgpu-dwarf-call-frame-information`. 2.12 Support for Source Languages Mapped to SIMT Hardware; ---------------------------------------------------------. If the source language is mapped onto the AMDGPU wavefronts in a SIMT manner,; then the variable DWARF location expressions must compute the location for a; single lane of the wavefront. Therefore, a DWARF operation is required to denote; the current lane, much like ``DW_OP_push_object_address`` denotes the current; object. See ``DW_OP_LLVM_push_lane`` in :ref:`amdgpu-dwarf-literal-operations`. In addition, a way is needed for the compiler to communicate how ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:32997,Energy Efficiency,schedul,schedules,32997,"size can be optional, but if the; MD5 checksum is present it must be valid for all files. This is a problem if; using link time optimization to combine compilation units where some have MD5; checksums and some do not. Therefore, sSupport to allow MD5 checksums to be; optionally present in the line table is added. See :ref:`amdgpu-dwarf-line-number-information`. 2.18 Add the HIP Programing Language; ------------------------------------. The HIP programming language [:ref:`HIP <amdgpu-dwarf-HIP>`], which is supported; by the AMDGPU, is added. See :ref:`amdgpu-dwarf-language-names-table`. 2.19 Support for Source Language Optimizations that Result in Concurrent Iteration Execution; --------------------------------------------------------------------------------------------. A compiler can perform loop optimizations that result in the generated code; executing multiple iterations concurrently. For example, software pipelining; schedules multiple iterations in an interleaved fashion to allow the; instructions of one iteration to hide the latencies of the instructions of; another iteration. Another example is vectorization that can exploit SIMD; hardware to allow a single instruction to execute multiple iterations using; vector registers. Note that although this is similar to SIMT execution, the way a client debugger; uses the information is fundamentally different. In SIMT execution the debugger; needs to present the concurrent execution as distinct source language threads; that the user can list and switch focus between. With iteration concurrency; optimizations, such as software pipelining and vectorized SIMD, the debugger; must not present the concurrency as distinct source language threads. Instead,; it must inform the user that multiple loop iterations are executing in parallel; and allow the user to select between them. In general, SIMT execution fixes the number of concurrent executions per target; architecture thread. However, both software pipelining and SIMD vect",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:68261,Energy Efficiency,allocate,allocated,68261,"m of prefix that; specifies the byte count. It can be used:. * as the value of a debugging information entry attribute that is encoded using; class ``exprloc`` (see :ref:`amdgpu-dwarf-classes-and-forms`),. * as the operand to certain operation expression operations,. * as the operand to certain call frame information operations (see; :ref:`amdgpu-dwarf-call-frame-information`),. * and in location list entries (see; :ref:`amdgpu-dwarf-location-list-expressions`). .. _amdgpu-dwarf-vendor-extensions-operations:. A.2.5.4.0 Vendor Extension Operations; #####################################. 1. ``DW_OP_LLVM_user``. ``DW_OP_LLVM_user`` encodes a vendor extension operation. It has at least one; operand: a ULEB128 constant identifying a vendor extension operation. The; remaining operands are defined by the vendor extension. The vendor extension; opcode 0 is reserved and cannot be used by any vendor extension. *The DW_OP_user encoding space can be understood to supplement the space; defined by DW_OP_lo_user and DW_OP_hi_user that is allocated by the standard; for the same purpose.*. .. _amdgpu-dwarf-stack-operations:. A.2.5.4.1 Stack Operations; ##########################. .. note::. This section replaces DWARF Version 5 section 2.5.1.3. The following operations manipulate the DWARF stack. Operations that index the; stack assume that the top of the stack (most recently added entry) has index 0.; They allow the stack entries to be either a value or location description. If any stack entry accessed by a stack operation is an incomplete composite; location description (see; :ref:`amdgpu-dwarf-composite-location-description-operations`), then the DWARF; expression is ill-formed. .. note::. These operations now support stack entries that are values and location; descriptions. .. note::. If it is desired to also make them work with incomplete composite location; descriptions, then would need to define that the composite location storage; specified by the incomplete composite locati",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:114632,Energy Efficiency,efficient,efficient,114632,"and difficult; to describe using ordinary DWARF location descriptions. Instead of forcing; complex thread-local storage calculations into the DWARF expressions, the*; ``DW_OP_form_tls_address`` *allows the consumer to perform the computation; based on the target architecture specific run-time environment.*. 5. ``DW_OP_call_frame_cfa``. ``DW_OP_call_frame_cfa`` pushes the location description L of the Canonical; Frame Address (CFA) of the current subprogram, obtained from the call frame; information on the stack. See :ref:`amdgpu-dwarf-call-frame-information`. *Although the value of the* ``DW_AT_frame_base`` *attribute of the debugger; information entry corresponding to the current subprogram can be computed; using a location list expression, in some cases this would require an; extensive location list because the values of the registers used in; computing the CFA change during a subprogram execution. If the call frame; information is present, then it already encodes such changes, and it is; space efficient to reference that using the* ``DW_OP_call_frame_cfa``; *operation.*. 6. ``DW_OP_fbreg``. ``DW_OP_fbreg`` has a single signed LEB128 integer operand that represents a; byte displacement B. The location description L for the *frame base* of the current subprogram is; obtained from the ``DW_AT_frame_base`` attribute of the debugger information; entry corresponding to the current subprogram as described in; :ref:`amdgpu-dwarf-low-level-information`. The location description L is updated as if the ``DW_OP_LLVM_offset_uconst; B`` operation was applied. The updated L is pushed on the stack. 7. ``DW_OP_breg0``, ``DW_OP_breg1``, ..., ``DW_OP_breg31``. The ``DW_OP_breg<N>`` operations encode the numbers of up to 32 registers,; numbered from 0 through 31, inclusive. The register number R corresponds to; the N in the operation name. They have a single signed LEB128 integer operand that represents a byte; displacement B. The address space identifier AS is defined as the one cor",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:149068,Energy Efficiency,allocate,allocated,149068,"ta; resides. *Target architecture specific DWARF address spaces may correspond to hardware; supported facilities such as memory utilizing base address registers, scratchpad; memory, and memory with special interleaving. The size of addresses in these; address spaces may vary. Their access and allocation may be hardware managed; with each thread or group of threads having access to independent storage. For; these reasons they may have properties that do not allow them to be viewed as; part of the unified global virtual address space accessible by all threads.*. *It is target architecture specific whether multiple DWARF address spaces are; supported and how source language memory spaces map to target architecture; specific DWARF address spaces. A target architecture may map multiple source; language memory spaces to the same target architecture specific DWARF address; class. Optimization may determine that variable lifetime and access pattern; allows them to be allocated in faster scratchpad memory represented by a; different DWARF address space than the default for the source language memory; space.*. Although DWARF address space identifiers are target architecture specific,; ``DW_ASPACE_LLVM_none`` is a common address space supported by all target; architectures, and defined as the target architecture default address space. DWARF address space identifiers are used by:. * The ``DW_AT_LLVM_address_space`` attribute. * The DWARF expression operations: ``DW_OP_aspace_bregx``,; ``DW_OP_form_aspace_address``, ``DW_OP_aspace_implicit_pointer``, and; ``DW_OP_xderef*``. * The CFI instructions: ``DW_CFA_def_aspace_cfa`` and; ``DW_CFA_def_aspace_cfa_sf``. .. note::. Currently, DWARF defines address class values as being target architecture; specific, and defines a DW_AT_address_class attribute. With the removal of; DW_AT_segment in DWARF 6, it is unclear how the address class is intended to; be used as the term is not used elsewhere. Should these be replaced by this; proposal'",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:150955,Energy Efficiency,allocate,allocated,150955,"ic, and defines a DW_AT_address_class attribute. With the removal of; DW_AT_segment in DWARF 6, it is unclear how the address class is intended to; be used as the term is not used elsewhere. Should these be replaced by this; proposal's more complete address space? Or are they intended to represent; source language memory spaces such as in OpenCL?. .. _amdgpu-dwarf-memory-spaces:. A.2.14 Memory Spaces; ~~~~~~~~~~~~~~~~~~~~. .. note::. This is a new section after DWARF Version 5 section 2.12 Segmented Addresses. DWARF memory spaces are used for source languages that have the concept of; memory spaces. They are used in the ``DW_AT_LLVM_memory_space`` attribute for; pointer type, reference type, variable, formal parameter, and constant debugger; information entries. Each DWARF memory space is conceptually a separate source language memory space; with its own lifetime and aliasing rules. DWARF memory spaces are used to; specify the source language memory spaces that pointer type and reference type; values refer, and to specify the source language memory space in which variables; are allocated. Although DWARF memory space identifiers are source language specific,; ``DW_MSPACE_LLVM_none`` is a common memory space supported by all source; languages, and defined as the source language default memory space. The set of currently defined DWARF memory spaces, together with source language; mappings, is given in :ref:`amdgpu-dwarf-source-language-memory-spaces-table`. Vendor defined source language memory spaces may be defined using codes in the; range ``DW_MSPACE_LLVM_lo_user`` to ``DW_MSPACE_LLVM_hi_user``. .. table:: Source language memory spaces; :name: amdgpu-dwarf-source-language-memory-spaces-table. =========================== ============ ============== ============== ==============; Memory Space Name Meaning C/C++ OpenCL CUDA/HIP; =========================== ============ ============== ============== ==============; ``DW_MSPACE_LLVM_none`` generic *default* generic *defa",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:158736,Energy Efficiency,allocate,allocated,158736,"on for register R, then L is replaced; with the result of evaluating a ``DW_OP_bregx R, 0`` operation. This; computes the frame base memory location description in the target; architecture default address space. *This allows the more compact* ``DW_OP_reg*`` *to be used instead of*; ``DW_OP_breg* 0``\ *.*. .. note::. This rule could be removed and require the producer to create the required; location description directly using ``DW_OP_call_frame_cfa``,; ``DW_OP_breg*``, or ``DW_OP_LLVM_aspace_bregx``. This would also then; allow a target to implement the call frames within a large register. Otherwise, the DWARF is ill-formed if SL is not a memory location; description in any of the target architecture specific address spaces. The resulting L is the *frame base* for the subprogram or entry point. *Typically, E will use the* ``DW_OP_call_frame_cfa`` *operation or be a; stack pointer register plus or minus some offset.*. *The frame base for a subprogram is typically an address relative to the; first unit of storage allocated for the subprogram's stack frame. The*; ``DW_AT_frame_base`` *attribute can be used in several ways:*. 1. *In subprograms that need location lists to locate local variables, the*; ``DW_AT_frame_base`` *can hold the needed location list, while all; variables' location descriptions can be simpler ones involving the frame; base.*. 2. *It can be used in resolving ""up-level"" addressing within; nested routines. (See also* ``DW_AT_static_link``\ *, below)*. *Some languages support nested subroutines. In such languages, it is; possible to reference the local variables of an outer subroutine from within; an inner subroutine. The* ``DW_AT_static_link`` *and* ``DW_AT_frame_base``; *attributes allow debuggers to support this same kind of referencing.*. 3. If a ``DW_TAG_subprogram`` or ``DW_TAG_entry_point`` debugger information; entry is lexically nested, it may have a ``DW_AT_static_link`` attribute,; whose value is a DWARF expression E. The result of the attr",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:198577,Energy Efficiency,allocate,allocated,198577,"ersion`` (ubyte). A version number (see Section 7.24 Call Frame Information). This number is; specific to the call frame information and is independent of the DWARF; version number. The value of the CIE version number is 4. .. note::. Would this be increased to 5 to reflect the changes in these extensions?. 4. ``augmentation`` (sequence of UTF-8 characters). A null-terminated UTF-8 string that identifies the augmentation to this CIE; or to the FDEs that use it. If a reader encounters an augmentation string; that is unexpected, then only the following fields can be read:. * CIE: length, CIE_id, version, augmentation; * FDE: length, CIE_pointer, initial_location, address_range. If there is no augmentation, this value is a zero byte. *The augmentation string allows users to indicate that there is additional; vendor and target architecture specific information in the CIE or FDE which; is needed to virtually unwind a stack frame. For example, this might be; information about dynamically allocated data which needs to be freed on exit; from the routine.*. *Because the* ``.debug_frame`` *section is useful independently of any*; ``.debug_info`` *section, the augmentation string always uses UTF-8; encoding.*. The recommended format for the augmentation string is:. | ``[``\ *vendor*\ ``:v``\ *X*\ ``.``\ *Y*\ [\ ``:``\ *options*\ ]\ ``]``\ *. Where *vendor* is the producer, ``vX.Y`` specifies the major X and minor Y; version number of the extensions used, and *options* is an optional string; providing additional information about the extensions. The version number; must conform to semantic versioning [:ref:`SEMVER <amdgpu-dwarf-SEMVER>`].; The *options* string must not contain the ""\ ``]``\ "" character. For example:. ::. [abc:v0.0][def:v1.2:feature-a=on,feature-b=3]. 5. ``address_size`` (ubyte). The size of a target address in this CIE and any FDEs that use it, in bytes.; If a compilation unit exists for this frame, its address size must match the; address size here. 6. ``segme",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:12251,Integrability,wrap,wrap-around,12251,"ding location; descriptions that describe when bytes are in registers, are implicit, or a; composite of these, the ``DW_OP_LLVM_offset``, ``DW_OP_LLVM_offset_uconst``, and; ``DW_OP_LLVM_bit_offset`` offset operations are added. The offset operations can operate on location storage of any size. For example,; implicit location storage could be any number of bits in size. It is simpler to; define offsets that exceed the size of the location storage as being an; evaluation error, than having to force an implementation to support potentially; infinite precision offsets to allow it to correctly track a series of positive; and negative offsets that may transiently overflow or underflow, but end up in; range. This is simple for the arithmetic operations as they are defined in terms; of two's complement arithmetic on a base type of a fixed size. Therefore, the; offset operation define that integer overflow is ill-formed. This is in contrast; to the ``DW_OP_plus``, ``DW_OP_plus_uconst``, and ``DW_OP_minus`` arithmetic; operations which define that it causes wrap-around. Having the offset operations allows ``DW_OP_push_object_address`` to push a; location description that may be in a register, or be an implicit value. The; DWARF expression of ``DW_TAG_ptr_to_member_type`` can use the offset operations; without regard to what kind of location description was pushed. Since; :ref:`amdgpu-dwarf-allow-location-description-on-the-dwarf-evaluation-stack` has; generalized location storage to be bit indexable, ``DW_OP_LLVM_bit_offset``; generalizes DWARF to work with bit fields. This is generally not possible in; DWARF Version 5. The ``DW_OP_*piece`` operations only allow literal indices. A way to use a; computed offset of an arbitrary location description (such as a vector register); is required. The offset operations provide this ability since they can be used; to compute a location description on the stack. It could be possible to define ``DW_OP_plus``, ``DW_OP_plus_uconst``, and; ``",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:13978,Integrability,wrap,wrap,13978,"itrary location description (such as a vector register); is required. The offset operations provide this ability since they can be used; to compute a location description on the stack. It could be possible to define ``DW_OP_plus``, ``DW_OP_plus_uconst``, and; ``DW_OP_minus`` to operate on location descriptions to avoid needing; ``DW_OP_LLVM_offset`` and ``DW_OP_LLVM_offset_uconst``. However, this is not; proposed since currently the arithmetic operations are defined to require values; of the same base type and produces a result with the same base type. Allowing; these operations to act on location descriptions would permit the first operand; to be a location description and the second operand to be an integral value; type, or vice versa, and return a location description. This complicates the; rules for implicit conversions between default address space memory location; descriptions and generic base type values. Currently the rules would convert; such a location description to the memory address value and then perform two's; compliment wrap around arithmetic. If the result was used as a location; description, it would be implicitly converted back to a default address space; memory location description. This is different to the overflow rules on location; descriptions. To allow control, an operation that converts a memory location; description to an address integral type value would be required. Keeping a; separation of location description operations and arithmetic operations avoids; this semantic complexity. See ``DW_OP_LLVM_offset``, ``DW_OP_LLVM_offset_uconst``, and; ``DW_OP_LLVM_bit_offset`` in; :ref:`amdgpu-dwarf-general-location-description-operations`. 2.5 Generalize Creation of Undefined Location Descriptions; ----------------------------------------------------------. Current DWARF uses an empty expression to indicate an undefined location; description. Since; :ref:`amdgpu-dwarf-allow-location-description-on-the-dwarf-evaluation-stack`; allows location desc",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:91910,Integrability,depend,dependent,91910,"S bits is retrieved from the location storage LS specified by; one of the single location descriptions SL of L. *If L, or the location description of any composite location description; part that is a subcomponent of L, has more than one single location; description, then any one of them can be selected as they are required to; all have the same value. For any single location description SL, bits are; retrieved from the associated storage location starting at the bit offset; specified by SL. For a composite location description, the retrieved bits; are the concatenation of the N bits from each composite location part PL,; where N is limited to the size of PL.*. V is pushed on the stack with the type T. .. note::. This definition makes it an evaluation error if L is a register location; description that has less than TS bits remaining in the register storage.; Particularly since these extensions extend location descriptions to have; a bit offset, it would be odd to define this as performing sign extension; based on the type, or be target architecture dependent, as the number of; remaining bits could be any number. This matches the GDB implementation; for ``DW_OP_deref_type``. These extensions define ``DW_OP_*breg*`` in terms of; ``DW_OP_regval_type``. ``DW_OP_regval_type`` is defined in terms of; ``DW_OP_regx``, which uses a 0 bit offset, and ``DW_OP_deref_type``.; Therefore, it requires the register size to be greater or equal to the; address size of the address space. This matches the GDB implementation for; ``DW_OP_*breg*``. The DWARF is ill-formed if D is not in the current compilation unit, D is; not a ``DW_TAG_base_type`` debugging information entry, or if TS divided by; 8 (the byte size) and rounded up to a whole number is not equal to S. .. note::. This definition allows the base type to be a bit size since there seems no; reason to restrict it. It is an evaluation error if any bit of the value is retrieved from the; undefined location storage or the offset o",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:145841,Integrability,depend,depends,145841,"ction, no base address entry is needed. *End-of-list*. This kind of location list entry marks the end of the location list; expression. The address ranges defined by the bounded location description entries of a; location list expression may overlap. When they do, they describe a situation in; which an object exists simultaneously in more than one place. If all of the address ranges in a given location list expression do not; collectively cover the entire range over which the object in question is; defined, and there is no following default location description entry, it is; assumed that the object is not available for the portion of the range that is; not covered. The result of the evaluation of a DWARF location list expression is:. * If the current program location is not specified, then it is an evaluation; error. .. note::. If the location list only has a single default entry, should that be; considered a match if there is no program location? If there are non-default; entries then it seems it has to be an evaluation error when there is no; program location as that indicates the location depends on the program; location which is not known. * If there are no matching location list entries, then the result is a location; description that comprises one undefined location description. * Otherwise, the operation expression E of each matching location list entry is; evaluated with the current context, except that the result kind is a location; description, the object is unspecified, and the initial stack is empty. The; location list entry result is the location description returned by the; evaluation of E. The result is a location description that is comprised of the union of the; single location descriptions of the location description result of each; matching location list entry. A location list expression can only be used as the value of a debugger; information entry attribute that is encoded using class ``loclist`` or; ``loclistsptr`` (see :ref:`amdgpu-dwarf-class",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:159145,Integrability,rout,routines,159145,"ription directly using ``DW_OP_call_frame_cfa``,; ``DW_OP_breg*``, or ``DW_OP_LLVM_aspace_bregx``. This would also then; allow a target to implement the call frames within a large register. Otherwise, the DWARF is ill-formed if SL is not a memory location; description in any of the target architecture specific address spaces. The resulting L is the *frame base* for the subprogram or entry point. *Typically, E will use the* ``DW_OP_call_frame_cfa`` *operation or be a; stack pointer register plus or minus some offset.*. *The frame base for a subprogram is typically an address relative to the; first unit of storage allocated for the subprogram's stack frame. The*; ``DW_AT_frame_base`` *attribute can be used in several ways:*. 1. *In subprograms that need location lists to locate local variables, the*; ``DW_AT_frame_base`` *can hold the needed location list, while all; variables' location descriptions can be simpler ones involving the frame; base.*. 2. *It can be used in resolving ""up-level"" addressing within; nested routines. (See also* ``DW_AT_static_link``\ *, below)*. *Some languages support nested subroutines. In such languages, it is; possible to reference the local variables of an outer subroutine from within; an inner subroutine. The* ``DW_AT_static_link`` *and* ``DW_AT_frame_base``; *attributes allow debuggers to support this same kind of referencing.*. 3. If a ``DW_TAG_subprogram`` or ``DW_TAG_entry_point`` debugger information; entry is lexically nested, it may have a ``DW_AT_static_link`` attribute,; whose value is a DWARF expression E. The result of the attribute is obtained by evaluating E with a context that; has a result kind of a location description, an unspecified object, the; compilation unit that contains E, an empty initial stack, and other context; elements corresponding to the source language thread of execution upon which; the user is focused, if any. The result of the evaluation is the location; description L of the *canonical frame address* (s",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:194167,Integrability,depend,dependency,194167," CFA location; description.*. .. note::. Should DWARF allow the address size to be a different size to the size of; the register? Requiring them to be the same bit size avoids any issue of; conversion as the bit contents of the register is simply interpreted as a; value of the address. GDB has a per register hook that allows a target specific conversion on a; register by register basis. It defaults to truncation of bigger registers,; and to actually reading bytes from the next register (or reads out of bounds; for the last register) for smaller registers. There are no GDB tests that; read a register out of bounds (except an illegal hand written assembly; test). *register(R)*; This register has been stored in another register numbered R. The previous value of this register is the location description obtained using; the call frame information for the current frame and current program location; for register R. The DWARF is ill-formed if the size of this register does not match the size; of register R or if there is a cyclic dependency in the call frame; information. .. note::. Should this also allow R to be larger than this register? If so is the value; stored in the low order bits and it is undefined what is stored in the; extra upper bits?. *expression(E)*; The previous value of this register is located at the location description; produced by evaluating the DWARF operation expression E (see; :ref:`amdgpu-dwarf-operation-expressions`). E is evaluated with the current context, except the result kind is a location; description, the compilation unit is unspecified, the object is unspecified,; and an initial stack comprising the location description of the current CFA; (see :ref:`amdgpu-dwarf-operation-expressions`). *val_expression(E)*; The previous value of this register is located at the implicit location; description created from the value produced by evaluating the DWARF operation; expression E (see :ref:`amdgpu-dwarf-operation-expressions`). E is evaluated with the",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:198634,Integrability,rout,routine,198634,"ersion`` (ubyte). A version number (see Section 7.24 Call Frame Information). This number is; specific to the call frame information and is independent of the DWARF; version number. The value of the CIE version number is 4. .. note::. Would this be increased to 5 to reflect the changes in these extensions?. 4. ``augmentation`` (sequence of UTF-8 characters). A null-terminated UTF-8 string that identifies the augmentation to this CIE; or to the FDEs that use it. If a reader encounters an augmentation string; that is unexpected, then only the following fields can be read:. * CIE: length, CIE_id, version, augmentation; * FDE: length, CIE_pointer, initial_location, address_range. If there is no augmentation, this value is a zero byte. *The augmentation string allows users to indicate that there is additional; vendor and target architecture specific information in the CIE or FDE which; is needed to virtually unwind a stack frame. For example, this might be; information about dynamically allocated data which needs to be freed on exit; from the routine.*. *Because the* ``.debug_frame`` *section is useful independently of any*; ``.debug_info`` *section, the augmentation string always uses UTF-8; encoding.*. The recommended format for the augmentation string is:. | ``[``\ *vendor*\ ``:v``\ *X*\ ``.``\ *Y*\ [\ ``:``\ *options*\ ]\ ``]``\ *. Where *vendor* is the producer, ``vX.Y`` specifies the major X and minor Y; version number of the extensions used, and *options* is an optional string; providing additional information about the extensions. The version number; must conform to semantic versioning [:ref:`SEMVER <amdgpu-dwarf-SEMVER>`].; The *options* string must not contain the ""\ ``]``\ "" character. For example:. ::. [abc:v0.0][def:v1.2:feature-a=on,feature-b=3]. 5. ``address_size`` (ubyte). The size of a target address in this CIE and any FDEs that use it, in bytes.; If a compilation unit exists for this frame, its address size must match the; address size here. 6. ``segme",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:203338,Integrability,depend,depend,203338," sequence of table defining instructions that are described in; :ref:`amdgpu-dwarf-call-frame-instructions`. 6. ``padding`` (array of ubyte). Enough ``DW_CFA_nop`` instructions to make the size of this entry match the; length value above. .. _amdgpu-dwarf-call-frame-instructions:. A.6.4.2 Call Frame Instructions; +++++++++++++++++++++++++++++++. Each call frame instruction is defined to take 0 or more operands. Some of the; operands may be encoded as part of the opcode (see; :ref:`amdgpu-dwarf-call-frame-information-encoding`). The instructions are; defined in the following sections. Some call frame instructions have operands that are encoded as DWARF operation; expressions E (see :ref:`amdgpu-dwarf-operation-expressions`). The DWARF; operations that can be used in E have the following restrictions:. * ``DW_OP_addrx``, ``DW_OP_call2``, ``DW_OP_call4``, ``DW_OP_call_ref``,; ``DW_OP_const_type``, ``DW_OP_constx``, ``DW_OP_convert``,; ``DW_OP_deref_type``, ``DW_OP_fbreg``, ``DW_OP_implicit_pointer``,; ``DW_OP_regval_type``, ``DW_OP_reinterpret``, and ``DW_OP_xderef_type``; operations are not allowed because the call frame information must not depend; on other debug sections. * ``DW_OP_push_object_address`` is not allowed because there is no object; context to provide a value to push. * ``DW_OP_LLVM_push_lane`` and ``DW_OP_LLVM_push_iteration`` are not allowed; because the call frame instructions describe the actions for the whole target; architecture thread, not the lanes or iterations independently. * ``DW_OP_call_frame_cfa`` and ``DW_OP_entry_value`` are not allowed because; their use would be circular. * ``DW_OP_LLVM_call_frame_entry_reg`` is not allowed if evaluating E causes a; circular dependency between ``DW_OP_LLVM_call_frame_entry_reg`` operations. *For example, if a register R1 has a* ``DW_CFA_def_cfa_expression``; *instruction that evaluates a* ``DW_OP_LLVM_call_frame_entry_reg`` *operation; that specifies register R2, and register R2 has a*; ``DW_CFA_def_cfa",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:203898,Integrability,depend,dependency,203898,"rf-operation-expressions`). The DWARF; operations that can be used in E have the following restrictions:. * ``DW_OP_addrx``, ``DW_OP_call2``, ``DW_OP_call4``, ``DW_OP_call_ref``,; ``DW_OP_const_type``, ``DW_OP_constx``, ``DW_OP_convert``,; ``DW_OP_deref_type``, ``DW_OP_fbreg``, ``DW_OP_implicit_pointer``,; ``DW_OP_regval_type``, ``DW_OP_reinterpret``, and ``DW_OP_xderef_type``; operations are not allowed because the call frame information must not depend; on other debug sections. * ``DW_OP_push_object_address`` is not allowed because there is no object; context to provide a value to push. * ``DW_OP_LLVM_push_lane`` and ``DW_OP_LLVM_push_iteration`` are not allowed; because the call frame instructions describe the actions for the whole target; architecture thread, not the lanes or iterations independently. * ``DW_OP_call_frame_cfa`` and ``DW_OP_entry_value`` are not allowed because; their use would be circular. * ``DW_OP_LLVM_call_frame_entry_reg`` is not allowed if evaluating E causes a; circular dependency between ``DW_OP_LLVM_call_frame_entry_reg`` operations. *For example, if a register R1 has a* ``DW_CFA_def_cfa_expression``; *instruction that evaluates a* ``DW_OP_LLVM_call_frame_entry_reg`` *operation; that specifies register R2, and register R2 has a*; ``DW_CFA_def_cfa_expression`` *instruction that that evaluates a*; ``DW_OP_LLVM_call_frame_entry_reg`` *operation that specifies register R1.*. *Call frame instructions to which these restrictions apply include*; ``DW_CFA_def_cfa_expression``\ *,* ``DW_CFA_expression``\ *, and*; ``DW_CFA_val_expression``\ *.*. .. _amdgpu-dwarf-row-creation-instructions:. A.6.4.2.1 Row Creation Instructions; ###################################. .. note::. These instructions are the same as in DWARF Version 5 section 6.4.2.1. .. _amdgpu-dwarf-cfa-definition-instructions:. A.6.4.2.2 CFA Definition Instructions; #####################################. 1. ``DW_CFA_def_cfa``. The ``DW_CFA_def_cfa`` instruction takes two unsigned LEB128 ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:738,Modifiability,portab,portable,738,".. _amdgpu-dwarf-extensions-for-heterogeneous-debugging:. ********************************************; DWARF Extensions For Heterogeneous Debugging; ********************************************. .. contents::; :local:. .. warning::. This document describes **provisional extensions** to DWARF Version 5; [:ref:`DWARF <amdgpu-dwarf-DWARF>`] to support heterogeneous debugging. It is; not currently fully implemented and is subject to change. .. _amdgpu-dwarf-introduction:. 1. Introduction; ===============. AMD [:ref:`AMD <amdgpu-dwarf-AMD>`] has been working on supporting heterogeneous; computing. A heterogeneous computing program can be written in a high level; language such as C++ or Fortran with OpenMP pragmas, OpenCL, or HIP (a portable; C++ programming environment for heterogeneous computing [:ref:`HIP; <amdgpu-dwarf-HIP>`]). A heterogeneous compiler and runtime allows a program to; execute on multiple devices within the same native process. Devices could; include CPUs, GPUs, DSPs, FPGAs, or other special purpose accelerators.; Currently HIP programs execute on systems with CPUs and GPUs. The AMD [:ref:`AMD <amdgpu-dwarf-AMD>`] ROCm platform [:ref:`AMD-ROCm; <amdgpu-dwarf-AMD-ROCm>`] is an implementation of the industry standard for; heterogeneous computing devices defined by the Heterogeneous System Architecture; (HSA) Foundation [:ref:`HSA <amdgpu-dwarf-HSA>`]. It is open sourced and; includes contributions to open source projects such as LLVM [:ref:`LLVM; <amdgpu-dwarf-LLVM>`] for compilation and GDB for debugging [:ref:`GDB; <amdgpu-dwarf-GDB>`]. The LLVM compiler has upstream support for commercially available AMD GPU; hardware (AMDGPU) [:ref:`AMDGPU-LLVM <amdgpu-dwarf-AMDGPU-LLVM>`]. The open; source ROCgdb [:ref:`AMD-ROCgdb <amdgpu-dwarf-AMD-ROCgdb>`] GDB based debugger; also has support for AMDGPU which is being upstreamed. Support for AMDGPU is; also being added by third parties to the GCC [:ref:`GCC <amdgpu-dwarf-GCC>`]; compiler and the Perforce TotalView",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:3216,Modifiability,evolve,evolve,3216,"mdgpu-dwarf-extensions` section gives an overview of; the extensions devised to address the missing features. The extensions seek to; be general in nature and backwards compatible with DWARF Version 5. Their goal; is to be applicable to meeting the needs of any heterogeneous system and not be; vendor or architecture specific. That is followed by appendix; :ref:`amdgpu-dwarf-changes-relative-to-dwarf-version-5` which contains the; textual changes for the extensions relative to the DWARF Version 5 standard.; There are a number of notes included that raise open questions, or provide; alternative approaches that may be worth considering. Then appendix; :ref:`amdgpu-dwarf-further-examples` links to the AMD GPU specific usage of the; extensions that includes an example. Finally, appendix; :ref:`amdgpu-dwarf-references` provides references to further information. .. _amdgpu-dwarf-extensions:. 2. Extensions; =============. The extensions continue to evolve through collaboration with many individuals and; active prototyping within the GDB debugger and LLVM compiler. Input has also; been very much appreciated from the developers working on the Perforce TotalView; HPC Debugger and GCC compiler. The inputs provided and insights gained so far have been incorporated into this; current version. The plan is to participate in upstreaming the work and; addressing any feedback. If there is general interest then some or all of these; extensions could be submitted as future DWARF standard proposals. The general principles in designing the extensions have been:. 1. Be backwards compatible with the DWARF Version 5 [:ref:`DWARF; <amdgpu-dwarf-DWARF>`] standard. 2. Be vendor and architecture neutral. They are intended to apply to other; heterogeneous hardware devices including GPUs, DSPs, FPGAs, and other; specialized hardware. These collectively include similar characteristics and; requirements as AMDGPU devices. 3. Provide improved optimization support for non-GPU code. For example, some; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:5632,Modifiability,extend,extending,5632,"at some of the generalizations may also benefit other DWARF; issues that have been raised. The remainder of this section enumerates the extensions and provides motivation; for each in terms of heterogeneous debugging. .. _amdgpu-dwarf-allow-location-description-on-the-dwarf-evaluation-stack:. 2.1 Allow Location Description on the DWARF Expression Stack; ------------------------------------------------------------. DWARF Version 5 does not allow location descriptions to be entries on the DWARF; expression stack. They can only be the final result of the evaluation of a DWARF; expression. However, by allowing a location description to be a first-class; entry on the DWARF expression stack it becomes possible to compose expressions; containing both values and location descriptions naturally. It allows objects to; be located in any kind of memory address space, in registers, be implicit; values, be undefined, or a composite of any of these. By extending DWARF carefully, all existing DWARF expressions can retain their; current semantic meaning. DWARF has implicit conversions that convert from a; value that represents an address in the default address space to a memory; location description. This can be extended to allow a default address space; memory location description to be implicitly converted back to its address; value. This allows all DWARF Version 5 expressions to retain their same meaning,; while enabling the ability to explicitly create memory location descriptions in; non-default address spaces and generalizing the power of composite location; descriptions to any kind of location description. For those familiar with the definition of location descriptions in DWARF Version; 5, the definitions in these extensions are presented differently, but does in; fact define the same concept with the same fundamental semantics. However, it; does so in a way that allows the concept to extend to support address spaces,; bit addressing, the ability for composite location descrip",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:5895,Modifiability,extend,extended,5895,"arf-evaluation-stack:. 2.1 Allow Location Description on the DWARF Expression Stack; ------------------------------------------------------------. DWARF Version 5 does not allow location descriptions to be entries on the DWARF; expression stack. They can only be the final result of the evaluation of a DWARF; expression. However, by allowing a location description to be a first-class; entry on the DWARF expression stack it becomes possible to compose expressions; containing both values and location descriptions naturally. It allows objects to; be located in any kind of memory address space, in registers, be implicit; values, be undefined, or a composite of any of these. By extending DWARF carefully, all existing DWARF expressions can retain their; current semantic meaning. DWARF has implicit conversions that convert from a; value that represents an address in the default address space to a memory; location description. This can be extended to allow a default address space; memory location description to be implicitly converted back to its address; value. This allows all DWARF Version 5 expressions to retain their same meaning,; while enabling the ability to explicitly create memory location descriptions in; non-default address spaces and generalizing the power of composite location; descriptions to any kind of location description. For those familiar with the definition of location descriptions in DWARF Version; 5, the definitions in these extensions are presented differently, but does in; fact define the same concept with the same fundamental semantics. However, it; does so in a way that allows the concept to extend to support address spaces,; bit addressing, the ability for composite location descriptions to be composed; of any kind of location description, and the ability to support objects located; at multiple places. Collectively these changes expand the set of architectures; that can be supported and improves support for optimized code. Several approaches were ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:6588,Modifiability,extend,extend,6588,"sting DWARF expressions can retain their; current semantic meaning. DWARF has implicit conversions that convert from a; value that represents an address in the default address space to a memory; location description. This can be extended to allow a default address space; memory location description to be implicitly converted back to its address; value. This allows all DWARF Version 5 expressions to retain their same meaning,; while enabling the ability to explicitly create memory location descriptions in; non-default address spaces and generalizing the power of composite location; descriptions to any kind of location description. For those familiar with the definition of location descriptions in DWARF Version; 5, the definitions in these extensions are presented differently, but does in; fact define the same concept with the same fundamental semantics. However, it; does so in a way that allows the concept to extend to support address spaces,; bit addressing, the ability for composite location descriptions to be composed; of any kind of location description, and the ability to support objects located; at multiple places. Collectively these changes expand the set of architectures; that can be supported and improves support for optimized code. Several approaches were considered, and the one presented, together with the; extensions it enables, appears to be the simplest and cleanest one that offers; the greatest improvement of DWARF's ability to support debugging optimized GPU; and non-GPU code. Examining the GDB debugger and LLVM compiler, it appears only; to require modest changes as they both already have to support general use of; location descriptions. It is anticipated that will also be the case for other; debuggers and compilers. GDB has been modified to evaluate DWARF Version 5 expressions with location; descriptions as stack entries and with implicit conversions. All GDB tests have; passed, except one that turned out to be an invalid test case by DWARF Version 5",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:8538,Modifiability,extend,extending,8538,". All GDB tests have; passed, except one that turned out to be an invalid test case by DWARF Version 5; rules. The code in GDB actually became simpler as all evaluation is done on a; single stack and there was no longer a need to maintain a separate structure for; the location description results. This gives confidence in backwards; compatibility. See :ref:`amdgpu-dwarf-expressions` and nested sections. This extension is separately described at *Allow Location Descriptions on the; DWARF Expression Stack* [:ref:`AMDGPU-DWARF-LOC; <amdgpu-dwarf-AMDGPU-DWARF-LOC>`]. 2.2 Generalize CFI to Allow Any Location Description Kind; ---------------------------------------------------------. CFI describes restoring callee saved registers that are spilled. Currently CFI; only allows a location description that is a register, memory address, or; implicit location description. AMDGPU optimized code may spill scalar registers; into portions of vector registers. This requires extending CFI to allow any; location description kind to be supported. See :ref:`amdgpu-dwarf-call-frame-information`. 2.3 Generalize DWARF Operation Expressions to Support Multiple Places; ---------------------------------------------------------------------. In DWARF Version 5 a location description is defined as a single location; description or a location list. A location list is defined as either; effectively an undefined location description or as one or more single; location descriptions to describe an object with multiple places. With; :ref:`amdgpu-dwarf-allow-location-description-on-the-dwarf-evaluation-stack`,; the ``DW_OP_push_object_address`` and ``DW_OP_call*`` operations can put a; location description on the stack. Furthermore, debugger information entry; attributes such as ``DW_AT_data_member_location``, ``DW_AT_use_location``, and; ``DW_AT_vtable_elem_location`` are defined as pushing a location description on; the expression stack before evaluating the expression. DWARF Version 5 only allows the",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:16277,Modifiability,variab,variables,16277,"t possible to specify that a particular one of the input; location descriptions is undefined. See the ``DW_OP_LLVM_undefined`` operation in; :ref:`amdgpu-dwarf-undefined-location-description-operations`. 2.6 Generalize Creation of Composite Location Descriptions; ----------------------------------------------------------. To allow composition of composite location descriptions, an explicit operation; that indicates the end of the definition of a composite location description is; required. This can be implied if the end of a DWARF expression is reached,; allowing current DWARF expressions to remain legal. See ``DW_OP_LLVM_piece_end`` in; :ref:`amdgpu-dwarf-composite-location-description-operations`. 2.7 Generalize DWARF Base Objects to Allow Any Location Description Kind; ------------------------------------------------------------------------. The number of registers and the cost of memory operations is much higher for; AMDGPU than a typical CPU. The compiler attempts to optimize whole variables and; arrays into registers. Currently DWARF only allows ``DW_OP_push_object_address`` and related operations; to work with a global memory location. To support AMDGPU optimized code it is; required to generalize DWARF to allow any location description to be used. This; allows registers, or composite location descriptions that may be a mixture of; memory, registers, or even implicit values. See ``DW_OP_push_object_address`` in; :ref:`amdgpu-dwarf-general-location-description-operations`. 2.8 General Support for Address Spaces; --------------------------------------. AMDGPU needs to be able to describe addresses that are in different kinds of; memory. Optimized code may need to describe a variable that resides in pieces; that are in different kinds of storage which may include parts of registers,; memory that is in a mixture of memory kinds, implicit values, or be undefined. DWARF has the concept of segment addresses. However, the segment cannot be; specified within a DWARF e",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:16983,Modifiability,variab,variable,16983,"------------------------------------------------------------------------. The number of registers and the cost of memory operations is much higher for; AMDGPU than a typical CPU. The compiler attempts to optimize whole variables and; arrays into registers. Currently DWARF only allows ``DW_OP_push_object_address`` and related operations; to work with a global memory location. To support AMDGPU optimized code it is; required to generalize DWARF to allow any location description to be used. This; allows registers, or composite location descriptions that may be a mixture of; memory, registers, or even implicit values. See ``DW_OP_push_object_address`` in; :ref:`amdgpu-dwarf-general-location-description-operations`. 2.8 General Support for Address Spaces; --------------------------------------. AMDGPU needs to be able to describe addresses that are in different kinds of; memory. Optimized code may need to describe a variable that resides in pieces; that are in different kinds of storage which may include parts of registers,; memory that is in a mixture of memory kinds, implicit values, or be undefined. DWARF has the concept of segment addresses. However, the segment cannot be; specified within a DWARF expression, which is only able to specify the offset; portion of a segment address. The segment index is only provided by the entity; that specifies the DWARF expression. Therefore, the segment index is a property; that can only be put on complete objects, such as a variable. That makes it only; suitable for describing an entity (such as variable or subprogram code) that is; in a single kind of memory. AMDGPU uses multiple address spaces. For example, a variable may be allocated in; a register that is partially spilled to the call stack which is in the private; address space, and partially spilled to the local address space. DWARF mentions; address spaces, for example as an argument to the ``DW_OP_xderef*`` operations.; A new section that defines address spaces is added (se",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:17541,Modifiability,variab,variable,17541,"e DWARF to allow any location description to be used. This; allows registers, or composite location descriptions that may be a mixture of; memory, registers, or even implicit values. See ``DW_OP_push_object_address`` in; :ref:`amdgpu-dwarf-general-location-description-operations`. 2.8 General Support for Address Spaces; --------------------------------------. AMDGPU needs to be able to describe addresses that are in different kinds of; memory. Optimized code may need to describe a variable that resides in pieces; that are in different kinds of storage which may include parts of registers,; memory that is in a mixture of memory kinds, implicit values, or be undefined. DWARF has the concept of segment addresses. However, the segment cannot be; specified within a DWARF expression, which is only able to specify the offset; portion of a segment address. The segment index is only provided by the entity; that specifies the DWARF expression. Therefore, the segment index is a property; that can only be put on complete objects, such as a variable. That makes it only; suitable for describing an entity (such as variable or subprogram code) that is; in a single kind of memory. AMDGPU uses multiple address spaces. For example, a variable may be allocated in; a register that is partially spilled to the call stack which is in the private; address space, and partially spilled to the local address space. DWARF mentions; address spaces, for example as an argument to the ``DW_OP_xderef*`` operations.; A new section that defines address spaces is added (see; :ref:`amdgpu-dwarf-address-spaces`). A new attribute ``DW_AT_LLVM_address_space`` is added to pointer and reference; types (see :ref:`amdgpu-dwarf-type-modifier-entries`). This allows the compiler; to specify which address space is being used to represent the pointer or; reference type. DWARF uses the concept of an address in many expression operations but does not; define how it relates to address spaces. For example,; ``DW_OP_push",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:17614,Modifiability,variab,variable,17614," may be a mixture of; memory, registers, or even implicit values. See ``DW_OP_push_object_address`` in; :ref:`amdgpu-dwarf-general-location-description-operations`. 2.8 General Support for Address Spaces; --------------------------------------. AMDGPU needs to be able to describe addresses that are in different kinds of; memory. Optimized code may need to describe a variable that resides in pieces; that are in different kinds of storage which may include parts of registers,; memory that is in a mixture of memory kinds, implicit values, or be undefined. DWARF has the concept of segment addresses. However, the segment cannot be; specified within a DWARF expression, which is only able to specify the offset; portion of a segment address. The segment index is only provided by the entity; that specifies the DWARF expression. Therefore, the segment index is a property; that can only be put on complete objects, such as a variable. That makes it only; suitable for describing an entity (such as variable or subprogram code) that is; in a single kind of memory. AMDGPU uses multiple address spaces. For example, a variable may be allocated in; a register that is partially spilled to the call stack which is in the private; address space, and partially spilled to the local address space. DWARF mentions; address spaces, for example as an argument to the ``DW_OP_xderef*`` operations.; A new section that defines address spaces is added (see; :ref:`amdgpu-dwarf-address-spaces`). A new attribute ``DW_AT_LLVM_address_space`` is added to pointer and reference; types (see :ref:`amdgpu-dwarf-type-modifier-entries`). This allows the compiler; to specify which address space is being used to represent the pointer or; reference type. DWARF uses the concept of an address in many expression operations but does not; define how it relates to address spaces. For example,; ``DW_OP_push_object_address`` pushes the address of an object. Other contexts; implicitly push an address on the stack before eval",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:17732,Modifiability,variab,variable,17732,"Spaces; --------------------------------------. AMDGPU needs to be able to describe addresses that are in different kinds of; memory. Optimized code may need to describe a variable that resides in pieces; that are in different kinds of storage which may include parts of registers,; memory that is in a mixture of memory kinds, implicit values, or be undefined. DWARF has the concept of segment addresses. However, the segment cannot be; specified within a DWARF expression, which is only able to specify the offset; portion of a segment address. The segment index is only provided by the entity; that specifies the DWARF expression. Therefore, the segment index is a property; that can only be put on complete objects, such as a variable. That makes it only; suitable for describing an entity (such as variable or subprogram code) that is; in a single kind of memory. AMDGPU uses multiple address spaces. For example, a variable may be allocated in; a register that is partially spilled to the call stack which is in the private; address space, and partially spilled to the local address space. DWARF mentions; address spaces, for example as an argument to the ``DW_OP_xderef*`` operations.; A new section that defines address spaces is added (see; :ref:`amdgpu-dwarf-address-spaces`). A new attribute ``DW_AT_LLVM_address_space`` is added to pointer and reference; types (see :ref:`amdgpu-dwarf-type-modifier-entries`). This allows the compiler; to specify which address space is being used to represent the pointer or; reference type. DWARF uses the concept of an address in many expression operations but does not; define how it relates to address spaces. For example,; ``DW_OP_push_object_address`` pushes the address of an object. Other contexts; implicitly push an address on the stack before evaluating an expression. For; example, the ``DW_AT_use_location`` attribute of the; ``DW_TAG_ptr_to_member_type``. The expression belongs to a source language type; which may apply to objects allocat",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:19425,Modifiability,variab,variables,19425," to address spaces. For example,; ``DW_OP_push_object_address`` pushes the address of an object. Other contexts; implicitly push an address on the stack before evaluating an expression. For; example, the ``DW_AT_use_location`` attribute of the; ``DW_TAG_ptr_to_member_type``. The expression belongs to a source language type; which may apply to objects allocated in different kinds of storage. Therefore,; it is desirable that the expression that uses the address can do so without; regard to what kind of storage it specifies, including the address space of a; memory location description. For example, a pointer to member value may want to; be applied to an object that may reside in any address space. The DWARF ``DW_OP_xderef*`` operations allow a value to be converted into an; address of a specified address space which is then read. But it provides no; way to create a memory location description for an address in the non-default; address space. For example, AMDGPU variables can be allocated in the local; address space at a fixed address. The ``DW_OP_LLVM_form_aspace_address`` (see; :ref:`amdgpu-dwarf-memory-location-description-operations`) operation is defined; to create a memory location description from an address and address space. If; can be used to specify the location of a variable that is allocated in a; specific address space. This allows the size of addresses in an address space to; be larger than the generic type. It also allows a consumer great implementation; freedom. It allows the implicit conversion back to a value to be limited only to; the default address space to maintain compatibility with DWARF Version 5. For; other address spaces the producer can use the new operations that explicitly; specify the address space. In contrast, if the ``DW_OP_LLVM_form_aspace_address`` operation had been; defined to produce a value, and an implicit conversion to a memory location; description was defined, then it would be limited to the size of the generic; type (which m",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:19747,Modifiability,variab,variable,19747," a source language type; which may apply to objects allocated in different kinds of storage. Therefore,; it is desirable that the expression that uses the address can do so without; regard to what kind of storage it specifies, including the address space of a; memory location description. For example, a pointer to member value may want to; be applied to an object that may reside in any address space. The DWARF ``DW_OP_xderef*`` operations allow a value to be converted into an; address of a specified address space which is then read. But it provides no; way to create a memory location description for an address in the non-default; address space. For example, AMDGPU variables can be allocated in the local; address space at a fixed address. The ``DW_OP_LLVM_form_aspace_address`` (see; :ref:`amdgpu-dwarf-memory-location-description-operations`) operation is defined; to create a memory location description from an address and address space. If; can be used to specify the location of a variable that is allocated in a; specific address space. This allows the size of addresses in an address space to; be larger than the generic type. It also allows a consumer great implementation; freedom. It allows the implicit conversion back to a value to be limited only to; the default address space to maintain compatibility with DWARF Version 5. For; other address spaces the producer can use the new operations that explicitly; specify the address space. In contrast, if the ``DW_OP_LLVM_form_aspace_address`` operation had been; defined to produce a value, and an implicit conversion to a memory location; description was defined, then it would be limited to the size of the generic; type (which matches the size of the default address space). An implementation; would likely have to use *reserved ranges* of value to represent different; address spaces. Such a value would likely not match any address value in the; actual hardware. That would require the consumer to have special treatment for; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:21858,Modifiability,extend,extending,21858,"tion-description-operations`) operation is added; to allow the address space of the address held in a register to be specified. Similarly, ``DW_OP_implicit_pointer`` treats its implicit pointer value as being; in the default address space. A ``DW_OP_LLVM_aspace_implicit_pointer``; (:ref:`amdgpu-dwarf-implicit-location-description-operations`) operation is; added to allow the address space to be specified. Almost all uses of addresses in DWARF are limited to defining location; descriptions, or to be dereferenced to read memory. The exception is; ``DW_CFA_val_offset`` which uses the address to set the value of a register. In; order to support address spaces, the CFA DWARF expression is defined to be a; memory location description. This allows it to specify an address space which is; used to convert the offset address back to an address in that address space. See; :ref:`amdgpu-dwarf-call-frame-information`. This approach of extending memory location descriptions to support address; spaces, allows all existing DWARF Version 5 expressions to have the identical; semantics. It allows the compiler to explicitly specify the address space it is; using. For example, a compiler could choose to access private memory in a; swizzled manner when mapping a source language thread to the lane of a wavefront; in a SIMT manner. Or a compiler could choose to access it in an unswizzled; manner if mapping the same language with the wavefront being the thread. It also allows the compiler to mix the address space it uses to access private; memory. For example, for SIMT it can still spill entire vector registers in an; unswizzled manner, while using a swizzled private memory for SIMT variable; access. This approach also allows memory location descriptions for different address; spaces to be combined using the regular ``DW_OP_*piece`` operations. Location descriptions are an abstraction of storage. They give freedom to the; consumer on how to implement them. They allow the address space to enc",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:22609,Modifiability,variab,variable,22609,"r. In; order to support address spaces, the CFA DWARF expression is defined to be a; memory location description. This allows it to specify an address space which is; used to convert the offset address back to an address in that address space. See; :ref:`amdgpu-dwarf-call-frame-information`. This approach of extending memory location descriptions to support address; spaces, allows all existing DWARF Version 5 expressions to have the identical; semantics. It allows the compiler to explicitly specify the address space it is; using. For example, a compiler could choose to access private memory in a; swizzled manner when mapping a source language thread to the lane of a wavefront; in a SIMT manner. Or a compiler could choose to access it in an unswizzled; manner if mapping the same language with the wavefront being the thread. It also allows the compiler to mix the address space it uses to access private; memory. For example, for SIMT it can still spill entire vector registers in an; unswizzled manner, while using a swizzled private memory for SIMT variable; access. This approach also allows memory location descriptions for different address; spaces to be combined using the regular ``DW_OP_*piece`` operations. Location descriptions are an abstraction of storage. They give freedom to the; consumer on how to implement them. They allow the address space to encode lane; information so they can be used to read memory with only the memory location; description and no extra information. The same set of operations can operate on; locations independent of their kind of storage. The ``DW_OP_deref*`` therefore; can be used on any storage kind, including memory location descriptions of; different address spaces. Therefore, the ``DW_OP_xderef*`` operations are; unnecessary, except to become a more compact way to encode a non-default address; space address followed by dereferencing it. See; :ref:`amdgpu-dwarf-general-operations`. 2.9 Support for Vector Base Types; -------------------",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:25231,Modifiability,variab,variable,25231,"into portions; of a vector register. Since DWARF stack value entries have a base type and AMDGPU registers are a; vector of dwords, the ability to specify that a base type is a vector is; required. See ``DW_AT_LLVM_vector_size`` in :ref:`amdgpu-dwarf-base-type-entries`. .. _amdgpu-dwarf-operation-to-create-vector-composite-location-descriptions:. 2.10 DWARF Operations to Create Vector Composite Location Descriptions; ----------------------------------------------------------------------. AMDGPU optimized code may spill vector registers to non-global address space; memory, and this spilling may be done only for SIMT lanes that are active on; entry to the subprogram. To support this the CFI rule for the partially spilled; register needs to use an expression that uses the EXEC register as a bit mask to; select between the register (for inactive lanes) and the stack spill location; (for active lanes that are spilled). This needs to evaluate to a location; description, and not a value, as a debugger needs to change the value if the; user assigns to the variable. Another usage is to create an expression that evaluates to provide a vector of; logical PCs for active and inactive lanes in a SIMT execution model. Again the; EXEC register is used to select between active and inactive PC values. In order; to represent a vector of PC values, a way to create a composite location; description that is a vector of a single location is used. It may be possible to use existing DWARF to incrementally build the composite; location description, possibly using the DWARF operations for control flow to; create a loop. However, for the AMDGPU that would require loop iteration of 64.; A concern is that the resulting DWARF would have a significant size and would be; reasonably common as it is needed for every vector register that is spilled in a; function. AMDGPU can have up to 512 vector registers. Another concern is the; time taken to evaluate such non-trivial expressions repeatedly. To avoi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:28091,Modifiability,variab,variable,28091," a DWARF expression involving the set of SIMT lanes active on entry to a; subprogram is required. The SIMT active lane mask may be held in a register that; is modified as the subprogram executes. However, its value may be saved on entry; to the subprogram. The Call Frame Information (CFI) already encodes such register saving, so it is; more efficient to provide an operation to return the location of a saved; register than have to generate a loclist to describe the same information. This; is now possible since; :ref:`amdgpu-dwarf-allow-location-description-on-the-dwarf-evaluation-stack`; allows location descriptions on the stack. See ``DW_OP_LLVM_call_frame_entry_reg`` in; :ref:`amdgpu-dwarf-general-location-description-operations` and; :ref:`amdgpu-dwarf-call-frame-information`. 2.12 Support for Source Languages Mapped to SIMT Hardware; ---------------------------------------------------------. If the source language is mapped onto the AMDGPU wavefronts in a SIMT manner,; then the variable DWARF location expressions must compute the location for a; single lane of the wavefront. Therefore, a DWARF operation is required to denote; the current lane, much like ``DW_OP_push_object_address`` denotes the current; object. See ``DW_OP_LLVM_push_lane`` in :ref:`amdgpu-dwarf-literal-operations`. In addition, a way is needed for the compiler to communicate how many source; language threads of execution are mapped to a target architecture thread's SIMT; lanes. See ``DW_AT_LLVM_lanes`` in :ref:`amdgpu-dwarf-low-level-information`. .. _amdgpu-dwarf-support-for-divergent-control-flow-of-simt-hardware:. 2.13 Support for Divergent Control Flow of SIMT Hardware; --------------------------------------------------------. If the source language is mapped onto the AMDGPU wavefronts in a SIMT manner the; compiler can use the AMDGPU execution mask register to control which lanes are; active. To describe the conceptual location of non-active lanes requires an; attribute that has an expression",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:54365,Modifiability,variab,variable,54365,"tor as the current object when it evaluates its associated expression.*. The result is undefined if the location description is invalid (see; :ref:`amdgpu-dwarf-location-description`). *An initial stack*. This is a list of values or location descriptions that will be pushed on the; operation expression evaluation stack in the order provided before evaluation; of an operation expression starts. Some debugger information entries have attributes that evaluate their DWARF; expression value with initial stack entries. In all other cases the initial; stack is empty. The result is undefined if any location descriptions are invalid (see; :ref:`amdgpu-dwarf-location-description`). If the evaluation requires a context element that is not specified, then the; result of the evaluation is an error. *A DWARF expression for a location description may be able to be evaluated; without a thread, lane, call frame, program location, or architecture context.; For example, the location of a global variable may be able to be evaluated; without such context. If the expression evaluates with an error then it may; indicate the variable has been optimized and so requires more context.*. *The DWARF expression for call frame information (see*; :ref:`amdgpu-dwarf-call-frame-information`\ *) operations are restricted to; those that do not require the compilation unit context to be specified.*. The DWARF is ill-formed if all the ``address_size`` fields in the headers of all; the entries in the ``.debug_info``, ``.debug_addr``, ``.debug_line``,; ``.debug_rnglists``, ``.debug_rnglists.dwo``, ``.debug_loclists``, and; ``.debug_loclists.dwo`` sections corresponding to any given program location do; not match. .. _amdgpu-dwarf-expression-value:. A.2.5.2 DWARF Expression Value; ++++++++++++++++++++++++++++++. A value has a type and a literal value. It can represent a literal value of any; supported base type of the target architecture. The base type specifies the; size, encoding, and endianity of the lit",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:54493,Modifiability,variab,variable,54493,"description is invalid (see; :ref:`amdgpu-dwarf-location-description`). *An initial stack*. This is a list of values or location descriptions that will be pushed on the; operation expression evaluation stack in the order provided before evaluation; of an operation expression starts. Some debugger information entries have attributes that evaluate their DWARF; expression value with initial stack entries. In all other cases the initial; stack is empty. The result is undefined if any location descriptions are invalid (see; :ref:`amdgpu-dwarf-location-description`). If the evaluation requires a context element that is not specified, then the; result of the evaluation is an error. *A DWARF expression for a location description may be able to be evaluated; without a thread, lane, call frame, program location, or architecture context.; For example, the location of a global variable may be able to be evaluated; without such context. If the expression evaluates with an error then it may; indicate the variable has been optimized and so requires more context.*. *The DWARF expression for call frame information (see*; :ref:`amdgpu-dwarf-call-frame-information`\ *) operations are restricted to; those that do not require the compilation unit context to be specified.*. The DWARF is ill-formed if all the ``address_size`` fields in the headers of all; the entries in the ``.debug_info``, ``.debug_addr``, ``.debug_line``,; ``.debug_rnglists``, ``.debug_rnglists.dwo``, ``.debug_loclists``, and; ``.debug_loclists.dwo`` sections corresponding to any given program location do; not match. .. _amdgpu-dwarf-expression-value:. A.2.5.2 DWARF Expression Value; ++++++++++++++++++++++++++++++. A value has a type and a literal value. It can represent a literal value of any; supported base type of the target architecture. The base type specifies the; size, encoding, and endianity of the literal value. .. note::. It may be desirable to add an implicit pointer base type encoding. It would be; used for ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:56886,Modifiability,variab,variables,56886,"ere is a distinguished base type termed the generic type, which is an integral; type that has the size of an address in the target architecture default address; space, a target architecture defined endianity, and unspecified signedness. *The generic type is the same as the unspecified type used for stack operations; defined in DWARF Version 4 and before.*. An integral type is a base type that has an encoding of ``DW_ATE_signed``,; ``DW_ATE_signed_char``, ``DW_ATE_unsigned``, ``DW_ATE_unsigned_char``,; ``DW_ATE_boolean``, or any target architecture defined integral encoding in the; inclusive range ``DW_ATE_lo_user`` to ``DW_ATE_hi_user``. .. note::. It is unclear if ``DW_ATE_address`` is an integral type. GDB does not seem to; consider it as integral. .. _amdgpu-dwarf-location-description:. A.2.5.3 DWARF Location Description; ++++++++++++++++++++++++++++++++++. *Debugging information must provide consumers a way to find the location of; program variables, determine the bounds of dynamic arrays and strings, and; possibly to find the base address of a subprogram’s call frame or the return; address of a subprogram. Furthermore, to meet the needs of recent computer; architectures and optimization techniques, debugging information must be able to; describe the location of an object whose location changes over the object’s; lifetime, and may reside at multiple locations simultaneously during parts of an; object's lifetime.*. Information about the location of program objects is provided by location; descriptions. Location descriptions can consist of one or more single location descriptions. A single location description specifies the location storage that holds a; program object and a position within the location storage where the program; object starts. The position within the location storage is expressed as a bit; offset relative to the start of the location storage. A location storage is a linear stream of bits that can hold values. Each; location storage has a size in ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:76401,Modifiability,variab,variable,76401,"s the call; operation, E can use, and/or remove entries already on the stack, and can; add new entries to the stack. *Values on the stack at the time of the call may be used as parameters by; the called expression and values left on the stack by the called expression; may be used as return values by prior agreement between the calling and; called expressions.*. * If D has a ``DW_AT_location`` attribute that is encoded as a ``loclist`` or; ``loclistsptr``, then the specified location list expression E is; evaluated. The evaluation of E uses the current context, except the result; kind is a location description, the compilation unit is the one that; contains D, and the initial stack is empty. The location description; result is pushed on the stack. .. note::. This rule avoids having to define how to execute a matched location list; entry operation expression on the same stack as the call when there are; multiple matches. But it allows the call to obtain the location; description for a variable or formal parameter which may use a location; list expression. An alternative is to treat the case when D has a ``DW_AT_location``; attribute that is encoded as a ``loclist`` or ``loclistsptr``, and the; specified location list expression E' matches a single location list; entry with operation expression E, the same as the ``exprloc`` case and; evaluate on the same stack. But this is not attractive as if the attribute is for a variable that; happens to end with a non-singleton stack, it will not simply put a; location description on the stack. Presumably the intent of using; ``DW_OP_call*`` on a variable or formal parameter debugger information; entry is to push just one location description on the stack. That; location description may have more than one single location description. The previous rule for ``exprloc`` also has the same problem, as normally; a variable or formal parameter location expression may leave multiple; entries on the stack and only return the top entry. GDB",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:76841,Modifiability,variab,variable,76841," specified location list expression E is; evaluated. The evaluation of E uses the current context, except the result; kind is a location description, the compilation unit is the one that; contains D, and the initial stack is empty. The location description; result is pushed on the stack. .. note::. This rule avoids having to define how to execute a matched location list; entry operation expression on the same stack as the call when there are; multiple matches. But it allows the call to obtain the location; description for a variable or formal parameter which may use a location; list expression. An alternative is to treat the case when D has a ``DW_AT_location``; attribute that is encoded as a ``loclist`` or ``loclistsptr``, and the; specified location list expression E' matches a single location list; entry with operation expression E, the same as the ``exprloc`` case and; evaluate on the same stack. But this is not attractive as if the attribute is for a variable that; happens to end with a non-singleton stack, it will not simply put a; location description on the stack. Presumably the intent of using; ``DW_OP_call*`` on a variable or formal parameter debugger information; entry is to push just one location description on the stack. That; location description may have more than one single location description. The previous rule for ``exprloc`` also has the same problem, as normally; a variable or formal parameter location expression may leave multiple; entries on the stack and only return the top entry. GDB implements ``DW_OP_call*`` by always executing E on the same stack.; If the location list has multiple matching entries, it simply picks the; first one and ignores the rest. This seems fundamentally at odds with; the desire to support multiple places for variables. So, it feels like ``DW_OP_call*`` should both support pushing a location; description on the stack for a variable or formal parameter, and also; support being able to execute an operation expression on",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:77013,Modifiability,variab,variable,77013," is the one that; contains D, and the initial stack is empty. The location description; result is pushed on the stack. .. note::. This rule avoids having to define how to execute a matched location list; entry operation expression on the same stack as the call when there are; multiple matches. But it allows the call to obtain the location; description for a variable or formal parameter which may use a location; list expression. An alternative is to treat the case when D has a ``DW_AT_location``; attribute that is encoded as a ``loclist`` or ``loclistsptr``, and the; specified location list expression E' matches a single location list; entry with operation expression E, the same as the ``exprloc`` case and; evaluate on the same stack. But this is not attractive as if the attribute is for a variable that; happens to end with a non-singleton stack, it will not simply put a; location description on the stack. Presumably the intent of using; ``DW_OP_call*`` on a variable or formal parameter debugger information; entry is to push just one location description on the stack. That; location description may have more than one single location description. The previous rule for ``exprloc`` also has the same problem, as normally; a variable or formal parameter location expression may leave multiple; entries on the stack and only return the top entry. GDB implements ``DW_OP_call*`` by always executing E on the same stack.; If the location list has multiple matching entries, it simply picks the; first one and ignores the rest. This seems fundamentally at odds with; the desire to support multiple places for variables. So, it feels like ``DW_OP_call*`` should both support pushing a location; description on the stack for a variable or formal parameter, and also; support being able to execute an operation expression on the same stack.; Being able to specify a different operation expression for different; program locations seems a desirable feature to retain. A solution to that is to ha",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:77280,Modifiability,variab,variable,77280," when there are; multiple matches. But it allows the call to obtain the location; description for a variable or formal parameter which may use a location; list expression. An alternative is to treat the case when D has a ``DW_AT_location``; attribute that is encoded as a ``loclist`` or ``loclistsptr``, and the; specified location list expression E' matches a single location list; entry with operation expression E, the same as the ``exprloc`` case and; evaluate on the same stack. But this is not attractive as if the attribute is for a variable that; happens to end with a non-singleton stack, it will not simply put a; location description on the stack. Presumably the intent of using; ``DW_OP_call*`` on a variable or formal parameter debugger information; entry is to push just one location description on the stack. That; location description may have more than one single location description. The previous rule for ``exprloc`` also has the same problem, as normally; a variable or formal parameter location expression may leave multiple; entries on the stack and only return the top entry. GDB implements ``DW_OP_call*`` by always executing E on the same stack.; If the location list has multiple matching entries, it simply picks the; first one and ignores the rest. This seems fundamentally at odds with; the desire to support multiple places for variables. So, it feels like ``DW_OP_call*`` should both support pushing a location; description on the stack for a variable or formal parameter, and also; support being able to execute an operation expression on the same stack.; Being able to specify a different operation expression for different; program locations seems a desirable feature to retain. A solution to that is to have a distinct ``DW_AT_LLVM_proc`` attribute; for the ``DW_TAG_dwarf_procedure`` debugging information entry. Then the; ``DW_AT_location`` attribute expression is always executed separately; and pushes a location description (that may have multiple single; loca",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:77660,Modifiability,variab,variables,77660,"location list expression E' matches a single location list; entry with operation expression E, the same as the ``exprloc`` case and; evaluate on the same stack. But this is not attractive as if the attribute is for a variable that; happens to end with a non-singleton stack, it will not simply put a; location description on the stack. Presumably the intent of using; ``DW_OP_call*`` on a variable or formal parameter debugger information; entry is to push just one location description on the stack. That; location description may have more than one single location description. The previous rule for ``exprloc`` also has the same problem, as normally; a variable or formal parameter location expression may leave multiple; entries on the stack and only return the top entry. GDB implements ``DW_OP_call*`` by always executing E on the same stack.; If the location list has multiple matching entries, it simply picks the; first one and ignores the rest. This seems fundamentally at odds with; the desire to support multiple places for variables. So, it feels like ``DW_OP_call*`` should both support pushing a location; description on the stack for a variable or formal parameter, and also; support being able to execute an operation expression on the same stack.; Being able to specify a different operation expression for different; program locations seems a desirable feature to retain. A solution to that is to have a distinct ``DW_AT_LLVM_proc`` attribute; for the ``DW_TAG_dwarf_procedure`` debugging information entry. Then the; ``DW_AT_location`` attribute expression is always executed separately; and pushes a location description (that may have multiple single; location descriptions), and the ``DW_AT_LLVM_proc`` attribute expression; is always executed on the same stack and can leave anything on the; stack. The ``DW_AT_LLVM_proc`` attribute could have the new classes; ``exprproc``, ``loclistproc``, and ``loclistsptrproc`` to indicate that; the expression is executed on the same sta",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:77776,Modifiability,variab,variable,77776,"tack. But this is not attractive as if the attribute is for a variable that; happens to end with a non-singleton stack, it will not simply put a; location description on the stack. Presumably the intent of using; ``DW_OP_call*`` on a variable or formal parameter debugger information; entry is to push just one location description on the stack. That; location description may have more than one single location description. The previous rule for ``exprloc`` also has the same problem, as normally; a variable or formal parameter location expression may leave multiple; entries on the stack and only return the top entry. GDB implements ``DW_OP_call*`` by always executing E on the same stack.; If the location list has multiple matching entries, it simply picks the; first one and ignores the rest. This seems fundamentally at odds with; the desire to support multiple places for variables. So, it feels like ``DW_OP_call*`` should both support pushing a location; description on the stack for a variable or formal parameter, and also; support being able to execute an operation expression on the same stack.; Being able to specify a different operation expression for different; program locations seems a desirable feature to retain. A solution to that is to have a distinct ``DW_AT_LLVM_proc`` attribute; for the ``DW_TAG_dwarf_procedure`` debugging information entry. Then the; ``DW_AT_location`` attribute expression is always executed separately; and pushes a location description (that may have multiple single; location descriptions), and the ``DW_AT_LLVM_proc`` attribute expression; is always executed on the same stack and can leave anything on the; stack. The ``DW_AT_LLVM_proc`` attribute could have the new classes; ``exprproc``, ``loclistproc``, and ``loclistsptrproc`` to indicate that; the expression is executed on the same stack. ``exprproc`` is the same; encoding as ``exprloc``. ``loclistproc`` and ``loclistsptrproc`` are the; same encoding as their non-\ ``proc`` counterparts,",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:80473,Modifiability,variab,variable,80473,"ion 5,; and the new semantics for DWARF Version 6 which has been done for some; other features. Another option is to limit the execution to be on the same stack only to; the evaluation of an expression E that is the value of a; ``DW_AT_location`` attribute of a ``DW_TAG_dwarf_procedure`` debugging; information entry. The DWARF would be ill-formed if E is a location list; expression that does not match exactly one location list entry. In all; other cases the evaluation of an expression E that is the value of a; ``DW_AT_location`` attribute would evaluate E with the current context,; except the result kind is a location description, the compilation unit; is the one that contains D, and the initial stack is empty. The location; description result is pushed on the stack. * If D has a ``DW_AT_const_value`` attribute with a value V, then it is as; if a ``DW_OP_implicit_value V`` operation was executed. *This allows a call operation to be used to compute the location; description for any variable or formal parameter regardless of whether the; producer has optimized it to a constant. This is consistent with the*; ``DW_OP_implicit_pointer`` *operation.*. .. note::. Alternatively, could deprecate using ``DW_AT_const_value`` for; ``DW_TAG_variable`` and ``DW_TAG_formal_parameter`` debugger information; entries that are constants and instead use ``DW_AT_location`` with an; operation expression that results in a location description with one; implicit location description. Then this rule would not be required. * Otherwise, there is no effect and no changes are made to the stack. .. note::. In DWARF Version 5, if D does not have a ``DW_AT_location`` then; ``DW_OP_call*`` is defined to have no effect. It is unclear that this is; the right definition as a producer should be able to rely on using; ``DW_OP_call*`` to get a location description for any non-\; ``DW_TAG_dwarf_procedure`` debugging information entries. Also, the; producer should not be creating DWARF with ``DW_OP_call*`` ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:89881,Modifiability,extend,extended,89881," the current compilation unit for a base type of the; generic type. The operation is equivalent to performing ``DW_OP_deref_type S, DR``. 3. ``DW_OP_deref_size``. ``DW_OP_deref_size`` has a single 1-byte unsigned integral constant that; represents a byte result size S. TS is the smaller of the generic type bit size and S scaled by 8 (the byte; size). If TS is smaller than the generic type bit size then T is an unsigned; integral type of bit size TS, otherwise T is the generic type. DR is the; offset of a hypothetical debug information entry D in the current; compilation unit for a base type T. .. note::. Truncating the value when S is larger than the generic type matches what; GDB does. This allows the generic type size to not be an integral byte; size. It does allow S to be arbitrarily large. Should S be restricted to; the size of the generic type rounded up to a multiple of 8?. The operation is equivalent to performing ``DW_OP_deref_type S, DR``, except; if T is not the generic type, the value V pushed is zero-extended to the; generic type bit size and its type changed to the generic type. 4. ``DW_OP_deref_type``. ``DW_OP_deref_type`` has two operands. The first is a 1-byte unsigned; integral constant S. The second is an unsigned LEB128 integer DR that; represents the byte offset of a debugging information entry D relative to; the beginning of the current compilation unit, that provides the type T of; the result value. TS is the bit size of the type T. *While the size of the pushed value V can be inferred from the type T, it is; encoded explicitly as the operand S so that the operation can be parsed; easily without reference to the* ``.debug_info`` *section.*. .. note::. It is unclear why the operand S is needed. Unlike ``DW_OP_const_type``,; the size is not needed for parsing. Any evaluation needs to get the base; type T to push with the value to know its encoding and bit size. It pops one stack entry that must be a location description L. A value V of TS bits is",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:91752,Modifiability,extend,extend,91752,"S bits is retrieved from the location storage LS specified by; one of the single location descriptions SL of L. *If L, or the location description of any composite location description; part that is a subcomponent of L, has more than one single location; description, then any one of them can be selected as they are required to; all have the same value. For any single location description SL, bits are; retrieved from the associated storage location starting at the bit offset; specified by SL. For a composite location description, the retrieved bits; are the concatenation of the N bits from each composite location part PL,; where N is limited to the size of PL.*. V is pushed on the stack with the type T. .. note::. This definition makes it an evaluation error if L is a register location; description that has less than TS bits remaining in the register storage.; Particularly since these extensions extend location descriptions to have; a bit offset, it would be odd to define this as performing sign extension; based on the type, or be target architecture dependent, as the number of; remaining bits could be any number. This matches the GDB implementation; for ``DW_OP_deref_type``. These extensions define ``DW_OP_*breg*`` in terms of; ``DW_OP_regval_type``. ``DW_OP_regval_type`` is defined in terms of; ``DW_OP_regx``, which uses a 0 bit offset, and ``DW_OP_deref_type``.; Therefore, it requires the register size to be greater or equal to the; address size of the address space. This matches the GDB implementation for; ``DW_OP_*breg*``. The DWARF is ill-formed if D is not in the current compilation unit, D is; not a ``DW_TAG_base_type`` debugging information entry, or if TS divided by; 8 (the byte size) and rounded up to a whole number is not equal to S. .. note::. This definition allows the base type to be a bit size since there seems no; reason to restrict it. It is an evaluation error if any bit of the value is retrieved from the; undefined location storage or the offset o",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:94237,Modifiability,extend,extended,94237," be an integral type; value that represents an address A. The second must be an integral type; value that represents a target architecture specific address space; identifier AS. The operation is equivalent to performing ``DW_OP_swap;; DW_OP_LLVM_form_aspace_address; DW_OP_deref``. The value V retrieved is left; on the stack with the generic type. *This operation is deprecated as the* ``DW_OP_LLVM_form_aspace_address``; *operation can be used and provides greater expressiveness.*. 6. ``DW_OP_xderef_size`` *Deprecated*. ``DW_OP_xderef_size`` has a single 1-byte unsigned integral constant that; represents a byte result size S. It pops two stack entries. The first must be an integral type value that; represents an address A. The second must be an integral type value that; represents a target architecture specific address space identifier AS. The operation is equivalent to performing ``DW_OP_swap;; DW_OP_LLVM_form_aspace_address; DW_OP_deref_size S``. The zero-extended; value V retrieved is left on the stack with the generic type. *This operation is deprecated as the* ``DW_OP_LLVM_form_aspace_address``; *operation can be used and provides greater expressiveness.*. 7. ``DW_OP_xderef_type`` *Deprecated*. ``DW_OP_xderef_type`` has two operands. The first is a 1-byte unsigned; integral constant S. The second operand is an unsigned LEB128 integer DR; that represents the byte offset of a debugging information entry D relative; to the beginning of the current compilation unit, that provides the type T; of the result value. It pops two stack entries. The first must be an integral type value that; represents an address A. The second must be an integral type value that; represents a target architecture specific address space identifier AS. The operation is equivalent to performing ``DW_OP_swap;; DW_OP_LLVM_form_aspace_address; DW_OP_deref_type S DR``. The value V; retrieved is left on the stack with the type T. *This operation is deprecated as the* ``DW_OP_LLVM_form_aspace_address`",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:100012,Modifiability,variab,variable,100012,"LLVM_offset``. *This operation is supplied specifically to be able to encode more field; displacements in two bytes than can be done with* ``DW_OP_lit*;; DW_OP_LLVM_offset``\ *.*. .. note::. Should this be named ``DW_OP_LLVM_offset_uconst`` to match; ``DW_OP_plus_uconst``, or ``DW_OP_LLVM_offset_constu`` to match; ``DW_OP_constu``?. 3. ``DW_OP_LLVM_bit_offset`` *New*. ``DW_OP_LLVM_bit_offset`` pops two stack entries. The first must be an; integral type value that represents a bit displacement B. The second must be; a location description L. It adds the value of B to the bit offset of each single location description; SL of L, and pushes the updated L. It is an evaluation error if the updated bit offset of any SL is less than 0; or greater than or equal to the size of the location storage specified by; SL. 4. ``DW_OP_push_object_address``. ``DW_OP_push_object_address`` pushes the location description L of the; current object. *This object may correspond to an independent variable that is part of a; user presented expression that is being evaluated. The object location; description may be determined from the variable's own debugging information; entry or it may be a component of an array, structure, or class whose; address has been dynamically determined by an earlier step during user; expression evaluation.*. *This operation provides explicit functionality (especially for arrays; involving descriptors) that is analogous to the implicit push of the base; location description of a structure prior to evaluation of a*; ``DW_AT_data_member_location`` *to access a data member of a structure.*. .. note::. This operation could be removed and the object location description; specified as the initial stack as for ``DW_AT_data_member_location``. Or this operation could be used instead of needing to specify an initial; stack. The latter approach is more composable as access to the object may; be needed at any point of the expression, and passing it as the initial; stack requires ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:100151,Modifiability,variab,variable,100151,"ld this be named ``DW_OP_LLVM_offset_uconst`` to match; ``DW_OP_plus_uconst``, or ``DW_OP_LLVM_offset_constu`` to match; ``DW_OP_constu``?. 3. ``DW_OP_LLVM_bit_offset`` *New*. ``DW_OP_LLVM_bit_offset`` pops two stack entries. The first must be an; integral type value that represents a bit displacement B. The second must be; a location description L. It adds the value of B to the bit offset of each single location description; SL of L, and pushes the updated L. It is an evaluation error if the updated bit offset of any SL is less than 0; or greater than or equal to the size of the location storage specified by; SL. 4. ``DW_OP_push_object_address``. ``DW_OP_push_object_address`` pushes the location description L of the; current object. *This object may correspond to an independent variable that is part of a; user presented expression that is being evaluated. The object location; description may be determined from the variable's own debugging information; entry or it may be a component of an array, structure, or class whose; address has been dynamically determined by an earlier step during user; expression evaluation.*. *This operation provides explicit functionality (especially for arrays; involving descriptors) that is analogous to the implicit push of the base; location description of a structure prior to evaluation of a*; ``DW_AT_data_member_location`` *to access a data member of a structure.*. .. note::. This operation could be removed and the object location description; specified as the initial stack as for ``DW_AT_data_member_location``. Or this operation could be used instead of needing to specify an initial; stack. The latter approach is more composable as access to the object may; be needed at any point of the expression, and passing it as the initial; stack requires the entire expression to be aware where on the stack it is.; If this were done, ``DW_AT_use_location`` would require a; ``DW_OP_push_object2_address`` operation for the second object. Or a more ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:107124,Modifiability,extend,extended,107124,"o A and an address space equal to AS of the; corresponding SL. ``DW_ASPACE_LLVM_none`` is defined as the target architecture default address; space. See :ref:`amdgpu-dwarf-address-spaces`. If a stack entry is required to be a location description, but it is a value V; with the generic type, then it is implicitly converted to a location description; L with one memory location description SL. SL specifies the memory location; storage that corresponds to the target architecture default address space with a; bit offset equal to V scaled by 8 (the byte size). .. note::. If it is wanted to allow any integral type value to be implicitly converted to; a memory location description in the target architecture default address; space:. If a stack entry is required to be a location description, but is a value V; with an integral type, then it is implicitly converted to a location; description L with a one memory location description SL. If the type size of; V is less than the generic type size, then the value V is zero extended to; the size of the generic type. The least significant generic type size bits; are treated as an unsigned value to be used as an address A. SL specifies; memory location storage corresponding to the target architecture default; address space with a bit offset equal to A scaled by 8 (the byte size). The implicit conversion could also be defined as target architecture specific.; For example, GDB checks if V is an integral type. If it is not it gives an; error. Otherwise, GDB zero-extends V to 64 bits. If the GDB target defines a; hook function, then it is called. The target specific hook function can modify; the 64-bit value, possibly sign extending based on the original value type.; Finally, GDB treats the 64-bit value V as a memory location address. If a stack entry is required to be a location description, but it is an implicit; pointer value IPV with the target architecture default address space, then it is; implicitly converted to a location descriptio",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:107617,Modifiability,extend,extends,107617,"ffset equal to V scaled by 8 (the byte size). .. note::. If it is wanted to allow any integral type value to be implicitly converted to; a memory location description in the target architecture default address; space:. If a stack entry is required to be a location description, but is a value V; with an integral type, then it is implicitly converted to a location; description L with a one memory location description SL. If the type size of; V is less than the generic type size, then the value V is zero extended to; the size of the generic type. The least significant generic type size bits; are treated as an unsigned value to be used as an address A. SL specifies; memory location storage corresponding to the target architecture default; address space with a bit offset equal to A scaled by 8 (the byte size). The implicit conversion could also be defined as target architecture specific.; For example, GDB checks if V is an integral type. If it is not it gives an; error. Otherwise, GDB zero-extends V to 64 bits. If the GDB target defines a; hook function, then it is called. The target specific hook function can modify; the 64-bit value, possibly sign extending based on the original value type.; Finally, GDB treats the 64-bit value V as a memory location address. If a stack entry is required to be a location description, but it is an implicit; pointer value IPV with the target architecture default address space, then it is; implicitly converted to a location description with one single location; description specified by IPV. See; :ref:`amdgpu-dwarf-implicit-location-description-operations`. .. note::. Is this rule required for DWARF Version 5 backwards compatibility? If not, it; can be eliminated, and the producer can use; ``DW_OP_LLVM_form_aspace_address``. If a stack entry is required to be a value, but it is a location description L; with one memory location description SL in the target architecture default; address space with a bit offset B that is a multiple of 8, the",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:107780,Modifiability,extend,extending,107780," location description in the target architecture default address; space:. If a stack entry is required to be a location description, but is a value V; with an integral type, then it is implicitly converted to a location; description L with a one memory location description SL. If the type size of; V is less than the generic type size, then the value V is zero extended to; the size of the generic type. The least significant generic type size bits; are treated as an unsigned value to be used as an address A. SL specifies; memory location storage corresponding to the target architecture default; address space with a bit offset equal to A scaled by 8 (the byte size). The implicit conversion could also be defined as target architecture specific.; For example, GDB checks if V is an integral type. If it is not it gives an; error. Otherwise, GDB zero-extends V to 64 bits. If the GDB target defines a; hook function, then it is called. The target specific hook function can modify; the 64-bit value, possibly sign extending based on the original value type.; Finally, GDB treats the 64-bit value V as a memory location address. If a stack entry is required to be a location description, but it is an implicit; pointer value IPV with the target architecture default address space, then it is; implicitly converted to a location description with one single location; description specified by IPV. See; :ref:`amdgpu-dwarf-implicit-location-description-operations`. .. note::. Is this rule required for DWARF Version 5 backwards compatibility? If not, it; can be eliminated, and the producer can use; ``DW_OP_LLVM_form_aspace_address``. If a stack entry is required to be a value, but it is a location description L; with one memory location description SL in the target architecture default; address space with a bit offset B that is a multiple of 8, then it is implicitly; converted to a value equal to B divided by 8 (the byte size) with the generic; type. 1. ``DW_OP_addr``. ``DW_OP_addr`` has a ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:110681,Modifiability,extend,extending,110681,"t pushes a location description L with one memory location description SL; on the stack. SL specifies the memory location storage corresponding to the; target architecture default address space with a bit offset equal to A; scaled by 8 (the byte size). *If the DWARF is part of a code object, then A may need to be relocated. For; example, in the ELF code object format, A must be adjusted by the difference; between the ELF segment virtual address and the virtual address at which the; segment is loaded.*. 3. ``DW_OP_LLVM_form_aspace_address`` *New*. ``DW_OP_LLVM_form_aspace_address`` pops top two stack entries. The first; must be an integral type value that represents a target architecture; specific address space identifier AS. The second must be an integral type; value that represents an address A. The address size S is defined as the address bit size of the target; architecture specific address space that corresponds to AS. A is adjusted to S bits by zero extending if necessary, and then treating; the least significant S bits as an unsigned value A'. It pushes a location description L with one memory location description SL; on the stack. SL specifies the memory location storage LS that corresponds; to AS with a bit offset equal to A' scaled by 8 (the byte size). If AS is an address space that is specific to context elements, then LS; corresponds to the location storage associated with the current context. *For example, if AS is for per thread storage then LS is the location; storage for the current thread. For languages that are implemented using a; SIMT execution model, then if AS is for per lane storage then LS is the; location storage for the current lane of the current thread. Therefore, if L; is accessed by an operation, the location storage selected when the location; description was created is accessed, and not the location storage associated; with the current context of the access operation.*. The DWARF expression is ill-formed if AS is not one of the values ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:112953,Modifiability,variab,variables,112953,"icit; location descriptions created by the ``DW_OP_implicit_pointer`` and; ``DW_OP_LLVM_aspace_implicit_pointer`` operations. 4. ``DW_OP_form_tls_address``. ``DW_OP_form_tls_address`` pops one stack entry that must be an integral; type value and treats it as a thread-local storage address TA. It pushes a location description L with one memory location description SL; on the stack. SL is the target architecture specific memory location; description that corresponds to the thread-local storage address TA. The meaning of the thread-local storage address TA is defined by the; run-time environment. If the run-time environment supports multiple; thread-local storage blocks for a single thread, then the block; corresponding to the executable or shared library containing this DWARF; expression is used. *Some implementations of C, C++, Fortran, and other languages, support a; thread-local storage class. Variables with this storage class have distinct; values and addresses in distinct threads, much as automatic variables have; distinct values and addresses in each subprogram invocation. Typically,; there is a single block of storage containing all thread-local variables; declared in the main executable, and a separate block for the variables; declared in each shared library. Each thread-local variable can then be; accessed in its block using an identifier. This identifier is typically a; byte offset into the block and pushed onto the DWARF stack by one of the*; ``DW_OP_const*`` *operations prior to the* ``DW_OP_form_tls_address``; *operation. Computing the address of the appropriate block can be complex; (in some cases, the compiler emits a function call to do it), and difficult; to describe using ordinary DWARF location descriptions. Instead of forcing; complex thread-local storage calculations into the DWARF expressions, the*; ``DW_OP_form_tls_address`` *allows the consumer to perform the computation; based on the target architecture specific run-time environment.*. 5. ``DW",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:113105,Modifiability,variab,variables,113105,"one stack entry that must be an integral; type value and treats it as a thread-local storage address TA. It pushes a location description L with one memory location description SL; on the stack. SL is the target architecture specific memory location; description that corresponds to the thread-local storage address TA. The meaning of the thread-local storage address TA is defined by the; run-time environment. If the run-time environment supports multiple; thread-local storage blocks for a single thread, then the block; corresponding to the executable or shared library containing this DWARF; expression is used. *Some implementations of C, C++, Fortran, and other languages, support a; thread-local storage class. Variables with this storage class have distinct; values and addresses in distinct threads, much as automatic variables have; distinct values and addresses in each subprogram invocation. Typically,; there is a single block of storage containing all thread-local variables; declared in the main executable, and a separate block for the variables; declared in each shared library. Each thread-local variable can then be; accessed in its block using an identifier. This identifier is typically a; byte offset into the block and pushed onto the DWARF stack by one of the*; ``DW_OP_const*`` *operations prior to the* ``DW_OP_form_tls_address``; *operation. Computing the address of the appropriate block can be complex; (in some cases, the compiler emits a function call to do it), and difficult; to describe using ordinary DWARF location descriptions. Instead of forcing; complex thread-local storage calculations into the DWARF expressions, the*; ``DW_OP_form_tls_address`` *allows the consumer to perform the computation; based on the target architecture specific run-time environment.*. 5. ``DW_OP_call_frame_cfa``. ``DW_OP_call_frame_cfa`` pushes the location description L of the Canonical; Frame Address (CFA) of the current subprogram, obtained from the call frame; information o",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:113178,Modifiability,variab,variables,113178,"one stack entry that must be an integral; type value and treats it as a thread-local storage address TA. It pushes a location description L with one memory location description SL; on the stack. SL is the target architecture specific memory location; description that corresponds to the thread-local storage address TA. The meaning of the thread-local storage address TA is defined by the; run-time environment. If the run-time environment supports multiple; thread-local storage blocks for a single thread, then the block; corresponding to the executable or shared library containing this DWARF; expression is used. *Some implementations of C, C++, Fortran, and other languages, support a; thread-local storage class. Variables with this storage class have distinct; values and addresses in distinct threads, much as automatic variables have; distinct values and addresses in each subprogram invocation. Typically,; there is a single block of storage containing all thread-local variables; declared in the main executable, and a separate block for the variables; declared in each shared library. Each thread-local variable can then be; accessed in its block using an identifier. This identifier is typically a; byte offset into the block and pushed onto the DWARF stack by one of the*; ``DW_OP_const*`` *operations prior to the* ``DW_OP_form_tls_address``; *operation. Computing the address of the appropriate block can be complex; (in some cases, the compiler emits a function call to do it), and difficult; to describe using ordinary DWARF location descriptions. Instead of forcing; complex thread-local storage calculations into the DWARF expressions, the*; ``DW_OP_form_tls_address`` *allows the consumer to perform the computation; based on the target architecture specific run-time environment.*. 5. ``DW_OP_call_frame_cfa``. ``DW_OP_call_frame_cfa`` pushes the location description L of the Canonical; Frame Address (CFA) of the current subprogram, obtained from the call frame; information o",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:113240,Modifiability,variab,variable,113240," L with one memory location description SL; on the stack. SL is the target architecture specific memory location; description that corresponds to the thread-local storage address TA. The meaning of the thread-local storage address TA is defined by the; run-time environment. If the run-time environment supports multiple; thread-local storage blocks for a single thread, then the block; corresponding to the executable or shared library containing this DWARF; expression is used. *Some implementations of C, C++, Fortran, and other languages, support a; thread-local storage class. Variables with this storage class have distinct; values and addresses in distinct threads, much as automatic variables have; distinct values and addresses in each subprogram invocation. Typically,; there is a single block of storage containing all thread-local variables; declared in the main executable, and a separate block for the variables; declared in each shared library. Each thread-local variable can then be; accessed in its block using an identifier. This identifier is typically a; byte offset into the block and pushed onto the DWARF stack by one of the*; ``DW_OP_const*`` *operations prior to the* ``DW_OP_form_tls_address``; *operation. Computing the address of the appropriate block can be complex; (in some cases, the compiler emits a function call to do it), and difficult; to describe using ordinary DWARF location descriptions. Instead of forcing; complex thread-local storage calculations into the DWARF expressions, the*; ``DW_OP_form_tls_address`` *allows the consumer to perform the computation; based on the target architecture specific run-time environment.*. 5. ``DW_OP_call_frame_cfa``. ``DW_OP_call_frame_cfa`` pushes the location description L of the Canonical; Frame Address (CFA) of the current subprogram, obtained from the call frame; information on the stack. See :ref:`amdgpu-dwarf-call-frame-information`. *Although the value of the* ``DW_AT_frame_base`` *attribute of the debugger; ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:126677,Modifiability,variab,variables,126677,"D has a ``DW_AT_location`` attribute, the DWARF expression E from the; ``DW_AT_location`` attribute is evaluated with the current context, except; that the result kind is a location description, the compilation unit is; the one that contains D, the object is unspecified, and the initial stack; is empty. RL is the expression result. *Note that E is evaluated with the context of the expression accessing; IPV, and not the context of the expression that contained the*; ``DW_OP_implicit_pointer`` *or* ``DW_OP_LLVM_aspace_implicit_pointer``; *operation that created L.*. * If D has a ``DW_AT_const_value`` attribute, then an implicit location; storage RLS is created from the ``DW_AT_const_value`` attribute's value; with a size matching the size of the ``DW_AT_const_value`` attribute's; value. RL comprises one implicit location description SRL. SRL specifies; RLS with a bit offset of 0. .. note::. If using ``DW_AT_const_value`` for variables and formal parameters is; deprecated and instead ``DW_AT_location`` is used with an implicit; location description, then this rule would not be required. * Otherwise, it is an evaluation error. The bit offset of RL is updated as if the ``DW_OP_LLVM_offset_uconst B``; operation was applied. If a ``DW_OP_stack_value`` operation pops a value that is the same as IPV,; then it pushes a location description that is the same as L. It is an evaluation error if LS or IPV is accessed in any other manner. *The restrictions on how an implicit pointer location description created; by* ``DW_OP_implicit_pointer`` *and* ``DW_OP_LLVM_aspace_implicit_pointer``; *can be used are to simplify the DWARF consumer. Similarly, for an implicit; pointer value created by* ``DW_OP_deref*`` *and* ``DW_OP_stack_value``\ *.*. 4. ``DW_OP_LLVM_aspace_implicit_pointer`` *New*. ``DW_OP_LLVM_aspace_implicit_pointer`` has two operands that are the same as; for ``DW_OP_implicit_pointer``. It pops one stack entry that must be an integral type value that represents; a target arc",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:135327,Modifiability,variab,variable,135327,"L. L is left on the stack. * Otherwise, if the top stack entry is a location description or can be; converted to one, then it is popped and treated as a part location; description PL. Then:. * If the top stack entry (after popping PL) is a location description L; comprised of one incomplete composite location description SL, then the; incomplete composite location storage LS that SL specifies is updated to; append a new part P. P specifies the location description PL and has a; bit size of S scaled by 8 (the byte size). L is left on the stack. * Otherwise, a location description L comprised of one incomplete; composite location description SL is pushed on the stack. An incomplete composite location storage LS is created with a single; part P. P specifies the location description PL and has a bit size of S; scaled by 8 (the byte size). SL specifies LS with a bit offset of 0. * Otherwise, the DWARF expression is ill-formed. *Many compilers store a single variable in sets of registers or store a; variable partially in memory and partially in registers.* ``DW_OP_piece``; *provides a way of describing where a part of a variable is located.*. *If a non-0 byte displacement is required, the* ``DW_OP_LLVM_offset``; *operation can be used to update the location description before using it as; the part location description of a* ``DW_OP_piece`` *operation.*. *The evaluation rules for the* ``DW_OP_piece`` *operation allow it to be; compatible with the DWARF Version 5 definition.*. .. note::. Since these extensions allow location descriptions to be entries on the; stack, a simpler operation to create composite location descriptions could; be defined. For example, just one operation that specifies how many parts,; and pops pairs of stack entries for the part size and location; description. Not only would this be a simpler operation and avoid the; complexities of incomplete composite location descriptions, but it may; also have a smaller encoding in practice. However, the desire f",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:135369,Modifiability,variab,variable,135369,"L. L is left on the stack. * Otherwise, if the top stack entry is a location description or can be; converted to one, then it is popped and treated as a part location; description PL. Then:. * If the top stack entry (after popping PL) is a location description L; comprised of one incomplete composite location description SL, then the; incomplete composite location storage LS that SL specifies is updated to; append a new part P. P specifies the location description PL and has a; bit size of S scaled by 8 (the byte size). L is left on the stack. * Otherwise, a location description L comprised of one incomplete; composite location description SL is pushed on the stack. An incomplete composite location storage LS is created with a single; part P. P specifies the location description PL and has a bit size of S; scaled by 8 (the byte size). SL specifies LS with a bit offset of 0. * Otherwise, the DWARF expression is ill-formed. *Many compilers store a single variable in sets of registers or store a; variable partially in memory and partially in registers.* ``DW_OP_piece``; *provides a way of describing where a part of a variable is located.*. *If a non-0 byte displacement is required, the* ``DW_OP_LLVM_offset``; *operation can be used to update the location description before using it as; the part location description of a* ``DW_OP_piece`` *operation.*. *The evaluation rules for the* ``DW_OP_piece`` *operation allow it to be; compatible with the DWARF Version 5 definition.*. .. note::. Since these extensions allow location descriptions to be entries on the; stack, a simpler operation to create composite location descriptions could; be defined. For example, just one operation that specifies how many parts,; and pops pairs of stack entries for the part size and location; description. Not only would this be a simpler operation and avoid the; complexities of incomplete composite location descriptions, but it may; also have a smaller encoding in practice. However, the desire f",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:135492,Modifiability,variab,variable,135492,"d to one, then it is popped and treated as a part location; description PL. Then:. * If the top stack entry (after popping PL) is a location description L; comprised of one incomplete composite location description SL, then the; incomplete composite location storage LS that SL specifies is updated to; append a new part P. P specifies the location description PL and has a; bit size of S scaled by 8 (the byte size). L is left on the stack. * Otherwise, a location description L comprised of one incomplete; composite location description SL is pushed on the stack. An incomplete composite location storage LS is created with a single; part P. P specifies the location description PL and has a bit size of S; scaled by 8 (the byte size). SL specifies LS with a bit offset of 0. * Otherwise, the DWARF expression is ill-formed. *Many compilers store a single variable in sets of registers or store a; variable partially in memory and partially in registers.* ``DW_OP_piece``; *provides a way of describing where a part of a variable is located.*. *If a non-0 byte displacement is required, the* ``DW_OP_LLVM_offset``; *operation can be used to update the location description before using it as; the part location description of a* ``DW_OP_piece`` *operation.*. *The evaluation rules for the* ``DW_OP_piece`` *operation allow it to be; compatible with the DWARF Version 5 definition.*. .. note::. Since these extensions allow location descriptions to be entries on the; stack, a simpler operation to create composite location descriptions could; be defined. For example, just one operation that specifies how many parts,; and pops pairs of stack entries for the part size and location; description. Not only would this be a simpler operation and avoid the; complexities of incomplete composite location descriptions, but it may; also have a smaller encoding in practice. However, the desire for; compatibility with DWARF Version 5 is likely a stronger consideration. 2. ``DW_OP_bit_piece``. ``DW_OP_bi",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:139842,Modifiability,variab,variable,139842," value M. The second must be a location description; that represents the one-location description L1. The third must be a; location description that represents the zero-location description L0. A complete composite location storage LS is created with C parts P\ :sub:`N`; ordered in ascending N from 0 to C-1 inclusive. Each P\ :sub:`N` specifies; location description PL\ :sub:`N` and has a bit size of S. PL\ :sub:`N` is as if the ``DW_OP_LLVM_bit_offset N*S`` operation was; applied to PLX\ :sub:`N`\ . PLX\ :sub:`N` is the same as L0 if the N\ :sup:`th` least significant bit of; M is a zero, otherwise it is the same as L1. A location description L comprised of one complete composite location; description SL is pushed on the stack. SL specifies LS with a bit offset of; 0. The DWARF expression is ill-formed if S or C are 0, or if the bit size of M; is less than C. .. note::. Should the count operand for DW_OP_extend and DW_OP_select_bit_piece be; changed to get the count value off the stack? This would allow support for; architectures that have variable length vector instructions such as ARM; and RISC-V. 6. ``DW_OP_LLVM_overlay`` *New*. ``DW_OP_LLVM_overlay`` pops four stack entries. The first must be an; integral type value that represents the overlay byte size value S. The; second must be an integral type value that represents the overlay byte; offset value O. The third must be a location description that represents the; overlay location description OL. The fourth must be a location description; that represents the base location description BL. The action is the same as for ``DW_OP_LLVM_bit_overlay``, except that the; overlay bit size BS and overlay bit offset BO used are S and O respectively; scaled by 8 (the byte size). 7. ``DW_OP_LLVM_bit_overlay`` *New*. ``DW_OP_LLVM_bit_overlay`` pops four stack entries. The first must be an; integral type value that represents the overlay bit size value BS. The; second must be an integral type value that represents the overlay b",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:149012,Modifiability,variab,variable,149012,"ta; resides. *Target architecture specific DWARF address spaces may correspond to hardware; supported facilities such as memory utilizing base address registers, scratchpad; memory, and memory with special interleaving. The size of addresses in these; address spaces may vary. Their access and allocation may be hardware managed; with each thread or group of threads having access to independent storage. For; these reasons they may have properties that do not allow them to be viewed as; part of the unified global virtual address space accessible by all threads.*. *It is target architecture specific whether multiple DWARF address spaces are; supported and how source language memory spaces map to target architecture; specific DWARF address spaces. A target architecture may map multiple source; language memory spaces to the same target architecture specific DWARF address; class. Optimization may determine that variable lifetime and access pattern; allows them to be allocated in faster scratchpad memory represented by a; different DWARF address space than the default for the source language memory; space.*. Although DWARF address space identifiers are target architecture specific,; ``DW_ASPACE_LLVM_none`` is a common address space supported by all target; architectures, and defined as the target architecture default address space. DWARF address space identifiers are used by:. * The ``DW_AT_LLVM_address_space`` attribute. * The DWARF expression operations: ``DW_OP_aspace_bregx``,; ``DW_OP_form_aspace_address``, ``DW_OP_aspace_implicit_pointer``, and; ``DW_OP_xderef*``. * The CFI instructions: ``DW_CFA_def_aspace_cfa`` and; ``DW_CFA_def_aspace_cfa_sf``. .. note::. Currently, DWARF defines address class values as being target architecture; specific, and defines a DW_AT_address_class attribute. With the removal of; DW_AT_segment in DWARF 6, it is unclear how the address class is intended to; be used as the term is not used elsewhere. Should these be replaced by this; proposal'",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:150561,Modifiability,variab,variable,150561,"ssion operations: ``DW_OP_aspace_bregx``,; ``DW_OP_form_aspace_address``, ``DW_OP_aspace_implicit_pointer``, and; ``DW_OP_xderef*``. * The CFI instructions: ``DW_CFA_def_aspace_cfa`` and; ``DW_CFA_def_aspace_cfa_sf``. .. note::. Currently, DWARF defines address class values as being target architecture; specific, and defines a DW_AT_address_class attribute. With the removal of; DW_AT_segment in DWARF 6, it is unclear how the address class is intended to; be used as the term is not used elsewhere. Should these be replaced by this; proposal's more complete address space? Or are they intended to represent; source language memory spaces such as in OpenCL?. .. _amdgpu-dwarf-memory-spaces:. A.2.14 Memory Spaces; ~~~~~~~~~~~~~~~~~~~~. .. note::. This is a new section after DWARF Version 5 section 2.12 Segmented Addresses. DWARF memory spaces are used for source languages that have the concept of; memory spaces. They are used in the ``DW_AT_LLVM_memory_space`` attribute for; pointer type, reference type, variable, formal parameter, and constant debugger; information entries. Each DWARF memory space is conceptually a separate source language memory space; with its own lifetime and aliasing rules. DWARF memory spaces are used to; specify the source language memory spaces that pointer type and reference type; values refer, and to specify the source language memory space in which variables; are allocated. Although DWARF memory space identifiers are source language specific,; ``DW_MSPACE_LLVM_none`` is a common memory space supported by all source; languages, and defined as the source language default memory space. The set of currently defined DWARF memory spaces, together with source language; mappings, is given in :ref:`amdgpu-dwarf-source-language-memory-spaces-table`. Vendor defined source language memory spaces may be defined using codes in the; range ``DW_MSPACE_LLVM_lo_user`` to ``DW_MSPACE_LLVM_hi_user``. .. table:: Source language memory spaces; :name: amdgpu-dwarf-sour",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:150940,Modifiability,variab,variables,150940,"ic, and defines a DW_AT_address_class attribute. With the removal of; DW_AT_segment in DWARF 6, it is unclear how the address class is intended to; be used as the term is not used elsewhere. Should these be replaced by this; proposal's more complete address space? Or are they intended to represent; source language memory spaces such as in OpenCL?. .. _amdgpu-dwarf-memory-spaces:. A.2.14 Memory Spaces; ~~~~~~~~~~~~~~~~~~~~. .. note::. This is a new section after DWARF Version 5 section 2.12 Segmented Addresses. DWARF memory spaces are used for source languages that have the concept of; memory spaces. They are used in the ``DW_AT_LLVM_memory_space`` attribute for; pointer type, reference type, variable, formal parameter, and constant debugger; information entries. Each DWARF memory space is conceptually a separate source language memory space; with its own lifetime and aliasing rules. DWARF memory spaces are used to; specify the source language memory spaces that pointer type and reference type; values refer, and to specify the source language memory space in which variables; are allocated. Although DWARF memory space identifiers are source language specific,; ``DW_MSPACE_LLVM_none`` is a common memory space supported by all source; languages, and defined as the source language default memory space. The set of currently defined DWARF memory spaces, together with source language; mappings, is given in :ref:`amdgpu-dwarf-source-language-memory-spaces-table`. Vendor defined source language memory spaces may be defined using codes in the; range ``DW_MSPACE_LLVM_lo_user`` to ``DW_MSPACE_LLVM_hi_user``. .. table:: Source language memory spaces; :name: amdgpu-dwarf-source-language-memory-spaces-table. =========================== ============ ============== ============== ==============; Memory Space Name Meaning C/C++ OpenCL CUDA/HIP; =========================== ============ ============== ============== ==============; ``DW_MSPACE_LLVM_none`` generic *default* generic *defa",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:154500,Modifiability,extend,extending,154500,"e language semantics. A.3 Program Scope Entries; -------------------------. .. note::. This section provides changes to existing debugger information entry; attributes. These would be incorporated into the corresponding DWARF Version 5; chapter 3 sections. A.3.1 Unit Entries; ~~~~~~~~~~~~~~~~~~. .. _amdgpu-dwarf-full-and-partial-compilation-unit-entries:. A.3.1.1 Full and Partial Compilation Unit Entries; +++++++++++++++++++++++++++++++++++++++++++++++++. .. note::. This augments DWARF Version 5 section 3.1.1 and Table 3.1. Additional language codes defined for use with the ``DW_AT_language`` attribute; are defined in :ref:`amdgpu-dwarf-language-names-table`. .. table:: Language Names; :name: amdgpu-dwarf-language-names-table. ==================== =============================; Language Name Meaning; ==================== =============================; ``DW_LANG_LLVM_HIP`` HIP Language.; ==================== =============================. The HIP language [:ref:`HIP <amdgpu-dwarf-HIP>`] can be supported by extending; the C++ language. .. note::. The following new attribute is added. 1. A ``DW_TAG_compile_unit`` debugger information entry for a compilation unit; may have a ``DW_AT_LLVM_augmentation`` attribute, whose value is an; augmentation string. *The augmentation string allows producers to indicate that there is; additional vendor or target specific information in the debugging; information entries. For example, this might be information about the; version of vendor specific extensions that are being used.*. If not present, or if the string is empty, then the compilation unit has no; augmentation string. The format for the augmentation string is:. | ``[``\ *vendor*\ ``:v``\ *X*\ ``.``\ *Y*\ [\ ``:``\ *options*\ ]\ ``]``\ *. Where *vendor* is the producer, ``vX.Y`` specifies the major X and minor Y; version number of the extensions used, and *options* is an optional string; providing additional information about the extensions. The version number; must conform to ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:158909,Modifiability,variab,variables,158909,"g*`` *to be used instead of*; ``DW_OP_breg* 0``\ *.*. .. note::. This rule could be removed and require the producer to create the required; location description directly using ``DW_OP_call_frame_cfa``,; ``DW_OP_breg*``, or ``DW_OP_LLVM_aspace_bregx``. This would also then; allow a target to implement the call frames within a large register. Otherwise, the DWARF is ill-formed if SL is not a memory location; description in any of the target architecture specific address spaces. The resulting L is the *frame base* for the subprogram or entry point. *Typically, E will use the* ``DW_OP_call_frame_cfa`` *operation or be a; stack pointer register plus or minus some offset.*. *The frame base for a subprogram is typically an address relative to the; first unit of storage allocated for the subprogram's stack frame. The*; ``DW_AT_frame_base`` *attribute can be used in several ways:*. 1. *In subprograms that need location lists to locate local variables, the*; ``DW_AT_frame_base`` *can hold the needed location list, while all; variables' location descriptions can be simpler ones involving the frame; base.*. 2. *It can be used in resolving ""up-level"" addressing within; nested routines. (See also* ``DW_AT_static_link``\ *, below)*. *Some languages support nested subroutines. In such languages, it is; possible to reference the local variables of an outer subroutine from within; an inner subroutine. The* ``DW_AT_static_link`` *and* ``DW_AT_frame_base``; *attributes allow debuggers to support this same kind of referencing.*. 3. If a ``DW_TAG_subprogram`` or ``DW_TAG_entry_point`` debugger information; entry is lexically nested, it may have a ``DW_AT_static_link`` attribute,; whose value is a DWARF expression E. The result of the attribute is obtained by evaluating E with a context that; has a result kind of a location description, an unspecified object, the; compilation unit that contains E, an empty initial stack, and other context; elements corresponding to the source language th",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:158994,Modifiability,variab,variables,158994,"g*`` *to be used instead of*; ``DW_OP_breg* 0``\ *.*. .. note::. This rule could be removed and require the producer to create the required; location description directly using ``DW_OP_call_frame_cfa``,; ``DW_OP_breg*``, or ``DW_OP_LLVM_aspace_bregx``. This would also then; allow a target to implement the call frames within a large register. Otherwise, the DWARF is ill-formed if SL is not a memory location; description in any of the target architecture specific address spaces. The resulting L is the *frame base* for the subprogram or entry point. *Typically, E will use the* ``DW_OP_call_frame_cfa`` *operation or be a; stack pointer register plus or minus some offset.*. *The frame base for a subprogram is typically an address relative to the; first unit of storage allocated for the subprogram's stack frame. The*; ``DW_AT_frame_base`` *attribute can be used in several ways:*. 1. *In subprograms that need location lists to locate local variables, the*; ``DW_AT_frame_base`` *can hold the needed location list, while all; variables' location descriptions can be simpler ones involving the frame; base.*. 2. *It can be used in resolving ""up-level"" addressing within; nested routines. (See also* ``DW_AT_static_link``\ *, below)*. *Some languages support nested subroutines. In such languages, it is; possible to reference the local variables of an outer subroutine from within; an inner subroutine. The* ``DW_AT_static_link`` *and* ``DW_AT_frame_base``; *attributes allow debuggers to support this same kind of referencing.*. 3. If a ``DW_TAG_subprogram`` or ``DW_TAG_entry_point`` debugger information; entry is lexically nested, it may have a ``DW_AT_static_link`` attribute,; whose value is a DWARF expression E. The result of the attribute is obtained by evaluating E with a context that; has a result kind of a location description, an unspecified object, the; compilation unit that contains E, an empty initial stack, and other context; elements corresponding to the source language th",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:159303,Modifiability,variab,variables,159303,"Otherwise, the DWARF is ill-formed if SL is not a memory location; description in any of the target architecture specific address spaces. The resulting L is the *frame base* for the subprogram or entry point. *Typically, E will use the* ``DW_OP_call_frame_cfa`` *operation or be a; stack pointer register plus or minus some offset.*. *The frame base for a subprogram is typically an address relative to the; first unit of storage allocated for the subprogram's stack frame. The*; ``DW_AT_frame_base`` *attribute can be used in several ways:*. 1. *In subprograms that need location lists to locate local variables, the*; ``DW_AT_frame_base`` *can hold the needed location list, while all; variables' location descriptions can be simpler ones involving the frame; base.*. 2. *It can be used in resolving ""up-level"" addressing within; nested routines. (See also* ``DW_AT_static_link``\ *, below)*. *Some languages support nested subroutines. In such languages, it is; possible to reference the local variables of an outer subroutine from within; an inner subroutine. The* ``DW_AT_static_link`` *and* ``DW_AT_frame_base``; *attributes allow debuggers to support this same kind of referencing.*. 3. If a ``DW_TAG_subprogram`` or ``DW_TAG_entry_point`` debugger information; entry is lexically nested, it may have a ``DW_AT_static_link`` attribute,; whose value is a DWARF expression E. The result of the attribute is obtained by evaluating E with a context that; has a result kind of a location description, an unspecified object, the; compilation unit that contains E, an empty initial stack, and other context; elements corresponding to the source language thread of execution upon which; the user is focused, if any. The result of the evaluation is the location; description L of the *canonical frame address* (see; :ref:`amdgpu-dwarf-call-frame-information`) of the relevant call frame of; the subprogram instance that immediately lexically encloses the current call; frame's subprogram or entry point.",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:160911,Modifiability,variab,variable,160911,"tion upon which; the user is focused, if any. The result of the evaluation is the location; description L of the *canonical frame address* (see; :ref:`amdgpu-dwarf-call-frame-information`) of the relevant call frame of; the subprogram instance that immediately lexically encloses the current call; frame's subprogram or entry point. The DWARF is ill-formed if L is not comprised of one memory location; description for one of the target architecture specific address spaces. In the context of supporting nested subroutines, the DW_AT_frame_base; attribute value obeys the following constraints:. 1. It computes a value that does not change during the life of the; subprogram, and. 2. The computed value is unique among instances of the same subroutine. *For typical DW_AT_frame_base use, this means that a recursive subroutine's; stack frame must have non-zero size.*. *If a debugger is attempting to resolve an up-level reference to a variable,; it uses the nesting structure of DWARF to determine which subroutine is the; lexical parent and the* ``DW_AT_static_link`` *value to identify the; appropriate active frame of the parent. It can then attempt to find the; reference within the context of the parent.*. .. note::. The following new attributes are added. 4. For languages that are implemented using a SIMT execution model, a; ``DW_TAG_subprogram``, ``DW_TAG_inlined_subroutine``, or; ``DW_TAG_entry_point`` debugger information entry may have a; ``DW_AT_LLVM_lanes`` attribute whose value is an integer constant that is; the number of source language threads of execution per target architecture; thread. *For example, a compiler may map source language threads of execution onto; lanes of a target architecture thread using a SIMT execution model.*. It is the static number of source language threads of execution per target; architecture thread. It is not the dynamic number of source language threads; of execution with which the target architecture thread was initiated, for; example, due",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:172363,Modifiability,variab,variables,172363," call.*. 3. Each call site parameter entry may also have a ``DW_AT_call_parameter``; attribute which contains a reference to a ``DW_TAG_formal_parameter`` entry,; ``DW_AT_type attribute`` referencing the type of the parameter or; ``DW_AT_name`` attribute describing the parameter's name. *Examples using call site entries and related attributes are found in Appendix; D.15.*. .. _amdgpu-dwarf-lexical-block-entries:. A.3.5 Lexical Block Entries; ~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. note::. This section is the same as DWARF Version 5 section 3.5. A.4 Data Object and Object List Entries; ---------------------------------------. .. note::. This section provides changes to existing debugger information entry; attributes. These would be incorporated into the corresponding DWARF Version 5; chapter 4 sections. .. _amdgpu-dwarf-data-object-entries:. A.4.1 Data Object Entries; ~~~~~~~~~~~~~~~~~~~~~~~~~. Program variables, formal parameters and constants are represented by debugging; information entries with the tags ``DW_TAG_variable``,; ``DW_TAG_formal_parameter`` and ``DW_TAG_constant``, respectively. *The tag DW_TAG_constant is used for languages that have true named constants.*. The debugging information entry for a program variable, formal parameter or; constant may have the following attributes:. 1. A ``DW_AT_location`` attribute, whose value is a DWARF expression E that; describes the location of a variable or parameter at run-time. The result of the attribute is obtained by evaluating E with a context that; has a result kind of a location description, an unspecified object, the; compilation unit that contains E, an empty initial stack, and other context; elements corresponding to the source language thread of execution upon which; the user is focused, if any. The result of the evaluation is the location; description of the base of the data object. See :ref:`amdgpu-dwarf-control-flow-operations` for special evaluation rules; used by the ``DW_OP_call*`` operations. .. note::. D",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:172686,Modifiability,variab,variable,172686," attribute describing the parameter's name. *Examples using call site entries and related attributes are found in Appendix; D.15.*. .. _amdgpu-dwarf-lexical-block-entries:. A.3.5 Lexical Block Entries; ~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. note::. This section is the same as DWARF Version 5 section 3.5. A.4 Data Object and Object List Entries; ---------------------------------------. .. note::. This section provides changes to existing debugger information entry; attributes. These would be incorporated into the corresponding DWARF Version 5; chapter 4 sections. .. _amdgpu-dwarf-data-object-entries:. A.4.1 Data Object Entries; ~~~~~~~~~~~~~~~~~~~~~~~~~. Program variables, formal parameters and constants are represented by debugging; information entries with the tags ``DW_TAG_variable``,; ``DW_TAG_formal_parameter`` and ``DW_TAG_constant``, respectively. *The tag DW_TAG_constant is used for languages that have true named constants.*. The debugging information entry for a program variable, formal parameter or; constant may have the following attributes:. 1. A ``DW_AT_location`` attribute, whose value is a DWARF expression E that; describes the location of a variable or parameter at run-time. The result of the attribute is obtained by evaluating E with a context that; has a result kind of a location description, an unspecified object, the; compilation unit that contains E, an empty initial stack, and other context; elements corresponding to the source language thread of execution upon which; the user is focused, if any. The result of the evaluation is the location; description of the base of the data object. See :ref:`amdgpu-dwarf-control-flow-operations` for special evaluation rules; used by the ``DW_OP_call*`` operations. .. note::. Delete the description of how the ``DW_OP_call*`` operations evaluate a; ``DW_AT_location`` attribute as that is now described in the operations. .. note::. See the discussion about the ``DW_AT_location`` attribute in the; ``DW_OP_call*`` operat",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:172867,Modifiability,variab,variable,172867,".. _amdgpu-dwarf-lexical-block-entries:. A.3.5 Lexical Block Entries; ~~~~~~~~~~~~~~~~~~~~~~~~~~~. .. note::. This section is the same as DWARF Version 5 section 3.5. A.4 Data Object and Object List Entries; ---------------------------------------. .. note::. This section provides changes to existing debugger information entry; attributes. These would be incorporated into the corresponding DWARF Version 5; chapter 4 sections. .. _amdgpu-dwarf-data-object-entries:. A.4.1 Data Object Entries; ~~~~~~~~~~~~~~~~~~~~~~~~~. Program variables, formal parameters and constants are represented by debugging; information entries with the tags ``DW_TAG_variable``,; ``DW_TAG_formal_parameter`` and ``DW_TAG_constant``, respectively. *The tag DW_TAG_constant is used for languages that have true named constants.*. The debugging information entry for a program variable, formal parameter or; constant may have the following attributes:. 1. A ``DW_AT_location`` attribute, whose value is a DWARF expression E that; describes the location of a variable or parameter at run-time. The result of the attribute is obtained by evaluating E with a context that; has a result kind of a location description, an unspecified object, the; compilation unit that contains E, an empty initial stack, and other context; elements corresponding to the source language thread of execution upon which; the user is focused, if any. The result of the evaluation is the location; description of the base of the data object. See :ref:`amdgpu-dwarf-control-flow-operations` for special evaluation rules; used by the ``DW_OP_call*`` operations. .. note::. Delete the description of how the ``DW_OP_call*`` operations evaluate a; ``DW_AT_location`` attribute as that is now described in the operations. .. note::. See the discussion about the ``DW_AT_location`` attribute in the; ``DW_OP_call*`` operation. Having each attribute only have a single; purpose and single execution semantics seems desirable. It makes it easier; for the co",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:174773,Modifiability,variab,variable,174773,"purpose and single execution semantics seems desirable. It makes it easier; for the consumer that no longer have to track the context. It makes it; easier for the producer as it can rely on a single semantics for each; attribute. For that reason, limiting the ``DW_AT_location`` attribute to only; supporting evaluating the location description of an object, and using a; different attribute and encoding class for the evaluation of DWARF; expression *procedures* on the same operation expression stack seems; desirable. 2. ``DW_AT_const_value``. .. note::. Could deprecate using the ``DW_AT_const_value`` attribute for; ``DW_TAG_variable`` or ``DW_TAG_formal_parameter`` debugger information; entries that have been optimized to a constant. Instead,; ``DW_AT_location`` could be used with a DWARF expression that produces an; implicit location description now that any location description can be; used within a DWARF expression. This allows the ``DW_OP_call*`` operations; to be used to push the location description of any variable regardless of; how it is optimized. 3. ``DW_AT_LLVM_memory_space``. A ``DW_AT_memory_space`` attribute with a constant value representing a source; language specific DWARF memory space (see 2.14 ""Memory Spaces""). If omitted,; defaults to ``DW_MSPACE_none``. A.4.2 Common Block Entries; ~~~~~~~~~~~~~~~~~~~~~~~~~~. A common block entry also has a ``DW_AT_location`` attribute whose value is a; DWARF expression E that describes the location of the common block at run-time.; The result of the attribute is obtained by evaluating E with a context that has; a result kind of a location description, an unspecified object, the compilation; unit that contains E, an empty initial stack, and other context elements; corresponding to the source language thread of execution upon which the user is; focused, if any. The result of the evaluation is the location description of the; base of the common block. See :ref:`amdgpu-dwarf-control-flow-operations` for; special evalu",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:179232,Modifiability,extend,extended,179232,"n; entry D in the current compilation unit for an integral base type matching the; address size of AS. An object P having the given pointer or reference type are; dereferenced as if the ``DW_OP_push_object_address; DW_OP_deref_type DR;; DW_OP_constu AS; DW_OP_form_aspace_address`` operation expression was evaluated; with the current context except: the result kind is location description; the; initial stack is empty; and the object is the location description of P. .. note::. What if the current context does not have a current target architecture; defined?. .. note::. With the expanded support for DWARF address spaces, it may be worth examining; if they can be used for what was formerly supported by DWARF 5 segments. That; would include specifying the address space of all code addresses (compilation; units, subprograms, subprogram entries, labels, subprogram types, etc.).; Either the code address attributes could be extended to allow a exprloc form; (so that ``DW_OP_form_aspace_address`` can be used) or the; ``DW_AT_LLVM_address_space`` attribute be allowed on all DIEs that allow; ``DW_AT_segment``. A.5.7 Structure, Union, Class and Interface Type Entries; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~. A.5.7.3 Derived or Extended Structures, Classes and Interfaces; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++. 1. For a ``DW_AT_data_member_location`` attribute there are two cases:. 1. If the attribute is an integer constant B, it provides the offset in; bytes from the beginning of the containing entity. The result of the attribute is obtained by evaluating a; ``DW_OP_LLVM_offset B`` operation with an initial stack comprising the; location description of the beginning of the containing entity. The; result of the evaluation is the location description of the base of the; member entry. *If the beginning of the containing entity is not byte aligned, then the; beginning of the member entry has the same bit displacement within a; byte.*. 2. Oth",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:186116,Modifiability,extend,extended,186116,"fferent; program location ranges. But if supporting for some then should be for; all. It seems odd this attribute is not the same as; ``DW_AT_data_member_location`` in having an initial stack with the; location description of the object since the expression has to need it. A.6 Other Debugging Information; -------------------------------. .. note::. This section provides changes to existing debugger information entry; attributes. These would be incorporated into the corresponding DWARF Version 5; chapter 6 sections. A.6.1 Accelerated Access; ~~~~~~~~~~~~~~~~~~~~~~~~. .. _amdgpu-dwarf-lookup-by-name:. A.6.1.1 Lookup By Name; ++++++++++++++++++++++. A.6.1.1.1 Contents of the Name Index; ####################################. .. note::. The following provides changes to DWARF Version 5 section 6.1.1.1. The rule for debugger information entries included in the name index in the; optional ``.debug_names`` section is extended to also include named; ``DW_TAG_variable`` debugging information entries with a ``DW_AT_location``; attribute that includes a ``DW_OP_LLVM_form_aspace_address`` operation. The name index must contain an entry for each debugging information entry that; defines a named subprogram, label, variable, type, or namespace, subject to the; following rules:. * ``DW_TAG_variable`` debugging information entries with a ``DW_AT_location``; attribute that includes a ``DW_OP_addr``, ``DW_OP_LLVM_form_aspace_address``,; or ``DW_OP_form_tls_address`` operation are included; otherwise, they are; excluded. A.6.1.1.4 Data Representation of the Name Index; ###############################################. .. _amdgpu-dwarf-name-index-section-header:. A.6.1.1.4.1 Section Header; ^^^^^^^^^^^^^^^^^^^^^^^^^^. .. note::. The following provides an addition to DWARF Version 5 section 6.1.1.4.1 item; 14 ``augmentation_string``. A null-terminated UTF-8 vendor specific augmentation string, which provides; additional information about the contents of this index. If provided, the; recomme",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:186412,Modifiability,variab,variable,186412,"with the; location description of the object since the expression has to need it. A.6 Other Debugging Information; -------------------------------. .. note::. This section provides changes to existing debugger information entry; attributes. These would be incorporated into the corresponding DWARF Version 5; chapter 6 sections. A.6.1 Accelerated Access; ~~~~~~~~~~~~~~~~~~~~~~~~. .. _amdgpu-dwarf-lookup-by-name:. A.6.1.1 Lookup By Name; ++++++++++++++++++++++. A.6.1.1.1 Contents of the Name Index; ####################################. .. note::. The following provides changes to DWARF Version 5 section 6.1.1.1. The rule for debugger information entries included in the name index in the; optional ``.debug_names`` section is extended to also include named; ``DW_TAG_variable`` debugging information entries with a ``DW_AT_location``; attribute that includes a ``DW_OP_LLVM_form_aspace_address`` operation. The name index must contain an entry for each debugging information entry that; defines a named subprogram, label, variable, type, or namespace, subject to the; following rules:. * ``DW_TAG_variable`` debugging information entries with a ``DW_AT_location``; attribute that includes a ``DW_OP_addr``, ``DW_OP_LLVM_form_aspace_address``,; or ``DW_OP_form_tls_address`` operation are included; otherwise, they are; excluded. A.6.1.1.4 Data Representation of the Name Index; ###############################################. .. _amdgpu-dwarf-name-index-section-header:. A.6.1.1.4.1 Section Header; ^^^^^^^^^^^^^^^^^^^^^^^^^^. .. note::. The following provides an addition to DWARF Version 5 section 6.1.1.4.1 item; 14 ``augmentation_string``. A null-terminated UTF-8 vendor specific augmentation string, which provides; additional information about the contents of this index. If provided, the; recommended format for augmentation string is:. | ``[``\ *vendor*\ ``:v``\ *X*\ ``.``\ *Y*\ [\ ``:``\ *options*\ ]\ ``]``\ *. Where *vendor* is the producer, ``vX.Y`` specifies the major X and minor ",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:232820,Modifiability,variab,variable,232820,"upper bound of dimension i.; DW_OP_lit<n> ! sizeof(dim); DW_OP_mul; DW_OP_lit<n> ! offsetof(dim); DW_OP_plus; DW_OP_push_object_address; DW_OP_swap; DW_OP_offset; DW_OP_lit<n> ! offset of upperbound in dim; DW_OP_offset; DW_OP_deref); DW_AT_byte_stride(expression=; ! Looks up the byte stride of dimension i.; ...; ! (analogous to DW_AT_upper_bound); ); ----------------------------------------------------------------------------. .. note::. This example suggests that ``DW_AT_lower_bound`` and ``DW_AT_upper_bound``; evaluate an exprloc with an initial stack containing the rank value. The; attribute definition should be updated to state this. D.2.6 Ada Example; +++++++++++++++++. Figure D.20: Ada example: DWARF description. .. code::; :number-lines:. ----------------------------------------------------------------------------; 11$: DW_TAG_variable; DW_AT_name(""M""); DW_AT_type(reference to INTEGER); 12$: DW_TAG_array_type; ! No name, default (Ada) order, default stride; DW_AT_type(reference to INTEGER); 13$: DW_TAG_subrange_type; DW_AT_type(reference to INTEGER); DW_AT_lower_bound(constant 1); DW_AT_upper_bound(reference to variable M at 11$); 14$: DW_TAG_variable; DW_AT_name(""VEC1""); DW_AT_type(reference to array type at 12$); ...; 21$: DW_TAG_subrange_type; DW_AT_name(""TEENY""); DW_AT_type(reference to INTEGER); DW_AT_lower_bound(constant 1); DW_AT_upper_bound(constant 100); ...; 26$: DW_TAG_structure_type; DW_AT_name(""REC2""); 27$: DW_TAG_member; DW_AT_name(""N""); DW_AT_type(reference to subtype TEENY at 21$); DW_AT_data_member_location(constant 0); 28$: DW_TAG_array_type; ! No name, default (Ada) order, default stride; ! Default data location; DW_AT_type(reference to INTEGER); 29$: DW_TAG_subrange_type; DW_AT_type(reference to subrange TEENY at 21$); DW_AT_lower_bound(constant 1); DW_AT_upper_bound(reference to member N at 27$); 30$: DW_TAG_member; DW_AT_name(""VEC2""); DW_AT_type(reference to array ""subtype"" at 28$); DW_AT_data_member_location(machine=; DW_OP_lit<n> ! wh",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:4203,Performance,optimiz,optimization,4203,"to evolve through collaboration with many individuals and; active prototyping within the GDB debugger and LLVM compiler. Input has also; been very much appreciated from the developers working on the Perforce TotalView; HPC Debugger and GCC compiler. The inputs provided and insights gained so far have been incorporated into this; current version. The plan is to participate in upstreaming the work and; addressing any feedback. If there is general interest then some or all of these; extensions could be submitted as future DWARF standard proposals. The general principles in designing the extensions have been:. 1. Be backwards compatible with the DWARF Version 5 [:ref:`DWARF; <amdgpu-dwarf-DWARF>`] standard. 2. Be vendor and architecture neutral. They are intended to apply to other; heterogeneous hardware devices including GPUs, DSPs, FPGAs, and other; specialized hardware. These collectively include similar characteristics and; requirements as AMDGPU devices. 3. Provide improved optimization support for non-GPU code. For example, some; extensions apply to traditional CPU hardware that supports large vector; registers. Compilers can map source languages, and source language; extensions, that describe large scale parallel execution, onto the lanes of; the vector registers. This is common in programming languages used in ML and; HPC. 4. Fully define well-formed DWARF in a consistent style based on the DWARF; Version 5 specification. It is possible that some of the generalizations may also benefit other DWARF; issues that have been raised. The remainder of this section enumerates the extensions and provides motivation; for each in terms of heterogeneous debugging. .. _amdgpu-dwarf-allow-location-description-on-the-dwarf-evaluation-stack:. 2.1 Allow Location Description on the DWARF Expression Stack; ------------------------------------------------------------. DWARF Version 5 does not allow location descriptions to be entries on the DWARF; expression stack. They can only be",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:6911,Performance,optimiz,optimized,6911,"ation description. This can be extended to allow a default address space; memory location description to be implicitly converted back to its address; value. This allows all DWARF Version 5 expressions to retain their same meaning,; while enabling the ability to explicitly create memory location descriptions in; non-default address spaces and generalizing the power of composite location; descriptions to any kind of location description. For those familiar with the definition of location descriptions in DWARF Version; 5, the definitions in these extensions are presented differently, but does in; fact define the same concept with the same fundamental semantics. However, it; does so in a way that allows the concept to extend to support address spaces,; bit addressing, the ability for composite location descriptions to be composed; of any kind of location description, and the ability to support objects located; at multiple places. Collectively these changes expand the set of architectures; that can be supported and improves support for optimized code. Several approaches were considered, and the one presented, together with the; extensions it enables, appears to be the simplest and cleanest one that offers; the greatest improvement of DWARF's ability to support debugging optimized GPU; and non-GPU code. Examining the GDB debugger and LLVM compiler, it appears only; to require modest changes as they both already have to support general use of; location descriptions. It is anticipated that will also be the case for other; debuggers and compilers. GDB has been modified to evaluate DWARF Version 5 expressions with location; descriptions as stack entries and with implicit conversions. All GDB tests have; passed, except one that turned out to be an invalid test case by DWARF Version 5; rules. The code in GDB actually became simpler as all evaluation is done on a; single stack and there was no longer a need to maintain a separate structure for; the location description results. T",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:7150,Performance,optimiz,optimized,7150,"xpressions to retain their same meaning,; while enabling the ability to explicitly create memory location descriptions in; non-default address spaces and generalizing the power of composite location; descriptions to any kind of location description. For those familiar with the definition of location descriptions in DWARF Version; 5, the definitions in these extensions are presented differently, but does in; fact define the same concept with the same fundamental semantics. However, it; does so in a way that allows the concept to extend to support address spaces,; bit addressing, the ability for composite location descriptions to be composed; of any kind of location description, and the ability to support objects located; at multiple places. Collectively these changes expand the set of architectures; that can be supported and improves support for optimized code. Several approaches were considered, and the one presented, together with the; extensions it enables, appears to be the simplest and cleanest one that offers; the greatest improvement of DWARF's ability to support debugging optimized GPU; and non-GPU code. Examining the GDB debugger and LLVM compiler, it appears only; to require modest changes as they both already have to support general use of; location descriptions. It is anticipated that will also be the case for other; debuggers and compilers. GDB has been modified to evaluate DWARF Version 5 expressions with location; descriptions as stack entries and with implicit conversions. All GDB tests have; passed, except one that turned out to be an invalid test case by DWARF Version 5; rules. The code in GDB actually became simpler as all evaluation is done on a; single stack and there was no longer a need to maintain a separate structure for; the location description results. This gives confidence in backwards; compatibility. See :ref:`amdgpu-dwarf-expressions` and nested sections. This extension is separately described at *Allow Location Descriptions on the; DWA",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:8446,Performance,optimiz,optimized,8446,"xpressions with location; descriptions as stack entries and with implicit conversions. All GDB tests have; passed, except one that turned out to be an invalid test case by DWARF Version 5; rules. The code in GDB actually became simpler as all evaluation is done on a; single stack and there was no longer a need to maintain a separate structure for; the location description results. This gives confidence in backwards; compatibility. See :ref:`amdgpu-dwarf-expressions` and nested sections. This extension is separately described at *Allow Location Descriptions on the; DWARF Expression Stack* [:ref:`AMDGPU-DWARF-LOC; <amdgpu-dwarf-AMDGPU-DWARF-LOC>`]. 2.2 Generalize CFI to Allow Any Location Description Kind; ---------------------------------------------------------. CFI describes restoring callee saved registers that are spilled. Currently CFI; only allows a location description that is a register, memory address, or; implicit location description. AMDGPU optimized code may spill scalar registers; into portions of vector registers. This requires extending CFI to allow any; location description kind to be supported. See :ref:`amdgpu-dwarf-call-frame-information`. 2.3 Generalize DWARF Operation Expressions to Support Multiple Places; ---------------------------------------------------------------------. In DWARF Version 5 a location description is defined as a single location; description or a location list. A location list is defined as either; effectively an undefined location description or as one or more single; location descriptions to describe an object with multiple places. With; :ref:`amdgpu-dwarf-allow-location-description-on-the-dwarf-evaluation-stack`,; the ``DW_OP_push_object_address`` and ``DW_OP_call*`` operations can put a; location description on the stack. Furthermore, debugger information entry; attributes such as ``DW_AT_data_member_location``, ``DW_AT_use_location``, and; ``DW_AT_vtable_elem_location`` are defined as pushing a location description on; t",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:13952,Performance,perform,perform,13952,"itrary location description (such as a vector register); is required. The offset operations provide this ability since they can be used; to compute a location description on the stack. It could be possible to define ``DW_OP_plus``, ``DW_OP_plus_uconst``, and; ``DW_OP_minus`` to operate on location descriptions to avoid needing; ``DW_OP_LLVM_offset`` and ``DW_OP_LLVM_offset_uconst``. However, this is not; proposed since currently the arithmetic operations are defined to require values; of the same base type and produces a result with the same base type. Allowing; these operations to act on location descriptions would permit the first operand; to be a location description and the second operand to be an integral value; type, or vice versa, and return a location description. This complicates the; rules for implicit conversions between default address space memory location; descriptions and generic base type values. Currently the rules would convert; such a location description to the memory address value and then perform two's; compliment wrap around arithmetic. If the result was used as a location; description, it would be implicitly converted back to a default address space; memory location description. This is different to the overflow rules on location; descriptions. To allow control, an operation that converts a memory location; description to an address integral type value would be required. Keeping a; separation of location description operations and arithmetic operations avoids; this semantic complexity. See ``DW_OP_LLVM_offset``, ``DW_OP_LLVM_offset_uconst``, and; ``DW_OP_LLVM_bit_offset`` in; :ref:`amdgpu-dwarf-general-location-description-operations`. 2.5 Generalize Creation of Undefined Location Descriptions; ----------------------------------------------------------. Current DWARF uses an empty expression to indicate an undefined location; description. Since; :ref:`amdgpu-dwarf-allow-location-description-on-the-dwarf-evaluation-stack`; allows location desc",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:16262,Performance,optimiz,optimize,16262,"t possible to specify that a particular one of the input; location descriptions is undefined. See the ``DW_OP_LLVM_undefined`` operation in; :ref:`amdgpu-dwarf-undefined-location-description-operations`. 2.6 Generalize Creation of Composite Location Descriptions; ----------------------------------------------------------. To allow composition of composite location descriptions, an explicit operation; that indicates the end of the definition of a composite location description is; required. This can be implied if the end of a DWARF expression is reached,; allowing current DWARF expressions to remain legal. See ``DW_OP_LLVM_piece_end`` in; :ref:`amdgpu-dwarf-composite-location-description-operations`. 2.7 Generalize DWARF Base Objects to Allow Any Location Description Kind; ------------------------------------------------------------------------. The number of registers and the cost of memory operations is much higher for; AMDGPU than a typical CPU. The compiler attempts to optimize whole variables and; arrays into registers. Currently DWARF only allows ``DW_OP_push_object_address`` and related operations; to work with a global memory location. To support AMDGPU optimized code it is; required to generalize DWARF to allow any location description to be used. This; allows registers, or composite location descriptions that may be a mixture of; memory, registers, or even implicit values. See ``DW_OP_push_object_address`` in; :ref:`amdgpu-dwarf-general-location-description-operations`. 2.8 General Support for Address Spaces; --------------------------------------. AMDGPU needs to be able to describe addresses that are in different kinds of; memory. Optimized code may need to describe a variable that resides in pieces; that are in different kinds of storage which may include parts of registers,; memory that is in a mixture of memory kinds, implicit values, or be undefined. DWARF has the concept of segment addresses. However, the segment cannot be; specified within a DWARF e",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:16454,Performance,optimiz,optimized,16454,"e Creation of Composite Location Descriptions; ----------------------------------------------------------. To allow composition of composite location descriptions, an explicit operation; that indicates the end of the definition of a composite location description is; required. This can be implied if the end of a DWARF expression is reached,; allowing current DWARF expressions to remain legal. See ``DW_OP_LLVM_piece_end`` in; :ref:`amdgpu-dwarf-composite-location-description-operations`. 2.7 Generalize DWARF Base Objects to Allow Any Location Description Kind; ------------------------------------------------------------------------. The number of registers and the cost of memory operations is much higher for; AMDGPU than a typical CPU. The compiler attempts to optimize whole variables and; arrays into registers. Currently DWARF only allows ``DW_OP_push_object_address`` and related operations; to work with a global memory location. To support AMDGPU optimized code it is; required to generalize DWARF to allow any location description to be used. This; allows registers, or composite location descriptions that may be a mixture of; memory, registers, or even implicit values. See ``DW_OP_push_object_address`` in; :ref:`amdgpu-dwarf-general-location-description-operations`. 2.8 General Support for Address Spaces; --------------------------------------. AMDGPU needs to be able to describe addresses that are in different kinds of; memory. Optimized code may need to describe a variable that resides in pieces; that are in different kinds of storage which may include parts of registers,; memory that is in a mixture of memory kinds, implicit values, or be undefined. DWARF has the concept of segment addresses. However, the segment cannot be; specified within a DWARF expression, which is only able to specify the offset; portion of a segment address. The segment index is only provided by the entity; that specifies the DWARF expression. Therefore, the segment index is a property; that",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:24667,Performance,optimiz,optimized,24667,"iler to generate DWARF for languages that; map a thread to the complete wavefront. It also allows more efficient DWARF to; be generated to describe the CFI as only a single expression is required for; the whole vector register, rather than a separate expression for each lane's; dword of the vector register. It also allows the compiler to produce DWARF; that indexes the vector register if it spills scalar registers into portions; of a vector register. Since DWARF stack value entries have a base type and AMDGPU registers are a; vector of dwords, the ability to specify that a base type is a vector is; required. See ``DW_AT_LLVM_vector_size`` in :ref:`amdgpu-dwarf-base-type-entries`. .. _amdgpu-dwarf-operation-to-create-vector-composite-location-descriptions:. 2.10 DWARF Operations to Create Vector Composite Location Descriptions; ----------------------------------------------------------------------. AMDGPU optimized code may spill vector registers to non-global address space; memory, and this spilling may be done only for SIMT lanes that are active on; entry to the subprogram. To support this the CFI rule for the partially spilled; register needs to use an expression that uses the EXEC register as a bit mask to; select between the register (for inactive lanes) and the stack spill location; (for active lanes that are spilled). This needs to evaluate to a location; description, and not a value, as a debugger needs to change the value if the; user assigns to the variable. Another usage is to create an expression that evaluates to provide a vector of; logical PCs for active and inactive lanes in a SIMT execution model. Again the; EXEC register is used to select between active and inactive PC values. In order; to represent a vector of PC values, a way to create a composite location; description that is a vector of a single location is used. It may be possible to use existing DWARF to incrementally build the composite; location description, possibly using the DWARF operation",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:29440,Performance,perform,perform,29440,"he compiler to communicate how many source; language threads of execution are mapped to a target architecture thread's SIMT; lanes. See ``DW_AT_LLVM_lanes`` in :ref:`amdgpu-dwarf-low-level-information`. .. _amdgpu-dwarf-support-for-divergent-control-flow-of-simt-hardware:. 2.13 Support for Divergent Control Flow of SIMT Hardware; --------------------------------------------------------. If the source language is mapped onto the AMDGPU wavefronts in a SIMT manner the; compiler can use the AMDGPU execution mask register to control which lanes are; active. To describe the conceptual location of non-active lanes requires an; attribute that has an expression that computes the source location PC for each; lane. For efficiency, the expression calculates the source location the wavefront as a; whole. This can be done using the ``DW_OP_LLVM_select_bit_piece`` (see; :ref:`amdgpu-dwarf-operation-to-create-vector-composite-location-descriptions`); operation. The AMDGPU may update the execution mask to perform whole wavefront operations.; Therefore, there is a need for an attribute that computes the current active; lane mask. This can have an expression that may evaluate to the SIMT active lane; mask register or to a saved mask when in whole wavefront execution mode. An example that uses these attributes is referenced in the; :ref:`amdgpu-dwarf-further-examples` appendix. See ``DW_AT_LLVM_lane_pc`` and ``DW_AT_LLVM_active_lane`` in; :ref:`amdgpu-dwarf-composite-location-description-operations`. 2.14 Define Source Language Memory Classes; -------------------------------------------. AMDGPU supports languages, such as OpenCL [:ref:`OpenCL <amdgpu-dwarf-OpenCL>`],; that define source language memory classes. Support is added to define language; specific memory spaces so they can be used in a consistent way by consumers. Support for using memory spaces in defining source language types and data; object allocation is also added. See :ref:`amdgpu-dwarf-memory-spaces`. 2.15 Define Augm",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:32189,Performance,optimiz,optimization,32189,"lookup by name table, and in the CFI Common Information Entry; (CIE). See :ref:`amdgpu-dwarf-full-and-partial-compilation-unit-entries`,; :ref:`amdgpu-dwarf-name-index-section-header`, and; :ref:`amdgpu-dwarf-structure_of-call-frame-information`. 2.16 Support Embedding Source Text for Online Compilation; ---------------------------------------------------------. AMDGPU supports programming languages that include online compilation where the; source text may be created at runtime. For example, the OpenCL and HIP language; runtimes support online compilation. To support is, a way to embed the source; text in the debug information is provided. See :ref:`amdgpu-dwarf-line-number-information`. 2.17 Allow MD5 Checksums to be Optionally Present; -------------------------------------------------. In DWARF Version 5 the file timestamp and file size can be optional, but if the; MD5 checksum is present it must be valid for all files. This is a problem if; using link time optimization to combine compilation units where some have MD5; checksums and some do not. Therefore, sSupport to allow MD5 checksums to be; optionally present in the line table is added. See :ref:`amdgpu-dwarf-line-number-information`. 2.18 Add the HIP Programing Language; ------------------------------------. The HIP programming language [:ref:`HIP <amdgpu-dwarf-HIP>`], which is supported; by the AMDGPU, is added. See :ref:`amdgpu-dwarf-language-names-table`. 2.19 Support for Source Language Optimizations that Result in Concurrent Iteration Execution; --------------------------------------------------------------------------------------------. A compiler can perform loop optimizations that result in the generated code; executing multiple iterations concurrently. For example, software pipelining; schedules multiple iterations in an interleaved fashion to allow the; instructions of one iteration to hide the latencies of the instructions of; another iteration. Another example is vectorization that can exploit SI",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:32857,Performance,perform,perform,32857,"ormation`. 2.17 Allow MD5 Checksums to be Optionally Present; -------------------------------------------------. In DWARF Version 5 the file timestamp and file size can be optional, but if the; MD5 checksum is present it must be valid for all files. This is a problem if; using link time optimization to combine compilation units where some have MD5; checksums and some do not. Therefore, sSupport to allow MD5 checksums to be; optionally present in the line table is added. See :ref:`amdgpu-dwarf-line-number-information`. 2.18 Add the HIP Programing Language; ------------------------------------. The HIP programming language [:ref:`HIP <amdgpu-dwarf-HIP>`], which is supported; by the AMDGPU, is added. See :ref:`amdgpu-dwarf-language-names-table`. 2.19 Support for Source Language Optimizations that Result in Concurrent Iteration Execution; --------------------------------------------------------------------------------------------. A compiler can perform loop optimizations that result in the generated code; executing multiple iterations concurrently. For example, software pipelining; schedules multiple iterations in an interleaved fashion to allow the; instructions of one iteration to hide the latencies of the instructions of; another iteration. Another example is vectorization that can exploit SIMD; hardware to allow a single instruction to execute multiple iterations using; vector registers. Note that although this is similar to SIMT execution, the way a client debugger; uses the information is fundamentally different. In SIMT execution the debugger; needs to present the concurrent execution as distinct source language threads; that the user can list and switch focus between. With iteration concurrency; optimizations, such as software pipelining and vectorized SIMD, the debugger; must not present the concurrency as distinct source language threads. Instead,; it must inform the user that multiple loop iterations are executing in parallel; and allow the user to select bet",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst:32870,Performance,optimiz,optimizations,32870,"ormation`. 2.17 Allow MD5 Checksums to be Optionally Present; -------------------------------------------------. In DWARF Version 5 the file timestamp and file size can be optional, but if the; MD5 checksum is present it must be valid for all files. This is a problem if; using link time optimization to combine compilation units where some have MD5; checksums and some do not. Therefore, sSupport to allow MD5 checksums to be; optionally present in the line table is added. See :ref:`amdgpu-dwarf-line-number-information`. 2.18 Add the HIP Programing Language; ------------------------------------. The HIP programming language [:ref:`HIP <amdgpu-dwarf-HIP>`], which is supported; by the AMDGPU, is added. See :ref:`amdgpu-dwarf-language-names-table`. 2.19 Support for Source Language Optimizations that Result in Concurrent Iteration Execution; --------------------------------------------------------------------------------------------. A compiler can perform loop optimizations that result in the generated code; executing multiple iterations concurrently. For example, software pipelining; schedules multiple iterations in an interleaved fashion to allow the; instructions of one iteration to hide the latencies of the instructions of; another iteration. Another example is vectorization that can exploit SIMD; hardware to allow a single instruction to execute multiple iterations using; vector registers. Note that although this is similar to SIMT execution, the way a client debugger; uses the information is fundamentally different. In SIMT execution the debugger; needs to present the concurrent execution as distinct source language threads; that the user can list and switch focus between. With iteration concurrency; optimizations, such as software pipelining and vectorized SIMD, the debugger; must not present the concurrency as distinct source language threads. Instead,; it must inform the user that multiple loop iterations are executing in parallel; and allow the user to select bet",MatchSource.DOCS,interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/docs/AMDGPUDwarfExtensionsForHeterogeneousDebugging.rst
